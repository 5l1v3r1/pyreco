__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# packstack documentation build configuration file, created by
# sphinx-quickstart on Thu Nov 15 20:34:41 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

sys.path.append('..')
from packstack import version as packstackversion

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'packstack'
copyright = u'2012, Red Hat'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = packstackversion.version_string()
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'packstackdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'packstack.tex', u'packstack Documentation', u'Derek Higgins', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('packstack', 'packstack', u'install openstack', [u'Derek Higgins, Martin Magr, Sandro Mathys, Flavio Percoco, Alvaro Lopez Ortega'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'packstack', u'packstack Documentation',
   u'Derek Higgins', 'packstack', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = basedefs
# -*- coding: utf-8 -*-

"""
This module provides all the predefined variables.
"""

import os
import pwd
import sys
import datetime
import tempfile

from .utils import get_current_user


APP_NAME = "Installer"

FILE_YUM_VERSION_LOCK = "/etc/yum/pluginconf.d/versionlock.list"

PACKSTACK_VAR_DIR = "/var/tmp/packstack"
try:
    os.mkdir(PACKSTACK_VAR_DIR, 0700)
except OSError:
    # directory is already created, check ownership
    stat = os.stat(PACKSTACK_VAR_DIR)
    if stat.st_uid == 0 and os.getuid() != stat.st_uid:
        print ('%s is already created and owned by root. Please change '
               'ownership and try again.' % PACKSTACK_VAR_DIR)
        sys.exit(1)
finally:
    uid, gid = get_current_user()

    if uid != 0 and os.getuid() == 0:
        try:
            os.chown(PACKSTACK_VAR_DIR, uid, gid)
        except Exception, ex:
            print ('Unable to change owner of %s. Please fix ownership '
                   'manually and try again.' % PACKSTACK_VAR_DIR)
            sys.exit(1)

_tmpdirprefix = datetime.datetime.now().strftime('%Y%m%d-%H%M%S-')
VAR_DIR = tempfile.mkdtemp(prefix=_tmpdirprefix, dir=PACKSTACK_VAR_DIR)
DIR_LOG = VAR_DIR
PUPPET_MANIFEST_RELATIVE = "manifests"
PUPPET_MANIFEST_DIR = os.path.join(VAR_DIR, PUPPET_MANIFEST_RELATIVE)

FILE_INSTALLER_LOG = "setup.log"

DIR_PROJECT_DIR = os.environ.get('INSTALLER_PROJECT_DIR', os.path.join(os.getcwd(), 'packstack'))
DIR_PLUGINS = os.path.join(DIR_PROJECT_DIR, "plugins")
DIR_MODULES = os.path.join(DIR_PROJECT_DIR, "modules")



EXEC_RPM = "rpm"
EXEC_SEMANAGE = "semanage"
EXEC_NSLOOKUP = "nslookup"
EXEC_CHKCONFIG = "chkconfig"
EXEC_SERVICE = "service"
EXEC_IP = "ip"

# space len size for color print
SPACE_LEN = 70

########NEW FILE########
__FILENAME__ = drones
# -*- coding: utf-8 -*-

import os
import stat
import uuid
import time
import logging
import tarfile
import tempfile

from .. import utils


class SshTarballTransferMixin(object):
    """
    Transfers resources and recipes by packing them to tar.gz and
    copying it via ssh.
    """
    def _transfer(self, pack_path, pack_dest, res_dir):
        node = self.node
        args = locals()
        # copy and extract tarball
        script = utils.ScriptRunner()
        script.append("scp %(pack_path)s root@%(node)s:%(pack_dest)s"
                      % args)
        script.append("ssh -o StrictHostKeyChecking=no "
                        "-o UserKnownHostsFile=/dev/null root@%(node)s "
                        "tar -C %(res_dir)s -xpzf %(pack_dest)s" % args)
        try:
            script.execute()
        except ScriptRuntimeError as ex:
            # TO-DO: change to appropriate exception
            raise RuntimeError('Failed to copy resources to node %s. '
                               'Reason: %s' % (node, ex))

    def _pack_resources(self):
        randpart = uuid.uuid4().hex[:8]
        pack_path = os.path.join(self.local_tmpdir,
                                 'res-%s.tar.gz' % randpart)
        pack = tarfile.open(pack_path, mode='w:gz')
        os.chmod(pack_path, stat.S_IRUSR | stat.S_IWUSR)
        for path, dest in self._resources:
            if not dest:
                dest = os.path.basename(path)
            pack.add(path,
                     arcname=os.path.join(dest, os.path.basename(path)))
        pack.close()
        return pack_path

    def _copy_resources(self):
        pack_path = self._pack_resources()
        pack_dest = os.path.join(self.remote_tmpdir,
                                 os.path.basename(pack_path))
        self._transfer(pack_path, pack_dest, self.resource_dir)

    def _pack_recipes(self):
        randpart = uuid.uuid4().hex[:8]
        pack_path = os.path.join(self.local_tmpdir,
                                 'rec-%s.tar.gz' % randpart)
        pack = tarfile.open(pack_path, mode='w:gz')
        os.chmod(pack_path, stat.S_IRUSR | stat.S_IWUSR)
        if self.recipe_dir.startswith(self.resource_dir):
            dest = self.recipe_dir[len(self.resource_dir):].lstrip('/')
        else:
            dest = ''
        for marker, recipes in self._recipes.iteritems():
            for path in recipes:
                _dest = os.path.join(dest, os.path.basename(path))
                pack.add(path, arcname=_dest)
        pack.close()
        return pack_path

    def _copy_recipes(self):
        pack_path = self._pack_recipes()
        pack_dest = os.path.join(self.remote_tmpdir,
                                 os.path.basename(pack_path))
        if self.recipe_dir.startswith(self.resource_dir):
            extr_dest = self.resource_dir
        else:
            extr_dest = self.recipe_dir
        self._transfer(pack_path, pack_dest, extr_dest)


class DroneObserver(object):
    """
    Base class for listening messages from drones.
    """
    def applying(self, drone, recipe):
        """
        Drone is calling this method when it starts applying recipe.
        """
        # subclass must implement this method
        raise NotImplementedError()

    def checking(self, drone, recipe):
        """
        Drone is calling this method when it starts checking if recipe
        has been applied.
        """
        # subclass must implement this method
        raise NotImplementedError()

    def finished(self, drone, recipe):
        """
        Drone is calling this method when it's finished with recipe
        application.
        """
        # subclass must implement this method
        raise NotImplementedError()


class Drone(object):
    """
    Base class used to apply installation recipes to nodes.
    """
    def __init__(self, node, resource_dir=None, recipe_dir=None,
                 local_tmpdir=None, remote_tmpdir=None):
        self._recipes = utils.SortedDict()
        self._resources = []
        self._applied = set()
        self._running = set()
        self._observer = None

        # remote host IP or hostname
        self.node = node
        # working directories on remote host
        self.resource_dir = resource_dir or \
                            '/tmp/drone%s' % uuid.uuid4().hex[:8]
        self.recipe_dir = recipe_dir or \
                          os.path.join(self.resource_dir, 'recipes')
        # temporary directories
        self.remote_tmpdir = remote_tmpdir or \
                             '/tmp/drone%s' % uuid.uuid4().hex[:8]
        self.local_tmpdir = local_tmpdir or \
                            tempfile.mkdtemp(prefix='drone')

    def init_node(self):
        """
        Initializes node for manipulation.
        """
        created = []
        server = utils.ScriptRunner(self.node)
        for i in (self.resource_dir, self.recipe_dir,
                  self.remote_tmpdir):
            server.append('mkdir -p %s' % os.path.dirname(i))
            server.append('mkdir --mode 0700 %s' % i)
            created.append('%s:%s' % (self.node, i))
        server.execute()

        # TO-DO: complete logger name when logging will be setup correctly
        logger = logging.getLogger()
        logger.debug('Created directories: %s' % ','.join(created))

    @property
    def recipes(self):
        for i in self._recipes.itervalues():
            for y in i:
                yield y

    @property
    def resources(self):
        for i in self._resources:
            yield i[0]

    def add_recipe(self, path, marker=None):
        """
        Registers recipe for application on node. Recipes will be
        applied in order they where added to drone. Multiple recipes can
        be applied in paralel if they have same marker.
        """
        marker = marker or uuid.uuid4().hex[:8]
        self._recipes.setdefault(marker, []).append(path)

    def add_resource(self, path, destination=None):
        """
        Registers resource. Destination will be relative from resource
        directory on node.
        """
        dest = destination or ''
        self._resources.append((path, dest))

    def _copy_resources(self):
        """
        Copies all local files registered in self._resources to their
        appropriate destination on self.node. If tmpdir is given this
        method can operate only in this directory.
        """
        # subclass must implement this method
        raise NotImplementedError()

    def _copy_recipes(self):
        """
        Copies all local files registered in self._recipes to their
        appropriate destination on self.node. If tmpdir is given this
        method can operate only in this directory.
        """
        # subclass must implement this method
        raise NotImplementedError()

    def prepare_node(self):
        """
        Copies all local resources and recipes to self.node.
        """
        # TO-DO: complete logger name when logging will be setup correctly
        logger = logging.getLogger()
        logger.debug('Copying drone resources to node %s: %s'
                     % (self.node, self.resources))
        self._copy_resources()
        logger.debug('Copying drone recipes to node %s: %s'
                     % (self.node, [i[0] for i in self.recipes]))
        self._copy_recipes()

    def _apply(self, recipe):
        """
        Starts application of single recipe given as path to the recipe
        file in self.node. This method should not wait until recipe is
        applied.
        """
        # subclass must implement this method
        raise NotImplementedError()

    def _finished(self, recipe):
        """
        Returns True if given recipe is applied, otherwise returns False
        """
        # subclass must implement this method
        raise NotImplementedError()

    def _wait(self):
        """
        Waits until all started applications of recipes will be finished
        """
        while self._running:
            _run = list(self._running)
            for recipe in _run:
                if self._observer:
                    self._observer.checking(self, recipe)
                if self._finished(recipe):
                    self._applied.add(recipe)
                    self._running.remove(recipe)
                    if self._observer:
                        self._observer.finished(self, recipe)
                else:
                    time.sleep(3)
                    continue

    def set_observer(self, observer):
        """
        Registers an observer. Given object should be subclass of class
        DroneObserver.
        """
        for attr in ('applying', 'checking',  'finished'):
            if not hasattr(observer, attr):
                raise ValueError('Observer object should be a subclass '
                                 'of class DroneObserver.')
        self._observer = observer

    def apply(self, marker=None, name=None, skip=None):
        """
        Applies recipes on node. If marker is specified, only recipes
        with given marker are applied. If name is specified only recipe
        with given name is applied. Skips recipes with names given
        in list parameter skip.
        """
        # TO-DO: complete logger name when logging will be setup correctly
        logger = logging.getLogger()
        skip = skip or []
        lastmarker = None
        for mark, recipelist in self._recipes.iteritems():
            if marker and marker != mark:
                logger.debug('Skipping marker %s for node %s.' %
                             (mark, self.node))
                continue
            for recipe in recipelist:
                base = os.path.basename(recipe)
                if (name and name != base) or base in skip:
                    logger.debug('Skipping recipe %s for node %s.' %
                                 (recipe, self.node))
                    continue

                # if the marker has changed then we don't want to
                # proceed until all of the previous puppet runs have
                # finished
                if lastmarker and lastmarker != mark:
                    self._wait()
                lastmarker = mark

                logger.debug('Applying recipe %s to node %s.' %
                             (base, self.node))
                rpath = os.path.join(self.recipe_dir, base)
                if self._observer:
                    self._observer.applying(self, recipe)
                self._running.add(rpath)
                self._apply(rpath)
        self._wait()

    def cleanup(self, resource_dir=True, recipe_dir=True):
        """
        Removes all directories created by this drone.
        """
        shutil.rmtree(self.local_tmpdir, ignore_errors=True)
        server = utils.ScriptRunner(self.node)
        server.append('rm -fr %s' % self.remote_tmpdir)
        if recipe_dir:
            server.append('rm -fr %s' % self.recipe_dir)
        if resource_dir:
            server.append('rm -fr %s' % self.resource_dir)
        server.execute()


class PackstackDrone(SshTarballTransferMixin, Drone):
    """
    This drone uses Puppet and it's manifests to manipulate node.
    """
    # XXX: Since this implementation is Packstack specific (_apply
    #      method), it should be moved out of installer when
    #      Controller and plugin system will be refactored and installer
    #      will support projects.
    def __init__(self, *args, **kwargs):
        kwargs['resource_dir'] = ('/var/tmp/packstack/drone%s'
                                  % uuid.uuid4().hex[:8])
        kwargs['recipe_dir'] = '%s/manifests' % kwargs['resource_dir']
        kwargs['remote_tmpdir'] = '%s/temp' % kwargs['resource_dir']

        super(PackstackDrone, self).__init__(*args, **kwargs)

        self.module_dir = os.path.join(self.resource_dir, 'modules')
        self.fact_dir = os.path.join(self.resource_dir, 'facts')

    def init_node(self):
        """
        Initializes node for manipulation.
        """
        super(PackstackDrone, self).init_node()
        server = utils.ScriptRunner(self.node)
        for pkg in ("puppet", "openssh-clients", "tar"):
            server.append("rpm -q --whatprovides %(pkg)s || "
                              "yum install -y %(pkg)s" % locals())
        server.execute()

    def add_resource(self, path, resource_type=None):
        """
        Resource type should be module, fact or resource.
        """
        resource_type = resource_type or 'resource'
        dest = '%ss' % resource_type
        super(PackstackDrone, self).add_resource(path, destination=dest)

    def _finished(self, recipe):
        recipe_base = os.path.basename(recipe)
        log = os.path.join(self.recipe_dir,
                           recipe_base.replace(".finished", ".log"))
        local = utils.ScriptRunner()
        local.append('scp -o StrictHostKeyChecking=no '
                         '-o UserKnownHostsFile=/dev/null '
                         'root@%s:%s %s' % (self.node, recipe, log))
        try:
            # once a remote puppet run has finished, we retrieve
            # the log file and check it for errors
            local.execute(log=False)
            # if we got to this point the puppet apply has finished
            return True
        except utils.ScriptRuntimeError, e:
            # the test raises an exception if the file doesn't exist yet
            return False

    def _apply(self, recipe):
        running = "%s.running" % recipe
        finished = "%s.finished" % recipe

        server = utils.ScriptRunner(self.node)
        server.append("touch %s" % running)
        server.append("chmod 600 %s" % running)

        # XXX: This is terrible hack, but unfortunatelly the apache
        # puppet module doesn't work if we set FACTERLIB
        # https://github.com/puppetlabs/puppetlabs-apache/pull/138
        for bad_word in ('horizon', 'nagios', 'apache'):
            if bad_word in recipe:
                break
        else:
            server.append("export FACTERLIB=$FACTERLIB:%s" %
                          self.fact_dir)
        server.append("export PACKSTACK_VAR_DIR=%s" % self.resource_dir)

        # TO-DO: complete logger name when logging will be setup correctly
        logger = logging.getLogger()
        loglevel = logger.level <= logging.DEBUG and '--debug' or ''
        rdir = self.resource_dir
        mdir = self._module_dir
        server.append(
            "( flock %(rdir)s/ps.lock "
                "puppet apply %(loglevel)s --modulepath %(mdir)s "
                "%(recipe)s > %(running)s 2>&1 < /dev/null; "
            "mv %(running)s %(finished)s ) "
            "> /dev/null 2>&1 < /dev/null &" % locals())
        server.execute()

########NEW FILE########
__FILENAME__ = parameters
# -*- coding: utf-8 -*-

"""
Container set for groups and parameters
"""

from ..utils.datastructures import SortedDict


class Parameter(object):
    allowed_keys = ('CONF_NAME', 'CMD_OPTION', 'USAGE', 'PROMPT',
                    'PROCESSORS', 'VALIDATORS', 'LOOSE_VALIDATION',
                    'DEFAULT_VALUE', 'USE_DEFAULT', 'OPTION_LIST',
                    'MASK_INPUT', 'NEED_CONFIRM', 'CONDITION', 'DEPRECATES')

    def __init__(self, attributes=None):
        attributes = attributes or {}
        defaults = {}.fromkeys(self.allowed_keys)
        defaults.update(attributes)

        for key, value in defaults.iteritems():
            if key not in self.allowed_keys:
                raise KeyError('Given attribute %s is not allowed' % key)
            self.__dict__[key] = value


class Group(Parameter):
    allowed_keys = ('GROUP_NAME', 'DESCRIPTION', 'PRE_CONDITION',
                    'PRE_CONDITION_MATCH', 'POST_CONDITION',
                    'POST_CONDITION_MATCH')

    def __init__(self, attributes=None, parameters=None):
        super(Group, self).__init__(attributes)
        self.parameters = SortedDict()
        for param in parameters or []:
            self.parameters[param['CONF_NAME']] = Parameter(attributes=param)

    def search(self, attr, value):
        """
        Returns list of parameters which have given attribute of given
        value.
        """
        result = []
        for param in self.parameters.itervalues():
            if getattr(param, attr) == value:
                result.append(param)
        return result

########NEW FILE########
__FILENAME__ = sequences
# -*- coding: utf-8 -*-

"""
Base class for steps & sequences
"""
import re
import sys
import logging
import traceback

from .. import utils
from ..exceptions import SequenceError


class Step(object):
    """
    Wrapper for function representing single setup step.
    """
    def __init__(self, name, function, title=None):
        self.name = name
        self.title = title or ('Step: %s' % name)

        # process step function
        if function and not callable(function):
            raise SequenceError("Function object have to be callable. "
                                "Object %s is not callable." % function)
        self.function = function

    def run(self, config=None, messages=None):
        config = config if config is not None else {}
        messages = messages if messages is not None else []
        # TO-DO: complete logger name when logging will be setup correctly
        logger = logging.getLogger()
        logger.debug('Running step %s.' % self.name)

        # execute and report state
        try:
            self.function(config, messages)
        except Exception, ex:
            logger.debug(traceback.format_exc())
            state = utils.state_message(self.title, 'ERROR', 'red')
            sys.stdout.write('%s\n' % state)
            sys.stdout.flush()
            raise SequenceError(str(ex))
        else:
            state = utils.state_message(self.title, 'DONE', 'green')
            sys.stdout.write('%s\n' % state)
            sys.stdout.flush()



class Sequence(object):
    """
    Wrapper for sequence of setup steps.
    """
    def __init__(self, name, steps, title=None, condition=None,
                 cond_match=None):
        self.name = name
        self.title = title
        self.condition = condition
        self.cond_match = cond_match

        # process sequence steps
        self.steps = utils.SortedDict()
        for step in steps:
            name, func = step['name'], step['function']
            self.steps[name] = Step(name, func, title=step.get('title'))

    def validate_condition(self, config):
        """
        Returns True if config option condition has value given
        in cond_match. Otherwise returns False.
        """
        if not self.condition:
            return True
        result = config.get(self.condition)
        return result == self.cond_match

    def run(self, config=None, messages=None, step=None):
        """
        Runs sequence of steps. Runs only specific step if step's name
        is given via 'step' parameter.
        """
        config = config if config is not None else {}
        messages = messages if messages is not None else []
        if not self.validate_condition(config):
            return
        if step:
            self.steps[step].run(config=config, messages=messages)
            return

        logger = logging.getLogger()
        logger.debug('Running sequence %s.' % self.name)
        if self.title:
            sys.stdout.write('%s\n' % self.title)
            sys.stdout.flush()
        for step in self.steps.itervalues():
            step.run(config=config, messages=messages)

########NEW FILE########
__FILENAME__ = exceptions
# -*- coding: utf-8 -*-

__all__ = (
    'PackStackError',

    'InstallError',
    'FlagValidationError',
    'MissingRequirements',

    'PluginError',
    'ParamProcessingError',
    'ParamValidationError',

    'NetworkError',
    'ScriptRuntimeError',
)


class PackStackError(Exception):
    """Default Exception class for packstack installer."""
    def __init__(self, *args, **kwargs):
        super(PackStackError, self).__init__(*args)
        self.stdout = kwargs.get('stdout', None)
        self.stderr = kwargs.get('stderr', None)


class PuppetError(Exception):
    """Raised when Puppet will have some problems."""


class MissingRequirements(PackStackError):
    """Raised when minimum install requirements are not met."""
    pass


class InstallError(PackStackError):
    """Exception for generic errors during setup run."""
    pass


class FlagValidationError(InstallError):
    """Raised when single flag validation fails."""
    pass


class ParamValidationError(InstallError):
    """Raised when parameter value validation fails."""
    pass


class PluginError(PackStackError):
    pass


class ParamProcessingError(PluginError):
    pass


class NetworkError(PackStackError):
    """Should be used for packstack's network failures."""
    pass


class ScriptRuntimeError(PackStackError):
    """
    Raised when utils.ScriptRunner.execute does not end successfully.
    """
    pass


class ExecuteRuntimeError(PackStackError):
    """Raised when utils.execute does not end successfully."""


class SequenceError(PackStackError):
    """Exception for errors during setup sequence run."""
    pass

########NEW FILE########
__FILENAME__ = output_messages
'''
external text file to hold all user visible text.
info messages begins with INFO_ and error msg with ERR_

any text with %s inside it, has dynamic parameters inside.
please don't remove the %s from the text.
you can relocate %s position in the text as long as the context is kept.
\n means new line in the text
\ at the end of a line lets you continue the text in a new line

DONT CHANGE any of the params names (in UPPER-CASE)
they are used in the engine-setup.py
'''

import basedefs

#####################
####INFO MESSAGES####
#####################

INFO_HEADER="Welcome to %s setup utility" % basedefs.APP_NAME
INFO_INSTALL_SUCCESS="\n **** Installation completed successfully ******\n"
INFO_INSTALL="Installing:"
INFO_DSPLY_PARAMS="\n%s will be installed using the following configuration:" % basedefs.APP_NAME
INFO_USE_PARAMS="Proceed with the configuration listed above"
INFO_DONE="DONE"
INFO_ERROR="ERROR"
INFO_LOG_FILE_PATH="The installation log file is available at: %s"
INFO_MANIFEST_PATH="The generated manifests are available at: %s"
INFO_ADDTIONAL_MSG="Additional information:"
INFO_ADDTIONAL_MSG_BULLET=" * %s"
INFO_CONF_PARAMS_PASSWD_CONFIRM_PROMPT="Confirm password"
INFO_VAL_PATH_SPACE="Error: mount point %s contains only %s of available space while a minimum of %s is required"
INFO_VAL_NOT_INTEGER="Error: value is not an integer"
INFO_VAL_PORT_NOT_RANGE="Error: port is outside the range of %i - 65535"
INFO_VAL_STRING_EMPTY="Warning: The %s parameter is empty"
INFO_VAL_NOT_IN_OPTIONS="Error: response is not part of the following accepted answers: %s"
INFO_VAL_NOT_DOMAIN="Error: domain is not a valid domain name"
INFO_VAL_NOT_USER="Error: user name contains illegal characters"
INFO_VAL_PORT_OCCUPIED="Error: TCP Port %s is already open by %s (pid: %s)"
INFO_VAL_PORT_OCCUPIED_BY_JBOSS="Error: TCP Port %s is used by JBoss"
INFO_VAL_PASSWORD_DONT_MATCH="Error: passwords don't match"

INFO_CHANGED_VALUE = ("Packstack changed given value %s to required "
                      "value %s")
WARN_VAL_IS_HOSTNAME = ("Warning: Packstack failed to change given "
                        "hostname %s to IP address. Note that some "
                        "services might not run correctly when hostname"
                        " is used.")

INFO_STRING_LEN_LESS_THAN_MIN="String length is less than the minimum allowed: %s"
INFO_STRING_EXCEEDS_MAX_LENGTH="String length exceeds the maximum length allowed: %s"
INFO_STRING_CONTAINS_ILLEGAL_CHARS="String contains illegal characters"
INFO_CINDER_VOLUMES_EXISTS="Did not create a cinder volume group, one already existed"
INFO_REMOVE_REMOTE_VAR="Removing %s on %s (if it is a remote host)"

WARN_WEAK_PASS="Warning: Weak Password."

ERR_PING = "Error: the provided hostname is unreachable"
ERR_SSH = "Error: could not connect to the ssh server: %s"
ERR_FILE = "Error: the provided file is not present"
ERR_CHECK_LOG_FILE_FOR_MORE_INFO="Please check log file %s for more information"
ERR_YUM_LOCK="Internal Error: Can't edit versionlock "
ERR_FAILED_START_SERVICE = "Error: Can't start the %s service"
ERR_FAILED_STOP_SERVICE = "Error: Can't stop the %s service"
ERR_EXP_HANDLE_PARAMS="Failed handling user parameters input"
ERR_EXP_KEYBOARD_INTERRUPT="Keyboard interrupt caught."
ERR_READ_RPM_VER="Error reading version number for package %s"
ERR_EXP_READ_INPUT_PARAM="Error while trying to read parameter %s from user."
ERR_EXP_VALIDATE_PARAM="Error validating parameter %s from user."
ERR_EXP_HANDLE_ANSWER_FILE="Failed handling answer file: %s"
ERR_EXP_GET_CFG_IPS="Could not get list of available IP addresses on this host"
ERR_EXP_GET_CFG_IPS_CODES="Failed to get list of IP addresses"
ERR_EXP_CANT_FIND_IP="Could not find any configured IP address"
ERR_DIDNT_RESOLVED_IP="%s did not resolve into an IP address"
ERR_IPS_NOT_CONFIGED="Some or all of the IP addresses: (%s) which were resolved from the FQDN %s are not configured on any interface on this host"
ERR_IPS_NOT_CONFIGED_ON_INT="The IP (%s) which was resolved from the FQDN %s is not configured on any interface on this host"
ERR_IPS_HAS_NO_PTR="None of the IP addresses on this host(%s) holds a PTR record for the FQDN: %s"
ERR_IP_HAS_NO_PTR="The IP %s does not hold a PTR record for the FQDN: %s"
ERR_EXP_FAILED_INIT_LOGGER="Unexpected error: Failed to initiate logger, please check file system permission"
ERR_FAILURE="General failure"
ERR_NO_ANSWER_FILE="Error: Could not find file %s"
ERR_ONLY_1_FLAG="Error: The %s flag is mutually exclusive to all other command line options"
ERR_REMOVE_REMOTE_VAR="Error: Failed to remove directory %s on %s, it contains sensitive data and should be removed"

#

########NEW FILE########
__FILENAME__ = processors
# -*- coding: utf-8 -*-

import netaddr
import os

from .utils import ScriptRunner, force_ip
from .exceptions import ParamProcessingError, NetworkError


__all__ = ('ParamProcessingError', 'process_cidr', 'process_host',
           'process_ssh_key')


def process_cidr(param, process_args=None):
    """
    Corrects given CIDR if necessary.
    """
    if '/' not in param:
        # we need to skip this if single IP address has been given
        return param
    try:
        return str(netaddr.IPNetwork(param).cidr)
    except Exception, ex:
        raise ParamProcessingError(str(ex))


def process_host(param, process_args=None):
    """
    Tries to change given parameter to IP address, if it is in hostname
    format
    """
    localhost = process_args and \
                process_args.get('allow_localhost', False)
    try:
        return force_ip(param, allow_localhost=localhost)
    except NetworkError, ex:
        raise ParamProcessingError(str(ex))


def process_ssh_key(param, process_args=None):
    """
    Generates SSH key if given key in param doesn't exist. In case param
    is an empty string it generates default SSH key ($HOME/.ssh/id_rsa).
    """
    def create_key(path):
        # make path absolute
        path = os.path.expanduser(path)
        path = os.path.abspath(path)
        # create new ssh key
        local = ScriptRunner()
        local.append('ssh-keygen -f "%s" -N ""' % path)
        local.execute()

    if not param:
        key_file = '%s/.ssh/id_rsa' % os.environ["HOME"]
        param = '%s.pub' % key_file
        if not os.path.isfile(param):
            create_key(key_file)
    elif not os.path.isfile(param):
        key_file = param.endswith('.pub') and param[:-4] or param
        param = param.endswith('.pub') and param or ('%s.pub' % param)
        create_key(key_file)
    return param


def process_add_quotes_around_values(param, process_args=None):
    """
    Add a single quote character around each element of a comma
    separated list of values
    """
    params_list = param.split(',')
    for index, elem in enumerate(params_list):
        if not elem.startswith("'"):
            elem = "'" + elem
        if not elem.endswith("'"):
            elem = elem + "'"
        params_list[index] = elem
    param = ','.join(params_list)
    return param

########NEW FILE########
__FILENAME__ = datastructures
# -*- coding: utf-8 -*-

import copy
from types import GeneratorType


# taken from Django.utils.datastructures
class SortedDict(dict):
    """
    A dictionary that keeps its keys in the order in which they're inserted.
    """
    def __new__(cls, *args, **kwargs):
        instance = super(SortedDict, cls).__new__(cls, *args, **kwargs)
        instance.keyOrder = []
        return instance

    def __init__(self, data=None):
        if data is None:
            data = {}
        elif isinstance(data, GeneratorType):
            # Unfortunately we need to be able to read a generator twice.  Once
            # to get the data into self with our super().__init__ call and a
            # second time to setup keyOrder correctly
            data = list(data)
        super(SortedDict, self).__init__(data)
        if isinstance(data, dict):
            self.keyOrder = data.keys()
        else:
            self.keyOrder = []
            seen = set()
            for key, value in data:
                if key not in seen:
                    self.keyOrder.append(key)
                    seen.add(key)

    def __deepcopy__(self, memo):
        return self.__class__([(key, copy.deepcopy(value, memo))
                               for key, value in self.iteritems()])

    def __setitem__(self, key, value):
        if key not in self:
            self.keyOrder.append(key)
        super(SortedDict, self).__setitem__(key, value)

    def __delitem__(self, key):
        super(SortedDict, self).__delitem__(key)
        self.keyOrder.remove(key)

    def __iter__(self):
        return iter(self.keyOrder)

    def pop(self, k, *args):
        result = super(SortedDict, self).pop(k, *args)
        try:
            self.keyOrder.remove(k)
        except ValueError:
            # Key wasn't in the dictionary in the first place. No problem.
            pass
        return result

    def popitem(self):
        result = super(SortedDict, self).popitem()
        self.keyOrder.remove(result[0])
        return result

    def items(self):
        return zip(self.keyOrder, self.values())

    def iteritems(self):
        for key in self.keyOrder:
            yield key, self[key]

    def keys(self):
        return self.keyOrder[:]

    def iterkeys(self):
        return iter(self.keyOrder)

    def values(self):
        return map(self.__getitem__, self.keyOrder)

    def itervalues(self):
        for key in self.keyOrder:
            yield self[key]

    def update(self, dict_):
        for k, v in dict_.iteritems():
            self[k] = v

    def setdefault(self, key, default):
        if key not in self:
            self.keyOrder.append(key)
        return super(SortedDict, self).setdefault(key, default)

    def value_for_index(self, index):
        """Returns the value of the item at the given zero-based index."""
        return self[self.keyOrder[index]]

    def insert(self, index, key, value):
        """Inserts the key, value pair before the item with the given index."""
        if key in self.keyOrder:
            n = self.keyOrder.index(key)
            del self.keyOrder[n]
            if n < index:
                index -= 1
        self.keyOrder.insert(index, key)
        super(SortedDict, self).__setitem__(key, value)

    def copy(self):
        """Returns a copy of this object."""
        # This way of initializing the copy means it works for subclasses, too.
        obj = self.__class__(self)
        obj.keyOrder = self.keyOrder[:]
        return obj

    def __repr__(self):
        """
        Replaces the normal dict.__repr__ with a version that returns the keys
        in their sorted order.
        """
        return '{%s}' % ', '.join(['%r: %r' % (k, v) for k, v in self.items()])

    def clear(self):
        super(SortedDict, self).clear()
        self.keyOrder = []

########NEW FILE########
__FILENAME__ = decorators
# -*- coding: utf-8 -*-

import time


def retry(count=1, delay=0, retry_on=Exception):
    """
    Decorator which tries to run specified fuction if the previous
    run ended by given exception. Retry count and delays can be also
    specified.
    """
    if count < 0 or delay < 0:
        raise ValueError('Count and delay has to be positive number.')

    def decorator(func):
        def wrapper(*args, **kwargs):
            tried = 0
            while tried <= count:
                try:
                    return func(*args, **kwargs)
                except retry_on:
                    if tried >= count:
                        raise
                    if delay:
                        time.sleep(delay)
                    tried += 1
        wrapper.func_name = func.func_name
        return wrapper
    return decorator

########NEW FILE########
__FILENAME__ = network
# -*- coding: utf-8 -*-

import re
import socket

from ..exceptions import NetworkError
from .shell import execute, ScriptRunner


def get_localhost_ip():
    """
    Returns IP address of localhost.
    """
    # TO-DO: Will probably need to find better way to find out localhost
    #        address.

    # find nameservers
    ns_regex = re.compile('nameserver\s*(?P<ns_ip>[\d\.\:]+)')
    rc, resolv = execute('cat /etc/resolv.conf | grep nameserver',
                         can_fail=False, use_shell=True, log=False)
    nsrvs = []
    for line in resolv.split('\n'):
        match = ns_regex.match(line.strip())
        if match:
            nsrvs.append(match.group('ns_ip'))

    # try to connect to nameservers and return own IP address
    nsrvs.append('8.8.8.8')  # default to google dns
    for i in nsrvs:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect((i, 0))
            loc_ip = s.getsockname()[0]
        except socket.error:
            continue
        else:
            return loc_ip
    raise NetworkError('Local IP address discovery failed. Please set '
                       'nameserver correctly.')


def host2ip(hostname, allow_localhost=False):
    """
    Converts given hostname to IP address. Raises NetworkError
    if conversion failed.
    """
    try:
        ip_list = socket.gethostbyaddr(hostname)[2]
        if allow_localhost:
            return ip_list[0]
        else:
            local_ips = ('127.0.0.1', '::1')
            for ip in ip_list:
                if ip not in local_ips:
                    break
            else:
                raise NameError()
            return ip
    except NameError:
        # given hostname is localhost, return appropriate IP address
        return get_localhost_ip()
    except socket.error:
        raise NetworkError('Unknown hostname %s.' % hostname)
    except Exception, ex:
        raise NetworkError('Unknown error appeared: %s' % repr(ex))


def force_ip(host, allow_localhost=False):
    host = host.strip()
    ipv4_regex = re.compile('\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')
    ipv6_regex = re.compile('[abcdef\d\:]+')
    if not ipv4_regex.match(host) or not ipv6_regex.match(host):
        host = host2ip(host, allow_localhost=allow_localhost)
    return host


def device_from_ip(ip):
    server = ScriptRunner()
    server.append("DEVICE=($(ip -o address show to %s | cut -f 2 -d ' '))"
                  % ip)
    # Ensure that the IP is only assigned to one interface
    server.append("if [ ! -z ${DISPLAY[1]} ]; then false; fi")
    # Test device, raises an exception if it doesn't exist
    server.append("ip link show \"$DEVICE\" > /dev/null")
    server.append("echo $DEVICE")
    rv, stdout = server.execute()
    return stdout.strip()

########NEW FILE########
__FILENAME__ = shell
# -*- coding: utf-8 -*-

import re
import types
import logging
import subprocess

from ..exceptions import (ExecuteRuntimeError, ScriptRuntimeError,
                          NetworkError)
from .strings import mask_string


block_fmt = ("\n============= %(title)s ==========\n%(content)s\n"
             "======== END OF %(title)s ========")


def execute(cmd, workdir=None, can_fail=True, mask_list=None,
            use_shell=False, log=True):
    """
    Runs shell command cmd. If can_fail is set to False
    ExecuteRuntimeError is raised if command returned non-zero return
    code. Otherwise
    """
    mask_list = mask_list or []
    repl_list = [("'", "'\\''")]

    if not isinstance(cmd, types.StringType):
        import pipes
        masked = ' '.join((pipes.quote(i) for i in cmd))
    else:
        masked = cmd
    masked = mask_string(masked, mask_list, repl_list)
    if log:
        logging.info("Executing command:\n%s" % masked)

    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE, cwd=workdir,
                            shell=use_shell, close_fds=True)
    out, err = proc.communicate()
    masked_out = mask_string(out, mask_list, repl_list)
    masked_err = mask_string(err, mask_list, repl_list)
    if log:
        logging.debug(block_fmt % {'title': 'STDOUT', 'content': masked_out})

    if proc.returncode:
        if log:
            logging.debug(block_fmt % {'title': 'STDERR',
                                       'content': masked_err})
        if can_fail:
            msg = ('Failed to execute command, '
                   'stdout: %s\nstderr: %s' %
                   (masked_out, masked_err))
            raise ExecuteRuntimeError(msg, stdout=out, stderr=err)
    return proc.returncode, out


class ScriptRunner(object):
    _pkg_search = 'rpm -q --whatprovides'

    def __init__(self, ip=None):
        self.script = []
        self.ip = ip

    def append(self, s):
        self.script.append(s)

    def clear(self):
        self.script = []

    def execute(self, can_fail=True, mask_list=None, log=True):
        mask_list = mask_list or []
        repl_list = [("'", "'\\''")]
        script = "\n".join(self.script)

        masked = mask_string(script, mask_list, repl_list)
        if log:
            logging.info("[%s] Executing script:\n%s" %
                         (self.ip or 'localhost', masked))

        _PIPE = subprocess.PIPE  # pylint: disable=E1101
        if self.ip:
            cmd = ["ssh", "-o", "StrictHostKeyChecking=no",
                          "-o", "UserKnownHostsFile=/dev/null",
                          "root@%s" % self.ip, "bash -x"]
        else:
            cmd = ["bash", "-x"]
        obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE,
                               close_fds=True, shell=False)

        script = "function t(){ exit $? ; } \n trap t ERR \n" + script
        out, err = obj.communicate(script)
        masked_out = mask_string(out, mask_list, repl_list)
        masked_err = mask_string(err, mask_list, repl_list)
        if log:
            logging.debug(block_fmt % {'title': 'STDOUT',
                                       'content': masked_out})

        if obj.returncode:
            if log:
                logging.debug(block_fmt % {'title': 'STDERR',
                                           'content': masked_err})
            if can_fail:
                pattern = (r'^ssh\:')
                if re.search(pattern, err):
                    raise NetworkError(masked_err, stdout=out, stderr=err)
                else:
                    msg = ('Failed to run remote script, '
                           'stdout: %s\nstderr: %s' %
                           (masked_out, masked_err))
                    raise ScriptRuntimeError(msg, stdout=out, stderr=err)
        return obj.returncode, out

    def template(self, src, dst, varsdict):
        with open(src) as fp:
            content = fp.read() % varsdict
            self.append("cat > %s <<- EOF\n%s\nEOF\n" % (dst, content))

    def if_not_exists(self, path, command):
        self.append("[ -e %s ] || %s" % (path, command))

    def if_exists(self, path, command):
        self.append("[ -e %s ] && %s" % (path, command))

    def if_installed(self, pkg, command):
        self.append("%s %s && %s" % (self._pkg_search, pkg, command))

    def if_not_installed(self, pkg, command):
        self.append("%s %s || %s" % (self._pkg_search, pkg, command))

    def chown(self, target, uid, gid):
        self.append("chown %s:%s %s" % (uid, gid, target))

    def chmod(self, target, mode):
        self.append("chmod %s %s" % (mode, target))

########NEW FILE########
__FILENAME__ = shortcuts
# -*- coding: utf-8 -*-

import grp
import os
import pwd


def host_iter(config):
    for key, value in config.iteritems():
        if key.endswith("_HOST"):
            host = value.split('/')[0]
            if host:
                yield key, host
        if key.endswith("_HOSTS"):
            for i in value.split(","):
                host = i.strip().split('/')[0]
                if host:
                    yield key, host


def hosts(config):
    result = set()
    for key, host in host_iter(config):
        result.add(host)
    return result


def get_current_user():
    try:
        user = pwd.getpwnam(os.getlogin())
        uid, gid = user.pw_uid, user.pw_gid
    except OSError:
        # in case program is run by a script
        uid, gid = os.getuid(), os.getgid()
    return uid, gid


def get_current_username():
    uid, gid = get_current_user()
    user = pwd.getpwuid(uid).pw_name
    group = grp.getgrgid(gid).gr_name
    return user, group


def split_hosts(hosts_string):
    hosts = set()
    for host in hosts_string.split(','):
        shost = host.strip()
        if shost:
            hosts.add(shost)
    return hosts

########NEW FILE########
__FILENAME__ = strings
# -*- coding: utf-8 -*-

import re


STR_MASK = '*' * 8
COLORS = {'nocolor': "\033[0m", 'red': "\033[0;31m",
          'green': "\033[32m", 'blue': "\033[34m",
          'yellow': "\033[33m"}


def color_text(text, color):
    """
    Returns given text string with appropriate color tag. Allowed values
    for color parameter are 'red', 'blue', 'green' and 'yellow'.
    """
    return '%s%s%s' % (COLORS[color], text, COLORS['nocolor'])


def mask_string(unmasked, mask_list=None, replace_list=None):
    """
    Replaces words from mask_list with MASK in unmasked string.
    If words are needed to be transformed before masking, transformation
    could be describe in replace list. For example [("'","'\\''")]
    replaces all ' characters with '\\''.
    """
    mask_list = mask_list or []
    replace_list = replace_list or []

    masked = unmasked
    for word in sorted(mask_list, lambda x, y: len(y) - len(x)):
        if not word:
            continue
        for before, after in replace_list:
            word = word.replace(before, after)
        masked = masked.replace(word, STR_MASK)
    return masked


def state_format(msg, state, color):
    """
    Formats state with offset according to given message.
    """
    _msg = '%s' % msg.strip()
    for clr in COLORS.values():
        _msg = re.sub(re.escape(clr), '', msg)

    space = 70 - len(_msg)
    state = '[ %s ]' % color_text(state, color)
    return state.rjust(space)


def state_message(msg, state, color):
    """
    Formats given message with colored state information.
    """
    return '%s%s' % (msg, state_format(msg, state, color))

########NEW FILE########
__FILENAME__ = validators
# -*- coding: utf-8 -*-

"""
Contains all core validation functions.
"""

import os
import re
import socket
import logging
import tempfile
import traceback

import basedefs
from . import utils

from .setup_controller import Controller
from .exceptions import ParamValidationError


__all__ = ('ParamValidationError', 'validate_integer', 'validate_float',
           'validate_regexp', 'validate_port', 'validate_not_empty',
           'validate_options', 'validate_multi_options', 'validate_ip',
           'validate_multi_ip', 'validate_file', 'validate_ping',
           'validate_multi_ping', 'validate_ssh', 'validate_multi_ssh',
           'validate_sshkey')


def validate_integer(param, options=None):
    """
    Raises ParamValidationError if given param is not integer.
    """
    options = options or []
    try:
        int(param)
    except ValueError:
        logging.debug('validate_integer(%s, options=%s) failed.' %
                      (param, options))
        msg = 'Given value is not an integer: %s'
        raise ParamValidationError(msg % param)


def validate_float(param, options=None):
    """
    Raises ParamValidationError if given param is not a float.
    """
    options = options or []
    try:
        float(param)
    except ValueError:
        logging.debug('validate_float(%s, options=%s) failed.' %
                      (param, options))
        msg = 'Given value is not a float: %s'
        raise ParamValidationError(msg % param)


def validate_regexp(param, options=None):
    """
    Raises ParamValidationError if given param doesn't match at least
    one of regular expressions given in options.
    """
    options = options or []
    for regex in options:
        if re.search(regex, param):
            break
    else:
        logging.debug('validate_regexp(%s, options=%s) failed.' %
                      (param, options))
        msg = 'Given value does not match required regular expression: %s'
        raise ParamValidationError(msg % param)


def validate_multi_regexp(param, options=None):
    """
    Raises ParamValidationError if any of the comma separated values given
    in param doesn't match one of the regular expressions given in options.
    """
    options = options or []
    for i in param.split(','):
        validate_regexp(i.strip(), options=options)


def validate_port(param, options=None):
    """
    Raises ParamValidationError if given param is not a decimal number
    in range (0, 65535).
    """
    options = options or []
    validate_integer(param, options)
    port = int(param)
    if not (port >= 0 and port < 65535):
        logging.debug('validate_port(%s, options=%s) failed.' %
                      (param, options))
        msg = 'Given value is outside the range of (0, 65535): %s'
        raise ParamValidationError(msg % param)


def validate_not_empty(param, options=None):
    """
    Raises ParamValidationError if given param is empty.
    """
    options = options or []
    if not param and param is not False:
        logging.debug('validate_not_empty(%s, options=%s) failed.' %
                      (param, options))
        msg = 'Given value is not allowed: %s'
        raise ParamValidationError(msg % param)


def validate_options(param, options=None):
    """
    Raises ParamValidationError if given param is not member of options.
    """
    options = options or []

    # TO-DO: to be more flexible, remove this and exit in case param is empty
    validate_not_empty(param, options)
    if param not in options:
        logging.debug('validate_options(%s, options=%s) failed.' %
                      (param, options))
        msg = 'Given value is not member of allowed values %s: %s'
        raise ParamValidationError(msg % (options, param))


def validate_multi_options(param, options=None):
    """
    Validates if comma separated values given in params are members
    of options.
    """
    if not param:
        return
    options = options or []
    for i in param.split(','):
        validate_options(i.strip(), options=options)


def validate_ip(param, options=None):
    """
    Raises ParamValidationError if given parameter value is not in IPv4
    or IPv6 address.
    """
    for family in (socket.AF_INET, socket.AF_INET6):
        try:
            socket.inet_pton(family, param)
            break
        except socket.error:
            continue
    else:
        logging.debug('validate_ip(%s, options=%s) failed.' %
                      (param, options))
        msg = 'Given host is not in IP address format: %s'
        raise ParamValidationError(msg % param)


def validate_multi_ip(param, options=None):
    """
    Raises ParamValidationError if comma separated IP addresses given
    parameter value are in IPv4 or IPv6 aformat.
    """
    for host in param.split(','):
        host = host.split('/', 1)[0]
        validate_ip(host.strip(), options)


def validate_file(param, options=None):
    """
    Raises ParamValidationError if provided file in param does not exist.
    """
    options = options or []
    # TO-DO: to be more flexible, remove this and exit in case param is empty
    validate_not_empty(param)

    if not os.path.isfile(param):
        logging.debug('validate_file(%s, options=%s) failed.' %
                      (param, options))
        msg = 'Given file does not exist: %s'
        raise ParamValidationError(msg % param)


def validate_ping(param, options=None):
    """
    Raises ParamValidationError if provided host does not answer to ICMP
    echo request.
    """
    options = options or []
    # TO-DO: to be more flexible, remove this and exit in case param is empty
    validate_not_empty(param)

    rc, out = utils.execute(['/bin/ping', '-c', '1', str(param)],
                            can_fail=False)
    if rc != 0:
        logging.debug('validate_ping(%s, options=%s) failed.' %
                      (param, options))
        msg = 'Given host is unreachable: %s'
        raise ParamValidationError(msg % param)


def validate_multi_ping(param, options=None):
    """
    Raises ParamValidationError if comma separated host given in param
    do not answer to ICMP echo request.
    """
    options = options or []
    # TO-DO: to be more flexible, remove this and exit in case param is empty
    validate_not_empty(param)
    for host in param.split(","):
        validate_ping(host.strip())


_tested_ports = []
def touch_port(host, port):
    """
    Check that provided host is listening on provided port.
    """
    key = "%s:%d" % (host, port)
    if key in _tested_ports:
        return
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    s.shutdown(socket.SHUT_RDWR)
    s.close()
    _tested_ports.append(key)


def validate_ssh(param, options=None):
    """
    Raises ParamValidationError if provided host does not listen
    on port 22.
    """
    options = options or []
    try:
        touch_port(param.strip(), 22)
    except socket.error:
        logging.debug('validate_ssh(%s, options=%s) failed.' %
                      (param, options))
        msg = 'Given host does not listen on port 22: %s'
        raise ParamValidationError(msg % param)


def validate_multi_ssh(param, options=None):
    """
    Raises ParamValidationError if comma separated host provided
    in param do not listen on port 22.
    """
    options = options or []
    for host in param.split(","):
        validate_ssh(host)


def validate_sshkey(param, options=None):
    """
    Raises ParamValidationError if provided sshkey file is not public key.
    """
    if not param:
        return
    with open(param) as sshkey:
        line = sshkey.readline()
    msg = None
    if not re.search('ssh-|ecdsa', line):
        msg = ('Invalid content header in %s, Public SSH key is required.'
               % param)
    if re.search('BEGIN [RD]SA PRIVATE KEY', line):
        msg = 'Public SSH key is required. You passed private key.'
    if msg:
        raise ParamValidationError(msg)

########NEW FILE########
__FILENAME__ = common
# -*- coding: utf-8 -*-

from ..installer import utils


def filtered_hosts(config, exclude=True, dbhost=True):
    """
    Returns list of hosts which need installation taking into account
    CONFIG_MYSQL_INSTAL if parameter dbhost is True and EXCLUDE_SERVERS
    if parameter exclude is True.
    """
    exclset = set([i.strip()
                   for i in config.get('EXCLUDE_SERVERS', '').split(',')
                   if i.strip()])
    result = set()
    dbinst = config.get('CONFIG_MYSQL_INSTALL') == 'y'
    vcenter = config.get('CONFIG_VMWARE_BACKEND') == 'y'
    for hosttype, hostname in utils.host_iter(config):
        # if dbhost is being taken into account and we are not installing MySQL
        # then we should omit the MySQL host
        if dbhost and not dbinst and hosttype == 'CONFIG_MYSQL_HOST':
            continue
        if vcenter and hosttype == 'CONFIG_VCENTER_HOST':
            continue
        result.add(hostname)
    if exclude:
        result = result - exclset
    return result


def is_all_in_one(config):
    """
    Returns True if packstack is running allinone setup, otherwise
    returns False.
    """
    # Even if some host have been excluded from installation, we must count
    # with them when checking all-in-one. MySQL host should however be omitted
    # if we are not installing MySQL
    return len(filtered_hosts(config, exclude=False, dbhost=True)) == 1

########NEW FILE########
__FILENAME__ = ospluginutils

import logging
import os
import re

from packstack.installer import basedefs
from packstack.installer.setup_controller import Controller
from packstack.installer.exceptions import PackStackError

controller = Controller()

PUPPET_DIR = os.path.join(basedefs.DIR_PROJECT_DIR, "puppet")
PUPPET_TEMPLATE_DIR = os.path.join(PUPPET_DIR, "templates")


class NovaConfig(object):
    """
    Helper class to create puppet manifest entries for nova_config
    """
    def __init__(self):
        self.options = {}

    def addOption(self, n, v):
        self.options[n] = v

    def getManifestEntry(self):
        entry = ""
        if not self.options:
            return entry

        entry += "nova_config{\n"
        for k, v in self.options.items():
            entry += '    "%s": value => "%s";\n' % (k, v)
        entry += "}"
        return entry


class ManifestFiles(object):
    def __init__(self):
        self.filelist = []
        self.data = {}
        self.global_data = None

    # continuous manifest file that have the same marker can be
    # installed in parallel, if on different servers
    def addFile(self, filename, marker, data=''):
        self.data[filename] = self.data.get(filename, '') + '\n' + data
        for f, p in self.filelist:
            if f == filename:
                return

        self.filelist.append((filename, marker))

    def getFiles(self):
        return [f for f in self.filelist]

    def writeManifests(self):
        """
        Write out the manifest data to disk, this should only be called once
        write before the puppet manifests are copied to the various servers
        """
        if not self.global_data:
            with open(os.path.join(PUPPET_TEMPLATE_DIR, "global.pp")) as gfp:
                self.global_data = gfp.read() % controller.CONF
        os.mkdir(basedefs.PUPPET_MANIFEST_DIR, 0700)
        for fname, data in self.data.items():
            path = os.path.join(basedefs.PUPPET_MANIFEST_DIR, fname)
            fd = os.open(path, os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0600)
            with os.fdopen(fd, 'w') as fp:
                fp.write(self.global_data + data)
manifestfiles = ManifestFiles()


def getManifestTemplate(template_name):
    with open(os.path.join(PUPPET_TEMPLATE_DIR, template_name)) as fp:
        return fp.read() % controller.CONF


def appendManifestFile(manifest_name, data, marker=''):
    manifestfiles.addFile(manifest_name, marker, data)


def gethostlist(CONF):
    hosts = []
    for key, value in CONF.items():
        if key.endswith("_HOST"):
            value = value.split('/')[0]
            if value and value not in hosts:
                hosts.append(value)
        if key.endswith("_HOSTS"):
            for host in value.split(","):
                host = host.strip()
                host = host.split('/')[0]
                if host and host not in hosts:
                    hosts.append(host)
    return hosts

########NEW FILE########
__FILENAME__ = puppet
# -*- coding: utf-8 -*-

import logging
import os
import re

from packstack.installer.exceptions import PuppetError


# TODO: Fill logger name when logging system will be refactored
logger = logging.getLogger()

re_color = re.compile('\x1b.*?\d\dm')
re_error = re.compile(
    'err:|Syntax error at|^Duplicate definition:|^Invalid tag|'
    '^No matching value for selector param|^Parameter name failed:|Error:|'
    '^Invalid parameter|^Duplicate declaration:|^Could not find resource|'
    '^Could not parse for|^/usr/bin/puppet:\d+: .+|.+\(LoadError\)|'
    '^Could not autoload|'
    '^\/usr\/bin\/env\: jruby\: No such file or directory'
)
re_ignore = re.compile(
    # Puppet preloads a provider using the mysql command before it is installed
    'Command mysql is missing|'
    # Puppet preloads a database_grant provider which fails if /root/.my.cnf
    # is missing, this is ok because it will be retried later if needed
    'Could not prefetch database_grant provider.*?\\.my\\.cnf|'
    # Swift Puppet module tries to install swift-plugin-s3, there is no such
    # package on RHEL, fixed in the upstream puppet module
    'yum.*?install swift-plugin-s3'
)
re_notice = re.compile(r"notice: .*Notify\[packstack_info\]"
                         "\/message: defined \'message\' as "
                         "\'(?P<message>.*)\'")

surrogates = [
    # Value in /etc/sysctl.conf cannot be changed
    ('Sysctl::Value\[.*\]\/Sysctl\[(?P<arg1>.*)\].*Field \'val\' is required',
        'Cannot change value of %(arg1)s in /etc/sysctl.conf'),
    # Package is not found in yum repos
    ('Package\[.*\]\/ensure.*yum.*install (?P<arg1>.*)\'.*Nothing to do',
        'Package %(arg1)s has not been found in enabled Yum repos.'),
    ('Execution of \'.*yum.*install (?P<arg1>.*)\'.*Nothing to do',
        'Package %(arg1)s has not been found in enabled Yum repos.'),
    # Packstack does not cooperate with jruby
    ('jruby', 'Your Puppet installation uses jruby instead of ruby. Package '
              'jruby does not cooperate with Packstack well. You will have to '
              'fix this manually.'),
]


def validate_logfile(logpath):
    """
    Check given Puppet log file for errors and raise PuppetError if there is
    any error
    """
    manifestpath = os.path.splitext(logpath)[0]
    manifestfile = os.path.basename(manifestpath)
    with open(logpath) as logfile:
        for line in logfile:
            line = line.strip()

            if re_error.search(line) is None:
                continue

            error = re_color.sub('', line)  # remove colors
            if re_ignore.search(line):
                msg = ('Ignoring expected error during Puppet run %s: %s' %
                       (manifestfile, error))
                logger.debug(msg)
                continue

            for regex, surrogate in surrogates:
                match = re.search(regex, error)
                if match is None:
                    continue

                args = {}
                num = 1
                while True:
                    try:
                        args['arg%d' % num] = match.group(num)
                        num += 1
                    except IndexError:
                        break
                error = surrogate % args

            message = ('Error appeared during Puppet run: %s\n%s\n'
                       'You will find full trace in log %s' %
                       (manifestfile, error, logpath))
            raise PuppetError(message)


def scan_logfile(logpath):
    """
    Returns list of packstack_info/packstack_warn notices parsed from
    given puppet log file.
    """
    output = []
    with open(logpath) as logfile:
        for line in logfile:
            match = re_notice.search(line)
            if match:
                output.append(match.group('message'))
    return output

########NEW FILE########
__FILENAME__ = shortcuts
# -*- coding: utf-8 -*-


def get_mq(config, plugin):
    return plugin + "_%s.pp" % config.get('CONFIG_AMQP_BACKEND')

########NEW FILE########
__FILENAME__ = amqp_002
# -*- coding: utf-8 -*-

"""
Installs and configures amqp
"""

import logging
import uuid
import os

from packstack.installer import validators
from packstack.installer import basedefs
from packstack.installer import utils

from packstack.modules.common import filtered_hosts
from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "AMQP"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    params = [
        {"CMD_OPTION": "amqp-backend",
         "USAGE": ("Set the AMQP service backend. Allowed values are: "
                   "qpid, rabbitmq"),
         "PROMPT": "Set the AMQP service backend",
         "OPTION_LIST": ["qpid", "rabbitmq"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "rabbitmq",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_AMQP_BACKEND",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False,
         "DEPRECATES": ['CONFIG_AMQP_SERVER']},

        {"CMD_OPTION": "amqp-host",
         "USAGE": ("The IP address of the server on which to install the "
                   "AMQP service"),
         "PROMPT": "Enter the IP address of the AMQP service",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_ssh],
         "DEFAULT_VALUE": utils.get_localhost_ip(),
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_AMQP_HOST",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "amqp-enable-ssl",
         "USAGE": "Enable SSL for the AMQP service",
         "PROMPT": "Enable SSL for the AMQP service?",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "n",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_AMQP_ENABLE_SSL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "amqp-enable-auth",
         "USAGE": "Enable Authentication for the AMQP service",
         "PROMPT": "Enable Authentication for the AMQP service?",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "n",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_AMQP_ENABLE_AUTH",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "AMQP",
             "DESCRIPTION": "AMQP Config parameters",
             "PRE_CONDITION": False,
             "PRE_CONDITION_MATCH": True,
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)

    params = [
        {"CMD_OPTION": "amqp-nss-certdb-pw",
         "USAGE": ("The password for the NSS certificate database of the AMQP "
                   "service"),
         "PROMPT": "Enter the password for NSS certificate database",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:32],
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_AMQP_NSS_CERTDB_PW",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "amqp-ssl-port",
         "USAGE": ("The port in which the AMQP service listens to SSL "
                   "connections"),
         "PROMPT": "Enter the SSL port for the AMQP service",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": "5671",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_AMQP_SSL_PORT",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "amqp-ssl-cert-file",
         "USAGE": ("The filename of the certificate that the AMQP service "
                   "is going to use"),
         "PROMPT": ("Enter the filename of the SSL certificate for the AMQP "
                    "service"),
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": "/etc/pki/tls/certs/amqp_selfcert.pem",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_AMQP_SSL_CERT_FILE",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "amqp-ssl-key-file",
         "USAGE": ("The filename of the private key that the AMQP service "
                   "is going to use"),
         "PROMPT": "Enter the private key filename",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": "/etc/pki/tls/private/amqp_selfkey.pem",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_AMQP_SSL_KEY_FILE",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "amqp-ssl-self-signed",
         "USAGE": "Auto Generates self signed SSL certificate and key",
         "PROMPT": "Generate Self Signed SSL Certificate",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": "y",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_AMQP_SSL_SELF_SIGNED",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "AMQPSSL",
             "DESCRIPTION": "AMQP Config SSL parameters",
             "PRE_CONDITION": "CONFIG_AMQP_ENABLE_SSL",
             "PRE_CONDITION_MATCH": "y",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)

    params = [
        {"CMD_OPTION": "amqp-auth-user",
         "USAGE": "User for amqp authentication",
         "PROMPT": "Enter the user for amqp authentication",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": "amqp_user",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_AMQP_AUTH_USER",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "amqp-auth-password",
         "USAGE": "Password for user authentication",
         "PROMPT": "Enter the password for user authentication",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_AMQP_AUTH_PASSWORD",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "AMQPAUTH",
             "DESCRIPTION": "AMQP Config Athentication parameters",
             "PRE_CONDITION": "CONFIG_AMQP_ENABLE_AUTH",
             "PRE_CONDITION_MATCH": "y",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)


def initSequences(controller):
    amqpsteps = [
        {'title': 'Adding AMQP manifest entries',
         'functions': [create_manifest]}
    ]
    controller.addSequence("Installing AMQP", [], [], amqpsteps)


#-------------------------- step functions --------------------------

def create_manifest(config, messages):
    server = utils.ScriptRunner(config['CONFIG_AMQP_HOST'])
    if config['CONFIG_AMQP_ENABLE_SSL'] == 'y':
        config['CONFIG_AMQP_ENABLE_SSL'] = 'true'
        config['CONFIG_AMQP_PROTOCOL'] = 'ssl'
        config['CONFIG_AMQP_CLIENTS_PORT'] = "5671"
        if config['CONFIG_AMQP_SSL_SELF_SIGNED'] == 'y':
            server.append(
                "openssl req -batch -new -x509 -nodes -keyout %s "
                "-out %s -days 1095"
                % (config['CONFIG_AMQP_SSL_KEY_FILE'],
                   config['CONFIG_AMQP_SSL_CERT_FILE'])
            )
            server.execute()
    else:
        # Set default values
        config['CONFIG_AMQP_CLIENTS_PORT'] = "5672"
        config['CONFIG_AMQP_SSL_PORT'] = "5671"
        config['CONFIG_AMQP_SSL_CERT_FILE'] = ""
        config['CONFIG_AMQP_SSL_KEY_FILE'] = ""
        config['CONFIG_AMQP_NSS_CERTDB_PW'] = ""
        config['CONFIG_AMQP_ENABLE_SSL'] = 'false'
        config['CONFIG_AMQP_PROTOCOL'] = 'tcp'

    if config['CONFIG_AMQP_ENABLE_AUTH'] == 'n':
        config['CONFIG_AMQP_AUTH_PASSWORD'] = 'guest'
        config['CONFIG_AMQP_AUTH_USER'] = 'guest'

    manifestfile = "%s_amqp.pp" % config['CONFIG_AMQP_HOST']
    manifestdata = getManifestTemplate('amqp.pp')

    # All hosts should be able to talk to amqp
    config['FIREWALL_SERVICE_NAME'] = "amqp"
    config['FIREWALL_PORTS'] = "'5671', '5672'"
    config['FIREWALL_CHAIN'] = "INPUT"
    for host in filtered_hosts(config, exclude=False):
        config['FIREWALL_ALLOWED'] = "'%s'" % host
        config['FIREWALL_SERVICE_ID'] = "amqp_%s" % host
        manifestdata += getManifestTemplate("firewall.pp")

    appendManifestFile(manifestfile, manifestdata, 'pre')

########NEW FILE########
__FILENAME__ = ceilometer_800
# -*- coding: utf-8 -*-

"""
Installs and configures Ceilometer
"""

import logging
import os
import uuid

from packstack.installer import utils
from packstack.installer import validators
from packstack.modules.shortcuts import get_mq
from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-Ceilometer"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    ceilometer_params = {
        "CEILOMETER": [
            {"CONF_NAME": "CONFIG_CEILOMETER_SECRET",
             "CMD_OPTION": "ceilometer-secret",
             "USAGE": "Secret key for signing metering messages",
             "PROMPT": "Enter the Ceilometer secret key",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": uuid.uuid4().hex[:16],
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "USE_DEFAULT": True,
             "NEED_CONFIRM": True,
             "CONDITION": False},

            {"CONF_NAME": "CONFIG_CEILOMETER_KS_PW",
             "CMD_OPTION": "ceilometer-ks-passwd",
             "USAGE": ("The password to use for Ceilometer to authenticate "
                       "with Keystone"),
             "PROMPT": "Enter the password for the Ceilometer Keystone access",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": uuid.uuid4().hex[:16],
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "USE_DEFAULT": True,
             "NEED_CONFIRM": True,
             "CONDITION": False},
        ],

        "MONGODB": [
            {"CMD_OPTION": "mongodb-host",
             "USAGE": ("The IP address of the server on which to install "
                       "MongoDB"),
             "PROMPT": "Enter the IP address of the MongoDB server",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_ssh],
             "DEFAULT_VALUE": utils.get_localhost_ip(),
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_MONGODB_HOST",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],
    }

    ceilometer_groups = [
        {"GROUP_NAME": "CEILOMETER",
         "DESCRIPTION": "Ceilometer Config parameters",
         "PRE_CONDITION": "CONFIG_CEILOMETER_INSTALL",
         "PRE_CONDITION_MATCH": "y",
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "MONGODB",
         "DESCRIPTION": "MONGODB Config parameters",
         "PRE_CONDITION": "CONFIG_CEILOMETER_INSTALL",
         "PRE_CONDITION_MATCH": "y",
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},
    ]
    for group in ceilometer_groups:
        paramList = ceilometer_params[group["GROUP_NAME"]]
        controller.addGroup(group, paramList)


def initSequences(controller):
    if controller.CONF['CONFIG_CEILOMETER_INSTALL'] != 'y':
        return

    steps = [{'title': 'Adding MongoDB manifest entries',
              'functions': [create_mongodb_manifest]},
             {'title': 'Adding Ceilometer manifest entries',
              'functions': [create_manifest]},
             {'title': 'Adding Ceilometer Keystone manifest entries',
              'functions': [create_keystone_manifest]}]
    controller.addSequence("Installing OpenStack Ceilometer", [], [],
                           steps)


#-------------------------- step functions --------------------------

def create_manifest(config, messages):
    manifestfile = "%s_ceilometer.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate(get_mq(config, "ceilometer"))
    manifestdata += getManifestTemplate("ceilometer.pp")

    config['FIREWALL_ALLOWED'] = "'ALL'"
    config['FIREWALL_SERVICE_NAME'] = 'ceilometer-api'
    config['FIREWALL_SERVICE_ID'] = 'ceilometer_api'
    config['FIREWALL_PORTS'] = "'8777'"
    config['FIREWALL_CHAIN'] = "INPUT"
    manifestdata += getManifestTemplate("firewall.pp")
    # Add a template that creates a group for nova because the ceilometer
    # class needs it
    if config['CONFIG_NOVA_INSTALL'] == 'n':
        manifestdata += getManifestTemplate("ceilometer_nova_disabled.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_mongodb_manifest(config, messages):
    manifestfile = "%s_mongodb.pp" % config['CONFIG_MONGODB_HOST']
    manifestdata = getManifestTemplate("mongodb.pp")
    config['FIREWALL_ALLOWED'] = "'%s'" % config['CONFIG_CONTROLLER_HOST']
    config['FIREWALL_SERVICE_NAME'] = 'mongodb-server'
    config['FIREWALL_PORTS'] = "'27017'"
    manifestdata += getManifestTemplate("firewall.pp")
    appendManifestFile(manifestfile, manifestdata, 'pre')


def create_keystone_manifest(config, messages):
    manifestfile = "%s_keystone.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("keystone_ceilometer.pp")
    appendManifestFile(manifestfile, manifestdata)

########NEW FILE########
__FILENAME__ = cinder_250
# -*- coding: utf-8 -*-

"""
Installs and configures Cinder
"""

import os
import re
import uuid
import logging

from packstack.installer import exceptions
from packstack.installer import processors
from packstack.installer import validators
from packstack.installer.utils import split_hosts

from packstack.installer import basedefs
from packstack.installer import utils


from packstack.modules.shortcuts import get_mq
from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile)

from packstack.installer import exceptions
from packstack.installer import output_messages


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-Cinder"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    params = [
        {"CMD_OPTION": "cinder-db-passwd",
         "USAGE": "The password to use for the Cinder to access DB",
         "PROMPT": "Enter the password for the Cinder DB access",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_CINDER_DB_PW",
         "USE_DEFAULT": True,
         "NEED_CONFIRM": True,
         "CONDITION": False},

        {"CMD_OPTION": "cinder-ks-passwd",
         "USAGE": ("The password to use for the Cinder to authenticate with "
                   "Keystone"),
         "PROMPT": "Enter the password for the Cinder Keystone access",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_CINDER_KS_PW",
         "USE_DEFAULT": True,
         "NEED_CONFIRM": True,
         "CONDITION": False},

        {"CMD_OPTION": "cinder-backend",
         "USAGE": ("The Cinder backend to use, valid options are: lvm, "
                   "gluster, nfs"),
         "PROMPT": "Enter the Cinder backend to be configured",
         "OPTION_LIST": ["lvm", "gluster", "nfs"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "lvm",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_CINDER_BACKEND",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "CINDER",
             "DESCRIPTION": "Cinder Config parameters",
             "PRE_CONDITION": "CONFIG_CINDER_INSTALL",
             "PRE_CONDITION_MATCH": "y",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)

    def check_lvm_options(config):
        return (config.get('CONFIG_CINDER_INSTALL', 'n') == 'y' and
                config.get('CONFIG_CINDER_BACKEND', 'lvm') == 'lvm')

    params = [
        {"CMD_OPTION": "cinder-volumes-create",
         "USAGE": ("Create Cinder's volumes group. This should only be done "
                   "for testing on a proof-of-concept installation of Cinder. "
                   "This will create a file-backed volume group and is not "
                   "suitable for production usage."),
         "PROMPT": ("Should Cinder's volumes group be created (for "
                    "proof-of-concept installation)?"),
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "y",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_CINDER_VOLUMES_CREATE",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "CINDERVOLUMECREATE",
             "DESCRIPTION": "Cinder volume create Config parameters",
             "PRE_CONDITION": check_lvm_options,
             "PRE_CONDITION_MATCH": True,
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)

    def check_lvm_vg_options(config):
        return (config.get('CONFIG_CINDER_INSTALL', 'n') == 'y' and
                config.get('CONFIG_CINDER_BACKEND', 'lvm') == 'lvm' and
                config.get('CONFIG_CINDER_VOLUMES_CREATE', 'y') == 'y')

    params = [
        {"CMD_OPTION": "cinder-volumes-size",
         "USAGE": ("Cinder's volumes group size. Note that actual volume size "
                   "will be extended with 3% more space for VG metadata."),
         "PROMPT": "Enter Cinder's volumes group usable size",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": "20G",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_CINDER_VOLUMES_SIZE",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "CINDERVOLUMESIZE",
             "DESCRIPTION": "Cinder volume size Config parameters",
             "PRE_CONDITION": check_lvm_vg_options,
             "PRE_CONDITION_MATCH": True,
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)

    def check_gluster_options(config):
        return (config.get('CONFIG_CINDER_INSTALL', 'n') == 'y' and
                config.get('CONFIG_CINDER_BACKEND', 'lvm') == 'gluster')

    params = [
        {"CMD_OPTION": "cinder-gluster-mounts",
         "USAGE": ("A single or comma separated list of gluster volume shares "
                   "to mount, eg: ip-address:/vol-name, domain:/vol-name "),
         "PROMPT": ("Enter a single or comma separated list of gluster volume "
                    "shares to use with Cinder"),
         "OPTION_LIST": ["^'([\d]{1,3}\.){3}[\d]{1,3}:/.*'",
                         "^'[a-zA-Z0-9][\-\.\w]*:/.*'"],
         "VALIDATORS": [validators.validate_multi_regexp],
         "PROCESSORS": [processors.process_add_quotes_around_values],
         "DEFAULT_VALUE": "",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_CINDER_GLUSTER_MOUNTS",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "CINDERGLUSTERMOUNTS",
             "DESCRIPTION": "Cinder gluster Config parameters",
             "PRE_CONDITION": check_gluster_options,
             "PRE_CONDITION_MATCH": True,
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)

    def check_nfs_options(config):
        return (config.get('CONFIG_CINDER_INSTALL', 'n') == 'y' and
                config.get('CONFIG_CINDER_BACKEND', 'lvm') == 'nfs')

    params = [
        {"CMD_OPTION": "cinder-nfs-mounts",
         "USAGE": ("A single or comma seprated list of NFS exports to mount, "
                   "eg: ip-address:/export-name "),
         "PROMPT": ("Enter a single or comma seprated list of NFS exports to "
                    "use with Cinder"),
         "OPTION_LIST": ["^'([\d]{1,3}\.){3}[\d]{1,3}:/.*'"],
         "VALIDATORS": [validators.validate_multi_regexp],
         "PROCESSORS": [processors.process_add_quotes_around_values],
         "DEFAULT_VALUE": "",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_CINDER_NFS_MOUNTS",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "CINDERNFSMOUNTS",
             "DESCRIPTION": "Cinder NFS Config parameters",
             "PRE_CONDITION": check_nfs_options,
             "PRE_CONDITION_MATCH": True,
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)


def initSequences(controller):
    if controller.CONF['CONFIG_CINDER_INSTALL'] != 'y':
        return

    cinder_steps = [
        {'title': 'Installing dependencies for Cinder',
         'functions': [install_cinder_deps]},
        {'title': 'Adding Cinder Keystone manifest entries',
         'functions': [create_keystone_manifest]},
        {'title': 'Adding Cinder manifest entries',
         'functions': [create_manifest]}
    ]

    if controller.CONF['CONFIG_CINDER_BACKEND'] == 'lvm':
        cinder_steps.append(
            {'title': 'Checking if the Cinder server has a cinder-volumes vg',
             'functions': [check_cinder_vg]})
    controller.addSequence("Installing OpenStack Cinder", [], [], cinder_steps)


#-------------------------- step functions --------------------------

def install_cinder_deps(config, messages):
    server = utils.ScriptRunner(config['CONFIG_CONTROLLER_HOST'])
    pkgs = []
    if config['CONFIG_CINDER_BACKEND'] == 'lvm':
        pkgs.append('lvm2')
    for p in pkgs:
        server.append("rpm -q --whatprovides %(package)s || "
                      "yum install -y %(package)s" % dict(package=p))
    server.execute()


def check_cinder_vg(config, messages):
    cinders_volume = 'cinder-volumes'

    # Do we have a cinder-volumes vg?
    have_cinders_volume = False
    server = utils.ScriptRunner(config['CONFIG_CONTROLLER_HOST'])
    server.append('vgdisplay %s' % cinders_volume)
    try:
        server.execute()
        have_cinders_volume = True
    except exceptions.ScriptRuntimeError:
        pass

    # Configure system LVM settings (snapshot_autoextend)
    server = utils.ScriptRunner(config['CONFIG_CONTROLLER_HOST'])
    server.append('sed -i -r "s/^ *snapshot_autoextend_threshold +=.*/'
                  '    snapshot_autoextend_threshold = 80/" '
                  '/etc/lvm/lvm.conf')
    server.append('sed -i -r "s/^ *snapshot_autoextend_percent +=.*/'
                  '    snapshot_autoextend_percent = 20/" '
                  '/etc/lvm/lvm.conf')
    try:
        server.execute()
    except exceptions.ScriptRuntimeError:
        logging.info("Warning: Unable to set system LVM settings.")

    if config["CONFIG_CINDER_VOLUMES_CREATE"] != "y":
        if not have_cinders_volume:
            raise exceptions.MissingRequirements("The cinder server should "
                                                 "contain a cinder-volumes "
                                                 "volume group")
    else:
        if have_cinders_volume:
            messages.append(
                output_messages.INFO_CINDER_VOLUMES_EXISTS)
            return

        server = utils.ScriptRunner(config['CONFIG_CONTROLLER_HOST'])
        server.append('systemctl')
        try:
            server.execute()
            rst_cmd = 'systemctl restart openstack-cinder-volume.service'
        except exceptions.ScriptRuntimeError:
            rst_cmd = 'service openstack-cinder-volume restart'

        server.clear()
        logging.info("A new cinder volumes group will be created")

        cinders_volume_path = '/var/lib/cinder'
        server.append('mkdir -p  %s' % cinders_volume_path)
        logging.debug("Volume's path: %s" % cinders_volume_path)

        match = re.match('^(?P<size>\d+)G$',
                         config['CONFIG_CINDER_VOLUMES_SIZE'].strip())
        if not match:
            msg = 'Invalid Cinder volumes VG size.'
            raise exceptions.ParamValidationError(msg)

        cinders_volume_size = int(match.group('size')) * 1024
        cinders_reserve = int(cinders_volume_size * 0.03)

        cinders_volume_size = cinders_volume_size + cinders_reserve
        cinders_volume_path = os.path.join(cinders_volume_path, cinders_volume)
        server.append('dd if=/dev/zero of=%s bs=1 count=0 seek=%sM'
                      % (cinders_volume_path, cinders_volume_size))
        server.append('LOFI=$(losetup --show -f  %s)' % cinders_volume_path)
        server.append('pvcreate $LOFI')
        server.append('vgcreate %s $LOFI' % cinders_volume)

        # Add the loop device on boot
        server.append('grep %(volume)s /etc/rc.d/rc.local || '
                      'echo "losetup -f %(path)s && '
                      'vgchange -a y %(volume)s && '
                      '%(restart_cmd)s" '
                      '>> /etc/rc.d/rc.local' %
                      {'volume': cinders_volume, 'restart_cmd': rst_cmd,
                       'path': cinders_volume_path})
        server.append('grep "#!" /etc/rc.d/rc.local || '
                      'sed -i \'1i#!/bin/sh\' /etc/rc.d/rc.local')
        server.append('chmod +x /etc/rc.d/rc.local')

        # Let's make sure it exists
        server.append('vgdisplay %s' % cinders_volume)

        try:
            server.execute()
        except exceptions.ScriptRuntimeError:
            # Release loop device if cinder's volume creation
            # fails.
            try:
                logging.debug("Release loop device, volume creation failed")
                server = utils.ScriptRunner(config['CONFIG_CONTROLLER_HOST'])
                server.append('losetup -d $(losetup -j %s | cut -d : -f 1)'
                              % cinders_volume_path)
                server.execute()
            except:
                pass

            raise exceptions.MissingRequirements("Cinder's volume group '%s' "
                                                 "could not be created"
                                                 % cinders_volume)


def create_keystone_manifest(config, messages):
    manifestfile = "%s_keystone.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("keystone_cinder.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_manifest(config, messages):
    manifestdata = getManifestTemplate(get_mq(config, "cinder"))
    manifestfile = "%s_cinder.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata += getManifestTemplate("cinder.pp")

    if config['CONFIG_CINDER_BACKEND'] == "gluster":
        manifestdata += getManifestTemplate("cinder_gluster.pp")
    if config['CONFIG_CINDER_BACKEND'] == "nfs":
        manifestdata += getManifestTemplate("cinder_nfs.pp")
    if config['CONFIG_CINDER_BACKEND'] == "vmdk":
        manifestdata += getManifestTemplate("cinder_vmdk.pp")
    if config['CONFIG_CEILOMETER_INSTALL'] == 'y':
        manifestdata += getManifestTemplate('cinder_ceilometer.pp')
    if config['CONFIG_SWIFT_INSTALL'] == 'y':
        manifestdata += getManifestTemplate('cinder_backup.pp')

    config['FIREWALL_SERVICE_NAME'] = "cinder"
    config['FIREWALL_PORTS'] = "'3260', '8776'"
    config['FIREWALL_CHAIN'] = "INPUT"

    if (config['CONFIG_NOVA_INSTALL'] == 'y' and
            config['CONFIG_VMWARE_BACKEND'] == 'n'):
        for host in split_hosts(config['CONFIG_COMPUTE_HOSTS']):
            config['FIREWALL_ALLOWED'] = "'%s'" % host
            config['FIREWALL_SERVICE_ID'] = "cinder_%s" % host
            manifestdata += getManifestTemplate("firewall.pp")
    else:
        config['FIREWALL_ALLOWED'] = "'ALL'"
        config['FIREWALL_SERVICE_ID'] = "cinder_ALL"
        manifestdata += getManifestTemplate("firewall.pp")

    appendManifestFile(manifestfile, manifestdata)

########NEW FILE########
__FILENAME__ = dashboard_500
# -*- coding: utf-8 -*-

"""
Installs and configures OpenStack Horizon
"""

import logging
import os
import uuid

from packstack.installer import validators
from packstack.installer import basedefs, output_messages
from packstack.installer import exceptions
from packstack.installer import utils

from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-Horizon"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    params = [
        {"CMD_OPTION": "os-horizon-ssl",
         "USAGE": "To set up Horizon communication over https set this to 'y'",
         "PROMPT": "Would you like to set up Horizon communication over https",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "n",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_HORIZON_SSL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "OSHORIZON",
             "DESCRIPTION": "OpenStack Horizon Config parameters",
             "PRE_CONDITION": "CONFIG_HORIZON_INSTALL",
             "PRE_CONDITION_MATCH": "y",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)

    params = [
        {"CMD_OPTION": "os-ssl-cert",
         "USAGE": ("PEM encoded certificate to be used for ssl on the https "
                   "server, leave blank if one should be generated, this "
                   "certificate should not require a passphrase"),
         "PROMPT": ("Enter the path to a PEM encoded certificate to be used "
                    "on the https server, leave blank if one should be "
                    "generated, this certificate should not require "
                    "a passphrase"),
         "OPTION_LIST": [],
         "VALIDATORS": [],
         "DEFAULT_VALUE": '',
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_SSL_CERT",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-ssl-key",
         "USAGE": ("SSL keyfile corresponding to the certificate if one was "
                   "entered"),
         "PROMPT": ("Enter the SSL keyfile corresponding to the certificate "
                    "if one was entered"),
         "OPTION_LIST": [],
         "VALIDATORS": [],
         "DEFAULT_VALUE": "",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_SSL_KEY",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "OSSSL",
             "DESCRIPTION": "SSL Config parameters",
             "PRE_CONDITION": "CONFIG_HORIZON_SSL",
             "PRE_CONDITION_MATCH": "y",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)


def initSequences(controller):
    if controller.CONF['CONFIG_HORIZON_INSTALL'] != 'y':
        return

    steps = [
        {'title': 'Adding Horizon manifest entries',
         'functions': [create_manifest]}
    ]
    controller.addSequence("Installing OpenStack Horizon", [], [], steps)


#-------------------------- step functions --------------------------

def create_manifest(config, messages):
    config["CONFIG_HORIZON_SECRET_KEY"] = uuid.uuid4().hex
    horizon_host = config['CONFIG_CONTROLLER_HOST']
    manifestfile = "%s_horizon.pp" % horizon_host

    proto = "http"
    config["CONFIG_HORIZON_PORT"] = "'80'"
    sslmanifestdata = ''
    if config["CONFIG_HORIZON_SSL"] == 'y':
        config["CONFIG_HORIZON_PORT"] = "'443'"
        proto = "https"
        sslmanifestdata += getManifestTemplate("https.pp")

        # Are we using the users cert/key files
        if config["CONFIG_SSL_CERT"]:
            ssl_cert = config["CONFIG_SSL_CERT"]
            ssl_key = config["CONFIG_SSL_KEY"]

            if not os.path.exists(ssl_cert):
                raise exceptions.ParamValidationError(
                    "The file %s doesn't exist" % ssl_cert)

            if ssl_key and not os.path.exists(ssl_key):
                raise exceptions.ParamValidationError(
                    "The file %s doesn't exist" % ssl_key)

            resources = config.setdefault('RESOURCES', {})
            host_resources = resources.setdefault(horizon_host, [])
            host_resources.append((ssl_cert, 'ssl_ps_server.crt'))
            if ssl_key:
                host_resources.append(ssl_key, 'ssl_ps_server.key')
        else:
            messages.append(
                "%sNOTE%s : A certificate was generated to be used for ssl, "
                "You should change the ssl certificate configured in "
                "/etc/httpd/conf.d/ssl.conf on %s to use a CA signed cert."
                % (utils.COLORS['red'], utils.COLORS['nocolor'], horizon_host))

    manifestdata = getManifestTemplate("horizon.pp")
    manifestdata += sslmanifestdata
    appendManifestFile(manifestfile, manifestdata)

    msg = ("To access the OpenStack Dashboard browse to %s://%s/dashboard .\n"
           "Please, find your login credentials stored in the keystonerc_admin"
           " in your home directory."
           % (proto, config['CONFIG_CONTROLLER_HOST']))
    messages.append(msg)

########NEW FILE########
__FILENAME__ = glance_200
# -*- coding: utf-8 -*-

"""
Installs and configures Glance
"""

import uuid
import logging

from packstack.installer import validators
from packstack.installer import basedefs
from packstack.installer import utils
from packstack.installer.utils import split_hosts

from packstack.modules.shortcuts import get_mq
from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile)

#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-Glance"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    params = [
        {"CMD_OPTION": "glance-db-passwd",
         "USAGE": "The password to use for the Glance to access DB",
         "PROMPT": "Enter the password for the Glance DB access",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_GLANCE_DB_PW",
         "USE_DEFAULT": True,
         "NEED_CONFIRM": True,
         "CONDITION": False},

        {"CMD_OPTION": "glance-ks-passwd",
         "USAGE": ("The password to use for the Glance to authenticate "
                   "with Keystone"),
         "PROMPT": "Enter the password for the Glance Keystone access",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_GLANCE_KS_PW",
         "USE_DEFAULT": True,
         "NEED_CONFIRM": True,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "GLANCE",
             "DESCRIPTION": "Glance Config parameters",
             "PRE_CONDITION": "CONFIG_GLANCE_INSTALL",
             "PRE_CONDITION_MATCH": "y",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)


def initSequences(controller):
    conf = controller.CONF
    if conf['CONFIG_GLANCE_INSTALL'] != 'y':
        if conf['CONFIG_NOVA_INSTALL'] == 'y':
            raise RuntimeError('Glance is required to install Nova properly. '
                               'Please set CONFIG_GLANCE_INSTALL=y')
        return

    glancesteps = [
        {'title': 'Adding Glance Keystone manifest entries',
         'functions': [create_keystone_manifest]},
        {'title': 'Adding Glance manifest entries',
         'functions': [create_manifest]}
    ]
    controller.addSequence("Installing OpenStack Glance", [], [], glancesteps)


#-------------------------- step functions --------------------------

def create_keystone_manifest(config, messages):
    manifestfile = "%s_keystone.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("keystone_glance.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_manifest(config, messages):
    manifestfile = "%s_glance.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("glance.pp")
    if config['CONFIG_CEILOMETER_INSTALL'] == 'y':
        mq_template = get_mq(config, "glance_ceilometer")
        manifestdata += getManifestTemplate(mq_template)

    config['FIREWALL_SERVICE_NAME'] = "glance"
    config['FIREWALL_PORTS'] = "'9292'"
    config['FIREWALL_CHAIN'] = "INPUT"
    if config['CONFIG_NOVA_INSTALL'] == 'y':
        for host in split_hosts(config['CONFIG_COMPUTE_HOSTS']):
            config['FIREWALL_ALLOWED'] = "'%s'" % host
            config['FIREWALL_SERVICE_ID'] = "glance_%s" % host
            manifestdata += getManifestTemplate("firewall.pp")
    else:
        config['FIREWALL_ALLOWED'] = "'ALL'"
        config['FIREWALL_SERVICE_ID'] = "glance_ALL"
        manifestdata += getManifestTemplate("firewall.pp")

    appendManifestFile(manifestfile, manifestdata)

########NEW FILE########
__FILENAME__ = heat_750
# -*- coding: utf-8 -*-

"""
Installs and configures heat
"""

import uuid
import logging
import os

from packstack.installer import utils
from packstack.installer import validators

from packstack.modules.shortcuts import get_mq
from packstack.modules.ospluginutils import (getManifestTemplate,
                                             manifestfiles,
                                             appendManifestFile)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-Heat"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    parameters = [
        {"CMD_OPTION": "os-heat-mysql-password",
         "USAGE": ('The password used by Heat user to authenticate against '
                   'MySQL'),
         "PROMPT": "Enter the password for the Heat MySQL user",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_HEAT_DB_PW",
         "USE_DEFAULT": True,
         "NEED_CONFIRM": True,
         "CONDITION": False},

        {"CMD_OPTION": "heat-auth-encryption-key",
         "USAGE": ("The encryption key to use for authentication info "
                   "in database"),
         "PROMPT": ("Enter the authentication key for Heat to use for "
                    "authenticate info in database"),
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_HEAT_AUTH_ENC_KEY",
         "USE_DEFAULT": True,
         "NEED_CONFIRM": True,
         "CONDITION": False},

        {"CMD_OPTION": "os-heat-ks-passwd",
         "USAGE": ("The password to use for the Heat to authenticate "
                   "with Keystone"),
         "PROMPT": "Enter the password for the Heat Keystone access",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_HEAT_KS_PW",
         "USE_DEFAULT": True,
         "NEED_CONFIRM": True,
         "CONDITION": False},

        {"CMD_OPTION": "os-heat-cloudwatch-install",
         "USAGE": ("Set to 'y' if you would like Packstack to install Heat "
                   "CloudWatch API"),
         "PROMPT": "Should Packstack install Heat CloudWatch API",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "n",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_HEAT_CLOUDWATCH_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-heat-cfn-install",
         "USAGE": ("Set to 'y' if you would like Packstack to install Heat "
                   "CloudFormation API"),
         "PROMPT": "Should Packstack install Heat CloudFormation API",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "n",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_HEAT_CFN_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "Heat",
             "DESCRIPTION": "Heat Config parameters",
             "PRE_CONDITION": "CONFIG_HEAT_INSTALL",
             "PRE_CONDITION_MATCH": "y",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, parameters)


def initSequences(controller):
    config = controller.CONF
    if config['CONFIG_HEAT_INSTALL'] != 'y':
        return
    steps = [
        {'title': 'Adding Heat manifest entries',
         'functions': [create_manifest]},
        {'title': 'Adding Heat Keystone manifest entries',
         'functions': [create_keystone_manifest]}
    ]

    if config.get('CONFIG_HEAT_CLOUDWATCH_INSTALL', 'n') == 'y':
        steps.append(
            {'title': 'Adding Heat CloudWatch API manifest entries',
             'functions': [create_cloudwatch_manifest]})
    if config.get('CONFIG_HEAT_CFN_INSTALL', 'n') == 'y':
        steps.append(
            {'title': 'Adding Heat CloudFormation API manifest entries',
             'functions': [create_cfn_manifest]})
    controller.addSequence("Installing Heat", [], [], steps)


#-------------------------- step functions --------------------------

def create_manifest(config, messages):
    manifestfile = "%s_heat.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate(get_mq(config, "heat"))
    manifestdata += getManifestTemplate("heat.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_keystone_manifest(config, messages):
    manifestfile = "%s_keystone.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("keystone_heat.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_cloudwatch_manifest(config, messages):
    manifestfile = "%s_heatcw.pp" % controller.CONF['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate(get_mq(config, "heat"))
    manifestdata += getManifestTemplate("heat_cloudwatch.pp")
    appendManifestFile(manifestfile, manifestdata, marker='heat')


def create_cfn_manifest(config, messages):
    manifestfile = "%s_heatcnf.pp" % controller.CONF['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate(get_mq(config, "heat"))
    manifestdata += getManifestTemplate("heat_cfn.pp")
    appendManifestFile(manifestfile, manifestdata, marker='heat')

########NEW FILE########
__FILENAME__ = keystone_100
# -*- coding: utf-8 -*-

"""
Installs and configures Keystone
"""

import logging
import uuid

from packstack.installer import validators
from packstack.installer import basedefs
from packstack.installer import utils

from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-Keystone"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    params = [
        {"CMD_OPTION": "keystone-db-passwd",
         "USAGE": "The password to use for the Keystone to access DB",
         "PROMPT": "Enter the password for the Keystone DB access",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_KEYSTONE_DB_PW",
         "USE_DEFAULT": True,
         "NEED_CONFIRM": True,
         "CONDITION": False},

        {"CMD_OPTION": "keystone-admin-token",
         "USAGE": "The token to use for the Keystone service api",
         "PROMPT": "The token to use for the Keystone service api",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex,
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_KEYSTONE_ADMIN_TOKEN",
         "USE_DEFAULT": True,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "keystone-admin-passwd",
         "USAGE": "The password to use for the Keystone admin user",
         "PROMPT": "Enter the password for the Keystone admin user",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_KEYSTONE_ADMIN_PW",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": True,
         "CONDITION": False},

        {"CMD_OPTION": "keystone-demo-passwd",
         "USAGE": "The password to use for the Keystone demo user",
         "PROMPT": "Enter the password for the Keystone demo user",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_KEYSTONE_DEMO_PW",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": True,
         "CONDITION": False},

        {"CMD_OPTION": "keystone-token-format",
         "USAGE": "Kestone token format. Use either UUID or PKI",
         "PROMPT": "Enter the Keystone token format.",
         "OPTION_LIST": ['UUID', 'PKI'],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": 'PKI',
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": 'CONFIG_KEYSTONE_TOKEN_FORMAT',
         "USE_DEFAULT": True,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "KEYSTONE",
             "DESCRIPTION": "Keystone Config parameters",
             "PRE_CONDITION": lambda x: 'yes',
             "PRE_CONDITION_MATCH": "yes",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)


def initSequences(controller):
    keystonesteps = [
        {'title': 'Adding Keystone manifest entries',
         'functions': [create_manifest]},
    ]
    controller.addSequence("Installing OpenStack Keystone", [], [],
                           keystonesteps)


#-------------------------- step functions --------------------------

def create_manifest(config, messages):
    manifestfile = "%s_keystone.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("keystone.pp")

    config['FIREWALL_ALLOWED'] = "'ALL'"
    config['FIREWALL_SERVICE_NAME'] = "keystone"
    config['FIREWALL_SERVICE_ID'] = "keystone"
    config['FIREWALL_PORTS'] = "'5000', '35357'"
    config['FIREWALL_CHAIN'] = "INPUT"
    manifestdata += getManifestTemplate("firewall.pp")

    appendManifestFile(manifestfile, manifestdata)

########NEW FILE########
__FILENAME__ = mysql_001
# -*- coding: utf-8 -*-

"""
Installs and configures MySQL
"""

import uuid
import logging

from packstack.installer import validators
from packstack.installer import utils
from packstack.installer.utils import split_hosts

from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "MySQL"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    params = [
        {"CMD_OPTION": "mysql-host",
         "USAGE": ("The IP address of the server on which to install MySQL or "
                   "IP address of DB server to use if MySQL installation was "
                   "not selected"),
         "PROMPT": "Enter the IP address of the MySQL server",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_ssh],
         "DEFAULT_VALUE": utils.get_localhost_ip(),
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_MYSQL_HOST",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "mysql-user",
         "USAGE": "Username for the MySQL admin user",
         "PROMPT": "Enter the username for the MySQL admin user",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": "root",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_MYSQL_USER",
         "USE_DEFAULT": True,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "mysql-pw",
         "USAGE": "Password for the MySQL admin user",
         "PROMPT": "Enter the password for the MySQL admin user",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_MYSQL_PW",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": True,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "MYSQL",
             "DESCRIPTION": "MySQL Config parameters",
             "PRE_CONDITION": lambda x: 'yes',
             "PRE_CONDITION_MATCH": "yes",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)


def initSequences(controller):
    mysqlsteps = [
        {'title': 'Adding MySQL manifest entries',
         'functions': [create_manifest]}
    ]
    controller.addSequence("Installing MySQL", [], [], mysqlsteps)


#-------------------------- step functions --------------------------

def create_manifest(config, messages):
    if config['CONFIG_MYSQL_INSTALL'] == 'y':
        install = True
        suffix = 'install'
    else:
        install = False
        suffix = 'noinstall'

    manifestfile = "%s_mysql.pp" % config['CONFIG_MYSQL_HOST']
    manifestdata = [getManifestTemplate('mysql_%s.pp' % suffix)]

    def append_for(module, suffix):
        # Modules have to be appended to the existing mysql.pp
        # otherwise pp will fail for some of them saying that
        # Mysql::Config definition is missing.
        template = "mysql_%s_%s.pp" % (module, suffix)
        manifestdata.append(getManifestTemplate(template))

    append_for("keystone", suffix)
    for mod in ['nova', 'cinder', 'glance', 'neutron', 'heat']:
        if config['CONFIG_%s_INSTALL' % mod.upper()] == 'y':
            append_for(mod, suffix)

    hosts = set([config['CONFIG_CONTROLLER_HOST']])
    hosts |= split_hosts(config['CONFIG_COMPUTE_HOSTS'])

    config['FIREWALL_SERVICE_NAME'] = "mysql"
    config['FIREWALL_PORTS'] = "'3306'"
    config['FIREWALL_CHAIN'] = "INPUT"
    for host in hosts:
        config['FIREWALL_ALLOWED'] = "'%s'" % host
        config['FIREWALL_SERVICE_ID'] = "mysql_%s" % host
        manifestdata.append(getManifestTemplate("firewall.pp"))

    appendManifestFile(manifestfile, "\n".join(manifestdata), 'pre')

########NEW FILE########
__FILENAME__ = nagios_910
# -*- coding: utf-8 -*-

"""
Installs and configures Nagios
"""

import uuid
import logging

from packstack.installer import validators
from packstack.installer import basedefs, output_messages
from packstack.installer import utils

from packstack.modules.common import filtered_hosts
from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-Nagios"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    params = [
        {"CMD_OPTION": "nagios-passwd",
         "USAGE": "The password of the nagiosadmin user on the Nagios server",
         "PROMPT": "Enter the password for the nagiosadmin user",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_NAGIOS_PW",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "NAGIOS",
             "DESCRIPTION": "Nagios Config parameters",
             "PRE_CONDITION": "CONFIG_NAGIOS_INSTALL",
             "PRE_CONDITION_MATCH": "y",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)


def initSequences(controller):
    if controller.CONF['CONFIG_NAGIOS_INSTALL'] != 'y':
        return

    nagiossteps = [
        {'title': 'Adding Nagios server manifest entries',
         'functions': [create_manifest]},
        {'title': 'Adding Nagios host manifest entries',
         'functions': [create_nrpe_manifests]}
    ]
    controller.addSequence("Installing Nagios", [], [], nagiossteps)


#------------------------- helper functions -------------------------

def _serviceentry(**kwargs):
    s = 'define service {\n'
    for key in sorted(kwargs.keys()):
        s += "\t%s\t%s\n" % (key, kwargs[key])
    s += "\t}\n"
    return s


def _copy_script(**kwargs):
    # TODO : Replace all these shell templates with with python
    return ('file{"/usr/lib64/nagios/plugins/%(name)s":'
            'mode => 755, owner => "nagios", '
            'seltype => "nagios_unconfined_plugin_exec_t", '
            'content => template("packstack/%(name)s.erb"),}\n'
            'nagios_command {"%(name)s": '
            'command_line => "/usr/lib64/nagios/plugins/%(name)s",}\n'
            % kwargs)


def nagios_host(hostname, **kwargs):
    out = ("nagios_host { '%s': " % hostname)
    for key, value in kwargs.items():
        out = "%s, %s => '%s'" % (out, key, value)
    return "%s}\n" % out


#-------------------------- step functions --------------------------

def create_manifest(config, messages):
    manifest_entries = ''
    # I should be adding service entries with nagios_service
    # but it appears to be broken http://projects.puppetlabs.com/issues/3420
    service_entries = ''
    for hostname in filtered_hosts(config):
        manifest_entries += nagios_host(hostname, address=hostname,
                                        use='linux-server')

        service_entries += _serviceentry(
            name='load5-%s' % hostname,
            service_description='5 minute load average',
            host_name=hostname,
            check_command="check_nrpe!load5",
            use="generic-service",
            normal_check_interval='5'
        )

        service_entries += _serviceentry(
            name='df_var-%s' % hostname,
            service_description='Percent disk space used on /var',
            host_name=hostname,
            check_command="check_nrpe!df_var",
            use="generic-service"
        )

    manifest_entries += _copy_script(name="keystone-user-list")
    service_entries += _serviceentry(
        name='keystone-user-list',
        service_description='number of keystone users',
        host_name=config['CONFIG_CONTROLLER_HOST'],
        check_command="keystone-user-list",
        use="generic-service",
        normal_check_interval='5'
    )

    if config['CONFIG_GLANCE_INSTALL'] == 'y':
        manifest_entries += _copy_script(name="glance-index")
        service_entries += _serviceentry(
            name='glance-index',
            service_description='number of glance images',
            host_name=config['CONFIG_CONTROLLER_HOST'],
            check_command="glance-index", use="generic-service",
            normal_check_interval='5'
        )

    if config['CONFIG_NOVA_INSTALL'] == 'y':
        manifest_entries += _copy_script(name="nova-list")
        service_entries += _serviceentry(
            name='nova-list',
            service_description='number of nova vm instances',
            host_name=config['CONFIG_CONTROLLER_HOST'],
            check_command="nova-list", use="generic-service",
            normal_check_interval='5'
        )

    if config['CONFIG_CINDER_INSTALL'] == 'y':
        manifest_entries += _copy_script(name="cinder-list")
        service_entries += _serviceentry(
            name='cinder-list',
            service_description='number of cinder volumes',
            host_name=config['CONFIG_CONTROLLER_HOST'],
            check_command="cinder-list", use="generic-service",
            normal_check_interval='5'
        )

    if config['CONFIG_SWIFT_INSTALL'] == 'y':
        manifest_entries += _copy_script(name="swift-list")
        service_entries += _serviceentry(
            name='swift-list',
            service_description='number of swift containers',
            host_name=config['CONFIG_CONTROLLER_HOST'],
            check_command="swift-list", use="generic-service",
            normal_check_interval='5'
        )

    manifest_entries += ("file { '/etc/nagios/nagios_service.cfg': \n"
                         "ensure => present, mode => 644,\n"
                         "owner => 'nagios', group => 'nagios',\n"
                         "before => Service['nagios'],\n"
                         "content => '%s'}" % service_entries)

    config['CONFIG_NAGIOS_MANIFEST_CONFIG'] = manifest_entries

    manifestfile = "%s_nagios.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("nagios_server.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_nrpe_manifests(config, messages):
    for hostname in filtered_hosts(config):
        config['CONFIG_NRPE_HOST'] = hostname
        manifestfile = "%s_nagios_nrpe.pp" % hostname
        manifestdata = getManifestTemplate("nagios_nrpe.pp")
        # Only the Nagios host is allowed to talk to nrpe
        config['FIREWALL_ALLOWED'] = "'%s'" % config['CONFIG_CONTROLLER_HOST']
        config['FIREWALL_SERVICE_NAME'] = "nagios-nrpe"
        config['FIREWALL_SERVICE_ID'] = "nagios_nrpe"
        config['FIREWALL_PORTS'] = '5666'
        config['FIREWALL_CHAIN'] = "INPUT"
        manifestdata += getManifestTemplate("firewall.pp")
        appendManifestFile(manifestfile, manifestdata)

    messages.append("To use Nagios, browse to "
                    "http://%(CONFIG_CONTROLLER_HOST)s/nagios "
                    "username: nagiosadmin, password: %(CONFIG_NAGIOS_PW)s"
                    % config)

########NEW FILE########
__FILENAME__ = neutron_350
# -*- coding: utf-8 -*-

"""
Installs and configures neutron
"""

import logging
import os
import re
import uuid

from packstack.installer import utils
from packstack.installer import validators
from packstack.installer.utils import split_hosts

from packstack.modules.shortcuts import get_mq
from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-Neutron"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    conf_params = {
        "NEUTRON": [
            {"CMD_OPTION": "os-neutron-ks-password",
             "USAGE": ("The password to use for Neutron to authenticate "
                       "with Keystone"),
             "PROMPT": "Enter the password for Neutron Keystone access",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": uuid.uuid4().hex[:16],
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_NEUTRON_KS_PW",
             "USE_DEFAULT": True,
             "NEED_CONFIRM": True,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-db-password",
             "USAGE": "The password to use for Neutron to access DB",
             "PROMPT": "Enter the password for Neutron DB access",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": uuid.uuid4().hex[:16],
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_NEUTRON_DB_PW",
             "USE_DEFAULT": True,
             "NEED_CONFIRM": True,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-l3-ext-bridge",
             "USAGE": ("The name of the bridge that the Neutron L3 agent will "
                       "use for external traffic, or 'provider' if using "
                       "provider networks"),
             "PROMPT": ("Enter the bridge the Neutron L3 agent will use for "
                        "external traffic, or 'provider' if using provider "
                        "networks"),
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": "br-ex",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NEUTRON_L3_EXT_BRIDGE",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-l2-plugin",
             "USAGE": "The name of the L2 plugin to be used with Neutron",
             "PROMPT": ("Enter the name of the L2 plugin to be used "
                        "with Neutron"),
             "OPTION_LIST": ["linuxbridge", "openvswitch", "ml2"],
             "VALIDATORS": [validators.validate_options],
             "DEFAULT_VALUE": "openvswitch",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_NEUTRON_L2_PLUGIN",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-metadata-pw",
             "USAGE": "Neutron metadata agent password",
             "PROMPT": "Enter Neutron metadata agent password",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": uuid.uuid4().hex[:16],
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_NEUTRON_METADATA_PW",
             "USE_DEFAULT": True,
             "NEED_CONFIRM": True,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-lbaas-install",
             "USAGE": ("Set to 'y' if you would like Packstack to install "
                       "Neutron LBaaS"),
             "PROMPT": "Should Packstack install Neutron LBaaS",
             "OPTION_LIST": ["y", "n"],
             "VALIDATORS": [validators.validate_options],
             "DEFAULT_VALUE": "n",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_LBAAS_INSTALL",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],

        "NEUTRON_LB_PLUGIN": [
            {"CMD_OPTION": "os-neutron-lb-tenant-network-type",
             "USAGE": ("The type of network to allocate for tenant networks "
                       "(eg. vlan, local)"),
             "PROMPT": ("Enter the type of network to allocate for tenant "
                        "networks"),
             "OPTION_LIST": ["local", "vlan"],
             "VALIDATORS": [validators.validate_options],
             "DEFAULT_VALUE": "local",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_NEUTRON_LB_TENANT_NETWORK_TYPE",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-lb-vlan-ranges",
             "USAGE": ("A comma separated list of VLAN ranges for the Neutron "
                       "linuxbridge plugin (eg. physnet1:1:4094,physnet2,"
                       "physnet3:3000:3999)"),
             "PROMPT": ("Enter a comma separated list of VLAN ranges for "
                        "the Neutron linuxbridge plugin"),
             "OPTION_LIST": [],
             "VALIDATORS": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NEUTRON_LB_VLAN_RANGES",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],

        "NEUTRON_LB_PLUGIN_AND_AGENT": [
            {"CMD_OPTION": "os-neutron-lb-interface-mappings",
             "USAGE": ("A comma separated list of interface mappings for the "
                       "Neutron linuxbridge plugin (eg. physnet1:br-eth1,"
                       "physnet2:br-eth2,physnet3:br-eth3)"),
             "PROMPT": ("Enter a comma separated list of interface mappings "
                        "for the Neutron linuxbridge plugin"),
             "OPTION_LIST": [],
             "VALIDATORS": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NEUTRON_LB_INTERFACE_MAPPINGS",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],

        "NEUTRON_OVS_PLUGIN": [
            {"CMD_OPTION": "os-neutron-ovs-tenant-network-type",
             "USAGE": ("Type of network to allocate for tenant networks "
                       "(eg. vlan, local, gre, vxlan)"),
             "PROMPT": ("Enter the type of network to allocate for tenant "
                        "networks"),
             "OPTION_LIST": ["local", "vlan", "gre", "vxlan"],
             "VALIDATORS": [validators.validate_options],
             "DEFAULT_VALUE": "local",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_NEUTRON_OVS_TENANT_NETWORK_TYPE",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-ovs-vlan-ranges",
             "USAGE": ("A comma separated list of VLAN ranges for the Neutron "
                       "openvswitch plugin (eg. physnet1:1:4094,physnet2,"
                       "physnet3:3000:3999)"),
             "PROMPT": ("Enter a comma separated list of VLAN ranges for the "
                        "Neutron openvswitch plugin"),
             "OPTION_LIST": [],
             "VALIDATORS": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NEUTRON_OVS_VLAN_RANGES",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],

        "NEUTRON_OVS_PLUGIN_AND_AGENT": [
            {"CMD_OPTION": "os-neutron-ovs-bridge-mappings",
             "USAGE": ("A comma separated list of bridge mappings for the "
                       "Neutron openvswitch plugin (eg. physnet1:br-eth1,"
                       "physnet2:br-eth2,physnet3:br-eth3)"),
             "PROMPT": ("Enter a comma separated list of bridge mappings for "
                        "the Neutron openvswitch plugin"),
             "OPTION_LIST": [],
             "VALIDATORS": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NEUTRON_OVS_BRIDGE_MAPPINGS",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-ovs-bridge-interfaces",
             "USAGE": ("A comma separated list of colon-separated OVS "
                       "bridge:interface pairs. The interface will be added "
                       "to the associated bridge."),
             "PROMPT": ("Enter a comma separated list of OVS bridge:interface "
                        "pairs for the Neutron openvswitch plugin"),
             "OPTION_LIST": [],
             "VALIDATORS": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NEUTRON_OVS_BRIDGE_IFACES",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],

        "NEUTRON_OVS_PLUGIN_TUNNEL": [
            {"CMD_OPTION": "os-neutron-ovs-tunnel-ranges",
             "USAGE": ("A comma separated list of tunnel ranges for the "
                       "Neutron openvswitch plugin (eg. 1:1000)"),
             "PROMPT": ("Enter a comma separated list of tunnel ranges for "
                        "the Neutron openvswitch plugin"),
             "OPTION_LIST": [],
             "VALIDATORS": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NEUTRON_OVS_TUNNEL_RANGES",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],

        "NEUTRON_OVS_PLUGIN_AND_AGENT_TUNNEL": [
            {"CMD_OPTION": "os-neutron-ovs-tunnel-if",
             "USAGE": ("The interface for the OVS tunnel. Packstack will "
                       "override the IP address used for tunnels on this "
                       "hypervisor to the IP found on the specified interface."
                       " (eg. eth1)"),
             "PROMPT": ("Enter interface with IP to override the default "
                        "tunnel local_ip"),
             "OPTION_LIST": [],
             "VALIDATORS": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NEUTRON_OVS_TUNNEL_IF",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],

        "NEUTRON_OVS_PLUGIN_AND_AGENT_VXLAN": [
            {"CMD_OPTION": "os-neutron-ovs-vxlan-udp-port",
             "CONF_NAME": "CONFIG_NEUTRON_OVS_VXLAN_UDP_PORT",
             "USAGE": "VXLAN UDP port",
             "PROMPT": "Enter VXLAN UDP port number",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_port],
             "DEFAULT_VALUE": 4789,
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,

             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],

        "NEUTRON_ML2_PLUGIN": [
            {"CMD_OPTION": "os-neutron-ml2-type-drivers",
             "CONF_NAME": "CONFIG_NEUTRON_ML2_TYPE_DRIVERS",
             "USAGE": ("A comma separated list of network type driver "
                       "entrypoints to be loaded from the "
                       "neutron.ml2.type_drivers namespace."),
             "PROMPT": ("Enter a comma separated list of network type driver "
                        "entrypoints"),
             "OPTION_LIST": ["local", "flat", "vlan", "gre", "vxlan"],
             "VALIDATORS": [validators.validate_multi_options],
             "DEFAULT_VALUE": "local",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-ml2-tenant-network-types",
             "CONF_NAME": "CONFIG_NEUTRON_ML2_TENANT_NETWORK_TYPES",
             "USAGE": ("A comma separated ordered list of network_types to "
                       "allocate as tenant networks. The value 'local' is "
                       "only useful for single-box testing but provides no "
                       "connectivity between hosts."),
             "PROMPT": ("Enter a comma separated ordered list of "
                        "network_types to allocate as tenant networks"),
             "OPTION_LIST": ["local", "vlan", "gre", "vxlan"],
             "VALIDATORS": [validators.validate_multi_options],
             "DEFAULT_VALUE": "local",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-ml2-mechanism-drivers",
             "CONF_NAME": "CONFIG_NEUTRON_ML2_MECHANISM_DRIVERS",
             "USAGE": ("A comma separated ordered list of networking "
                       "mechanism driver entrypoints to be loaded from the "
                       "neutron.ml2.mechanism_drivers namespace."),
             "PROMPT": ("Enter a comma separated ordered list of networking "
                        "mechanism driver entrypoints"),
             "OPTION_LIST": ["logger", "test", "linuxbridge", "openvswitch",
                             "hyperv", "ncs", "arista", "cisco_nexus",
                             "l2population"],
             "VALIDATORS": [validators.validate_multi_options],
             "DEFAULT_VALUE": "openvswitch",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-ml2-flat-networks",
             "CONF_NAME": "CONFIG_NEUTRON_ML2_FLAT_NETWORKS",
             "USAGE": ("A comma separated  list of physical_network names "
                       "with which flat networks can be created. Use * to "
                       "allow flat networks with arbitrary physical_network "
                       "names."),
             "PROMPT": ("Enter a comma separated  list of physical_network "
                        "names with which flat networks can be created"),
             "OPTION_LIST": [],
             "VALIDATORS": [],
             "DEFAULT_VALUE": "*",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-ml2-vlan-ranges",
             "CONF_NAME": "CONFIG_NEUTRON_ML2_VLAN_RANGES",
             "USAGE": ("A comma separated list of <physical_network>:"
                       "<vlan_min>:<vlan_max> or <physical_network> "
                       "specifying physical_network names usable for VLAN "
                       "provider and tenant networks, as well as ranges of "
                       "VLAN tags on each available for allocation to tenant "
                       "networks."),
             "PROMPT": ("Enter a comma separated list of physical_network "
                        "names usable for VLAN"),
             "OPTION_LIST": [],
             "VALIDATORS": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-ml2-tunnel-id-ranges",
             "CONF_NAME": "CONFIG_NEUTRON_ML2_TUNNEL_ID_RANGES",
             "USAGE": ("A comma separated list of <tun_min>:<tun_max> tuples "
                       "enumerating ranges of GRE tunnel IDs that are "
                       "available for tenant network allocation. Should be "
                       "an array with tun_max +1 - tun_min > 1000000"),
             "PROMPT": ("Enter a comma separated list of <tun_min>:<tun_max> "
                        "tuples enumerating ranges of GRE tunnel IDs that "
                        "are available for tenant network allocation"),
             "OPTION_LIST": [],
             "VALIDATORS": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-ml2-vxlan-group",
             "CONF_NAME": "CONFIG_NEUTRON_ML2_VXLAN_GROUP",
             "USAGE": ("Multicast group for VXLAN. If unset, disables VXLAN "
                       "enable sending allocate broadcast traffic to this "
                       "multicast group. When left unconfigured, will disable "
                       "multicast VXLAN mode. Should be an Multicast IP "
                       "(v4 or v6) address."),
             "PROMPT": "Enter a multicast group for VXLAN",
             "OPTION_LIST": [],
             "VALIDATORS": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "os-neutron-ml2-vni-ranges",
             "CONF_NAME": "CONFIG_NEUTRON_ML2_VNI_RANGES",
             "USAGE": ("A comma separated list of <vni_min>:<vni_max> tuples "
                       "enumerating ranges of VXLAN VNI IDs that are "
                       "available for tenant network allocation. Min value "
                       "is 0 and Max value is 16777215."),
             "PROMPT": ("Enter a comma separated list of <vni_min>:<vni_max> "
                        "tuples enumerating ranges of VXLAN VNI IDs that are "
                        "available for tenant network allocation"),
             "OPTION_LIST": [],
             "VALIDATORS": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            # We need to ask for this only in case of ML2 plugins
            {"CMD_OPTION": "os-neutron-l2-agent",
             "USAGE": "The name of the L2 agent to be used with Neutron",
             "PROMPT": ("Enter the name of the L2 agent to be used "
                        "with Neutron"),
             "OPTION_LIST": ["linuxbridge", "openvswitch"],
             "VALIDATORS": [validators.validate_options],
             "DEFAULT_VALUE": "openvswitch",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_NEUTRON_L2_AGENT",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],
    }

    def use_ml2_plugin(config):
        return (config['CONFIG_NEUTRON_INSTALL'] == 'y' and
                config['CONFIG_NEUTRON_L2_PLUGIN'] == 'ml2')

    def use_linuxbridge_plugin(config):
        result = (config['CONFIG_NEUTRON_INSTALL'] == 'y' and
                  config['CONFIG_NEUTRON_L2_PLUGIN'] == 'linuxbridge')
        if result:
            config["CONFIG_NEUTRON_L2_AGENT"] = 'linuxbridge'
        return result

    def use_linuxbridge_agent(config):
        ml2_used = (use_ml2_plugin(config) and
                    config["CONFIG_NEUTRON_L2_AGENT"] == 'linuxbridge')
        return use_linuxbridge_plugin(config) or ml2_used

    def use_openvswitch_plugin(config):
        result = (config['CONFIG_NEUTRON_INSTALL'] == 'y' and
                  config['CONFIG_NEUTRON_L2_PLUGIN'] == 'openvswitch')
        if result:
            config["CONFIG_NEUTRON_L2_AGENT"] = 'openvswitch'
        return result

    def use_openvswitch_plugin_tunnel(config):
        tun_types = ('gre', 'vxlan')
        return (use_openvswitch_plugin(config) and
                config['CONFIG_NEUTRON_OVS_TENANT_NETWORK_TYPE'] in tun_types)

    def use_ml2_with_ovs(config):
        return (use_ml2_plugin(config) and
                config["CONFIG_NEUTRON_L2_AGENT"] == 'openvswitch')

    def use_openvswitch_agent(config):
        return use_openvswitch_plugin(config) or use_ml2_with_ovs(config)

    def use_openvswitch_agent_tunnel(config):
        return (use_openvswitch_plugin_tunnel(config) or
                use_ml2_with_ovs(config))

    def use_openvswitch_vxlan(config):
        ovs_vxlan = (
            use_openvswitch_plugin_tunnel(config) and
            config['CONFIG_NEUTRON_OVS_TENANT_NETWORK_TYPE'] == 'vxlan'
        )
        ml2_vxlan = (
            use_ml2_with_ovs(config) and
            'vxlan' in config['CONFIG_NEUTRON_ML2_TENANT_NETWORK_TYPES']
        )
        return ovs_vxlan or ml2_vxlan

    conf_groups = [
        {"GROUP_NAME": "NEUTRON",
         "DESCRIPTION": "Neutron config",
         "PRE_CONDITION": "CONFIG_NEUTRON_INSTALL",
         "PRE_CONDITION_MATCH": "y",
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "NEUTRON_ML2_PLUGIN",
         "DESCRIPTION": "Neutron ML2 plugin config",
         "PRE_CONDITION": use_ml2_plugin,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "NEUTRON_LB_PLUGIN",
         "DESCRIPTION": "Neutron LB plugin config",
         "PRE_CONDITION": use_linuxbridge_plugin,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "NEUTRON_LB_PLUGIN_AND_AGENT",
         "DESCRIPTION": "Neutron LB agent config",
         "PRE_CONDITION": use_linuxbridge_agent,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "NEUTRON_OVS_PLUGIN",
         "DESCRIPTION": "Neutron OVS plugin config",
         "PRE_CONDITION": use_openvswitch_plugin,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "NEUTRON_OVS_PLUGIN_AND_AGENT",
         "DESCRIPTION": "Neutron OVS agent config",
         "PRE_CONDITION": use_openvswitch_agent,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "NEUTRON_OVS_PLUGIN_TUNNEL",
         "DESCRIPTION": "Neutron OVS plugin config for tunnels",
         "PRE_CONDITION": use_openvswitch_plugin_tunnel,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "NEUTRON_OVS_PLUGIN_AND_AGENT_TUNNEL",
         "DESCRIPTION": "Neutron OVS agent config for tunnels",
         "PRE_CONDITION": use_openvswitch_agent_tunnel,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "NEUTRON_OVS_PLUGIN_AND_AGENT_VXLAN",
         "DESCRIPTION": "Neutron OVS agent config for VXLAN",
         "PRE_CONDITION": use_openvswitch_vxlan,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},
    ]
    for group in conf_groups:
        params = conf_params[group["GROUP_NAME"]]
        controller.addGroup(group, params)


def initSequences(controller):
    config = controller.CONF
    if config['CONFIG_NEUTRON_INSTALL'] != 'y':
        return

    if config['CONFIG_NEUTRON_L2_PLUGIN'] == 'openvswitch':
        plugin_db = 'ovs_neutron'
        plugin_path = ('neutron.plugins.openvswitch.ovs_neutron_plugin.'
                       'OVSNeutronPluginV2')
    elif config['CONFIG_NEUTRON_L2_PLUGIN'] == 'linuxbridge':
        plugin_db = 'neutron_linux_bridge'
        plugin_path = ('neutron.plugins.linuxbridge.lb_neutron_plugin.'
                       'LinuxBridgePluginV2')
    elif config['CONFIG_NEUTRON_L2_PLUGIN'] == 'ml2':
        plugin_db = 'neutron'
        plugin_path = 'neutron.plugins.ml2.plugin.Ml2Plugin'
        # values modification
        for key in ('CONFIG_NEUTRON_ML2_TYPE_DRIVERS',
                    'CONFIG_NEUTRON_ML2_TENANT_NETWORK_TYPES',
                    'CONFIG_NEUTRON_ML2_MECHANISM_DRIVERS',
                    'CONFIG_NEUTRON_ML2_FLAT_NETWORKS',
                    'CONFIG_NEUTRON_ML2_VLAN_RANGES',
                    'CONFIG_NEUTRON_ML2_TUNNEL_ID_RANGES',
                    'CONFIG_NEUTRON_ML2_VNI_RANGES'):
            config[key] = str([i.strip() for i in config[key].split(',') if i])
        key = 'CONFIG_NEUTRON_ML2_VXLAN_GROUP'
        config[key] = "'%s'" % config[key] if config[key] else 'undef'

    config['CONFIG_NEUTRON_L2_DBNAME'] = plugin_db
    config['CONFIG_NEUTRON_CORE_PLUGIN'] = plugin_path

    global api_hosts, network_hosts, compute_hosts, q_hosts
    api_hosts = split_hosts(config['CONFIG_CONTROLLER_HOST'])
    network_hosts = split_hosts(config['CONFIG_NETWORK_HOSTS'])
    compute_hosts = set()
    if config['CONFIG_NOVA_INSTALL'] == 'y':
        compute_hosts = split_hosts(config['CONFIG_COMPUTE_HOSTS'])
    q_hosts = api_hosts | network_hosts | compute_hosts

    neutron_steps = [
        {'title': 'Adding Neutron API manifest entries',
         'functions': [create_manifests]},
        {'title': 'Adding Neutron Keystone manifest entries',
         'functions': [create_keystone_manifest]},
        {'title': 'Adding Neutron L3 manifest entries',
         'functions': [create_l3_manifests]},
        {'title': 'Adding Neutron L2 Agent manifest entries',
         'functions': [create_l2_agent_manifests]},
        {'title': 'Adding Neutron DHCP Agent manifest entries',
         'functions': [create_dhcp_manifests]},
        {'title': 'Adding Neutron LBaaS Agent manifest entries',
         'functions': [create_lbaas_manifests]},
        {'title': 'Adding Neutron Metadata Agent manifest entries',
         'functions': [create_metadata_manifests]},
    ]
    controller.addSequence("Installing OpenStack Neutron", [], [],
                           neutron_steps)


#------------------------- helper functions -------------------------

def get_if_driver(config):
    agent = config['CONFIG_NEUTRON_L2_AGENT']
    if agent == "openvswitch":
        return 'neutron.agent.linux.interface.OVSInterfaceDriver'
    elif agent == 'linuxbridge':
        return 'neutron.agent.linux.interface.BridgeInterfaceDriver'


def find_mapping(haystack, needle):
    return needle in [x.split(':')[1].strip() for x in get_values(haystack)]


def get_values(val):
    return [x.strip() for x in val.split(',')] if val else []


def get_agent_type(config):
    # The only real use case I can think of for multiples right now is to list
    # "vlan,gre" or "vlan,vxlan" so that VLANs are used if available,
    # but tunnels are used if not.
    tenant_types = config.get('CONFIG_NEUTRON_ML2_TENANT_NETWORK_TYPES',
                              "['local']").strip('[]')
    tenant_types = [i.strip('"\'') for i in tenant_types.split(',')]

    for i in ['gre', 'vxlan', 'vlan']:
        if i in tenant_types:
            return i
    return tenant_types[0]


#-------------------------- step functions --------------------------

def create_manifests(config, messages):
    global q_hosts

    service_plugins = []
    if config['CONFIG_LBAAS_INSTALL'] == 'y':
        service_plugins.append(
            'neutron.services.loadbalancer.plugin.LoadBalancerPlugin'
        )
    if config['CONFIG_NEUTRON_L2_PLUGIN'] == 'ml2':
        # ML2 uses the L3 Router service plugin to implement l3 agent
        service_plugins.append(
            'neutron.services.l3_router.l3_router_plugin.L3RouterPlugin'
        )
    config['SERVICE_PLUGINS'] = (str(service_plugins) if service_plugins
                                 else 'undef')

    if config['CONFIG_NEUTRON_L2_PLUGIN'] == 'openvswitch':
        nettype = config.get("CONFIG_NEUTRON_OVS_TENANT_NETWORK_TYPE", "local")
        plugin_manifest = 'neutron_ovs_plugin_%s.pp' % nettype
    elif config['CONFIG_NEUTRON_L2_PLUGIN'] == 'linuxbridge':
        plugin_manifest = 'neutron_lb_plugin.pp'
    elif config['CONFIG_NEUTRON_L2_PLUGIN'] == 'ml2':
        plugin_manifest = 'neutron_ml2_plugin.pp'

    config['FIREWALL_SERVICE_NAME'] = "neutron server"
    config['FIREWALL_PORTS'] = "'9696'"
    config['FIREWALL_CHAIN'] = "INPUT"

    for host in q_hosts:
        manifest_file = "%s_neutron.pp" % (host,)
        manifest_data = getManifestTemplate("neutron.pp")
        manifest_data += getManifestTemplate(get_mq(config, "neutron"))
        appendManifestFile(manifest_file, manifest_data, 'neutron')

        if host in api_hosts:
            manifest_file = "%s_neutron.pp" % (host,)
            manifest_data = getManifestTemplate("neutron_api.pp")
            manifest_data += getManifestTemplate("neutron_notifications.pp")

            # Firewall Rules
            for f_host in q_hosts:
                config['FIREWALL_ALLOWED'] = "'%s'" % f_host
                config['FIREWALL_SERVICE_ID'] = ("neutron_server_%s_%s"
                                                 % (host, f_host))
                manifest_data += getManifestTemplate("firewall.pp")

            appendManifestFile(manifest_file, manifest_data, 'neutron')

        # Set up any l2 plugin configs we need anywhere we install neutron
        # XXX I am not completely sure about this, but it seems necessary:
        manifest_data = getManifestTemplate(plugin_manifest)
        appendManifestFile(manifest_file, manifest_data, 'neutron')


def create_keystone_manifest(config, messages):
    manifestfile = "%s_keystone.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("keystone_neutron.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_l3_manifests(config, messages):
    global network_hosts

    plugin = config['CONFIG_NEUTRON_L2_PLUGIN']
    if config['CONFIG_NEUTRON_L3_EXT_BRIDGE'] == 'provider':
        config['CONFIG_NEUTRON_L3_EXT_BRIDGE'] = ''

    for host in network_hosts:
        config['CONFIG_NEUTRON_L3_HOST'] = host
        config['CONFIG_NEUTRON_L3_INTERFACE_DRIVER'] = get_if_driver(config)
        manifestdata = getManifestTemplate("neutron_l3.pp")
        manifestfile = "%s_neutron.pp" % (host,)
        appendManifestFile(manifestfile, manifestdata + '\n')
        ext_bridge = config['CONFIG_NEUTRON_L3_EXT_BRIDGE']
        mapping = find_mapping(config['CONFIG_NEUTRON_OVS_BRIDGE_MAPPINGS'],
                               ext_bridge) if ext_bridge else None
        if config['CONFIG_NEUTRON_L2_PLUGIN'] == 'openvswitch' and not mapping:
            config['CONFIG_NEUTRON_OVS_BRIDGE'] = ext_bridge
            manifestdata = getManifestTemplate('neutron_ovs_bridge.pp')
            appendManifestFile(manifestfile, manifestdata + '\n')


def create_dhcp_manifests(config, messages):
    global network_hosts

    plugin = config['CONFIG_NEUTRON_L2_PLUGIN']
    for host in network_hosts:
        config["CONFIG_NEUTRON_DHCP_HOST"] = host
        config['CONFIG_NEUTRON_DHCP_INTERFACE_DRIVER'] = get_if_driver(config)
        manifest_data = getManifestTemplate("neutron_dhcp.pp")
        manifest_file = "%s_neutron.pp" % (host,)

        # Firewall Rules
        for f_host in q_hosts:
            config['FIREWALL_ALLOWED'] = "'%s'" % f_host
            config['FIREWALL_SERVICE_NAME'] = "neutron dhcp in"
            config['FIREWALL_SERVICE_ID'] = ("neutron_dhcp_in_%s_%s"
                                             % (host, f_host))
            config['FIREWALL_PORTS'] = "'67'"
            config['FIREWALL_CHAIN'] = "INPUT"
            manifest_data += getManifestTemplate("firewall.pp")
            config['FIREWALL_SERVICE_NAME'] = "neutron dhcp out"
            config['FIREWALL_SERVICE_ID'] = ("neutron_dhcp_out_%s_%s"
                                             % (host, f_host))
            config['FIREWALL_PORTS'] = "'68'"
            config['FIREWALL_CHAIN'] = "OUTPUT"
            manifest_data += getManifestTemplate("firewall.pp")

        appendManifestFile(manifest_file, manifest_data, 'neutron')


def create_lbaas_manifests(config, messages):
    global api_hosts

    if not config['CONFIG_LBAAS_INSTALL'] == 'y':
        return

    for host in api_hosts:
        config['CONFIG_NEUTRON_LBAAS_INTERFACE_DRIVER'] = get_if_driver(config)
        manifestdata = getManifestTemplate("neutron_lbaas.pp")
        manifestfile = "%s_neutron.pp" % (host,)
        appendManifestFile(manifestfile, manifestdata + "\n")


def create_l2_agent_manifests(config, messages):
    global q_hosts

    plugin = config['CONFIG_NEUTRON_L2_PLUGIN']
    agent = config["CONFIG_NEUTRON_L2_AGENT"]

    if agent == "openvswitch":
        host_var = 'CONFIG_NEUTRON_OVS_HOST'
        if plugin == agent:
            # monolithic plugin installation
            ovs_type = 'CONFIG_NEUTRON_OVS_TENANT_NETWORK_TYPE'
            ovs_type = config.get(ovs_type, 'local')
        elif plugin == 'ml2':
            ovs_type = get_agent_type(config)
        else:
            raise RuntimeError('Invalid combination of plugin and agent.')
        template_name = "neutron_ovs_agent_%s.pp" % ovs_type

        bm_arr = get_values(config["CONFIG_NEUTRON_OVS_BRIDGE_MAPPINGS"])
        iface_arr = get_values(config["CONFIG_NEUTRON_OVS_BRIDGE_IFACES"])

        # The CONFIG_NEUTRON_OVS_BRIDGE_MAPPINGS parameter contains a
        # comma-separated list of bridge mappings. Since the puppet module
        # expects this parameter to be an array, this parameter must be
        # properly formatted by packstack, then consumed by the puppet module.
        # For example, the input string 'A, B' should formatted as '['A','B']'.
        config["CONFIG_NEUTRON_OVS_BRIDGE_MAPPINGS"] = str(bm_arr)
    elif agent == "linuxbridge":
        host_var = 'CONFIG_NEUTRON_LB_HOST'
        template_name = 'neutron_lb_agent.pp'
    else:
        raise KeyError("Unknown layer2 agent")

    # Install l2 agents on every compute host in addition to any hosts listed
    # specifically for the l2 agent
    for host in q_hosts:
        config[host_var] = host
        manifestfile = "%s_neutron.pp" % (host,)
        manifestdata = getManifestTemplate(template_name)
        appendManifestFile(manifestfile, manifestdata + "\n")
        if agent == "openvswitch" and ovs_type == 'vlan':
            for if_map in iface_arr:
                bridge_key = 'CONFIG_NEUTRON_OVS_BRIDGE'
                iface_key = 'CONFIG_NEUTRON_OVS_IFACE'
                config[bridge_key], config[iface_key] = if_map.split(':')
                manifestdata = getManifestTemplate("neutron_ovs_port.pp")
                appendManifestFile(manifestfile, manifestdata + "\n")
        # Additional configurations required for compute hosts
        if host in compute_hosts:
            manifestdata = getManifestTemplate('neutron_bridge_module.pp')
            appendManifestFile(manifestfile, manifestdata + '\n')


def create_metadata_manifests(config, messages):
    global network_hosts
    if config.get('CONFIG_NOVA_INSTALL') == 'n':
        return
    for host in network_hosts:
        config['CONFIG_NEUTRON_METADATA_HOST'] = host
        manifestdata = getManifestTemplate('neutron_metadata.pp')
        manifestfile = "%s_neutron.pp" % (host,)
        appendManifestFile(manifestfile, manifestdata + "\n")

########NEW FILE########
__FILENAME__ = nova_300
# -*- coding: utf-8 -*-

"""
Installs and configures nova
"""

import os
import uuid
import logging
import platform
import socket

from packstack.installer import basedefs, processors, utils, validators
from packstack.installer.exceptions import ScriptRuntimeError

from packstack.modules.shortcuts import get_mq
from packstack.modules.ospluginutils import (NovaConfig, getManifestTemplate,
                                             appendManifestFile, manifestfiles)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-Nova"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    if platform.linux_distribution()[0] == "Fedora":
        primary_netif = "em1"
        secondary_netif = "em2"
    else:
        primary_netif = "eth0"
        secondary_netif = "eth1"

    nova_params = {
        "NOVA": [
            {"CMD_OPTION": "nova-db-passwd",
             "USAGE": "The password to use for the Nova to access DB",
             "PROMPT": "Enter the password for the Nova DB access",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": uuid.uuid4().hex[:16],
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_NOVA_DB_PW",
             "USE_DEFAULT": True,
             "NEED_CONFIRM": True,
             "CONDITION": False},

            {"CMD_OPTION": "nova-ks-passwd",
             "USAGE": ("The password to use for the Nova to authenticate "
                       "with Keystone"),
             "PROMPT": "Enter the password for the Nova Keystone access",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": uuid.uuid4().hex[:16],
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_NOVA_KS_PW",
             "USE_DEFAULT": True,
             "NEED_CONFIRM": True,
             "CONDITION": False},

            {"CMD_OPTION": "novasched-cpu-allocation-ratio",
             "USAGE": ("The overcommitment ratio for virtual to physical CPUs."
                       " Set to 1.0 to disable CPU overcommitment"),
             "PROMPT": "Enter the CPU overcommitment ratio. Set to 1.0 to "
                       "disable CPU overcommitment",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_float],
             "DEFAULT_VALUE": 16.0,
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NOVA_SCHED_CPU_ALLOC_RATIO",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "novasched-ram-allocation-ratio",
             "USAGE": ("The overcommitment ratio for virtual to physical RAM. "
                       "Set to 1.0 to disable RAM overcommitment"),
             "PROMPT": ("Enter the RAM overcommitment ratio. Set to 1.0 to "
                        "disable RAM overcommitment"),
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_float],
             "DEFAULT_VALUE": 1.5,
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NOVA_SCHED_RAM_ALLOC_RATIO",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],

        "NOVA_NETWORK": [
            {"CMD_OPTION": "novacompute-privif",
             "USAGE": ("Private interface for Flat DHCP on the Nova compute "
                       "servers"),
             "PROMPT": ("Enter the Private interface for Flat DHCP on the Nova"
                        " compute servers"),
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": secondary_netif,
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NOVA_COMPUTE_PRIVIF",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "novanetwork-manager",
             "USAGE": "Nova network manager",
             "PROMPT": "Enter the Nova network manager",
             "OPTION_LIST": [r'^nova\.network\.manager\.\w+Manager$'],
             "VALIDATORS": [validators.validate_regexp],
             "DEFAULT_VALUE": "nova.network.manager.FlatDHCPManager",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NOVA_NETWORK_MANAGER",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "novanetwork-pubif",
             "USAGE": "Public interface on the Nova network server",
             "PROMPT": "Enter the Public interface on the Nova network server",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": primary_netif,
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NOVA_NETWORK_PUBIF",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "novanetwork-privif",
             "USAGE": ("Private interface for network manager on the Nova "
                       "network server"),
             "PROMPT": ("Enter the Private interface for network manager on "
                        "the Nova network server"),
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": secondary_netif,
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NOVA_NETWORK_PRIVIF",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "novanetwork-fixed-range",
             "USAGE": "IP Range for network manager",
             "PROMPT": "Enter the IP Range for network manager",
             "OPTION_LIST": ["^[\:\.\da-fA-f]+(\/\d+){0,1}$"],
             "PROCESSORS": [processors.process_cidr],
             "VALIDATORS": [validators.validate_regexp],
             "DEFAULT_VALUE": "192.168.32.0/22",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NOVA_NETWORK_FIXEDRANGE",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "novanetwork-floating-range",
             "USAGE": "IP Range for Floating IP's",
             "PROMPT": "Enter the IP Range for Floating IP's",
             "OPTION_LIST": ["^[\:\.\da-fA-f]+(\/\d+){0,1}$"],
             "PROCESSORS": [processors.process_cidr],
             "VALIDATORS": [validators.validate_regexp],
             "DEFAULT_VALUE": "10.3.4.0/22",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NOVA_NETWORK_FLOATRANGE",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "novanetwork-default-floating-pool",
             "USAGE": ("Name of the default floating pool to which the "
                       "specified floating ranges are added to"),
             "PROMPT": "What should the default floating pool be called?",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": "nova",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_NOVA_NETWORK_DEFAULTFLOATINGPOOL",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "novanetwork-auto-assign-floating-ip",
             "USAGE": "Automatically assign a floating IP to new instances",
             "PROMPT": ("Should new instances automatically have a floating "
                        "IP assigned?"),
             "OPTION_LIST": ["y", "n"],
             "VALIDATORS": [validators.validate_options],
             "DEFAULT_VALUE": "n",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_NOVA_NETWORK_AUTOASSIGNFLOATINGIP",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],

        "NOVA_NETWORK_VLAN": [
            {"CMD_OPTION": "novanetwork-vlan-start",
             "USAGE": "First VLAN for private networks",
             "PROMPT": "Enter first VLAN for private networks",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": 100,
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NOVA_NETWORK_VLAN_START",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "novanetwork-num-networks",
             "USAGE": "Number of networks to support",
             "PROMPT": "How many networks should be supported",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": 1,
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NOVA_NETWORK_NUMBER",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "novanetwork-network-size",
             "USAGE": "Number of addresses in each private subnet",
             "PROMPT": "How many addresses should be in each private subnet",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": 255,
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_NOVA_NETWORK_SIZE",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],
    }

    def use_nova_network(config):
        return (config['CONFIG_NOVA_INSTALL'] == 'y' and
                config['CONFIG_NEUTRON_INSTALL'] != 'y')

    def use_nova_network_vlan(config):
        manager = 'nova.network.manager.VlanManager'
        return (config['CONFIG_NOVA_INSTALL'] == 'y' and
                config['CONFIG_NEUTRON_INSTALL'] != 'y' and
                config['CONFIG_NOVA_NETWORK_MANAGER'] == manager)

    nova_groups = [
        {"GROUP_NAME": "NOVA",
         "DESCRIPTION": "Nova Options",
         "PRE_CONDITION": "CONFIG_NOVA_INSTALL",
         "PRE_CONDITION_MATCH": "y",
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "NOVA_NETWORK",
         "DESCRIPTION": "Nova Network Options",
         "PRE_CONDITION": use_nova_network,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "NOVA_NETWORK_VLAN",
         "DESCRIPTION": "Nova Network VLAN Options",
         "PRE_CONDITION": use_nova_network_vlan,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},
    ]
    for group in nova_groups:
        params = nova_params[group["GROUP_NAME"]]
        controller.addGroup(group, params)


def initSequences(controller):
    if controller.CONF['CONFIG_NOVA_INSTALL'] != 'y':
        return

    novaapisteps = [
        {'title': 'Adding Nova API manifest entries',
         'functions': [create_api_manifest]},
        {'title': 'Adding Nova Keystone manifest entries',
         'functions': [create_keystone_manifest]},
        {'title': 'Adding Nova Cert manifest entries',
         'functions': [create_cert_manifest]},
        {'title': 'Adding Nova Conductor manifest entries',
         'functions': [create_conductor_manifest]},
        {'title': 'Creating ssh keys for Nova migration',
         'functions': [create_ssh_keys]},
        {'title': 'Gathering ssh host keys for Nova migration',
         'functions': [gather_host_keys]},
        {'title': 'Adding Nova Compute manifest entries',
         'functions': [create_compute_manifest]},
        {'title': 'Adding Nova Scheduler manifest entries',
         'functions': [create_sched_manifest]},
        {'title': 'Adding Nova VNC Proxy manifest entries',
         'functions': [create_vncproxy_manifest]},
        {'title': 'Adding Nova Common manifest entries',
         'functions': [create_common_manifest]},
    ]

    if controller.CONF['CONFIG_NEUTRON_INSTALL'] == 'y':
        novaapisteps.append(
            {'title': 'Adding Openstack Network-related Nova manifest entries',
             'functions': [create_neutron_manifest]}
        )
    else:
        novaapisteps.append(
            {'title': 'Adding Nova Network manifest entries',
             'functions': [create_network_manifest]}
        )
    controller.addSequence("Installing OpenStack Nova API", [], [],
                           novaapisteps)


#------------------------- helper functions -------------------------

def check_ifcfg(host, device):
    """
    Raises ScriptRuntimeError if given host does not have give device.
    """
    server = utils.ScriptRunner(host)
    cmd = "ip addr show dev %s || ( echo Device %s does not exist && exit 1 )"
    server.append(cmd % (device, device))
    server.execute()


def bring_up_ifcfg(host, device):
    """
    Brings given device up if it's down. Raises ScriptRuntimeError in case
    of failure.
    """
    server = utils.ScriptRunner(host)
    server.append('ip link show up | grep "%s"' % device)
    try:
        server.execute()
    except ScriptRuntimeError:
        server.clear()
        cmd = 'ip link set dev %s up'
        server.append(cmd % device)
        try:
            server.execute()
        except ScriptRuntimeError:
            msg = ('Failed to bring up network interface %s on host %s.'
                   ' Interface should be up so Openstack can work'
                   ' properly.' % (device, host))
            raise ScriptRuntimeError(msg)


#-------------------------- step functions --------------------------

def create_ssh_keys(config, messages):
    migration_key = os.path.join(basedefs.VAR_DIR, 'nova_migration_key')
    # Generate key
    local = utils.ScriptRunner()
    local.append('ssh-keygen -t rsa -b 2048 -f "%s" -N ""' % migration_key)
    local.execute()

    with open(migration_key) as fp:
        secret = fp.read().strip()
    with open('%s.pub' % migration_key) as fp:
        public = fp.read().strip()

    config['NOVA_MIGRATION_KEY_TYPE'] = 'ssh-rsa'
    config['NOVA_MIGRATION_KEY_PUBLIC'] = public.split()[1]
    config['NOVA_MIGRATION_KEY_SECRET'] = secret


def gather_host_keys(config, messages):
    global compute_hosts

    for host in compute_hosts:
        local = utils.ScriptRunner()
        local.append('ssh-keyscan %s' % host)
        retcode, hostkey = local.execute()
        config['HOST_KEYS_%s' % host] = hostkey


def create_api_manifest(config, messages):
    # Since this step is running first, let's create necesary variables here
    # and make them global
    global compute_hosts, network_hosts
    com_var = config.get("CONFIG_COMPUTE_HOSTS", "")
    compute_hosts = set([i.strip() for i in com_var.split(",") if i.strip()])
    net_var = config.get("CONFIG_NETWORK_HOSTS", "")
    network_hosts = set([i.strip() for i in net_var.split(",") if i.strip()])

    # This is a hack around us needing to generate the neutron metadata
    # password, but the nova puppet plugin uses the existence of that
    # password to determine whether or not to configure neutron metadata
    # proxy support. So the nova_api.pp template needs unquoted 'undef'
    # to disable metadata support if neutron is not being installed.
    if config['CONFIG_NEUTRON_INSTALL'] != 'y':
        config['CONFIG_NEUTRON_METADATA_PW_UNQUOTED'] = 'undef'
    else:
        config['CONFIG_NEUTRON_METADATA_PW_UNQUOTED'] = \
            "'%s'" % config['CONFIG_NEUTRON_METADATA_PW']
    manifestfile = "%s_api_nova.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("nova_api.pp")
    appendManifestFile(manifestfile, manifestdata, 'novaapi')


def create_keystone_manifest(config, messages):
    manifestfile = "%s_keystone.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("keystone_nova.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_cert_manifest(config, messages):
    manifestfile = "%s_nova.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("nova_cert.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_conductor_manifest(config, messages):
    manifestfile = "%s_nova.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("nova_conductor.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_compute_manifest(config, messages):
    global compute_hosts, network_hosts

    ssh_hostkeys = ''
    for host in compute_hosts:
        try:
            host_name, host_aliases, host_addrs = socket.gethostbyaddr(host)
        except socket.herror:
            host_name, host_aliases, host_addrs = (host, [], [])

        for hostkey in config['HOST_KEYS_%s' % host].split('\n'):
            hostkey = hostkey.strip()
            if not hostkey:
                continue

            _, host_key_type, host_key_data = hostkey.split()
            config['SSH_HOST_NAME'] = host_name
            config['SSH_HOST_ALIASES'] = ','.join(
                '"%s"' % addr for addr in host_aliases + host_addrs
            )
            config['SSH_HOST_KEY'] = host_key_data
            config['SSH_HOST_KEY_TYPE'] = host_key_type
            ssh_hostkeys += getManifestTemplate("sshkey.pp")

    for host in compute_hosts:
        config["CONFIG_NOVA_COMPUTE_HOST"] = host
        manifestdata = getManifestTemplate("nova_compute.pp")
        if config['CONFIG_VMWARE_BACKEND'] == 'y':
            manifestdata += getManifestTemplate("nova_compute_vmware.pp")
        else:
            manifestdata += getManifestTemplate("nova_compute_libvirt.pp")
        if (config['CONFIG_VMWARE_BACKEND'] != 'y' and
                config['CONFIG_CINDER_INSTALL'] == 'y' and
                config['CONFIG_CINDER_BACKEND'] == 'gluster'):
            manifestdata += getManifestTemplate("nova_gluster.pp")
        if (config['CONFIG_VMWARE_BACKEND'] != 'y' and
                config['CONFIG_CINDER_INSTALL'] == 'y' and
                config['CONFIG_CINDER_BACKEND'] == 'nfs'):
            manifestdata += getManifestTemplate("nova_nfs.pp")
        manifestfile = "%s_nova.pp" % host

        nova_config_options = NovaConfig()
        if config['CONFIG_NEUTRON_INSTALL'] != 'y':
            if host not in network_hosts:
                nova_config_options.addOption(
                    "DEFAULT/flat_interface",
                    config['CONFIG_NOVA_COMPUTE_PRIVIF']
                )
            check_ifcfg(host, config['CONFIG_NOVA_COMPUTE_PRIVIF'])
            try:
                bring_up_ifcfg(host, config['CONFIG_NOVA_COMPUTE_PRIVIF'])
            except ScriptRuntimeError as ex:
                # just warn user to do it by himself
                messages.append(str(ex))

        if config['CONFIG_CEILOMETER_INSTALL'] == 'y':
            mq_template = get_mq(config, "nova_ceilometer")
            manifestdata += getManifestTemplate(mq_template)
            manifestdata += getManifestTemplate("nova_ceilometer.pp")

        config['FIREWALL_ALLOWED'] = "'%s'" % config['CONFIG_CONTROLLER_HOST']
        config['FIREWALL_SERVICE_NAME'] = "nova compute"
        config['FIREWALL_SERVICE_ID'] = "nova_compute"
        config['FIREWALL_PORTS'] = "'5900-5999'"
        config['FIREWALL_CHAIN'] = "INPUT"
        manifestdata += getManifestTemplate("firewall.pp")

        manifestdata += "\n" + nova_config_options.getManifestEntry()
        manifestdata += "\n" + ssh_hostkeys
        appendManifestFile(manifestfile, manifestdata)


def create_network_manifest(config, messages):
    global compute_hosts, network_hosts
    if config['CONFIG_NEUTRON_INSTALL'] == "y":
        return

    # set default values for VlanManager in case this values are not in config
    for key, value in [('CONFIG_NOVA_NETWORK_VLAN_START', 100),
                       ('CONFIG_NOVA_NETWORK_SIZE', 255),
                       ('CONFIG_NOVA_NETWORK_NUMBER', 1)]:
        config[key] = config.get(key, value)

    api_host = config['CONFIG_CONTROLLER_HOST']
    multihost = len(network_hosts) > 1
    config['CONFIG_NOVA_NETWORK_MULTIHOST'] = multihost and 'true' or 'false'
    for host in network_hosts:
        for i in ('CONFIG_NOVA_NETWORK_PRIVIF', 'CONFIG_NOVA_NETWORK_PUBIF'):
            check_ifcfg(host, config[i])
            try:
                bring_up_ifcfg(host, config[i])
            except ScriptRuntimeError as ex:
                # just warn user to do it by himself
                messages.append(str(ex))

        key = 'CONFIG_NOVA_NETWORK_AUTOASSIGNFLOATINGIP'
        config[key] = config[key] == "y"

        # We need to explicitly set the network size
        routing_prefix = config['CONFIG_NOVA_NETWORK_FIXEDRANGE'].split('/')[1]
        net_size = 2 ** (32 - int(routing_prefix))
        config['CONFIG_NOVA_NETWORK_FIXEDSIZE'] = str(net_size)

        manifestfile = "%s_nova.pp" % host
        manifestdata = getManifestTemplate("nova_network.pp")

        # in multihost mode each compute host runs nova-api-metadata
        if multihost and host != api_host and host in compute_hosts:
            manifestdata += getManifestTemplate("nova_metadata.pp")
        appendManifestFile(manifestfile, manifestdata)


def create_sched_manifest(config, messages):
    manifestfile = "%s_nova.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("nova_sched.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_vncproxy_manifest(config, messages):
    manifestfile = "%s_nova.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("nova_vncproxy.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_common_manifest(config, messages):
    global compute_hosts, network_hosts
    network_type = (config['CONFIG_NEUTRON_INSTALL'] == "y" and
                    'neutron' or 'nova')
    network_multi = len(network_hosts) > 1
    dbacces_hosts = set([config.get('CONFIG_CONTROLLER_HOST')])
    dbacces_hosts |= network_hosts

    for manifestfile, marker in manifestfiles.getFiles():
        if manifestfile.endswith("_nova.pp"):
            host, manifest = manifestfile.split('_', 1)
            host = host.strip()

            if host in compute_hosts and host not in dbacces_hosts:
                # we should omit password in case we are installing only
                # nova-compute to the host
                perms = "nova"
            else:
                perms = "nova:%(CONFIG_NOVA_DB_PW)s"
            sqlconn = "mysql://%s@%%(CONFIG_MYSQL_HOST)s/nova" % perms
            config['CONFIG_NOVA_SQL_CONN'] = sqlconn % config

            # for nova-network in multihost mode each compute host is metadata
            # host otherwise we use api host
            if (network_type == 'nova' and network_multi and
                    host in compute_hosts):
                metadata = host
            else:
                metadata = config['CONFIG_CONTROLLER_HOST']
            config['CONFIG_NOVA_METADATA_HOST'] = metadata

            data = getManifestTemplate(get_mq(config, "nova_common"))
            data += getManifestTemplate("nova_common.pp")
            appendManifestFile(os.path.split(manifestfile)[1], data)


def create_neutron_manifest(config, messages):
    if config['CONFIG_NEUTRON_INSTALL'] != "y":
        return

    virt_driver = 'nova.virt.libvirt.vif.LibvirtGenericVIFDriver'
    config['CONFIG_NOVA_LIBVIRT_VIF_DRIVER'] = virt_driver

    for manifestfile, marker in manifestfiles.getFiles():
        if manifestfile.endswith("_nova.pp"):
            data = getManifestTemplate("nova_neutron.pp")
            appendManifestFile(os.path.split(manifestfile)[1], data)

########NEW FILE########
__FILENAME__ = openstack_client_400
# -*- coding: utf-8 -*-

"""
Installs and configures an OpenStack Client
"""

import logging
import os

from packstack.installer import validators
from packstack.installer import basedefs, output_messages
from packstack.installer import utils

from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-Client"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    group = {"GROUP_NAME": "NOVACLIENT",
             "DESCRIPTION": "NOVACLIENT Config parameters",
             "PRE_CONDITION": "CONFIG_CLIENT_INSTALL",
             "PRE_CONDITION_MATCH": "y",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, [])


def initSequences(controller):
    if controller.CONF['CONFIG_CLIENT_INSTALL'] != 'y':
        return

    osclientsteps = [
        {'title': 'Adding OpenStack Client manifest entries',
         'functions': [create_manifest]}
    ]
    controller.addSequence("Installing OpenStack Client", [], [],
                           osclientsteps)


#-------------------------- step functions --------------------------

def create_manifest(config, messages):
    client_host = config['CONFIG_CONTROLLER_HOST'].strip()
    manifestfile = "%s_osclient.pp" % client_host

    server = utils.ScriptRunner(client_host)
    server.append('echo $HOME')
    rc, root_home = server.execute()
    root_home = root_home.strip()

    homedir = os.path.expanduser('~')
    config['HOME_DIR'] = homedir

    uname, gname = utils.get_current_username()
    config['NO_ROOT_USER'], config['NO_ROOT_GROUP'] = uname, gname

    no_root_allinone = (client_host == utils.get_localhost_ip() and
                        root_home != homedir)
    config['NO_ROOT_USER_ALLINONE'] = no_root_allinone and 'true' or 'false'

    manifestdata = getManifestTemplate("openstack_client.pp")
    appendManifestFile(manifestfile, manifestdata)

    msg = ("File %s/keystonerc_admin has been created on OpenStack client host"
           " %s. To use the command line tools you need to source the file.")
    messages.append(msg % (root_home, client_host))

    if no_root_allinone:
        msg = ("Copy of keystonerc_admin file has been created for non-root "
               "user in %s.")
        messages.append(msg % homedir)

########NEW FILE########
__FILENAME__ = postscript_948
# -*- coding: utf-8 -*-

"""
Installs and configures an OpenStack Client
"""

import logging

from packstack.installer import utils

from packstack.modules.common import filtered_hosts
from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "Postscript"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    group = {"GROUP_NAME": "POSTSCRIPT",
             "DESCRIPTION": "POSTSCRIPT Config parameters",
             "PRE_CONDITION": lambda x: 'yes',
             "PRE_CONDITION_MATCH": "yes",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, [])


def initSequences(controller):
    postscript_steps = [
        {'title': 'Adding post install manifest entries',
         'functions': [create_manifest]}
    ]
    controller.addSequence("Running post install scripts", [], [],
                           postscript_steps)


#-------------------------- step functions --------------------------

def create_manifest(config, messages):
    for hostname in filtered_hosts(config):
        manifestfile = "%s_postscript.pp" % hostname
        manifestdata = getManifestTemplate("postscript.pp")
        appendManifestFile(manifestfile, manifestdata, 'postscript')
        if config.get("CONFIG_PROVISION_ALL_IN_ONE_OVS_BRIDGE") != 'n':
            fmted = config['CONFIG_NEUTRON_L3_EXT_BRIDGE'].replace('-', '_')
            config['EXT_BRIDGE_VAR'] = fmted
            manifestdata = getManifestTemplate("persist_ovs_bridge.pp")
            appendManifestFile(manifestfile, manifestdata, 'postscript')

########NEW FILE########
__FILENAME__ = prescript_000
# -*- coding: utf-8 -*-

"""
Plugin responsible for setting OpenStack global options
"""

import glob
import logging
import os
import re
import uuid

from packstack.installer import (basedefs, exceptions, processors, utils,
                                 validators)

from packstack.modules.common import filtered_hosts
from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "Prescript"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    default_ssh_key = os.path.join(os.environ["HOME"], ".ssh/*.pub")
    default_ssh_key = (glob.glob(default_ssh_key) + [""])[0]
    params = [
        {"CMD_OPTION": "ssh-public-key",
         "USAGE": ("Path to a Public key to install on servers. If a usable "
                   "key has not been installed on the remote servers the user "
                   "will be prompted for a password and this key will be "
                   "installed so the password will not be required again"),
         "PROMPT": ("Enter the path to your ssh Public key to install "
                    "on servers"),
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_file, validators.validate_sshkey],
         "PROCESSORS": [processors.process_ssh_key],
         "DEFAULT_VALUE": default_ssh_key,
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_SSH_KEY",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "mysql-install",
         "USAGE": "Set to 'y' if you would like Packstack to install MySQL",
         "PROMPT": "Should Packstack install MySQL DB",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "y",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_MYSQL_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-glance-install",
         "USAGE": ("Set to 'y' if you would like Packstack to install "
                   "OpenStack Image Service (Glance)"),
         "PROMPT": "Should Packstack install OpenStack Image Service (Glance)",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "y",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_GLANCE_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-cinder-install",
         "USAGE": ("Set to 'y' if you would like Packstack to install "
                   "OpenStack Block Storage (Cinder)"),
         "PROMPT": ("Should Packstack install OpenStack Block Storage "
                    "(Cinder) service"),
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "y",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_CINDER_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-nova-install",
         "USAGE": ("Set to 'y' if you would like Packstack to install "
                   "OpenStack Compute (Nova)"),
         "PROMPT": "Should Packstack install OpenStack Compute (Nova) service",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "y",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_NOVA_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-neutron-install",
         "USAGE": ("Set to 'y' if you would like Packstack to install "
                   "OpenStack Networking (Neutron). Otherwise Nova Network "
                   "will be used."),
         "PROMPT": ("Should Packstack install OpenStack Networking (Neutron) "
                    "service"),
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "y",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_NEUTRON_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-horizon-install",
         "USAGE": ("Set to 'y' if you would like Packstack to install "
                   "OpenStack Dashboard (Horizon)"),
         "PROMPT": "Should Packstack install OpenStack Dashboard (Horizon)",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "y",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_HORIZON_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-swift-install",
         "USAGE": ("Set to 'y' if you would like Packstack to install "
                   "OpenStack Object Storage (Swift)"),
         "PROMPT": "Should Packstack install OpenStack Object Storage (Swift)",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "y",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_SWIFT_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-ceilometer-install",
         "USAGE": ("Set to 'y' if you would like Packstack to install "
                   "OpenStack Metering (Ceilometer)"),
         "PROMPT": "Should Packstack install OpenStack Metering (Ceilometer)",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "y",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_CEILOMETER_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-heat-install",
         "USAGE": ("Set to 'y' if you would like Packstack to install "
                   "OpenStack Orchestration (Heat)"),
         "PROMPT": "Should Packstack install OpenStack Orchestration (Heat)",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "n",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_HEAT_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-client-install",
         "USAGE": ("Set to 'y' if you would like Packstack to install "
                   "the OpenStack Client packages. An admin \"rc\" file will "
                   "also be installed"),
         "PROMPT": "Should Packstack install OpenStack client tools",
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "y",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_CLIENT_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "ntp-servers",
         "USAGE": ("Comma separated list of NTP servers. Leave plain if "
                   "Packstack should not install ntpd on instances."),
         "PROMPT": ("Enter a comma separated list of NTP server(s). Leave "
                    "plain if Packstack should not install ntpd "
                    "on instances."),
         "OPTION_LIST": [],
         "DEFAULT_VALUE": '',
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_NTP_SERVERS",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "nagios-install",
         "USAGE": ("Set to 'y' if you would like Packstack to install Nagios "
                   "to monitor OpenStack hosts"),
         "PROMPT": ("Should Packstack install Nagios to monitor OpenStack "
                    "hosts"),
         "OPTION_LIST": ["y", "n"],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": 'y',
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_NAGIOS_INSTALL",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "exclude-servers",
         "USAGE": ("Comma separated list of servers to be excluded from "
                   "installation in case you are running Packstack the second "
                   "time with the same answer file and don't want Packstack "
                   "to touch these servers. Leave plain if you don't need to "
                   "exclude any server."),
         "PROMPT": ("Enter a comma separated list of server(s) to be excluded."
                    " Leave plain if you don't need to exclude any server."),
         "OPTION_LIST": [],
         "DEFAULT_VALUE": '',
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "EXCLUDE_SERVERS",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-debug-mode",
         "USAGE": ("Set to 'y' if you want to run OpenStack services in debug "
                   "mode. Otherwise set to 'n'."),
         "PROMPT": "Do you want to run OpenStack services in debug mode",
         "OPTION_LIST": ["y", "n"],
         "DEFAULT_VALUE": "n",
         "VALIDATORS": [validators.validate_options],
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_DEBUG_MODE",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CONF_NAME": "CONFIG_CONTROLLER_HOST",
         "CMD_OPTION": "os-controller-host",
         "USAGE": ("The IP address of the server on which to install OpenStack"
                   " services specific to controller role such as API servers,"
                   " Horizon, etc."),
         "PROMPT": "Enter the IP address of the controller host",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_ip,
                        validators.validate_ssh],
         "DEFAULT_VALUE": utils.get_localhost_ip(),
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False,
         "DEPRECATES": ['CONFIG_CEILOMETER_HOST',
                        'CONFIG_CINDER_HOST',
                        'CONFIG_GLANCE_HOST',
                        'CONFIG_HORIZON_HOST',
                        'CONFIG_HEAT_HOST',
                        'CONFIG_KEYSTONE_HOST',
                        'CONFIG_NAGIOS_HOST',
                        'CONFIG_NEUTRON_SERVER_HOST',
                        'CONFIG_NEUTRON_LBAAS_HOSTS',
                        'CONFIG_NOVA_API_HOST',
                        'CONFIG_NOVA_CERT_HOST',
                        'CONFIG_NOVA_VNCPROXY_HOST',
                        'CONFIG_NOVA_SCHED_HOST',
                        'CONFIG_OSCLIENT_HOST',
                        'CONFIG_SWIFT_PROXY_HOSTS']},

        {"CONF_NAME": "CONFIG_COMPUTE_HOSTS",
         "CMD_OPTION": "os-compute-hosts",
         "USAGE": ("The list of IP addresses of the server on which to install"
                   " the Nova compute service"),
         "PROMPT": ("Enter list of IP addresses on which to install compute "
                    "service"),
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_multi_ip,
                        validators.validate_multi_ssh],
         "DEFAULT_VALUE": utils.get_localhost_ip(),
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False,
         "DEPRECATES": ['CONFIG_NOVA_COMPUTE_HOSTS']},

        {"CONF_NAME": "CONFIG_NETWORK_HOSTS",
         "CMD_OPTION": "os-network-hosts",
         "USAGE": ("The list of IP addresses of the server on which "
                   "to install the network service such as Nova "
                   "network or Neutron"),
         "PROMPT": ("Enter list of IP addresses on which to install "
                    "network service"),
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_multi_ip,
                        validators.validate_multi_ssh],
         "DEFAULT_VALUE": utils.get_localhost_ip(),
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False,
         "DEPRECATES": ['CONFIG_NEUTRON_L3_HOSTS',
                        'CONFIG_NEUTRON_DHCP_HOSTS',
                        'CONFIG_NEUTRON_METADATA_HOSTS',
                        'CONFIG_NOVA_NETWORK_HOSTS']},

        {"CMD_OPTION": "os-vmware",
         "USAGE": ("Set to 'y' if you want to use VMware vCenter as hypervisor"
                   " and storage. Otherwise set to 'n'."),
         "PROMPT": ("Do you want to use VMware vCenter as hypervisor and "
                    "datastore"),
         "OPTION_LIST": ["y", "n"],
         "DEFAULT_VALUE": "n",
         "VALIDATORS": [validators.validate_options],
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_VMWARE_BACKEND",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "GLOBAL",
             "DESCRIPTION": "Global Options",
             "PRE_CONDITION": lambda x: 'yes',
             "PRE_CONDITION_MATCH": "yes",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)

    def use_vcenter(config):
        return (config['CONFIG_NOVA_INSTALL'] == 'y' and
                config['CONFIG_VMWARE_BACKEND'] == 'y')

    params = [
        {"CMD_OPTION": "vcenter-host",
         "USAGE": "The IP address of the VMware vCenter server",
         "PROMPT": ("Enter the IP address of the VMware vCenter server to use "
                    "with Nova"),
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_ip],
         "DEFAULT_VALUE": "",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_VCENTER_HOST",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "vcenter-username",
         "USAGE": "The username to authenticate to VMware vCenter server",
         "PROMPT": ("Enter the username to authenticate on VMware "
                    "vCenter server"),
         "DEFAULT_VALUE": "",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_VCENTER_USER",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "vcenter-password",
         "USAGE": "The password to authenticate to VMware vCenter server",
         "PROMPT": ("Enter the password to authenticate on VMware "
                    "vCenter server"),
         "DEFAULT_VALUE": "",
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_VCENTER_PASSWORD",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "vcenter-cluster",
         "USAGE": "The name of the vCenter cluster",
         "PROMPT": "Enter the name of the vCenter datastore",
         "DEFAULT_VALUE": "",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_VCENTER_CLUSTER_NAME",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "VMWARE",
             "DESCRIPTION": "vCenter Config Parameters",
             "PRE_CONDITION": use_vcenter,
             "PRE_CONDITION_MATCH": True,
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)


def initSequences(controller):
    prescript_steps = [
        {'title': 'Setting up ssh keys',
         'functions': [install_keys]},
        {'title': 'Discovering hosts\' details',
         'functions': [discover]},
        {'title': 'Adding pre install manifest entries',
         'functions': [create_manifest]},
    ]

    if controller.CONF['CONFIG_NTP_SERVERS']:
        prescript_steps.append(
            {'title': 'Installing time synchronization via NTP',
             'functions': [create_ntp_manifest]})
    else:
        controller.MESSAGES.append('Time synchronization installation was '
                                   'skipped. Please note that unsynchronized '
                                   'time on server instances might be problem '
                                   'for some OpenStack components.')
    controller.addSequence("Running pre install scripts", [], [],
                           prescript_steps)


#-------------------------- step functions --------------------------

def install_keys(config, messages):
    with open(config["CONFIG_SSH_KEY"]) as fp:
        sshkeydata = fp.read().strip()
    for hostname in filtered_hosts(config):
        if '/' in hostname:
            hostname = hostname.split('/')[0]
        server = utils.ScriptRunner(hostname)
        # TODO replace all that with ssh-copy-id
        server.append("mkdir -p ~/.ssh")
        server.append("chmod 500 ~/.ssh")
        server.append("grep '%s' ~/.ssh/authorized_keys > /dev/null 2>&1 || "
                      "echo %s >> ~/.ssh/authorized_keys"
                      % (sshkeydata, sshkeydata))
        server.append("chmod 400 ~/.ssh/authorized_keys")
        server.append("restorecon -r ~/.ssh")
        server.execute()


def discover(config, messages):
    """
    Discovers details about hosts.
    """
    # TODO: Once Controller is refactored, move this function to it (facter can
    #       be used for that too).
    details = {}
    release_regexp = re.compile(r'^(?P<OS>.*) release (?P<release>[\d\.]*)')
    for host in filtered_hosts(config):
        details.setdefault(host, {})
        server = utils.ScriptRunner(host)
        # discover OS and release
        server.append('cat /etc/redhat-release')
        try:
            rc, out = server.execute()
            match = release_regexp.search(out)
            if not match:
                raise exceptions.ScriptRuntimeError()
        except exceptions.ScriptRuntimeError:
            details[host]['os'] = 'Unknown'
            details[host]['release'] = 'Unknown'
        else:
            opsys = match.group('OS')
            for pattern, surr in [('^Red Hat Enterprise Linux.*', 'RHEL'),
                                  ('^Fedora.*', 'Fedora'),
                                  ('^CentOS.*', 'CentOS'),
                                  ('^Scientific Linux.*', 'SL')]:
                opsys = re.sub(pattern, surr, opsys)
            details[host]['os'] = opsys
            details[host]['release'] = match.group('release')

        # Create the packstack tmp directory
        server.clear()
        server.append("mkdir -p %s" % basedefs.PACKSTACK_VAR_DIR)
        # Separately create the tmp directory for this packstack run, this will
        # fail if the directory already exists
        host_dir = os.path.join(basedefs.PACKSTACK_VAR_DIR, uuid.uuid4().hex)
        server.append("mkdir --mode 0700 %s" % host_dir)
        for i in ('modules', 'resources'):
            server.append("mkdir --mode 0700 %s" % os.path.join(host_dir, i))
        server.execute()
        details[host]['tmpdir'] = host_dir
    config['HOST_DETAILS'] = details


def create_manifest(config, messages):
    key = 'CONFIG_DEBUG_MODE'
    config[key] = config[key] == 'y' and 'true' or 'false'

    for hostname in filtered_hosts(config):
        manifestfile = "%s_prescript.pp" % hostname
        manifestdata = getManifestTemplate("prescript.pp")
        appendManifestFile(manifestfile, manifestdata)


def create_ntp_manifest(config, messages):
    srvlist = [i.strip()
               for i in config['CONFIG_NTP_SERVERS'].split(',')
               if i.strip()]
    config['CONFIG_NTP_SERVERS'] = ' '.join(srvlist)

    definiton = '\n'.join(['server %s' % i for i in srvlist])
    config['CONFIG_NTP_SERVER_DEF'] = '%s\n' % definiton

    marker = uuid.uuid4().hex[:16]
    for hostname in filtered_hosts(config):
        manifestdata = getManifestTemplate('ntpd.pp')
        appendManifestFile('%s_ntpd.pp' % hostname,
                           manifestdata,
                           marker=marker)

########NEW FILE########
__FILENAME__ = provision_700
# -*- coding: utf-8 -*-

"""
Installs and configures neutron
"""

import logging

from packstack.installer import utils
from packstack.installer import validators

from packstack.modules.common import is_all_in_one
from packstack.modules.ospluginutils import (appendManifestFile,
                                             getManifestTemplate)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-Provision"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):

    def process_provision(param, process_args=None):
        return param if is_all_in_one(controller.CONF) else 'n'

    conf_params = {
        "PROVISION_INIT": [
            {"CMD_OPTION": "provision-demo",
             "USAGE": ("Whether to provision for demo usage and testing. Note "
                       "that provisioning is only supported for all-in-one "
                       "installations."),
             "PROMPT": ("Would you like to provision for demo usage "
                        "and testing"),
             "OPTION_LIST": ["y", "n"],
             "VALIDATORS": [validators.validate_options],
             "DEFAULT_VALUE": "y",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_PROVISION_DEMO",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "provision-tempest",
             "USAGE": "Whether to configure tempest for testing",
             "PROMPT": ("Would you like to configure Tempest (OpenStack test "
                        "suite). Note that provisioning is only supported for "
                        "all-in-one installations."),
             "OPTION_LIST": ["y", "n"],
             "VALIDATORS": [validators.validate_options],
             "DEFAULT_VALUE": "n",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_PROVISION_TEMPEST",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
            ],

        "PROVISION_DEMO": [
            {"CMD_OPTION": "provision-demo-floatrange",
             "USAGE": "The CIDR network address for the floating IP subnet",
             "PROMPT": "Enter the network address for the floating IP subnet",
             "OPTION_LIST": False,
             "VALIDATORS": False,
             "DEFAULT_VALUE": "172.24.4.224/28",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_PROVISION_DEMO_FLOATRANGE",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
            ],

        "TEMPEST_GIT_REFS": [
            {"CMD_OPTION": "provision-tempest-repo-uri",
             "USAGE": "The uri of the tempest git repository to use",
             "PROMPT": "What is the uri of the Tempest git repository?",
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": "https://github.com/openstack/tempest.git",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_PROVISION_TEMPEST_REPO_URI",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "provision-tempest-repo-revision",
             "USAGE": "The revision of the tempest git repository to use",
             "PROMPT": ("What revision, branch, or tag of the Tempest git "
                        "repository should be used"),
             "OPTION_LIST": [],
             "VALIDATORS": [validators.validate_not_empty],
             "DEFAULT_VALUE": "master",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_PROVISION_TEMPEST_REPO_REVISION",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],

        "PROVISION_ALL_IN_ONE_OVS_BRIDGE": [
            {"CMD_OPTION": "provision-all-in-one-ovs-bridge",
             "USAGE": ("Whether to configure the ovs external bridge in an "
                       "all-in-one deployment"),
             "PROMPT": "Would you like to configure the external ovs bridge",
             "OPTION_LIST": ["y", "n"],
             "VALIDATORS": [validators.validate_options],
             "DEFAULT_VALUE": "n",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_PROVISION_ALL_IN_ONE_OVS_BRIDGE",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},
        ],
    }

    def check_provisioning_demo(config):
        return (allow_provisioning(config) and
                (config.get('CONFIG_PROVISION_DEMO', 'n') == 'y' or
                 config.get('CONFIG_PROVISION_TEMPEST', 'n') == 'y'))

    def check_provisioning_tempest(config):
        return (allow_provisioning(config) and
                config.get('CONFIG_PROVISION_TEMPEST', 'n') == 'y')

    def allow_all_in_one_ovs_bridge(config):
        return (allow_provisioning(config) and
                config['CONFIG_NEUTRON_INSTALL'] == 'y' and
                config['CONFIG_NEUTRON_L2_PLUGIN'] == 'openvswitch')

    conf_groups = [
        {"GROUP_NAME": "PROVISION_INIT",
         "DESCRIPTION": "Provisioning demo config",
         "PRE_CONDITION": lambda x: 'yes',
         "PRE_CONDITION_MATCH": "yes",
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "PROVISION_DEMO",
         "DESCRIPTION": "Provisioning demo config",
         "PRE_CONDITION": allow_provisioning,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "TEMPEST_GIT_REFS",
         "DESCRIPTION": "Optional tempest git uri and branch",
         "PRE_CONDITION": check_provisioning_tempest,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},

        {"GROUP_NAME": "PROVISION_ALL_IN_ONE_OVS_BRIDGE",
         "DESCRIPTION": "Provisioning all-in-one ovs bridge config",
         "PRE_CONDITION": allow_all_in_one_ovs_bridge,
         "PRE_CONDITION_MATCH": True,
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},
        ]
    for group in conf_groups:
        paramList = conf_params[group["GROUP_NAME"]]
        controller.addGroup(group, paramList)

    # Due to group checking some parameters might not be initialized, but
    # provision.pp needs them all. So we will initialize them with default
    # values
    params = [
        controller.getParamByName(x)
        for x in ['CONFIG_PROVISION_TEMPEST_REPO_URI',
                  'CONFIG_PROVISION_TEMPEST_REPO_REVISION',
                  'CONFIG_PROVISION_ALL_IN_ONE_OVS_BRIDGE']
    ]
    for param in params:
        value = controller.CONF.get(param.CONF_NAME, param.DEFAULT_VALUE)
        controller.CONF[param.CONF_NAME] = value


def initSequences(controller):
    config = controller.CONF
    provisioning_required = (
        config['CONFIG_PROVISION_DEMO'] == 'y'
        or
        config['CONFIG_PROVISION_TEMPEST'] == 'y'
    )

    if not provisioning_required or not allow_provisioning(config):
        return

    marshall_conf_bool(config, 'CONFIG_PROVISION_TEMPEST')
    marshall_conf_bool(config, 'CONFIG_PROVISION_ALL_IN_ONE_OVS_BRIDGE')

    provision_steps = [
        {'title': 'Adding Provisioning manifest entries',
         'functions': [create_manifest]}
    ]
    controller.addSequence("Provisioning for Demo and Testing Usage",
                           [], [], provision_steps)


#------------------------- helper functions -------------------------

def marshall_conf_bool(conf, key):
    if conf[key] == 'y':
        conf[key] = 'true'
    else:
        conf[key] = 'false'


def allow_provisioning(config):
    # Provisioning is currently supported only for all-in-one (due
    # to a limitation with how the custom types for OpenStack
    # resources are implemented).
    return is_all_in_one(config)


#-------------------------- step functions --------------------------

def create_manifest(config, messages):
    # Using the neutron or nova api servers as the provisioning target
    # will suffice for the all-in-one case.
    if config['CONFIG_NEUTRON_INSTALL'] != "y":
        # The provisioning template requires the name of the external
        # bridge but the value will be missing if neutron isn't
        # configured to be installed.
        config['CONFIG_NEUTRON_L3_EXT_BRIDGE'] = 'br-ex'

    # Set template-specific parameter to configure whether neutron is
    # available.  The value needs to be true/false rather than the y/n.
    # provided by CONFIG_NEUTRON_INSTALL.
    config['PROVISION_NEUTRON_AVAILABLE'] = config['CONFIG_NEUTRON_INSTALL']
    marshall_conf_bool(config, 'PROVISION_NEUTRON_AVAILABLE')

    manifest_file = '%s_provision.pp' % config['CONFIG_CONTROLLER_HOST']
    manifest_data = getManifestTemplate("provision.pp")
    appendManifestFile(manifest_file, manifest_data)

########NEW FILE########
__FILENAME__ = puppet_950
# -*- coding: utf-8 -*-

"""
Installs and configures puppet
"""

import sys
import logging
import os
import platform
import time

from packstack.installer import utils
from packstack.installer import basedefs, output_messages
from packstack.installer.exceptions import ScriptRuntimeError, PuppetError

from packstack.modules.common import filtered_hosts
from packstack.modules.ospluginutils import manifestfiles
from packstack.modules.puppet import scan_logfile, validate_logfile


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "Puppet"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


PUPPET_DIR = os.environ.get('PACKSTACK_PUPPETDIR',
                            '/usr/share/openstack-puppet/')
MODULE_DIR = os.path.join(PUPPET_DIR, 'modules')


def initConfig(controller):
    group = {"GROUP_NAME": "PUPPET",
             "DESCRIPTION": "Puppet Config parameters",
             "PRE_CONDITION": lambda x: 'yes',
             "PRE_CONDITION_MATCH": "yes",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, [])


def initSequences(controller):
    puppetpresteps = [
        {'title': 'Clean Up', 'functions': [run_cleanup]},
    ]
    controller.insertSequence("Clean Up", [], [], puppetpresteps, index=0)

    puppetsteps = [
        {'title': 'Installing Dependencies',
            'functions': [install_deps]},
        {'title': 'Copying Puppet modules and manifests',
            'functions': [copy_puppet_modules]},
        {'title': 'Applying Puppet manifests',
            'functions': [apply_puppet_manifest]},
        {'title': 'Finalizing',
            'functions': [finalize]}
    ]
    controller.addSequence("Puppet", [], [], puppetsteps)


#------------------------- helper functions -------------------------

def wait_for_puppet(currently_running, messages):
    log_len = 0
    twirl = ["-", "\\", "|", "/"]
    while currently_running:
        for hostname, finished_logfile in currently_running:
            log_file = os.path.splitext(os.path.basename(finished_logfile))[0]
            space_len = basedefs.SPACE_LEN - len(log_file)
            if len(log_file) > log_len:
                log_len = len(log_file)
            if hasattr(sys.stdout, "isatty") and sys.stdout.isatty():
                twirl = twirl[-1:] + twirl[:-1]
                sys.stdout.write(("\rTesting if puppet apply is finished: %s"
                                 % log_file).ljust(40 + log_len))
                sys.stdout.write("[ %s ]" % twirl[0])
                sys.stdout.flush()
            try:
                # Once a remote puppet run has finished, we retrieve the log
                # file and check it for errors
                local_server = utils.ScriptRunner()
                log = os.path.join(basedefs.PUPPET_MANIFEST_DIR,
                                   os.path.basename(finished_logfile))
                log = log.replace(".finished", ".log")
                local_server.append('scp -o StrictHostKeyChecking=no '
                                    '-o UserKnownHostsFile=/dev/null '
                                    'root@%s:%s %s'
                                    % (hostname, finished_logfile, log))
                # To not pollute logs we turn of logging of command execution
                local_server.execute(log=False)

                # If we got to this point the puppet apply has finished
                currently_running.remove((hostname, finished_logfile))

                # clean off the last "testing apply" msg
                if hasattr(sys.stdout, "isatty") and sys.stdout.isatty():
                    sys.stdout.write(("\r").ljust(45 + log_len))

            except ScriptRuntimeError:
                # the test raises an exception if the file doesn't exist yet
                # TO-DO: We need to start testing 'e' for unexpected exceptions
                time.sleep(3)
                continue

            # check log file for relevant notices
            messages.extend(scan_logfile(log))

            # check the log file for errors
            sys.stdout.write('\r')
            try:
                validate_logfile(log)
                state = utils.state_message('%s:' % log_file, 'DONE', 'green')
                sys.stdout.write('%s\n' % state)
                sys.stdout.flush()
            except PuppetError:
                state = utils.state_message('%s:' % log_file, 'ERROR', 'red')
                sys.stdout.write('%s\n' % state)
                sys.stdout.flush()
                raise


#-------------------------- step functions --------------------------

def run_cleanup(config, messages):
    localserver = utils.ScriptRunner()
    localserver.append("rm -rf %s/*pp" % basedefs.PUPPET_MANIFEST_DIR)
    localserver.execute()


def install_deps(config, messages):
    deps = ["puppet", "openssh-clients", "tar", "nc"]
    modules_pkg = 'openstack-puppet-modules'

    local = utils.ScriptRunner()
    local.append('rpm -q --requires %s | egrep -v "^(rpmlib|\/|perl)"'
                 % modules_pkg)
    rc, modules_deps = local.execute()

    # Modules package might not be installed if we are running from source.
    # In this case we assume user knows what (s)he's doing and we don't
    # install modules dependencies
    if ('%s is not installed' % modules_pkg) not in modules_deps:
        modules_deps = [i.strip() for i in modules_deps.split() if i.strip()]
        deps.extend(modules_deps)

    for hostname in filtered_hosts(config):
        server = utils.ScriptRunner(hostname)
        for package in deps:
            server.append("rpm -q --whatprovides %s || yum install -y %s"
                          % (package, package))
        server.execute()


def copy_puppet_modules(config, messages):
    os_modules = ' '.join(('apache', 'ceilometer', 'certmonger', 'cinder',
                           'concat', 'firewall', 'glance', 'heat', 'horizon',
                           'inifile', 'keystone', 'memcached', 'mongodb',
                           'mysql', 'neutron', 'nova', 'nssdb', 'openstack',
                           'packstack', 'qpid', 'rabbitmq', 'rsync', 'ssh',
                           'stdlib', 'swift', 'sysctl', 'tempest', 'vcsrepo',
                           'vlan', 'vswitch', 'xinetd'))

        # write puppet manifest to disk
    manifestfiles.writeManifests()

    server = utils.ScriptRunner()
    for hostname in filtered_hosts(config):
        host_dir = config['HOST_DETAILS'][hostname]['tmpdir']
        # copy Packstack manifests
        server.append("cd %s/puppet" % basedefs.DIR_PROJECT_DIR)
        server.append("cd %s" % basedefs.PUPPET_MANIFEST_DIR)
        server.append("tar --dereference -cpzf - ../manifests | "
                      "ssh -o StrictHostKeyChecking=no "
                      "-o UserKnownHostsFile=/dev/null "
                      "root@%s tar -C %s -xpzf -" % (hostname, host_dir))

        # copy resources
        resources = config.get('RESOURCES', {})
        for path, localname in resources.get(hostname, []):
            server.append("scp -o StrictHostKeyChecking=no "
                          "-o UserKnownHostsFile=/dev/null "
                          "%s root@%s:%s/resources/%s" %
                          (path, hostname, host_dir, localname))

        # copy Puppet modules required by Packstack
        server.append("cd %s" % MODULE_DIR)
        server.append("tar --dereference -cpzf - %s | "
                      "ssh -o StrictHostKeyChecking=no "
                      "-o UserKnownHostsFile=/dev/null "
                      "root@%s tar -C %s -xpzf -" %
                      (os_modules, hostname,
                       os.path.join(host_dir, 'modules')))
    server.execute()


def apply_puppet_manifest(config, messages):
    if config.get("DRY_RUN"):
        return
    currently_running = []
    lastmarker = None
    loglevel = ''
    logcmd = False
    if logging.root.level <= logging.DEBUG:
        loglevel = '--debug'
        logcmd = True
    for manifest, marker in manifestfiles.getFiles():
        # if the marker has changed then we don't want to proceed until
        # all of the previous puppet runs have finished
        if lastmarker is not None and lastmarker != marker:
            wait_for_puppet(currently_running, messages)
        lastmarker = marker

        for hostname in filtered_hosts(config):
            if "%s_" % hostname not in manifest:
                continue

            host_dir = config['HOST_DETAILS'][hostname]['tmpdir']
            print "Applying %s" % manifest
            server = utils.ScriptRunner(hostname)

            man_path = os.path.join(config['HOST_DETAILS'][hostname]['tmpdir'],
                                    basedefs.PUPPET_MANIFEST_RELATIVE,
                                    manifest)

            running_logfile = "%s.running" % man_path
            finished_logfile = "%s.finished" % man_path
            currently_running.append((hostname, finished_logfile))

            server.append("touch %s" % running_logfile)
            server.append("chmod 600 %s" % running_logfile)
            server.append("export PACKSTACK_VAR_DIR=%s" % host_dir)
            cmd = ("( flock %s/ps.lock "
                   "puppet apply %s --modulepath %s/modules %s > %s "
                   "2>&1 < /dev/null ; "
                   "mv %s %s ) > /dev/null 2>&1 < /dev/null &"
                   % (host_dir, loglevel, host_dir, man_path, running_logfile,
                      running_logfile, finished_logfile))
            server.append(cmd)
            server.execute(log=logcmd)

    # wait for outstanding puppet runs befor exiting
    wait_for_puppet(currently_running, messages)


def finalize(config, messages):
    for hostname in filtered_hosts(config):
        server = utils.ScriptRunner(hostname)
        server.append("installed=$(rpm -q kernel --last | head -n1 | "
                      "sed 's/kernel-\([a-z0-9\.\_\-]*\).*/\\1/g')")
        server.append("loaded=$(uname -r | head -n1)")
        server.append('[ "$loaded" == "$installed" ]')
        try:
            rc, out = server.execute()
        except ScriptRuntimeError:
            messages.append('Because of the kernel update the host %s '
                            'requires reboot.' % hostname)

########NEW FILE########
__FILENAME__ = serverprep_949
# -*- coding: utf-8 -*-

"""
prepare server
"""

import os
import re
import uuid
import logging
import platform

from packstack.installer import basedefs
from packstack.installer import exceptions
from packstack.installer import utils
from packstack.installer import validators

from packstack.modules.common import filtered_hosts, is_all_in_one


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-SERVERPREPARE"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    conf_params = {
        "SERVERPREPARE": [
            {"CMD_OPTION": "use-epel",
             "USAGE": "To subscribe each server to EPEL enter \"y\"",
             "PROMPT": "To subscribe each server to EPEL enter \"y\"",
             "OPTION_LIST": ["y", "n"],
             "VALIDATORS": [validators.validate_options],
             "DEFAULT_VALUE": "n",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_USE_EPEL",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "additional-repo",
             "USAGE": ("A comma separated list of URLs to any additional yum "
                       "repositories to install"),
             "PROMPT": ("Enter a comma separated list of URLs to any "
                        "additional yum repositories to install"),
             "OPTION_LIST": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_REPO",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False}
        ],

        "RHEL": [
            {"CMD_OPTION": "rh-username",
             "USAGE": ("To subscribe each server with Red Hat subscription "
                       "manager, include this with CONFIG_RH_PW"),
             "PROMPT": "To subscribe each server to Red Hat enter a username ",
             "OPTION_LIST": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_RH_USER",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "rh-password",
             "USAGE": ("To subscribe each server with Red Hat subscription "
                       "manager, include this with CONFIG_RH_USER"),
             "PROMPT": ("To subscribe each server to Red Hat enter your "
                        "password"),
             "OPTION_LIST": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_RH_PW",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "rhn-satellite-server",
             "USAGE": ("To subscribe each server with RHN Satellite,fill "
                       "Satellite's URL here. Note that either satellite's "
                       "username/password or activation key has "
                       "to be provided"),
             "PROMPT": ("To subscribe each server with RHN Satellite enter "
                        "RHN Satellite server URL"),
             "OPTION_LIST": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_SATELLITE_URL",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False}
        ],

        "SATELLITE": [
            {"CMD_OPTION": "rhn-satellite-username",
             "USAGE": "Username to access RHN Satellite",
             "PROMPT": ("Enter RHN Satellite username or leave plain if you "
                        "will use activation key instead"),
             "OPTION_LIST": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": False,
             "LOOSE_VALIDATION": True,
             "CONF_NAME": "CONFIG_SATELLITE_USER",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "rhn-satellite-password",
             "USAGE": "Password to access RHN Satellite",
             "PROMPT": ("Enter RHN Satellite password or leave plain if you "
                        "will use activation key instead"),
             "OPTION_LIST": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_SATELLITE_PW",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "rhn-satellite-activation-key",
             "USAGE": "Activation key for subscription to RHN Satellite",
             "PROMPT": ("Enter RHN Satellite activation key or leave plain if "
                        "you used username/password instead"),
             "OPTION_LIST": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_SATELLITE_AKEY",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "rhn-satellite-cacert",
             "USAGE": "Specify a path or URL to a SSL CA certificate to use",
             "PROMPT": "Specify a path or URL to a SSL CA certificate to use",
             "OPTION_LIST": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_SATELLITE_CACERT",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "rhn-satellite-profile",
             "USAGE": ("If required specify the profile name that should be "
                       "used as an identifier for the system "
                       "in RHN Satellite"),
             "PROMPT": ("If required specify the profile name that should be "
                        "used as an identifier for the system "
                        "in RHN Satellite"),
             "OPTION_LIST": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_SATELLITE_PROFILE",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "rhn-satellite-flags",
             "USAGE": ("Comma separated list of flags passed to rhnreg_ks. "
                       "Valid flags are: novirtinfo, norhnsd, nopackages"),
             "PROMPT": ("Enter comma separated list of flags passed "
                        "to rhnreg_ks"),
             "OPTION_LIST": ['novirtinfo', 'norhnsd', 'nopackages'],
             "VALIDATORS": [validators.validate_multi_options],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_SATELLITE_FLAGS",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "rhn-satellite-proxy-host",
             "USAGE": "Specify a HTTP proxy to use with RHN Satellite",
             "PROMPT": "Specify a HTTP proxy to use with RHN Satellite",
             "OPTION_LIST": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_SATELLITE_PROXY",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False}
        ],

        "SATELLITE_PROXY": [
            {"CMD_OPTION": "rhn-satellite-proxy-username",
             "USAGE": ("Specify a username to use with an authenticated "
                       "HTTP proxy"),
             "PROMPT": ("Specify a username to use with an authenticated "
                        "HTTP proxy"),
             "OPTION_LIST": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_SATELLITE_PROXY_USER",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False},

            {"CMD_OPTION": "rhn-satellite-proxy-password",
             "USAGE": ("Specify a password to use with an authenticated "
                       "HTTP proxy."),
             "PROMPT": ("Specify a password to use with an authenticated "
                        "HTTP proxy."),
             "OPTION_LIST": [],
             "DEFAULT_VALUE": "",
             "MASK_INPUT": True,
             "LOOSE_VALIDATION": False,
             "CONF_NAME": "CONFIG_SATELLITE_PROXY_PW",
             "USE_DEFAULT": False,
             "NEED_CONFIRM": False,
             "CONDITION": False}
        ]
    }

    def filled_satellite(config):
        return bool(config.get('CONFIG_SATELLITE_URL'))

    def filled_satellite_proxy(config):
        return bool(config.get('CONFIG_SATELLITE_PROXY'))

    conf_groups = [
        {"GROUP_NAME": "SERVERPREPARE",
         "DESCRIPTION": "Server Prepare Configs ",
         "PRE_CONDITION": lambda x: 'yes',
         "PRE_CONDITION_MATCH": "yes",
         "POST_CONDITION": False,
         "POST_CONDITION_MATCH": True},
    ]

    config = controller.CONF
    if (is_all_in_one(config) and is_rhel()) or not is_all_in_one(config):
        conf_groups.append({"GROUP_NAME": "RHEL",
                            "DESCRIPTION": "RHEL config",
                            "PRE_CONDITION": lambda x: 'yes',
                            "PRE_CONDITION_MATCH": "yes",
                            "POST_CONDITION": False,
                            "POST_CONDITION_MATCH": True})

        conf_groups.append({"GROUP_NAME": "SATELLITE",
                            "DESCRIPTION": "RHN Satellite config",
                            "PRE_CONDITION": filled_satellite,
                            "PRE_CONDITION_MATCH": True,
                            "POST_CONDITION": False,
                            "POST_CONDITION_MATCH": True})

        conf_groups.append({"GROUP_NAME": "SATELLITE_PROXY",
                            "DESCRIPTION": "RHN Satellite proxy config",
                            "PRE_CONDITION": filled_satellite_proxy,
                            "PRE_CONDITION_MATCH": True,
                            "POST_CONDITION": False,
                            "POST_CONDITION_MATCH": True})

    for group in conf_groups:
        params = conf_params[group["GROUP_NAME"]]
        controller.addGroup(group, params)


def initSequences(controller):
    preparesteps = [
        {'title': 'Preparing servers', 'functions': [server_prep]}
    ]
    controller.addSequence("Preparing servers", [], [], preparesteps)


#------------------------- helper functions -------------------------

def is_rhel():
    return 'Red Hat Enterprise Linux' in platform.linux_distribution()[0]


def run_rhn_reg(host, server_url, username=None, password=None,
                cacert=None, activation_key=None, profile_name=None,
                proxy_host=None, proxy_user=None, proxy_pass=None,
                flags=None):
    """
    Registers given host to given RHN Satellite server. To successfully
    register either activation_key or username/password is required.
    """
    logging.debug('Setting RHN Satellite server: %s.' % locals())

    mask = []
    cmd = ['/usr/sbin/rhnreg_ks']
    server = utils.ScriptRunner(host)

    # check satellite server url
    server_url = (server_url.rstrip('/').endswith('/XMLRPC')
                  and server_url or '%s/XMLRPC' % server_url)
    cmd.extend(['--serverUrl', server_url])

    if activation_key:
        cmd.extend(['--activationkey', activation_key])
    elif username:
        cmd.extend(['--username', username])
        if password:
            cmd.extend(['--password', password])
            mask.append(password)
    else:
        raise exceptions.InstallError('Either RHN Satellite activation '
                                      'key or username/password must '
                                      'be provided.')

    if cacert:
        # use and if required download given certificate
        location = "/etc/sysconfig/rhn/%s" % os.path.basename(cacert)
        if not os.path.isfile(location):
            logging.debug('Downloading cacert from %s.' % server_url)
            wget_cmd = ('ls %(location)s &> /dev/null && echo -n "" || '
                        'wget -nd --no-check-certificate --timeout=30 '
                        '--tries=3 -O "%(location)s" "%(cacert)s"' %
                        locals())
            server.append(wget_cmd)
        cmd.extend(['--sslCACert', location])

    if profile_name:
        cmd.extend(['--profilename', profile_name])
    if proxy_host:
        cmd.extend(['--proxy', proxy_host])
        if proxy_user:
            cmd.extend(['--proxyUser', proxy_user])
            if proxy_pass:
                cmd.extend(['--proxyPassword', proxy_pass])
                mask.append(proxy_pass)

    flags = flags or []
    flags.append('force')
    for i in flags:
        cmd.append('--%s' % i)

    server.append(' '.join(cmd))
    server.append('yum clean metadata')
    server.execute(mask_list=mask)


def run_rhsm_reg(host, username, password):
    """
    Registers given host to Red Hat Repositories via subscription manager.
    """
    server = utils.ScriptRunner(host)

    # register host
    cmd = ('subscription-manager register --username=\"%s\" '
           '--password=\"%s\" --autosubscribe || true')
    server.append(cmd % (username, password.replace('"', '\\"')))

    # subscribe to required channel
    cmd = ('subscription-manager list --consumed | grep -i openstack || '
           'subscription-manager subscribe --pool %s')
    pool = ("$(subscription-manager list --available | "
            "grep -e 'Red Hat OpenStack' -m 1 -A 2 | grep 'Pool Id' | "
            "awk '{print $3}')")
    server.append(cmd % pool)
    server.append("subscription-manager repos "
                  "--enable rhel-6-server-optional-rpms")

    server.append("yum clean all")
    server.append("rpm -q --whatprovides yum-utils || "
                  "yum install -y yum-utils")
    server.append("yum clean metadata")
    server.execute(mask_list=[password])


def manage_epel(host, config):
    """
    Installs and/or enables EPEL repo if it is required or disables it if it
    is not required.
    """
    if config['HOST_DETAILS'][host]['os'] in ('Fedora', 'Unknown'):
        return

    # yum's $releasever can be non numeric on RHEL, so interpolate here
    releasever = config['HOST_DETAILS'][host]['release'].split('.')[0]
    mirrors = ('https://mirrors.fedoraproject.org/metalink?repo=epel-%s&'
               'arch=$basearch' % releasever)
    server = utils.ScriptRunner(host)
    if config['CONFIG_USE_EPEL'] == 'y':
        server.append('REPOFILE=$(mktemp)')
        server.append('cat /etc/yum.conf > $REPOFILE')
        server.append("echo -e '[packstack-epel]\nname=packstack-epel\n"
                      "enabled=1\nmirrorlist=%(mirrors)s' >> $REPOFILE"
                      % locals())
        server.append('( rpm -q --whatprovides epel-release ||'
                      ' yum install -y --nogpg -c $REPOFILE epel-release ) '
                      '|| true')
        server.append('rm -rf $REPOFILE')
        try:
            server.execute()
        except exceptions.ScriptRuntimeError as ex:
            msg = 'Failed to set EPEL repo on host %s:\n%s' % (host, ex)
            raise exceptions.ScriptRuntimeError(msg)

    # if there's an epel repo explicitly enables or disables it
    # according to: CONFIG_USE_EPEL
    if config['CONFIG_USE_EPEL'] == 'y':
        cmd = 'enable'
        enabled = '(1|True)'
    else:
        cmd = 'disable'
        enabled = '(0|False)'

    server.clear()
    server.append('yum-config-manager --%(cmd)s epel' % locals())
    rc, out = server.execute()

    # yum-config-manager returns 0 always, but returns current setup
    # if succeeds
    match = re.search('enabled\s*\=\s*%(enabled)s' % locals(), out)
    if match:
        return
    msg = 'Failed to set EPEL repo on host %s:\n'
    if cmd == 'enable':
        # fail in case user wants to have EPEL enabled
        msg += ('RPM file seems to be installed, but appropriate repo file is '
                'probably missing in /etc/yum.repos.d/')
        raise exceptions.ScriptRuntimeError(msg % host)
    else:
        # just warn in case disabling failed which might happen when EPEL repo
        # is not installed at all
        msg += 'This is OK in case you don\'t want EPEL installed and enabled.'
        # TO-DO: fill logger name when logging will be refactored.
        logger = logging.getLogger()
        logger.warn(msg % host)


def manage_rdo(host, config):
    """
    Installs and enables RDO repo on host in case it is installed locally.
    """
    try:
        cmd = "rpm -q rdo-release --qf='%{version}-%{release}.%{arch}\n'"
        rc, out = utils.execute(cmd, use_shell=True)
    except exceptions.ExecuteRuntimeError:
        # RDO repo is not installed, so we don't need to continue
        return
    match = re.match(r'^(?P<version>\w+)\-(?P<release>\d+\.[\d\w]+)\n', out)
    version, release = match.group('version'), match.group('release')
    rdo_url = ("http://rdo.fedorapeople.org/openstack/openstack-%(version)s/"
               "rdo-release-%(version)s-%(release)s.rpm" % locals())

    server = utils.ScriptRunner(host)
    server.append("(rpm -q 'rdo-release-%(version)s' ||"
                  " yum install -y --nogpg %(rdo_url)s) || true"
                  % locals())
    try:
        server.execute()
    except exceptions.ScriptRuntimeError as ex:
        msg = 'Failed to set RDO repo on host %s:\n%s' % (host, ex)
        raise exceptions.ScriptRuntimeError(msg)

    reponame = 'openstack-%s' % version
    server.clear()
    server.append('yum-config-manager --enable %(reponame)s' % locals())
    # yum-config-manager returns 0 always, but returns current setup
    # if succeeds
    rc, out = server.execute()
    match = re.search('enabled\s*=\s*(1|True)', out)
    if not match:
        msg = ('Failed to set RDO repo on host %s:\nRPM file seems to be '
               'installed, but appropriate repo file is probably missing '
               'in /etc/yum.repos.d/' % host)
        raise exceptions.ScriptRuntimeError(msg)


#-------------------------- step functions --------------------------

def server_prep(config, messages):
    rh_username = None
    sat_url = None
    if is_rhel():
        rh_username = config["CONFIG_RH_USER"].strip()
        rh_password = config["CONFIG_RH_PW"].strip()

        sat_registered = set()

        sat_url = config["CONFIG_SATELLITE_URL"].strip()
        if sat_url:
            flag_list = config["CONFIG_SATELLITE_FLAGS"].split(',')
            sat_flags = [i.strip() for i in flag_list if i.strip()]
            sat_proxy_user = config.get("CONFIG_SATELLITE_PROXY_USER", '')
            sat_proxy_pass = config.get("CONFIG_SATELLITE_PROXY_PW", '')
            sat_args = {
                'username': config["CONFIG_SATELLITE_USER"].strip(),
                'password': config["CONFIG_SATELLITE_PW"].strip(),
                'cacert': config["CONFIG_SATELLITE_CACERT"].strip(),
                'activation_key': config["CONFIG_SATELLITE_AKEY"].strip(),
                'profile_name': config["CONFIG_SATELLITE_PROFILE"].strip(),
                'proxy_host': config["CONFIG_SATELLITE_PROXY"].strip(),
                'proxy_user': sat_proxy_user.strip(),
                'proxy_pass': sat_proxy_pass.strip(),
                'flags': sat_flags
            }

    for hostname in filtered_hosts(config):
        # Subscribe to Red Hat Repositories if configured
        if rh_username:
            run_rhsm_reg(hostname, rh_username, rh_password)

        # Subscribe to RHN Satellite if configured
        if sat_url and hostname not in sat_registered:
            run_rhn_reg(hostname, sat_url, **sat_args)
            sat_registered.add(hostname)

        server = utils.ScriptRunner(hostname)
        server.append('rpm -q --whatprovides yum-utils || '
                      'yum install -y yum-utils')
        server.execute()

        # enable or disable EPEL according to configuration
        manage_epel(hostname, config)
        # enable RDO if it is installed locally
        manage_rdo(hostname, config)

        reponame = 'rhel-server-ost-6-4-rpms'
        server.clear()
        server.append('yum install -y yum-plugin-priorities || true')
        server.append('rpm -q epel-release && yum-config-manager '
                      '--setopt="%(reponame)s.priority=1" '
                      '--save %(reponame)s' % locals())

        # Add yum repositories if configured
        CONFIG_REPO = config["CONFIG_REPO"].strip()
        if CONFIG_REPO:
            for i, repourl in enumerate(CONFIG_REPO.split(',')):
                reponame = 'packstack_%d' % i
                server.append('echo "[%(reponame)s]\nname=%(reponame)s\n'
                              'baseurl=%(repourl)s\nenabled=1\n'
                              'priority=1\ngpgcheck=0"'
                              ' > /etc/yum.repos.d/%(reponame)s.repo'
                              % locals())

        server.append("yum clean metadata")
        server.execute()

########NEW FILE########
__FILENAME__ = swift_600
# -*- coding: utf-8 -*-

"""
Installs and configures an OpenStack Swift
"""

import os
import re
import uuid
import logging

from packstack.installer import validators
from packstack.installer.exceptions import ParamValidationError
from packstack.installer import basedefs
from packstack.installer import utils
from packstack.installer.utils import split_hosts

from packstack.modules.ospluginutils import (getManifestTemplate,
                                             appendManifestFile, manifestfiles)


#------------------ oVirt installer initialization ------------------

PLUGIN_NAME = "OS-Swift"
PLUGIN_NAME_COLORED = utils.color_text(PLUGIN_NAME, 'blue')


def initConfig(controller):
    params = [
        {"CMD_OPTION": "os-swift-ks-passwd",
         "USAGE": ("The password to use for the Swift to authenticate "
                   "with Keystone"),
         "PROMPT": "Enter the password for the Swift Keystone access",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_SWIFT_KS_PW",
         "USE_DEFAULT": True,
         "NEED_CONFIRM": True,
         "CONDITION": False},

        {"CMD_OPTION": "os-swift-storages",
         "USAGE": ("A comma separated list of devices which to use as Swift "
                   "Storage device. Each entry should take the format "
                   "/path/to/dev, for example /dev/vdb will install /dev/vdb "
                   "as Swift storage device (packstack does not create "
                   "the filesystem, you must do this first). If value is "
                   "omitted Packstack will create a loopback device for test "
                   "setup"),
         "PROMPT": "Enter the Swift Storage devices e.g. /path/to/dev",
         "OPTION_LIST": [],
         "VALIDATORS": [],
         "DEFAULT_VALUE": '',
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_SWIFT_STORAGES",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False,
         "DEPRECATES": ['CONFIG_SWIFT_STORAGE_HOSTS']},

        {"CMD_OPTION": "os-swift-storage-zones",
         "USAGE": ("Number of swift storage zones, this number MUST be "
                   "no bigger than the number of storage devices configured"),
         "PROMPT": ("Enter the number of swift storage zones, MUST be no "
                    "bigger than the number of storage devices configured"),
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_integer],
         "DEFAULT_VALUE": "1",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_SWIFT_STORAGE_ZONES",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-swift-storage-replicas",
         "USAGE": ("Number of swift storage replicas, this number MUST be "
                   "no bigger than the number of storage zones configured"),
         "PROMPT": ("Enter the number of swift storage replicas, MUST be no "
                    "bigger than the number of storage zones configured"),
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_integer],
         "DEFAULT_VALUE": "1",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_SWIFT_STORAGE_REPLICAS",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-swift-storage-fstype",
         "USAGE": "FileSystem type for storage nodes",
         "PROMPT": "Enter FileSystem type for storage nodes",
         "OPTION_LIST": ['xfs', 'ext4'],
         "VALIDATORS": [validators.validate_options],
         "DEFAULT_VALUE": "ext4",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_SWIFT_STORAGE_FSTYPE",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},

        {"CMD_OPTION": "os-swift-hash",
         "USAGE": "Shared secret for Swift",
         "PROMPT": "Enter hash for Swift shared secret",
         "OPTION_LIST": [],
         "VALIDATORS": [validators.validate_not_empty],
         "DEFAULT_VALUE": uuid.uuid4().hex[:16],
         "MASK_INPUT": True,
         "LOOSE_VALIDATION": False,
         "CONF_NAME": "CONFIG_SWIFT_HASH",
         "USE_DEFAULT": True,
         "NEED_CONFIRM": True,
         "CONDITION": False},

        {"CMD_OPTION": "os-swift-storage-size",
         "USAGE": "Size of the swift loopback file storage device",
         "PROMPT": ("Enter the size of the storage device (eg. 2G, 2000M, "
                    "2000000K)"),
         "OPTION_LIST": [],
         "VALIDATORS": [validate_storage_size],
         "DEFAULT_VALUE": "2G",
         "MASK_INPUT": False,
         "LOOSE_VALIDATION": True,
         "CONF_NAME": "CONFIG_SWIFT_STORAGE_SIZE",
         "USE_DEFAULT": False,
         "NEED_CONFIRM": False,
         "CONDITION": False},
    ]
    group = {"GROUP_NAME": "OSSWIFT",
             "DESCRIPTION": "OpenStack Swift Config parameters",
             "PRE_CONDITION": "CONFIG_SWIFT_INSTALL",
             "PRE_CONDITION_MATCH": "y",
             "POST_CONDITION": False,
             "POST_CONDITION_MATCH": True}
    controller.addGroup(group, params)


def initSequences(controller):
    if controller.CONF['CONFIG_SWIFT_INSTALL'] != 'y':
        return

    steps = [
        {'title': 'Adding Swift Keystone manifest entries',
         'functions': [create_keystone_manifest]},
        {'title': 'Adding Swift builder manifest entries',
         'functions': [create_builder_manifest]},
        {'title': 'Adding Swift proxy manifest entries',
         'functions': [create_proxy_manifest]},
        {'title': 'Adding Swift storage manifest entries',
         'functions': [create_storage_manifest]},
        {'title': 'Adding Swift common manifest entries',
         'functions': [create_common_manifest]},
    ]
    controller.addSequence("Installing OpenStack Swift", [], [], steps)


#------------------------- helper functions -------------------------

def validate_storage_size(param, options=None):
    match = re.match(r'\d+G|\d+M|\d+K', param, re.IGNORECASE)
    if not match:
        msg = 'Storage size not have a valid value (eg. 1G, 1000M, 1000000K)'
        raise ParamValidationError(msg)


def parse_devices(config):
    """
    Returns dict containing information about Swift storage devices.
    """
    devices = []
    device_number = 0
    num_zones = int(config["CONFIG_SWIFT_STORAGE_ZONES"])
    for device in config["CONFIG_SWIFT_STORAGES"].split(","):
        device = device.strip()
        if not device:
            continue
        device_number += 1
        zone = str((device_number % num_zones) + 1)
        devices.append({'device': device, 'zone': zone,
                        'device_name': 'device%s' % device_number})
    if not devices:
        devices.append({'device': None, 'zone': 1,
                        'device_name': 'swiftloopback'})
    return devices


def check_device(host, device):
    """
    Raises ScriptRuntimeError if given device is not mounted on given
    host.
    """
    server = utils.ScriptRunner(host)

    # the device MUST exist
    cmd = 'ls -l %s'
    server.append(cmd % device)

    # if it is not mounted then we can use it
    cmd = 'grep "%s " /proc/self/mounts || exit 0'
    server.append(cmd % device)

    # if it is mounted then the mount point has to be in /srv/node
    cmd = 'grep "%s /srv/node" /proc/self/mounts && exit 0'
    server.append(cmd % device)

    # if we got here without exiting then we can't use this device
    server.append('exit 1')
    server.execute()


def get_storage_size(config):
    ranges = {'G': 1048576, 'M': 1024, 'K': 1}
    size = config['CONFIG_SWIFT_STORAGE_SIZE'].strip()
    for measure in ['G', 'M', 'K']:
        if re.match('\d+' + measure, size, re.IGNORECASE):
            intsize = int(size.rstrip(measure)) * ranges[measure]
            return intsize


#-------------------------- step functions --------------------------

def create_keystone_manifest(config, messages):
    # parse devices in first step
    global devices
    devices = parse_devices(config)
    manifestfile = "%s_keystone.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("keystone_swift.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_builder_manifest(config, messages):
    global devices
    # The ring file should be built and distributed before the storage services
    # come up. Specifically the replicator crashes if the ring isn't present

    def device_def(dev_type, host, dev_port, devicename, zone):
        fmt = ('\n@@%s { "%s:%s/%s":\n'
               '  zone   => %s,\n'
               '  weight => 10, }\n')
        return fmt % (dev_type, host, dev_port, devicename, zone)

    manifestfile = "%s_ring_swift.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("swift_builder.pp")

    # Add each device to the ring
    devicename = 0
    for device in devices:
        host = config['CONFIG_CONTROLLER_HOST']
        devicename = device['device_name']
        zone = device['zone']
        for dev_type, dev_port in [('ring_object_device', 6000),
                                   ('ring_container_device', 6001),
                                   ('ring_account_device', 6002)]:
            manifestdata += device_def(dev_type, host, dev_port, devicename,
                                       zone)
    appendManifestFile(manifestfile, manifestdata, 'swiftbuilder')


def create_proxy_manifest(config, messages):
    manifestfile = "%s_swift.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("swift_proxy.pp")
    appendManifestFile(manifestfile, manifestdata)


def create_storage_manifest(config, messages):
    global devices

    manifestfile = "%s_swift.pp" % config['CONFIG_CONTROLLER_HOST']
    manifestdata = getManifestTemplate("swift_storage.pp")

    # this need to happen once per storage device
    for device in devices:
        host = config['CONFIG_CONTROLLER_HOST']
        devicename = device['device_name']
        device = device['device']
        fstype = config["CONFIG_SWIFT_STORAGE_FSTYPE"]
        if device:
            check_device(host, device)
            manifestdata += ('\nswift::storage::%s { "%s":\n'
                             '  device => "%s",\n}\n'
                             % (fstype, devicename, device))
        else:
            # create loopback device if none was specified
            config['CONFIG_SWIFT_STORAGE_SEEK'] = get_storage_size(config)
            manifestdata += "\n" + getManifestTemplate("swift_loopback.pp")

    # set allowed hosts for firewall
    hosts = set([config['CONFIG_CONTROLLER_HOST']])
    if config['CONFIG_NOVA_INSTALL'] == 'y':
        hosts |= split_hosts(config['CONFIG_COMPUTE_HOSTS'])

    config['FIREWALL_SERVICE_NAME'] = "swift storage and rsync"
    config['FIREWALL_PORTS'] = "'6000', '6001', '6002', '873'"
    config['FIREWALL_CHAIN'] = "INPUT"

    for host in hosts:
        config['FIREWALL_ALLOWED'] = "'%s'" % host
        config['FIREWALL_SERVICE_ID'] = "swift_storage_and_rsync_%s" % host
        manifestdata += getManifestTemplate("firewall.pp")

    appendManifestFile(manifestfile, manifestdata)


def create_common_manifest(config, messages):
    for manifestfile, marker in manifestfiles.getFiles():
        if manifestfile.endswith("_swift.pp"):
            data = getManifestTemplate("swift_common.pp")
            appendManifestFile(os.path.split(manifestfile)[1], data)

########NEW FILE########
__FILENAME__ = netns
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import contextlib
import inspect
import os
import random
import subprocess
import sys
import tempfile
import time
import uuid
import unittest


def execute(cmd_string, check_error=True, return_code=0, input=None,
            block=True, error_msg='Error executing cmd'):
    print cmd_string
    cmd = cmd_string.split(' ')
    proc = subprocess.Popen(cmd,
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    if input:
        proc.communicate(input=input)
    elif block:
        proc.wait()
    if (check_error and
            proc.returncode is not None and
            proc.returncode != return_code):
        msg = """
%(error_msg)s
 Command: %(cmd)s
 Exit Code: %(code)s
""".strip() % dict(cmd=' '.join(cmd),
                   code=proc.returncode,
                   error_msg=error_msg)
        if input:
            msg += "\n Stdin: %s" % input
        if not proc.stdout.closed:
            msg += "\n Stdout: %s" % proc.stdout.read()
        if not proc.stderr.closed:
            msg += "\n Stderr: %s" % proc.stderr.read()
        raise Exception(msg)
    return proc


def e(cmd, prefix='ip netns exec ', sudo=False, **kwargs):
    frame_locals = inspect.getargvalues(sys._getframe(1))[3]
    if sudo:
        prefix = 'sudo ' + prefix
    return execute(prefix + cmd % frame_locals, **kwargs)


def rand_name(name='test'):
    return '%s-%s' % (name, str(random.randint(1, 0x7fffffff)))


@contextlib.contextmanager
def add_namespace():
    name = rand_name('testns')
    try:
        e('ip netns add %(name)s', prefix='')
        e('%(name)s ip link set lo up')
        yield name
    finally:
        e('ip netns delete %(name)s', prefix='')


@contextlib.contextmanager
def add_namespaces():
    with add_namespace() as ns1:
        with add_namespace() as ns2:
            yield ns1, ns2


def add_veth_pair(ns1, ns2, veth1, veth2, address1, address2):
    e('ip link add %(veth1)s netns %(ns1)s type veth '
      'peer name %(veth2)s netns %(ns2)s', prefix='')
    e('%(ns1)s ip link show %(veth1)s')
    e('%(ns2)s ip link show %(veth2)s')
    e('%(ns1)s ip -4 addr add %(address1)s/24 brd 255.255.255.0 '
      'scope global dev %(veth1)s')
    e('%(ns2)s ip -4 addr add %(address2)s/24 brd 255.255.255.0 '
      'scope global dev %(veth2)s')
    e('%(ns1)s ip link set %(veth1)s up')
    e('%(ns2)s ip link set %(veth2)s up')


class TestNetns(unittest.TestCase):

    def test_neutron_netns_cmds(self):
        """Exercise the netns functionality required by neutron.

          - Check that a veth pair can be configured to transit traffic
            between 2 namespaces
          - Check that iptables filtering can be configured
          - Check that iptables routing can be configured

        """
        # Naming scheme [resource][id]_[namespace id]
        veth1_1 = 'veth1_1'
        veth1_2 = 'veth1_2'
        address1_1 = '192.168.0.1'
        address1_2 = '192.168.0.2'
        with add_namespaces() as (ns1, ns2):
            # Check that inter-namespace connectivity can be established
            add_veth_pair(ns1, ns2, veth1_1, veth1_2, address1_1, address1_2)
            e('%(ns1)s ip link list')
            e('%(ns1)s ip link show %(veth1_1)s')
            e('%(ns1)s arping -A -U -I %(veth1_1)s '
              '-c 1 %(address1_1)s')
            e('%(ns2)s route add default gw %(address1_1)s')
            e('%(ns2)s ping -c 1 -w 1 %(address1_1)s')
            e('ping -c 1 -w 1 %(address1_1)s', prefix='', return_code=1,
              error_msg='Namespace isolation not supported!')

            # Check that iptables filtering and save/restore can be performed
            try:
                iptables_filename = os.path.join(
                                        tempfile.gettempdir(),
                                        'iptables-%s' % str(uuid.uuid4()))
                e('%%(ns1)s iptables-save > %s' % iptables_filename)
                e('%(ns1)s iptables -A INPUT -p icmp --icmp-type 8 -j DROP')
                e('%(ns2)s ping -c 1 -w 1 %(address1_1)s', return_code=1)
                e('%%(ns1)s iptables-restore < %s' % iptables_filename)
                e('%(ns2)s ping -c 1 -w 1 %(address1_1)s')
            finally:
                if os.path.exists(iptables_filename):
                    os.unlink(iptables_filename)

            # Create another namespace (ns3) that is connected to ns1
            # via a different subnet, so that traffic between ns3 and
            # ns2 will have to be routed by ns1:
            #
            #  ns2 <- 192.168.0.0/24 -> ns1 <- 192.168.1.0/24 -> ns3
            #
            with add_namespace() as ns3:
                veth2_1 = 'veth2_1'
                veth2_3 = 'veth2_3'
                address2_1 = '192.168.1.1'
                address2_3 = '192.168.1.2'
                add_veth_pair(ns1, ns3, veth2_1, veth2_3,
                              address2_1, address2_3)
                e('%(ns1)s sysctl -w net.ipv4.ip_forward=1')
                e('%(ns1)s iptables -t nat -A POSTROUTING -o %(veth2_1)s -j '
                  'MASQUERADE')
                e('%(ns1)s iptables -A FORWARD -i %(veth2_1)s -o %(veth1_1)s '
                  '-m state --state RELATED,ESTABLISHED -j ACCEPT')
                e('%(ns1)s iptables -A FORWARD -i %(veth1_1)s -o %(veth2_1)s '
                  '-j ACCEPT')
                e('%(ns2)s ping -c 1 -w 1 %(address2_3)s')

            # Check that links can be torn down
            e('%(ns1)s ip -4 addr del %(address1_1)s/24 '
              'dev %(veth1_1)s')
            e('%(ns1)s ip link delete %(veth1_1)s')

    def test_domain_socket_access(self):
        """Check that a domain socket can be accessed regardless of namespace.

        Neutron extends nova' metadata service - which identifies VM's
        by their ip addresses - to configurations with overlapping
        ips.  Support is provided by:

          - a proxy in each namespace (neutron-ns-metadata-proxy)

            - the proxy can uniquely identify a given VM by its ip
              address in the context of the router or network of the
              namespace.

          - a metadata agent (neutron-metadata-agent) that forwards
            requests from the namespace proxies to nova's metadata
            service.

        Communication between the proxies and the agent is over a unix
        domain socket.  It is necessary that access to a domain socket
        not be restricted by namespace, or such communication will not
        be possible.

        """
        try:
            execute('which nc')
        except Exception:
            self.fail("The 'nc' command is not available - please install it.")

        sock_filename = os.path.join(tempfile.gettempdir(),
                                     'testsock-%s' % str(uuid.uuid4()))
        server = None
        try:
            # Create a server in the root namespace attached to a domain socket
            server = e('nc -lU %(sock_filename)s', sudo=False, prefix='',
                       block=False)
            # Attempt to connect to the domain socket from within a namespace
            with add_namespace() as ns:
                e('%(ns)s nc -U %(sock_filename)s', input='magic',
                  error_msg='Unable to communicate between namespaces via '
                            'domain sockets.')
        finally:
            if server:
                server.kill()
            if os.path.exists(sock_filename):
                os.unlink(sock_filename)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = version

VERSION = ['2014', '1', '1']
FINAL=False
RELEASE="Icehouse"
SNAPTAG=None

def release_string():
    return RELEASE

def version_string():
    if FINAL:
        return '.'.join(filter(None, VERSION))
    else:
        return '.'.join(filter(None, VERSION))+"dev{0}".format(SNAPTAG)

########NEW FILE########
__FILENAME__ = test_drones
# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2013, Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import os
import shutil
import tempfile
import subprocess
from unittest import TestCase

from ..test_base import PackstackTestCaseMixin
from packstack.installer.core.drones import *
from packstack.installer import utils


class SshTarballTransferMixinTestCase(PackstackTestCaseMixin, TestCase):
    def setUp(self):
        # Creating a temp directory that can be used by tests
        self.tempdir = tempfile.mkdtemp()

    def tearDown(self):
        # remove the temp directory
        #shutil.rmtree(self.tempdir)
        pass

    def setUp(self):
        self.tempdir = tempfile.mkdtemp()
        # prepare resource files
        res1path = os.path.join(self.tempdir, 'res1.txt')
        with open(res1path, 'w') as f:
            f.write('resource one')
        resdir = os.path.join(self.tempdir, 'resdir')
        os.mkdir(resdir)
        res2path = os.path.join(resdir, 'res2.txt')
        with open(res2path, 'w') as f:
            f.write('resource two')
        # prepare recipe files
        rec1path = os.path.join(self.tempdir, 'rec1.pp')
        with open(rec1path, 'w') as f:
            f.write('recipe one')
        recdir = os.path.join(self.tempdir, 'recdir')
        os.mkdir(recdir)
        rec2path = os.path.join(recdir, 'rec2.pp')
        with open(rec2path, 'w') as f:
            f.write('recipe two')
        # prepare class
        self.mixin = SshTarballTransferMixin()
        self.mixin.node = '127.0.0.1'
        self.mixin.resource_dir = os.path.join(self.tempdir, 'remote')
        self.mixin.recipe_dir = os.path.join(self.tempdir, 'remote',
                                             'recipes')
        self.mixin.local_tmpdir = os.path.join(self.tempdir, 'loctmp')
        self.mixin.remote_tmpdir = os.path.join(self.tempdir, 'remtmp')
        self.mixin._resources = [(res1path, 'resources'),
                                 (resdir, 'resources')]
        self.mixin._recipes = {'one': [rec1path], 'two': [rec2path]}

        for i in (self.mixin.resource_dir, self.mixin.recipe_dir,
                  self.mixin.local_tmpdir, self.mixin.remote_tmpdir):
            os.mkdir(i)

    def test_tarball_packing(self):
        """
        Tests packing of resources and recipes
        """
        # pack
        res_path = self.mixin._pack_resources()
        rec_path = self.mixin._pack_recipes()
        # unpack
        for pack_path in (res_path, rec_path):
            tarball = tarfile.open(pack_path)
            tarball.extractall(path=self.tempdir)
        # check content of files
        for path, content in \
                [('resources/res1.txt', 'resource one'),
                 ('resources/resdir/res2.txt', 'resource two'),
                 ('recipes/rec1.pp', 'recipe one'),
                 ('recipes/rec2.pp', 'recipe two')]:
            with open(os.path.join(self.tempdir, path)) as f:
                fcont = f.read()
                self.assertEqual(fcont, content)
        # clean for next test
        shutil.rmtree(os.path.join(self.tempdir, 'resources'))
        shutil.rmtree(os.path.join(self.tempdir, 'recipes'))

    '''
    # uncomment this test only on local machines
    def test_transfer(self):
        """
        Tests resources transfer if sshd to 127.0.0.1 is enabled.
        """
        remtmp = self.mixin.resource_dir
        server = utils.ScriptRunner('127.0.0.1')
        try:
           server.append('echo "test"')
           server.execute()
        except ScripRuntimeError:
            return
        # transfer
        self.mixin._copy_resources()
        self.mixin._copy_recipes()
        # check content of files
        for path, content in \
                [('resources/res1.txt', 'resource one'),
                 ('resources/resdir/res2.txt', 'resource two'),
                 ('recipes/rec1.pp', 'recipe one'),
                 ('recipes/rec2.pp', 'recipe two')]:
            with open(os.path.join(remtmp, path)) as f:
                fcont = f.read()
                self.assertEqual(fcont, content)
        # clean for next test
        server = utils.ScriptRunner('127.0.0.1')
        server.append('rm -fr %s' % remtmp)
        server.execute()
    '''


class FakeDroneObserver(DroneObserver):
    def __init__(self, *args, **kwargs):
        super(FakeDroneObserver, self).__init__(*args, **kwargs)
        self.log = []

    def applying(self, drone, recipe):
        """
        Drone is calling this method when it starts applying recipe.
        """
        self.log.append('applying:%s' % recipe)

    def checking(self, drone, recipe):
        """
        Drone is calling this method when it starts checking if recipe
        has been applied.
        """
        self.log.append('checking:%s' % recipe)

    def finished(self, drone, recipe):
        """
        Drone is calling this method when it's finished with recipe
        application.
        """
        # subclass must implement this method
        self.log.append('finished:%s' % recipe)


class FakeDrone(Drone):
    def __init__(self, *args, **kwargs):
        super(FakeDrone, self).__init__(*args, **kwargs)
        self.log = []

    def _apply(self, recipe):
        self.log.append(recipe)

    def _finished(self, recipe):
        return True


class DroneTestCase(PackstackTestCaseMixin, TestCase):
    def setUp(self):
        super(DroneTestCase, self).setUp()
        self.observer = FakeDroneObserver()
        self.drone = FakeDrone('127.0.0.1')
        self.drone.add_recipe('/some/recipe/path1.rec')
        self.drone.add_recipe('/some/recipe/path2.rec')
        self.drone.add_recipe('/some/recipe/path3a.rec', marker='test')
        self.drone.add_recipe('/some/recipe/path3b.rec', marker='test')
        self.drone.add_recipe('/some/recipe/path4a.rec', marker='next')
        self.drone.add_recipe('/some/recipe/path4b.rec', marker='next')
        self.drone.add_recipe('/some/recipe/path5.rec')

    def test_drone_behavior(self):
        """
        Tests Drone's recipe application order.
        """
        self.drone.log = []
        self.drone.apply()

        rdir = self.drone.recipe_dir
        recpaths = [os.path.join(rdir, os.path.basename(i))
                    for i in self.drone.recipes]
        self.assertListEqual(self.drone.log, recpaths)

    def test_observer_behavior(self):
        """
        Tests DroneObserver calling.
        """
        self.drone.set_observer(self.observer)
        self.drone.apply()

        rdir = self.drone.recipe_dir.rstrip('/')
        first = ['applying:/some/recipe/path1.rec',
                 'checking:%s/path1.rec' % rdir,
                 'finished:%s/path1.rec' % rdir,
                 'applying:/some/recipe/path2.rec',
                 'checking:%s/path2.rec' % rdir,
                 'finished:%s/path2.rec' % rdir]
        last = ['applying:/some/recipe/path5.rec',
                'checking:%s/path5.rec' % rdir,
                'finished:%s/path5.rec' % rdir]
        self.assertListEqual(self.observer.log[:6], first)
        self.assertListEqual(self.observer.log[-3:], last)
        self.assertEqual(len(self.observer.log), 21)

########NEW FILE########
__FILENAME__ = test_processors
# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2013, Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import os
import shutil
import tempfile
from unittest import TestCase
from packstack.installer.processors import *

from ..test_base import PackstackTestCaseMixin


class ProcessorsTestCase(PackstackTestCaseMixin, TestCase):
    def test_process_host(self):
        """Test packstack.installer.processors.process_host"""
        proc_local = process_host('localhost',
                                  process_args={'allow_localhost': True})
        self.assertIn(proc_local, ['127.0.0.1', '::1'])

    def test_process_ssh_key(self):
        """Test packstack.installer.processors.process_ssh_key"""
        path = process_ssh_key(os.path.join(self.tempdir, 'id_rsa'))
        # test if key was created
        self.assertEquals(True, bool(path))
        # test if key exists
        # XXX: process_ssh_key does not create ssh key during test run
        #      ... not sure why, nevertheless it works in normal run
        #self.assertEquals(True, os.path.isfile(path))

########NEW FILE########
__FILENAME__ = test_sequences
# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2013, Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import sys
import StringIO
from unittest import TestCase

from packstack.installer import utils
from packstack.installer.core.sequences import *

from ..test_base import PackstackTestCaseMixin


class StepTestCase(PackstackTestCaseMixin, TestCase):
    def setUp(self):
        super(StepTestCase, self).setUp()
        self._stdout = sys.stdout
        sys.stdout = StringIO.StringIO()

    def tearDown(self):
        super(StepTestCase, self).tearDown()
        sys.stdout = self._stdout

    def test_run(self):
        """
        Test packstack.instaler.core.sequences.Step run.
        """
        def func(config, messages):
            if 'test' not in config:
                raise AssertionError('Missing config value.')

        step = Step('test', func, title='Running test')
        step.run(config={'test': 'test'})
        contents = sys.stdout.getvalue()

        state = '[ %s ]\n' % utils.color_text('DONE', 'green')
        if not contents.startswith('Running test') or \
           not contents.endswith(state):
            raise AssertionError('Step run test failed: %s' % contents)


class SequenceTestCase(PackstackTestCaseMixin, TestCase):
    def setUp(self):
        super(SequenceTestCase, self).setUp()
        self._stdout = sys.stdout
        sys.stdout = StringIO.StringIO()

        self.steps = [{'name': '1', 'function': lambda x, y: True,
                       'title': 'Step 1'},
                      {'name': '2', 'function': lambda x, y: True,
                       'title': 'Step 2'},
                      {'name': '3', 'function': lambda x, y: True,
                       'title': 'Step 3'}]

        self.seq = Sequence('test', self.steps, condition='test',
                                                cond_match='test')

    def tearDown(self):
        super(SequenceTestCase, self).tearDown()
        sys.stdout = self._stdout

    def test_run(self):
        """
        Test packstack.instaler.core.sequences.Sequence run.
        """
        self.seq.run()
        contents = sys.stdout.getvalue()
        self.assertEqual(contents, '')

        self.seq.run(config={'test': 'test'}, step='2')
        contents = sys.stdout.getvalue()
        assert contents.startswith('Step 2')

        output = []
        self.steps.insert(0, {'title': 'Step 2'})
        for i in self.steps:
            output.append('%s\n' % utils.state_message(i['title'],
                                                       'DONE', 'green'))

        self.seq.run(config={'test': 'test'})
        contents = sys.stdout.getvalue()
        self.assertEqual(contents, ''.join(output))

########NEW FILE########
__FILENAME__ = test_utils
# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2013, Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Test cases for packstack.installer.utils module.
"""

import shutil
import tempfile
from unittest import TestCase

from ..test_base import PackstackTestCaseMixin, FakePopen
from packstack.installer.utils import *
from packstack.installer.utils.strings import STR_MASK
from packstack.installer.exceptions import ExecuteRuntimeError


cnt = 0


class ParameterTestCase(PackstackTestCaseMixin, TestCase):
    def setUp(self):
        # Creating a temp directory that can be used by tests
        self.tempdir = tempfile.mkdtemp()
        FakePopen.register('echo "this is test"',
                           stdout='this is test')

    def tearDown(self):
        # remove the temp directory
        shutil.rmtree(self.tempdir)

    def test_sorteddict(self):
        """Test packstack.installer.utils.datastructures.SortedDict"""
        sdict = SortedDict()
        sdict['1'] = 1
        sdict['2'] = 2
        sdict.update(SortedDict([('3', 3), ('4', 4), ('5', 5)]))
        self.assertListEqual(sdict.keys(), ['1', '2', '3', '4', '5'])
        self.assertListEqual(sdict.values(), [1, 2, 3, 4, 5])

    def test_retry(self):
        """Test packstack.installer.utils.decorators.retry"""

        @retry(count=3, delay=0, retry_on=ValueError)
        def test_sum():
            global cnt
            cnt += 1
            raise ValueError

        global cnt
        cnt = 0

        try:
            test_sum()
        except ValueError:
            pass
        self.assertEqual(cnt, 4)
        self.assertRaises(ValueError, test_sum)

    def test_network(self):
        """Test packstack.installer.utils.network functions"""
        self.assertIn(host2ip('localhost', allow_localhost=True),
                      ['127.0.0.1', '::1'])

    def test_shell(self):
        """Test packstack.installer.utils.shell functions"""
        rc, out = execute(['echo', 'this is test'])
        self.assertEqual(out.strip(), 'this is test')
        rc, out = execute('echo "this is test"', use_shell=True)
        self.assertEqual(out.strip(), 'this is test')
        try:
            execute('echo "mask the password" && exit 1',
                    use_shell=True, mask_list=['password'])
            raise AssertionError('Masked execution failed.')
        except ExecuteRuntimeError, ex:
            should_be = ('Failed to execute command, stdout: mask the %s\n\n'
                         'stderr: ' % STR_MASK)
            self.assertEqual(str(ex), should_be)

        script = ScriptRunner()
        script.append('echo "this is test"')
        rc, out = script.execute()
        self.assertEqual(out.strip(), 'this is test')

    def test_strings(self):
        """Test packstack.installer.utils.strings functions"""
        self.assertEqual(color_text('test text', 'red'),
                        '\033[0;31mtest text\033[0m')
        self.assertEqual(mask_string('test text', mask_list=['text']),
                         'test %s' % STR_MASK)
        masked = mask_string("test '\\''text'\\''",
                             mask_list=["'text'"],
                             replace_list=[("'", "'\\''")])
        self.assertEqual(masked, 'test %s' % STR_MASK)

    def test_shortcuts(self):
        """Test packstack.installer.utils.shortcuts functions"""
        conf = {"A_HOST": "1.1.1.1", "B_HOSTS": "2.2.2.2,1.1.1.1",
                "C_HOSTS": "3.3.3.3/vdc"}
        hostlist = list(hosts(conf))
        hostlist.sort()
        self.assertEquals(['1.1.1.1', '2.2.2.2', '3.3.3.3'], hostlist)

########NEW FILE########
__FILENAME__ = test_validators
# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2013, Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import os
import shutil
import tempfile
from unittest import TestCase
from packstack.installer.validators import *

from ..test_base import PackstackTestCaseMixin


class ValidatorsTestCase(PackstackTestCaseMixin, TestCase):
    def setUp(self):
        # Creating a temp directory that can be used by tests
        self.tempdir = tempfile.mkdtemp()

    def tearDown(self):
        # remove the temp directory
        shutil.rmtree(self.tempdir)

    def test_validate_integer(self):
        """Test packstack.installer.validators.validate_integer"""
        validate_integer('1')
        self.assertRaises(ParamValidationError, validate_integer, 'test')

    def test_validate_regexp(self):
        """Test packstack.installer.validators.validate_regexp"""
        validate_regexp('Test_123', options=['\w'])
        self.assertRaises(ParamValidationError, validate_regexp,
                          '!#$%', options=['\w'])

    def test_validate_port(self):
        """Test packstack.installer.validators.validate_port"""
        validate_port('666')
        self.assertRaises(ParamValidationError, validate_port, 'test')
        self.assertRaises(ParamValidationError, validate_port, '-3')

    def test_validate_not_empty(self):
        """Test packstack.installer.validators.validate_not_empty"""
        validate_not_empty('test')
        validate_not_empty(False)
        self.assertRaises(ParamValidationError, validate_not_empty, '')
        self.assertRaises(ParamValidationError, validate_not_empty, [])
        self.assertRaises(ParamValidationError, validate_not_empty, {})

    def test_validate_options(self):
        """Test packstack.installer.validators.validate_options"""
        validate_options('a', options=['a', 'b'])
        validate_options('b', options=['a', 'b'])
        self.assertRaises(ParamValidationError, validate_options,
                          'c', options=['a', 'b'])

    def test_validate_ip(self):
        """Test packstack.installer.validators.validate_ip"""
        validate_ip('127.0.0.1')
        validate_ip('::1')
        self.assertRaises(ParamValidationError, validate_ip, 'test')

    def test_validate_file(self):
        """Test packstack.installer.validators.validate_file"""
        fname = os.path.join(self.tempdir, '.test_validate_file')
        bad_name = os.path.join(self.tempdir, '.me_no_exists')
        with open(fname, 'w') as f:
            f.write('test')
        validate_file(fname)
        self.assertRaises(ParamValidationError, validate_file, bad_name)

    def test_validate_ping(self):
        """Test packstack.installer.validators.validate_ping"""
        # ping to broadcast fails
        self.assertRaises(ParamValidationError, validate_ping,
                          '255.255.255.255')

    def test_validate_ssh(self):
        """Test packstack.installer.validators.validate_ssh"""
        # ssh to broadcast fails
        self.assertRaises(ParamValidationError, validate_ssh,
                          '255.255.255.255')

    def test_validate_float(self):
        """Test packstack.installer.validators.validate_float"""
        validate_float('5.3')
        self.assertRaises(ParamValidationError, validate_float, 'test')

########NEW FILE########
__FILENAME__ = test_ospluginutils
# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2013, Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import os
from unittest import TestCase

from ..test_base import PackstackTestCaseMixin
from packstack.modules.ospluginutils import gethostlist


class OSPluginUtilsTestCase(PackstackTestCaseMixin, TestCase):
    def test_gethostlist(self):
        conf = {"A_HOST": "1.1.1.1", "B_HOSTS": "2.2.2.2,1.1.1.1",
                "C_HOSTS": "3.3.3.3/vdc"}
        hosts = gethostlist(conf)
        hosts.sort()
        self.assertEquals(['1.1.1.1', '2.2.2.2', '3.3.3.3'], hosts)

########NEW FILE########
__FILENAME__ = test_puppet
# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2013, Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import os

from unittest import TestCase
from ..test_base import PackstackTestCaseMixin

from packstack.installer.exceptions import PuppetError
from packstack.modules.puppet import validate_logfile, scan_logfile


class PuppetTestCase(PackstackTestCaseMixin, TestCase):

    def test_validate_logfile(self):
        """Test packstack.modules.validate_logfile"""
        filename = os.path.join(self.tempdir, "puppet.log")
        # test valid run
        with open(filename, "w") as fp:
            fp.write("Everything went ok")
        validate_logfile(filename)
        # test invalid run
        with open(filename, "w") as fp:
            fp.write("No matching value for selector param 'Fedora' ...")
        self.assertRaises(PuppetError, validate_logfile, filename)
        # test run with error exception
        with open(filename, "w") as fp:
            err = ("err: Could not prefetch database_grant provider 'mysql': "
                   "Execution of '/usr/bin/mysql --defaults-file=/root/.my.cnf"
                   " mysql -Be describe user' returned 1: Could not open "
                   "required defaults file: /root/.my.cnf")
            fp.write(err)
        validate_logfile(filename)
        # test surrogate
        with open(filename, "w") as fp:
            err = ("err: /Stage[main]/Vswitch::Ovs/Package[openvswitch]/ensure"
                   ": change from absent to present failed: Execution of "
                   "'/usr/bin/yum -d 0 -e 0 -y install openvswitch' returned "
                   "1: Error: Nothing to do")
            fp.write(err)
        self.assertRaises(PuppetError, validate_logfile, filename)
        try:
            validate_logfile(filename)
        except PuppetError as ex:
            ex_msg = str(ex)
            sr_msg = ("Package openvswitch has not been found in enabled Yum "
                      "repos")
            assert sr_msg in ex_msg

########NEW FILE########
__FILENAME__ = test_base
# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2013, Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import shutil
import tempfile
import subprocess
import logging
import re

from packstack.installer.utils.shell import block_fmt
from packstack.installer.exceptions import (ScriptRuntimeError,
                                            NetworkError)
from packstack.installer.utils.strings import mask_string

LOG = logging.getLogger(__name__)


class FakePopen(object):
    '''The FakePopen class replaces subprocess.Popen. Instead of actually
    executing commands, it permits the caller to register a list of
    commands the output to produce using the FakePopen.register and
    FakePopen.register_as_script method.  By default, FakePopen will return
    empty stdout and stderr and a successful (0) returncode.
    '''

    cmd_registry = {}
    script_registry = {}

    @classmethod
    def register(cls, args, stdout='', stderr='', returncode=0):
        '''Register a fake command.'''
        if isinstance(args, list):
            args = tuple(args)
        cls.cmd_registry[args] = {'stdout': stdout,
                                  'stderr': stderr,
                                  'returncode': returncode}

    @classmethod
    def register_as_script(cls, args, stdout='', stderr='', returncode=0):
        '''Register a fake script.'''
        if isinstance(args, list):
            args = '\n'.join(args)
        prefix = "function t(){ exit $? ; } \n trap t ERR \n"
        args = prefix + args
        cls.script_registry[args] = {'stdout': stdout,
                                     'stderr': stderr,
                                     'returncode': returncode}

    def __init__(self, args, **kwargs):
        script = ["ssh", "-o", "StrictHostKeyChecking=no",
                  "-o", "UserKnownHostsFile=/dev/null"]
        if args[-1] == "bash -x" and args[:5] == script:
            self._init_as_script(args, **kwargs)
        else:
            self._init_as_cmd(args, **kwargs)

    def _init_as_cmd(self, args, **kwargs):
        self._is_script = False
        if isinstance(args, list):
            args = tuple(args)
            cmd = ' '.join(args)
        else:
            cmd = args

        if args in self.cmd_registry:
            this = self.cmd_registry[args]
        else:
            LOG.warn('call to unregistered command: %s', cmd)
            this = {'stdout': '', 'stderr': '', 'returncode': 0}

        self.stdout = this['stdout']
        self.stderr = this['stderr']
        self.returncode = this['returncode']

    def _init_as_script(self, args, **kwargs):
        self._is_script = True

    def communicate(self, input=None):
        if self._is_script:
            if input in self.script_registry:
                this = self.script_registry[input]
            else:
                LOG.warn('call to unregistered script: %s', input)
                this = {'stdout': '', 'stderr': '', 'returncode': 0}
            self.stdout = this['stdout']
            self.stderr = this['stderr']
            self.returncode = this['returncode']
        return self.stdout, self.stderr


class PackstackTestCaseMixin(object):
    """
    Implementation of some assertion methods available by default
    in Python2.7+ only
    """
    def setUp(self):
        # Creating a temp directory that can be used by tests
        self.tempdir = tempfile.mkdtemp()

        # some plugins call popen, we're replacing it for tests
        self._Popen = subprocess.Popen
        self.fake_popen = subprocess.Popen = FakePopen

    def tearDown(self):
        # remove the temp directory
        shutil.rmtree(self.tempdir)
        subprocess.Popen = self._Popen

    def assertItemsEqual(self, list1, list2, msg=None):
        f, s = len(list1), len(list2)
        _msg = msg or ('Element counts were not equal. First has %s, '
                       'Second has %s' % (f, s))
        self.assertEqual(f, s, msg=_msg)

        _msg = msg or ('Given lists differ:\n%(list1)s'
                       '\n%(list2)s' % locals())
        for i in list1:
            if i not in list2:
                raise AssertionError(_msg)

    def assertListEqual(self, list1, list2, msg=None):
        f, s = len(list1), len(list2)
        _msg = msg or ('Element counts were not equal. First has %s, '
                       'Second has %s' % (f, s))
        self.assertEqual(f, s, msg=_msg)

        _msg = msg or ('Given lists differ:\n%(list1)s'
                       '\n%(list2)s' % locals())
        for index, item in enumerate(list1):
            if item != list2[index]:
                raise AssertionError(_msg)

    def assertIsInstance(self, obj, cls, msg=None):
        _msg = msg or ('%s is not an instance of %s' % (obj, cls))
        if not isinstance(obj, cls):
            raise AssertionError(_msg)

    def assertIn(self, first, second, msg=None):
        _msg = msg or ('%s is not a member of %s' % (first, second))
        if first not in second:
            raise AssertionError(_msg)

    def assertIsNone(self, expr, msg=None):
        _msg = msg or ('%s is not None' % expr)
        if expr is not None:
            raise AssertionError(_msg)

########NEW FILE########
__FILENAME__ = test_plugin_serverprep
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2013, Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import os
from unittest import TestCase

from test_base import PackstackTestCaseMixin
from packstack.plugins import serverprep_949
from packstack.installer.setup_controller import Controller

serverprep_949.controller = Controller()


class OSPluginUtilsTestCase(PackstackTestCaseMixin, TestCase):
    def test_rhn_creds_quoted(self):
        """Make sure RHN password is quoted"""

        # On non-RHEL, the CONFIG_{RH,SATELLITE} options are never set,
        # i.e. this test would always fail. Therefore, only run it on RHEL.
        if not serverprep_949.is_rhel():
            return

        password = "dasd|'asda%><?"

        serverprep_949.controller.CONF["CONFIG_KEYSTONE_HOST"] = "1.2.3.4"
        serverprep_949.controller.CONF["CONFIG_USE_EPEL"] = "n"
        serverprep_949.controller.CONF["CONFIG_REPO"] = ""
        serverprep_949.controller.CONF["CONFIG_RH_USER"] = "testuser"
        serverprep_949.controller.CONF["CONFIG_RH_PW"] = password
        serverprep_949.controller.CONF["CONFIG_RH_BETA_REPO"] = "n"

        serverprep_949.controller.CONF["CONFIG_SATELLITE_FLAGS"] = ""
        serverprep_949.controller.CONF["CONFIG_SATELLITE_URL"] = ""
        serverprep_949.controller.CONF["CONFIG_SATELLITE_USER"] = ""
        serverprep_949.controller.CONF["CONFIG_SATELLITE_PW"] = ""
        serverprep_949.controller.CONF["CONFIG_SATELLITE_CACERT"] = ""
        serverprep_949.controller.CONF["CONFIG_SATELLITE_AKEY"] = ""
        serverprep_949.controller.CONF["CONFIG_SATELLITE_PROFILE"] = ""
        serverprep_949.controller.CONF["CONFIG_SATELLITE_PROXY"] = ""
        serverprep_949.controller.CONF["CONFIG_SATELLITE_PROXY_USER"] = ""
        serverprep_949.controller.CONF["CONFIG_SATELLITE_PROXY_PW"] = ""

        serverprep_949.serverprep(serverprep_949.controller.CONF)

        self.assertNotEqual(
            self.fake_popen.data.find('--password="%s"' % password), -1
        )

########NEW FILE########
