__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Pecan documentation build configuration file, created by
# sphinx-quickstart on Sat Oct  9 14:41:27 2010.
#
# This file is execfile()d w/ the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import pkg_resources

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration ----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']

intersphinx_mapping = {
    'python': ('http://docs.python.org', None),
    'webob': ('http://docs.webob.org/en/latest', None),
    'webtest': ('http://webtest.readthedocs.org/en/latest/', None),
    'beaker': ('http://beaker.readthedocs.org/en/latest/', None),
    'paste': ('http://pythonpaste.org', None),
}

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Pecan'
copyright = u'2010, Jonathan LaCour'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
dist = pkg_resources.get_distribution('pecan')
version = release = dist.version
# The full version, including alpha/beta/rc tags.
#release = '0.3.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output --------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Pecandoc'


# -- Options for LaTeX output -------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual])
latex_documents = [
  ('index', 'Pecan.tex', u'Pecan Documentation',
   u'Jonathan LaCour', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output -------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pecan', u'Pecan Documentation',
     [u'Jonathan LaCour'], 1)
]

########NEW FILE########
__FILENAME__ = base
import pkg_resources
import argparse
import logging
import sys
from warnings import warn

import six

log = logging.getLogger(__name__)


class HelpfulArgumentParser(argparse.ArgumentParser):

    def error(self, message):  # pragma: nocover
        """error(message: string)

        Prints a usage message incorporating the message to stderr and
        exits.

        If you override this in a subclass, it should not return -- it
        should either exit or raise an exception.
        """
        self.print_help(sys.stderr)
        self._print_message('\n')
        self.exit(2, '%s: %s\n' % (self.prog, message))


class CommandManager(object):
    """ Used to discover `pecan.command` entry points. """

    def __init__(self):
        self.commands = {}
        self.load_commands()

    def load_commands(self):
        for ep in pkg_resources.iter_entry_points('pecan.command'):
            log.debug('%s loading plugin %s', self.__class__.__name__, ep)
            if ep.name in self.commands:
                warn(
                    "Duplicate entry points found on `%s` - ignoring %s" % (
                        ep.name,
                        ep
                    ),
                    RuntimeWarning
                )
                continue
            try:
                cmd = ep.load()
                assert hasattr(cmd, 'run')
            except Exception as e:  # pragma: nocover
                warn("Unable to load plugin %s: %s" % (ep, e), RuntimeWarning)
                continue
            self.add({ep.name: cmd})

    def add(self, cmd):
        self.commands.update(cmd)


class CommandRunner(object):
    """ Dispatches `pecan` command execution requests. """

    def __init__(self):
        self.manager = CommandManager()
        self.parser = HelpfulArgumentParser(add_help=True)
        self.parser.add_argument(
            '--version',
            action='version',
            version='Pecan %s' % self.version
        )
        self.parse_sub_commands()

    def parse_sub_commands(self):
        subparsers = self.parser.add_subparsers(
            dest='command_name',
            metavar='command'
        )
        for name, cmd in self.commands.items():
            sub = subparsers.add_parser(
                name,
                help=cmd.summary
            )
            for arg in getattr(cmd, 'arguments', tuple()):
                arg = arg.copy()
                if isinstance(arg.get('name'), six.string_types):
                    sub.add_argument(arg.pop('name'), **arg)
                elif isinstance(arg.get('name'), list):
                    sub.add_argument(*arg.pop('name'), **arg)

    def run(self, args):
        ns = self.parser.parse_args(args)
        self.commands[ns.command_name]().run(ns)

    @classmethod
    def handle_command_line(cls):  # pragma: nocover
        runner = CommandRunner()
        runner.run(sys.argv[1:])

    @property
    def version(self):
        return pkg_resources.get_distribution('pecan').version

    @property
    def commands(self):
        return self.manager.commands


class BaseCommandMeta(type):

    @property
    def summary(cls):
        """
        This is used to populate the --help argument on the command line.

        This provides a default behavior which takes the first sentence of the
        command's docstring and uses it.
        """
        return cls.__doc__.strip().splitlines()[0].rstrip('.')


class BaseCommandParent(object):
    """
    A base interface for Pecan commands.

    Can be extended to support ``pecan`` command extensions in individual Pecan
    projects, e.g.,

    $ ``pecan my-custom-command config.py``

    ::

        # myapp/myapp/custom_command.py
        class CustomCommand(pecan.commands.base.BaseCommand):
            '''
            (First) line of the docstring is used to summarize the command.
            '''

            arguments = ({
                'name': '--extra_arg',
                'help': 'an extra command line argument',
                'optional': True
            })

            def run(self, args):
                super(SomeCommand, self).run(args)
                if args.extra_arg:
                    pass
    """

    arguments = ({
        'name': 'config_file',
        'help': 'a Pecan configuration file',
        'nargs': '?',
        'default': None,
    },)

    def run(self, args):
        """To be implemented by subclasses."""
        self.args = args

    def load_app(self):
        from pecan import load_app
        return load_app(self.args.config_file)

BaseCommand = BaseCommandMeta('BaseCommand', (BaseCommandParent,), {
    '__doc__': BaseCommandParent.__doc__
})

########NEW FILE########
__FILENAME__ = create
"""
Create command for Pecan
"""
import pkg_resources
import logging
from warnings import warn
from pecan.commands import BaseCommand
from pecan.scaffolds import DEFAULT_SCAFFOLD

log = logging.getLogger(__name__)


class ScaffoldManager(object):
    """ Used to discover `pecan.scaffold` entry points. """

    def __init__(self):
        self.scaffolds = {}
        self.load_scaffolds()

    def load_scaffolds(self):
        for ep in pkg_resources.iter_entry_points('pecan.scaffold'):
            log.debug('%s loading scaffold %s', self.__class__.__name__, ep)
            try:
                cmd = ep.load()
                assert hasattr(cmd, 'copy_to')
            except Exception as e:  # pragma: nocover
                warn(
                    "Unable to load scaffold %s: %s" % (ep, e), RuntimeWarning
                )
                continue
            self.add({ep.name: cmd})

    def add(self, cmd):
        self.scaffolds.update(cmd)


class CreateCommand(BaseCommand):
    """
    Creates the file layout for a new Pecan scaffolded project.
    """

    manager = ScaffoldManager()

    arguments = ({
        'name': 'project_name',
        'help': 'the (package) name of the new project'
    }, {
        'name': 'template_name',
        'metavar': 'template_name',
        'help': 'a registered Pecan template',
        'nargs': '?',
        'default': DEFAULT_SCAFFOLD,
        'choices': manager.scaffolds.keys()
    })

    def run(self, args):
        super(CreateCommand, self).run(args)
        self.manager.scaffolds[args.template_name]().copy_to(
            args.project_name
        )

########NEW FILE########
__FILENAME__ = serve
"""
Serve command for Pecan.
"""
from __future__ import print_function
import logging
import os
import sys
import time
import subprocess
from wsgiref.simple_server import WSGIRequestHandler


from pecan.commands import BaseCommand
from pecan import util


logger = logging.getLogger(__name__)


class ServeCommand(BaseCommand):
    """
    Serves a Pecan web application.

    This command serves a Pecan web application using the provided
    configuration file for the server and application.
    """

    arguments = BaseCommand.arguments + ({
        'name': '--reload',
        'help': 'Watch for changes and automatically reload.',
        'default': False,
        'action': 'store_true'
    },)

    def run(self, args):
        super(ServeCommand, self).run(args)
        app = self.load_app()
        self.serve(app, app.config)

    def create_subprocess(self):
        self.server_process = subprocess.Popen(
            [arg for arg in sys.argv if arg != '--reload'],
            stdout=sys.stdout, stderr=sys.stderr
        )

    def watch_and_spawn(self, conf):
        from watchdog.observers import Observer
        from watchdog.events import (
            FileSystemEventHandler, FileSystemMovedEvent, FileModifiedEvent,
            DirModifiedEvent
        )

        print('Monitoring for changes...')
        self.create_subprocess()

        parent = self

        class AggressiveEventHandler(FileSystemEventHandler):
            def should_reload(self, event):
                for t in (
                    FileSystemMovedEvent, FileModifiedEvent, DirModifiedEvent
                ):
                    if isinstance(event, t):
                        return True
                return False

            def on_modified(self, event):
                if self.should_reload(event):
                    parent.server_process.kill()
                    parent.create_subprocess()

        # Determine a list of file paths to monitor
        paths = self.paths_to_monitor(conf)

        event_handler = AggressiveEventHandler()
        for path, recurse in paths:
            observer = Observer()
            observer.schedule(
                event_handler,
                path=path,
                recursive=recurse
            )
            observer.start()

        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            pass

    def paths_to_monitor(self, conf):
        paths = []

        for package_name in getattr(conf.app, 'modules', []):
            module = __import__(package_name, fromlist=['app'])
            if hasattr(module, 'app') and hasattr(module.app, 'setup_app'):
                paths.append((
                    os.path.dirname(module.__file__),
                    True
                ))
                break

        paths.append((os.path.dirname(conf.__file__), False))
        return paths

    def _serve(self, app, conf):
        from wsgiref.simple_server import make_server

        host, port = conf.server.host, int(conf.server.port)
        srv = make_server(
            host,
            port,
            app,
            handler_class=PecanWSGIRequestHandler,
        )

        print('Starting server in PID %s' % os.getpid())

        if host == '0.0.0.0':
            print(
                'serving on 0.0.0.0:%s, view at http://127.0.0.1:%s' %
                (port, port)
            )
        else:
            print("serving on http://%s:%s" % (host, port))

        try:
            srv.serve_forever()
        except KeyboardInterrupt:
            # allow CTRL+C to shutdown
            pass

    def serve(self, app, conf):
        """
        A very simple approach for a WSGI server.
        """

        if self.args.reload:
            try:
                self.watch_and_spawn(conf)
            except ImportError:
                print('The `--reload` option requires `watchdog` to be '
                      'installed.')
                print('   $ pip install watchdog')
        else:
            self._serve(app, conf)


def gunicorn_run():
    """
    The ``gunicorn_pecan`` command for launching ``pecan`` applications
    """
    try:
        from gunicorn.app.wsgiapp import WSGIApplication
    except ImportError as exc:
        args = exc.args
        arg0 = args[0] if args else ''
        arg0 += ' (are you sure `gunicorn` is installed?)'
        exc.args = (arg0,) + args[1:]
        raise

    class PecanApplication(WSGIApplication):

        def init(self, parser, opts, args):
            if len(args) != 1:
                parser.error("No configuration file was specified.")

            self.cfgfname = os.path.normpath(
                os.path.join(os.getcwd(), args[0])
            )
            self.cfgfname = os.path.abspath(self.cfgfname)
            if not os.path.exists(self.cfgfname):
                parser.error("Config file not found: %s" % self.cfgfname)

            from pecan.configuration import _runtime_conf, set_config
            set_config(self.cfgfname, overwrite=True)

            # If available, use the host and port from the pecan config file
            cfg = {}
            if _runtime_conf.get('server'):
                server = _runtime_conf['server']
                if hasattr(server, 'host') and hasattr(server, 'port'):
                    cfg['bind'] = '%s:%s' % (
                        server.host, server.port
                    )
            return cfg

        def load(self):
            from pecan.deploy import deploy
            return deploy(self.cfgfname)

    PecanApplication("%(prog)s [OPTIONS] config.py").run()


class PecanWSGIRequestHandler(WSGIRequestHandler, object):
    """
    A wsgiref request handler class that allows actual log output depending on
    the application configuration.
    """

    def __init__(self, *args, **kwargs):
        # We set self.path to avoid crashes in log_message() on unsupported
        # requests (like "OPTIONS").
        self.path = ''
        super(PecanWSGIRequestHandler, self).__init__(*args, **kwargs)

    def log_message(self, format, *args):
        """
        overrides the ``log_message`` method from the wsgiref server so that
        normal logging works with whatever configuration the application has
        been set to.

        Levels are inferred from the HTTP status code, 4XX codes are treated as
        warnings, 5XX as errors and everything else as INFO level.
        """
        code = args[1][0]
        levels = {
            '4': 'warning',
            '5': 'error'
        }

        log_handler = getattr(logger, levels.get(code, 'info'))
        log_handler(format % args)

########NEW FILE########
__FILENAME__ = shell
"""
Shell command for Pecan.
"""
from pecan.commands import BaseCommand
from webtest import TestApp
from warnings import warn
import sys


class NativePythonShell(object):
    """
    Open an interactive python shell with the Pecan app loaded.
    """

    @classmethod
    def invoke(cls, ns, banner):  # pragma: nocover
        """
        :param ns: local namespace
        :param banner: interactive shell startup banner

        Embed an interactive native python shell.
        """
        import code
        py_prefix = sys.platform.startswith('java') and 'J' or 'P'
        shell_banner = 'Pecan Interactive Shell\n%sython %s\n\n' % \
            (py_prefix, sys.version)
        shell = code.InteractiveConsole(locals=ns)
        try:
            import readline  # noqa
        except ImportError:
            pass
        shell.interact(shell_banner + banner)


class IPythonShell(object):
    """
    Open an interactive ipython shell with the Pecan app loaded.
    """

    @classmethod
    def invoke(cls, ns, banner):  # pragma: nocover
        """
        :param ns: local namespace
        :param banner: interactive shell startup banner

        Embed an interactive ipython shell.
        Try the InteractiveShellEmbed API first, fall back on
        IPShellEmbed for older IPython versions.
        """
        try:
            from IPython.frontend.terminal.embed import (
                InteractiveShellEmbed
            )
            # try and load their default profile
            from IPython.frontend.terminal.ipapp import (
                load_default_config
            )
            config = load_default_config()
            shell = InteractiveShellEmbed(config=config, banner2=banner)
            shell(local_ns=ns)
        except ImportError:
            # Support for the IPython <= 0.10 shell API
            from IPython.Shell import IPShellEmbed
            shell = IPShellEmbed(argv=[])
            shell.set_banner(shell.IP.BANNER + '\n\n' + banner)
            shell(local_ns=ns, global_ns={})


class BPythonShell(object):
    """
    Open an interactive bpython shell with the Pecan app loaded.
    """

    @classmethod
    def invoke(cls, ns, banner):  # pragma: nocover
        """
        :param ns: local namespace
        :param banner: interactive shell startup banner

        Embed an interactive bpython shell.
        """
        from bpython import embed
        embed(ns, ['-i'], banner)


class ShellCommand(BaseCommand):
    """
    Open an interactive shell with the Pecan app loaded.
    Attempt to invoke the specified python shell flavor
    (ipython, bpython, etc.). Fall back on the native
    python shell if the requested flavor variance is not
    installed.
    """

    SHELLS = {
        'python': NativePythonShell,
        'ipython': IPythonShell,
        'bpython': BPythonShell,
    }

    arguments = BaseCommand.arguments + ({
        'name': ['--shell', '-s'],
        'help': 'which Python shell to use',
        'choices': SHELLS.keys(),
        'default': 'python'
    },)

    def run(self, args):
        """
        Load the pecan app, prepare the locals, sets the
        banner, and invokes the python shell.
        """
        super(ShellCommand, self).run(args)

        # load the application
        app = self.load_app()

        # prepare the locals
        locs = dict(__name__='pecan-admin')
        locs['wsgiapp'] = app
        locs['app'] = TestApp(app)

        model = self.load_model(app.config)
        if model:
            locs['model'] = model

        # insert the pecan locals
        from pecan import abort, conf, redirect, request, response
        locs['abort'] = abort
        locs['conf'] = conf
        locs['redirect'] = redirect
        locs['request'] = request
        locs['response'] = response

        # prepare the banner
        banner = '  The following objects are available:\n'
        banner += '  %-10s - This project\'s WSGI App instance\n' % 'wsgiapp'
        banner += '  %-10s - The current configuration\n' % 'conf'
        banner += '  %-10s - webtest.TestApp wrapped around wsgiapp\n' % 'app'
        if model:
            model_name = getattr(
                model,
                '__module__',
                getattr(model, '__name__', 'model')
            )
            banner += '  %-10s - Models from %s\n' % ('model', model_name)

        self.invoke_shell(locs, banner)

    def invoke_shell(self, locs, banner):
        """
        Invokes the appropriate flavor of the python shell.
        Falls back on the native python shell if the requested
        flavor (ipython, bpython,etc) is not installed.
        """
        shell = self.SHELLS[self.args.shell]
        try:
            shell().invoke(locs, banner)
        except ImportError as e:
            warn((
                "%s is not installed, `%s`, "
                "falling back to native shell") % (self.args.shell, e),
                RuntimeWarning
            )
            if shell == NativePythonShell:
                raise
            NativePythonShell().invoke(locs, banner)

    def load_model(self, config):
        """
        Load the model extension module
        """
        for package_name in getattr(config.app, 'modules', []):
            module = __import__(package_name, fromlist=['model'])
            if hasattr(module, 'model'):
                return module.model
        return None

########NEW FILE########
__FILENAME__ = configuration
import re
import inspect
import os

import six


IDENTIFIER = re.compile(r'[a-z_](\w)*$', re.IGNORECASE)

DEFAULT = {
    # Server Specific Configurations
    'server': {
        'port': '8080',
        'host': '0.0.0.0'
    },

    # Pecan Application Configurations
    'app': {
        'root': None,
        'modules': [],
        'static_root': 'public',
        'template_path': '',
        'force_canonical': True
    }
}


class ConfigDict(dict):
    pass


class Config(object):
    '''
    Base class for Pecan configurations.

    Create a Pecan configuration object from a dictionary or a
    filename.

    :param conf_dict: A python dictionary to use for the configuration.
    :param filename: A filename to use for the configuration.
    '''

    def __init__(self, conf_dict={}, filename=''):

        self.__values__ = {}
        self.__file__ = filename
        self.update(conf_dict)

    def empty(self):
        self.__values__ = {}

    def update(self, conf_dict):
        '''
        Updates this configuration with a dictionary.

        :param conf_dict: A python dictionary to update this configuration
                          with.
        '''

        if isinstance(conf_dict, dict):
            iterator = six.iteritems(conf_dict)
        else:
            iterator = iter(conf_dict)

        for k, v in iterator:
            if not IDENTIFIER.match(k):
                raise ValueError('\'%s\' is not a valid indentifier' % k)

            cur_val = self.__values__.get(k)

            if isinstance(cur_val, Config):
                cur_val.update(conf_dict[k])
            else:
                self[k] = conf_dict[k]

    def get(self, attribute, default=None):
        try:
            return self[attribute]
        except KeyError:
            return default

    def __dictify__(self, obj, prefix):
        '''
        Private helper method for to_dict.
        '''
        for k, v in obj.copy().items():
            if prefix:
                del obj[k]
                k = "%s%s" % (prefix, k)
            if isinstance(v, Config):
                v = self.__dictify__(dict(v), prefix)
            obj[k] = v
        return obj

    def to_dict(self, prefix=None):
        '''
        Converts recursively the Config object into a valid dictionary.

        :param prefix: A string to optionally prefix all key elements in the
                       returned dictonary.
        '''

        conf_obj = dict(self)
        return self.__dictify__(conf_obj, prefix)

    def __getattr__(self, name):
        try:
            return self.__values__[name]
        except KeyError:
            msg = "'pecan.conf' object has no attribute '%s'" % name
            raise AttributeError(msg)

    def __getitem__(self, key):
        return self.__values__[key]

    def __setitem__(self, key, value):
        if isinstance(value, dict) and not isinstance(value, ConfigDict):
            if value.get('__force_dict__'):
                del value['__force_dict__']
                self.__values__[key] = ConfigDict(value)
            else:
                self.__values__[key] = Config(value, filename=self.__file__)
        elif isinstance(value, six.string_types) and '%(confdir)s' in value:
            confdir = os.path.dirname(self.__file__) or os.getcwd()
            self.__values__[key] = value.replace('%(confdir)s', confdir)
        else:
            self.__values__[key] = value

    def __iter__(self):
        return six.iteritems(self.__values__)

    def __dir__(self):
        """
        When using dir() returns a list of the values in the config.  Note:
        This function only works in Python2.6 or later.
        """
        return list(self.__values__.keys())

    def __repr__(self):
        return 'Config(%s)' % str(self.__values__)


def conf_from_file(filepath):
    '''
    Creates a configuration dictionary from a file.

    :param filepath: The path to the file.
    '''

    abspath = os.path.abspath(os.path.expanduser(filepath))
    conf_dict = {}
    if not os.path.isfile(abspath):
        raise RuntimeError('`%s` is not a file.' % abspath)

    with open(abspath, 'rb') as f:
        exec(compile(f.read(), abspath, 'exec'), globals(), conf_dict)
    conf_dict['__file__'] = abspath

    return conf_from_dict(conf_dict)


def get_conf_path_from_env():
    '''
    If the ``PECAN_CONFIG`` environment variable exists and it points to
    a valid path it will return that, otherwise it will raise
    a ``RuntimeError``.
    '''
    config_path = os.environ.get('PECAN_CONFIG')
    if not config_path:
        error = "PECAN_CONFIG is not set and " \
                "no config file was passed as an argument."
    elif not os.path.isfile(config_path):
        error = "PECAN_CONFIG was set to an invalid path: %s" % config_path
    else:
        return config_path

    raise RuntimeError(error)


def conf_from_dict(conf_dict):
    '''
    Creates a configuration dictionary from a dictionary.

    :param conf_dict: The configuration dictionary.
    '''
    conf = Config(filename=conf_dict.get('__file__', ''))

    for k, v in six.iteritems(conf_dict):
        if k.startswith('__'):
            continue
        elif inspect.ismodule(v):
            continue

        conf[k] = v
    return conf


def initconf():
    '''
    Initializes the default configuration and exposes it at
    ``pecan.configuration.conf``, which is also exposed at ``pecan.conf``.
    '''
    return conf_from_dict(DEFAULT)


def set_config(config, overwrite=False):
    '''
    Updates the global configuration.

    :param config: Can be a dictionary containing configuration, or a string
                   which represents a (relative) configuration filename.
    '''

    if config is None:
        config = get_conf_path_from_env()

    # must be after the fallback other a bad fallback will incorrectly clear
    if overwrite is True:
        _runtime_conf.empty()

    if isinstance(config, six.string_types):
        config = conf_from_file(config)
        _runtime_conf.update(config)
        if config.__file__:
            _runtime_conf.__file__ = config.__file__
    elif isinstance(config, dict):
        _runtime_conf.update(conf_from_dict(config))
    else:
        raise TypeError('%s is neither a dictionary or a string.' % config)


_runtime_conf = initconf()

########NEW FILE########
__FILENAME__ = core
try:
    from simplejson import loads
except ImportError:             # pragma: no cover
    from json import loads      # noqa
from itertools import chain
from mimetypes import guess_type, add_type
from os.path import splitext
import logging
import operator

import six

from webob import Request, Response, exc, acceptparse

from .compat import urlparse, unquote_plus, izip
from .secure import handle_security
from .templating import RendererFactory
from .routing import lookup_controller, NonCanonicalPath
from .util import _cfg, encode_if_needed
from .middleware.recursive import ForwardRequestException


# make sure that json is defined in mimetypes
add_type('application/json', '.json', True)

state = None
logger = logging.getLogger(__name__)


def proxy(key):
    class ObjectProxy(object):
        def __getattr__(self, attr):
            obj = getattr(state, key)
            return getattr(obj, attr)

        def __setattr__(self, attr, value):
            obj = getattr(state, key)
            return setattr(obj, attr, value)

        def __delattr__(self, attr):
            obj = getattr(state, key)
            return delattr(obj, attr)

        def __dir__(self):
            obj = getattr(state, key)
            return dir(obj)

    return ObjectProxy()


request = proxy('request')
response = proxy('response')


def override_template(template, content_type=None):
    '''
    Call within a controller to override the template that is used in
    your response.

    :param template: a valid path to a template file, just as you would specify
                     in an ``@expose``.
    :param content_type: a valid MIME type to use for the response.func_closure
    '''

    request.pecan['override_template'] = template
    if content_type:
        request.pecan['override_content_type'] = content_type


def abort(status_code=None, detail='', headers=None, comment=None, **kw):
    '''
    Raise an HTTP status code, as specified. Useful for returning status
    codes like 401 Unauthorized or 403 Forbidden.

    :param status_code: The HTTP status code as an integer.
    :param detail: The message to send along, as a string.
    :param headers: A dictionary of headers to send along with the response.
    :param comment: A comment to include in the response.
    '''

    raise exc.status_map[status_code](
        detail=detail,
        headers=headers,
        comment=comment,
        **kw
    )


def redirect(location=None, internal=False, code=None, headers={},
             add_slash=False):
    '''
    Perform a redirect, either internal or external. An internal redirect
    performs the redirect server-side, while the external redirect utilizes
    an HTTP 302 status code.

    :param location: The HTTP location to redirect to.
    :param internal: A boolean indicating whether the redirect should be
                     internal.
    :param code: The HTTP status code to use for the redirect. Defaults to 302.
    :param headers: Any HTTP headers to send with the response, as a
                    dictionary.
    '''

    if add_slash:
        if location is None:
            split_url = list(urlparse.urlsplit(state.request.url))
            new_proto = state.request.environ.get(
                'HTTP_X_FORWARDED_PROTO', split_url[0]
            )
            split_url[0] = new_proto
        else:
            split_url = urlparse.urlsplit(location)

        split_url[2] = split_url[2].rstrip('/') + '/'
        location = urlparse.urlunsplit(split_url)

    if not headers:
        headers = {}
    if internal:
        if code is not None:
            raise ValueError('Cannot specify a code for internal redirects')
        request.environ['pecan.recursive.context'] = request.context
        raise ForwardRequestException(location)
    if code is None:
        code = 302
    raise exc.status_map[code](location=location, headers=headers)


def render(template, namespace):
    '''
    Render the specified template using the Pecan rendering framework
    with the specified template namespace as a dictionary. Useful in a
    controller where you have no template specified in the ``@expose``.

    :param template: The path to your template, as you would specify in
                     ``@expose``.
    :param namespace: The namespace to use for rendering the template, as a
                      dictionary.
    '''

    return state.app.render(template, namespace)


def load_app(config, **kwargs):
    '''
    Used to load a ``Pecan`` application and its environment based on passed
    configuration.

    :param config: Can be a dictionary containing configuration, a string which
                    represents a (relative) configuration filename

    returns a pecan.Pecan object
    '''
    from .configuration import _runtime_conf, set_config
    set_config(config, overwrite=True)

    for package_name in getattr(_runtime_conf.app, 'modules', []):
        module = __import__(package_name, fromlist=['app'])
        if hasattr(module, 'app') and hasattr(module.app, 'setup_app'):
            app = module.app.setup_app(_runtime_conf, **kwargs)
            app.config = _runtime_conf
            return app
    raise RuntimeError(
        'No app.setup_app found in any of the configured app.modules'
    )


class Pecan(object):
    '''
    Base Pecan application object. Generally created using ``pecan.make_app``,
    rather than being created manually.

    Creates a Pecan application instance, which is a WSGI application.

    :param root: A string representing a root controller object (e.g.,
                "myapp.controller.root.RootController")
    :param default_renderer: The default template rendering engine to use.
                             Defaults to mako.
    :param template_path: A relative file system path (from the project root)
                          where template files live.  Defaults to 'templates'.
    :param hooks: A callable which returns a list of
                  :class:`pecan.hooks.PecanHook`
    :param custom_renderers: Custom renderer objects, as a dictionary keyed
                             by engine name.
    :param extra_template_vars: Any variables to inject into the template
                                namespace automatically.
    :param force_canonical: A boolean indicating if this project should
                            require canonical URLs.
    :param guess_content_type_from_ext: A boolean indicating if this project
                            should use the extension in the URL for guessing
                            the content type to return.
    '''

    SIMPLEST_CONTENT_TYPES = (
        ['text/html'],
        ['text/plain']
    )

    def __init__(self, root, default_renderer='mako',
                 template_path='templates', hooks=lambda: [],
                 custom_renderers={}, extra_template_vars={},
                 force_canonical=True, guess_content_type_from_ext=True,
                 context_local_factory=None, **kw):

        self.init_context_local(context_local_factory)

        if isinstance(root, six.string_types):
            root = self.__translate_root__(root)

        self.root = root
        self.renderers = RendererFactory(custom_renderers, extra_template_vars)
        self.default_renderer = default_renderer

        # pre-sort these so we don't have to do it per-request
        if six.callable(hooks):
            hooks = hooks()

        self.hooks = list(sorted(
            hooks,
            key=operator.attrgetter('priority')
        ))
        self.template_path = template_path
        self.force_canonical = force_canonical
        self.guess_content_type_from_ext = guess_content_type_from_ext

    def init_context_local(self, local_factory):
        global state
        if local_factory is None:
            from threading import local as local_factory
        state = local_factory()

    def __translate_root__(self, item):
        '''
        Creates a root controller instance from a string root, e.g.,

        > __translate_root__("myproject.controllers.RootController")
        myproject.controllers.RootController()

        :param item: The string to the item
        '''

        if '.' in item:
            parts = item.split('.')
            name = '.'.join(parts[:-1])
            fromlist = parts[-1:]

            module = __import__(name, fromlist=fromlist)
            kallable = getattr(module, parts[-1])
            msg = "%s does not represent a callable class or function."
            assert hasattr(kallable, '__call__'), msg % item
            return kallable()

        raise ImportError('No item named %s' % item)

    def route(self, req, node, path):
        '''
        Looks up a controller from a node based upon the specified path.

        :param node: The node, such as a root controller object.
        :param path: The path to look up on this node.
        '''

        path = path.split('/')[1:]
        try:
            node, remainder = lookup_controller(node, path)
            return node, remainder
        except NonCanonicalPath as e:
            if self.force_canonical and \
                    not _cfg(e.controller).get('accept_noncanonical', False):
                if req.method == 'POST':
                    raise RuntimeError(
                        "You have POSTed to a URL '%s' which "
                        "requires a slash. Most browsers will not maintain "
                        "POST data when redirected. Please update your code "
                        "to POST to '%s/' or set force_canonical to False" %
                        (req.pecan['routing_path'],
                            req.pecan['routing_path'])
                    )
                redirect(code=302, add_slash=True)
            return e.controller, e.remainder

    def determine_hooks(self, controller=None):
        '''
        Determines the hooks to be run, in which order.

        :param controller: If specified, includes hooks for a specific
                           controller.
        '''

        controller_hooks = []
        if controller:
            controller_hooks = _cfg(controller).get('hooks', [])
            if controller_hooks:
                return list(
                    sorted(
                        chain(controller_hooks, self.hooks),
                        key=operator.attrgetter('priority')
                    )
                )
        return self.hooks

    def handle_hooks(self, hook_type, *args):
        '''
        Processes hooks of the specified type.

        :param hook_type: The type of hook, including ``before``, ``after``,
                          ``on_error``, and ``on_route``.
        :param \*args: Arguments to pass to the hooks.
        '''
        if hook_type in ['before', 'on_route']:
            hooks = state.hooks
        else:
            hooks = reversed(state.hooks)

        for hook in hooks:
            result = getattr(hook, hook_type)(*args)
            # on_error hooks can choose to return a Response, which will
            # be used instead of the standard error pages.
            if hook_type == 'on_error' and isinstance(result, Response):
                return result

    def get_args(self, pecan_state, all_params, remainder, argspec, im_self):
        '''
        Determines the arguments for a controller based upon parameters
        passed the argument specification for the controller.
        '''
        args = []
        kwargs = dict()
        valid_args = argspec[0][1:]

        def _decode(x):
            return unquote_plus(x) if isinstance(x, six.string_types) \
                else x

        remainder = [_decode(x) for x in remainder]

        if im_self is not None:
            args.append(im_self)

        # grab the routing args from nested REST controllers
        if 'routing_args' in pecan_state:
            remainder = pecan_state['routing_args'] + list(remainder)
            del pecan_state['routing_args']

        # handle positional arguments
        if valid_args and remainder:
            args.extend(remainder[:len(valid_args)])
            remainder = remainder[len(valid_args):]
            valid_args = valid_args[len(args):]

        # handle wildcard arguments
        if [i for i in remainder if i]:
            if not argspec[1]:
                abort(404)
            args.extend(remainder)

        # get the default positional arguments
        if argspec[3]:
            defaults = dict(izip(argspec[0][-len(argspec[3]):], argspec[3]))
        else:
            defaults = dict()

        # handle positional GET/POST params
        for name in valid_args:
            if name in all_params:
                args.append(all_params.pop(name))
            elif name in defaults:
                args.append(defaults[name])
            else:
                break

        # handle wildcard GET/POST params
        if argspec[2]:
            for name, value in six.iteritems(all_params):
                if name not in argspec[0]:
                    kwargs[encode_if_needed(name)] = value

        return args, kwargs

    def render(self, template, namespace):
        renderer = self.renderers.get(
            self.default_renderer,
            self.template_path
        )
        if template == 'json':
            renderer = self.renderers.get('json', self.template_path)
        if ':' in template:
            renderer = self.renderers.get(
                template.split(':')[0],
                self.template_path
            )
            template = template.split(':')[1]
        return renderer.render(template, namespace)

    def handle_request(self, req, resp):
        '''
        The main request handler for Pecan applications.
        '''

        # get a sorted list of hooks, by priority (no controller hooks yet)
        state.hooks = self.hooks
        pecan_state = req.pecan

        # store the routing path for the current application to allow hooks to
        # modify it
        pecan_state['routing_path'] = path = req.encget('PATH_INFO')

        # handle "on_route" hooks
        self.handle_hooks('on_route', state)

        # lookup the controller, respecting content-type as requested
        # by the file extension on the URI
        pecan_state['extension'] = None

        # attempt to guess the content type based on the file extension
        if self.guess_content_type_from_ext \
                and not pecan_state['content_type'] \
                and '.' in path:
            new_path, extension = splitext(path)

            # preface with a letter to ensure compat for 2.5
            potential_type = guess_type('x' + extension)[0]

            if potential_type is not None:
                path = new_path
                pecan_state['extension'] = extension
                pecan_state['content_type'] = potential_type

        controller, remainder = self.route(req, self.root, path)
        cfg = _cfg(controller)

        if cfg.get('generic_handler'):
            raise exc.HTTPNotFound

        # handle generic controllers
        im_self = None
        if cfg.get('generic'):
            im_self = six.get_method_self(controller)
            handlers = cfg['generic_handlers']
            controller = handlers.get(req.method, handlers['DEFAULT'])
            handle_security(controller, im_self)
            cfg = _cfg(controller)

        # add the controller to the state so that hooks can use it
        state.controller = controller

        # if unsure ask the controller for the default content type
        content_types = cfg.get('content_types', {})
        if not pecan_state['content_type']:
            # attempt to find a best match based on accept headers (if they
            # exist)
            accept = getattr(req.accept, 'header_value', '*/*')
            if accept == '*/*' or (
                    accept.startswith('text/html,') and
                    list(content_types.keys()) in self.SIMPLEST_CONTENT_TYPES):
                pecan_state['content_type'] = cfg.get(
                    'content_type',
                    'text/html'
                )
            else:
                best_default = acceptparse.MIMEAccept(
                    accept
                ).best_match(
                    content_types.keys()
                )

                if best_default is None:
                    msg = "Controller '%s' defined does not support " + \
                          "content_type '%s'. Supported type(s): %s"
                    logger.error(
                        msg % (
                            controller.__name__,
                            pecan_state['content_type'],
                            content_types.keys()
                        )
                    )
                    raise exc.HTTPNotAcceptable()

                pecan_state['content_type'] = best_default
        elif cfg.get('content_type') is not None and \
                pecan_state['content_type'] not in content_types:

            msg = "Controller '%s' defined does not support content_type " + \
                  "'%s'. Supported type(s): %s"
            logger.error(
                msg % (
                    controller.__name__,
                    pecan_state['content_type'],
                    content_types.keys()
                )
            )
            raise exc.HTTPNotFound

        # get a sorted list of hooks, by priority
        state.hooks = self.determine_hooks(controller)

        # handle "before" hooks
        self.handle_hooks('before', state)

        # fetch any parameters
        if req.method == 'GET':
            params = dict(req.GET)
        else:
            params = dict(req.params)

        # fetch the arguments for the controller
        args, kwargs = self.get_args(
            pecan_state,
            params,
            remainder,
            cfg['argspec'],
            im_self
        )

        # get the result from the controller
        result = controller(*args, **kwargs)

        # a controller can return the response object which means they've taken
        # care of filling it out
        if result is response:
            return
        elif isinstance(result, Response):
            state.response = result
            return

        raw_namespace = result

        # pull the template out based upon content type and handle overrides
        template = content_types.get(pecan_state['content_type'])

        # check if for controller override of template
        template = pecan_state.get('override_template', template)
        pecan_state['content_type'] = pecan_state.get(
            'override_content_type',
            pecan_state['content_type']
        )

        # if there is a template, render it
        if template:
            if template == 'json':
                pecan_state['content_type'] = 'application/json'
            result = self.render(template, result)

        # If we are in a test request put the namespace where it can be
        # accessed directly
        if req.environ.get('paste.testing'):
            testing_variables = req.environ['paste.testing_variables']
            testing_variables['namespace'] = raw_namespace
            testing_variables['template_name'] = template
            testing_variables['controller_output'] = result

        # set the body content
        if result and isinstance(result, six.text_type):
            resp.text = result
        elif result:
            resp.body = result
        elif response.status_int == 200:
            resp.status = 204

        if resp.status_int in (204, 304):
            resp.content_type = None
        elif pecan_state['content_type']:
            # set the content type
            resp.content_type = pecan_state['content_type']

    def __call__(self, environ, start_response):
        '''
        Implements the WSGI specification for Pecan applications, utilizing
        ``WebOb``.
        '''

        # create the request and response object
        state.request = req = Request(environ)
        state.response = resp = Response()
        state.hooks = []
        state.app = self
        state.controller = None

        # handle the request
        try:
            # add context and environment to the request
            req.context = environ.get('pecan.recursive.context', {})
            req.pecan = dict(content_type=None)

            self.handle_request(req, resp)
        except Exception as e:
            # if this is an HTTP Exception, set it as the response
            if isinstance(e, exc.HTTPException):
                state.response = e
                environ['pecan.original_exception'] = e

            # if this is not an internal redirect, run error hooks
            on_error_result = None
            if not isinstance(e, ForwardRequestException):
                on_error_result = self.handle_hooks('on_error', state, e)

            # if the on_error handler returned a Response, use it.
            if isinstance(on_error_result, Response):
                state.response = on_error_result
            else:
                if not isinstance(e, exc.HTTPException):
                    raise
        finally:
            # handle "after" hooks
            self.handle_hooks('after', state)

        # get the response
        try:
            return state.response(environ, start_response)
        finally:
            # clean up state
            del state.hooks
            del state.request
            del state.response
            del state.controller
            del state.app

########NEW FILE########
__FILENAME__ = decorators
from inspect import getargspec, getmembers, isclass, ismethod, isfunction

import six

from .util import _cfg

__all__ = [
    'expose', 'transactional', 'accept_noncanonical', 'after_commit',
    'after_rollback'
]


def when_for(controller):
    def when(method=None, **kw):
        def decorate(f):
            expose(**kw)(f)
            _cfg(f)['generic_handler'] = True
            controller._pecan['generic_handlers'][method.upper()] = f
            return f
        return decorate
    return when


def expose(template=None,
           content_type='text/html',
           generic=False):

    '''
    Decorator used to flag controller methods as being "exposed" for
    access via HTTP, and to configure that access.

    :param template: The path to a template, relative to the base template
                     directory.
    :param content_type: The content-type to use for this template.
    :param generic: A boolean which flags this as a "generic" controller,
                    which uses generic functions based upon
                    ``functools.singledispatch`` generic functions.  Allows you
                    to split a single controller into multiple paths based upon
                    HTTP method.
    '''

    if template == 'json':
        content_type = 'application/json'

    def decorate(f):
        # flag the method as exposed
        f.exposed = True

        # set a "pecan" attribute, where we will store details
        cfg = _cfg(f)
        cfg['content_type'] = content_type
        cfg.setdefault('template', []).append(template)
        cfg.setdefault('content_types', {})[content_type] = template

        # handle generic controllers
        if generic:
            cfg['generic'] = True
            cfg['generic_handlers'] = dict(DEFAULT=f)
            f.when = when_for(f)

        # store the arguments for this controller method
        cfg['argspec'] = getargspec(f)

        return f

    return decorate


def transactional(ignore_redirects=True):
    '''
    If utilizing the :mod:`pecan.hooks` ``TransactionHook``, allows you
    to flag a controller method or class as being wrapped in a transaction,
    regardless of HTTP method.

    :param ignore_redirects: Indicates if the hook should ignore redirects
                             for this controller or not.
    '''

    def deco(f):
        if isclass(f):
            for meth in [
                m[1] for m in getmembers(f)
                if (isfunction if six.PY3 else ismethod)(m[1])
            ]:
                if getattr(meth, 'exposed', False):
                    _cfg(meth)['transactional'] = True
                    _cfg(meth)['transactional_ignore_redirects'] = _cfg(
                        meth
                    ).get(
                        'transactional_ignore_redirects',
                        ignore_redirects
                    )
        else:
            _cfg(f)['transactional'] = True
            _cfg(f)['transactional_ignore_redirects'] = ignore_redirects
        return f
    return deco


def after_action(action_type, action):
    '''
    If utilizing the :mod:`pecan.hooks` ``TransactionHook``, allows you
    to flag a controller method to perform a callable action after the
    action_type is successfully issued.

    :param action: The callable to call after the commit is successfully
    issued.  '''

    if action_type not in ('commit', 'rollback'):
        raise Exception('action_type (%s) is not valid' % action_type)

    def deco(func):
        _cfg(func).setdefault('after_%s' % action_type, []).append(action)
        return func
    return deco


def after_commit(action):
    '''
    If utilizing the :mod:`pecan.hooks` ``TransactionHook``, allows you
    to flag a controller method to perform a callable action after the
    commit is successfully issued.

    :param action: The callable to call after the commit is successfully
                   issued.
    '''
    return after_action('commit', action)


def after_rollback(action):
    '''
    If utilizing the :mod:`pecan.hooks` ``TransactionHook``, allows you
    to flag a controller method to perform a callable action after the
    rollback is successfully issued.

    :param action: The callable to call after the rollback is successfully
                   issued.
    '''
    return after_action('rollback', action)


def accept_noncanonical(func):
    '''
    Flags a controller method as accepting non-canoncial URLs.
    '''

    _cfg(func)['accept_noncanonical'] = True
    return func

########NEW FILE########
__FILENAME__ = deploy
from .core import load_app


def deploy(config):
    """
    Given a config (dictionary of relative filename), returns a configured
    WSGI app.
    """
    return load_app(config)

########NEW FILE########
__FILENAME__ = extensions
import sys
import pkg_resources
import inspect
import logging

log = logging.getLogger(__name__)


class PecanExtensionMissing(ImportError):
    pass


class PecanExtensionImporter(object):
    """
    Short circuits imports for extensions.

    This is used in combination with ``pecan.ext`` so that when a user does
    ``from pecan.ext import foo``, it will attempt to map ``foo`` to a
    registered setuptools entry point in some other (Pecan extension) project.

    Conversely, an extension developer may define an entry point in his
    ``setup.py``, e.g.,

    setup(
      ...
      entry_points='''
      [pecan.extension]
      celery = pecancelery.lib.core
      '''
    )

    This is mostly for convenience and consistency.  In this way, Pecan can
    maintain an ecosystem of extensions that share a common namespace,
    ``pecan.ext``, while still maintaining backwards compatibility for simple
    package names (e.g., ``pecancelery``).
    """

    extension_module = 'pecan.ext'
    prefix = extension_module + '.'

    def install(self):
        if self not in sys.meta_path:
            sys.meta_path.append(self)

    def __eq__(self, b):
        return self.__class__.__module__ == b.__class__.__module__ and \
            self.__class__.__name__ == b.__class__.__name__

    def __ne__(self, b):
        return not self.__eq__(b)

    def find_module(self, fullname, path=None):
        if fullname.startswith(self.prefix):
            return self

    def load_module(self, fullname):
        if fullname in sys.modules:
            return self
        extname = fullname.split(self.prefix)[1]
        module = self.find_module_for_extension(extname)
        realname = module.__name__
        try:
            __import__(realname)
        except ImportError:
            raise sys.exc_info()
        module = sys.modules[fullname] = sys.modules[realname]
        if '.' not in extname:
            setattr(sys.modules[self.extension_module], extname, module)
        return module

    def find_module_for_extension(self, name):
        for ep in pkg_resources.iter_entry_points('pecan.extension'):
            if ep.name != name:
                continue
            log.debug('%s loading extension %s', self.__class__.__name__, ep)
            module = ep.load()
            if not inspect.ismodule(module):
                log.debug('%s is not a module, skipping...' % module)
                continue
            return module
        raise PecanExtensionMissing(
            'The `pecan.ext.%s` extension is not installed.' % name
        )

########NEW FILE########
__FILENAME__ = hooks
import sys
from inspect import getmembers

from webob.exc import HTTPFound

from .util import iscontroller, _cfg
from .routing import lookup_controller

__all__ = [
    'PecanHook', 'TransactionHook', 'HookController',
    'RequestViewerHook'
]


def walk_controller(root_class, controller, hooks):
    if not isinstance(controller, (int, dict)):
        for name, value in getmembers(controller):
            if name == 'controller':
                continue
            if name.startswith('__') and name.endswith('__'):
                continue

            if iscontroller(value):
                for hook in hooks:
                    value._pecan.setdefault('hooks', []).append(hook)
            elif hasattr(value, '__class__'):
                if name.startswith('__') and name.endswith('__'):
                    continue
                walk_controller(root_class, value, hooks)


class HookControllerMeta(type):
    '''
    A base class for controllers that would like to specify hooks on
    their controller methods. Simply create a list of hook objects
    called ``__hooks__`` as a member of the controller's namespace.
    '''

    def __init__(cls, name, bases, dict_):
        walk_controller(cls, cls, dict_.get('__hooks__', []))


HookController = HookControllerMeta(
    'HookController',
    (object,),
    {'__doc__': ("A base class for controllers that would like to specify "
                 "hooks on their controller methods. Simply create a list "
                 "of hook objects called ``__hooks__`` as a class attribute "
                 "of your controller.")}
)


class PecanHook(object):
    '''
    A base class for Pecan hooks. Inherit from this class to create your
    own hooks. Set a priority on a hook by setting the ``priority``
    attribute for the hook, which defaults to 100.
    '''

    priority = 100

    def on_route(self, state):
        '''
        Override this method to create a hook that gets called upon
        the start of routing.

        :param state: The Pecan ``state`` object for the current request.
        '''
        return

    def before(self, state):
        '''
        Override this method to create a hook that gets called after
        routing, but before the request gets passed to your controller.

        :param state: The Pecan ``state`` object for the current request.
        '''
        return

    def after(self, state):
        '''
        Override this method to create a hook that gets called after
        the request has been handled by the controller.

        :param state: The Pecan ``state`` object for the current request.
        '''
        return

    def on_error(self, state, e):
        '''
        Override this method to create a hook that gets called upon
        an exception being raised in your controller.

        :param state: The Pecan ``state`` object for the current request.
        :param e: The ``Exception`` object that was raised.
        '''
        return


class TransactionHook(PecanHook):
    '''
    :param start: A callable that will bind to a writable database and
                  start a transaction.
    :param start_ro: A callable that will bind to a readable database.
    :param commit: A callable that will commit the active transaction.
    :param rollback: A callable that will roll back the active
                     transaction.
    :param clear: A callable that will clear your current context.

    A basic framework hook for supporting wrapping requests in
    transactions. By default, it will wrap all but ``GET`` and ``HEAD``
    requests in a transaction. Override the ``is_transactional`` method
    to define your own rules for what requests should be transactional.
    '''

    def __init__(self, start, start_ro, commit, rollback, clear):

        self.start = start
        self.start_ro = start_ro
        self.commit = commit
        self.rollback = rollback
        self.clear = clear

    def is_transactional(self, state):
        '''
        Decide if a request should be wrapped in a transaction, based
        upon the state of the request. By default, wraps all but ``GET``
        and ``HEAD`` requests in a transaction, along with respecting
        the ``transactional`` decorator from :mod:pecan.decorators.

        :param state: The Pecan state object for the current request.
        '''

        controller = getattr(state, 'controller', None)
        if controller:
            force_transactional = _cfg(controller).get('transactional', False)
        else:
            force_transactional = False

        if state.request.method not in ('GET', 'HEAD') or force_transactional:
            return True
        return False

    def on_route(self, state):
        state.request.error = False
        if self.is_transactional(state):
            state.request.transactional = True
            self.start()
        else:
            state.request.transactional = False
            self.start_ro()

    def before(self, state):
        if self.is_transactional(state) \
                and not getattr(state.request, 'transactional', False):
            self.clear()
            state.request.transactional = True
            self.start()

    def on_error(self, state, e):
        #
        # If we should ignore redirects,
        # (e.g., shouldn't consider them rollback-worthy)
        # don't set `state.request.error = True`.
        #
        trans_ignore_redirects = (
            state.request.method not in ('GET', 'HEAD')
        )
        if state.controller is not None:
            trans_ignore_redirects = (
                _cfg(state.controller).get(
                    'transactional_ignore_redirects',
                    trans_ignore_redirects
                )
            )
        if type(e) is HTTPFound and trans_ignore_redirects is True:
            return
        state.request.error = True

    def after(self, state):
        if getattr(state.request, 'transactional', False):
            action_name = None
            if state.request.error:
                action_name = 'after_rollback'
                self.rollback()
            else:
                action_name = 'after_commit'
                self.commit()

            #
            # If a controller was routed to, find any
            # after_* actions it may have registered, and perform
            # them.
            #
            if action_name:
                controller = getattr(state, 'controller', None)
                if controller is not None:
                    actions = _cfg(controller).get(action_name, [])
                    for action in actions:
                        action()

        self.clear()


class RequestViewerHook(PecanHook):
    '''
    :param config:   A (optional) dictionary that can hold ``items`` and/or
                     ``blacklist`` keys.
    :param writer:   The stream writer to use. Can redirect output to other
                     streams as long as the passed in stream has a
                     ``write`` callable method.
    :param terminal: Outputs to the chosen stream writer (usually
                     the terminal)
    :param headers:  Sets values to the X-HTTP headers

    Returns some information about what is going on in a single request.  It
    accepts specific items to report on but uses a default list of items when
    none are passed in.  Based on the requested ``url``, items can also be
    blacklisted.
    Configuration is flexible, can be passed in (or not) and can contain
    some or all the keys supported.

    **items**

    This key holds the items that this hook will display. When this key is
    passed only the items in the list will be used.  Valid items are *any*
    item that the ``request`` object holds, by default it uses the
    following:

    * path
    * status
    * method
    * controller
    * params
    * hooks

    .. note::
        This key should always use a ``list`` of items to use.

    **blacklist**

    This key holds items that will be blacklisted based on ``url``. If
    there is a need to omit urls that start with `/javascript`, then this
    key would look like::

        'blacklist': ['/javascript']

    As many blacklisting items as needed can be contained in the list. The hook
    will verify that the url is not starting with items in this list to display
    results, otherwise it will get omitted.

    .. note::
        This key should always use a ``list`` of items to use.

    For more detailed documentation about this hook, please see
    :ref:`requestviewerhook`
    '''

    available = ['path', 'status', 'method', 'controller', 'params', 'hooks']

    def __init__(self, config=None, writer=sys.stdout, terminal=True,
                 headers=True):

        if not config:
            self.config = {'items': self.available}
        else:
            if config.__class__.__name__ == 'Config':
                self.config = config.to_dict()
            else:
                self.config = config
        self.writer = writer
        self.items = self.config.get('items', self.available)
        self.blacklist = self.config.get('blacklist', [])
        self.terminal = terminal
        self.headers = headers

    def after(self, state):

        # Default and/or custom response information
        responses = {
            'controller': lambda self, state: self.get_controller(state),
            'method': lambda self, state: state.request.method,
            'path': lambda self, state: state.request.path,
            'params': lambda self, state: [
                (p[0].encode('utf-8'), p[1].encode('utf-8'))
                for p in state.request.params.items()
            ],
            'status': lambda self, state: state.response.status,
            'hooks': lambda self, state: self.format_hooks(state.app.hooks),
        }

        is_available = [
            i for i in self.items
            if i in self.available or hasattr(state.request, i)
        ]

        terminal = []
        headers = []
        will_skip = [
            i for i in self.blacklist
            if state.request.path.startswith(i)
        ]

        if will_skip:
            return

        for request_info in is_available:
            try:
                value = responses.get(request_info)
                if not value:
                    value = getattr(state.request, request_info)
                else:
                    value = value(self, state)
            except Exception as e:
                value = e

            terminal.append('%-12s - %s\n' % (request_info, value))
            headers.append((request_info, value))

        if self.terminal:
            self.writer.write(''.join(terminal))
            self.writer.write('\n\n')

        if self.headers:
            for h in headers:
                key = str(h[0])
                value = str(h[1])
                name = 'X-Pecan-%s' % key
                state.response.headers[name] = value

    def get_controller(self, state):
        '''
        Retrieves the actual controller name from the application
        Specific to Pecan (not available in the request object)
        '''
        path = state.request.pecan['routing_path'].split('/')[1:]
        controller, reminder = lookup_controller(state.app.root, path)
        return controller.__str__().split()[2]

    def format_hooks(self, hooks):
        '''
        Tries to format the hook objects to be more readable
        Specific to Pecan (not available in the request object)
        '''
        str_hooks = [str(i).split()[0].strip('<') for i in hooks]
        return [i.split('.')[-1] for i in str_hooks if '.' in i]

########NEW FILE########
__FILENAME__ = jsonify
try:
    from simplejson import JSONEncoder
except ImportError:                     # pragma: no cover
    from json import JSONEncoder        # noqa

from datetime import datetime, date
from decimal import Decimal

# depending on the version WebOb might have 2 types of dicts
try:
    # WebOb <= 1.1.1
    from webob.multidict import MultiDict, UnicodeMultiDict
    webob_dicts = (MultiDict, UnicodeMultiDict)  # pragma: no cover
except ImportError:  # pragma no cover
    # WebOb >= 1.2
    from webob.multidict import MultiDict
    webob_dicts = (MultiDict,)

import six
try:
    from functools import singledispatch
except ImportError:  # pragma: no cover
    from singledispatch import singledispatch

try:
    from sqlalchemy.engine.result import ResultProxy, RowProxy
except ImportError:  # pragma no cover
    try:
        from sqlalchemy.engine.base import ResultProxy, RowProxy
    except ImportError:  # pragma no cover
        # dummy classes since we don't have SQLAlchemy installed

        class ResultProxy(object):  # noqa
            pass

        class RowProxy(object):  # noqa
            pass


#
# encoders
#

def is_saobject(obj):
    return hasattr(obj, '_sa_class_manager')


class GenericJSON(JSONEncoder):
    '''
    Generic JSON encoder.  Makes several attempts to correctly JSONify
    requested response objects.
    '''
    def default(self, obj):
        '''
        Converts an object and returns a ``JSON``-friendly structure.

        :param obj: object or structure to be converted into a
                    ``JSON``-ifiable structure

        Considers the following special cases in order:

        * object has a callable __json__() attribute defined
            returns the result of the call to __json__()
        * date and datetime objects
            returns the object cast to str
        * Decimal objects
            returns the object cast to float
        * SQLAlchemy objects
            returns a copy of the object.__dict__ with internal SQLAlchemy
            parameters removed
        * SQLAlchemy ResultProxy objects
            Casts the iterable ResultProxy into a list of tuples containing
            the entire resultset data, returns the list in a dictionary
            along with the resultset "row" count.

            .. note:: {'count': 5, 'rows': [('Ed Jones',), ('Pete Jones',),
                ('Wendy Williams',), ('Mary Contrary',), ('Fred Smith',)]}

        * SQLAlchemy RowProxy objects
            Casts the RowProxy cursor object into a dictionary, probably
            losing its ordered dictionary behavior in the process but
            making it JSON-friendly.
        * webob_dicts objects
            returns webob_dicts.mixed() dictionary, which is guaranteed
            to be JSON-friendly.
        '''
        if hasattr(obj, '__json__') and six.callable(obj.__json__):
            return obj.__json__()
        elif isinstance(obj, (date, datetime)):
            return str(obj)
        elif isinstance(obj, Decimal):
            # XXX What to do about JSONEncoder crappy handling of Decimals?
            # SimpleJSON has better Decimal encoding than the std lib
            # but only in recent versions
            return float(obj)
        elif is_saobject(obj):
            props = {}
            for key in obj.__dict__:
                if not key.startswith('_sa_'):
                    props[key] = getattr(obj, key)
            return props
        elif isinstance(obj, ResultProxy):
            props = dict(rows=list(obj), count=obj.rowcount)
            if props['count'] < 0:
                props['count'] = len(props['rows'])
            return props
        elif isinstance(obj, RowProxy):
            return dict(obj)
        elif isinstance(obj, webob_dicts):
            return obj.mixed()
        else:
            return JSONEncoder.default(self, obj)

_default = GenericJSON()


def with_when_type(f):
    # Add some backwards support for simplegeneric's API
    f.when_type = f.register
    return f


@with_when_type
@singledispatch
def jsonify(obj):
    return _default.default(obj)


class GenericFunctionJSON(GenericJSON):
    def default(self, obj):
        return jsonify(obj)

_instance = GenericFunctionJSON()


def encode(obj):
    return _instance.encode(obj)

########NEW FILE########
__FILENAME__ = log
import logging

from logutils.colorize import ColorizingStreamHandler


class DefaultColorizer(ColorizingStreamHandler):

    level_map = {
        logging.DEBUG: (None, 'blue', True),
        logging.INFO: (None, None, True),
        logging.WARNING: (None, 'yellow', True),
        logging.ERROR: (None, 'red', True),
        logging.CRITICAL: (None, 'red', True),
    }


class ColorFormatter(logging.Formatter):
    """
    A very basic logging formatter that not only applies color to the
    levels of the ouput but can also add padding to the the level names so that
    they do not alter the visuals of logging when presented on the terminal.

    The padding is provided by a convenient keyword that adds padding to the
    ``levelname`` so that log output is easier to follow::

        %(padded_color_levelname)s

    Which would result in log level output that looks like::

        [INFO    ]
        [WARNING ]
        [ERROR   ]
        [DEBUG   ]
        [CRITICAL]

    If colored output is not supported, it falls back to non-colored output
    without any extra settings.
    """

    def __init__(self, _logging=None, colorizer=None, *a, **kw):
        self.logging = _logging or logging
        self.color = colorizer or DefaultColorizer()
        logging.Formatter.__init__(self, *a, **kw)

    def format(self, record):
        levelname = record.levelname
        padded_level = '%-8s' % levelname

        record.color_levelname = self.color.colorize(levelname, record)
        record.padded_color_levelname = self.color.colorize(
            padded_level,
            record
        )
        return self.logging.Formatter.format(self, record)

########NEW FILE########
__FILENAME__ = debug
from traceback import print_exc
from pprint import pformat
import pdb

from six.moves import cStringIO as StringIO

from mako.template import Template
from webob import Response

from .resources import (pecan_image, xregexp_js, syntax_js, syntax_css, theme,
                        brush)


debug_template_raw = '''<html>
 <head>
  <title>Pecan - Application Error</title>

  <link rel="stylesheet" type="text/css" href="${syntax_css}" />
  <link rel="stylesheet" type="text/css" href="${theme}" />

  <script type="text/javascript" src="${xregexp_js}"></script>
  <script type="text/javascript" src="${syntax_js}">
    /**
     * SyntaxHighlighter
     * http://alexgorbatchev.com/SyntaxHighlighter
     *
     * SyntaxHighlighter is donationware. If you are using it, please donate.
     * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
     *
     * @version
     * 3.0.83 (July 02 2010)
     *
     * @copyright
     * Copyright (C) 2004-2010 Alex Gorbatchev.
     *
     * @license
     * Dual licensed under the MIT and GPL licenses.
     */
  </script>
  <script type="text/javascript" src="${brush}">
    /**
     * SyntaxHighlighter
     * http://alexgorbatchev.com/SyntaxHighlighter
     *
     * SyntaxHighlighter is donationware. If you are using it, please donate.
     * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
     *
     * @version
     * 3.0.83 (July 02 2010)
     *
     * @copyright
     * Copyright (C) 2004-2010 Alex Gorbatchev.
     *
     * @license
     * Dual licensed under the MIT and GPL licenses.
     */
  </script>

  <style type="text/css">
    body {
      color: #000;
      background: #FFF;
      font-family: 'Helvetica Neue', 'Helvetica', 'Verdana', sans-serif;
      font-size: 12px;
      padding: 0;
      margin: 0;
    }

    a {
      color: #FAFF78;
    }

    h1, h2, h3, h4, h5, h6 {
      font-family: 'Helvetica', sans-serif;
    }

    h1 {
      margin: 0;
      padding: .75em 1.5em 1em 1.5em;
      color: #F90;
      font-size: 14px;
      font-weight: bold;
    }

    h1 img  {
      padding-right: 5px;
    }

    h2 {
      color: #311F00;
    }

    header  {
      width: 100%;
      background: #311F00;
    }

    div#error-content  {
      padding: 0 2em;
    }

    .syntaxhighlighter a,
    .syntaxhighlighter div,
    .syntaxhighlighter code,
    .syntaxhighlighter table,
    .syntaxhighlighter table td,
    .syntaxhighlighter table tr,
    .syntaxhighlighter table tbody,
    .syntaxhighlighter table thead,
    .syntaxhighlighter table caption,
    .syntaxhighlighter textarea {
      font-family: monospace !important;
    }

    .syntaxhighlighter .container {
       background: #FDF6E3 !important;
       padding: 1em !important;
    }

    .syntaxhighlighter .container .line {
       background: #FDF6E3 !important;
    }

    .syntaxhighlighter .container .line .python.string {
       color: #C70 !important;
    }

    #debug {
        background: #FDF6E3;
        padding: 10px !important;
        margin-top: 10px;
        font-family: monospace;
    }

  </style>
  <script type="text/javascript">
      SyntaxHighlighter.defaults['gutter'] = false;
      SyntaxHighlighter.defaults['toolbar'] = false;
      SyntaxHighlighter.all()
  </script>

  <script type="text/javascript">
    function get_request() {
        /* ajax sans jquery makes me sad */
        var request = false;

        // Mozilla/Safari
        if (window.XMLHttpRequest) {
            request = new XMLHttpRequest();
        }

        // IE
        else if (window.ActiveXObject) {
            request = new ActiveXObject("Microsoft.XMLHTTP");
        }

        return request;
    }

    function debug_request(btn) {
        btn.disabled = true;

        request = get_request();
        request.open('GET', '/__pecan_initiate_pdb__', true);
        request.onreadystatechange = function() {
            if (request.readyState == 4) {
                btn.disabled = false;
            }
        }
        request.send('');

        /* automatically timeout after 5 minutes, re-enabling the button */
        setTimeout(function() {
           request.abort();
        }, 5 * 60 * 1000);
    }
  </script>
 </head>
 <body>

  <header>
    <h1>
      <img style="padding-top: 7px"
           align="center" alt="pecan logo"
           height="25"
           src="${pecan_image}" />
      application error
    </h1>
  </header>

  <div id="error-content">

    <p>
      <b>To disable this interface, set </b>
      <pre class="brush: python">conf.app.debug = False</pre>
    </p>

    <h2>Traceback</h2>
    <div id="traceback">
      <pre class="brush: python">${traceback}</pre>
    </div>

    % if not debugging:
    <b>Want to debug this request?</b>
    <div id="debug">
      You can <button onclick="debug_request(this)">
        repeat this request
      </button> with a Python debugger breakpoint.
    </div>
    % endif

    <h2>WSGI Environment</h2>
    <div id="environ">
      <pre class="brush: python">${environment}</pre>
    </div>
  </div>
 </body>
</html>
'''

debug_template = Template(debug_template_raw)
__debug_environ__ = None


class PdbMiddleware(object):
    def __init__(self, app, debugger):
        self.app = app
        self.debugger = debugger

    def __call__(self, environ, start_response):
        try:
            return self.app(environ, start_response)
        except:
            self.debugger()


class DebugMiddleware(object):
    """A WSGI middleware that provides debugging assistance for development
    environments.

    To enable the debugging middleware, simply set the ``debug`` flag to
    ``True`` in your configuration file::

        app = {
            ...
            'debug': True,
            ...
        }

    Once enabled, the middleware will automatically catch exceptions raised by
    your application, and display the Python stack trace and WSGI environment
    in your browser for easy debugging.

    To further aid in debugging, the middleware includes the ability to repeat
    the offending request, automatically inserting a breakpoint, and dropping
    your console into the Python debugger, ``pdb``.

    For more information, refer to the  `documentation for pdb
    <http://docs.python.org/library/pdb.html>`_ available on the Python
    website.

    :param app: the application to wrap.
    :param debugger: a callable to start debugging, defaulting to the Python
                     debugger, ``pdb``.
    """

    def __init__(self, app, debugger=pdb.post_mortem):
        self.app = app
        self.debugger = debugger

    def __call__(self, environ, start_response):
        assert not environ['wsgi.multiprocess'], (
            "The DebugMiddleware middleware is not usable in a "
            "multi-process environment")

        if environ.get('paste.testing'):
            return self.app(environ, start_response)

        # initiate a PDB session if requested
        global __debug_environ__
        debugging = environ['PATH_INFO'] == '/__pecan_initiate_pdb__'
        if debugging:
            PdbMiddleware(self.app, self.debugger)(
                __debug_environ__, start_response
            )
            environ = __debug_environ__

        try:
            return self.app(environ, start_response)
        except:
            # save the environ for debugging
            if not debugging:
                __debug_environ__ = environ

            # get a formatted exception
            out = StringIO()
            print_exc(file=out)

            # get formatted WSGI environment
            formatted_environ = pformat(environ)

            # render our template
            result = debug_template.render(
                traceback=out.getvalue(),
                environment=formatted_environ,
                pecan_image=pecan_image,
                xregexp_js=xregexp_js,
                syntax_js=syntax_js,
                brush=brush,
                syntax_css=syntax_css,
                theme=theme,
                debugging=debugging
            )

            # construct and return our response
            response = Response()
            response.status_int = 400
            response.unicode_body = result
            return response(environ, start_response)

########NEW FILE########
__FILENAME__ = errordocument
import sys

from six import b as b_
from .recursive import ForwardRequestException, RecursionLoop


class StatusPersist(object):

    def __init__(self, app, status, url):
        self.app = app
        self.status = status
        self.url = url

    def __call__(self, environ, start_response):
        def keep_status_start_response(status, headers, exc_info=None):
            return start_response(self.status, headers, exc_info)
        parts = self.url.split('?')
        environ['PATH_INFO'] = parts[0]
        if len(parts) > 1:
            environ['QUERY_STRING'] = parts[1]
        else:
            environ['QUERY_STRING'] = ''

        try:
            return self.app(environ, keep_status_start_response)
        except RecursionLoop as e:
            environ['wsgi.errors'].write(
                'Recursion error getting error page: %s\n' % e
            )
            keep_status_start_response(
                '500 Server Error',
                [('Content-type', 'text/plain')],
                sys.exc_info()
            )
            return [b_(
                'Error: %s.  (Error page could not be fetched)' % self.status
            )]


class ErrorDocumentMiddleware(object):
    '''
    Intersects HTTP response status code, looks it up in the error map defined
    in the Pecan app config.py, and routes to the controller assigned to that
    status.
    '''
    def __init__(self, app, error_map):
        self.app = app
        self.error_map = error_map

    def __call__(self, environ, start_response):

        def replacement_start_response(status, headers, exc_info=None):
            '''
            Overrides the default response if the status is defined in the
            Pecan app error map configuration.
            '''
            try:
                status_code = int(status.split(' ')[0])
            except (ValueError, TypeError):  # pragma: nocover
                raise Exception((
                    'ErrorDocumentMiddleware received an invalid '
                    'status %s' % status
                ))

            if status_code in self.error_map:
                def factory(app):
                    return StatusPersist(
                        app,
                        status,
                        self.error_map[status_code]
                    )
                raise ForwardRequestException(factory=factory)
            return start_response(status, headers, exc_info)

        app_iter = self.app(environ, replacement_start_response)
        return app_iter

########NEW FILE########
__FILENAME__ = recursive
# (c) 2005 Ian Bicking and contributors; written for Paste
# Licensed under the MIT license:
# http://www.opensource.org/licenses/mit-license.php

"""
Middleware to make internal requests and forward requests internally.

Raise ``ForwardRequestException(new_path_info)`` to do a forward
(aborting the current request).
"""

__all__ = ['RecursiveMiddleware']


class RecursionLoop(AssertionError):
    # Subclasses AssertionError for legacy reasons
    """Raised when a recursion enters into a loop"""


class CheckForRecursionMiddleware(object):
    def __init__(self, app, env):
        self.app = app
        self.env = env

    def __call__(self, environ, start_response):
        path_info = environ.get('PATH_INFO', '')
        if path_info in self.env.get('pecan.recursive.old_path_info', []):
            raise RecursionLoop(
                "Forwarding loop detected; %r visited twice (internal "
                "redirect path: %s)"
                % (path_info, self.env['pecan.recursive.old_path_info'])
            )
        old_path_info = self.env.setdefault(
            'pecan.recursive.old_path_info', []
        )
        old_path_info.append(self.env.get('PATH_INFO', ''))
        return self.app(environ, start_response)


class RecursiveMiddleware(object):

    """
    A WSGI middleware that allows for recursive and forwarded calls.
    All these calls go to the same 'application', but presumably that
    application acts differently with different URLs.  The forwarded
    URLs must be relative to this container.
    """

    def __init__(self, application, global_conf=None):
        self.application = application

    def __call__(self, environ, start_response):
        my_script_name = environ.get('SCRIPT_NAME', '')
        environ['pecan.recursive.script_name'] = my_script_name
        try:
            return self.application(environ, start_response)
        except ForwardRequestException as e:
            middleware = CheckForRecursionMiddleware(
                e.factory(self), environ)
            return middleware(environ, start_response)


class ForwardRequestException(Exception):
    """
    Used to signal that a request should be forwarded to a different location.

    ``url``
        The URL to forward to starting with a ``/`` and relative to
        ``RecursiveMiddleware``. URL fragments can also contain query strings
        so ``/error?code=404`` would be a valid URL fragment.

    ``environ``
        An altertative WSGI environment dictionary to use for the forwarded
        request. If specified is used *instead* of the ``url_fragment``

    ``factory``
        If specifed ``factory`` is used instead of ``url`` or ``environ``.
        ``factory`` is a callable that takes a WSGI application object
        as the first argument and returns an initialised WSGI middleware
        which can alter the forwarded response.

    Basic usage (must have ``RecursiveMiddleware`` present) :

    .. code-block:: python

        from pecan.middleware.recursive import ForwardRequestException
        def app(environ, start_response):
            if environ['PATH_INFO'] == '/hello':
                start_response("200 OK", [('Content-type', 'text/plain')])
                return ['Hello World!']
            elif environ['PATH_INFO'] == '/error':
                start_response("404 Not Found",
                    [('Content-type', 'text/plain')]
                )
                return ['Page not found']
            else:
                raise ForwardRequestException('/error')

        from pecan.middleware.recursive import RecursiveMiddleware
        app = RecursiveMiddleware(app)

    If you ran this application and visited ``/hello`` you would get a
    ``Hello World!`` message. If you ran the application and visited
    ``/not_found`` a ``ForwardRequestException`` would be raised and the caught
    by the ``RecursiveMiddleware``. The ``RecursiveMiddleware`` would then
    return the headers and response from the ``/error`` URL but would display
    a ``404 Not found`` status message.

    You could also specify an ``environ`` dictionary instead of a url. Using
    the same example as before:

    .. code-block:: python

        def app(environ, start_response):
            ... same as previous example ...
            else:
                new_environ = environ.copy()
                new_environ['PATH_INFO'] = '/error'
                raise ForwardRequestException(environ=new_environ)
    """

    def __init__(self, url=None, environ={}, factory=None, path_info=None):
        # Check no incompatible options have been chosen
        if factory and url:
            raise TypeError(
                'You cannot specify factory and a url in '
                'ForwardRequestException'
            )  # pragma: nocover
        elif factory and environ:
            raise TypeError(
                'You cannot specify factory and environ in '
                'ForwardRequestException'
            )  # pragma: nocover
        if url and environ:
            raise TypeError(
                'You cannot specify environ and url in '
                'ForwardRequestException'
            )  # pragma: nocover

        # set the path_info or warn about its use.
        if path_info:
            self.path_info = path_info

        # If the url can be treated as a path_info do that
        if url and '?' not in str(url):
            self.path_info = url

        # Base middleware
        class ForwardRequestExceptionMiddleware(object):
            def __init__(self, app):
                self.app = app

        # Otherwise construct the appropriate middleware factory
        if hasattr(self, 'path_info'):
            p = self.path_info

            def factory_pi(app):
                class PathInfoForward(ForwardRequestExceptionMiddleware):
                    def __call__(self, environ, start_response):
                        environ['PATH_INFO'] = p
                        return self.app(environ, start_response)
                return PathInfoForward(app)

            self.factory = factory_pi
        elif url:
            def factory_url(app):
                class URLForward(ForwardRequestExceptionMiddleware):
                    def __call__(self, environ, start_response):
                        environ['PATH_INFO'] = url.split('?')[0]
                        environ['QUERY_STRING'] = url.split('?')[1]
                        return self.app(environ, start_response)
                return URLForward(app)

            self.factory = factory_url
        elif environ:
            def factory_env(app):
                class EnvironForward(ForwardRequestExceptionMiddleware):
                    def __call__(self, environ_, start_response):
                        return self.app(environ, start_response)
                return EnvironForward(app)

            self.factory = factory_env
        else:
            self.factory = factory

########NEW FILE########
__FILENAME__ = static
"""
This code is adapted from the Werkzeug project, under the BSD license.

:copyright: (c) 2011 by the Werkzeug Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

import os
import mimetypes
from datetime import datetime
from time import gmtime

import six


class FileWrapper(object):
    """This class can be used to convert a :class:`file`-like object into
    an iterable.  It yields `buffer_size` blocks until the file is fully
    read.

    You should not use this class directly but rather use the
    :func:`wrap_file` function that uses the WSGI server's file wrapper
    support if it's available.

    :param file: a :class:`file`-like object with a :meth:`~file.read` method.
    :param buffer_size: number of bytes for one iteration.
    """

    def __init__(self, file, buffer_size=8192):
        self.file = file
        self.buffer_size = buffer_size

    def close(self):
        if hasattr(self.file, 'close'):
            self.file.close()

    def __iter__(self):
        return self

    def next(self):
        data = self.file.read(self.buffer_size)
        if data:
            return data
        raise StopIteration()


if six.PY3:
    FileWrapper.__next__ = FileWrapper.next


def wrap_file(environ, file, buffer_size=8192):
    """Wraps a file.  This uses the WSGI server's file wrapper if available
    or otherwise the generic :class:`FileWrapper`.

    If the file wrapper from the WSGI server is used it's important to not
    iterate over it from inside the application but to pass it through
    unchanged.

    More information about file wrappers are available in :pep:`333`.

    :param file: a :class:`file`-like object with a :meth:`~file.read` method.
    :param buffer_size: number of bytes for one iteration.
    """
    return environ.get('wsgi.file_wrapper', FileWrapper)(file, buffer_size)


def _dump_date(d, delim):
    """Used for `http_date` and `cookie_date`."""
    if d is None:
        d = gmtime()
    elif isinstance(d, datetime):
        d = d.utctimetuple()
    elif isinstance(d, (int, float)):
        d = gmtime(d)
    return '%s, %02d%s%s%s%s %02d:%02d:%02d GMT' % (
        ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun')[d.tm_wday],
        d.tm_mday, delim,
        ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
         'Oct', 'Nov', 'Dec')[d.tm_mon - 1],
        delim, str(d.tm_year), d.tm_hour, d.tm_min, d.tm_sec
    )


def http_date(timestamp=None):
    """Formats the time to match the RFC1123 date format.

    Accepts a floating point number expressed in seconds since the epoch in, a
    datetime object or a timetuple.  All times in UTC.

    Outputs a string in the format ``Wdy, DD Mon YYYY HH:MM:SS GMT``.

    :param timestamp: If provided that date is used, otherwise the current.
    """
    return _dump_date(timestamp, ' ')


class StaticFileMiddleware(object):
    """A WSGI middleware that provides static content for development
    environments.

    Currently the middleware does not support non ASCII filenames.  If the
    encoding on the file system happens to be the encoding of the URI it may
    work but this could also be by accident.  We strongly suggest using ASCII
    only file names for static files.

    The middleware will guess the mimetype using the Python `mimetype`
    module.  If it's unable to figure out the charset it will fall back
    to `fallback_mimetype`.

    :param app: the application to wrap.  If you don't want to wrap an
                application you can pass it :exc:`NotFound`.
    :param directory: the directory to serve up.
    :param fallback_mimetype: the fallback mimetype for unknown files.
    """

    def __init__(self, app, directory, fallback_mimetype='text/plain'):
        self.app = app
        self.directory = directory
        self.loader = self.get_directory_loader(directory)
        self.fallback_mimetype = fallback_mimetype

    def _opener(self, filename):
        return lambda: (
            open(filename, 'rb'),
            datetime.utcfromtimestamp(os.path.getmtime(filename)),
            int(os.path.getsize(filename))
        )

    def get_directory_loader(self, directory):
        def loader(path):
            path = path or directory
            if path is not None:
                path = os.path.join(directory, path)
            if os.path.isfile(path):
                return os.path.basename(path), self._opener(path)
            return None, None
        return loader

    def __call__(self, environ, start_response):
        # sanitize the path for non unix systems
        cleaned_path = environ.get('PATH_INFO', '').strip('/')
        for sep in os.sep, os.altsep:
            if sep and sep != '/':
                cleaned_path = cleaned_path.replace(sep, '/')
        path = '/'.join([''] + [x for x in cleaned_path.split('/')
                                if x and x != '..'])

        # attempt to find a loader for the file
        real_filename, file_loader = self.loader(path[1:])
        if file_loader is None:
            return self.app(environ, start_response)

        # serve the file with the appropriate name if we found it
        guessed_type = mimetypes.guess_type(real_filename)
        mime_type = guessed_type[0] or self.fallback_mimetype
        f, mtime, file_size = file_loader()

        headers = [('Date', http_date())]
        headers.append(('Cache-Control', 'public'))
        headers.extend((
            ('Content-Type', mime_type),
            ('Content-Length', str(file_size)),
            ('Last-Modified', http_date(mtime))
        ))

        start_response('200 OK', headers)
        return wrap_file(environ, f)

########NEW FILE########
__FILENAME__ = rest
from inspect import getargspec, ismethod

from webob import exc
import six

from .core import abort, request
from .decorators import expose
from .routing import lookup_controller, handle_lookup_traversal
from .util import iscontroller


class RestController(object):
    '''
    A base class for ``REST`` based controllers. Inherit from this class
    to implement a REST controller.

    ``RestController`` implements a set of routing functions which override
    the default pecan routing with behavior consistent with RESTful routing.
    This functionality covers navigation to the requested resource
    controllers, and the appropriate handling of both the common (``GET``,
    ``POST``, ``PUT``, ``DELETE``) as well as custom-defined REST action
    methods.

    For more on developing **RESTful** web applications with Pecan, see
    :ref:`rest`.
    '''
    _custom_actions = {}

    @expose()
    def _route(self, args):
        '''
        Routes a request to the appropriate controller and returns its result.

        Performs a bit of validation - refuses to route delete and put actions
        via a GET request).
        '''
        # convention uses "_method" to handle browser-unsupported methods
        if request.environ.get('pecan.validation_redirected', False) is True:
            #
            # If the request has been internally redirected due to a validation
            # exception, we want the request method to be enforced as GET, not
            # the `_method` param which may have been passed for REST support.
            #
            method = request.method.lower()
        else:
            method = request.params.get('_method', request.method).lower()

        # make sure DELETE/PUT requests don't use GET
        if request.method == 'GET' and method in ('delete', 'put'):
            abort(405)

        # check for nested controllers
        result = self._find_sub_controllers(args)
        if result:
            return result

        # handle the request
        handler = getattr(
            self,
            '_handle_%s' % method,
            self._handle_unknown_method
        )

        try:
            result = handler(method, args)

            #
            # If the signature of the handler does not match the number
            # of remaining positional arguments, attempt to handle
            # a _lookup method (if it exists)
            #
            argspec = getargspec(result[0])
            num_args = len(argspec[0][1:])
            if num_args < len(args):
                _lookup_result = self._handle_lookup(args)
                if _lookup_result:
                    return _lookup_result
        except exc.HTTPNotFound:
            #
            # If the matching handler results in a 404, attempt to handle
            # a _lookup method (if it exists)
            #
            _lookup_result = self._handle_lookup(args)
            if _lookup_result:
                return _lookup_result
            raise

        # return the result
        return result

    def _handle_lookup(self, args):
        # filter empty strings from the arg list
        args = list(six.moves.filter(bool, args))

        # check for lookup controllers
        lookup = getattr(self, '_lookup', None)
        if args and iscontroller(lookup):
            result = handle_lookup_traversal(lookup, args)
            if result:
                return lookup_controller(*result)

    def _find_controller(self, *args):
        '''
        Returns the appropriate controller for routing a custom action.
        '''
        for name in args:
            obj = getattr(self, name, None)
            if obj and iscontroller(obj):
                return obj
        return None

    def _find_sub_controllers(self, remainder):
        '''
        Identifies the correct controller to route to by analyzing the
        request URI.
        '''
        # need either a get_one or get to parse args
        method = None
        for name in ('get_one', 'get'):
            if hasattr(self, name):
                method = name
                break
        if not method:
            return

        # get the args to figure out how much to chop off
        args = getargspec(getattr(self, method))
        fixed_args = len(args[0][1:]) - len(
            request.pecan.get('routing_args', [])
        )
        var_args = args[1]

        # attempt to locate a sub-controller
        if var_args:
            for i, item in enumerate(remainder):
                controller = getattr(self, item, None)
                if controller and not ismethod(controller):
                    self._set_routing_args(remainder[:i])
                    return lookup_controller(controller, remainder[i + 1:])
        elif fixed_args < len(remainder) and hasattr(
            self, remainder[fixed_args]
        ):
            controller = getattr(self, remainder[fixed_args])
            if not ismethod(controller):
                self._set_routing_args(remainder[:fixed_args])
                return lookup_controller(
                    controller,
                    remainder[fixed_args + 1:]
                )

    def _handle_unknown_method(self, method, remainder):
        '''
        Routes undefined actions (like RESET) to the appropriate controller.
        '''
        # try finding a post_{custom} or {custom} method first
        controller = self._find_controller('post_%s' % method, method)
        if controller:
            return controller, remainder

        # if no controller exists, try routing to a sub-controller; note that
        # since this isn't a safe GET verb, any local exposes are 405'd
        if remainder:
            if self._find_controller(remainder[0]):
                abort(405)
            sub_controller = getattr(self, remainder[0], None)
            if sub_controller:
                return lookup_controller(sub_controller, remainder[1:])

        abort(404)

    def _handle_get(self, method, remainder):
        '''
        Routes ``GET`` actions to the appropriate controller.
        '''
        # route to a get_all or get if no additional parts are available
        if not remainder or remainder == ['']:
            controller = self._find_controller('get_all', 'get')
            if controller:
                argspec = getargspec(controller)
                fixed_args = len(argspec.args[1:]) - len(
                    request.pecan.get('routing_args', [])
                )
                if len(remainder) < fixed_args:
                    abort(404)
                return controller, []
            abort(404)

        method_name = remainder[-1]
        # check for new/edit/delete GET requests
        if method_name in ('new', 'edit', 'delete'):
            if method_name == 'delete':
                method_name = 'get_delete'
            controller = self._find_controller(method_name)
            if controller:
                return controller, remainder[:-1]

        match = self._handle_custom_action(method, remainder)
        if match:
            return match

        controller = getattr(self, remainder[0], None)
        if controller and not ismethod(controller):
            return lookup_controller(controller, remainder[1:])

        # finally, check for the regular get_one/get requests
        controller = self._find_controller('get_one', 'get')
        if controller:
            return controller, remainder

        abort(404)

    def _handle_delete(self, method, remainder):
        '''
        Routes ``DELETE`` actions to the appropriate controller.
        '''
        if remainder:
            match = self._handle_custom_action(method, remainder)
            if match:
                return match

            controller = getattr(self, remainder[0], None)
            if controller and not ismethod(controller):
                return lookup_controller(controller, remainder[1:])

        # check for post_delete/delete requests first
        controller = self._find_controller('post_delete', 'delete')
        if controller:
            return controller, remainder

        # if no controller exists, try routing to a sub-controller; note that
        # since this is a DELETE verb, any local exposes are 405'd
        if remainder:
            if self._find_controller(remainder[0]):
                abort(405)
            sub_controller = getattr(self, remainder[0], None)
            if sub_controller:
                return lookup_controller(sub_controller, remainder[1:])

        abort(404)

    def _handle_post(self, method, remainder):
        '''
        Routes ``POST`` requests.
        '''
        # check for custom POST/PUT requests
        if remainder:
            match = self._handle_custom_action(method, remainder)
            if match:
                return match

            controller = getattr(self, remainder[0], None)
            if controller and not ismethod(controller):
                return lookup_controller(controller, remainder[1:])

        # check for regular POST/PUT requests
        controller = self._find_controller(method)
        if controller:
            return controller, remainder

        abort(404)

    def _handle_put(self, method, remainder):
        return self._handle_post(method, remainder)

    def _handle_custom_action(self, method, remainder):
        remainder = [r for r in remainder if r]
        if remainder:
            if method in ('put', 'delete'):
                # For PUT and DELETE, additional arguments are supplied, e.g.,
                # DELETE /foo/XYZ
                method_name = remainder[0]
                remainder = remainder[1:]
            else:
                method_name = remainder[-1]
                remainder = remainder[:-1]
            if method.upper() in self._custom_actions.get(method_name, []):
                controller = self._find_controller(
                    '%s_%s' % (method, method_name),
                    method_name
                )
                if controller:
                    return controller, remainder

    def _set_routing_args(self, args):
        '''
        Sets default routing arguments.
        '''
        request.pecan.setdefault('routing_args', []).extend(args)

########NEW FILE########
__FILENAME__ = routing
import warnings

from webob import exc

from .secure import handle_security, cross_boundary
from .util import iscontroller

__all__ = ['lookup_controller', 'find_object']


class PecanNotFound(Exception):
    pass


class NonCanonicalPath(Exception):
    '''
    Exception Raised when a non-canonical path is encountered when 'walking'
    the URI.  This is typically a ``POST`` request which requires a trailing
    slash.
    '''
    def __init__(self, controller, remainder):
        self.controller = controller
        self.remainder = remainder


def lookup_controller(obj, remainder):
    '''
    Traverses the requested url path and returns the appropriate controller
    object, including default routes.

    Handles common errors gracefully.
    '''
    notfound_handlers = []
    while True:
        try:
            obj, remainder = find_object(obj, remainder, notfound_handlers)
            handle_security(obj)
            return obj, remainder
        except (exc.HTTPNotFound, PecanNotFound):
            while notfound_handlers:
                name, obj, remainder = notfound_handlers.pop()
                if name == '_default':
                    # Notfound handler is, in fact, a controller, so stop
                    #   traversal
                    return obj, remainder
                else:
                    # Notfound handler is an internal redirect, so continue
                    #   traversal
                    result = handle_lookup_traversal(obj, remainder)
                    if result:
                        # If no arguments are passed to the _lookup, yet the
                        # argspec requires at least one, raise a 404
                        if (
                            remainder == ['']
                            and len(obj._pecan['argspec'].args) > 1
                        ):
                            raise exc.HTTPNotFound
                        return lookup_controller(*result)
            else:
                raise exc.HTTPNotFound


def handle_lookup_traversal(obj, args):
    try:
        result = obj(*args)
        if result:
            prev_obj = obj
            obj, remainder = result
            # crossing controller boundary
            cross_boundary(prev_obj, obj)
            return result
    except TypeError as te:
        msg = 'Got exception calling lookup(): %s (%s)'
        warnings.warn(
            msg % (te, te.args),
            RuntimeWarning
        )


def find_object(obj, remainder, notfound_handlers):
    '''
    'Walks' the url path in search of an action for which a controller is
    implemented and returns that controller object along with what's left
    of the remainder.
    '''
    prev_obj = None
    while True:
        if obj is None:
            raise PecanNotFound
        if iscontroller(obj):
            return obj, remainder

        # are we traversing to another controller
        cross_boundary(prev_obj, obj)
        try:
            next_obj, rest = remainder[0], remainder[1:]
            if next_obj == '':
                index = getattr(obj, 'index', None)
                if iscontroller(index):
                    return index, rest
        except IndexError:
            # the URL has hit an index method without a trailing slash
            index = getattr(obj, 'index', None)
            if iscontroller(index):
                raise NonCanonicalPath(index, [])

        default = getattr(obj, '_default', None)
        if iscontroller(default):
            notfound_handlers.append(('_default', default, remainder))

        lookup = getattr(obj, '_lookup', None)
        if iscontroller(lookup):
            notfound_handlers.append(('_lookup', lookup, remainder))

        route = getattr(obj, '_route', None)
        if iscontroller(route):
            next_obj, next_remainder = route(remainder)
            cross_boundary(route, next_obj)
            return next_obj, next_remainder

        if not remainder:
            raise PecanNotFound
        prev_obj = obj
        remainder = rest
        obj = getattr(obj, next_obj, None)

########NEW FILE########
__FILENAME__ = root
from pecan import expose, redirect
from webob.exc import status_map


class RootController(object):

    @expose(generic=True, template='index.html')
    def index(self):
        return dict()

    @index.when(method='POST')
    def index_post(self, q):
        redirect('http://pecan.readthedocs.org/en/latest/search.html?q=%s' % q)

    @expose('error.html')
    def error(self, status):
        try:
            status = int(status)
        except ValueError:  # pragma: no cover
            status = 500
        message = getattr(status_map.get(status), 'explanation', '')
        return dict(status=status, message=message)

########NEW FILE########
__FILENAME__ = test_units
from unittest import TestCase


class TestUnits(TestCase):

    def test_units(self):
        assert 5 * 5 == 25

########NEW FILE########
__FILENAME__ = root
from pecan import expose, response, abort
from pecan.rest import RestController

people = {
    1: 'Luke',
    2: 'Leia',
    3: 'Han',
    4: 'Anakin'
}


class PeopleController(RestController):

    @expose('json')
    def get_all(self):
        return people

    @expose()
    def get_one(self, person_id):
        return people.get(int(person_id)) or abort(404)

    @expose()
    def post(self):
        # TODO: Create a new person
        response.status = 201

    @expose()
    def put(self, person_id):
        # TODO: Idempotent PUT (returns 200 or 204)
        response.status = 204

    @expose()
    def delete(self, person_id):
        # TODO: Idempotent DELETE
        response.status = 200


class RootController(object):

    people = PeopleController()

    @expose()
    def index(self):
        return "Hello, World!"

########NEW FILE########
__FILENAME__ = errors
import json
import webob
from pecan.hooks import PecanHook


class JSONErrorHook(PecanHook):
    """
    A pecan hook that translates webob HTTP errors into a JSON format.
    """

    def on_error(self, state, exc):
        if isinstance(exc, webob.exc.HTTPError):
            return webob.Response(
                body=json.dumps({'reason': str(exc)}),
                status=exc.status,
                headerlist=exc.headerlist,
                content_type='application/json'
            )

########NEW FILE########
__FILENAME__ = test_units
from unittest import TestCase


class TestUnits(TestCase):

    def test_units(self):
        assert 5 * 5 == 25

########NEW FILE########
__FILENAME__ = secure
from functools import wraps
from inspect import getmembers, isfunction
from webob import exc

import six

if six.PY3:
    from .compat import is_bound_method as ismethod
else:
    from inspect import ismethod

from .decorators import expose
from .util import _cfg, iscontroller

__all__ = ['unlocked', 'secure', 'SecureController']


class _SecureState(object):
    def __init__(self, desc, boolean_value):
        self.description = desc
        self.boolean_value = boolean_value

    def __repr__(self):
        return '<SecureState %s>' % self.description

    def __nonzero__(self):
        return self.boolean_value

    def __bool__(self):
        return self.__nonzero__()

Any = _SecureState('Any', False)
Protected = _SecureState('Protected', True)


# security method decorators
def _unlocked_method(func):
    _cfg(func)['secured'] = Any
    return func


def _secure_method(check_permissions_func):
    def wrap(func):
        cfg = _cfg(func)
        cfg['secured'] = Protected
        cfg['check_permissions'] = check_permissions_func
        return func
    return wrap


# classes to assist with wrapping attributes
class _UnlockedAttribute(object):
    def __init__(self, obj):
        self.obj = obj

    @_unlocked_method
    @expose()
    def _lookup(self, *remainder):
        return self.obj, remainder


class _SecuredAttribute(object):
    def __init__(self, obj, check_permissions):
        self.obj = obj
        self.check_permissions = check_permissions
        self._parent = None

    def _check_permissions(self):
        if isinstance(self.check_permissions, six.string_types):
            return getattr(self.parent, self.check_permissions)()
        else:
            return self.check_permissions()

    def __get_parent(self):
        return self._parent

    def __set_parent(self, parent):
        if ismethod(parent):
            self._parent = six.get_method_self(parent)
        else:
            self._parent = parent
    parent = property(__get_parent, __set_parent)

    @_secure_method('_check_permissions')
    @expose()
    def _lookup(self, *remainder):
        return self.obj, remainder


# helper for secure decorator
def _allowed_check_permissions_types(x):
    return (
        ismethod(x) or
        isfunction(x) or
        isinstance(x, six.string_types)
    )


# methods that can either decorate functions or wrap classes
# these should be the main methods used for securing or unlocking
def unlocked(func_or_obj):
    """
    This method unlocks method or class attribute on a SecureController.  Can
    be used to decorate or wrap an attribute
    """
    if ismethod(func_or_obj) or isfunction(func_or_obj):
        return _unlocked_method(func_or_obj)
    else:
        return _UnlockedAttribute(func_or_obj)


def secure(func_or_obj, check_permissions_for_obj=None):
    """
    This method secures a method or class depending on invocation.

    To decorate a method use one argument:
        @secure(<check_permissions_method>)

    To secure a class, invoke with two arguments:
        secure(<obj instance>, <check_permissions_method>)
    """
    if _allowed_check_permissions_types(func_or_obj):
        return _secure_method(func_or_obj)
    else:
        if not _allowed_check_permissions_types(check_permissions_for_obj):
            msg = "When securing an object, secure() requires the " + \
                  "second argument to be method"
            raise TypeError(msg)
        return _SecuredAttribute(func_or_obj, check_permissions_for_obj)


class SecureControllerMeta(type):
    """
    Used to apply security to a controller.
    Implementations of SecureController should extend the
    `check_permissions` method to return a True or False
    value (depending on whether or not the user has permissions
    to the controller).
    """
    def __init__(cls, name, bases, dict_):
        cls._pecan = dict(
            secured=Protected,
            check_permissions=cls.check_permissions,
            unlocked=[]
        )

        for name, value in getmembers(cls)[:]:
            if (isfunction if six.PY3 else ismethod)(value):
                if iscontroller(value) and value._pecan.get(
                    'secured'
                ) is None:
                    # Wrap the function so that the security context is
                    # local to this class definition.  This works around
                    # the fact that unbound method attributes are shared
                    # across classes with the same bases.
                    wrapped = _make_wrapper(value)
                    wrapped._pecan['secured'] = Protected
                    wrapped._pecan['check_permissions'] = \
                        cls.check_permissions
                    setattr(cls, name, wrapped)
            elif hasattr(value, '__class__'):
                if name.startswith('__') and name.endswith('__'):
                    continue
                if isinstance(value, _UnlockedAttribute):
                    # mark it as unlocked and remove wrapper
                    cls._pecan['unlocked'].append(value.obj)
                    setattr(cls, name, value.obj)
                elif isinstance(value, _SecuredAttribute):
                    # The user has specified a different check_permissions
                    # than the class level version.  As far as the class
                    # is concerned, this method is unlocked because
                    # it is using a check_permissions function embedded in
                    # the _SecuredAttribute wrapper
                    cls._pecan['unlocked'].append(value)


class SecureControllerBase(object):

    @classmethod
    def check_permissions(cls):
        """
        Returns `True` or `False` to grant access.  Implemented in subclasses
        of :class:`SecureController`.
        """
        return False


SecureController = SecureControllerMeta(
    'SecureController',
    (SecureControllerBase,),
    {'__doc__': SecureControllerMeta.__doc__}
)


def _make_wrapper(f):
    """return a wrapped function with a copy of the _pecan context"""
    @wraps(f)
    def wrapper(*args, **kwargs):
        return f(*args, **kwargs)
    wrapper._pecan = f._pecan.copy()
    return wrapper


# methods to evaluate security during routing
def handle_security(controller, im_self=None):
    """ Checks the security of a controller.  """
    if controller._pecan.get('secured', False):
        check_permissions = controller._pecan['check_permissions']

        if isinstance(check_permissions, six.string_types):
            check_permissions = getattr(
                im_self or six.get_method_self(controller),
                check_permissions
            )

        if not check_permissions():
            raise exc.HTTPUnauthorized


def cross_boundary(prev_obj, obj):
    """ Check permissions as we move between object instances. """
    if prev_obj is None:
        return

    if isinstance(obj, _SecuredAttribute):
        # a secure attribute can live in unsecure class so we have to set
        # while we walk the route
        obj.parent = prev_obj

    if hasattr(prev_obj, '_pecan'):
        if obj not in prev_obj._pecan.get('unlocked', []):
            handle_security(prev_obj)

########NEW FILE########
__FILENAME__ = templating
from .compat import escape
from .jsonify import encode

_builtin_renderers = {}
error_formatters = []

#
# JSON rendering engine
#


class JsonRenderer(object):
    '''
    Defines the builtin ``JSON`` renderer.
    '''
    def __init__(self, path, extra_vars):
        pass

    def render(self, template_path, namespace):
        '''
        Implements ``JSON`` rendering.
        '''
        return encode(namespace)

    # TODO: add error formatter for json (pass it through json lint?)

_builtin_renderers['json'] = JsonRenderer

#
# Genshi rendering engine
#

try:
    from genshi.template import (TemplateLoader,
                                 TemplateError as gTemplateError)

    class GenshiRenderer(object):
        '''
        Defines the builtin ``Genshi`` renderer.
        '''
        def __init__(self, path, extra_vars):
            self.loader = TemplateLoader([path], auto_reload=True)
            self.extra_vars = extra_vars

        def render(self, template_path, namespace):
            '''
            Implements ``Genshi`` rendering.
            '''
            tmpl = self.loader.load(template_path)
            stream = tmpl.generate(**self.extra_vars.make_ns(namespace))
            return stream.render('html')

    _builtin_renderers['genshi'] = GenshiRenderer

    def format_genshi_error(exc_value):
        '''
        Implements ``Genshi`` renderer error formatting.
        '''
        if isinstance(exc_value, (gTemplateError)):
            retval = '<h4>Genshi error %s</h4>' % escape(
                exc_value.args[0],
                True
            )
            retval += format_line_context(exc_value.filename, exc_value.lineno)
            return retval
    error_formatters.append(format_genshi_error)
except ImportError:                                 # pragma no cover
    pass


#
# Mako rendering engine
#

try:
    from mako.lookup import TemplateLookup
    from mako.exceptions import (CompileException, SyntaxException,
                                 html_error_template)

    class MakoRenderer(object):
        '''
        Defines the builtin ``Mako`` renderer.
        '''
        def __init__(self, path, extra_vars):
            self.loader = TemplateLookup(
                directories=[path],
                output_encoding='utf-8'
            )
            self.extra_vars = extra_vars

        def render(self, template_path, namespace):
            '''
            Implements ``Mako`` rendering.
            '''
            tmpl = self.loader.get_template(template_path)
            return tmpl.render(**self.extra_vars.make_ns(namespace))

    _builtin_renderers['mako'] = MakoRenderer

    def format_mako_error(exc_value):
        '''
        Implements ``Mako`` renderer error formatting.
        '''
        if isinstance(exc_value, (CompileException, SyntaxException)):
            return html_error_template().render(full=False, css=False)

    error_formatters.append(format_mako_error)
except ImportError:                                 # pragma no cover
    pass


#
# Kajiki rendering engine
#

try:
    from kajiki.loader import FileLoader

    class KajikiRenderer(object):
        '''
        Defines the builtin ``Kajiki`` renderer.
        '''
        def __init__(self, path, extra_vars):
            self.loader = FileLoader(path, reload=True)
            self.extra_vars = extra_vars

        def render(self, template_path, namespace):
            '''
            Implements ``Kajiki`` rendering.
            '''
            Template = self.loader.import_(template_path)
            stream = Template(self.extra_vars.make_ns(namespace))
            return stream.render()
    _builtin_renderers['kajiki'] = KajikiRenderer
    # TODO: add error formatter for kajiki
except ImportError:                                 # pragma no cover
    pass

#
# Jinja2 rendering engine
#
try:
    from jinja2 import Environment, FileSystemLoader
    from jinja2.exceptions import TemplateSyntaxError as jTemplateSyntaxError

    class JinjaRenderer(object):
        '''
        Defines the builtin ``Jinja`` renderer.
        '''
        def __init__(self, path, extra_vars):
            self.env = Environment(loader=FileSystemLoader(path))
            self.extra_vars = extra_vars

        def render(self, template_path, namespace):
            '''
            Implements ``Jinja`` rendering.
            '''
            template = self.env.get_template(template_path)
            return template.render(self.extra_vars.make_ns(namespace))
    _builtin_renderers['jinja'] = JinjaRenderer

    def format_jinja_error(exc_value):
        '''
        Implements ``Jinja`` renderer error formatting.
        '''
        retval = '<h4>Jinja2 error in \'%s\' on line %d</h4><div>%s</div>'
        if isinstance(exc_value, (jTemplateSyntaxError)):
            retval = retval % (
                exc_value.name,
                exc_value.lineno,
                exc_value.message
            )
            retval += format_line_context(exc_value.filename, exc_value.lineno)
            return retval
    error_formatters.append(format_jinja_error)
except ImportError:                                 # pragma no cover
    pass


#
# format helper function
#
def format_line_context(filename, lineno, context=10):
    '''
    Formats the the line context for error rendering.

    :param filename: the location of the file, within which the error occurred
    :param lineno: the offending line number
    :param context: number of lines of code to display before and after the
                    offending line.
    '''
    lines = open(filename).readlines()

    lineno = lineno - 1  # files are indexed by 1 not 0
    if lineno > 0:
        start_lineno = max(lineno - context, 0)
        end_lineno = lineno + context

        lines = [escape(l, True) for l in lines[start_lineno:end_lineno]]
        i = lineno - start_lineno
        lines[i] = '<strong>%s</strong>' % lines[i]

    else:
        lines = [escape(l, True) for l in lines[:context]]
    msg = '<pre style="background-color:#ccc;padding:2em;">%s</pre>'
    return msg % ''.join(lines)


#
# Extra Vars Rendering
#
class ExtraNamespace(object):
    '''
    Extra variables for the template namespace to pass to the renderer as named
    parameters.

    :param extras: dictionary of extra parameters. Defaults to an empty dict.
    '''
    def __init__(self, extras={}):
        self.namespace = dict(extras)

    def update(self, d):
        '''
        Updates the extra variable dictionary for the namespace.
        '''
        self.namespace.update(d)

    def make_ns(self, ns):
        '''
        Returns the `lazily` created template namespace.
        '''
        if self.namespace:
            val = {}
            val.update(self.namespace)
            val.update(ns)
            return val
        else:
            return ns


#
# Rendering Factory
#
class RendererFactory(object):
    '''
    Manufactures known Renderer objects.

    :param custom_renderers: custom-defined renderers to manufacture
    :param extra_vars: extra vars for the template namespace
    '''
    def __init__(self, custom_renderers={}, extra_vars={}):
        self._renderers = {}
        self._renderer_classes = dict(_builtin_renderers)
        self.add_renderers(custom_renderers)
        self.extra_vars = ExtraNamespace(extra_vars)

    def add_renderers(self, custom_dict):
        '''
        Adds a custom renderer.

        :param custom_dict: a dictionary of custom renderers to add
        '''
        self._renderer_classes.update(custom_dict)

    def available(self, name):
        '''
        Returns true if queried renderer class is available.

        :param name: renderer name
        '''
        return name in self._renderer_classes

    def get(self, name, template_path):
        '''
        Returns the renderer object.

        :param name: name of the requested renderer
        :param template_path: path to the template
        '''
        if name not in self._renderers:
            cls = self._renderer_classes.get(name)
            if cls is None:
                return None
            else:
                self._renderers[name] = cls(template_path, self.extra_vars)
        return self._renderers[name]

########NEW FILE########
__FILENAME__ = testing
from pecan import load_app
from webtest import TestApp


def load_test_app(config=None, **kwargs):
    """
    Used for functional tests where you need to test your
    literal application and its integration with the framework.

    :param config: Can be a dictionary containing configuration, a string which
                    represents a (relative) configuration filename or ``None``
                    which will fallback to get the ``PECAN_CONFIG`` env
                    variable.

    returns a pecan.Pecan WSGI application wrapped in a webtest.TestApp
    instance.

    ::
        app = load_test_app('path/to/some/config.py')

        resp = app.get('/path/to/some/resource').status_int
        assert resp.status_int == 200

        resp = app.post('/path/to/some/resource', params={'param': 'value'})
        assert resp.status_int == 302

    Alternatively you could call ``load_test_app`` with no parameters if the
    environment variable is set ::

        app = load_test_app()

        resp = app.get('/path/to/some/resource').status_int
        assert resp.status_int == 200
    """
    return TestApp(load_app(config, **kwargs))

########NEW FILE########
__FILENAME__ = importerror
import pecan.thismoduledoesnotexist

########NEW FILE########
__FILENAME__ = module_and_underscore
import sys

__badattr__ = True
moduleattr = sys

########NEW FILE########
__FILENAME__ = config


# Server Specific Configurations
server = {
    'port': '8081',
    'host': '1.1.1.1',
    'hostport': '{pecan.conf.server.host}:{pecan.conf.server.port}'
}

# Pecan Application Configurations
app = {
    'static_root': 'public',
    'template_path': 'myproject/templates',
    'debug': True
}

# Custom Configurations must be in Python dictionary format::
#
# foo = {'bar':'baz'}
#
# All configurations are accessible at::
# pecan.conf

########NEW FILE########
__FILENAME__ = empty
app = {}
server = {}

########NEW FILE########
__FILENAME__ = foobar
foo = "bar"

########NEW FILE########
__FILENAME__ = forcedict
# Pecan Application Configurations
beaker = {
    'session.key': 'key',
    'session.type': 'cookie',
    'session.validate_key': '1a971a7df182df3e1dec0af7c6913ec7',
    '__force_dict__': True
}

# Custom Configurations must be in Python dictionary format::
#
# foo = {'bar':'baz'}
#
# All configurations are accessible at::
# pecan.conf

########NEW FILE########
__FILENAME__ = test_debug
from wsgiref.util import setup_testing_defaults

from webtest import TestApp
from six import b as b_

from pecan.middleware.debug import DebugMiddleware
from pecan.tests import PecanTestCase


class StripPasteVar(object):
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        environ.pop('paste.testing')
        return self.app(environ, start_response)


class TestDebugMiddleware(PecanTestCase):

    def setUp(self):
        super(TestDebugMiddleware, self).setUp()

        def conditional_error_app(environ, start_response):
            setup_testing_defaults(environ)
            if environ['PATH_INFO'] == '/error':
                assert 1 == 2
            start_response("200 OK", [('Content-type', 'text/plain')])
            return [b_('requested page returned')]
        self.app = TestApp(StripPasteVar(DebugMiddleware(
            conditional_error_app
        )))

    def test_middleware_passes_through_when_no_exception_raised(self):
        r = self.app.get('/')
        assert r.status_int == 200
        assert r.body == b_('requested page returned')

    def test_middleware_gives_stack_trace_on_errors(self):
        r = self.app.get('/error', expect_errors=True)
        assert r.status_int == 400
        assert b_('AssertionError') in r.body

    def test_middleware_complains_in_multi_process_environment(self):

        class MultiProcessApp(object):

            def __init__(self, app):
                self.app = app

            def __call__(self, environ, start_response):
                environ['wsgi.multiprocess'] = True
                return self.app(environ, start_response)

        def conditional_error_app(environ, start_response):
            start_response("200 OK", [('Content-type', 'text/plain')])
            return ['Hello, World!']

        app = TestApp(MultiProcessApp(DebugMiddleware(conditional_error_app)))
        self.assertRaises(
            AssertionError,
            app.get,
            '/'
        )

    def test_middlware_allows_for_post_mortem_debugging(self):
        def patch_debugger(d):
            def _patched_debug_request():
                d.append(True)
            return _patched_debug_request

        debugger = []

        app = TestApp(StripPasteVar(DebugMiddleware(
            self.app,
            patch_debugger(debugger)
        )))

        r = app.get('/error', expect_errors=True)
        assert r.status_int == 400

        r = app.get('/__pecan_initiate_pdb__', expect_errors=True)
        assert len(debugger) > 0

########NEW FILE########
__FILENAME__ = test_errordocument
import json

from webtest import TestApp
from six import b as b_

import pecan
from pecan.middleware.errordocument import ErrorDocumentMiddleware
from pecan.middleware.recursive import RecursiveMiddleware
from pecan.tests import PecanTestCase


def four_oh_four_app(environ, start_response):
    if environ['PATH_INFO'].startswith('/error'):
        code = environ['PATH_INFO'].split('/')[2]
        start_response("200 OK", [('Content-type', 'text/plain')])

        body = "Error: %s" % code
        if environ['QUERY_STRING']:
            body += "\nQS: %s" % environ['QUERY_STRING']
        return [b_(body)]
    start_response("404 Not Found", [('Content-type', 'text/plain')])
    return []


class TestErrorDocumentMiddleware(PecanTestCase):

    def setUp(self):
        super(TestErrorDocumentMiddleware, self).setUp()
        self.app = TestApp(RecursiveMiddleware(ErrorDocumentMiddleware(
            four_oh_four_app, {404: '/error/404'}
        )))

    def test_hit_error_page(self):
        r = self.app.get('/error/404')
        assert r.status_int == 200
        assert r.body == b_('Error: 404')

    def test_middleware_routes_to_404_message(self):
        r = self.app.get('/', expect_errors=True)
        assert r.status_int == 404
        assert r.body == b_('Error: 404')

    def test_error_endpoint_with_query_string(self):
        app = TestApp(RecursiveMiddleware(ErrorDocumentMiddleware(
            four_oh_four_app, {404: '/error/404?foo=bar'}
        )))
        r = app.get('/', expect_errors=True)
        assert r.status_int == 404
        assert r.body == b_('Error: 404\nQS: foo=bar')

    def test_error_with_recursion_loop(self):
        app = TestApp(RecursiveMiddleware(ErrorDocumentMiddleware(
            four_oh_four_app, {404: '/'}
        )))
        r = app.get('/', expect_errors=True)
        assert r.status_int == 404
        assert r.body == b_(
            'Error: 404 Not Found.  (Error page could not be fetched)'
        )

    def test_original_exception(self):

        class RootController(object):

            @pecan.expose()
            def index(self):
                if pecan.request.method != 'POST':
                    pecan.abort(405, 'You have to POST, dummy!')
                return 'Hello, World!'

            @pecan.expose('json')
            def error(self, status):
                return dict(
                    status=int(status),
                    reason=pecan.request.environ[
                        'pecan.original_exception'
                    ].detail
                )

        app = pecan.Pecan(RootController())
        app = RecursiveMiddleware(ErrorDocumentMiddleware(app, {
            405: '/error/405'
        }))
        app = TestApp(app)

        assert app.post('/').status_int == 200
        r = app.get('/', expect_errors=405)
        assert r.status_int == 405

        resp = json.loads(r.body.decode())
        assert resp['status'] == 405
        assert resp['reason'] == 'You have to POST, dummy!'

########NEW FILE########
__FILENAME__ = test_recursive
from webtest import TestApp
from six import b as b_

from pecan.middleware.recursive import (RecursiveMiddleware,
                                        ForwardRequestException)
from pecan.tests import PecanTestCase


def simple_app(environ, start_response):
    start_response("200 OK", [('Content-type', 'text/plain')])
    return [b_('requested page returned')]


def error_docs_app(environ, start_response):
    if environ['PATH_INFO'] == '/not_found':
        start_response("404 Not found", [('Content-type', 'text/plain')])
        return [b_('Not found')]
    elif environ['PATH_INFO'] == '/error':
        start_response("200 OK", [('Content-type', 'text/plain')])
        return [b_('Page not found')]
    elif environ['PATH_INFO'] == '/recurse':
        raise ForwardRequestException('/recurse')
    else:
        return simple_app(environ, start_response)


class Middleware(object):
    def __init__(self, app, url='/error'):
        self.app = app
        self.url = url

    def __call__(self, environ, start_response):
        raise ForwardRequestException(self.url)


def forward(app):
    app = TestApp(RecursiveMiddleware(app))
    res = app.get('')

    assert res.headers['content-type'] == 'text/plain'
    assert res.status == '200 OK'
    assert 'requested page returned' in res
    res = app.get('/error')
    assert res.headers['content-type'] == 'text/plain'
    assert res.status == '200 OK'
    assert 'Page not found' in res
    res = app.get('/not_found')
    assert res.headers['content-type'] == 'text/plain'
    assert res.status == '200 OK'
    assert 'Page not found' in res
    try:
        res = app.get('/recurse')
    except AssertionError as e:
        if str(e).startswith('Forwarding loop detected'):
            pass
        else:
            raise AssertionError('Failed to detect forwarding loop')


class TestRecursiveMiddleware(PecanTestCase):

    def test_ForwardRequest_url(self):
        class TestForwardRequestMiddleware(Middleware):
            def __call__(self, environ, start_response):
                if environ['PATH_INFO'] != '/not_found':
                    return self.app(environ, start_response)
                raise ForwardRequestException(self.url)
        forward(TestForwardRequestMiddleware(error_docs_app))

    def test_ForwardRequest_url_with_params(self):
        class TestForwardRequestMiddleware(Middleware):
            def __call__(self, environ, start_response):
                if environ['PATH_INFO'] != '/not_found':
                    return self.app(environ, start_response)
                raise ForwardRequestException(self.url + '?q=1')
        forward(TestForwardRequestMiddleware(error_docs_app))

    def test_ForwardRequest_environ(self):
        class TestForwardRequestMiddleware(Middleware):
            def __call__(self, environ, start_response):
                if environ['PATH_INFO'] != '/not_found':
                    return self.app(environ, start_response)
                environ['PATH_INFO'] = self.url
                raise ForwardRequestException(environ=environ)
        forward(TestForwardRequestMiddleware(error_docs_app))

    def test_ForwardRequest_factory(self):

        class TestForwardRequestMiddleware(Middleware):
            def __call__(self, environ, start_response):
                if environ['PATH_INFO'] != '/not_found':
                    return self.app(environ, start_response)
                environ['PATH_INFO'] = self.url

                def factory(app):

                    class WSGIApp(object):

                        def __init__(self, app):
                            self.app = app

                        def __call__(self, e, start_response):
                            def keep_status_start_response(status, headers,
                                                           exc_info=None):
                                return start_response(
                                    '404 Not Found', headers, exc_info
                                )
                            return self.app(e, keep_status_start_response)

                    return WSGIApp(app)

                raise ForwardRequestException(factory=factory)

        app = TestForwardRequestMiddleware(error_docs_app)
        app = TestApp(RecursiveMiddleware(app))
        res = app.get('')
        assert res.headers['content-type'] == 'text/plain'
        assert res.status == '200 OK'
        assert 'requested page returned' in res
        res = app.get('/error')
        assert res.headers['content-type'] == 'text/plain'
        assert res.status == '200 OK'
        assert 'Page not found' in res
        res = app.get('/not_found', status=404)
        assert res.headers['content-type'] == 'text/plain'
        assert res.status == '404 Not Found'  # Different status
        assert 'Page not found' in res
        try:
            res = app.get('/recurse')
        except AssertionError as e:
            if str(e).startswith('Forwarding loop detected'):
                pass
            else:
                raise AssertionError('Failed to detect forwarding loop')

    def test_ForwardRequestException(self):
        class TestForwardRequestExceptionMiddleware(Middleware):
            def __call__(self, environ, start_response):
                if environ['PATH_INFO'] != '/not_found':
                    return self.app(environ, start_response)
                raise ForwardRequestException(path_info=self.url)
        forward(TestForwardRequestExceptionMiddleware(error_docs_app))

########NEW FILE########
__FILENAME__ = test_static
from pecan.middleware.static import (StaticFileMiddleware, FileWrapper,
                                     _dump_date)
from pecan.tests import PecanTestCase

import os


class TestStaticFileMiddleware(PecanTestCase):

    def setUp(self):
        super(TestStaticFileMiddleware, self).setUp()

        def app(environ, start_response):
            response_headers = [('Content-type', 'text/plain')]
            start_response('200 OK', response_headers)
            return ['Hello world!\n']

        self.app = StaticFileMiddleware(
            app, os.path.dirname(__file__)
        )

        self._status = None
        self._response_headers = None

    def _request(self, path):
        def start_response(status, response_headers, exc_info=None):
            self._status = status
            self._response_headers = response_headers
        return self.app(
            dict(PATH_INFO=path),
            start_response
        )

    def _get_response_header(self, header):
        for k, v in self._response_headers:
            if k.upper() == header.upper():
                return v
        return None

    def test_file_can_be_found(self):
        result = self._request('/static_fixtures/text.txt')
        assert isinstance(result, FileWrapper)

    def test_no_file_found_causes_passthrough(self):
        result = self._request('/static_fixtures/nosuchfile.txt')
        assert not isinstance(result, FileWrapper)
        assert result == ['Hello world!\n']

    def test_mime_type_works_for_png_files(self):
        self._request('/static_fixtures/self.png')
        assert self._get_response_header('Content-Type') == 'image/png'

    def test_file_can_be_closed(self):
        result = self._request('/static_fixtures/text.txt')
        assert result.close() is None

    def test_file_can_be_iterated_over(self):
        result = self._request('/static_fixtures/text.txt')
        assert len([x for x in result])

    def test_date_dumping_on_unix_timestamps(self):
        result = _dump_date(1331755274.59, ' ')
        assert result == 'Wed, 14 Mar 2012 20:01:14 GMT'

    def test_separator_sanitization_still_finds_file(self):
        os.altsep = ':'
        result = self._request(':static_fixtures:text.txt')
        assert isinstance(result, FileWrapper)

########NEW FILE########
__FILENAME__ = scaffold_builder
import os
import sys
import subprocess
import time


if sys.version_info < (2, 7):
    import unittest2 as unittest
else:
    import unittest  # noqa

from six import b as b_

from pecan.compat import urlopen, URLError
from pecan.tests import PecanTestCase


if __name__ == '__main__':

    class TestTemplateBuilds(PecanTestCase):
        """
        Used to test the templated quickstart project(s).
        """

        @property
        def bin(self):
            return os.path.dirname(sys.executable)

        def poll(self, proc):
            limit = 30
            for i in range(limit):
                proc.poll()

                # Make sure it's running
                if proc.returncode is None:
                    break
                elif i == limit:  # pragma: no cover
                    raise RuntimeError("Server process didn't start.")
                time.sleep(.1)

        def test_project_pecan_serve_command(self):
            # Start the server
            proc = subprocess.Popen([
                os.path.join(self.bin, 'pecan'),
                'serve',
                'testing123/config.py'
            ])

            try:
                self.poll(proc)
                retries = 30
                while True:
                    retries -= 1
                    if retries < 0:  # pragma: nocover
                        raise RuntimeError(
                            "The HTTP server has not replied within 3 seconds."
                        )
                    try:
                        # ...and that it's serving (valid) content...
                        resp = urlopen('http://localhost:8080/')
                        assert resp.getcode()
                        assert len(resp.read().decode())
                    except URLError:
                        pass
                    else:
                        break
                    time.sleep(.1)
            finally:
                proc.terminate()

        def test_project_pecan_shell_command(self):
            # Start the server
            proc = subprocess.Popen([
                os.path.join(self.bin, 'pecan'),
                'shell',
                'testing123/config.py'
            ],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE
            )

            self.poll(proc)

            out, _ = proc.communicate(
                b_('{"model" : model, "conf" : conf, "app" : app}')
            )
            assert 'testing123.model' in out.decode(), out
            assert 'Config(' in out.decode(), out
            assert 'webtest.app.TestApp' in out.decode(), out

            try:
                # just in case stdin doesn't close
                proc.terminate()
            except:
                pass

    class TestThirdPartyServe(TestTemplateBuilds):

        def poll_http(self, name, proc, port):
            try:
                self.poll(proc)
                retries = 30
                while True:
                    retries -= 1
                    if retries < 0:  # pragma: nocover
                        raise RuntimeError(
                            "The %s server has not replied within"
                            " 3 seconds." % name
                        )
                    try:
                        # ...and that it's serving (valid) content...
                        resp = urlopen('http://localhost:%d/' % port)
                        assert resp.getcode()
                        assert len(resp.read().decode())
                    except URLError:
                        pass
                    else:
                        break
                    time.sleep(.1)
            finally:
                proc.terminate()

    class TestGunicornServeCommand(TestThirdPartyServe):

        def test_serve_from_config(self):
            # Start the server
            proc = subprocess.Popen([
                os.path.join(self.bin, 'gunicorn_pecan'),
                'testing123/config.py'
            ])

            self.poll_http('gunicorn', proc, 8080)

        def test_serve_with_custom_bind(self):
            # Start the server
            proc = subprocess.Popen([
                os.path.join(self.bin, 'gunicorn_pecan'),
                '--bind=0.0.0.0:9191',
                'testing123/config.py'
            ])

            self.poll_http('gunicorn', proc, 9191)

    class TestUWSGIServiceCommand(TestThirdPartyServe):

        def test_serve_from_config(self):
            # Start the server
            proc = subprocess.Popen([
                os.path.join(self.bin, 'uwsgi'),
                '--http-socket',
                ':8080',
                '--venv',
                sys.prefix,
                '--pecan',
                'testing123/config.py'
            ])

            self.poll_http('uwsgi', proc, 8080)

    # First, ensure that the `testing123` package has been installed
    args = [
        os.path.join(os.path.dirname(sys.executable), 'pip'),
        'install',
        '-U',
        '-e',
        './testing123'
    ]
    process = subprocess.Popen(args)
    _, unused_err = process.communicate()
    assert not process.poll()

    unittest.main()

########NEW FILE########
__FILENAME__ = test_base
import sys
import os
import json
import warnings
if sys.version_info < (2, 7):
    import unittest2 as unittest  # pragma: nocover
else:
    import unittest  # pragma: nocover

import webob
from webtest import TestApp
import six
from six import b as b_
from six.moves import cStringIO as StringIO

from pecan import (
    Pecan, expose, request, response, redirect, abort, make_app,
    override_template, render
)
from pecan.templating import (
    _builtin_renderers as builtin_renderers, error_formatters
)
from pecan.decorators import accept_noncanonical
from pecan.tests import PecanTestCase


class SampleRootController(object):
    pass


class TestAppRoot(PecanTestCase):

    def test_controller_lookup_by_string_path(self):
        app = Pecan('pecan.tests.test_base.SampleRootController')
        assert app.root and isinstance(app.root, SampleRootController)


class TestEmptyContent(PecanTestCase):
    @property
    def app_(self):
        class RootController(object):
            @expose()
            def index(self):
                pass

        return TestApp(Pecan(RootController()))

    def test_empty_index(self):
        r = self.app_.get('/')
        self.assertEqual(r.status_int, 204)
        self.assertNotIn('Content-Type', r.headers)
        self.assertEqual(r.headers['Content-Length'], '0')
        self.assertEqual(len(r.body), 0)


class TestIndexRouting(PecanTestCase):

    @property
    def app_(self):
        class RootController(object):
            @expose()
            def index(self):
                return 'Hello, World!'

        return TestApp(Pecan(RootController()))

    def test_empty_root(self):
        r = self.app_.get('/')
        assert r.status_int == 200
        assert r.body == b_('Hello, World!')

    def test_index(self):
        r = self.app_.get('/index')
        assert r.status_int == 200
        assert r.body == b_('Hello, World!')

    def test_index_html(self):
        r = self.app_.get('/index.html')
        assert r.status_int == 200
        assert r.body == b_('Hello, World!')


class TestObjectDispatch(PecanTestCase):

    @property
    def app_(self):
        class SubSubController(object):
            @expose()
            def index(self):
                return '/sub/sub/'

            @expose()
            def deeper(self):
                return '/sub/sub/deeper'

        class SubController(object):
            @expose()
            def index(self):
                return '/sub/'

            @expose()
            def deeper(self):
                return '/sub/deeper'

            sub = SubSubController()

        class RootController(object):
            @expose()
            def index(self):
                return '/'

            @expose()
            def deeper(self):
                return '/deeper'

            sub = SubController()

        return TestApp(Pecan(RootController()))

    def test_index(self):
        r = self.app_.get('/')
        assert r.status_int == 200
        assert r.body == b_('/')

    def test_one_level(self):
        r = self.app_.get('/deeper')
        assert r.status_int == 200
        assert r.body == b_('/deeper')

    def test_one_level_with_trailing(self):
        r = self.app_.get('/sub/')
        assert r.status_int == 200
        assert r.body == b_('/sub/')

    def test_two_levels(self):
        r = self.app_.get('/sub/deeper')
        assert r.status_int == 200
        assert r.body == b_('/sub/deeper')

    def test_two_levels_with_trailing(self):
        r = self.app_.get('/sub/sub/')
        assert r.status_int == 200

    def test_three_levels(self):
        r = self.app_.get('/sub/sub/deeper')
        assert r.status_int == 200
        assert r.body == b_('/sub/sub/deeper')


class TestLookups(PecanTestCase):

    @property
    def app_(self):
        class LookupController(object):
            def __init__(self, someID):
                self.someID = someID

            @expose()
            def index(self):
                return '/%s' % self.someID

            @expose()
            def name(self):
                return '/%s/name' % self.someID

        class RootController(object):
            @expose()
            def index(self):
                return '/'

            @expose()
            def _lookup(self, someID, *remainder):
                return LookupController(someID), remainder

        return TestApp(Pecan(RootController()))

    def test_index(self):
        r = self.app_.get('/')
        assert r.status_int == 200
        assert r.body == b_('/')

    def test_lookup(self):
        r = self.app_.get('/100/')
        assert r.status_int == 200
        assert r.body == b_('/100')

    def test_lookup_with_method(self):
        r = self.app_.get('/100/name')
        assert r.status_int == 200
        assert r.body == b_('/100/name')

    def test_lookup_with_wrong_argspec(self):
        class RootController(object):
            @expose()
            def _lookup(self, someID):
                return 'Bad arg spec'  # pragma: nocover

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            app = TestApp(Pecan(RootController()))
            r = app.get('/foo/bar', expect_errors=True)
            assert r.status_int == 404


class TestCanonicalLookups(PecanTestCase):

    @property
    def app_(self):
        class LookupController(object):
            def __init__(self, someID):
                self.someID = someID

            @expose()
            def index(self):
                return self.someID

        class UserController(object):
            @expose()
            def _lookup(self, someID, *remainder):
                return LookupController(someID), remainder

        class RootController(object):
            users = UserController()

        return TestApp(Pecan(RootController()))

    def test_canonical_lookup(self):
        assert self.app_.get('/users', expect_errors=404).status_int == 404
        assert self.app_.get('/users/', expect_errors=404).status_int == 404
        assert self.app_.get('/users/100').status_int == 302
        assert self.app_.get('/users/100/').body == b_('100')


class TestControllerArguments(PecanTestCase):

    @property
    def app_(self):
        class RootController(object):
            @expose()
            def index(self, id):
                return 'index: %s' % id

            @expose()
            def multiple(self, one, two):
                return 'multiple: %s, %s' % (one, two)

            @expose()
            def optional(self, id=None):
                return 'optional: %s' % str(id)

            @expose()
            def multiple_optional(self, one=None, two=None, three=None):
                return 'multiple_optional: %s, %s, %s' % (one, two, three)

            @expose()
            def variable_args(self, *args):
                return 'variable_args: %s' % ', '.join(args)

            @expose()
            def variable_kwargs(self, **kwargs):
                data = [
                    '%s=%s' % (key, kwargs[key])
                    for key in sorted(kwargs.keys())
                ]
                return 'variable_kwargs: %s' % ', '.join(data)

            @expose()
            def variable_all(self, *args, **kwargs):
                data = [
                    '%s=%s' % (key, kwargs[key])
                    for key in sorted(kwargs.keys())
                ]
                return 'variable_all: %s' % ', '.join(list(args) + data)

            @expose()
            def eater(self, id, dummy=None, *args, **kwargs):
                data = [
                    '%s=%s' % (key, kwargs[key])
                    for key in sorted(kwargs.keys())
                ]
                return 'eater: %s, %s, %s' % (
                    id,
                    dummy,
                    ', '.join(list(args) + data)
                )

            @expose()
            def _route(self, args):
                if hasattr(self, args[0]):
                    return getattr(self, args[0]), args[1:]
                else:
                    return self.index, args

        return TestApp(Pecan(RootController()))

    def test_required_argument(self):
        try:
            r = self.app_.get('/')
            assert r.status_int != 200  # pragma: nocover
        except Exception as ex:
            assert type(ex) == TypeError
            assert ex.args[0] in (
                "index() takes exactly 2 arguments (1 given)",
                "index() missing 1 required positional argument: 'id'"
            )  # this messaging changed in Python 3.3

    def test_single_argument(self):
        r = self.app_.get('/1')
        assert r.status_int == 200
        assert r.body == b_('index: 1')

    def test_single_argument_with_encoded_url(self):
        r = self.app_.get('/This%20is%20a%20test%21')
        assert r.status_int == 200
        assert r.body == b_('index: This is a test!')

    def test_two_arguments(self):
        r = self.app_.get('/1/dummy', status=404)
        assert r.status_int == 404

    def test_keyword_argument(self):
        r = self.app_.get('/?id=2')
        assert r.status_int == 200
        assert r.body == b_('index: 2')

    def test_keyword_argument_with_encoded_url(self):
        r = self.app_.get('/?id=This%20is%20a%20test%21')
        assert r.status_int == 200
        assert r.body == b_('index: This is a test!')

    def test_argument_and_keyword_argument(self):
        r = self.app_.get('/3?id=three')
        assert r.status_int == 200
        assert r.body == b_('index: 3')

    def test_encoded_argument_and_keyword_argument(self):
        r = self.app_.get('/This%20is%20a%20test%21?id=three')
        assert r.status_int == 200
        assert r.body == b_('index: This is a test!')

    def test_explicit_kwargs(self):
        r = self.app_.post('/', {'id': '4'})
        assert r.status_int == 200
        assert r.body == b_('index: 4')

    def test_path_with_explicit_kwargs(self):
        r = self.app_.post('/4', {'id': 'four'})
        assert r.status_int == 200
        assert r.body == b_('index: 4')

    def test_multiple_kwargs(self):
        r = self.app_.get('/?id=5&dummy=dummy')
        assert r.status_int == 200
        assert r.body == b_('index: 5')

    def test_kwargs_from_root(self):
        r = self.app_.post('/', {'id': '6', 'dummy': 'dummy'})
        assert r.status_int == 200
        assert r.body == b_('index: 6')

        # multiple args

    def test_multiple_positional_arguments(self):
        r = self.app_.get('/multiple/one/two')
        assert r.status_int == 200
        assert r.body == b_('multiple: one, two')

    def test_multiple_positional_arguments_with_url_encode(self):
        r = self.app_.get('/multiple/One%20/Two%21')
        assert r.status_int == 200
        assert r.body == b_('multiple: One , Two!')

    def test_multiple_positional_arguments_with_kwargs(self):
        r = self.app_.get('/multiple?one=three&two=four')
        assert r.status_int == 200
        assert r.body == b_('multiple: three, four')

    def test_multiple_positional_arguments_with_url_encoded_kwargs(self):
        r = self.app_.get('/multiple?one=Three%20&two=Four%20%21')
        assert r.status_int == 200
        assert r.body == b_('multiple: Three , Four !')

    def test_positional_args_with_dictionary_kwargs(self):
        r = self.app_.post('/multiple', {'one': 'five', 'two': 'six'})
        assert r.status_int == 200
        assert r.body == b_('multiple: five, six')

    def test_positional_args_with_url_encoded_dictionary_kwargs(self):
        r = self.app_.post('/multiple', {'one': 'Five%20', 'two': 'Six%20%21'})
        assert r.status_int == 200
        assert r.body == b_('multiple: Five%20, Six%20%21')

        # optional arg
    def test_optional_arg(self):
        r = self.app_.get('/optional')
        assert r.status_int == 200
        assert r.body == b_('optional: None')

    def test_multiple_optional(self):
        r = self.app_.get('/optional/1')
        assert r.status_int == 200
        assert r.body == b_('optional: 1')

    def test_multiple_optional_url_encoded(self):
        r = self.app_.get('/optional/Some%20Number')
        assert r.status_int == 200
        assert r.body == b_('optional: Some Number')

    def test_multiple_optional_missing(self):
        r = self.app_.get('/optional/2/dummy', status=404)
        assert r.status_int == 404

    def test_multiple_with_kwargs(self):
        r = self.app_.get('/optional?id=2')
        assert r.status_int == 200
        assert r.body == b_('optional: 2')

    def test_multiple_with_url_encoded_kwargs(self):
        r = self.app_.get('/optional?id=Some%20Number')
        assert r.status_int == 200
        assert r.body == b_('optional: Some Number')

    def test_multiple_args_with_url_encoded_kwargs(self):
        r = self.app_.get('/optional/3?id=three')
        assert r.status_int == 200
        assert r.body == b_('optional: 3')

    def test_url_encoded_positional_args(self):
        r = self.app_.get('/optional/Some%20Number?id=three')
        assert r.status_int == 200
        assert r.body == b_('optional: Some Number')

    def test_optional_arg_with_kwargs(self):
        r = self.app_.post('/optional', {'id': '4'})
        assert r.status_int == 200
        assert r.body == b_('optional: 4')

    def test_optional_arg_with_url_encoded_kwargs(self):
        r = self.app_.post('/optional', {'id': 'Some%20Number'})
        assert r.status_int == 200
        assert r.body == b_('optional: Some%20Number')

    def test_multiple_positional_arguments_with_dictionary_kwargs(self):
        r = self.app_.post('/optional/5', {'id': 'five'})
        assert r.status_int == 200
        assert r.body == b_('optional: 5')

    def test_multiple_positional_url_encoded_arguments_with_kwargs(self):
        r = self.app_.post('/optional/Some%20Number', {'id': 'five'})
        assert r.status_int == 200
        assert r.body == b_('optional: Some Number')

    def test_optional_arg_with_multiple_kwargs(self):
        r = self.app_.get('/optional?id=6&dummy=dummy')
        assert r.status_int == 200
        assert r.body == b_('optional: 6')

    def test_optional_arg_with_multiple_url_encoded_kwargs(self):
        r = self.app_.get('/optional?id=Some%20Number&dummy=dummy')
        assert r.status_int == 200
        assert r.body == b_('optional: Some Number')

    def test_optional_arg_with_multiple_dictionary_kwargs(self):
        r = self.app_.post('/optional', {'id': '7', 'dummy': 'dummy'})
        assert r.status_int == 200
        assert r.body == b_('optional: 7')

    def test_optional_arg_with_multiple_url_encoded_dictionary_kwargs(self):
        r = self.app_.post('/optional', {
            'id': 'Some%20Number',
            'dummy': 'dummy'
        })
        assert r.status_int == 200
        assert r.body == b_('optional: Some%20Number')

        # multiple optional args

    def test_multiple_optional_positional_args(self):
        r = self.app_.get('/multiple_optional')
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: None, None, None')

    def test_multiple_optional_positional_args_one_arg(self):
        r = self.app_.get('/multiple_optional/1')
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: 1, None, None')

    def test_multiple_optional_positional_args_one_url_encoded_arg(self):
        r = self.app_.get('/multiple_optional/One%21')
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: One!, None, None')

    def test_multiple_optional_positional_args_all_args(self):
        r = self.app_.get('/multiple_optional/1/2/3')
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: 1, 2, 3')

    def test_multiple_optional_positional_args_all_url_encoded_args(self):
        r = self.app_.get('/multiple_optional/One%21/Two%21/Three%21')
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: One!, Two!, Three!')

    def test_multiple_optional_positional_args_too_many_args(self):
        r = self.app_.get('/multiple_optional/1/2/3/dummy', status=404)
        assert r.status_int == 404

    def test_multiple_optional_positional_args_with_kwargs(self):
        r = self.app_.get('/multiple_optional?one=1')
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: 1, None, None')

    def test_multiple_optional_positional_args_with_url_encoded_kwargs(self):
        r = self.app_.get('/multiple_optional?one=One%21')
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: One!, None, None')

    def test_multiple_optional_positional_args_with_string_kwargs(self):
        r = self.app_.get('/multiple_optional/1?one=one')
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: 1, None, None')

    def test_multiple_optional_positional_args_with_encoded_str_kwargs(self):
        r = self.app_.get('/multiple_optional/One%21?one=one')
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: One!, None, None')

    def test_multiple_optional_positional_args_with_dict_kwargs(self):
        r = self.app_.post('/multiple_optional', {'one': '1'})
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: 1, None, None')

    def test_multiple_optional_positional_args_with_encoded_dict_kwargs(self):
        r = self.app_.post('/multiple_optional', {'one': 'One%21'})
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: One%21, None, None')

    def test_multiple_optional_positional_args_and_dict_kwargs(self):
        r = self.app_.post('/multiple_optional/1', {'one': 'one'})
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: 1, None, None')

    def test_multiple_optional_encoded_positional_args_and_dict_kwargs(self):
        r = self.app_.post('/multiple_optional/One%21', {'one': 'one'})
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: One!, None, None')

    def test_multiple_optional_args_with_multiple_kwargs(self):
        r = self.app_.get('/multiple_optional?one=1&two=2&three=3&four=4')
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: 1, 2, 3')

    def test_multiple_optional_args_with_multiple_encoded_kwargs(self):
        r = self.app_.get(
            '/multiple_optional?one=One%21&two=Two%21&three=Three%21&four=4'
        )
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: One!, Two!, Three!')

    def test_multiple_optional_args_with_multiple_dict_kwargs(self):
        r = self.app_.post(
            '/multiple_optional',
            {'one': '1', 'two': '2', 'three': '3', 'four': '4'}
        )
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: 1, 2, 3')

    def test_multiple_optional_args_with_multiple_encoded_dict_kwargs(self):
        r = self.app_.post(
            '/multiple_optional',
            {
                'one': 'One%21',
                'two': 'Two%21',
                'three': 'Three%21',
                'four': '4'
            }
        )
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: One%21, Two%21, Three%21')

    def test_multiple_optional_args_with_last_kwarg(self):
        r = self.app_.get('/multiple_optional?three=3')
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: None, None, 3')

    def test_multiple_optional_args_with_last_encoded_kwarg(self):
        r = self.app_.get('/multiple_optional?three=Three%21')
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: None, None, Three!')

    def test_multiple_optional_args_with_middle_arg(self):
        r = self.app_.get('/multiple_optional', {'two': '2'})
        assert r.status_int == 200
        assert r.body == b_('multiple_optional: None, 2, None')

    def test_variable_args(self):
        r = self.app_.get('/variable_args')
        assert r.status_int == 200
        assert r.body == b_('variable_args: ')

    def test_multiple_variable_args(self):
        r = self.app_.get('/variable_args/1/dummy')
        assert r.status_int == 200
        assert r.body == b_('variable_args: 1, dummy')

    def test_multiple_encoded_variable_args(self):
        r = self.app_.get('/variable_args/Testing%20One%20Two/Three%21')
        assert r.status_int == 200
        assert r.body == b_('variable_args: Testing One Two, Three!')

    def test_variable_args_with_kwargs(self):
        r = self.app_.get('/variable_args?id=2&dummy=dummy')
        assert r.status_int == 200
        assert r.body == b_('variable_args: ')

    def test_variable_args_with_dict_kwargs(self):
        r = self.app_.post('/variable_args', {'id': '3', 'dummy': 'dummy'})
        assert r.status_int == 200
        assert r.body == b_('variable_args: ')

    def test_variable_kwargs(self):
        r = self.app_.get('/variable_kwargs')
        assert r.status_int == 200
        assert r.body == b_('variable_kwargs: ')

    def test_multiple_variable_kwargs(self):
        r = self.app_.get('/variable_kwargs/1/dummy', status=404)
        assert r.status_int == 404

    def test_multiple_variable_kwargs_with_explicit_kwargs(self):
        r = self.app_.get('/variable_kwargs?id=2&dummy=dummy')
        assert r.status_int == 200
        assert r.body == b_('variable_kwargs: dummy=dummy, id=2')

    def test_multiple_variable_kwargs_with_explicit_encoded_kwargs(self):
        r = self.app_.get(
            '/variable_kwargs?id=Two%21&dummy=This%20is%20a%20test'
        )
        assert r.status_int == 200
        assert r.body == b_('variable_kwargs: dummy=This is a test, id=Two!')

    def test_multiple_variable_kwargs_with_dict_kwargs(self):
        r = self.app_.post('/variable_kwargs', {'id': '3', 'dummy': 'dummy'})
        assert r.status_int == 200
        assert r.body == b_('variable_kwargs: dummy=dummy, id=3')

    def test_multiple_variable_kwargs_with_encoded_dict_kwargs(self):
        r = self.app_.post(
            '/variable_kwargs',
            {'id': 'Three%21', 'dummy': 'This%20is%20a%20test'}
        )
        assert r.status_int == 200
        result = 'variable_kwargs: dummy=This%20is%20a%20test, id=Three%21'
        assert r.body == b_(result)

    def test_variable_all(self):
        r = self.app_.get('/variable_all')
        assert r.status_int == 200
        assert r.body == b_('variable_all: ')

    def test_variable_all_with_one_extra(self):
        r = self.app_.get('/variable_all/1')
        assert r.status_int == 200
        assert r.body == b_('variable_all: 1')

    def test_variable_all_with_two_extras(self):
        r = self.app_.get('/variable_all/2/dummy')
        assert r.status_int == 200
        assert r.body == b_('variable_all: 2, dummy')

    def test_variable_mixed(self):
        r = self.app_.get('/variable_all/3?month=1&day=12')
        assert r.status_int == 200
        assert r.body == b_('variable_all: 3, day=12, month=1')

    def test_variable_mixed_explicit(self):
        r = self.app_.get('/variable_all/4?id=four&month=1&day=12')
        assert r.status_int == 200
        assert r.body == b_('variable_all: 4, day=12, id=four, month=1')

    def test_variable_post(self):
        r = self.app_.post('/variable_all/5/dummy')
        assert r.status_int == 200
        assert r.body == b_('variable_all: 5, dummy')

    def test_variable_post_with_kwargs(self):
        r = self.app_.post('/variable_all/6', {'month': '1', 'day': '12'})
        assert r.status_int == 200
        assert r.body == b_('variable_all: 6, day=12, month=1')

    def test_variable_post_mixed(self):
        r = self.app_.post(
            '/variable_all/7',
            {'id': 'seven', 'month': '1', 'day': '12'}
        )
        assert r.status_int == 200
        assert r.body == b_('variable_all: 7, day=12, id=seven, month=1')

    def test_no_remainder(self):
        try:
            r = self.app_.get('/eater')
            assert r.status_int != 200  # pragma: nocover
        except Exception as ex:
            assert type(ex) == TypeError
            assert ex.args[0] in (
                "eater() takes at least 2 arguments (1 given)",
                "eater() missing 1 required positional argument: 'id'"
            )  # this messaging changed in Python 3.3

    def test_one_remainder(self):
        r = self.app_.get('/eater/1')
        assert r.status_int == 200
        assert r.body == b_('eater: 1, None, ')

    def test_two_remainders(self):
        r = self.app_.get('/eater/2/dummy')
        assert r.status_int == 200
        assert r.body == b_('eater: 2, dummy, ')

    def test_many_remainders(self):
        r = self.app_.get('/eater/3/dummy/foo/bar')
        assert r.status_int == 200
        assert r.body == b_('eater: 3, dummy, foo, bar')

    def test_remainder_with_kwargs(self):
        r = self.app_.get('/eater/4?month=1&day=12')
        assert r.status_int == 200
        assert r.body == b_('eater: 4, None, day=12, month=1')

    def test_remainder_with_many_kwargs(self):
        r = self.app_.get('/eater/5?id=five&month=1&day=12&dummy=dummy')
        assert r.status_int == 200
        assert r.body == b_('eater: 5, dummy, day=12, month=1')

    def test_post_remainder(self):
        r = self.app_.post('/eater/6')
        assert r.status_int == 200
        assert r.body == b_('eater: 6, None, ')

    def test_post_three_remainders(self):
        r = self.app_.post('/eater/7/dummy')
        assert r.status_int == 200
        assert r.body == b_('eater: 7, dummy, ')

    def test_post_many_remainders(self):
        r = self.app_.post('/eater/8/dummy/foo/bar')
        assert r.status_int == 200
        assert r.body == b_('eater: 8, dummy, foo, bar')

    def test_post_remainder_with_kwargs(self):
        r = self.app_.post('/eater/9', {'month': '1', 'day': '12'})
        assert r.status_int == 200
        assert r.body == b_('eater: 9, None, day=12, month=1')

    def test_post_many_remainders_with_many_kwargs(self):
        r = self.app_.post(
            '/eater/10',
            {'id': 'ten', 'month': '1', 'day': '12', 'dummy': 'dummy'}
        )
        assert r.status_int == 200
        assert r.body == b_('eater: 10, dummy, day=12, month=1')


class TestAbort(PecanTestCase):

    def test_abort(self):
        class RootController(object):
            @expose()
            def index(self):
                abort(404)

        app = TestApp(Pecan(RootController()))
        r = app.get('/', status=404)
        assert r.status_int == 404

    def test_abort_with_detail(self):
        class RootController(object):
            @expose()
            def index(self):
                abort(status_code=401, detail='Not Authorized')

        app = TestApp(Pecan(RootController()))
        r = app.get('/', status=401)
        assert r.status_int == 401


class TestScriptName(PecanTestCase):

    def setUp(self):
        super(TestScriptName, self).setUp()
        self.environ = {'SCRIPT_NAME': '/foo'}

    def test_handle_script_name(self):
        class RootController(object):
            @expose()
            def index(self):
                return 'Root Index'

        app = TestApp(Pecan(RootController()), extra_environ=self.environ)
        r = app.get('/foo/')
        assert r.status_int == 200


class TestRedirect(PecanTestCase):

    @property
    def app_(self):
        class RootController(object):
            @expose()
            def index(self):
                redirect('/testing')

            @expose()
            def internal(self):
                redirect('/testing', internal=True)

            @expose()
            def bad_internal(self):
                redirect('/testing', internal=True, code=301)

            @expose()
            def permanent(self):
                redirect('/testing', code=301)

            @expose()
            def testing(self):
                return 'it worked!'

        return TestApp(make_app(RootController(), debug=False))

    def test_index(self):
        r = self.app_.get('/')
        assert r.status_int == 302
        r = r.follow()
        assert r.status_int == 200
        assert r.body == b_('it worked!')

    def test_internal(self):
        r = self.app_.get('/internal')
        assert r.status_int == 200
        assert r.body == b_('it worked!')

    def test_internal_with_301(self):
        self.assertRaises(ValueError, self.app_.get, '/bad_internal')

    def test_permanent_redirect(self):
        r = self.app_.get('/permanent')
        assert r.status_int == 301
        r = r.follow()
        assert r.status_int == 200
        assert r.body == b_('it worked!')

    def test_x_forward_proto(self):
        class ChildController(object):
            @expose()
            def index(self):
                redirect('/testing')  # pragma: nocover

        class RootController(object):
            @expose()
            def index(self):
                redirect('/testing')  # pragma: nocover

            @expose()
            def testing(self):
                return 'it worked!'  # pragma: nocover
            child = ChildController()

        app = TestApp(make_app(RootController(), debug=True))
        res = app.get(
            '/child', extra_environ=dict(HTTP_X_FORWARDED_PROTO='https')
        )
        # non-canonical url will redirect, so we won't get a 301
        assert res.status_int == 302
        # should add trailing / and changes location to https
        assert res.location == 'https://localhost/child/'
        assert res.request.environ['HTTP_X_FORWARDED_PROTO'] == 'https'


class TestInternalRedirectContext(PecanTestCase):

    @property
    def app_(self):
        class RootController(object):

            @expose()
            def redirect_with_context(self):
                request.context['foo'] = 'bar'
                redirect('/testing')

            @expose()
            def internal_with_context(self):
                request.context['foo'] = 'bar'
                redirect('/testing', internal=True)

            @expose('json')
            def testing(self):
                return request.context

        return TestApp(make_app(RootController(), debug=False))

    def test_internal_with_request_context(self):
        r = self.app_.get('/internal_with_context')
        assert r.status_int == 200
        assert json.loads(r.body.decode()) == {'foo': 'bar'}

    def test_context_does_not_bleed(self):
        r = self.app_.get('/redirect_with_context').follow()
        assert r.status_int == 200
        assert json.loads(r.body.decode()) == {}


class TestStreamedResponse(PecanTestCase):

    def test_streaming_response(self):

        class RootController(object):
            @expose(content_type='text/plain')
            def test(self, foo):
                if foo == 'stream':
                    # mimic large file
                    contents = six.BytesIO(b_('stream'))
                    response.content_type = 'application/octet-stream'
                    contents.seek(0, os.SEEK_END)
                    response.content_length = contents.tell()
                    contents.seek(0, os.SEEK_SET)
                    response.app_iter = contents
                    return response
                else:
                    return 'plain text'

        app = TestApp(Pecan(RootController()))
        r = app.get('/test/stream')
        assert r.content_type == 'application/octet-stream'
        assert r.body == b_('stream')

        r = app.get('/test/plain')
        assert r.content_type == 'text/plain'
        assert r.body == b_('plain text')


class TestManualResponse(PecanTestCase):

    def test_manual_response(self):

        class RootController(object):
            @expose()
            def index(self):
                resp = webob.Response(response.environ)
                resp.body = b_('Hello, World!')
                return resp

        app = TestApp(Pecan(RootController()))
        r = app.get('/')
        assert r.body == b_('Hello, World!')


class TestThreadLocalState(PecanTestCase):

    def test_thread_local_dir(self):
        """
        Threadlocal proxies for request and response should properly
        proxy ``dir()`` calls to the underlying webob class.
        """
        class RootController(object):
            @expose()
            def index(self):
                assert 'method' in dir(request)
                assert 'status' in dir(response)
                return '/'

        app = TestApp(Pecan(RootController()))
        r = app.get('/')
        assert r.status_int == 200
        assert r.body == b_('/')

    def test_request_state_cleanup(self):
        """
        After a request, the state local() should be totally clean
        except for state.app (so that objects don't leak between requests)
        """
        from pecan.core import state

        class RootController(object):
            @expose()
            def index(self):
                return '/'

        app = TestApp(Pecan(RootController()))
        r = app.get('/')
        assert r.status_int == 200
        assert r.body == b_('/')

        assert state.__dict__ == {}


class TestFileTypeExtensions(PecanTestCase):

    @property
    def app_(self):
        """
        Test extension splits
        """
        class RootController(object):
            @expose(content_type=None)
            def _default(self, *args):
                ext = request.pecan['extension']
                assert len(args) == 1
                if ext:
                    assert ext not in args[0]
                return ext or ''

        return TestApp(Pecan(RootController()))

    def test_html_extension(self):
        r = self.app_.get('/index.html')
        assert r.status_int == 200
        assert r.body == b_('.html')

    def test_image_extension(self):
        r = self.app_.get('/image.png')
        assert r.status_int == 200
        assert r.body == b_('.png')

    def test_hidden_file(self):
        r = self.app_.get('/.vimrc')
        assert r.status_int == 204
        assert r.body == b_('')

    def test_multi_dot_extension(self):
        r = self.app_.get('/gradient.min.js')
        assert r.status_int == 200
        assert r.body == b_('.js')

    def test_bad_content_type(self):
        class RootController(object):
            @expose()
            def index(self):
                return '/'

        app = TestApp(Pecan(RootController()))
        r = app.get('/')
        assert r.status_int == 200
        assert r.body == b_('/')

        r = app.get('/index.html', expect_errors=True)
        assert r.status_int == 200
        assert r.body == b_('/')

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            r = app.get('/index.txt', expect_errors=True)
            assert r.status_int == 404

    def test_unknown_file_extension(self):
        class RootController(object):
            @expose(content_type=None)
            def _default(self, *args):
                assert 'example:x.tiny' in args
                assert request.pecan['extension'] is None
                return 'SOME VALUE'

        app = TestApp(Pecan(RootController()))

        r = app.get('/example:x.tiny')
        assert r.status_int == 200
        assert r.body == b_('SOME VALUE')

    def test_guessing_disabled(self):
        class RootController(object):
            @expose(content_type=None)
            def _default(self, *args):
                assert 'index.html' in args
                assert request.pecan['extension'] is None
                return 'SOME VALUE'

        app = TestApp(Pecan(RootController(),
                            guess_content_type_from_ext=False))

        r = app.get('/index.html')
        assert r.status_int == 200
        assert r.body == b_('SOME VALUE')


class TestContentTypeByAcceptHeaders(PecanTestCase):

    @property
    def app_(self):
        """
        Test that content type is set appropriately based on Accept headers.
        """
        class RootController(object):

            @expose(content_type='text/html')
            @expose(content_type='application/json')
            def index(self, *args):
                return 'Foo'

        return TestApp(Pecan(RootController()))

    def test_quality(self):
        r = self.app_.get('/', headers={
            'Accept': 'text/html,application/json;q=0.9,*/*;q=0.8'
        })
        assert r.status_int == 200
        assert r.content_type == 'text/html'

        r = self.app_.get('/', headers={
            'Accept': 'application/json,text/html;q=0.9,*/*;q=0.8'
        })
        assert r.status_int == 200
        assert r.content_type == 'application/json'

    def test_file_extension_has_higher_precedence(self):
        r = self.app_.get('/index.html', headers={
            'Accept': 'application/json,text/html;q=0.9,*/*;q=0.8'
        })
        assert r.status_int == 200
        assert r.content_type == 'text/html'

    def test_not_acceptable(self):
        r = self.app_.get('/', headers={
            'Accept': 'application/xml',
        }, status=406)
        assert r.status_int == 406

    def test_accept_header_missing(self):
        r = self.app_.get('/')
        assert r.status_int == 200
        assert r.content_type == 'text/html'


class TestCanonicalRouting(PecanTestCase):

    @property
    def app_(self):
        class ArgSubController(object):
            @expose()
            def index(self, arg):
                return arg

        class AcceptController(object):
            @accept_noncanonical
            @expose()
            def index(self):
                return 'accept'

        class SubController(object):
            @expose()
            def index(self, **kw):
                return 'subindex'

        class RootController(object):
            @expose()
            def index(self):
                return 'index'

            sub = SubController()
            arg = ArgSubController()
            accept = AcceptController()

        return TestApp(Pecan(RootController()))

    def test_root(self):
        r = self.app_.get('/')
        assert r.status_int == 200
        assert b_('index') in r.body

    def test_index(self):
        r = self.app_.get('/index')
        assert r.status_int == 200
        assert b_('index') in r.body

    def test_broken_clients(self):
        # for broken clients
        r = self.app_.get('', status=302)
        assert r.status_int == 302
        assert r.location == 'http://localhost/'

    def test_sub_controller_with_trailing(self):
        r = self.app_.get('/sub/')
        assert r.status_int == 200
        assert b_('subindex') in r.body

    def test_sub_controller_redirect(self):
        r = self.app_.get('/sub', status=302)
        assert r.status_int == 302
        assert r.location == 'http://localhost/sub/'

    def test_with_query_string(self):
        # try with query string
        r = self.app_.get('/sub?foo=bar', status=302)
        assert r.status_int == 302
        assert r.location == 'http://localhost/sub/?foo=bar'

    def test_posts_fail(self):
        try:
            self.app_.post('/sub', dict(foo=1))
            raise Exception("Post should fail")  # pragma: nocover
        except Exception as e:
            assert isinstance(e, RuntimeError)

    def test_with_args(self):
        r = self.app_.get('/arg/index/foo')
        assert r.status_int == 200
        assert r.body == b_('foo')

    def test_accept_noncanonical(self):
        r = self.app_.get('/accept/')
        assert r.status_int == 200
        assert r.body == b_('accept')

    def test_accept_noncanonical_no_trailing_slash(self):
        r = self.app_.get('/accept')
        assert r.status_int == 200
        assert r.body == b_('accept')


class TestNonCanonical(PecanTestCase):

    @property
    def app_(self):
        class ArgSubController(object):
            @expose()
            def index(self, arg):
                return arg  # pragma: nocover

        class AcceptController(object):
            @accept_noncanonical
            @expose()
            def index(self):
                return 'accept'  # pragma: nocover

        class SubController(object):
            @expose()
            def index(self, **kw):
                return 'subindex'

        class RootController(object):
            @expose()
            def index(self):
                return 'index'

            sub = SubController()
            arg = ArgSubController()
            accept = AcceptController()

        return TestApp(Pecan(RootController(), force_canonical=False))

    def test_index(self):
        r = self.app_.get('/')
        assert r.status_int == 200
        assert b_('index') in r.body

    def test_subcontroller(self):
        r = self.app_.get('/sub')
        assert r.status_int == 200
        assert b_('subindex') in r.body

    def test_subcontroller_with_kwargs(self):
        r = self.app_.post('/sub', dict(foo=1))
        assert r.status_int == 200
        assert b_('subindex') in r.body

    def test_sub_controller_with_trailing(self):
        r = self.app_.get('/sub/')
        assert r.status_int == 200
        assert b_('subindex') in r.body

    def test_proxy(self):
        class RootController(object):
            @expose()
            def index(self):
                request.testing = True
                assert request.testing is True
                del request.testing
                assert hasattr(request, 'testing') is False
                return '/'

        app = TestApp(make_app(RootController(), debug=True))
        r = app.get('/')
        assert r.status_int == 200

    def test_app_wrap(self):
        class RootController(object):
            pass

        wrapped_apps = []

        def wrap(app):
            wrapped_apps.append(app)
            return app

        make_app(RootController(), wrap_app=wrap, debug=True)
        assert len(wrapped_apps) == 1


class TestLogging(PecanTestCase):

    def test_logging_setup(self):
        class RootController(object):
            @expose()
            def index(self):
                import logging
                logging.getLogger('pecantesting').info('HELLO WORLD')
                return "HELLO WORLD"

        f = StringIO()

        app = TestApp(make_app(RootController(), logging={
            'loggers': {
                'pecantesting': {
                    'level': 'INFO', 'handlers': ['memory']
                }
            },
            'handlers': {
                'memory': {
                    'level': 'INFO',
                    'class': 'logging.StreamHandler',
                    'stream': f
                }
            }
        }))

        app.get('/')
        assert f.getvalue() == 'HELLO WORLD\n'

    def test_logging_setup_with_config_obj(self):
        class RootController(object):
            @expose()
            def index(self):
                import logging
                logging.getLogger('pecantesting').info('HELLO WORLD')
                return "HELLO WORLD"

        f = StringIO()

        from pecan.configuration import conf_from_dict
        app = TestApp(make_app(RootController(), logging=conf_from_dict({
            'loggers': {
                'pecantesting': {
                    'level': 'INFO', 'handlers': ['memory']
                }
            },
            'handlers': {
                'memory': {
                    'level': 'INFO',
                    'class': 'logging.StreamHandler',
                    'stream': f
                }
            }
        })))

        app.get('/')
        assert f.getvalue() == 'HELLO WORLD\n'


class TestEngines(PecanTestCase):

    template_path = os.path.join(os.path.dirname(__file__), 'templates')

    @unittest.skipIf('genshi' not in builtin_renderers, 'Genshi not installed')
    def test_genshi(self):

        class RootController(object):
            @expose('genshi:genshi.html')
            def index(self, name='Jonathan'):
                return dict(name=name)

            @expose('genshi:genshi_bad.html')
            def badtemplate(self):
                return dict()

        app = TestApp(
            Pecan(RootController(), template_path=self.template_path)
        )
        r = app.get('/')
        assert r.status_int == 200
        assert b_("<h1>Hello, Jonathan!</h1>") in r.body

        r = app.get('/index.html?name=World')
        assert r.status_int == 200
        assert b_("<h1>Hello, World!</h1>") in r.body

        error_msg = None
        try:
            r = app.get('/badtemplate.html')
        except Exception as e:
            for error_f in error_formatters:
                error_msg = error_f(e)
                if error_msg:
                    break
        assert error_msg is not None

    @unittest.skipIf('kajiki' not in builtin_renderers, 'Kajiki not installed')
    def test_kajiki(self):

        class RootController(object):
            @expose('kajiki:kajiki.html')
            def index(self, name='Jonathan'):
                return dict(name=name)

        app = TestApp(
            Pecan(RootController(), template_path=self.template_path)
        )
        r = app.get('/')
        assert r.status_int == 200
        assert b_("<h1>Hello, Jonathan!</h1>") in r.body

        r = app.get('/index.html?name=World')
        assert r.status_int == 200
        assert b_("<h1>Hello, World!</h1>") in r.body

    @unittest.skipIf('jinja' not in builtin_renderers, 'Jinja not installed')
    def test_jinja(self):

        class RootController(object):
            @expose('jinja:jinja.html')
            def index(self, name='Jonathan'):
                return dict(name=name)

            @expose('jinja:jinja_bad.html')
            def badtemplate(self):
                return dict()

        app = TestApp(
            Pecan(RootController(), template_path=self.template_path)
        )
        r = app.get('/')
        assert r.status_int == 200
        assert b_("<h1>Hello, Jonathan!</h1>") in r.body

        error_msg = None
        try:
            r = app.get('/badtemplate.html')
        except Exception as e:
            for error_f in error_formatters:
                error_msg = error_f(e)
                if error_msg:
                    break
        assert error_msg is not None

    @unittest.skipIf('mako' not in builtin_renderers, 'Mako not installed')
    def test_mako(self):

        class RootController(object):
            @expose('mako:mako.html')
            def index(self, name='Jonathan'):
                return dict(name=name)

            @expose('mako:mako_bad.html')
            def badtemplate(self):
                return dict()

        app = TestApp(
            Pecan(RootController(), template_path=self.template_path)
        )
        r = app.get('/')
        assert r.status_int == 200
        assert b_("<h1>Hello, Jonathan!</h1>") in r.body

        r = app.get('/index.html?name=World')
        assert r.status_int == 200
        assert b_("<h1>Hello, World!</h1>") in r.body

        error_msg = None
        try:
            r = app.get('/badtemplate.html')
        except Exception as e:
            for error_f in error_formatters:
                error_msg = error_f(e)
                if error_msg:
                    break
        assert error_msg is not None

    def test_json(self):
        try:
            from simplejson import loads
        except:
            from json import loads  # noqa

        expected_result = dict(
            name='Jonathan',
            age=30, nested=dict(works=True)
        )

        class RootController(object):
            @expose('json')
            def index(self):
                return expected_result

        app = TestApp(Pecan(RootController()))
        r = app.get('/')
        assert r.status_int == 200
        result = dict(loads(r.body.decode()))
        assert result == expected_result

    def test_override_template(self):
        class RootController(object):
            @expose('foo.html')
            def index(self):
                override_template(None, content_type='text/plain')
                return 'Override'

        app = TestApp(Pecan(RootController()))
        r = app.get('/')
        assert r.status_int == 200
        assert b_('Override') in r.body
        assert r.content_type == 'text/plain'

    def test_render(self):
        class RootController(object):
            @expose()
            def index(self, name='Jonathan'):
                return render('mako.html', dict(name=name))

        app = TestApp(
            Pecan(RootController(), template_path=self.template_path)
        )
        r = app.get('/')
        assert r.status_int == 200
        assert b_("<h1>Hello, Jonathan!</h1>") in r.body

########NEW FILE########
__FILENAME__ = test_commands
from pecan.tests import PecanTestCase


class TestCommandManager(PecanTestCase):

    def test_commands(self):
        from pecan.commands import ServeCommand, ShellCommand, CreateCommand
        from pecan.commands.base import CommandManager
        m = CommandManager()
        assert m.commands['serve'] == ServeCommand
        assert m.commands['shell'] == ShellCommand
        assert m.commands['create'] == CreateCommand


class TestCommandRunner(PecanTestCase):

    def test_commands(self):
        from pecan.commands import (
            ServeCommand, ShellCommand, CreateCommand, CommandRunner
        )
        runner = CommandRunner()
        assert runner.commands['serve'] == ServeCommand
        assert runner.commands['shell'] == ShellCommand
        assert runner.commands['create'] == CreateCommand

    def test_run(self):
        from pecan.commands import CommandRunner
        runner = CommandRunner()
        self.assertRaises(
            RuntimeError,
            runner.run,
            ['serve', 'missing_file.py']
        )


class TestCreateCommand(PecanTestCase):

    def test_run(self):
        from pecan.commands import CreateCommand

        class FakeArg(object):
            project_name = 'default'
            template_name = 'default'

        class FakeScaffold(object):
            def copy_to(self, project_name):
                assert project_name == 'default'

        class FakeManager(object):
            scaffolds = {
                'default': FakeScaffold
            }

        c = CreateCommand()
        c.manager = FakeManager()
        c.run(FakeArg())

########NEW FILE########
__FILENAME__ = test_conf
import os
import sys
import tempfile

from pecan.tests import PecanTestCase
from six import b as b_


__here__ = os.path.dirname(__file__)


class TestConf(PecanTestCase):

    def test_update_config_fail_identifier(self):
        """Fail when naming does not pass correctness"""
        from pecan import configuration
        bad_dict = {'bad name': 'value'}
        self.assertRaises(ValueError, configuration.Config, bad_dict)

    def test_update_set_config(self):
        """Update an empty configuration with the default values"""
        from pecan import configuration

        conf = configuration.initconf()
        conf.update(configuration.conf_from_file(os.path.join(
            __here__,
            'config_fixtures/config.py'
        )))

        self.assertEqual(conf.app.root, None)
        self.assertEqual(conf.app.template_path, 'myproject/templates')
        self.assertEqual(conf.app.static_root, 'public')

        self.assertEqual(conf.server.host, '1.1.1.1')
        self.assertEqual(conf.server.port, '8081')

    def test_update_set_default_config(self):
        """Update an empty configuration with the default values"""
        from pecan import configuration

        conf = configuration.initconf()
        conf.update(configuration.conf_from_file(os.path.join(
            __here__,
            'config_fixtures/empty.py'
        )))

        self.assertEqual(conf.app.root, None)
        self.assertEqual(conf.app.template_path, '')
        self.assertEqual(conf.app.static_root, 'public')

        self.assertEqual(conf.server.host, '0.0.0.0')
        self.assertEqual(conf.server.port, '8080')

    def test_update_force_dict(self):
        """Update an empty configuration with the default values"""
        from pecan import configuration
        conf = configuration.initconf()
        conf.update(configuration.conf_from_file(os.path.join(
            __here__,
            'config_fixtures/forcedict.py'
        )))

        self.assertEqual(conf.app.root, None)
        self.assertEqual(conf.app.template_path, '')
        self.assertEqual(conf.app.static_root, 'public')

        self.assertEqual(conf.server.host, '0.0.0.0')
        self.assertEqual(conf.server.port, '8080')

        self.assertTrue(isinstance(conf.beaker, dict))
        self.assertEqual(conf.beaker['session.key'], 'key')
        self.assertEqual(conf.beaker['session.type'], 'cookie')
        self.assertEqual(
            conf.beaker['session.validate_key'],
            '1a971a7df182df3e1dec0af7c6913ec7'
        )
        self.assertEqual(conf.beaker.get('__force_dict__'), None)

    def test_update_config_with_dict(self):
        from pecan import configuration
        conf = configuration.initconf()
        d = {'attr': True}
        conf['attr'] = d
        self.assertTrue(conf.attr.attr)

    def test_config_repr(self):
        from pecan import configuration
        conf = configuration.Config({'a': 1})
        self.assertEqual(repr(conf), "Config({'a': 1})")

    def test_config_from_dict(self):
        from pecan import configuration
        conf = configuration.conf_from_dict({})
        conf['path'] = '%(confdir)s'
        self.assertTrue(os.path.samefile(conf['path'], os.getcwd()))

    def test_config_from_file(self):
        from pecan import configuration
        path = os.path.join(
            os.path.dirname(__file__), 'config_fixtures', 'config.py'
        )
        configuration.conf_from_file(path)

    def test_config_illegal_ids(self):
        from pecan import configuration
        conf = configuration.Config({})
        conf.update(configuration.conf_from_file(os.path.join(
            __here__,
            'config_fixtures/bad/module_and_underscore.py'
        )))
        self.assertEqual([], list(conf))

    def test_config_missing_file(self):
        from pecan import configuration
        path = ('doesnotexist.py',)
        configuration.Config({})
        self.assertRaises(
            RuntimeError,
            configuration.conf_from_file,
            os.path.join(__here__, 'config_fixtures', *path)
        )

    def test_config_missing_file_on_path(self):
        from pecan import configuration
        path = ('bad', 'bad', 'doesnotexist.py',)
        configuration.Config({})

        self.assertRaises(
            RuntimeError,
            configuration.conf_from_file,
            os.path.join(__here__, 'config_fixtures', *path)
        )

    def test_config_with_syntax_error(self):
        from pecan import configuration
        with tempfile.NamedTemporaryFile('wb') as f:
            f.write(b_('\n'.join(['if false', 'var = 3'])))
            f.flush()
            configuration.Config({})

            self.assertRaises(
                SyntaxError,
                configuration.conf_from_file,
                f.name
            )

    def test_config_with_bad_import(self):
        from pecan import configuration
        path = ('bad', 'importerror.py')
        configuration.Config({})

        self.assertRaises(
            ImportError,
            configuration.conf_from_file,
            os.path.join(
                __here__,
                'config_fixtures',
                *path
            )
        )

    def test_config_dir(self):
        from pecan import configuration
        if sys.version_info >= (2, 6):
            conf = configuration.Config({})
            self.assertEqual([], dir(conf))
            conf = configuration.Config({'a': 1})
            self.assertEqual(['a'], dir(conf))

    def test_config_bad_key(self):
        from pecan import configuration
        conf = configuration.Config({'a': 1})
        assert conf.a == 1
        self.assertRaises(AttributeError, getattr, conf, 'b')

    def test_config_get_valid_key(self):
        from pecan import configuration
        conf = configuration.Config({'a': 1})
        assert conf.get('a') == 1

    def test_config_get_invalid_key(self):
        from pecan import configuration
        conf = configuration.Config({'a': 1})
        assert conf.get('b') is None

    def test_config_get_invalid_key_return_default(self):
        from pecan import configuration
        conf = configuration.Config({'a': 1})
        assert conf.get('b', True) is True

    def test_config_to_dict(self):
        from pecan import configuration
        conf = configuration.initconf()

        assert isinstance(conf, configuration.Config)

        to_dict = conf.to_dict()

        assert isinstance(to_dict, dict)
        assert to_dict['server']['host'] == '0.0.0.0'
        assert to_dict['server']['port'] == '8080'
        assert to_dict['app']['modules'] == []
        assert to_dict['app']['root'] is None
        assert to_dict['app']['static_root'] == 'public'
        assert to_dict['app']['template_path'] == ''

    def test_config_to_dict_nested(self):
        from pecan import configuration
        """have more than one level nesting and convert to dict"""
        conf = configuration.initconf()
        nested = {'one': {'two': 2}}
        conf['nested'] = nested

        to_dict = conf.to_dict()

        assert isinstance(to_dict, dict)
        assert to_dict['server']['host'] == '0.0.0.0'
        assert to_dict['server']['port'] == '8080'
        assert to_dict['app']['modules'] == []
        assert to_dict['app']['root'] is None
        assert to_dict['app']['static_root'] == 'public'
        assert to_dict['app']['template_path'] == ''
        assert to_dict['nested']['one']['two'] == 2

    def test_config_to_dict_prefixed(self):
        from pecan import configuration
        """Add a prefix for keys"""
        conf = configuration.initconf()

        assert isinstance(conf, configuration.Config)

        to_dict = conf.to_dict('prefix_')

        assert isinstance(to_dict, dict)
        assert to_dict['prefix_server']['prefix_host'] == '0.0.0.0'
        assert to_dict['prefix_server']['prefix_port'] == '8080'
        assert to_dict['prefix_app']['prefix_modules'] == []
        assert to_dict['prefix_app']['prefix_root'] is None
        assert to_dict['prefix_app']['prefix_static_root'] == 'public'
        assert to_dict['prefix_app']['prefix_template_path'] == ''


class TestGlobalConfig(PecanTestCase):

    def tearDown(self):
        from pecan import configuration
        configuration.set_config(
            dict(configuration.initconf()),
            overwrite=True
        )

    def test_paint_from_dict(self):
        from pecan import configuration
        configuration.set_config({'foo': 'bar'})
        assert dict(configuration._runtime_conf) != {'foo': 'bar'}
        self.assertEqual(configuration._runtime_conf.foo, 'bar')

    def test_overwrite_from_dict(self):
        from pecan import configuration
        configuration.set_config({'foo': 'bar'}, overwrite=True)
        assert dict(configuration._runtime_conf) == {'foo': 'bar'}

    def test_paint_from_file(self):
        from pecan import configuration
        configuration.set_config(os.path.join(
            __here__,
            'config_fixtures/foobar.py'
        ))
        assert dict(configuration._runtime_conf) != {'foo': 'bar'}
        assert configuration._runtime_conf.foo == 'bar'

    def test_overwrite_from_file(self):
        from pecan import configuration
        configuration.set_config(
            os.path.join(
                __here__,
                'config_fixtures/foobar.py',
            ),
            overwrite=True
        )
        assert dict(configuration._runtime_conf) == {'foo': 'bar'}

    def test_set_config_none_type(self):
        from pecan import configuration
        self.assertRaises(RuntimeError, configuration.set_config, None)

    def test_set_config_to_dir(self):
        from pecan import configuration
        self.assertRaises(RuntimeError, configuration.set_config, '/')


class TestConfFromEnv(PecanTestCase):
    #
    # Note that there is a good chance of pollution if ``tearDown`` does not
    # reset the configuration like this class does. If implementing new classes
    # for configuration this tearDown **needs to be implemented**
    #

    def setUp(self):
        super(TestConfFromEnv, self).setUp()
        self.addCleanup(self._remove_config_key)

        from pecan import configuration
        self.get_conf_path_from_env = configuration.get_conf_path_from_env

    def _remove_config_key(self):
        os.environ.pop('PECAN_CONFIG', None)

    def test_invalid_path(self):
        os.environ['PECAN_CONFIG'] = '/'
        msg = "PECAN_CONFIG was set to an invalid path: /"
        self.assertRaisesRegexp(
            RuntimeError,
            msg,
            self.get_conf_path_from_env
        )

    def test_is_not_set(self):
        msg = "PECAN_CONFIG is not set and " \
              "no config file was passed as an argument."
        self.assertRaisesRegexp(
            RuntimeError,
            msg,
            self.get_conf_path_from_env
        )

    def test_return_valid_path(self):
        __here__ = os.path.abspath(__file__)
        os.environ['PECAN_CONFIG'] = __here__
        assert self.get_conf_path_from_env() == __here__

########NEW FILE########
__FILENAME__ = test_generic
from webtest import TestApp
try:
    from simplejson import dumps
except:
    from json import dumps  # noqa

from six import b as b_

from pecan import Pecan, expose
from pecan.tests import PecanTestCase


class TestGeneric(PecanTestCase):

    def test_simple_generic(self):
        class RootController(object):
            @expose(generic=True)
            def index(self):
                pass

            @index.when(method='POST', template='json')
            def do_post(self):
                return dict(result='POST')

            @index.when(method='GET')
            def do_get(self):
                return 'GET'

        app = TestApp(Pecan(RootController()))
        r = app.get('/')
        assert r.status_int == 200
        assert r.body == b_('GET')

        r = app.post('/')
        assert r.status_int == 200
        assert r.body == b_(dumps(dict(result='POST')))

        r = app.get('/do_get', status=404)
        assert r.status_int == 404

########NEW FILE########
__FILENAME__ = test_hooks
from webtest import TestApp
from six import b as b_
from six import u as u_
from six.moves import cStringIO as StringIO

from webob import Response

from pecan import make_app, expose, redirect, abort
from pecan.hooks import (
    PecanHook, TransactionHook, HookController, RequestViewerHook
)
from pecan.configuration import Config
from pecan.decorators import transactional, after_commit, after_rollback
from pecan.tests import PecanTestCase


class TestHooks(PecanTestCase):

    def test_basic_single_hook(self):
        run_hook = []

        class RootController(object):
            @expose()
            def index(self):
                run_hook.append('inside')
                return 'Hello, World!'

        class SimpleHook(PecanHook):
            def on_route(self, state):
                run_hook.append('on_route')

            def before(self, state):
                run_hook.append('before')

            def after(self, state):
                run_hook.append('after')

            def on_error(self, state, e):
                run_hook.append('error')

        app = TestApp(make_app(RootController(), hooks=[SimpleHook()]))
        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        assert len(run_hook) == 4
        assert run_hook[0] == 'on_route'
        assert run_hook[1] == 'before'
        assert run_hook[2] == 'inside'
        assert run_hook[3] == 'after'

    def test_basic_multi_hook(self):
        run_hook = []

        class RootController(object):
            @expose()
            def index(self):
                run_hook.append('inside')
                return 'Hello, World!'

        class SimpleHook(PecanHook):
            def __init__(self, id):
                self.id = str(id)

            def on_route(self, state):
                run_hook.append('on_route' + self.id)

            def before(self, state):
                run_hook.append('before' + self.id)

            def after(self, state):
                run_hook.append('after' + self.id)

            def on_error(self, state, e):
                run_hook.append('error' + self.id)

        app = TestApp(make_app(RootController(), hooks=[
            SimpleHook(1), SimpleHook(2), SimpleHook(3)
        ]))
        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        assert len(run_hook) == 10
        assert run_hook[0] == 'on_route1'
        assert run_hook[1] == 'on_route2'
        assert run_hook[2] == 'on_route3'
        assert run_hook[3] == 'before1'
        assert run_hook[4] == 'before2'
        assert run_hook[5] == 'before3'
        assert run_hook[6] == 'inside'
        assert run_hook[7] == 'after3'
        assert run_hook[8] == 'after2'
        assert run_hook[9] == 'after1'

    def test_partial_hooks(self):
        run_hook = []

        class RootController(object):
            @expose()
            def index(self):
                run_hook.append('inside')
                return 'Hello World!'

            @expose()
            def causeerror(self):
                return [][1]

        class ErrorHook(PecanHook):
            def on_error(self, state, e):
                run_hook.append('error')

        class OnRouteHook(PecanHook):
            def on_route(self, state):
                run_hook.append('on_route')

        app = TestApp(make_app(RootController(), hooks=[
            ErrorHook(), OnRouteHook()
        ]))

        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Hello World!')

        assert len(run_hook) == 2
        assert run_hook[0] == 'on_route'
        assert run_hook[1] == 'inside'

        run_hook = []
        try:
            response = app.get('/causeerror')
        except Exception as e:
            assert isinstance(e, IndexError)

        assert len(run_hook) == 2
        assert run_hook[0] == 'on_route'
        assert run_hook[1] == 'error'

    def test_on_error_response_hook(self):
        run_hook = []

        class RootController(object):
            @expose()
            def causeerror(self):
                return [][1]

        class ErrorHook(PecanHook):
            def on_error(self, state, e):
                run_hook.append('error')

                r = Response()
                r.text = u_('on_error')

                return r

        app = TestApp(make_app(RootController(), hooks=[
            ErrorHook()
        ]))

        response = app.get('/causeerror')

        assert len(run_hook) == 1
        assert run_hook[0] == 'error'
        assert response.text == 'on_error'

    def test_prioritized_hooks(self):
        run_hook = []

        class RootController(object):
            @expose()
            def index(self):
                run_hook.append('inside')
                return 'Hello, World!'

        class SimpleHook(PecanHook):
            def __init__(self, id, priority=None):
                self.id = str(id)
                if priority:
                    self.priority = priority

            def on_route(self, state):
                run_hook.append('on_route' + self.id)

            def before(self, state):
                run_hook.append('before' + self.id)

            def after(self, state):
                run_hook.append('after' + self.id)

            def on_error(self, state, e):
                run_hook.append('error' + self.id)

        papp = make_app(RootController(), hooks=[
            SimpleHook(1, 3), SimpleHook(2, 2), SimpleHook(3, 1)
        ])
        app = TestApp(papp)
        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        assert len(run_hook) == 10
        assert run_hook[0] == 'on_route3'
        assert run_hook[1] == 'on_route2'
        assert run_hook[2] == 'on_route1'
        assert run_hook[3] == 'before3'
        assert run_hook[4] == 'before2'
        assert run_hook[5] == 'before1'
        assert run_hook[6] == 'inside'
        assert run_hook[7] == 'after1'
        assert run_hook[8] == 'after2'
        assert run_hook[9] == 'after3'

    def test_basic_isolated_hook(self):
        run_hook = []

        class SimpleHook(PecanHook):
            def on_route(self, state):
                run_hook.append('on_route')

            def before(self, state):
                run_hook.append('before')

            def after(self, state):
                run_hook.append('after')

            def on_error(self, state, e):
                run_hook.append('error')

        class SubSubController(object):
            @expose()
            def index(self):
                run_hook.append('inside_sub_sub')
                return 'Deep inside here!'

        class SubController(HookController):
            __hooks__ = [SimpleHook()]

            @expose()
            def index(self):
                run_hook.append('inside_sub')
                return 'Inside here!'

            sub = SubSubController()

        class RootController(object):
            @expose()
            def index(self):
                run_hook.append('inside')
                return 'Hello, World!'

            sub = SubController()

        app = TestApp(make_app(RootController()))
        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        assert len(run_hook) == 1
        assert run_hook[0] == 'inside'

        run_hook = []

        response = app.get('/sub/')
        assert response.status_int == 200
        assert response.body == b_('Inside here!')

        assert len(run_hook) == 3
        assert run_hook[0] == 'before'
        assert run_hook[1] == 'inside_sub'
        assert run_hook[2] == 'after'

        run_hook = []
        response = app.get('/sub/sub/')
        assert response.status_int == 200
        assert response.body == b_('Deep inside here!')

        assert len(run_hook) == 3
        assert run_hook[0] == 'before'
        assert run_hook[1] == 'inside_sub_sub'
        assert run_hook[2] == 'after'

    def test_isolated_hook_with_global_hook(self):
        run_hook = []

        class SimpleHook(PecanHook):
            def __init__(self, id):
                self.id = str(id)

            def on_route(self, state):
                run_hook.append('on_route' + self.id)

            def before(self, state):
                run_hook.append('before' + self.id)

            def after(self, state):
                run_hook.append('after' + self.id)

            def on_error(self, state, e):
                run_hook.append('error' + self.id)

        class SubController(HookController):
            __hooks__ = [SimpleHook(2)]

            @expose()
            def index(self):
                run_hook.append('inside_sub')
                return 'Inside here!'

        class RootController(object):
            @expose()
            def index(self):
                run_hook.append('inside')
                return 'Hello, World!'

            sub = SubController()

        app = TestApp(make_app(RootController(), hooks=[SimpleHook(1)]))
        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        assert len(run_hook) == 4
        assert run_hook[0] == 'on_route1'
        assert run_hook[1] == 'before1'
        assert run_hook[2] == 'inside'
        assert run_hook[3] == 'after1'

        run_hook = []

        response = app.get('/sub/')
        assert response.status_int == 200
        assert response.body == b_('Inside here!')

        assert len(run_hook) == 6
        assert run_hook[0] == 'on_route1'
        assert run_hook[1] == 'before2'
        assert run_hook[2] == 'before1'
        assert run_hook[3] == 'inside_sub'
        assert run_hook[4] == 'after1'
        assert run_hook[5] == 'after2'


class TestTransactionHook(PecanTestCase):
    def test_transaction_hook(self):
        run_hook = []

        class RootController(object):
            @expose()
            def index(self):
                run_hook.append('inside')
                return 'Hello, World!'

            @expose()
            def redirect(self):
                redirect('/')

            @expose()
            def error(self):
                return [][1]

        def gen(event):
            return lambda: run_hook.append(event)

        app = TestApp(make_app(RootController(), hooks=[
            TransactionHook(
                start=gen('start'),
                start_ro=gen('start_ro'),
                commit=gen('commit'),
                rollback=gen('rollback'),
                clear=gen('clear')
            )
        ]))

        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        assert len(run_hook) == 3
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'inside'
        assert run_hook[2] == 'clear'

        run_hook = []

        response = app.post('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        assert len(run_hook) == 4
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'inside'
        assert run_hook[2] == 'commit'
        assert run_hook[3] == 'clear'

        #
        # test hooks for GET /redirect
        # This controller should always be non-transactional
        #

        run_hook = []

        response = app.get('/redirect')
        assert response.status_int == 302
        assert len(run_hook) == 2
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'

        #
        # test hooks for POST /redirect
        # This controller should always be transactional,
        # even in the case of redirects
        #

        run_hook = []

        response = app.post('/redirect')
        assert response.status_int == 302
        assert len(run_hook) == 3
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'commit'
        assert run_hook[2] == 'clear'

        run_hook = []
        try:
            response = app.post('/error')
        except IndexError:
            pass

        assert len(run_hook) == 3
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'rollback'
        assert run_hook[2] == 'clear'

    def test_transaction_hook_with_after_actions(self):
        run_hook = []

        def action(name):
            def action_impl():
                run_hook.append(name)
            return action_impl

        class RootController(object):
            @expose()
            @after_commit(action('action-one'))
            def index(self):
                run_hook.append('inside')
                return 'Index Method!'

            @expose()
            @transactional()
            @after_commit(action('action-two'))
            def decorated(self):
                run_hook.append('inside')
                return 'Decorated Method!'

            @expose()
            @after_rollback(action('action-three'))
            def rollback(self):
                abort(500)

            @expose()
            @transactional()
            @after_rollback(action('action-four'))
            def rollback_decorated(self):
                abort(500)

        def gen(event):
            return lambda: run_hook.append(event)

        app = TestApp(make_app(RootController(), hooks=[
            TransactionHook(
                start=gen('start'),
                start_ro=gen('start_ro'),
                commit=gen('commit'),
                rollback=gen('rollback'),
                clear=gen('clear')
            )
        ]))

        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Index Method!')

        assert len(run_hook) == 3
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'inside'
        assert run_hook[2] == 'clear'

        run_hook = []

        response = app.post('/')
        assert response.status_int == 200
        assert response.body == b_('Index Method!')

        assert len(run_hook) == 5
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'inside'
        assert run_hook[2] == 'commit'
        assert run_hook[3] == 'action-one'
        assert run_hook[4] == 'clear'

        run_hook = []

        response = app.get('/decorated')
        assert response.status_int == 200
        assert response.body == b_('Decorated Method!')

        assert len(run_hook) == 7
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'
        assert run_hook[2] == 'start'
        assert run_hook[3] == 'inside'
        assert run_hook[4] == 'commit'
        assert run_hook[5] == 'action-two'
        assert run_hook[6] == 'clear'

        run_hook = []

        response = app.get('/rollback', expect_errors=True)
        assert response.status_int == 500

        assert len(run_hook) == 2
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'

        run_hook = []

        response = app.post('/rollback', expect_errors=True)
        assert response.status_int == 500

        assert len(run_hook) == 4
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'rollback'
        assert run_hook[2] == 'action-three'
        assert run_hook[3] == 'clear'

        run_hook = []

        response = app.get('/rollback_decorated', expect_errors=True)
        assert response.status_int == 500

        assert len(run_hook) == 6
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'
        assert run_hook[2] == 'start'
        assert run_hook[3] == 'rollback'
        assert run_hook[4] == 'action-four'
        assert run_hook[5] == 'clear'

        run_hook = []

        response = app.get('/fourohfour', status=404)
        assert response.status_int == 404

        assert len(run_hook) == 2
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'

    def test_transaction_hook_with_transactional_decorator(self):
        run_hook = []

        class RootController(object):
            @expose()
            def index(self):
                run_hook.append('inside')
                return 'Hello, World!'

            @expose()
            def redirect(self):
                redirect('/')

            @expose()
            @transactional()
            def redirect_transactional(self):
                redirect('/')

            @expose()
            @transactional(False)
            def redirect_rollback(self):
                redirect('/')

            @expose()
            def error(self):
                return [][1]

            @expose()
            @transactional(False)
            def error_rollback(self):
                return [][1]

            @expose()
            @transactional()
            def error_transactional(self):
                return [][1]

        def gen(event):
            return lambda: run_hook.append(event)

        app = TestApp(make_app(RootController(), hooks=[
            TransactionHook(
                start=gen('start'),
                start_ro=gen('start_ro'),
                commit=gen('commit'),
                rollback=gen('rollback'),
                clear=gen('clear')
            )
        ]))

        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        assert len(run_hook) == 3
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'inside'
        assert run_hook[2] == 'clear'

        run_hook = []

        # test hooks for /

        response = app.post('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        assert len(run_hook) == 4
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'inside'
        assert run_hook[2] == 'commit'
        assert run_hook[3] == 'clear'

        #
        # test hooks for GET /redirect
        # This controller should always be non-transactional
        #

        run_hook = []

        response = app.get('/redirect')
        assert response.status_int == 302
        assert len(run_hook) == 2
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'

        #
        # test hooks for POST /redirect
        # This controller should always be transactional,
        # even in the case of redirects
        #

        run_hook = []

        response = app.post('/redirect')
        assert response.status_int == 302
        assert len(run_hook) == 3
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'commit'
        assert run_hook[2] == 'clear'

        #
        # test hooks for GET /redirect_transactional
        # This controller should always be transactional,
        # even in the case of redirects
        #

        run_hook = []

        response = app.get('/redirect_transactional')
        assert response.status_int == 302
        assert len(run_hook) == 5
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'
        assert run_hook[2] == 'start'
        assert run_hook[3] == 'commit'
        assert run_hook[4] == 'clear'

        #
        # test hooks for POST /redirect_transactional
        # This controller should always be transactional,
        # even in the case of redirects
        #

        run_hook = []

        response = app.post('/redirect_transactional')
        assert response.status_int == 302
        assert len(run_hook) == 3
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'commit'
        assert run_hook[2] == 'clear'

        #
        # test hooks for GET /redirect_rollback
        # This controller should always be transactional,
        # *except* in the case of redirects
        #
        run_hook = []

        response = app.get('/redirect_rollback')
        assert response.status_int == 302
        assert len(run_hook) == 5
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'
        assert run_hook[2] == 'start'
        assert run_hook[3] == 'rollback'
        assert run_hook[4] == 'clear'

        #
        # test hooks for POST /redirect_rollback
        # This controller should always be transactional,
        # *except* in the case of redirects
        #

        run_hook = []

        response = app.post('/redirect_rollback')
        assert response.status_int == 302
        assert len(run_hook) == 3
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'rollback'
        assert run_hook[2] == 'clear'

        #
        # Exceptions (other than HTTPFound) should *always*
        # rollback no matter what
        #
        run_hook = []

        try:
            response = app.post('/error')
        except IndexError:
            pass

        assert len(run_hook) == 3
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'rollback'
        assert run_hook[2] == 'clear'

        run_hook = []

        try:
            response = app.get('/error')
        except IndexError:
            pass

        assert len(run_hook) == 2
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'

        run_hook = []

        try:
            response = app.post('/error_transactional')
        except IndexError:
            pass

        assert len(run_hook) == 3
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'rollback'
        assert run_hook[2] == 'clear'

        run_hook = []

        try:
            response = app.get('/error_transactional')
        except IndexError:
            pass

        assert len(run_hook) == 5
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'
        assert run_hook[2] == 'start'
        assert run_hook[3] == 'rollback'
        assert run_hook[4] == 'clear'

        run_hook = []

        try:
            response = app.post('/error_rollback')
        except IndexError:
            pass

        assert len(run_hook) == 3
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'rollback'
        assert run_hook[2] == 'clear'

        run_hook = []

        try:
            response = app.get('/error_rollback')
        except IndexError:
            pass

        assert len(run_hook) == 5
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'
        assert run_hook[2] == 'start'
        assert run_hook[3] == 'rollback'
        assert run_hook[4] == 'clear'

    def test_transaction_hook_with_transactional_class_decorator(self):
        run_hook = []

        @transactional()
        class RootController(object):
            @expose()
            def index(self):
                run_hook.append('inside')
                return 'Hello, World!'

            @expose()
            def redirect(self):
                redirect('/')

            @expose()
            @transactional(False)
            def redirect_rollback(self):
                redirect('/')

            @expose()
            def error(self):
                return [][1]

            @expose(generic=True)
            def generic(self):
                pass

            @generic.when(method='GET')
            def generic_get(self):
                run_hook.append('inside')
                return 'generic get'

            @generic.when(method='POST')
            def generic_post(self):
                run_hook.append('inside')
                return 'generic post'

        def gen(event):
            return lambda: run_hook.append(event)

        app = TestApp(make_app(RootController(), hooks=[
            TransactionHook(
                start=gen('start'),
                start_ro=gen('start_ro'),
                commit=gen('commit'),
                rollback=gen('rollback'),
                clear=gen('clear')
            )
        ]))

        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        assert len(run_hook) == 6
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'
        assert run_hook[2] == 'start'
        assert run_hook[3] == 'inside'
        assert run_hook[4] == 'commit'
        assert run_hook[5] == 'clear'

        run_hook = []

        # test hooks for /

        response = app.post('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        assert len(run_hook) == 4
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'inside'
        assert run_hook[2] == 'commit'
        assert run_hook[3] == 'clear'

        #
        # test hooks for GET /redirect
        # This controller should always be transactional,
        # even in the case of redirects
        #

        run_hook = []
        response = app.get('/redirect')
        assert response.status_int == 302
        assert len(run_hook) == 5
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'
        assert run_hook[2] == 'start'
        assert run_hook[3] == 'commit'
        assert run_hook[4] == 'clear'

        #
        # test hooks for POST /redirect
        # This controller should always be transactional,
        # even in the case of redirects
        #

        run_hook = []

        response = app.post('/redirect')
        assert response.status_int == 302
        assert len(run_hook) == 3
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'commit'
        assert run_hook[2] == 'clear'

        #
        # test hooks for GET /redirect_rollback
        # This controller should always be transactional,
        # *except* in the case of redirects
        #
        run_hook = []

        response = app.get('/redirect_rollback')
        assert response.status_int == 302
        assert len(run_hook) == 5
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'
        assert run_hook[2] == 'start'
        assert run_hook[3] == 'rollback'
        assert run_hook[4] == 'clear'

        #
        # test hooks for POST /redirect_rollback
        # This controller should always be transactional,
        # *except* in the case of redirects
        #

        run_hook = []

        response = app.post('/redirect_rollback')
        assert response.status_int == 302
        assert len(run_hook) == 3
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'rollback'
        assert run_hook[2] == 'clear'

        #
        # Exceptions (other than HTTPFound) should *always*
        # rollback no matter what
        #
        run_hook = []

        try:
            response = app.post('/error')
        except IndexError:
            pass

        assert len(run_hook) == 3
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'rollback'
        assert run_hook[2] == 'clear'

        run_hook = []

        try:
            response = app.get('/error')
        except IndexError:
            pass

        assert len(run_hook) == 5
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'
        assert run_hook[2] == 'start'
        assert run_hook[3] == 'rollback'
        assert run_hook[4] == 'clear'

        #
        # test hooks for GET /generic
        # This controller should always be transactional,
        #

        run_hook = []

        response = app.get('/generic')
        assert response.status_int == 200
        assert response.body == b_('generic get')
        assert len(run_hook) == 6
        assert run_hook[0] == 'start_ro'
        assert run_hook[1] == 'clear'
        assert run_hook[2] == 'start'
        assert run_hook[3] == 'inside'
        assert run_hook[4] == 'commit'
        assert run_hook[5] == 'clear'

        #
        # test hooks for POST /generic
        # This controller should always be transactional,
        #

        run_hook = []

        response = app.post('/generic')
        assert response.status_int == 200
        assert response.body == b_('generic post')
        assert len(run_hook) == 4
        assert run_hook[0] == 'start'
        assert run_hook[1] == 'inside'
        assert run_hook[2] == 'commit'
        assert run_hook[3] == 'clear'

    def test_transaction_hook_with_broken_hook(self):
        """
        In a scenario where a preceding hook throws an exception,
        ensure that TransactionHook still rolls back properly.
        """
        run_hook = []

        class RootController(object):
            @expose()
            def index(self):
                return 'Hello, World!'

        def gen(event):
            return lambda: run_hook.append(event)

        class MyCustomException(Exception):
            pass

        class MyHook(PecanHook):

            def on_route(self, state):
                raise MyCustomException('BROKEN!')

        app = TestApp(make_app(RootController(), hooks=[
            MyHook(),
            TransactionHook(
                start=gen('start'),
                start_ro=gen('start_ro'),
                commit=gen('commit'),
                rollback=gen('rollback'),
                clear=gen('clear')
            )
        ]))

        self.assertRaises(
            MyCustomException,
            app.get,
            '/'
        )

        assert len(run_hook) == 1
        assert run_hook[0] == 'clear'


class TestRequestViewerHook(PecanTestCase):

    def test_basic_single_default_hook(self):

        _stdout = StringIO()

        class RootController(object):
            @expose()
            def index(self):
                return 'Hello, World!'

        app = TestApp(
            make_app(
                RootController(), hooks=lambda: [
                    RequestViewerHook(writer=_stdout)
                ]
            )
        )
        response = app.get('/')

        out = _stdout.getvalue()

        assert response.status_int == 200
        assert response.body == b_('Hello, World!')
        assert 'path' in out
        assert 'method' in out
        assert 'status' in out
        assert 'method' in out
        assert 'params' in out
        assert 'hooks' in out
        assert '200 OK' in out
        assert "['RequestViewerHook']" in out
        assert '/' in out

    def test_bad_response_from_app(self):
        """When exceptions are raised the hook deals with them properly"""

        _stdout = StringIO()

        class RootController(object):
            @expose()
            def index(self):
                return 'Hello, World!'

        app = TestApp(
            make_app(
                RootController(), hooks=lambda: [
                    RequestViewerHook(writer=_stdout)
                ]
            )
        )
        response = app.get('/404', expect_errors=True)

        out = _stdout.getvalue()

        assert response.status_int == 404
        assert 'path' in out
        assert 'method' in out
        assert 'status' in out
        assert 'method' in out
        assert 'params' in out
        assert 'hooks' in out
        assert '404 Not Found' in out
        assert "['RequestViewerHook']" in out
        assert '/' in out

    def test_single_item(self):

        _stdout = StringIO()

        class RootController(object):
            @expose()
            def index(self):
                return 'Hello, World!'

        app = TestApp(
            make_app(
                RootController(),
                hooks=lambda: [
                    RequestViewerHook(
                        config={'items': ['path']}, writer=_stdout
                    )
                ]
            )
        )
        response = app.get('/')

        out = _stdout.getvalue()

        assert response.status_int == 200
        assert response.body == b_('Hello, World!')
        assert '/' in out
        assert 'path' in out
        assert 'method' not in out
        assert 'status' not in out
        assert 'method' not in out
        assert 'params' not in out
        assert 'hooks' not in out
        assert '200 OK' not in out
        assert "['RequestViewerHook']" not in out

    def test_single_blacklist_item(self):

        _stdout = StringIO()

        class RootController(object):
            @expose()
            def index(self):
                return 'Hello, World!'

        app = TestApp(
            make_app(
                RootController(),
                hooks=lambda: [
                    RequestViewerHook(
                        config={'blacklist': ['/']}, writer=_stdout
                    )
                ]
            )
        )
        response = app.get('/')

        out = _stdout.getvalue()

        assert response.status_int == 200
        assert response.body == b_('Hello, World!')
        assert out == ''

    def test_item_not_in_defaults(self):

        _stdout = StringIO()

        class RootController(object):
            @expose()
            def index(self):
                return 'Hello, World!'

        app = TestApp(
            make_app(
                RootController(),
                hooks=lambda: [
                    RequestViewerHook(
                        config={'items': ['date']}, writer=_stdout
                    )
                ]
            )
        )
        response = app.get('/')

        out = _stdout.getvalue()

        assert response.status_int == 200
        assert response.body == b_('Hello, World!')
        assert 'date' in out
        assert 'method' not in out
        assert 'status' not in out
        assert 'method' not in out
        assert 'params' not in out
        assert 'hooks' not in out
        assert '200 OK' not in out
        assert "['RequestViewerHook']" not in out
        assert '/' not in out

    def test_hook_formatting(self):
        hooks = ['<pecan.hooks.RequestViewerHook object at 0x103a5f910>']
        viewer = RequestViewerHook()
        formatted = viewer.format_hooks(hooks)

        assert formatted == ['RequestViewerHook']

    def test_deal_with_pecan_configs(self):
        """If config comes from pecan.conf convert it to dict"""
        conf = Config(conf_dict={'items': ['url']})
        viewer = RequestViewerHook(conf)

        assert viewer.items == ['url']

########NEW FILE########
__FILENAME__ = test_jsonify
from datetime import datetime, date
from decimal import Decimal
try:
    from simplejson import loads
except:
    from json import loads  # noqa
try:
    from sqlalchemy import orm, schema, types
    from sqlalchemy.engine import create_engine
except ImportError:
    create_engine = None  # noqa

from webtest import TestApp
from webob.multidict import MultiDict

from pecan.jsonify import jsonify, encode, ResultProxy, RowProxy
from pecan import Pecan, expose
from pecan.tests import PecanTestCase


def make_person():
    class Person(object):
        def __init__(self, first_name, last_name):
            self.first_name = first_name
            self.last_name = last_name

        @property
        def name(self):
            return '%s %s' % (self.first_name, self.last_name)
    return Person


def test_simple_rule():
    Person = make_person()

    # create a Person instance
    p = Person('Jonathan', 'LaCour')

    # register a generic JSON rule
    @jsonify.when_type(Person)
    def jsonify_person(obj):
        return dict(
            name=obj.name
        )

    # encode the object using our new rule
    result = loads(encode(p))
    assert result['name'] == 'Jonathan LaCour'
    assert len(result) == 1


class TestJsonify(PecanTestCase):

    def test_simple_jsonify(self):
        Person = make_person()

        # register a generic JSON rule
        @jsonify.when_type(Person)
        def jsonify_person(obj):
            return dict(
                name=obj.name
            )

        class RootController(object):
            @expose('json')
            def index(self):
                # create a Person instance
                p = Person('Jonathan', 'LaCour')
                return p

        app = TestApp(Pecan(RootController()))

        r = app.get('/')
        assert r.status_int == 200
        assert loads(r.body.decode()) == {'name': 'Jonathan LaCour'}


class TestJsonifyGenericEncoder(PecanTestCase):
    def test_json_callable(self):
        class JsonCallable(object):
            def __init__(self, arg):
                self.arg = arg

            def __json__(self):
                return {"arg": self.arg}

        result = encode(JsonCallable('foo'))
        assert loads(result) == {'arg': 'foo'}

    def test_datetime(self):
        today = date.today()
        now = datetime.now()

        result = encode(today)
        assert loads(result) == str(today)

        result = encode(now)
        assert loads(result) == str(now)

    def test_decimal(self):
        # XXX Testing for float match which is inexact

        d = Decimal('1.1')
        result = encode(d)
        assert loads(result) == float(d)

    def test_multidict(self):
        md = MultiDict()
        md.add('arg', 'foo')
        md.add('arg', 'bar')
        result = encode(md)
        assert loads(result) == {'arg': ['foo', 'bar']}

    def test_fallback_to_builtin_encoder(self):
        class Foo(object):
            pass

        self.assertRaises(TypeError, encode, Foo())


class TestJsonifySQLAlchemyGenericEncoder(PecanTestCase):

    def setUp(self):
        super(TestJsonifySQLAlchemyGenericEncoder, self).setUp()
        if not create_engine:
            self.create_fake_proxies()
        else:
            self.create_sa_proxies()

    def create_fake_proxies(self):

        # create a fake SA object
        class FakeSAObject(object):
            def __init__(self):
                self._sa_class_manager = object()
                self._sa_instance_state = 'awesome'
                self.id = 1
                self.first_name = 'Jonathan'
                self.last_name = 'LaCour'

        # create a fake result proxy
        class FakeResultProxy(ResultProxy):
            def __init__(self):
                self.rowcount = -1
                self.rows = []

            def __iter__(self):
                return iter(self.rows)

            def append(self, row):
                self.rows.append(row)

        # create a fake row proxy
        class FakeRowProxy(RowProxy):
            def __init__(self, arg=None):
                self.row = dict(arg)

            def __getitem__(self, key):
                return self.row.__getitem__(key)

            def keys(self):
                return self.row.keys()

        # get the SA objects
        self.sa_object = FakeSAObject()
        self.result_proxy = FakeResultProxy()
        self.result_proxy.append(
            FakeRowProxy([
                ('id', 1),
                ('first_name', 'Jonathan'),
                ('last_name', 'LaCour')
            ])
        )
        self.result_proxy.append(
            FakeRowProxy([
                ('id', 2), ('first_name', 'Yoann'), ('last_name', 'Roman')
            ]))
        self.row_proxy = FakeRowProxy([
            ('id', 1), ('first_name', 'Jonathan'), ('last_name', 'LaCour')
        ])

    def create_sa_proxies(self):

        # create the table and mapper
        metadata = schema.MetaData()
        user_table = schema.Table(
            'user',
            metadata,
            schema.Column('id', types.Integer, primary_key=True),
            schema.Column('first_name', types.Unicode(25)),
            schema.Column('last_name', types.Unicode(25))
        )

        class User(object):
            pass
        orm.mapper(User, user_table)

        # create the session
        engine = create_engine('sqlite:///:memory:')
        metadata.bind = engine
        metadata.create_all()
        session = orm.sessionmaker(bind=engine)()

        # add some dummy data
        user_table.insert().execute([
            {'first_name': 'Jonathan', 'last_name': 'LaCour'},
            {'first_name': 'Yoann', 'last_name': 'Roman'}
        ])

        # get the SA objects
        self.sa_object = session.query(User).first()
        select = user_table.select()
        self.result_proxy = select.execute()
        self.row_proxy = select.execute().fetchone()

    def test_sa_object(self):
        result = encode(self.sa_object)
        assert loads(result) == {
            'id': 1, 'first_name': 'Jonathan', 'last_name': 'LaCour'
        }

    def test_result_proxy(self):
        result = encode(self.result_proxy)
        assert loads(result) == {'count': 2, 'rows': [
            {'id': 1, 'first_name': 'Jonathan', 'last_name': 'LaCour'},
            {'id': 2, 'first_name': 'Yoann', 'last_name': 'Roman'}
        ]}

    def test_row_proxy(self):
        result = encode(self.row_proxy)
        assert loads(result) == {
            'id': 1, 'first_name': 'Jonathan', 'last_name': 'LaCour'
        }

########NEW FILE########
__FILENAME__ = test_rest
from webtest import TestApp
import warnings
try:
    from simplejson import dumps, loads
except:
    from json import dumps, loads  # noqa

from six import b as b_

from pecan import abort, expose, make_app, response
from pecan.rest import RestController
from pecan.tests import PecanTestCase


class TestRestController(PecanTestCase):

    def test_basic_rest(self):

        class OthersController(object):

            @expose()
            def index(self):
                return 'OTHERS'

            @expose()
            def echo(self, value):
                return str(value)

        class ThingsController(RestController):
            data = ['zero', 'one', 'two', 'three']

            _custom_actions = {'count': ['GET'], 'length': ['GET', 'POST']}

            others = OthersController()

            @expose()
            def get_one(self, id):
                return self.data[int(id)]

            @expose('json')
            def get_all(self):
                return dict(items=self.data)

            @expose()
            def length(self, id, value=None):
                length = len(self.data[int(id)])
                if value:
                    length += len(value)
                return str(length)

            @expose()
            def get_count(self):
                return str(len(self.data))

            @expose()
            def new(self):
                return 'NEW'

            @expose()
            def post(self, value):
                self.data.append(value)
                response.status = 302
                return 'CREATED'

            @expose()
            def edit(self, id):
                return 'EDIT %s' % self.data[int(id)]

            @expose()
            def put(self, id, value):
                self.data[int(id)] = value
                return 'UPDATED'

            @expose()
            def get_delete(self, id):
                return 'DELETE %s' % self.data[int(id)]

            @expose()
            def delete(self, id):
                del self.data[int(id)]
                return 'DELETED'

            @expose()
            def reset(self):
                return 'RESET'

            @expose()
            def post_options(self):
                return 'OPTIONS'

            @expose()
            def options(self):
                abort(500)

            @expose()
            def other(self):
                abort(500)

        class RootController(object):
            things = ThingsController()

        # create the app
        app = TestApp(make_app(RootController()))

        # test get_all
        r = app.get('/things')
        assert r.status_int == 200
        assert r.body == b_(dumps(dict(items=ThingsController.data)))

        # test get_one
        for i, value in enumerate(ThingsController.data):
            r = app.get('/things/%d' % i)
            assert r.status_int == 200
            assert r.body == b_(value)

        # test post
        r = app.post('/things', {'value': 'four'})
        assert r.status_int == 302
        assert r.body == b_('CREATED')

        # make sure it works
        r = app.get('/things/4')
        assert r.status_int == 200
        assert r.body == b_('four')

        # test edit
        r = app.get('/things/3/edit')
        assert r.status_int == 200
        assert r.body == b_('EDIT three')

        # test put
        r = app.put('/things/4', {'value': 'FOUR'})
        assert r.status_int == 200
        assert r.body == b_('UPDATED')

        # make sure it works
        r = app.get('/things/4')
        assert r.status_int == 200
        assert r.body == b_('FOUR')

        # test put with _method parameter and GET
        r = app.get('/things/4?_method=put', {'value': 'FOUR!'}, status=405)
        assert r.status_int == 405

        # make sure it works
        r = app.get('/things/4')
        assert r.status_int == 200
        assert r.body == b_('FOUR')

        # test put with _method parameter and POST
        r = app.post('/things/4?_method=put', {'value': 'FOUR!'})
        assert r.status_int == 200
        assert r.body == b_('UPDATED')

        # make sure it works
        r = app.get('/things/4')
        assert r.status_int == 200
        assert r.body == b_('FOUR!')

        # test get delete
        r = app.get('/things/4/delete')
        assert r.status_int == 200
        assert r.body == b_('DELETE FOUR!')

        # test delete
        r = app.delete('/things/4')
        assert r.status_int == 200
        assert r.body == b_('DELETED')

        # make sure it works
        r = app.get('/things')
        assert r.status_int == 200
        assert len(loads(r.body.decode())['items']) == 4

        # test delete with _method parameter and GET
        r = app.get('/things/3?_method=DELETE', status=405)
        assert r.status_int == 405

        # make sure it works
        r = app.get('/things')
        assert r.status_int == 200
        assert len(loads(r.body.decode())['items']) == 4

        # test delete with _method parameter and POST
        r = app.post('/things/3?_method=DELETE')
        assert r.status_int == 200
        assert r.body == b_('DELETED')

        # make sure it works
        r = app.get('/things')
        assert r.status_int == 200
        assert len(loads(r.body.decode())['items']) == 3

        # test "RESET" custom action
        r = app.request('/things', method='RESET')
        assert r.status_int == 200
        assert r.body == b_('RESET')

        # test "RESET" custom action with _method parameter
        r = app.get('/things?_method=RESET')
        assert r.status_int == 200
        assert r.body == b_('RESET')

        # test the "OPTIONS" custom action
        r = app.request('/things', method='OPTIONS')
        assert r.status_int == 200
        assert r.body == b_('OPTIONS')

        # test the "OPTIONS" custom action with the _method parameter
        r = app.post('/things', {'_method': 'OPTIONS'})
        assert r.status_int == 200
        assert r.body == b_('OPTIONS')

        # test the "other" custom action
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            r = app.request('/things/other', method='MISC', status=405)
            assert r.status_int == 405

        # test the "other" custom action with the _method parameter
        r = app.post('/things/other', {'_method': 'MISC'}, status=405)
        assert r.status_int == 405

        # test the "others" custom action
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            r = app.request('/things/others/', method='MISC')
            assert r.status_int == 200
            assert r.body == b_('OTHERS')

        # test the "others" custom action missing trailing slash
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            r = app.request('/things/others', method='MISC', status=302)
            assert r.status_int == 302

        # test the "others" custom action with the _method parameter
        r = app.get('/things/others/?_method=MISC')
        assert r.status_int == 200
        assert r.body == b_('OTHERS')

        # test an invalid custom action
        r = app.get('/things?_method=BAD', status=404)
        assert r.status_int == 404

        # test custom "GET" request "count"
        r = app.get('/things/count')
        assert r.status_int == 200
        assert r.body == b_('3')

        # test custom "GET" request "length"
        r = app.get('/things/1/length')
        assert r.status_int == 200
        assert r.body == b_(str(len('one')))

        # test custom "GET" request through subcontroller
        r = app.get('/things/others/echo?value=test')
        assert r.status_int == 200
        assert r.body == b_('test')

        # test custom "POST" request "length"
        r = app.post('/things/1/length', {'value': 'test'})
        assert r.status_int == 200
        assert r.body == b_(str(len('onetest')))

        # test custom "POST" request through subcontroller
        r = app.post('/things/others/echo', {'value': 'test'})
        assert r.status_int == 200
        assert r.body == b_('test')

    def test_getall_with_trailing_slash(self):

        class ThingsController(RestController):

            data = ['zero', 'one', 'two', 'three']

            @expose('json')
            def get_all(self):
                return dict(items=self.data)

        class RootController(object):
            things = ThingsController()

        # create the app
        app = TestApp(make_app(RootController()))

        # test get_all
        r = app.get('/things/')
        assert r.status_int == 200
        assert r.body == b_(dumps(dict(items=ThingsController.data)))

    def test_404_with_lookup(self):

        class LookupController(RestController):

            def __init__(self, _id):
                self._id = _id

            @expose()
            def get_all(self):
                return 'ID: %s' % self._id

        class ThingsController(RestController):

            @expose()
            def _lookup(self, _id, *remainder):
                return LookupController(_id), remainder

        class RootController(object):
            things = ThingsController()

        # create the app
        app = TestApp(make_app(RootController()))

        # these should 404
        for path in ('/things', '/things/'):
            r = app.get(path, expect_errors=True)
            assert r.status_int == 404

        r = app.get('/things/foo')
        assert r.status_int == 200
        assert r.body == b_('ID: foo')

    def test_getall_with_lookup(self):

        class LookupController(RestController):

            def __init__(self, _id):
                self._id = _id

            @expose()
            def get_all(self):
                return 'ID: %s' % self._id

        class ThingsController(RestController):

            data = ['zero', 'one', 'two', 'three']

            @expose()
            def _lookup(self, _id, *remainder):
                return LookupController(_id), remainder

            @expose('json')
            def get_all(self):
                return dict(items=self.data)

        class RootController(object):
            things = ThingsController()

        # create the app
        app = TestApp(make_app(RootController()))

        # test get_all
        for path in ('/things', '/things/'):
            r = app.get(path)
            assert r.status_int == 200
            assert r.body == b_(dumps(dict(items=ThingsController.data)))

        r = app.get('/things/foo')
        assert r.status_int == 200
        assert r.body == b_('ID: foo')

    def test_simple_nested_rest(self):

        class BarController(RestController):

            @expose()
            def post(self):
                return "BAR-POST"

            @expose()
            def delete(self, id_):
                return "BAR-%s" % id_

        class FooController(RestController):

            bar = BarController()

            @expose()
            def post(self):
                return "FOO-POST"

            @expose()
            def delete(self, id_):
                return "FOO-%s" % id_

        class RootController(object):
            foo = FooController()

        # create the app
        app = TestApp(make_app(RootController()))

        r = app.post('/foo')
        assert r.status_int == 200
        assert r.body == b_("FOO-POST")

        r = app.delete('/foo/1')
        assert r.status_int == 200
        assert r.body == b_("FOO-1")

        r = app.post('/foo/bar')
        assert r.status_int == 200
        assert r.body == b_("BAR-POST")

        r = app.delete('/foo/bar/2')
        assert r.status_int == 200
        assert r.body == b_("BAR-2")

    def test_complicated_nested_rest(self):

        class BarsController(RestController):

            data = [['zero-zero', 'zero-one'], ['one-zero', 'one-one']]

            @expose()
            def get_one(self, foo_id, id):
                return self.data[int(foo_id)][int(id)]

            @expose('json')
            def get_all(self, foo_id):
                return dict(items=self.data[int(foo_id)])

            @expose()
            def new(self, foo_id):
                return 'NEW FOR %s' % foo_id

            @expose()
            def post(self, foo_id, value):
                foo_id = int(foo_id)
                if len(self.data) < foo_id + 1:
                    self.data.extend([[]] * (foo_id - len(self.data) + 1))
                self.data[foo_id].append(value)
                response.status = 302
                return 'CREATED FOR %s' % foo_id

            @expose()
            def edit(self, foo_id, id):
                return 'EDIT %s' % self.data[int(foo_id)][int(id)]

            @expose()
            def put(self, foo_id, id, value):
                self.data[int(foo_id)][int(id)] = value
                return 'UPDATED'

            @expose()
            def get_delete(self, foo_id, id):
                return 'DELETE %s' % self.data[int(foo_id)][int(id)]

            @expose()
            def delete(self, foo_id, id):
                del self.data[int(foo_id)][int(id)]
                return 'DELETED'

        class FoosController(RestController):

            data = ['zero', 'one']

            bars = BarsController()

            @expose()
            def get_one(self, id):
                return self.data[int(id)]

            @expose('json')
            def get_all(self):
                return dict(items=self.data)

            @expose()
            def new(self):
                return 'NEW'

            @expose()
            def edit(self, id):
                return 'EDIT %s' % self.data[int(id)]

            @expose()
            def post(self, value):
                self.data.append(value)
                response.status = 302
                return 'CREATED'

            @expose()
            def put(self, id, value):
                self.data[int(id)] = value
                return 'UPDATED'

            @expose()
            def get_delete(self, id):
                return 'DELETE %s' % self.data[int(id)]

            @expose()
            def delete(self, id):
                del self.data[int(id)]
                return 'DELETED'

        class RootController(object):
            foos = FoosController()

        # create the app
        app = TestApp(make_app(RootController()))

        # test get_all
        r = app.get('/foos')
        assert r.status_int == 200
        assert r.body == b_(dumps(dict(items=FoosController.data)))

        # test nested get_all
        r = app.get('/foos/1/bars')
        assert r.status_int == 200
        assert r.body == b_(dumps(dict(items=BarsController.data[1])))

        # test get_one
        for i, value in enumerate(FoosController.data):
            r = app.get('/foos/%d' % i)
            assert r.status_int == 200
            assert r.body == b_(value)

        # test nested get_one
        for i, value in enumerate(FoosController.data):
            for j, value in enumerate(BarsController.data[i]):
                r = app.get('/foos/%s/bars/%s' % (i, j))
                assert r.status_int == 200
                assert r.body == b_(value)

        # test post
        r = app.post('/foos', {'value': 'two'})
        assert r.status_int == 302
        assert r.body == b_('CREATED')

        # make sure it works
        r = app.get('/foos/2')
        assert r.status_int == 200
        assert r.body == b_('two')

        # test nested post
        r = app.post('/foos/2/bars', {'value': 'two-zero'})
        assert r.status_int == 302
        assert r.body == b_('CREATED FOR 2')

        # make sure it works
        r = app.get('/foos/2/bars/0')
        assert r.status_int == 200
        assert r.body == b_('two-zero')

        # test edit
        r = app.get('/foos/1/edit')
        assert r.status_int == 200
        assert r.body == b_('EDIT one')

        # test nested edit
        r = app.get('/foos/1/bars/1/edit')
        assert r.status_int == 200
        assert r.body == b_('EDIT one-one')

        # test put
        r = app.put('/foos/2', {'value': 'TWO'})
        assert r.status_int == 200
        assert r.body == b_('UPDATED')

        # make sure it works
        r = app.get('/foos/2')
        assert r.status_int == 200
        assert r.body == b_('TWO')

        # test nested put
        r = app.put('/foos/2/bars/0', {'value': 'TWO-ZERO'})
        assert r.status_int == 200
        assert r.body == b_('UPDATED')

        # make sure it works
        r = app.get('/foos/2/bars/0')
        assert r.status_int == 200
        assert r.body == b_('TWO-ZERO')

        # test put with _method parameter and GET
        r = app.get('/foos/2?_method=put', {'value': 'TWO!'}, status=405)
        assert r.status_int == 405

        # make sure it works
        r = app.get('/foos/2')
        assert r.status_int == 200
        assert r.body == b_('TWO')

        # test nested put with _method parameter and GET
        r = app.get(
            '/foos/2/bars/0?_method=put',
            {'value': 'ZERO-TWO!'}, status=405
        )
        assert r.status_int == 405

        # make sure it works
        r = app.get('/foos/2/bars/0')
        assert r.status_int == 200
        assert r.body == b_('TWO-ZERO')

        # test put with _method parameter and POST
        r = app.post('/foos/2?_method=put', {'value': 'TWO!'})
        assert r.status_int == 200
        assert r.body == b_('UPDATED')

        # make sure it works
        r = app.get('/foos/2')
        assert r.status_int == 200
        assert r.body == b_('TWO!')

        # test nested put with _method parameter and POST
        r = app.post('/foos/2/bars/0?_method=put', {'value': 'TWO-ZERO!'})
        assert r.status_int == 200
        assert r.body == b_('UPDATED')

        # make sure it works
        r = app.get('/foos/2/bars/0')
        assert r.status_int == 200
        assert r.body == b_('TWO-ZERO!')

        # test get delete
        r = app.get('/foos/2/delete')
        assert r.status_int == 200
        assert r.body == b_('DELETE TWO!')

        # test nested get delete
        r = app.get('/foos/2/bars/0/delete')
        assert r.status_int == 200
        assert r.body == b_('DELETE TWO-ZERO!')

        # test nested delete
        r = app.delete('/foos/2/bars/0')
        assert r.status_int == 200
        assert r.body == b_('DELETED')

        # make sure it works
        r = app.get('/foos/2/bars')
        assert r.status_int == 200
        assert len(loads(r.body.decode())['items']) == 0

        # test delete
        r = app.delete('/foos/2')
        assert r.status_int == 200
        assert r.body == b_('DELETED')

        # make sure it works
        r = app.get('/foos')
        assert r.status_int == 200
        assert len(loads(r.body.decode())['items']) == 2

        # test nested delete with _method parameter and GET
        r = app.get('/foos/1/bars/1?_method=DELETE', status=405)
        assert r.status_int == 405

        # make sure it works
        r = app.get('/foos/1/bars')
        assert r.status_int == 200
        assert len(loads(r.body.decode())['items']) == 2

        # test delete with _method parameter and GET
        r = app.get('/foos/1?_method=DELETE', status=405)
        assert r.status_int == 405

        # make sure it works
        r = app.get('/foos')
        assert r.status_int == 200
        assert len(loads(r.body.decode())['items']) == 2

        # test nested delete with _method parameter and POST
        r = app.post('/foos/1/bars/1?_method=DELETE')
        assert r.status_int == 200
        assert r.body == b_('DELETED')

        # make sure it works
        r = app.get('/foos/1/bars')
        assert r.status_int == 200
        assert len(loads(r.body.decode())['items']) == 1

        # test delete with _method parameter and POST
        r = app.post('/foos/1?_method=DELETE')
        assert r.status_int == 200
        assert r.body == b_('DELETED')

        # make sure it works
        r = app.get('/foos')
        assert r.status_int == 200
        assert len(loads(r.body.decode())['items']) == 1

    def test_bad_rest(self):

        class ThingsController(RestController):
            pass

        class RootController(object):
            things = ThingsController()

        # create the app
        app = TestApp(make_app(RootController()))

        # test get_all
        r = app.get('/things', status=404)
        assert r.status_int == 404

        # test get_one
        r = app.get('/things/1', status=404)
        assert r.status_int == 404

        # test post
        r = app.post('/things', {'value': 'one'}, status=404)
        assert r.status_int == 404

        # test edit
        r = app.get('/things/1/edit', status=404)
        assert r.status_int == 404

        # test put
        r = app.put('/things/1', {'value': 'ONE'}, status=404)

        # test put with _method parameter and GET
        r = app.get('/things/1?_method=put', {'value': 'ONE!'}, status=405)
        assert r.status_int == 405

        # test put with _method parameter and POST
        r = app.post('/things/1?_method=put', {'value': 'ONE!'}, status=404)
        assert r.status_int == 404

        # test get delete
        r = app.get('/things/1/delete', status=404)
        assert r.status_int == 404

        # test delete
        r = app.delete('/things/1', status=404)
        assert r.status_int == 404

        # test delete with _method parameter and GET
        r = app.get('/things/1?_method=DELETE', status=405)
        assert r.status_int == 405

        # test delete with _method parameter and POST
        r = app.post('/things/1?_method=DELETE', status=404)
        assert r.status_int == 404

        # test "RESET" custom action
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            r = app.request('/things', method='RESET', status=404)
            assert r.status_int == 404

    def test_nested_rest_with_missing_intermediate_id(self):

        class BarsController(RestController):

            data = [['zero-zero', 'zero-one'], ['one-zero', 'one-one']]

            @expose('json')
            def get_all(self, foo_id):
                return dict(items=self.data[int(foo_id)])

        class FoosController(RestController):

            data = ['zero', 'one']

            bars = BarsController()

            @expose()
            def get_one(self, id):
                return self.data[int(id)]

            @expose('json')
            def get_all(self):
                return dict(items=self.data)

        class RootController(object):
            foos = FoosController()

        # create the app
        app = TestApp(make_app(RootController()))

        # test get_all
        r = app.get('/foos')
        assert r.status_int == 200
        assert r.body == b_(dumps(dict(items=FoosController.data)))

        # test nested get_all
        r = app.get('/foos/1/bars')
        assert r.status_int == 200
        assert r.body == b_(dumps(dict(items=BarsController.data[1])))

        r = app.get('/foos/bars', expect_errors=True)
        assert r.status_int == 404

    def test_custom_with_trailing_slash(self):

        class CustomController(RestController):

            _custom_actions = {
                'detail': ['GET'],
                'create': ['POST'],
                'update': ['PUT'],
                'remove': ['DELETE'],
            }

            @expose()
            def detail(self):
                return 'DETAIL'

            @expose()
            def create(self):
                return 'CREATE'

            @expose()
            def update(self, id):
                return id

            @expose()
            def remove(self, id):
                return id

        app = TestApp(make_app(CustomController()))

        r = app.get('/detail')
        assert r.status_int == 200
        assert r.body == b_('DETAIL')

        r = app.get('/detail/')
        assert r.status_int == 200
        assert r.body == b_('DETAIL')

        r = app.post('/create')
        assert r.status_int == 200
        assert r.body == b_('CREATE')

        r = app.post('/create/')
        assert r.status_int == 200
        assert r.body == b_('CREATE')

        r = app.put('/update/123')
        assert r.status_int == 200
        assert r.body == b_('123')

        r = app.put('/update/123/')
        assert r.status_int == 200
        assert r.body == b_('123')

        r = app.delete('/remove/456')
        assert r.status_int == 200
        assert r.body == b_('456')

        r = app.delete('/remove/456/')
        assert r.status_int == 200
        assert r.body == b_('456')

    def test_custom_delete(self):

        class OthersController(object):

            @expose()
            def index(self):
                return 'DELETE'

            @expose()
            def reset(self, id):
                return str(id)

        class ThingsController(RestController):

            others = OthersController()

            @expose()
            def delete_fail(self):
                abort(500)

        class RootController(object):
            things = ThingsController()

        # create the app
        app = TestApp(make_app(RootController()))

        # test bad delete
        r = app.delete('/things/delete_fail', status=405)
        assert r.status_int == 405

        # test bad delete with _method parameter and GET
        r = app.get('/things/delete_fail?_method=delete', status=405)
        assert r.status_int == 405

        # test bad delete with _method parameter and POST
        r = app.post('/things/delete_fail', {'_method': 'delete'}, status=405)
        assert r.status_int == 405

        # test custom delete without ID
        r = app.delete('/things/others/')
        assert r.status_int == 200
        assert r.body == b_('DELETE')

        # test custom delete without ID with _method parameter and GET
        r = app.get('/things/others/?_method=delete', status=405)
        assert r.status_int == 405

        # test custom delete without ID with _method parameter and POST
        r = app.post('/things/others/', {'_method': 'delete'})
        assert r.status_int == 200
        assert r.body == b_('DELETE')

        # test custom delete with ID
        r = app.delete('/things/others/reset/1')
        assert r.status_int == 200
        assert r.body == b_('1')

        # test custom delete with ID with _method parameter and GET
        r = app.get('/things/others/reset/1?_method=delete', status=405)
        assert r.status_int == 405

        # test custom delete with ID with _method parameter and POST
        r = app.post('/things/others/reset/1', {'_method': 'delete'})
        assert r.status_int == 200
        assert r.body == b_('1')

    def test_get_with_var_args(self):

        class OthersController(object):

            @expose()
            def index(self, one, two, three):
                return 'NESTED: %s, %s, %s' % (one, two, three)

        class ThingsController(RestController):

            others = OthersController()

            @expose()
            def get_one(self, *args):
                return ', '.join(args)

        class RootController(object):
            things = ThingsController()

        # create the app
        app = TestApp(make_app(RootController()))

        # test get request
        r = app.get('/things/one/two/three')
        assert r.status_int == 200
        assert r.body == b_('one, two, three')

        # test nested get request
        r = app.get('/things/one/two/three/others/')
        assert r.status_int == 200
        assert r.body == b_('NESTED: one, two, three')

    def test_sub_nested_rest(self):

        class BazsController(RestController):

            data = [[['zero-zero-zero']]]

            @expose()
            def get_one(self, foo_id, bar_id, id):
                return self.data[int(foo_id)][int(bar_id)][int(id)]

        class BarsController(RestController):

            data = [['zero-zero']]

            bazs = BazsController()

            @expose()
            def get_one(self, foo_id, id):
                return self.data[int(foo_id)][int(id)]

        class FoosController(RestController):

            data = ['zero']

            bars = BarsController()

            @expose()
            def get_one(self, id):
                return self.data[int(id)]

        class RootController(object):
            foos = FoosController()

        # create the app
        app = TestApp(make_app(RootController()))

        # test sub-nested get_one
        r = app.get('/foos/0/bars/0/bazs/0')
        assert r.status_int == 200
        assert r.body == b_('zero-zero-zero')

    def test_sub_nested_rest_with_overwrites(self):

        class FinalController(object):

            @expose()
            def index(self):
                return 'FINAL'

            @expose()
            def named(self):
                return 'NAMED'

        class BazsController(RestController):

            data = [[['zero-zero-zero']]]

            final = FinalController()

            @expose()
            def get_one(self, foo_id, bar_id, id):
                return self.data[int(foo_id)][int(bar_id)][int(id)]

            @expose()
            def post(self):
                return 'POST-GRAND-CHILD'

            @expose()
            def put(self, id):
                return 'PUT-GRAND-CHILD'

        class BarsController(RestController):

            data = [['zero-zero']]

            bazs = BazsController()

            @expose()
            def get_one(self, foo_id, id):
                return self.data[int(foo_id)][int(id)]

            @expose()
            def post(self):
                return 'POST-CHILD'

            @expose()
            def put(self, id):
                return 'PUT-CHILD'

        class FoosController(RestController):

            data = ['zero']

            bars = BarsController()

            @expose()
            def get_one(self, id):
                return self.data[int(id)]

            @expose()
            def post(self):
                return 'POST'

            @expose()
            def put(self, id):
                return 'PUT'

        class RootController(object):
            foos = FoosController()

        # create the app
        app = TestApp(make_app(RootController()))

        r = app.post('/foos')
        assert r.status_int == 200
        assert r.body == b_('POST')

        r = app.put('/foos/0')
        assert r.status_int == 200
        assert r.body == b_('PUT')

        r = app.post('/foos/bars')
        assert r.status_int == 200
        assert r.body == b_('POST-CHILD')

        r = app.put('/foos/bars/0')
        assert r.status_int == 200
        assert r.body == b_('PUT-CHILD')

        r = app.post('/foos/bars/bazs')
        assert r.status_int == 200
        assert r.body == b_('POST-GRAND-CHILD')

        r = app.put('/foos/bars/bazs/0')
        assert r.status_int == 200
        assert r.body == b_('PUT-GRAND-CHILD')

        r = app.get('/foos/bars/bazs/final/')
        assert r.status_int == 200
        assert r.body == b_('FINAL')

        r = app.get('/foos/bars/bazs/final/named')
        assert r.status_int == 200
        assert r.body == b_('NAMED')

    def test_post_with_kwargs_only(self):

        class RootController(RestController):

            @expose()
            def get_all(self):
                return 'INDEX'

            @expose('json')
            def post(self, **kw):
                return kw

        # create the app
        app = TestApp(make_app(RootController()))

        r = app.get('/')
        assert r.status_int == 200
        assert r.body == b_('INDEX')

        kwargs = {'foo': 'bar', 'spam': 'eggs'}
        r = app.post('/', kwargs)
        assert r.status_int == 200
        assert r.namespace['foo'] == 'bar'
        assert r.namespace['spam'] == 'eggs'

    def test_nested_rest_with_lookup(self):

        class SubController(RestController):

            @expose()
            def get_all(self):
                return "SUB"

        class FinalController(RestController):

            def __init__(self, id_):
                self.id_ = id_

            @expose()
            def get_all(self):
                return "FINAL-%s" % self.id_

            @expose()
            def post(self):
                return "POST-%s" % self.id_

        class LookupController(RestController):

            sub = SubController()

            def __init__(self, id_):
                self.id_ = id_

            @expose()
            def _lookup(self, id_, *remainder):
                return FinalController(id_), remainder

            @expose()
            def get_all(self):
                raise AssertionError("Never Reached")

            @expose()
            def post(self):
                return "POST-LOOKUP-%s" % self.id_

            @expose()
            def put(self, id_):
                return "PUT-LOOKUP-%s-%s" % (self.id_, id_)

            @expose()
            def delete(self, id_):
                return "DELETE-LOOKUP-%s-%s" % (self.id_, id_)

        class FooController(RestController):

            @expose()
            def _lookup(self, id_, *remainder):
                return LookupController(id_), remainder

            @expose()
            def get_one(self, id_):
                return "GET ONE"

            @expose()
            def get_all(self):
                return "INDEX"

            @expose()
            def post(self):
                return "POST"

            @expose()
            def put(self, id_):
                return "PUT-%s" % id_

            @expose()
            def delete(self, id_):
                return "DELETE-%s" % id_

        class RootController(RestController):
            foo = FooController()

        app = TestApp(make_app(RootController()))

        r = app.get('/foo')
        assert r.status_int == 200
        assert r.body == b_('INDEX')

        r = app.post('/foo')
        assert r.status_int == 200
        assert r.body == b_('POST')

        r = app.get('/foo/1')
        assert r.status_int == 200
        assert r.body == b_('GET ONE')

        r = app.post('/foo/1')
        assert r.status_int == 200
        assert r.body == b_('POST-LOOKUP-1')

        r = app.put('/foo/1')
        assert r.status_int == 200
        assert r.body == b_('PUT-1')

        r = app.delete('/foo/1')
        assert r.status_int == 200
        assert r.body == b_('DELETE-1')

        r = app.put('/foo/1/2')
        assert r.status_int == 200
        assert r.body == b_('PUT-LOOKUP-1-2')

        r = app.delete('/foo/1/2')
        assert r.status_int == 200
        assert r.body == b_('DELETE-LOOKUP-1-2')

        r = app.get('/foo/1/2')
        assert r.status_int == 200
        assert r.body == b_('FINAL-2')

        r = app.post('/foo/1/2')
        assert r.status_int == 200
        assert r.body == b_('POST-2')

    def test_nested_rest_with_default(self):

        class FooController(RestController):

            @expose()
            def _default(self, *remainder):
                return "DEFAULT %s" % remainder

        class RootController(RestController):
            foo = FooController()

        app = TestApp(make_app(RootController()))

        r = app.get('/foo/missing')
        assert r.status_int == 200
        assert r.body == b_("DEFAULT missing")

    def test_dynamic_rest_lookup(self):
        class BarController(RestController):
            @expose()
            def get_all(self):
                return "BAR"

            @expose()
            def put(self):
                return "PUT_BAR"

            @expose()
            def delete(self):
                return "DELETE_BAR"

        class BarsController(RestController):
            @expose()
            def _lookup(self, id_, *remainder):
                return BarController(), remainder

            @expose()
            def get_all(self):
                return "BARS"

            @expose()
            def post(self):
                return "POST_BARS"

        class FooController(RestController):
            bars = BarsController()

            @expose()
            def get_all(self):
                return "FOO"

            @expose()
            def put(self):
                return "PUT_FOO"

            @expose()
            def delete(self):
                return "DELETE_FOO"

        class FoosController(RestController):
            @expose()
            def _lookup(self, id_, *remainder):
                return FooController(), remainder

            @expose()
            def get_all(self):
                return "FOOS"

            @expose()
            def post(self):
                return "POST_FOOS"

        class RootController(RestController):
            foos = FoosController()

        app = TestApp(make_app(RootController()))

        r = app.get('/foos')
        assert r.status_int == 200
        assert r.body == b_('FOOS')

        r = app.post('/foos')
        assert r.status_int == 200
        assert r.body == b_('POST_FOOS')

        r = app.get('/foos/foo')
        assert r.status_int == 200
        assert r.body == b_('FOO')

        r = app.put('/foos/foo')
        assert r.status_int == 200
        assert r.body == b_('PUT_FOO')

        r = app.delete('/foos/foo')
        assert r.status_int == 200
        assert r.body == b_('DELETE_FOO')

        r = app.get('/foos/foo/bars')
        assert r.status_int == 200
        assert r.body == b_('BARS')

        r = app.post('/foos/foo/bars')
        assert r.status_int == 200
        assert r.body == b_('POST_BARS')

        r = app.get('/foos/foo/bars/bar')
        assert r.status_int == 200
        assert r.body == b_('BAR')

        r = app.put('/foos/foo/bars/bar')
        assert r.status_int == 200
        assert r.body == b_('PUT_BAR')

        r = app.delete('/foos/foo/bars/bar')
        assert r.status_int == 200
        assert r.body == b_('DELETE_BAR')

########NEW FILE########
__FILENAME__ = test_scaffolds
import os
import sys
import tempfile
import shutil

from six.moves import cStringIO as StringIO

from pecan.tests import PecanTestCase

if sys.version_info < (2, 7):
    import unittest2 as unittest
else:
    import unittest  # noqa


class TestPecanScaffold(PecanTestCase):

    def test_normalize_pkg_name(self):
        from pecan.scaffolds import PecanScaffold
        s = PecanScaffold()
        assert s.normalize_pkg_name('sam') == 'sam'
        assert s.normalize_pkg_name('sam1') == 'sam1'
        assert s.normalize_pkg_name('sam_') == 'sam_'
        assert s.normalize_pkg_name('Sam') == 'sam'
        assert s.normalize_pkg_name('SAM') == 'sam'
        assert s.normalize_pkg_name('sam ') == 'sam'
        assert s.normalize_pkg_name(' sam') == 'sam'
        assert s.normalize_pkg_name('sam$') == 'sam'
        assert s.normalize_pkg_name('sam-sam') == 'samsam'


class TestScaffoldUtils(PecanTestCase):

    def setUp(self):
        super(TestScaffoldUtils, self).setUp()
        self.scaffold_destination = tempfile.mkdtemp()
        self.out = sys.stdout

        sys.stdout = StringIO()

    def tearDown(self):
        shutil.rmtree(self.scaffold_destination)
        sys.stdout = self.out

    def test_copy_dir(self):
        from pecan.scaffolds import PecanScaffold

        class SimpleScaffold(PecanScaffold):
            _scaffold_dir = ('pecan', os.path.join(
                'tests', 'scaffold_fixtures', 'simple'
            ))

        SimpleScaffold().copy_to(os.path.join(
            self.scaffold_destination,
            'someapp'
        ), out_=StringIO())

        assert os.path.isfile(os.path.join(
            self.scaffold_destination, 'someapp', 'foo'
        ))
        assert os.path.isfile(os.path.join(
            self.scaffold_destination, 'someapp', 'bar', 'spam.txt'
        ))
        assert open(os.path.join(
            self.scaffold_destination, 'someapp', 'foo'
        ), 'r').read().strip() == 'YAR'
        assert open(os.path.join(
            self.scaffold_destination, 'someapp', 'foo'
        ), 'r').read().strip() == 'YAR'

    def test_destination_directory_levels_deep(self):
        from pecan.scaffolds import copy_dir
        f = StringIO()
        copy_dir(
            (
                'pecan', os.path.join('tests', 'scaffold_fixtures', 'simple')
            ),
            os.path.join(self.scaffold_destination, 'some', 'app'),
            {},
            out_=f
        )

        assert os.path.isfile(os.path.join(
            self.scaffold_destination, 'some', 'app', 'foo')
        )
        assert os.path.isfile(os.path.join(
            self.scaffold_destination, 'some', 'app', 'bar', 'spam.txt')
        )
        assert open(os.path.join(
            self.scaffold_destination, 'some', 'app', 'foo'
        ), 'r').read().strip() == 'YAR'
        assert open(os.path.join(
            self.scaffold_destination, 'some', 'app', 'bar', 'spam.txt'
        ), 'r').read().strip() == 'Pecan'

    def test_destination_directory_already_exists(self):
        from pecan.scaffolds import copy_dir
        f = StringIO()
        copy_dir(
            (
                'pecan', os.path.join('tests', 'scaffold_fixtures', 'simple')
            ),
            os.path.join(self.scaffold_destination),
            {},
            out_=f
        )
        assert 'already exists' in f.getvalue()

    def test_copy_dir_with_filename_substitution(self):
        from pecan.scaffolds import copy_dir
        copy_dir(
            (
                'pecan', os.path.join('tests', 'scaffold_fixtures', 'file_sub')
            ),
            os.path.join(
                self.scaffold_destination, 'someapp'
            ),
            {'package': 'thingy'},
            out_=StringIO()
        )

        assert os.path.isfile(os.path.join(
            self.scaffold_destination, 'someapp', 'foo_thingy')
        )
        assert os.path.isfile(os.path.join(
            self.scaffold_destination, 'someapp', 'bar_thingy', 'spam.txt')
        )
        assert open(os.path.join(
            self.scaffold_destination, 'someapp', 'foo_thingy'
        ), 'r').read().strip() == 'YAR'
        assert open(os.path.join(
            self.scaffold_destination, 'someapp', 'bar_thingy', 'spam.txt'
        ), 'r').read().strip() == 'Pecan'

    def test_copy_dir_with_file_content_substitution(self):
        from pecan.scaffolds import copy_dir
        copy_dir(
            (
                'pecan',
                os.path.join('tests', 'scaffold_fixtures', 'content_sub'),
            ),
            os.path.join(
                self.scaffold_destination, 'someapp'
            ),
            {'package': 'thingy'},
            out_=StringIO()
        )

        assert os.path.isfile(os.path.join(
            self.scaffold_destination, 'someapp', 'foo')
        )
        assert os.path.isfile(os.path.join(
            self.scaffold_destination, 'someapp', 'bar', 'spam.txt')
        )
        assert open(os.path.join(
            self.scaffold_destination, 'someapp', 'foo'
        ), 'r').read().strip() == 'YAR thingy'
        assert open(os.path.join(
            self.scaffold_destination, 'someapp', 'bar', 'spam.txt'
        ), 'r').read().strip() == 'Pecan thingy'

########NEW FILE########
__FILENAME__ = test_secure
import sys

if sys.version_info < (2, 7):
    import unittest2 as unittest
else:
    import unittest  # noqa

from six import b as b_
from webtest import TestApp

from pecan import expose, make_app
from pecan.secure import secure, unlocked, SecureController
from pecan.tests import PecanTestCase

try:
    set()
except:
    from sets import Set as set


class TestSecure(PecanTestCase):
    def test_simple_secure(self):
        authorized = False

        class SecretController(SecureController):
            @expose()
            def index(self):
                return 'Index'

            @expose()
            @unlocked
            def allowed(self):
                return 'Allowed!'

            @classmethod
            def check_permissions(cls):
                return authorized

        class RootController(object):
            @expose()
            def index(self):
                return 'Hello, World!'

            @expose()
            @secure(lambda: False)
            def locked(self):
                return 'No dice!'

            @expose()
            @secure(lambda: True)
            def unlocked(self):
                return 'Sure thing'

            secret = SecretController()

        app = TestApp(make_app(
            RootController(),
            debug=True,
            static_root='tests/static'
        ))
        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        response = app.get('/unlocked')
        assert response.status_int == 200
        assert response.body == b_('Sure thing')

        response = app.get('/locked', expect_errors=True)
        assert response.status_int == 401

        response = app.get('/secret/', expect_errors=True)
        assert response.status_int == 401

        response = app.get('/secret/allowed')
        assert response.status_int == 200
        assert response.body == b_('Allowed!')

    def test_unlocked_attribute(self):
        class AuthorizedSubController(object):
            @expose()
            def index(self):
                return 'Index'

            @expose()
            def allowed(self):
                return 'Allowed!'

        class SecretController(SecureController):
            @expose()
            def index(self):
                return 'Index'

            @expose()
            @unlocked
            def allowed(self):
                return 'Allowed!'

            authorized = unlocked(AuthorizedSubController())

        class RootController(object):
            @expose()
            def index(self):
                return 'Hello, World!'

            @expose()
            @secure(lambda: False)
            def locked(self):
                return 'No dice!'

            @expose()
            @secure(lambda: True)
            def unlocked(self):
                return 'Sure thing'

            secret = SecretController()

        app = TestApp(make_app(
            RootController(),
            debug=True,
            static_root='tests/static'
        ))
        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Hello, World!')

        response = app.get('/unlocked')
        assert response.status_int == 200
        assert response.body == b_('Sure thing')

        response = app.get('/locked', expect_errors=True)
        assert response.status_int == 401

        response = app.get('/secret/', expect_errors=True)
        assert response.status_int == 401

        response = app.get('/secret/allowed')
        assert response.status_int == 200
        assert response.body == b_('Allowed!')

        response = app.get('/secret/authorized/')
        assert response.status_int == 200
        assert response.body == b_('Index')

        response = app.get('/secret/authorized/allowed')
        assert response.status_int == 200
        assert response.body == b_('Allowed!')

    def test_secure_attribute(self):
        authorized = False

        class SubController(object):
            @expose()
            def index(self):
                return 'Hello from sub!'

        class RootController(object):
            @expose()
            def index(self):
                return 'Hello from root!'

            sub = secure(SubController(), lambda: authorized)

        app = TestApp(make_app(RootController()))
        response = app.get('/')
        assert response.status_int == 200
        assert response.body == b_('Hello from root!')

        response = app.get('/sub/', expect_errors=True)
        assert response.status_int == 401

        authorized = True
        response = app.get('/sub/')
        assert response.status_int == 200
        assert response.body == b_('Hello from sub!')

    def test_secured_generic_controller(self):
        authorized = False

        class RootController(object):

            @classmethod
            def check_permissions(cls):
                return authorized

            @expose(generic=True)
            def index(self):
                return 'Index'

            @secure('check_permissions')
            @index.when(method='POST')
            def index_post(self):
                return 'I should not be allowed'

            @secure('check_permissions')
            @expose(generic=True)
            def secret(self):
                return 'I should not be allowed'

        app = TestApp(make_app(
            RootController(),
            debug=True,
            static_root='tests/static'
        ))
        response = app.get('/')
        assert response.status_int == 200
        response = app.post('/', expect_errors=True)
        assert response.status_int == 401
        response = app.get('/secret/', expect_errors=True)
        assert response.status_int == 401

    def test_secured_generic_controller_lambda(self):
        authorized = False

        class RootController(object):

            @expose(generic=True)
            def index(self):
                return 'Index'

            @secure(lambda: authorized)
            @index.when(method='POST')
            def index_post(self):
                return 'I should not be allowed'

            @secure(lambda: authorized)
            @expose(generic=True)
            def secret(self):
                return 'I should not be allowed'

        app = TestApp(make_app(
            RootController(),
            debug=True,
            static_root='tests/static'
        ))
        response = app.get('/')
        assert response.status_int == 200
        response = app.post('/', expect_errors=True)
        assert response.status_int == 401
        response = app.get('/secret/', expect_errors=True)
        assert response.status_int == 401

    def test_secured_generic_controller_secure_attribute(self):
        authorized = False

        class SecureController(object):

            @expose(generic=True)
            def index(self):
                return 'I should not be allowed'

            @index.when(method='POST')
            def index_post(self):
                return 'I should not be allowed'

            @expose(generic=True)
            def secret(self):
                return 'I should not be allowed'

        class RootController(object):
            sub = secure(SecureController(), lambda: authorized)

        app = TestApp(make_app(
            RootController(),
            debug=True,
            static_root='tests/static'
        ))
        response = app.get('/sub/', expect_errors=True)
        assert response.status_int == 401
        response = app.post('/sub/', expect_errors=True)
        assert response.status_int == 401
        response = app.get('/sub/secret/', expect_errors=True)
        assert response.status_int == 401

    def test_secured_generic_controller_secure_attribute_with_unlocked(self):

        class RootController(SecureController):

            @unlocked
            @expose(generic=True)
            def index(self):
                return 'Unlocked!'

            @unlocked
            @index.when(method='POST')
            def index_post(self):
                return 'Unlocked!'

            @expose(generic=True)
            def secret(self):
                return 'I should not be allowed'

        app = TestApp(make_app(
            RootController(),
            debug=True,
            static_root='tests/static'
        ))
        response = app.get('/')
        assert response.status_int == 200
        response = app.post('/')
        assert response.status_int == 200
        response = app.get('/secret/', expect_errors=True)
        assert response.status_int == 401

    def test_state_attribute(self):
        from pecan.secure import Any, Protected
        assert repr(Any) == '<SecureState Any>'
        assert bool(Any) is False

        assert repr(Protected) == '<SecureState Protected>'
        assert bool(Protected) is True

    def test_secure_obj_only_failure(self):
        class Foo(object):
            pass

        try:
            secure(Foo())
        except Exception as e:
            assert isinstance(e, TypeError)


class TestObjectPathSecurity(PecanTestCase):

    def setUp(self):
        super(TestObjectPathSecurity, self).setUp()
        permissions_checked = set()

        class DeepSecretController(SecureController):
            authorized = False

            @expose()
            @unlocked
            def _lookup(self, someID, *remainder):
                if someID == 'notfound':
                    return None
                return SubController(someID), remainder

            @expose()
            def index(self):
                return 'Deep Secret'

            @classmethod
            def check_permissions(cls):
                permissions_checked.add('deepsecret')
                return cls.authorized

        class SubController(object):
            def __init__(self, myID):
                self.myID = myID

            @expose()
            def index(self):
                return 'Index %s' % self.myID

            deepsecret = DeepSecretController()

        class SecretController(SecureController):
            authorized = False
            independent_authorization = False

            @expose()
            def _lookup(self, someID, *remainder):
                if someID == 'notfound':
                    return None
                elif someID == 'lookup_wrapped':
                    return self.wrapped, remainder
                return SubController(someID), remainder

            @secure('independent_check_permissions')
            @expose()
            def independent(self):
                return 'Independent Security'

            wrapped = secure(
                SubController('wrapped'), 'independent_check_permissions'
            )

            @classmethod
            def check_permissions(cls):
                permissions_checked.add('secretcontroller')
                return cls.authorized

            @classmethod
            def independent_check_permissions(cls):
                permissions_checked.add('independent')
                return cls.independent_authorization

        class NotSecretController(object):
            @expose()
            def _lookup(self, someID, *remainder):
                if someID == 'notfound':
                    return None
                return SubController(someID), remainder

            unlocked = unlocked(SubController('unlocked'))

        class RootController(object):
            secret = SecretController()
            notsecret = NotSecretController()

        self.deepsecret_cls = DeepSecretController
        self.secret_cls = SecretController

        self.permissions_checked = permissions_checked
        self.app = TestApp(make_app(
            RootController(),
            debug=True,
            static_root='tests/static'
        ))

    def tearDown(self):
        self.permissions_checked.clear()
        self.secret_cls.authorized = False
        self.deepsecret_cls.authorized = False

    def test_sub_of_both_not_secret(self):
        response = self.app.get('/notsecret/hi/')
        assert response.status_int == 200
        assert response.body == b_('Index hi')

    def test_protected_lookup(self):
        response = self.app.get('/secret/hi/', expect_errors=True)
        assert response.status_int == 401

        self.secret_cls.authorized = True
        response = self.app.get('/secret/hi/')
        assert response.status_int == 200
        assert response.body == b_('Index hi')
        assert 'secretcontroller' in self.permissions_checked

    def test_secured_notfound_lookup(self):
        response = self.app.get('/secret/notfound/', expect_errors=True)
        assert response.status_int == 404

    def test_secret_through_lookup(self):
        response = self.app.get(
            '/notsecret/hi/deepsecret/', expect_errors=True
        )
        assert response.status_int == 401

    def test_layered_protection(self):
        response = self.app.get('/secret/hi/deepsecret/', expect_errors=True)
        assert response.status_int == 401
        assert 'secretcontroller' in self.permissions_checked

        self.secret_cls.authorized = True
        response = self.app.get('/secret/hi/deepsecret/', expect_errors=True)
        assert response.status_int == 401
        assert 'secretcontroller' in self.permissions_checked
        assert 'deepsecret' in self.permissions_checked

        self.deepsecret_cls.authorized = True
        response = self.app.get('/secret/hi/deepsecret/')
        assert response.status_int == 200
        assert response.body == b_('Deep Secret')
        assert 'secretcontroller' in self.permissions_checked
        assert 'deepsecret' in self.permissions_checked

    def test_cyclical_protection(self):
        self.secret_cls.authorized = True
        self.deepsecret_cls.authorized = True
        response = self.app.get('/secret/1/deepsecret/2/deepsecret/')
        assert response.status_int == 200
        assert response.body == b_('Deep Secret')
        assert 'secretcontroller' in self.permissions_checked
        assert 'deepsecret' in self.permissions_checked

    def test_unlocked_lookup(self):
        response = self.app.get('/notsecret/1/deepsecret/2/')
        assert response.status_int == 200
        assert response.body == b_('Index 2')
        assert 'deepsecret' not in self.permissions_checked

        response = self.app.get(
            '/notsecret/1/deepsecret/notfound/', expect_errors=True
        )
        assert response.status_int == 404
        assert 'deepsecret' not in self.permissions_checked

    def test_mixed_protection(self):
        self.secret_cls.authorized = True
        response = self.app.get(
            '/secret/1/deepsecret/notfound/', expect_errors=True
        )
        assert response.status_int == 404
        assert 'secretcontroller' in self.permissions_checked
        assert 'deepsecret' not in self.permissions_checked

    def test_independent_check_failure(self):
        response = self.app.get('/secret/independent/', expect_errors=True)
        assert response.status_int == 401
        assert len(self.permissions_checked) == 1
        assert 'independent' in self.permissions_checked

    def test_independent_check_success(self):
        self.secret_cls.independent_authorization = True
        response = self.app.get('/secret/independent')
        assert response.status_int == 200
        assert response.body == b_('Independent Security')
        assert len(self.permissions_checked) == 1
        assert 'independent' in self.permissions_checked

    def test_wrapped_attribute_failure(self):
        self.secret_cls.independent_authorization = False
        response = self.app.get('/secret/wrapped/', expect_errors=True)
        assert response.status_int == 401
        assert len(self.permissions_checked) == 1
        assert 'independent' in self.permissions_checked

    def test_wrapped_attribute_success(self):
        self.secret_cls.independent_authorization = True
        response = self.app.get('/secret/wrapped/')
        assert response.status_int == 200
        assert response.body == b_('Index wrapped')
        assert len(self.permissions_checked) == 1
        assert 'independent' in self.permissions_checked

    def test_lookup_to_wrapped_attribute_on_self(self):
        self.secret_cls.authorized = True
        self.secret_cls.independent_authorization = True
        response = self.app.get('/secret/lookup_wrapped/')
        assert response.status_int == 200
        assert response.body == b_('Index wrapped')
        assert len(self.permissions_checked) == 2
        assert 'independent' in self.permissions_checked
        assert 'secretcontroller' in self.permissions_checked

    def test_unlocked_attribute_in_insecure(self):
        response = self.app.get('/notsecret/unlocked/')
        assert response.status_int == 200
        assert response.body == b_('Index unlocked')


class SecureControllerSharedPermissionsRegression(PecanTestCase):
    """Regression tests for https://github.com/dreamhost/pecan/issues/131"""

    def setUp(self):
        super(SecureControllerSharedPermissionsRegression, self).setUp()

        class Parent(object):
            @expose()
            def index(self):
                return 'hello'

        class UnsecuredChild(Parent):
            pass

        class SecureChild(Parent, SecureController):
            @classmethod
            def check_permissions(cls):
                return False

        class RootController(object):

            secured = SecureChild()
            unsecured = UnsecuredChild()

        self.app = TestApp(make_app(RootController()))

    def test_inherited_security(self):
        assert self.app.get('/secured/', status=401).status_int == 401
        assert self.app.get('/unsecured/').status_int == 200

########NEW FILE########
__FILENAME__ = test_templating
import tempfile

from six import b as b_

from pecan.templating import RendererFactory, format_line_context
from pecan.tests import PecanTestCase


class TestTemplate(PecanTestCase):
    def setUp(self):
        super(TestTemplate, self).setUp()
        self.rf = RendererFactory()

    def test_available(self):
        self.assertTrue(self.rf.available('json'))
        self.assertFalse(self.rf.available('badrenderer'))

    def test_create_bad(self):
        self.assertEqual(self.rf.get('doesnotexist', '/'), None)

    def test_extra_vars(self):
        extra_vars = self.rf.extra_vars
        self.assertEqual(extra_vars.make_ns({}), {})

        extra_vars.update({'foo': 1})
        self.assertEqual(extra_vars.make_ns({}), {'foo': 1})

    def test_update_extra_vars(self):
        extra_vars = self.rf.extra_vars
        extra_vars.update({'foo': 1})

        self.assertEqual(extra_vars.make_ns({'bar': 2}), {'foo': 1, 'bar': 2})
        self.assertEqual(extra_vars.make_ns({'foo': 2}), {'foo': 2})


class TestTemplateLineFormat(PecanTestCase):

    def setUp(self):
        super(TestTemplateLineFormat, self).setUp()
        self.f = tempfile.NamedTemporaryFile()

    def tearDown(self):
        del self.f

    def test_format_line_context(self):
        for i in range(11):
            self.f.write(b_('Testing Line %d\n' % i))
        self.f.flush()

        assert format_line_context(self.f.name, 0).count('Testing Line') == 10

########NEW FILE########
__FILENAME__ = util
import sys


def iscontroller(obj):
    return getattr(obj, 'exposed', False)


def _cfg(f):
    if not hasattr(f, '_pecan'):
        f._pecan = {}
    return f._pecan


if sys.version_info >= (2, 6, 5):
    def encode_if_needed(s):
        return s
else:
    def encode_if_needed(s):  # noqa
        return s.encode('utf-8')

########NEW FILE########
