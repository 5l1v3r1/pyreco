__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-locking documentation build configuration file, created by
# sphinx-quickstart on Fri May 28 11:02:44 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
os.environ['DJANGO_SETTINGS_MODULE'] = 'django.conf.global_settings'

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.coverage']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-locking'
copyright = u'2010, Stijn Debrouwere'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.3'
# The full version, including alpha/beta/rc tags.
release = '0.3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'tango'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-lockingdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-locking.tex', u'django-locking Documentation',
   u'Stijn Debrouwere', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = admin
# encoding: utf-8

from datetime import datetime

from django.contrib import admin
from django.conf import settings
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _
from django import forms

from locking import LOCK_TIMEOUT, views

class LockableAdmin(admin.ModelAdmin):
    @property
    def media(self):
        # because reverse() doesn't yet work when this module is first loaded
        # (the urlconf still has to load at that point) the media definition
        # has to be dynamic, and we can't simply add a Media class to the
        # ModelAdmin as you usually would.
        #
        # Doing so would result in an ImproperlyConfigured exception, stating
        # "The included urlconf doesn't have any patterns in it."
        # 
        # See http://docs.djangoproject.com/en/dev/topics/forms/media/#media-as-a-dynamic-property
        # for more information about dynamic media definitions.
        
        css = {
            'all': ('locking/css/locking.css',)
            }
        js = (
            'http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js', 
            'locking/js/jquery.url.packed.js',
            #reverse('django.views.i18n.javascript_catalog'),
            reverse('locking_variables'),
            'locking/js/admin.locking.js',
            )
        
        return forms.Media(css=css, js=js)
    
    def changelist_view(self, request, extra_context=None):
        # we need the request objects in a few places where it's usually not present, 
        # so we're tacking it on to the LockableAdmin class
        self.request = request
        return super(LockableAdmin, self).changelist_view(request, extra_context)

    def save_model(self, request, obj, form, change):
        # object creation doesn't need/have locking in place
        if obj.pk:
            obj.unlock_for(request.user)
        obj.save()
        
    def lock(self, obj):
        if obj.is_locked:
            seconds_remaining = obj.lock_seconds_remaining
            minutes_remaining = seconds_remaining/60
            locked_until = _("Still locked for %s minutes by %s") \
                % (minutes_remaining, obj.locked_by)
            if self.request.user == obj.locked_by: 
                locked_until_self = _("You have a lock on this article for %s more minutes.") \
                    % (minutes_remaining)
                return '<img src="%slocking/img/page_edit.png" title="%s" />' \
                    % (settings.MEDIA_URL, locked_until_self)
            else:
                locked_until = _("Still locked for %s minutes by %s") \
                    % (minutes_remaining, obj.locked_by)
                return '<img src="%slocking/img/lock.png" title="%s" />' \
                    % (settings.MEDIA_URL, locked_until)

        else:
            return ''
    lock.allow_tags = True
    
    list_display = ('__str__', 'lock')
########NEW FILE########
__FILENAME__ = decorators
# encoding: utf-8

from django.http import HttpResponse
from django.contrib.contenttypes.models import ContentType

from locking.models import LockableModel
from locking import logger

def user_may_change_model(fn):
    def view(request, app, model, *vargs, **kwargs):
        may_change = '%s.change_%s' % (app, model)
        if not request.user.has_perm(may_change):
            return HttpResponse(status=401)
        else:
            return fn(request, app, model, *vargs, **kwargs)
            
    return view

def is_lockable(fn):
    def view(request, app, model, *vargs, **kwargs):
        try:
            cls = ContentType.objects.get(app_label=app, model=model).model_class()
            if issubclass(cls, LockableModel):
                lockable = True
            else:
                lockable = False
        except ContentType.DoesNotExist:
            lockable = False
            
        if lockable:
            return fn(request, app, model, *vargs, **kwargs)
        else:
            return HttpResponse(status=404)
    return view

def log(view):
    def decorated_view(*vargs, **kwargs):
        response = view(*vargs, **kwargs)
        logger.debug("Sending a request: \n\t%s" % (response.content))
        return response
    
    return decorated_view
########NEW FILE########
__FILENAME__ = managers
from django.db.models import Q, Manager
from locking import LOCK_TIMEOUT
import datetime

"""
    LOCKED
            if (datetime.today() - self.locked_at).seconds < LOCK_TIMEOUT:
            
            
            self.locked_at < (NOW - TIMEOUT)
"""

def point_of_timeout():
    delta = datetime.timedelta(seconds=LOCK_TIMEOUT)
    return datetime.datetime.now() - delta

class LockedManager(Manager):
    def get_query_set(self):
        timeout = point_of_timeout()
        return super(LockedManager, self).get_query_set().filter(_locked_at__gt=timeout, _locked_at__isnull=False)

class UnlockedManager(Manager):
    def get_query_set(self):
        timeout = point_of_timeout()
        return super(UnlockedManager, self).get_query_set().filter(Q(_locked_at__lte=timeout) | Q(_locked_at__isnull=True))
########NEW FILE########
__FILENAME__ = models
# encoding: utf-8

from datetime import datetime

from django.db import models
from django.conf import settings
from django.contrib.auth import models as auth

from locking import LOCK_TIMEOUT, logger
import managers

class ObjectLockedError(IOError):
    pass

class LockableModel(models.Model):
    """ LockableModel comes with three managers: ``objects``, ``locked`` and 
    ``unlocked``. They do what you'd expect them to. """

    objects = managers.Manager()
    locked = managers.LockedManager()
    unlocked = managers.UnlockedManager()

    def __init__(self, *vargs, **kwargs):
        super(LockableModel, self).__init__(*vargs, **kwargs)
        self._state.locking = False

    class Meta:
        abstract = True
        
    _locked_at = models.DateTimeField(db_column='locked_at', 
        null=True,
        editable=False)
    _locked_by = models.ForeignKey(auth.User, 
        db_column='locked_by',
        related_name="working_on_%(class)s",
        null=True,
        editable=False)
    _hard_lock = models.BooleanField(db_column='hard_lock', default=False, editable=False)
    
    # We don't want end-developers to manipulate database fields directly, 
    # hence we're putting these behind simple getters.
    # End-developers should use functionality like the lock_for method instead.
    @property
    def locked_at(self):
        """A simple ``DateTimeField`` that is the heart of the locking mechanism. Read-only."""
        return self._locked_at
    
    @property
    def locked_by(self):
        """``locked_by`` is a foreign key to ``auth.User``. The ``related_name`` on the 
        User object is ``working_on_%(class)s``. Read-only."""
        return self._locked_by
    
    @property
    def lock_type(self):
        """ Returns the type of lock that is currently active. Either
        ``hard``, ``soft`` or ``None``. Read-only. """
        if self.is_locked:
            if self._hard_lock:
                return "hard"
            else:
                return "soft"
        else:
            return None

    @property
    def is_locked(self):
        """
        A read-only property that returns True or False.
        Works by calculating if the last lock (self.locked_at) has timed out or not.
        """
        if isinstance(self.locked_at, datetime):
            if (datetime.today() - self.locked_at).seconds < LOCK_TIMEOUT:
                return True
            else:
                return False
        return False
    
    @property
    def lock_seconds_remaining(self):
        """
        A read-only property that returns the amount of seconds remaining before
        any existing lock times out.
        
        May or may not return a negative number if the object is currently unlocked.
        That number represents the amount of seconds since the last lock expired.
        
        If you want to extend a lock beyond its current expiry date, initiate a new
        lock using the ``lock_for`` method.
        """
        return LOCK_TIMEOUT - (datetime.today() - self.locked_at).seconds
    
    def lock_for(self, user, hard_lock=False):
        """
        Together with ``unlock_for`` this is probably the most important method 
        on this model. If applicable to your use-case, you should lock for a specific 
        user; that way, we can throw an exception when another user tries to unlock
        an object they haven't locked themselves.
        
        When using soft locks (the default), any process can still use the save method
        on this object. If you set ``hard_lock=True``, trying to save an object
        without first unlocking will raise an ``ObjectLockedError``.
        
        Don't use hard locks unless you really need them. See :doc:`design`.
        """
        logger.info("Attempting to initiate a lock for user `%s`" % user)

        if not isinstance(user, auth.User):
            raise ValueError("You should pass a valid auth.User to lock_for.")
        
        if self.lock_applies_to(user):
            raise ObjectLockedError("This object is already locked by another user. \
                May not override, except through the `unlock` method.")
        else:
            self._locked_at = datetime.today()
            self._locked_by = user
            self._hard_lock = self.__init_hard_lock = hard_lock
            date = self.locked_at.strftime("%H:%M:%S")
            # an administrative toggle, to make it easier for devs to extend `django-locking`
            # and react to locking and unlocking
            self._state.locking = True
            logger.info("Initiated a %s lock for `%s` at %s" % (self.lock_type, self.locked_by, self.locked_at))     

    def unlock(self):
        """
        This method serves solely to allow the application itself or admin users
        to do manual lock overrides, even if they haven't initiated these
        locks themselves. Otherwise, use ``unlock_for``.
        """
        self._locked_at = self._locked_by = None
        # an administrative toggle, to make it easier for devs to extend `django-locking`
        # and react to locking and unlocking
        self._state.locking = True
        logger.info("Disengaged lock on `%s`" % self)
    
    def unlock_for(self, user):
        """
        See ``lock_for``. If the lock was initiated for a specific user, 
        unlocking will fail unless that same user requested the unlocking. 
        Manual overrides should use the ``unlock`` method instead.
        
        Will raise a ObjectLockedError exception when the current user isn't authorized to
        unlock the object.
        """
        logger.info("Attempting to open up a lock on `%s` by user `%s`" % (self, user))
    
        # refactor: should raise exceptions instead
        if self.is_locked_by(user):
            self.unlock()
        else:
            raise ObjectLockedError("Trying to unlock for another user than the one who initiated the currently active lock. This is not allowed. You may want to try a manual override through the `unlock` method instead.")
    
    def lock_applies_to(self, user):
        """
        A lock does not apply to the user who initiated the lock. Thus, 
        ``lock_applies_to`` is used to ascertain whether a user is allowed
        to edit a locked object.
        """
        logger.info("Checking if the lock on `%s` applies to user `%s`" % (self, user))
        # a lock does not apply to the person who initiated the lock
        if self.is_locked and self.locked_by != user:
            logger.info("Lock applies.")
            return True
        else:
            logger.info("Lock does not apply.")
            return False
    
    def is_locked_by(self, user):
        """
        Returns True or False. Can be used to test whether this object is locked by
        a certain user. The ``lock_applies_to`` method and the ``is_locked`` and 
        ``locked_by`` attributes are probably more useful for most intents and
        purposes.
        """
        return user == self.locked_by
    
    def save(self, *vargs, **kwargs):
        if self.lock_type == 'hard' and not self.__init_hard_lock:
            raise ObjectLockedError("""There is currently a hard lock in place. You may not save.
            If you're requesting this save in order to unlock this object for the user who
            initiated the lock, make sure to call `unlock_for` first, with the user as
            the argument.""")
        self.__init_hard_lock = False
        
        super(LockableModel, self).save(*vargs, **kwargs)
        self._state.locking = False
########NEW FILE########
__FILENAME__ = admin
# encoding: utf-8

from django.contrib import admin
from locking.tests.models import Story
from locking.admin import LockableAdmin

class StoryAdmin(LockableAdmin):
    list_display = ('lock', 'content', )
    list_display_links = ('content', )

admin.site.register(Story, StoryAdmin)
########NEW FILE########
__FILENAME__ = models
from django.db import models
from locking import models as locking

class Story(locking.LockableModel):
    content = models.TextField(blank=True)
    
    class Meta:
        verbose_name_plural = 'stories'

class Unlockable(models.Model):
    # this model serves to test that utils.gather_lockable_models
    # actually does what it's supposed to
    content = models.TextField(blank=True)
########NEW FILE########
__FILENAME__ = tests
from datetime import datetime, timedelta
import simplejson

from django.core.urlresolvers import reverse
from django.test.client import Client
from django.contrib.auth.models import User

from locking import models, views, LOCK_TIMEOUT
from locking.tests.utils import TestCase
from locking.tests import models as testmodels

class AppTestCase(TestCase):
    fixtures = ['locking_scenario',]

    def setUp(self):
        self.alt_story, self.story = testmodels.Story.objects.all()
        users = User.objects.all()
        self.user, self.alt_user = users
    
    def test_hard_lock(self):
        # you can save a hard lock once (to initiate the lock)
        # but after that saving without first unlocking raises an error
        self.story.lock_for(self.user, hard_lock=True)
        self.assertEquals(self.story.lock_type, "hard")
        self.story.save()
        self.assertRaises(models.ObjectLockedError, self.story.save)
    
    def test_soft_lock(self):
        self.story.lock_for(self.user)
        self.story.save()
        self.assertEquals(self.story.lock_type, "soft")
        self.story.save() 
    
    def test_lock_for(self):
        self.story.lock_for(self.user)
        self.assertTrue(self.story.is_locked)
        self.story.save()
        self.assertTrue(self.story.is_locked)
  
    def test_lock_for_overwrite(self):
        # we shouldn't be able to overwrite an active lock by another user
        self.story.lock_for(self.alt_user)
        self.assertRaises(models.ObjectLockedError, self.story.lock_for, self.user)

    def test_unlock(self):
        self.story.lock_for(self.user)
        self.story.unlock()
        self.assertFalse(self.story.is_locked)
    
    def test_hard_unlock(self):
        self.story.lock_for(self.user, hard_lock=True)
        self.story.unlock_for(self.user)
        self.assertFalse(self.story.is_locked)
        self.story.unlock()

    def test_unlock_for_self(self):
        self.story.lock_for(self.user)
        self.story.unlock_for(self.user)
        self.assertFalse(self.story.is_locked)  

    def test_unlock_for_disallowed(self, hard_lock=False):
        # we shouldn't be able to disengage a lock that was put in place by another user
        self.story.lock_for(self.alt_user, hard_lock=hard_lock)
        self.assertRaises(models.ObjectLockedError, self.story.unlock_for, self.user)
    
    def test_hard_unlock_for_disallowed(self):
        self.test_unlock_for_disallowed(hard_lock=True)
    
    def test_lock_expiration(self):
        self.story.lock_for(self.user)
        self.assertTrue(self.story.is_locked)
        self.story._locked_at = datetime.today() - timedelta(minutes=LOCK_TIMEOUT+1)
        self.assertFalse(self.story.is_locked)
    
    def test_lock_applies_to(self):
        self.story.lock_for(self.alt_user)
        applies = self.story.lock_applies_to(self.user)
        self.assertTrue(applies)
    
    def test_lock_doesnt_apply_to(self):
        self.story.lock_for(self.user)
        applies = self.story.lock_applies_to(self.user)
        self.assertFalse(applies)
    
    def test_is_locked_by(self):
        self.story.lock_for(self.user)
        self.assertEquals(self.story.locked_by, self.user)
    
    def test_is_unlocked(self):
        # this might seem like a silly test, but an object
        # should be unlocked unless it has actually been locked
        self.assertFalse(self.story.is_locked)
    
    def test_gather_lockable_models(self):
        from locking import utils
        from locking.tests import models
        lockable_models = utils.gather_lockable_models()
        self.assertTrue("story" in lockable_models["tests"])
        self.assertTrue("unlockable" not in lockable_models["tests"])

    def test_locking_bit_when_locking(self):
        # when we've locked something, we should set an administrative
        # bit so other developers can know a save will do a lock or 
        # unlock and respond to that information if they so wish.
        self.story.content = "Blah"
        self.assertEquals(self.story._state.locking, False)
        self.story.lock_for(self.user)
        self.assertEquals(self.story._state.locking, True)
        self.story.save()
        self.assertEquals(self.story._state.locking, False)        

    def test_locking_bit_when_unlocking(self):
        # when we've locked something, we should set an administrative
        # bit so other developers can know a save will do a lock or 
        # unlock and respond to that information if they so wish.
        self.story.content = "Blah"
        self.assertEquals(self.story._state.locking, False)
        self.story.lock_for(self.user)
        self.story.unlock_for(self.user)
        self.assertEquals(self.story._state.locking, True)        
        self.story.save()
        self.assertEquals(self.story._state.locking, False)  

    def test_unlocked_manager(self):
        self.story.lock_for(self.user)
        self.story.save()
        self.assertEquals(testmodels.Story.objects.count(), 2)
        self.assertEquals(testmodels.Story.unlocked.count(), 1)
        self.assertEquals(testmodels.Story.unlocked.get(pk=self.alt_story.pk).pk, 1)
        self.assertRaises(testmodels.Story.DoesNotExist, testmodels.Story.unlocked.get, pk=self.story.pk)
        self.assertNotEquals(testmodels.Story.unlocked.all()[0].pk, self.story.pk)

    def test_locked_manager(self):
        self.story.lock_for(self.user)
        self.story.save()
        self.assertEquals(testmodels.Story.objects.count(), 2)
        self.assertEquals(testmodels.Story.locked.count(), 1)
        self.assertEquals(testmodels.Story.locked.get(pk=self.story.pk).pk, 2)
        self.assertRaises(testmodels.Story.DoesNotExist, testmodels.Story.locked.get, pk=self.alt_story.pk)
        self.assertEquals(testmodels.Story.locked.all()[0].pk, self.story.pk)

    def test_managers(self):
        self.story.lock_for(self.user)
        self.story.save()
        locked = testmodels.Story.locked.all()
        unlocked = testmodels.Story.unlocked.all()
        self.assertEquals(locked.count(), 1)
        self.assertEquals(unlocked.count(), 1)
        self.assertTrue(len(set(locked).intersection(set(unlocked))) == 0)

users = [
    # Stan is a superuser
    {"username": "Stan", "password": "green pastures"},
    # Fred has pretty much no permissions whatsoever
    {"username": "Fred", "password": "pastures of green"},
    ]
    
class BrowserTestCase(TestCase):
    fixtures = ['locking_scenario',]
    apps = ('locking.tests', 'django.contrib.auth', 'django.contrib.admin', )
    # REFACTOR: 
    # urls = 'locking.tests.urls'

    def setUp(self):
        # some objects we might use directly, instead of via the client
        self.story = story = testmodels.Story.objects.all()[0]
        user_objs = User.objects.all()
        self.user, self.alt_user = user_objs
        # client setup
        self.c = Client()
        self.c.login(**users[0])
        story_args = [story._meta.app_label, story._meta.module_name, story.pk]
        # refactor: http://docs.djangoproject.com/en/dev/topics/testing/#urlconf-configuration
        # is probably a smarter way to go about this
        self.urls = {
            "change": reverse('admin:tests_story_change', args=[story.pk]),
            "changelist": reverse('admin:tests_story_changelist'),
            "lock": reverse(views.lock, args=story_args),
            "unlock": reverse(views.unlock, args=story_args),
            "is_locked": reverse(views.is_locked, args=story_args),
            "js_variables": reverse(views.js_variables),
            }
    
    def tearDown(self):
        pass

    # Some terminology: 
    # - 'disallowed' is when the locking system does not allow a certain operation
    # - 'unauthorized' is when Django does not permit a user to do something
    # - 'unauthenticated' is when a user is logged out of Django
      
    def test_lock_when_allowed(self):
        res = self.c.get(self.urls['lock'])        
        self.assertEquals(res.status_code, 200)
        # reload our test story
        story = testmodels.Story.objects.get(pk=self.story.id)
        self.assertTrue(story.is_locked)
        
    def test_lock_when_logged_out(self):
        self.c.logout()
        res = self.c.get(self.urls['lock'])
        self.assertEquals(res.status_code, 401)
    
    def test_lock_when_unauthorized(self):
        # when a user doesn't have permission to change the model
        # this tests the user_may_change_model decorator
        self.c.logout()
        self.c.login(**users[1])
        res = self.c.get(self.urls['lock'])        
        self.assertEquals(res.status_code, 401)
    
    def test_lock_when_does_not_apply(self):
        # don't make a resource available to lock models that don't 
        # have locking enabled -- this tests the is_lockable decorator
        obj = testmodels.Unlockable.objects.get(pk=1)
        args = [obj._meta.app_label, obj._meta.module_name, obj.pk]
        url = reverse(views.lock, args=args)
        res = self.c.get(url)        
        self.assertEquals(res.status_code, 404)              
    
    def test_lock_when_disallowed(self):
        self.story.lock_for(self.alt_user)
        self.story.save()
        res = self.c.get(self.urls['lock'])        
        self.assertEquals(res.status_code, 403)
    
    def test_unlock_when_allowed(self):
        self.story.lock_for(self.user)
        self.story.save()
        res = self.c.get(self.urls['unlock'])        
        self.assertEquals(res.status_code, 200)
        # reload our test story
        story = testmodels.Story.objects.get(pk=self.story.id)
        self.assertFalse(story.is_locked)
    
    def test_unlock_when_disallowed(self):
        self.story.lock_for(self.alt_user)
        self.story.save()
        res = self.c.get(self.urls['unlock'])        
        self.assertEquals(res.status_code, 403)

    def test_is_locked_when_applies(self):
        self.story.lock_for(self.alt_user)
        self.story.save()
        res = self.c.get(self.urls['is_locked'])
        res = simplejson.loads(res.content)
        self.assertTrue(res['applies'])
        self.assertTrue(res['is_active'])
    
    def test_is_locked_when_self(self):
        self.story.lock_for(self.user)
        self.story.save()
        res = self.c.get(self.urls['is_locked'])
        res = simplejson.loads(res.content)
        self.assertFalse(res['applies'])
        self.assertTrue(res['is_active'])

    def test_js_variables(self):
        res = self.c.get(self.urls['js_variables'])
        self.assertEquals(res.status_code, 200)
        self.assertContains(res, LOCK_TIMEOUT)
    
    def test_admin_media(self):
        res = self.c.get(self.urls['change'])
        self.assertContains(res, 'admin.locking.js')
    
    def test_admin_changelist_when_locked(self):
        self.story.lock_for(self.alt_user)
        self.story.save()
        res = self.c.get(self.urls['changelist'])
        self.assertContains(res, 'locking/img/lock.png')
    
    def test_admin_changelist_when_locked_self(self):
        self.test_lock_when_allowed()
        res = self.c.get(self.urls['changelist'])
        self.assertContains(res, 'locking/img/page_edit.png')
    
    def test_admin_changelist_when_unlocked(self):
        res = self.c.get(self.urls['changelist'])
        self.assertNotContains(res, 'locking/img')
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.conf import settings
from django.contrib import admin

admin.autodiscover()

urlpatterns = patterns('',
    (r'^ajax/admin/', include('locking.urls')),
    (r'^admin/', include(admin.site.urls)),
    (r'', include('staticfiles.urls')),
)
########NEW FILE########
__FILENAME__ = utils
# encoding: utf-8

from django.conf import settings
from django.core.management import call_command
from django.db.models import loading
from django import test

class TestCase(test.TestCase):
    apps = ()

    def _pre_setup(self):
        # Add the models to the db.
        self._original_installed_apps = list(settings.INSTALLED_APPS)
        for app in self.apps:
            settings.INSTALLED_APPS.append(app)
        loading.cache.loaded = False
        call_command('syncdb', interactive=False, verbosity=0)
        # Call the original method that does the fixtures etc.
        super(TestCase, self)._pre_setup()

    def _post_teardown(self):
        # Call the original method.
        super(TestCase, self)._post_teardown()
        # Restore the settings.
        settings.INSTALLED_APPS = self._original_installed_apps
        loading.cache.loaded = False
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

urlpatterns = patterns('locking.views',
    # verwijst naar een ajax-view voor het lockingmechanisme
    (r'(?P<app>[\w-]+)/(?P<model>[\w-]+)/(?P<id>\d+)/lock/$', 'lock'),
    (r'(?P<app>[\w-]+)/(?P<model>[\w-]+)/(?P<id>\d+)/unlock/$', 'unlock'),
    (r'(?P<app>[\w-]+)/(?P<model>[\w-]+)/(?P<id>\d+)/is_locked/$', 'is_locked'),
    (r'variables\.js$', 'js_variables', {}, 'locking_variables'),
    )

urlpatterns += patterns('',
    (r'jsi18n/$', 'django.views.i18n.javascript_catalog', {'packages': 'locking'}),
    )
########NEW FILE########
__FILENAME__ = utils
# encoding: utf-8

from django.contrib.contenttypes.models import ContentType
from locking.models import LockableModel

def gather_lockable_models():
    lockable_models = dict()
    for contenttype in ContentType.objects.all():
        model = contenttype.model_class()
        # there might be a None value betwixt our content types
        if model:
            app = model._meta.app_label
            name = model._meta.module_name
            if issubclass(model, LockableModel):
                lockable_models.setdefault(app, {})
                lockable_models[app][name] = model
    return lockable_models
########NEW FILE########
__FILENAME__ = views
import simplejson

from django.http import HttpResponse
from django.core.urlresolvers import reverse

from locking.decorators import user_may_change_model, is_lockable, log
from locking import utils, LOCK_TIMEOUT, logger, models

"""
These views are called from javascript to open and close assets (objects), in order
to prevent concurrent editing.
"""

@log
@user_may_change_model
@is_lockable
def lock(request, app, model, id):
    obj = utils.gather_lockable_models()[app][model].objects.get(pk=id)

    try:
        obj.lock_for(request.user)
        obj.save()
        return HttpResponse(status=200)
    except models.ObjectLockedError:
        # The user tried to overwrite an existing lock by another user.
        # No can do, pal!
        return HttpResponse(status=403)

@log
@user_may_change_model
@is_lockable
def unlock(request, app, model, id):
    obj = utils.gather_lockable_models()[app][model].objects.get(pk=id)

    # Users who don't have exclusive access to an object anymore may still
    # request we unlock an object. This happens e.g. when a user navigates
    # away from an edit screen that's been open for very long.
    # When this happens, LockableModel.unlock_for will throw an exception, 
    # and we just ignore the request.
    # That way, any new lock that may since have been put in place by another 
    # user won't get accidentally overwritten.
    try:
        obj.unlock_for(request.user)
        obj.save()    
        return HttpResponse(status=200)
    except models.ObjectLockedError:
        return HttpResponse(status=403)

@log
@user_may_change_model
@is_lockable
def is_locked(request, app, model, id):    
    obj = utils.gather_lockable_models()[app][model].objects.get(pk=id)

    response = simplejson.dumps({
        "is_active": obj.is_locked,
        "for_user": getattr(obj.locked_by, 'username', None),
        "applies": obj.lock_applies_to(request.user),
        })
    return HttpResponse(response)

@log
def js_variables(request):
    response = "var locking = " + simplejson.dumps({
        'base_url': "/".join(request.path.split('/')[:-1]),
        'timeout': LOCK_TIMEOUT,
        })
    return HttpResponse(response)
########NEW FILE########
