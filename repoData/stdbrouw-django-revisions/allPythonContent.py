__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-versioning documentation build configuration file, created by
# sphinx-quickstart on Thu May 27 10:28:17 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
os.environ['DJANGO_SETTINGS_MODULE'] = 'django.conf.global_settings'

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.coverage']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-versioning'
copyright = u'2010, Stijn Debrouwere'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.5'
# The full version, including alpha/beta/rc tags.
release = '0.5'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-versioningdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-versioning.tex', u'django-versioning Documentation',
   u'Stijn Debrouwere', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = admin
# encoding: utf-8

"""
To make sure ``django-versioning`` works smoothly with the admin interface, you should add ``revisions.middleware.VersionedModelRedirectMiddleware`` to your middlewares in ``settings.py``, e.g.::

    MIDDLEWARE_CLASSES = (
        'django.middleware.common.CommonMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'revisions.middleware.VersionedModelRedirectMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
    )
    
To enable versioning in the admin, subclass from revisions.admin.VersionedAdmin instead of from django.admin.ModelAdmin. By default, this class has ``revisions.admin.AutoRevisionForm`` as its form, but you're not tied to this ModelForm: 

* AutoRevisionForm makes sure to clear any revision-specific fields, like log messages. Since these are tied to each individual revision, revision-specific fields should be empty upon each new edit.
* RevisionForm inherits from AutoRevisionForm, but adds a checkbox to the form that allows users to specify they only want to make a small change, and that we ought to save it in-place rather than creating a new revision.
* If you need neither, feel free to use a regular ModelForm instead.

Specify fields that need to be cleared as a list of attribute names like so::

    class MyModel(VersionedModel):
        class Versioning:
            clear_each_revision = ['log_message', 'codename', ]

When in doubt, don't specify your own form and stick to the default: the AutoRevisionForm.
"""

from django.contrib import admin
from revisions.managers import LatestManager
from django import forms

class AutoRevisionForm(forms.ModelForm):
    def __init__(self, *args, **kwargs):
        super(AutoRevisionForm, self).__init__(*args, **kwargs)
        
        for field in self.instance.Versioning.clear_each_revision:
            self.initial[field] = ''

class RevisionForm(AutoRevisionForm):
    small_change = forms.BooleanField(initial=False, 
        help_text="Fixed a typo, changed a couple of words. (Doesn't create a new revision)",
        required=False)

    def clean(self):
        self.instance.is_small_change = self.cleaned_data.get('small_change', False)
        del self.fields['small_change']
        del self.cleaned_data['small_change']
        return self.cleaned_data

class VersionedAdmin(admin.ModelAdmin):
    form = AutoRevisionForm
    
    def save_model(self, request, obj, form, change):
        """
        Given a model instance save it to the database.
        """
        obj.revise()
########NEW FILE########
__FILENAME__ = fields
# encoding: utf-8

from django.db import models

"""
1. Shouldn't trigger a django.core.management.validation error (which is tricky because it 
   doesn't check if the field is actually a regular ForeignKey, it just checks if it has a
   ``rel`` attribute.
2. Shouldn't add a true FK to databases that support it (that is, anything other than MySQL 
   and SQLite), but treat the foreign key as a regular integerfield/charfield that just
   happens to be a reference.
"""

# a pseudo-foreign key that supports referencing either the bundle or the individual revision
class ForeignKey(models.ForeignKey):
    def __init__(self):
        raise NotImplementedError()
########NEW FILE########
__FILENAME__ = managers
# encoding: utf-8

from datetime import datetime
from django.db import models
import inspect


def get_table_for_field(model, field_name):
    for field in model._meta.fields:
        if field_name == field.attname:
            return field.model._meta.db_table
    return None


class LatestQuerySet(models.query.QuerySet):
    # not too nice performance-wise, but the easiest solution
    # to make counts play nice with revisions
    def count(self):
        return len(list(self.iterator()))
        

class LatestManager(models.Manager):
    """ A manager that returns the latest revision of each bundle of content. """

    @property
    def current(self):
        qs = LatestQuerySet(self.model, using=self._db)
    
        # in case of concrete inheritance, we need the base table, not the leaf
        base = qs.query.model.get_base_model()
        base_table = base._meta.db_table

        # this may or may not be the fastest way to get the last revision of every
        # piece of content, depending on how your database query optimizer works, 
        # but it sure as hell is the easiest way to do it in Django without resorting
        # to multiple queries or working entirely with raw SQL.
        comparator_name = base.get_comparator_name()  
        comparator_table = get_table_for_field(qs.query.model, comparator_name)
        where = '{comparator_table}.{comparator} = (SELECT MAX({comparator}) FROM {table} as sub WHERE {table}.cid = sub.cid)'.format(
            table=base_table,
            comparator=comparator_name,
            comparator_table=comparator_table)
        
        qs = qs.extra(where=[where])
        return qs

    def get_query_set(self):              
        # Django uses the default manager (which on versioned models is this one)
        # to determine what to do when it saves a model instance. Because older
        # revisions aren't included in the queryset for LatestManager, when trying
        # to update such an older revision, the ORM gets confused and tries to insert 
        # a new record, or, when you pass force_update=True, Django complains that it 
        # couldn't find the right row to update.
        #
        # Specifically, you either get an IntegrityError saying "PRIMARY KEY must be unique" 
        # or a DatabaseError saying "Forced update did not affect any rows."
        #
        # We solve this little issue by simply using the plain models.Manager queryset
        # when saving. Simple fix, but it does require some trickery with the inspect
        # module and it does make this module prone to breakage whenever a new Django
        # version comes out.
        #
        # revisions.tests.AppTests.test_update_old_revision_in_place tests whether this works.
        #
        # The Django team advises against using a manager that filters out rows as the default one:
        # http://docs.djangoproject.com/en/dev/topics/db/managers/#do-not-filter-away-any-results-in-this-type-of-manager-subclass
        # ... but we feel that versioning should be an absolutely transparant concern, 
        # and work on related resources and in the admin without any fuss, leading us
        # to waive this concern.
   
        stack = inspect.stack()[3][3]
        # * 'save' for saving for plain models
        # * 'save_base' for saving models with inheritance
        # * '_collect_sub_objects' for deleting models with inheritance (Django 1.2)
        # * 'collect' for deleting models with inheritance (Django 1.3)
        if stack.startswith('save') or stack == 'collect' or stack == '_collect_sub_objects':
            return super(LatestManager, self).get_query_set()
        else:
            return self.current
            
    
def trash_aware(cls):
    for manager in cls._meta.abstract_managers:
        manager[2].trash = manager[2].filter(_is_trash=True)
        manager[2].live = manager[2].filter(_is_trash=False)
    return cls
########NEW FILE########
__FILENAME__ = middleware
# encoding: utf-8

# based on the FlatpageFallbackMiddleware

from django.http import Http404
from django.conf import settings
from django.core.urlresolvers import resolve, reverse, Resolver404
from django.shortcuts import redirect
from django.contrib.contenttypes.models import ContentType
from revisions.models import VersionedModel

class VersionedModelRedirectMiddleware(object):
    def process_response(self, request, response):
        if response.status_code == 404:
            try:
                route = resolve(request.path_info)
            except Resolver404:
                return response
            
            if route[0].__name__  == 'change_view':
                # 1. figure out which model instance the request was for
                app, model, pk = request.path_info.rstrip('/').split('/')[-3:]
                cls = ContentType.objects.get(app_label=app, model=model).model_class()
                
                # 2. get the latest revision for that content
                if issubclass(cls, VersionedModel):
                    obj = cls.objects.get(pk=pk).get_latest_revision()
                    # 3. redirect
                    return redirect(reverse('admin:%s_%s_change' % (app, model), args=[obj.pk]))

        return response
########NEW FILE########
__FILENAME__ = models
# encoding: utf-8

import uuid
import difflib
from datetime import date
from django.db import models
from django.utils.translation import ugettext as _
from django.core.exceptions import ImproperlyConfigured, ValidationError
from django.db import IntegrityError
from django.contrib.contenttypes.models import ContentType
from revisions import managers, utils
import inspect

# the crux of all errors seems to be that, with VersionedBaseModel, 
# doing setattr(self, self.pk_name, None) does _not_ lead to creating
# a new object, and thus versioning as a whole doesn't work

# the only thing lacking from the VersionedModelBase is a version id.
# You may use VersionedModelBase if you need to specify your own 
# AutoField (e.g. using UUIDs) or if you're trying to adapt an existing
# model to ``django-revisions`` and have an AutoField not named
# ``vid``.

class VersionedModelBase(models.Model, utils.ClonableMixin):
    @classmethod
    def get_base_model(cls):
        base = cls
        while isinstance(base._meta.pk, models.OneToOneField):
            base = base._meta.pk.rel.to
        return base    

    @property
    def base_model(self):
        return self.get_base_model()

    @property
    def pk_name(self):
        return self.base_model._meta.pk.attname

    # For UUIDs in particular, we need a way to know the order of revisions
    # e.g. through a ``changed`` datetime field.
    @classmethod
    def get_comparator_name(cls):
        if hasattr(cls.Versioning, 'comparator'):
            return cls.Versioning.comparator
        else:
            return cls.get_base_model()._meta.pk.attname

    @property
    def comparator_name(self):
        return self.get_comparator_name()

    @property
    def comparator(self):
        return getattr(self, self.comparator_name)

    @classmethod
    def get_implementations(cls):
        models = [contenttype.model_class() for contenttype in ContentType.objects.all()]
        return [model for model in models if isinstance(model, cls)]

    @property
    def _base_model(self):
        base = self
        while isinstance(base._meta.pk, models.OneToOneField):
            base = base._meta.pk.rel.to
        return base    

    @property
    def _base_table(self):
        return self._base_model._meta.db_table

    # content bundle id
    cid = models.CharField(max_length=36, editable=False, null=True, db_index=True)
    
    # managers
    latest = managers.LatestManager()
    objects = models.Manager()

    # all related revisions, plus easy shortcuts to the previous and next revision
    def get_revisions(self):
        qs = self.__class__.objects.filter(cid=self.cid).order_by(self.comparator_name)
        
        try:
            qs.prev = qs.filter(**{self.comparator_name + '__lt': self.comparator}).order_by('-' + self.comparator_name)[0]
        except IndexError:
            qs.prev = None
        try:
            qs.next = qs.filter(**{self.comparator_name + '__gt': self.comparator})[0]
        except IndexError:
            qs.next = None
        
        return qs
    
    def check_if_latest_revision(self):
        return self.comparator >= max([version.comparator for version in self.get_revisions()])
    
    @classmethod
    def fetch(cls, criterion):
        if isinstance(criterion, int) or isinstance(criterion, str):
            return cls.objects.get(pk=criterion)
        elif isinstance(criterion, models.Model):
            return criterion
        elif isinstance(criterion, date):
            pub_date = cls.Versioning.publication_date
            if pub_date:
                return cls.objects.filter(**{pub_date + '__lte': criterion}).order('-' + self.comparator_name)[0]
            else:
                raise ImproperlyConfigured("""Please specify which field counts as the publication
                    date for this model. You can do so inside a Versioning class. Read the docs 
                    for more info.""")
        else:
            raise TypeError("Can only fetch an object using a primary key, a date or a datetime object.")

    def revert_to(self, criterion):
        revert_to_obj = self.__class__.fetch(criterion)
    
        # You can only revert a model instance back to a previous instance.
        # Not any ol' object will do, and we check for that.
        if revert_to_obj.pk not in self.get_revisions().values_list('pk', flat=True):
            raise IndexError("Cannot revert to a primary key that is not part of the content bundle.")
        else:
            return revert_to_obj.revise()
            
    def get_latest_revision(self):
        return self.get_revisions().order_by('-' + self.comparator)[0]
    
    def make_current_revision(self):
        if not self.check_if_latest_revision():
            self.save()

    def show_diff_to(self, to, field):
        frm = unicode(getattr(self, field)).split()
        to = unicode(getattr(to, field)).split()
        differ = difflib.HtmlDiff()
        return differ.make_table(frm, to)

    def _get_unique_checks(self, exclude=[]):
        # for parity with Django's unique_together notation shortcut
        def parse_shortcut(unique_together):
            unique_together = tuple(unique_together)
            if len(unique_together) and isinstance(unique_together[0], basestring):
                unique_together = (unique_together, )    
            return unique_together
        
        # Django actually checks uniqueness for a single field in the very same way it
        # does things for unique_together, something we happily take advantage of
        unique = tuple([(field,) for field in getattr(self.Versioning, 'unique', ())])
        unique_together = \
            unique + \
            parse_shortcut(getattr(self.Versioning, 'unique_together', ())) + \
            parse_shortcut(getattr(self._meta, 'unique_together', ()))
        
        model = self.__class__()
        model._meta.unique_together = unique_together
        return models.Model._get_unique_checks(model, exclude)          

    def _get_attribute_history(self, name):
        if self.__dict__.get(name, False):
            return [(version.__dict__[name], version) for version in self.get_revisions()]
        else:
            raise AttributeError(name)

    def _get_related_objects(self, relatedmanager):
        """ This method extends a regular related-manager by also including objects
        that are related to other versions of the same content, instead of just to
        this one object. """
        
        related_model = relatedmanager.model
        related_model_name = related_model._meta.module_name
        
        # The foreign key field name on related objects often, by convention,
        # coincides with the name of the class it relates to, but not always, 
        # e.g. you could do something like
        #   class Book(models.Model):
        #       thingmabob = models.ForeignKey(Author)
        #
        # There is, afaik, no elegant way to get a RelatedManager to tell us that
        # related objects refer to this class by 'thingmabob', leading to this
        # kind of convoluted deep dive into the internals of the related class.
        #
        # By all means, I'd welcome suggestions for prettier code.
        ref_name = self._meta._name_map[related_model_name][0].field.name
        pks = [story.pk for story in self.get_revisions()]        
        objs = related_model._default_manager.filter(**{ref_name + '__in': pks})
        
        return objs
    
    def __getattr__(self, name):
        # we catch all lookups that start with 'related_'
        if name.startswith('related_'):
            related_name = "_".join(name.split("_")[1:])
            attribute = getattr(self, related_name, False)
            # we piggyback off of an existing relationship,
            # so the attribute has to exist and it has to be a 
            # RelatedManager or ManyRelatedManager
            if attribute:
                # (we check the module instead of using isinstance, since 
                # ManyRelatedManager is created using a factory so doesn't
                # actually exist inside of the module)
                if attribute.__class__.__dict__['__module__'] == 'django.db.models.fields.related':
                    return self._get_related_objects(attribute)

        if name.endswith('_history'):
            attribute = name.replace('_history', '')
            return self._get_attribute_history(attribute)

        raise AttributeError(name)
            
    def prepare_for_writing(self):
        """
        This method allows you to clear out certain fields in the model that are
        specific to each revision, like a log message.
        """
        for field in self.Versioning.clear_each_revision:
            super(VersionedModelBase, self).__setattr__(field, '')

    def validate_bundle(self):
        # uniqueness constraints per bundle can't be checked at the database level, 
        # which means we'll have to do so in the save method
        if getattr(self.Versioning, 'unique_together', None) or getattr(self.Versioning, 'unique', None):
            # replace ValidationError with IntegrityError because this is what users will expect
            try:
                self.validate_unique()
            except ValidationError, error:
                raise IntegrityError(error)

    def revise(self):
        self.validate_bundle()
        return self.clone()

    def save(self, *vargs, **kwargs):       
        # The first revision of a piece of content won't have a bundle id yet, 
        # and because the object isn't persisted in the database, there's no 
        # primary key either, so we use a UUID as the bundle ID.
        # 
        # (Note for smart alecks: Django chokes on using super/save() more than
        # once in the save method, so doing a preliminary save to get the PK
        # and using that value for a bundle ID is rather hard.)
        if not self.cid:
            self.cid = uuid.uuid4().hex

        self.validate_bundle()
        super(VersionedModelBase, self).save(*vargs, **kwargs)
        
    def delete_revision(self, *vargs, **kwargs):
        super(VersionedModelBase, self).delete(*vargs, **kwargs)
    
    def delete(self, *vargs, **kwargs):
        for revision in self.get_revisions():
            revision.delete_revision(*vargs, **kwargs)

    class Meta:
        abstract = True
    
    class Versioning:
        clear_each_revision = []
        publication_date = None
        unique_together = ()

class VersionedModel(VersionedModelBase):
    vid = models.AutoField(primary_key=True)
    
    class Meta:
        abstract = True

class TrashableModel(models.Model):
    """ Users wanting a version history may also expect a trash bin
    that allows them to recover deleted content, as is e.g. the
    case in WordPress. This is that thing. """
    
    _is_trash = models.BooleanField(db_column='is_trash', default=False, editable=False)
    
    @property
    def is_trash(self):
        return self._is_trash
    
    def get_content_bundle(self):
        if isinstance(self, VersionedModelBase):
            return self.get_revisions()
        else:
            return [self]        
    
    def delete(self):
        """
        It makes no sense to trash individual revisions: either you keep a version history or you don't.
        If you want to undo a revision, you should use obj.revert_to(preferred_revision) instead.
        """
        for obj in self.get_content_bundle():
            obj._is_trash = True
            obj.save()
    
    def delete_permanently(self):    
        for obj in self.get_content_bundle():
            super(TrashableModel, obj).delete()
    
    class Meta:
        abstract = True
########NEW FILE########
__FILENAME__ = shortcuts
from revisions import models

class VersionedModelShortcuts(object):
    """
    VersionedModel defines a few common operations (check_if_latest_revision, 
    get_latest_revision) that involve a database lookup. Common practice dictates that
    these should be implemented as methods rather than as properties, because properties
    would signal to the programmer that a simple lookup is taking place.
    
    However, because we value code that feels as natural and domain-driven as possible, 
    and because the database lookups involved are fairly quick queries, we've also included 
    a helper class that implements these common operations as properties -- a few convenient
    shortcuts if you will.
    """
    @property
    def revisions(self):
        return self.get_revisions()

    @property
    def is_latest_revision(self):
        return self.check_if_latest_revision()
    
    @property
    def latest_revision(self):
        return self.get_latest_revision()

class VersionedModel(models.VersionedModel, VersionedModelShortcuts):
    class Meta:
        abstract = True

TrashableModel = models.TrashableModel

class TrashableVersionedModel(VersionedModel, TrashableModel):
    class Meta:
        abstract = True
########NEW FILE########
__FILENAME__ = admin
# encoding: utf-8

from django.contrib import admin
from revisions.tests import models
from revisions.admin import VersionedAdmin, RevisionForm

class AsideInline(admin.TabularInline):
    model = models.Aside

class InfoInline(admin.TabularInline):
    model = models.Info

class StoryAdmin(VersionedAdmin):
    form = RevisionForm
    inlines = [AsideInline, InfoInline,]

admin.site.register(models.Story, StoryAdmin)
admin.site.register(models.FancyStory, StoryAdmin)
admin.site.register(models.TrashableStory)
########NEW FILE########
__FILENAME__ = models
from django.db import models
from revisions.models import VersionedModelBase, VersionedModel, TrashableModel
from revisions import shortcuts
from django.template.defaultfilters import slugify
from revisions import managers
from django_extensions.db.fields import UUIDField

class Story(VersionedModel):
    title = models.CharField(max_length=250)
    slug = models.SlugField(max_length=250, editable=False)
    body = models.TextField(blank=True)

    def save(self, *vargs, **kwargs):
        self.slug = slugify(self.title)
        super(Story, self).save(*vargs, **kwargs)
        
    def __unicode__(self):
        return self.title
    
    class Meta:
        verbose_name_plural = 'stories'
    
    class Versioning:
        clear_each_revision = ['title', 'slug']
        publication_date = None

class ManualStory(VersionedModelBase):
    alt_id = models.AutoField(primary_key=True)

    title = models.CharField(max_length=250)
    slug = models.SlugField(max_length=250, editable=False)
    body = models.TextField(blank=True)

    def save(self, *vargs, **kwargs):
        self.slug = slugify(self.title)
        super(ManualStory, self).save(*vargs, **kwargs)
        
    def __unicode__(self):
        return self.title
    
    class Meta:
        verbose_name_plural = 'manual stories'
    
    class Versioning:
        clear_each_revision = ['title', 'slug']
        publication_date = None

class UUIDStory(VersionedModelBase):
    alt_id = UUIDField(primary_key=True)

    title = models.CharField(max_length=250)
    slug = models.SlugField(max_length=250, editable=False)
    body = models.TextField(blank=True)
    changed = models.DateTimeField(auto_now=True)

    def save(self, *vargs, **kwargs):
        self.slug = slugify(self.title)
        super(UUIDStory, self).save(*vargs, **kwargs)
        
    def __unicode__(self):
        return self.title
    
    class Meta:
        verbose_name_plural = 'uuid-based stories'
    
    class Versioning:
        clear_each_revision = ['title', 'slug']
        publication_date = None
        comparator = 'changed'

class UniqueStory(VersionedModel):
    class Meta:
        verbose_name_plural = 'unique stories'
        unique_together = ("title", "body", )

    class Versioning:
        unique = ("body", )
        unique_together = ("title", "slug", )

    title = models.CharField(max_length=250)
    slug = models.SlugField(max_length=250, editable=False)
    body = models.TextField(blank=True)

    def save(self, *vargs, **kwargs):
        self.slug = slugify(self.title)
        super(UniqueStory, self).save(*vargs, **kwargs)
        
    def __unicode__(self):
        return self.title

class FancyStory(Story):
    is_very_fancy = models.BooleanField(default=True)

class FancyManualStory(ManualStory):
    is_very_fancy = models.BooleanField(default=True)

class ConvenientStory(Story, shortcuts.VersionedModelShortcuts):
    class Meta:
        proxy = True

@managers.trash_aware
class TrashableStory(VersionedModel, TrashableModel):
    title = models.CharField(max_length=250)
    slug = models.SlugField(max_length=250, editable=False)
    body = models.TextField(blank=True)

    def save(self, *vargs, **kwargs):
        self.slug = slugify(self.title)
        super(TrashableStory, self).save(*vargs, **kwargs)
        
    def __unicode__(self):
        return self.title

    class Meta:
        verbose_name_plural = 'trashable stories'

# this model allows us to test whether the trash system works nicely in tandem
# with revisions together with concrete inheritance
@managers.trash_aware
class FancyTrashableStory(TrashableStory):
    is_very_fancy = models.BooleanField(default=True)

    class Meta:
        verbose_name_plural = 'trashable stories'

class Aside(VersionedModel):
    # serves to test synchronous versioning
    message = models.CharField(max_length=250)
    story = models.ForeignKey(Story) 

class Info(models.Model):
    # serves to test related but unversioned objects
    content = models.CharField(max_length=250)
    story = models.ForeignKey(Story)

class InfoToBundle(models.Model):
    # serves to test FKs to a bundle
    content = models.CharField(max_length=250)
    #story = models.ForeignKey(Story, to_field='cid')
########NEW FILE########
__FILENAME__ = tests
from copy import copy
from django.db import IntegrityError
from django.test import TestCase
from django.test.client import Client
from django.contrib.auth.models import User
import revisions
from revisions.tests import models

#
# App tests
#

class ModelTests(TestCase):
    fixtures = ['revisions_scenario', 'asides_scenario']

    def setUp(self):
        self.story = models.Story.latest.all()[0]

    def test_get_revisions(self, pks=[1,2,3]):
        revisions = self.story.get_revisions()
        self.assertEquals(len(revisions), 3)
        self.assertEquals([rev.pk for rev in revisions], pks)
    
    def test_get_next_revision(self):
        next = self.story.get_revisions().next
        self.assertEquals(next, None)

    def test_get_prev_revision(self, prev_pk=2):
        prev = self.story.get_revisions().prev
        self.assertEquals(prev.pk, prev_pk)

    def test_get_prev_next_revision(self):
        revision_vid = self.story.pk
        prevnext_vid = self.story.get_revisions().prev.get_revisions().next.pk
        self.assertEquals(revision_vid, prevnext_vid)

    def test_id_assignment(self):
        obj = self.story.__class__(
            title = 'this is a title',
            body = 'this is some body text',
            )
        original_obj = copy(obj)
        obj.save()
        saved_obj = obj
        
        # a piece of versioned content is only assigned a bundle id upon the first save
        self.assertFalse(original_obj.cid)
        self.assertTrue(saved_obj.cid)

    def test_revision_creation(self):
        revision = self.story.revise()  
        self.assertTrue(self.story.comparator < revision.comparator)
        self.assertEquals(self.story.cid, revision.cid)
    
    def test_update_old_revision(self):
        base = self.story.get_revisions()[1]
        new = base.revise()
        
        self.assertTrue(base.comparator < new.comparator)
    
    def test_update_old_revision_in_place(self):
        """ It should be possible to update an old revision without creating a 
        new one, for administrative purposes, like updating a last_accessed time. """
        
        revision_count = {
            "before": self.story.get_revisions().count()
            }
        old_rev = self.story.get_revisions()[1]
        old_rev.title = 'Fiddling around with an old revision'
        old_rev.save()
        revision_count['after'] = self.story.get_revisions().count()
        
        self.assertEquals(revision_count['before'], revision_count['after'])
        
    def test_latest_manager(self, expected=None):
        """ The latest manager should only display the latest revision
        for each content bundle. """
        
        # see fixtures
        if not expected:
            expected = {
                "old_revision_pks": set([1,2,4]),
                "latest_revision_pks": set([3,5]),
                }
        
        actual = {
            "old_revisions": [story for story in self.story.__class__.latest.all() if not 
                story.check_if_latest_revision()],
            "latest_revisions": self.story.__class__.latest.all(),
            "latest_revision_pks": set([story.pk for story in self.story.__class__.latest.only(self.story.pk_name).all()])       
            }
        
        self.assertEquals(len(expected['latest_revision_pks']), len(actual['latest_revisions']))
        self.assertEquals(expected['latest_revision_pks'], actual['latest_revision_pks'])
        self.assertEquals(actual['latest_revisions'][0].title, 'This is a little story (final)')
        self.assertTrue(expected['old_revision_pks'].isdisjoint(actual['latest_revision_pks']))

    def test_fetch_by_pk(self, pk=2):
        story = self.story.__class__.fetch(pk)
        self.assertEquals(story.pk, pk)

    def test_revert_to(self):
        older_revision = self.story.get_revisions()[0]
        revision_count = len(self.story.get_revisions())
        reverted_revision = self.story.revert_to(older_revision)
        self.story.revise()
        new_revision_count = len(self.story.get_revisions())
        
        # does the reverted revision keep the bundle id intact?
        self.assertEquals(older_revision.cid, self.story.cid)
        # does it actually revert?
        self.assertEquals(older_revision.body, reverted_revision.body)
        # reverting to an old revision works by making a new one
        self.assertTrue(self.story.comparator > older_revision.comparator)
        self.assertTrue(revision_count < new_revision_count)

    def test_make_current_revision(self):
        latest_revision = self.story
        older_revision = self.story.get_revisions()[1]
        older_revision.make_current_revision()
        new_latest_revision = older_revision
        
        # note to self: zeker maken dat deze effectief verschillen in de fixture, 
        # zodat deze nieuwe revisie effectief goed gekopieerd moet zijn om deze
        # test te doen slagen -- anders heeft het geen zin
        self.assertEquals(older_revision.title, new_latest_revision.title)
        self.assertNotEqual(latest_revision.title, new_latest_revision.title)

    def test_clear_version_specific_fields(self):
        self.story.prepare_for_writing()
        self.assertEquals(self.story.slug, '')

class InheritanceTests(ModelTests):
    fixtures = ['revisions_scenario', 'fancy_revisions_scenario', 'asides_scenario']
    
    def setUp(self):
        self.story = models.FancyStory.latest.all()[0]    

class BaseModelTests(ModelTests):
    fixtures = ['basemodel_revisions_scenario', 'asides_scenario', ]
    
    def setUp(self):
        self.story = models.ManualStory.latest.all()[0]        

class UUIDModelTests(ModelTests):
    fixtures = ['uuidmodel_revisions_scenario', 'asides_scenario', ]
    
    def setUp(self):
        self.story = models.UUIDStory.latest.all()[0]

    def test_fetch_by_pk(self):
        super(UUIDModelTests, self).test_fetch_by_pk("def")

    def test_get_revisions(self):
        super(UUIDModelTests, self).test_get_revisions(["abc", "def", "ghi"])

    def test_get_prev_revision(self):
        super(UUIDModelTests, self).test_get_prev_revision("def")

    def test_latest_manager(self):
        expected = {
            "old_revision_pks": set(["abc","def","aaa"]),
            "latest_revision_pks": set(["ghi","bbb"]),
            }
        super(UUIDModelTests, self).test_latest_manager(expected)   

class FancyBaseModelTests(ModelTests):
    fixtures = ['basemodel_revisions_scenario', 'basemodel_fancy_revisions_scenario', 'asides_scenario', ]

    def setUp(self):
        self.story = models.FancyManualStory.latest.all()[0]

class UniquenessTests(TestCase):
    def setUp(self):
        self.story = models.UniqueStory(title="hello", body="there")
        self.story.save()
    
    def test_per_version_unique_together(self):
        self.assertRaises(IntegrityError, self.story.revise)

    def test_per_bundle_unique_together(self):
        # shouldn't raise an error
        self.story.title = "hola"
        self.story.revise()
        # this shouldn't either, because title and slug are unique_together per bundle (see UniqueStory.Versioning)
        story = models.UniqueStory(title="hey", slug="hey", body="you")
        story.save()
        story.body = "yonder"
        story.revise()
        # and for that same reason, this new story _should_ raise an IntegrityError
        new_story = models.UniqueStory(title="hey", slug="hey")
        self.assertRaises(IntegrityError, new_story.save)      

    def test_per_bundle_unique(self):
        # body is unique per bundle, and we've used "there" before, 
        # so this won't work
        new_story = models.UniqueStory(title="howdy", body="there")
        self.assertRaises(IntegrityError, new_story.save)

class ForeignKeyTests(TestCase):
    fixtures = ['revisions_scenario', ]
    
    def setUp(self):
        self.story = models.Story.latest.all()[0]
    
    def test_foreign_key_to_bundle(self):
        info = models.InfoToBundle(content="Something something.", story=self.story)
        info.save() 

class ConvenienceTests(TestCase):
    fixtures = ['revisions_scenario', 'asides_scenario']

    def setUp(self):
        self.story = models.Story.latest.all()[0]

    def test_get_related_objects(self):
        # we first count all the asides for this particular revision, and then
        # the amount of asides that are related to the content bundle as a whole
        # the fixtures are configured in such a way that there are fk-linked
        # items to multiple versions of the same story, so this count should differ
        #
        # We test out three ways of doing the same thing. 
        # All three should behave identically.
        related_manager = self.story.aside_set
        revision_pks = [rev.pk for rev in self.story.get_revisions().only(self.story.comparator_name).all()]
        asides = related_manager
        total_asides = self.story._get_related_objects(related_manager)
        total_asides_alt = models.Aside.latest.filter(story__in=revision_pks)
        
        self.assertTrue(total_asides.count() > asides.count())
        self.assertEquals(asides.count(), 1)
        self.assertEquals(total_asides.count(), 3)
        
        # we're comparing whether these two approaches to getting all the related objects
        # return the same stuff, not whether they return it in the same order --
        # that's why we compare sets, not lists.
        self.assertEquals(set(total_asides), set(total_asides_alt))

    def test_get_attribute_history(self):
        # get_attribute_history should be entirely functionally equivalent
        # to the list comprehension below
        body_revisions = [(story.body, story) for story in self.story.get_revisions()]
        body_revisions_shortcut = story._get_attribute_history('body')
        
        self.assertEquals(body_revisions, body_revisions_shortcut)

    def test_getattr_history(self):
        """ This just tests the getattr magic, which is a shortcut to
        _get_attribute_history, which is tested separately. """

        self.assertEquals(self.story.body_history, self.story._get_attribute_history('body'))

    def test_getattr_related(self):
        """ This just tests the getattr magic, which is a shortcut to
        _get_related_objects, which is tested separately. """
        
        without_getattr = self.story._get_related_objects(self.story.aside_set)
        with_getattr = self.story.related_aside_set
        
        self.assertEquals(set(without_getattr), set(with_getattr))

    def test_convenience_shortcuts(self):
        regular = self.story
        short = models.ConvenientStory.objects.get(pk=regular.pk)

        self.assertEquals(regular.get_revisions()[1].title, short.revisions[1].title)
        self.assertNotEquals(regular.get_revisions()[1].title, short.revisions[2].title)

class InheritanceConvenienceTests(ConvenienceTests):
    fixtures = ['revisions_scenario', 'fancy_revisions_scenario', 'asides_scenario']
    
    def setUp(self):
        self.story = models.FancyStory.latest.all()[0]        

class TrashTests(TestCase):
    fixtures = ['trashable_scenario']

    def setUp(self):
        self.story = models.TrashableStory.latest.all()[0]
        self.mgr = models.TrashableStory._default_manager
    
    def test_publicmanager(self):
        self.assertRaises(self.story.__class__.DoesNotExist, 
            self.mgr.trash.get,
            pk=self.story.pk)
        self.assertTrue(self.mgr.live.get(pk=self.story.pk))
    
    def test_delete_bundle(self):
        story_id = self.story.cid
        
        self.story.delete()
        self.assertRaises(self.story.__class__.DoesNotExist, 
            self.mgr.live.get,
            cid=story_id)
        trashed_story = self.mgr.trash.get(cid=story_id)
        for story in trashed_story.get_revisions():
            self.assertTrue(story.is_trash)

    def test_delete_permanently(self):
        story_id = self.story.cid
        self.story.delete_permanently()
        self.assertRaises(self.story.__class__.DoesNotExist, 
            self.mgr.get,
            cid=story_id)

class InheritanceTrashTests(TrashTests):
    fixtures = ['trashable_scenario', 'fancy_trashable_scenario']
    
    def setUp(self):
        self.story = models.FancyTrashableStory.latest.all()[0]
        self.mgr = models.FancyTrashableStory._default_manager

#
# Browser tests
#

users = [
    # Stan is a superuser
    {"username": "Stan", "password": "green pastures"},
    # Fred has pretty much no permissions whatsoever
    {"username": "Fred", "password": "pastures of green"},
    ]

class BrowserTests(TestCase):
    fixtures = ['revisions_scenario', 'users']
    apps = (
        'revisions',
        'revisions.tests',
        'django.contrib.auth',
        'django.contrib.sessions',
        'django.contrib.admin',
        )
    urls = 'revisions.tests.urls'
    
    def setUp(self):
        # some objects we might use directly, instead of via the client
        self.story = models.Story.objects.all()[0]
        user_objs = User.objects.all()
        self.user, self.alt_user = user_objs
        # client setup
        self.c = Client()
        self.c.login(**users[0])
        self.data = {
            'body': u'Hello there!', 
            'small_change': False,
            'title': u'Little big story',
            'aside_set-TOTAL_FORMS': 0,
            'info_set-TOTAL_FORMS': 0,
            'aside_set-INITIAL_FORMS': 0,
            'info_set-INITIAL_FORMS': 0,
            }
    
    def test_save_revision(self):
        response = self.c.post('/admin/tests/story/3/', self.data, follow=True)
        self.assertContains(response, '<a href="6/">Little big story</a>')
    
    def test_save_and_continue_redirect_middleware(self):
        # This test is failing for me, though it works when testing manually
        # Some aspect of middleware testing I'm unaware of?
        
        self.data.update({'_continue': True})
        response = self.c.post('/admin/tests/story/3/', self.data, follow=True)
        self.assertRedirects(response, '/admin/tests/story/6/')
    
    def test_frontend_redirects(self):
        # utils redirects testen in browser
        raise NotImplementedError()
    
    def test_revisionform(self):
        # tests whether fields specified in Versioning.clear_each_revision
        # (e.g. 'title') are empty as they should be; 
        # client-side counterpart to ModelTests.test_revisionform
        
        response = self.c.get('/admin/tests/story/3/')
        self.assertContains(response, '<input id="id_title" type="text" class="vTextField" name="title" maxlength="250" />')
########NEW FILE########
__FILENAME__ = urls
# encoding: utf-8

from django.conf.urls.defaults import *
from django.conf import settings
from django.contrib import admin

admin.autodiscover()

urlpatterns = patterns('',
    (r'^admin/', include(admin.site.urls)),
)
########NEW FILE########
__FILENAME__ = utils
# encoding: utf-8

try:
    from django_extensions.db.fields import CreationDateTimeField
except:
    CreationDateTimeField = ImportError

# Since Django 1.2, a simple copy.copy(model) w/ pk = None stopped working.
class ClonableMixin(object):
    def clone(self):    
        duplicate = self.__class__()
        for field in self._meta.fields:
            pk = field.primary_key
            comparator = (field.name is self.comparator_name)
            # people expect these fields to work per-bundle, not per-revision, 
            # so we'll overwrite these values with the old ones
            auto_field = \
                isinstance(field, CreationDateTimeField) or \
                getattr(field, 'auto_now_add', False)

            if not (pk or auto_field or comparator):
                value = getattr(self, field.name)
                setattr(duplicate, field.name, value)
        
        duplicate.save()
        
        # ... but the trick loses all ManyToMany relations.
        for field in self._meta.many_to_many:
            source = getattr(self, field.attname)
            destination = getattr(duplicate, field.attname)
            for item in source.all():
                destination.add(item)

        return duplicate
########NEW FILE########
__FILENAME__ = views
from django.views.generic import direct_to_template
from revisions.models import VersionedModel

def differ(request, compare_baseline_pk, compare_with_pk):
    raise NotImplementedError

def trashcan(request, model=None):
    if not model:
        models = VersionedModel.get_implementations()
    else:
        models = [model]
    
    raise NotImplementedError
########NEW FILE########
