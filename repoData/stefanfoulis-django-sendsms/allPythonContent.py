__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-sendsms documentation build configuration file, created by
# sphinx-quickstart on Sun Aug 21 17:29:36 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

from django.conf import settings
if not settings.configured:
    settings.configure(
        SMS_BACKEND = 'sendsms.backends.locmem.SmsBackend',
    )


# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-sendsms'
copyright = u'2011, Stefan Foulis'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.2'
# The full version, including alpha/beta/rc tags.
release = '0.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-sendsmsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-sendsms.tex', u'django-sendsms Documentation',
   u'Stefan Foulis', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-sendsms', u'django-sendsms Documentation',
     [u'Stefan Foulis'], 1)
]

########NEW FILE########
__FILENAME__ = api
#-*- coding: utf-8 -*-
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.utils.importlib import import_module
from sendsms.utils import load_object


def send_sms(body, from_phone, to, flash=False, fail_silently=False,
             auth_user=None, auth_password=None, connection=None):
    """
    Easy wrapper for send a single SMS to a recipient list. 

    :returns: the number of SMSs sent.
    """
    from sendsms.message import SmsMessage
    connection = connection or get_connection(
        username = auth_user, 
        password = auth_password,
        fail_silently = fail_silently
    )
    return SmsMessage(body=body, from_phone=from_phone, to=to, \
        flash=flash, connection=connection).send()


def send_mass_sms(datatuple, fail_silently=False,
             auth_user=None, auth_password=None, connection=None):
    """
    Given a datatuple of (message, from_phone, to, flash), sends each message to each
    recipient list. 
    
    :returns: the number of SMSs sent.
    """

    from sendsms.message import SmsMessage
    connection = connection or get_connection(
        username = auth_user, 
        password = auth_password,
        fail_silently = fail_silently
    )
    messages = [SmsMessage(message=message, from_phone=from_phone, to=to, flash=flash)
                for message, from_phone, to, flash in datatuple]
    connection.send_messages(messages)


def get_connection(path=None, fail_silently=False, **kwargs):
    """
    Load an sms backend and return an instance of it.

    :param string path: backend python path. Default: sendsms.backends.console.SmsBackend
    :param bool fail_silently: Flag to not throw exceptions on error. Default: False
    :returns: backend class instance.
    :rtype: :py:class:`~sendsms.backends.base.BaseSmsBackend` subclass
    """

    path = path or getattr(settings, 'SENDSMS_BACKEND', 'sendsms.backends.locmem.SmsBackend')
    try:
        mod_name, klass_name = path.rsplit('.', 1)
        mod = import_module(mod_name)
    except AttributeError as e:
        raise ImproperlyConfigured(u'Error importing sms backend module %s: "%s"' % (mod_name, e))

    try:
        klass = getattr(mod, klass_name)
    except AttributeError:
        raise ImproperlyConfigured('Module "%s" does not define a "%s" class' % (mod_name, klass_name))

    return klass(fail_silently=fail_silently, **kwargs)

########NEW FILE########
__FILENAME__ = base
#-*- coding: utf-8 -*-


class BaseSmsBackend(object):
    """
    Base class for sms backend implementations.

    Subclasses must at least overwrite send_messages()
    """
    def __init__(self, fail_silently=False, **kwargs):
        self.fail_silently = fail_silently

    def open(self):
        """
        Open a network connection.

        This method can be overwritten by backend implementations to open a network connection.
        It's up to the backend implementation to track the status of
        a network connection if it's needed by the backend.
        This method can be called by applications to force a single
        network connection to be used when sending multiple SMSs.

        The default implementation does nothing.
        """
        pass

    def close(self):
        """Close a network connection"""
        pass

    def send_messages(self, messages):
        """
        Sends one or more SmsMessage objects and returns the number of messages sent
        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = console
#-*- coding: utf-8 -*-
"""
SMS backend that writes messages to console instead of sending them.

This is a total ripoff of django.core.mail.backends.console
"""
import sys
import threading

from sendsms.backends.base import BaseSmsBackend

class SmsBackend(BaseSmsBackend):
    def __init__(self, *args, **kwargs):
        self.stream = kwargs.pop('stream', sys.stdout)
        self._lock = threading.RLock()
        super(SmsBackend, self).__init__(*args, **kwargs)

    def send_messages(self, messages):
        """Write all messages to the stream in a thread-safe way."""
        if not messages:
            return
        self._lock.acquire()
        try:
            # The try-except is nested to allow for
            # Python 2.4 support (Refs #12147)
            try:
                stream_created = self.open()
                for message in messages:
                    self.stream.write(render_message(message))
                    self.stream.write('\n')
                    self.stream.write('-'*79)
                    self.stream.write('\n')
                    self.stream.flush()  # flush after each message
                if stream_created:
                    self.close()
            except:
                if not self.fail_silently:
                    raise
        finally:
            self._lock.release()
        return len(messages)

def render_message(message):
    return u"""from: %(from)s\nto: %(to)s\nflash: %(flash)s\n%(body)s""" % {
        'from': message.from_phone,
        'to': ", ".join(message.to),
        'flash': message.flash,
        'body': message.body,
    }

########NEW FILE########
__FILENAME__ = dummy
#-*- coding: utf-8 -*-
"""
Dummy sms backend that does nothing.
"""

from sendsms.backends.base import BaseSmsBackend

class SmsBackend(BaseSmsBackend):
    def send_messages(self, messages):
        return len(messages)

########NEW FILE########
__FILENAME__ = esendex
# -*- coding: utf-8 -*-
"""
Esendex sms gateway backend. (http://www.esendex.es/)

Configuration example.
~~~~~~~~~~~~~~~~~~~~~~

Modify your settings.py::
    
    ESENDEX_USERNAME = 'yourusername'
    ESENDEX_PASSWORD = 'mysecretpassword'
    ESENDEX_ACCOUNT = 'account-key-provided-by-esendex'
    ESENDEX_SANDBOX = False # True if yo like test first
    INSTALLED_APPS += ['sendsms']

Usage::
    
    from sendsms.message import SmsMessage
    message = SmsMessage(
        body = 'my 160 chars sms',
        from_phone = '111111111',
        to = ['222222222']
    )
    message.send()
"""

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.utils.encoding import force_unicode

import requests

from .base import BaseSmsBackend

ESENDEX_API_URL = 'https://www.esendex.com/secure/messenger/formpost/SendSMS.aspx'
ESENDEX_USERNAME = getattr(settings, 'ESENDEX_USERNAME', '')
ESENDEX_PASSWORD = getattr(settings, 'ESENDEX_PASSWORD', '')
ESENDEX_ACCOUNT = getattr(settings, 'ESENDEX_ACCOUNT', '')
ESENDEX_SANDBOX = getattr(settings, 'ESENDEX_SANDBOX', False)

class SmsBackend(BaseSmsBackend):
    """ 
    SMS Backend for esendex.es provider.

    The methods "get_xxxxxx" serve to facilitate the inheritance. Thus if a private 
    project in the access data are dynamic, and are stored in the database. A child 
    class overrides the method "get_xxxx" to return data stored in the database.
    """

    def get_username(self):
        return ESENDEX_USERNAME

    def get_password(self):
        return ESENDEX_PASSWORD

    def get_account(self):
        return ESENDEX_ACCOUNT

    def _parse_response(self, response):
        """
        Parse http raw respone into python
        dictionary object.
        
        :param str response: http response
        :returns: response dict
        :rtype: dict
        """

        response_dict = {}
        for line in response.splitlines():
            key, value = response.split("=", 1)
            response_dict[key] = value
        return response_dict

    def _send(self, message):
        """
        Private method for send one message.

        :param SmsMessage message: SmsMessage class instance.
        :returns: True if message is sent else False
        :rtype: bool
        """

        params = {
            'EsendexUsername': self.get_username(),
            'EsendexPassword': self.get_password(),
            'EsendexAccount': self.get_account(), 
            'EsendexOriginator': message.from_phone, 
            'EsendexRecipient': ",".join(message.to),
            'EsendexBody': message.body,
            'EsendexPlainText':'1'
        }
        if ESENDEX_SANDBOX:
            params['EsendexTest'] = '1'

        response = requests.post(ESENDEX_API_URL, params)
        if response.status_code != 200:
            if not self.fail_silently:
                raise Exception('Bad status code')
            else:
                return False
        
        if not response.content.startswith('Result'):
            if not self.fail_silently:
                raise Exception('Bad result')
            else: 
                return False

        response = self._parse_response(response.content)
        
        if ESENDEX_SANDBOX and response['Result'] == 'Test':
            return True
        else:
            if response['Result'].startswith('OK'):
                return True
            else:
                if not self.fail_silently:
                    raise Exception('Bad result')
        
        return False

    def send_messages(self, messages):
        """
        Send messages.

        :param list messages: List of SmsMessage instences.
        :returns: number of messages seded succesful.
        :rtype: int
        """
        counter = 0
        for message in messages:
            res = self._send(message)
            if res:
                counter += 1

        return counter

########NEW FILE########
__FILENAME__ = filebased
"""
SMS backend that writes messages to file instead of sending them.

This is a total ripoff of django.core.mail.backends.filebased
"""

import datetime
import os

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from sendsms.backends.console import SmsBackend as ConsoleSmsBackend

class SmsBackend(ConsoleSmsBackend):
    def __init__(self, *args, **kwargs):
        self._fname = None
        if 'file_path' in kwargs:
            self.file_path = kwargs.pop('file_path')
        else:
            self.file_path = getattr(settings, 'SMS_FILE_PATH', None)
            # Make sure self.file_path is a string.
        if not isinstance(self.file_path, basestring):
            raise ImproperlyConfigured('Path for saving SMS is invalid: %r' % self.file_path)
        self.file_path = os.path.abspath(self.file_path)
        # Make sure that self.file_path is an directory if it exists.
        if os.path.exists(self.file_path) and not os.path.isdir(self.file_path):
            raise ImproperlyConfigured('Path for saving SMS messages exists, but is not a directory: %s' % self.file_path)
        # Try to create it, if it not exists.
        elif not os.path.exists(self.file_path):
            try:
                os.makedirs(self.file_path)
            except OSError, err:
                raise ImproperlyConfigured('Could not create directory for saving SMS messages: %s (%s)' % (self.file_path, err))
            # Make sure that self.file_path is writable.
        if not os.access(self.file_path, os.W_OK):
            raise ImproperlyConfigured('Could not write to directory: %s' % self.file_path)
            # Finally, call super().
        # Since we're using the console-based backend as a base,
        # force the stream to be None, so we don't default to stdout
        kwargs['stream'] = None
        super(SmsBackend, self).__init__(*args, **kwargs)

    def _get_filename(self):
        """Return a unique file name."""
        if self._fname is None:
            timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
            fname = "%s-%s.log" % (timestamp, abs(id(self)))
            self._fname = os.path.join(self.file_path, fname)
        return self._fname

    def open(self):
        if self.stream is None:
            self.stream = open(self._get_filename(), 'a')
            return True
        return False

    def close(self):
        try:
            if self.stream is not None:
                self.stream.close()
        finally:
            self.stream = None

########NEW FILE########
__FILENAME__ = locmem
#-*- coding: utf-8 -*-
"""
Backend for test environment.
"""

import sendsms
from sendsms.backends.base import BaseSmsBackend

class SmsBackend(BaseSmsBackend):
    """
    A sms backend for use during test sessions.

    The test connection stores messages in a dummy outbox,
    rather than sending them out on the wire.
    The dummy outbox is accessible through the outbox instance attribute.
    """
    def __init__(self, *args, **kwargs):
        super(SmsBackend, self).__init__(*args, **kwargs)
        if not hasattr(sendsms, 'outbox'):
            sendsms.outbox = []

    def send_messages(self, messages):
        """Redirect messages to the dummy outbox"""
        sendsms.outbox.extend(messages)
        return len(messages)

########NEW FILE########
__FILENAME__ = smsglobal
"""SMS Global sms backend class."""
from django.conf import settings
import urllib2
import urllib
import re
import logging
import math
from .base import BaseSmsBackend
from decimal import Decimal

logger = logging.getLogger(__name__)

SMSGLOBAL_USERNAME = getattr(settings, 'SMSGLOBAL_USERNAME', '')
SMSGLOBAL_PASSWORD = getattr(settings, 'SMSGLOBAL_PASSWORD', '')
SMSGLOBAL_CHECK_BALANCE_COUNTRY = getattr(settings, 'SMSGLOBAL_CHECK_BALANCE_COUNTRY', False)
SMSGLOBAL_API_URL_SENDSMS = 'https://www.smsglobal.com.au/http-api.php'
SMSGLOBAL_API_URL_CHECKBALANCE = 'https://www.smsglobal.com/credit-api.php'

class SmsBackend(BaseSmsBackend):
    """
    A wrapper that manages the SMS Global network connection.
    
    Sending and parsing functionality borrowed from http://namingcrisis.net/code
    """

    def get_username(self):
        return SMSGLOBAL_USERNAME
    
    def get_password(self):
        return SMSGLOBAL_PASSWORD

    def get_balance(self):
        """
        Get balance with provider.
        """
        if not SMSGLOBAL_CHECK_BALANCE_COUNTRY:
            raise Exception('SMSGLOBAL_CHECK_BALANCE_COUNTRY setting must be set to check balance.')
        
        params = {
          'user' : self.get_username(),
          'password' : self.get_password(),
          'country' : SMSGLOBAL_CHECK_BALANCE_COUNTRY,
        }
        
        req = urllib2.Request(SMSGLOBAL_API_URL_CHECKBALANCE, urllib.urlencode(params))
        response = urllib2.urlopen(req).read()

        # CREDITS:8658.44;COUNTRY:AU;SMS:3764.54;
        if response.startswith('ERROR'):
            raise Exception('Error retrieving balance: %s' % response.replace('ERROR:', ''))
        
        return dict([(p.split(':')[0].lower(), p.split(':')[1]) for p in response.split(';') if len(p) > 0])

    def send_messages(self, sms_messages):
        """
        Sends one or more SmsMessage objects and returns the number of sms
        messages sent.
        """
        if not sms_messages:
            return
        
        num_sent = 0
        for message in sms_messages:
            if self._send(message):
                num_sent += 1
        return num_sent

    def _send(self, message):
        """A helper method that does the actual sending."""
        charset='UTF-8'
        params = {
          'action' : 'sendsms',
          'user' : self.get_username(),
          'password' : self.get_password(),
          'from' : message.from_phone,
          'to' : ",".join(message.to),
          'text' : message.body,
          'clientcharset' : charset,
          'detectcharset' : 1,
          'maxsplit': int(math.ceil(len(message.body) / 160))
        }
        
        req = urllib2.Request(SMSGLOBAL_API_URL_SENDSMS, urllib.urlencode(params))
        result_page = urllib2.urlopen(req).read()
        results = self._parse_response(result_page)
        
        if results is None:
            if not self.fail_silently:
                raise Exception("Error determining response: [" + result_page + "]")
            return False
        
        code, sendqmsgid, msgid = results
        
        if code != '0':
            if not self.fail_silently:
                raise Exception("Error sending sms: [%s], extracted results(code, sendqmsgid, msgid): [%s]" % (result_page, results))
            return False
        else:
            logger.info('SENT to: %s; sender: %s; code: %s; sendqmsgid: %s; msgid: %s; message: %s' % (
                message.to,
                message.from_phone,
                code, 
                sendqmsgid, 
                msgid,
                message.body
            ))
            return True
    
    def _parse_response(self, result_page):
        """
        Takes a result page of sending the sms, returns an extracted tuple:
            ('numeric_err_code', '<sent_queued_message_id>', '<smsglobalmsgid>')
        Returns None if unable to extract info from result_page, it should be
        safe to assume that it was either a failed result or worse, the interface
        contract has changed.
        """
        # Sample result_page, single line -> "OK: 0; Sent queued message ID: 2063619577732703 SMSGlobalMsgID:6171799108850954"
        resultline = result_page.splitlines()[0] # get result line
        if resultline.startswith('ERROR:'):
            raise Exception(resultline.replace('ERROR: ', ''))
        patt = re.compile(r'^.+?:\s*(.+?)\s*;\s*Sent queued message ID:\s*(.+?)\s*SMSGlobalMsgID:(.+?)$', re.IGNORECASE)
        m = patt.match(resultline)
        if m:
            return (m.group(1), m.group(2), m.group(3)) 
        return None       
########NEW FILE########
__FILENAME__ = smspubli
# -*- coding: utf-8 -*-

"""
SmsPubli sms gateway backend. (http://www.smspubli.com)

Configuration example.
----------------------

Modify your settings.py::

    SMSPUBLI_USERNAME = 'yourusername'
    SMSPUBLI_PASSWORD = 'mysecretpassword'
    SMSPUBLI_ALLOW_LONG_SMS = True # or False
    INSTALLED_APPS += ['sendsms']


Usage::

    from sendsms.message import SmsMessage
    message = SmsMessage(
        body = 'my 160 chars sms',
        from_phone = '111111111',
        to = ['222222222']
    )
    message.send()
"""

import requests, logging
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.utils.encoding import force_unicode

from .base import BaseSmsBackend

SMSPUBLI_API_URL = 'https://secure.gateway360.com/api/push/'
SMSPUBLI_API_VERSION = 'HTTPV3'
SMSPUBLI_DC = 'SMS'
SMSPUBLI_DR = 0
SMSPUBLI_ROUTE = 2

SMSPUBLI_USERNAME = getattr(settings, 'SMSPUBLI_USERNAME', '')
SMSPUBLI_PASSWORD = getattr(settings, 'SMSPUBLI_PASSWORD', '')
SMSPUBLI_ALLOW_LONG_SMS = getattr(settings, 'SMSPUBLI_ALLOW_LONG_SMS', False)

class SmsBackend(BaseSmsBackend):
    """ 
    SMS Backend smspubli.com provider.

    The methods "get_xxxxxx" serve to facilitate the inheritance. Thus if a private 
    project in the access data are dynamic, and are stored in the database. A child 
    class overrides the method "get_xxxx" to return data stored in the database.
    """

    def get_username(self):
        return SMSPUBLI_USERNAME
    
    def get_password(self):
        return SMSPUBLI_PASSWORD

    def _send(self, message):
        """
        Private method for send one message.

        :param SmsMessage message: SmsMessage class instance.
        :returns: True if message is sended else False
        :rtype: bool
        """

        params = {
            'V': SMSPUBLI_API_VERSION, 
            'UN': SMSPUBLI_USERNAME, 
            'PWD': SMSPUBLI_PASSWORD,
            'R': SMSPUBLI_ROUTE, 
            'SA': message.from_phone,
            'DA': ','.join(message.to),
            'M': message.body.encode('latin-1'),
            'DC': SMSPUBLI_DC,
            'DR': SMSPUBLI_DR, 
            'UR': message.from_phone
        }
        if SMSPUBLI_ALLOW_LONG_SMS:
            params['LM'] = '1'

        response = requests.post(SMSPUBLI_API_URL, params)
        if response.status_code != 200:
            if  not self.fail_silently:
                raise
            else:
                return False

        response_msg, response_code = response.content.split(':')
        if response_msg == 'OK':
            try:
                if "," in response_code:
                    codes = map(int, response_code.split(","))
                else:
                    codes = [int(response_code)]

                for code in codes:
                    if code == -5:
                        #: TODO send error signal (no $$)
                        pass
                    elif code == -3:
                        #: TODO send error signal (incorrect num)
                        pass

                return True

            except (ValueError, TypeError):
                if not self.fail_silently:
                    raise
                return False
        
        return False

    def send_messages(self, messages):
        """
        Send messages.

        :param list messages: List of SmsMessage instences.
        :returns: number of messages seded succesful.
        :rtype: int
        """

        counter = 0
        for message in messages:
            res = self._send(message)
            if res:
                counter += 1

        return counter

########NEW FILE########
__FILENAME__ = smssluzbacz
#    The New BSD License
#
#    Copyright (c) 2011-2012, CodeScale s.r.o.
#    All rights reserved.
#
#    Redistribution and use in source and binary forms, with or without modification,
#    are permitted provided that the following conditions are met:
#
#    * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#
#    * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
#    * Neither the name of CodeScale s.r.o. nor the names of its contributors
#    may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
#    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
#    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import logging
import unicodedata

from smssluzbacz_api.lite import SmsGateApi
from django.conf import settings

from sendsms.backends.base import BaseSmsBackend


log = logging.getLogger(__name__)


class SmsBackend(BaseSmsBackend):
    """SmsBackend for sms.sluzba.cz API.

    settings.py configuration constants:
      SMS_SLUZBA_API_LOGIN - sms.sluzba.cz login
      SMS_SLUZBA_API_PASSWORD - sms.sluzba.cz password
      SMS_SLUZBA_API_TIMEOUT - connection timeout to sms.sluzba.cz in seconds
      SMS_SLUZBA_API_USE_SSL - whether to use ssl via http or not
      SMS_SLUZBA_API_USE_POST - whether to use GET or POST http method

    """

    def __init__(self, fail_silently=False, **kwargs):
        super(SmsBackend, self).__init__(fail_silently=fail_silently, **kwargs)
        self.open()

    def __del__(self):
        self.close()

    def open(self):
        """Initializes sms.sluzba.cz API library."""
        self.client = SmsGateApi(getattr(settings, 'SMS_SLUZBA_API_LOGIN', ''),
                                 getattr(settings, 'SMS_SLUZBA_API_PASSWORD', ''),
                                 getattr(settings, 'SMS_SLUZBA_API_TIMEOUT', 2),
                                 getattr(settings, 'SMS_SLUZBA_API_USE_SSL', True))

    def close(self):
        """Cleaning up the reference for sms.sluzba.cz API library."""
        self.client = None

    def send_messages(self, messages):
        """Sending SMS messages via sms.sluzba.cz API.

        Note:
          This method returns number of actually sent sms messages
          not number of SmsMessage instances processed.

        :param messages: list of sms messages
        :type messages: list of sendsms.message.SmsMessage instances
        :returns: number of sent sms messages
        :rtype: int

        """
        count = 0
        for message in messages:
            message_body = unicodedata.normalize('NFKD', unicode(message.body)).encode('ascii', 'ignore')
            for tel_number in message.to:
                try:
                    self.client.send(tel_number, message_body, getattr(settings, 'SMS_SLUZBA_API_USE_POST', True))
                except Exception:
                    if self.fail_silently:
                        log.exception('Error while sending sms via sms.sluzba.cz backend API.')
                    else:
                        raise
                else:
                    count += 1

        return count
########NEW FILE########
__FILENAME__ = twiliorest
#-*- coding: utf-8 -*-
"""
this backend requires the twilio python library: http://pypi.python.org/pypi/twilio/
"""
from twilio.rest import TwilioRestClient
from django.conf import settings
from sendsms.backends.base import BaseSmsBackend

TWILIO_ACCOUNT_SID = getattr(settings, 'SENDSMS_TWILIO_ACCOUNT_SID', '')
TWILIO_AUTH_TOKEN = getattr(settings, 'SENDSMS_TWILIO_AUTH_TOKEN', '')

class SmsBackend(BaseSmsBackend):
    def send_messages(self, messages):
        client = TwilioRestClient(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
        for message in messages:
            for to in message.to:
                try:
                    msg = client.sms.messages.create(
                        to=to,
                        from_=message.from_phone,
                        body=message.body
                    )
                except:
                    if not self.fail_silently:
                        raise
########NEW FILE########
__FILENAME__ = exceptions

class InvalidPhoneNumber(Exception):
    """
    The backends can use this exception to raise a standardized exception, if the
    backend returns an error code related to the phone number.
    """
    pass
########NEW FILE########
__FILENAME__ = message
#-*- coding: utf-8 -*-
from sendsms.api import get_connection
from sendsms.signals import sms_post_send
from django.conf import settings

class SmsMessage(object):
    """
    A sms message
    """
    def __init__(self, body, from_phone=None, to=None, flash=False, connection=None):
        """
        Initialize a single SMS message (which can be sent to multiple recipients)
        """
        if to:
            #assert not isinstance(to, basetring), '"to" argument must be a list or tuple'
            self.to = list(to)
        else:
            self.to = []

        self.from_phone = from_phone or getattr(settings, 'SENDSMS_DEFAULT_FROM_PHONE', '')
        self.body = body
        self.flash = flash
        self.connection = connection

    def get_connection(self, fail_silently=False):
        if not self.connection:
            self.connection = get_connection(fail_silently=fail_silently)
        return self.connection

    def send(self, fail_silently=False):
        """
        Sends the sms message
        """
        if not self.to:
            # Don't bother creating the connection if there's nobody to send to
            return 0
        res = self.get_connection(fail_silently).send_messages([self])
        sms_post_send.send(sender=self, to=self.to, from_phone=self.from_phone, body=self.body)
        return res


########NEW FILE########
__FILENAME__ = signals
# -*- coding: utf-8 -*-
import django.dispatch
sms_post_send = django.dispatch.Signal(providing_args=['from_phone','to','body'])

########NEW FILE########
__FILENAME__ = utils
#-*- coding: utf-8 -*-
from importlib import import_module

def load_object(import_path):
    """
    Shamelessly stolen from https://github.com/ojii/django-load
    
    Loads an object from an 'import_path', like in MIDDLEWARE_CLASSES and the
    likes.

    Import paths should be: "mypackage.mymodule.MyObject". It then imports the
    module up until the last dot and tries to get the attribute after that dot
    from the imported module.

    If the import path does not contain any dots, a TypeError is raised.

    If the module cannot be imported, an ImportError is raised.

    If the attribute does not exist in the module, a AttributeError is raised.
    """
    if '.' not in import_path:
        raise TypeError(
            "'import_path' argument to 'load_object' must "
            "contain at least one dot."
        )
    module_name, object_name = import_path.rsplit('.', 1)
    module = import_module(module_name)
    return getattr(module, object_name)

########NEW FILE########
__FILENAME__ = test
# -*- coding: utf-8 -*-

import unittest
from django.conf import settings

import sendsms

if not settings.configured:
    settings.configure(
        SENDSMS_BACKEND = 'sendsms.backends.locmem.SmsBackend',
        ESENDEX_USERNAME = 'niwibe',
        ESENDEX_PASSWORD = '123123',
        ESENDEX_ACCOUNT = '123123',
        ESENDEX_SANDBOX = True,
    )


class TestApi(unittest.TestCase):
    def test_send_simple_sms(self):
        from sendsms.message import SmsMessage
        obj = SmsMessage(body="test", from_phone='111111111', to=['222222222'])
        obj.send()

        self.assertEqual(len(sendsms.outbox), 1)

    def test_send_esendex_sandbox(self):
        from sendsms.message import SmsMessage
        from sendsms.api import get_connection

        connection = get_connection('sendsms.backends.esendex.SmsBackend')
        obj = SmsMessage(body="test", from_phone='111111111', to=['222222222'], connection=connection)
        res = obj.send()
        self.assertEqual(res, 1)


if __name__ == '__main__':
    unittest.main(verbosity=2)



########NEW FILE########
