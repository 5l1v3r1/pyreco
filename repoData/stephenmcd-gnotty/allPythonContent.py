__FILENAME__ = conf
# This file is automatically generated via sphinx-me
from sphinx_me import setup_conf; setup_conf(globals())

########NEW FILE########
__FILENAME__ = admin

from django.contrib import admin

from gnotty.models import IRCMessage


class IRCMessageAdmin(admin.ModelAdmin):

    list_display = ("message_time", "server", "channel", "nickname",
                    "short_message")
    list_filter = ("server", "channel", "nickname")
    search_fields = ("channel", "nickname", "message")
    date_hierarchy = "message_time"


admin.site.register(IRCMessage, IRCMessageAdmin)

########NEW FILE########
__FILENAME__ = base

from collections import defaultdict
from inspect import getargspec
from logging import Formatter, StreamHandler, getLogger
from re import match

from gevent import sleep, spawn

from gnotty.client import BaseIRCClient
from gnotty.conf import settings


class BaseBot(BaseIRCClient):
    """
    Base bot class. Bots can be built by subclassing ``BaseBot`` and
    using mixins that define event handlers. The subclass itself can
    also implement the event handlers. See the README for more info
    on event handlers.
    """

    class __metaclass__(type):
        def __new__(cls, name, bases, attrs):
            """
            Build a dict mapping event names to their handler methods,
            which are any methods defined on any classes in the
            inheritance heirarchy, that have been marked with an
            "event" attribute, which gets assgined by the
            ``gnotty.bots.events.on`` decorator.
            """
            def all_bases(bases):
                for base in bases:
                    yield base
                    for base in all_bases(base.__bases__):
                        yield base
            base_values = [b.__dict__.values() for b in set(all_bases(bases))]
            attrs["events"] = defaultdict(list)
            for member in sum(base_values, attrs.values()):
                if hasattr(member, "event"):
                    attrs["events"][member.event.name].append(member)
            return type.__new__(cls, name, bases, attrs)

    def __init__(self, *args, **kwargs):
        """
        Sets up logging and interval events.
        """
        super(BaseBot, self).__init__(*args, **kwargs)
        fmt = Formatter("[%(server)s%(channel)s] %(nickname)s: %(message)s")
        handler = StreamHandler()
        handler.setFormatter(fmt)
        logger = getLogger("irc.message")
        logger.setLevel(settings.LOG_LEVEL)
        logger.addHandler(handler)
        # Spawn a thread (greenlet) for each timer event handler.
        for handler in self.events.get("timer", []):
            spawn(self.handle_timer_event, handler)

    def _dispatcher(self, connection, event):
        """
        This is the method in ``SimpleIRCClient`` that all IRC events
        get passed through. Here we map events to our own custom
        event handlers, and call them.
        """
        super(BaseBot, self)._dispatcher(connection, event)
        for handler in self.events[event.eventtype()]:
            handler(self, connection, event)

    def log(self, event, message, join_or_leave=False):
        extra = {
            "server": self.connection.server,
            "channel": self.channel,
            "nickname": self.get_nickname(event) if event else self.nickname,
            "join_or_leave": join_or_leave,
        }
        getLogger("irc.message").info(message, extra=extra)

    def message_channel(self, message):
        """
        We won't receive our own messages, so log them manually.
        """
        self.log(None, message)
        super(BaseBot, self).message_channel(message)

    def on_join(self, connection, event):
        self.log(event, "joins", join_or_leave=True)

    def on_quit(self, connection, event):
        self.log(event, "leaves", join_or_leave=True)

    def on_nick(self, connection, event):
        self.log(event, "is now known as %s" % event.target())

    def on_pubmsg(self, connection, event):
        """
        Log any public messages, and also handle the command event.
        """
        for message in event.arguments():
            self.log(event, message)
            command_args = filter(None, message.split())
            command_name = command_args.pop(0)
            for handler in self.events["command"]:
                if handler.event.args["command"] == command_name:
                    self.handle_command_event(event, handler, command_args)

    def handle_command_event(self, event, command, args):
        """
        Command handler - treats each word in the message
        that triggered the command as an argument to the command,
        and does some validation to ensure that the number of
        arguments match.
        """
        argspec = getargspec(command)
        num_all_args = len(argspec.args) - 2  # Ignore self/event args
        num_pos_args = num_all_args - len(argspec.defaults or [])
        if num_pos_args <= len(args) <= num_all_args:
            response = command(self, event, *args)
        elif num_all_args == num_pos_args:
            s = "s are" if num_all_args != 1 else " is"
            response = "%s arg%s required" % (num_all_args, s)
        else:
            bits = (num_pos_args, num_all_args)
            response = "between %s and %s args are required" % bits
        response = "%s: %s" % (self.get_nickname(event), response)
        self.message_channel(response)

    def handle_timer_event(self, handler):
        """
        Runs each timer handler in a separate greenlet thread.
        """
        while True:
            handler(self)
            sleep(handler.event.args["seconds"])

    def handle_webhook_event(self, environ, url, params):
        """
        Webhook handler - each handler for the webhook event
        takes an initial pattern argument for matching the URL
        requested. Here we match the URL to the pattern for each
        webhook handler, and bail out if it returns a response.
        """
        for handler in self.events["webhook"]:
            urlpattern = handler.event.args["urlpattern"]
            if not urlpattern or match(urlpattern, url):
                response = handler(self, environ, url, params)
                if response:
                    return response

########NEW FILE########
__FILENAME__ = chat

from random import choice, randint

from gevent import sleep

from gnotty.bots import events


class ChatMixin(object):
    """
    Mixin for a chat bot that greets and responds to people.
    """

    def __init__(self, *args, **kwargs):
        super(ChatMixin, self).__init__(*args, **kwargs)
        self.chatbots = []
        self.greetings = ("Hi", "Hello", "Howdy", "Welcome")
        try:
            from nltk.chat import bots
        except ImportError:
            from warnings import warn
            warn("ChatMixin requires nltk installed")
        else:
            get_bot = lambda x: x[0].func_globals["%sbot" % x[0].__name__]
            self.chatbots = map(get_bot, bots)

    def message_channel_delayed(self, message):
        """
        Pause for a random few seconds before messaging, to seem less
        bot like.
        """
        sleep(randint(2, 5))
        self.message_channel(message)

    @events.on("join")
    def greet(self, connection, event):
        nickname = self.get_nickname(event)
        greeting = choice(self.greetings)
        if nickname != self.nickname:
            self.message_channel_delayed("%s: %s" % (nickname, greeting))

    @events.on("pubmsg")
    def respond(self, connection, event):
        if not self.chatbots:
            return
        for message in event.arguments():
            prefix = "%s: " % self.nickname
            if message.startswith(prefix):
                nickname = self.get_nickname(event)
                chatbot = choice(self.chatbots)
                reply = chatbot.respond(message.replace(prefix, "", 1))
                self.message_channel_delayed("%s: %s" % (nickname, reply))

########NEW FILE########
__FILENAME__ = commands

from datetime import datetime
from inspect import getdoc, getargspec

from gnotty.bots import events
from gnotty.conf import settings


class CommandMixin(object):
    """
    Mixin for bots that provides a handful of basic commands.
    """

    def __init__(self, *args, **kwargs):
        self.joined = {}
        self.quit = {}
        super(CommandMixin, self).__init__(*args, **kwargs)

    @events.on("namreply")
    def handle_joined(self, connection, event):
        """
        Store join times for current nicknames when we first join.
        """
        nicknames = [s.lstrip("@+") for s in event.arguments()[-1].split()]
        for nickname in nicknames:
            self.joined[nickname] = datetime.now()

    @events.on("join")
    def handle_join(self, connection, event):
        """
        Store join time for a nickname when it joins.
        """
        nickname = self.get_nickname(event)
        self.joined[nickname] = datetime.now()

    @events.on("quit")
    def handle_quit(self, connection, event):
        """
        Store quit time for a nickname when it quits.
        """
        nickname = self.get_nickname(event)
        self.quit[nickname] = datetime.now()
        del self.joined[nickname]

    def timesince(self, when):
        """
        Returns human friendly version of the timespan between now
        and the given datetime.
        """
        units = (
            ("year",   60 * 60 * 24 * 365),
            ("week",   60 * 60 * 24 * 7),
            ("day",    60 * 60 * 24),
            ("hour",   60 * 60),
            ("minute", 60),
            ("second", 1),
        )
        delta = datetime.now() - when
        total_seconds = delta.days * 60 * 60 * 24 + delta.seconds
        parts = []
        for name, seconds in units:
            value = total_seconds / seconds
            if value > 0:
                total_seconds %= seconds
                s = "s" if value != 1 else ""
                parts.append("%s %s%s" % (value, name, s))
        return " and ".join(", ".join(parts).rsplit(", ", 1))

    def commands_dict(self):
        commands = self.events["command"]
        return dict([(c.event.args["command"], c) for c in commands])

    ##############
    #  Commands  #
    ##############

    @events.on("command", command="!version")
    def version(self, event):
        """
        Shows version information.
        """
        name = "%s.%s" % (self.__class__.__module__, self.__class__.__name__)
        return "%s [%s]" % (settings.GNOTTY_VERSION_STRING, name)

    @events.on("command", command="!commands")
    def commands(self, event):
        """
        Lists all available commands.
        """
        commands = sorted(self.commands_dict().keys())
        return "Available commands: %s" % " ".join(commands)

    @events.on("command", command="!help")
    def help(self, event, command_name=None):
        """
        Shows the help message for the bot. Takes an optional command name
        which when given, will show help for that command.
        """
        if command_name is None:
            return ("Type !commands for a list of all commands. Type "
                    "!help [command] to see help for a specific command.")
        try:
            command = self.commands_dict()[command_name]
        except KeyError:
            return "%s is not a command" % command_name

        argspec = getargspec(command)
        args = argspec.args[2:]
        defaults = argspec.defaults or []
        for i in range(-1, -len(defaults) - 1, -1):
            args[i] = "%s [default: %s]" % (args[i], defaults[i])
        args = ", ".join(args)
        help = getdoc(command).replace("\n", " ")
        return "help for %s: (args: %s) %s" % (command_name, args, help)

    @events.on("command", command="!uptime")
    def uptime(self, event, nickname=None):
        """
        Shows the amount of time since the given nickname has been
        in the channel. If no nickname is given, I'll use my own.
        """
        if nickname and nickname != self.nickname:
            try:
                uptime = self.timesince(self.joined[nickname])
            except KeyError:
                return "%s is not in the channel" % nickname
            else:
                if nickname == self.get_nickname(event):
                    prefix = "you have"
                else:
                    prefix = "%s has" % nickname
                return "%s been here for %s" % (prefix, uptime)
        uptime = self.timesince(self.joined[self.nickname])
        return "I've been here for %s" % uptime

    @events.on("command", command="!seen")
    def seen(self, event, nickname):
        """
        Shows the amount of time since the given nickname was last
        seen in the channel.
        """
        try:
            self.joined[nickname]
        except KeyError:
            pass
        else:
            if nickname == self.get_nickname(event):
                prefix = "you are"
            else:
                prefix = "%s is" % nickname
            return "%s here right now" % prefix
        try:
            seen = self.timesince(self.quit[nickname])
        except KeyError:
            return "%s has never been seen" % nickname
        else:
            return "%s was last seen %s ago" % (nickname,  seen)

    @events.on("command", command="!users")
    def users(self, event):
        """
        Shows the list of users currently in the channel.
        """
        return "Current users: %s" % ", ".join(sorted(self.joined.keys()))

########NEW FILE########
__FILENAME__ = commits

from json import loads

from gnotty.bots import events


class CommitMixin(object):
    """
    Base mixin for DCVS post-push webhooks. Defines the
    ``handle_payload`` method that accepts a  ``CommitPayload``
    instance, and converts it into messages to send back to the
    IRC channel.
    """

    def handle_payload(self, payload):
        commit = lambda c: "%s - %s" % (c["message"], payload.author(c))
        messages = [commit(c) for c in payload.commits()]
        if len(messages) == 1:
            commit_url = payload.commit_url(payload.commits()[0])
            messages[0] = "%s %s" % (messages[0], commit_url)
        else:
            messages.insert(0, "%s new commits:" % len(payload.commits()))
            messages.append("Compare view: %s" % payload.diff_url())
        for message in messages:
            self.message_channel(message)


class CommitPayload(object):
    """
    Base class for commit payloads. Commit payloads define each
    of the methods for extracting the relevant bits of information
    from the commit payload, that ``CommitMixin`` expects in order
    to be able to convert the commits into messages.
    """

    def __init__(self, payload):
        self.payload = payload

    def commits(self):
        return self.payload["commits"]

    def author(self, commit):
        raise NotImplementedError

    def commit_url(self, commit):
        raise NotImplementedError

    def diff_url(self):
        raise NotImplementedError


class GitHubPayload(CommitPayload):
    """
    GitHub payload handler.
    """

    def author(self, commit):
        return commit["committer"]["name"]

    def commit_url(self, commit):
        return commit["url"]

    def diff_url(self):
        return self.payload["compare"].replace("^", "")


class GitHubMixin(CommitMixin):
    """
    Mixin for GitHub post-push webhook bot.
    """

    @events.on("webhook", urlpattern="^/webhook/github/$")
    def github_payload(self, environ, url, params):
        payload = loads(params["payload"])
        self.handle_payload(GitHubPayload(payload))


class BitBucketPayload(CommitPayload):
    """
    Mixin for Bitbucket post-push webhook bot.
    """

    def repo_url(self):
        host = self.payload["canon_url"]
        return "%s%s" % (host, self.payload["repository"]["absolute_url"])

    def author(self, commit):
        return commit["raw_author"].split("<")[0]

    def commit_url(self, commit):
        return "%schangeset/%s/" % (self.repo_url(), commit["node"])

    def diff_url(self):
        first, last = self.commits()[0]["node"], self.commits()[-1]["node"]
        return "%scompare/%s..%s" % (self.repo_url(), first, last)


class BitBucketMixin(CommitMixin):
    """
    Bitbucket payload handler.
    """

    @events.on("webhook", urlpattern="^/webhook/bitbucket/$")
    def bitbucket_payload(self, environ, url, params):
        payload = loads(params["payload"])
        self.handle_payload(BitBucketPayload(payload))

########NEW FILE########
__FILENAME__ = events

from collections import namedtuple


Event = namedtuple("Event", ["name", "args"])


def on(event, *args, **kwargs):
    """
    Event method wrapper for bot mixins. When a bot is constructed,
    its metaclass inspects all members of all base classes, and
    looks for methods marked with an event attribute which is assigned
    via this wrapper. It then stores all the methods in a dict
    that maps event names to lists of these methods, which are each
    called when the event occurs.
    """
    def wrapper(func):
        for i, arg in args:
            kwargs[i] = arg
        func.event = Event(event, kwargs)
        return func
    return wrapper

########NEW FILE########
__FILENAME__ = rss

try:
    from feedparser import parse
except ImportError:
    parse = None

from gnotty.bots import events


class RSSMixin(object):
    """
    Mixin for bots that consume RSS feeds and post them to the
    channel. Feeds are defined by the ``feeds`` keyword arg to
    ``__init__``, and should contain a sequence of RSS feed URLs.

    Requires the ``feedparser`` library to be installed.
    """

    def __init__(self, *args, **kwargs):
        if parse is None:
            from warnings import warn
            warn("RSSMixin requires feedparser installed")
        self.feeds = kwargs.pop("feeds", [])
        self.feed_items = set()
        # Consume initial feed items without posting them.
        self.parse_feeds(message_channel=False)
        super(RSSMixin, self).__init__(*args, **kwargs)

    @events.on("timer", seconds=60)
    def parse_feeds(self, message_channel=True):
        """
        Iterates through each of the feed URLs, parses their items, and
        sends any items to the channel that have not been previously
        been parsed.
        """
        if parse:
            for feed_url in self.feeds:
                feed = parse(feed_url)
                for item in feed.entries:
                    if item["id"] not in self.feed_items:
                        self.feed_items.add(item["id"])
                        if message_channel:
                            message = self.format_item_message(feed, item)
                            self.message_channel(message)
                            return

    def format_item_message(self, feed, item):
        item["feed_title"] = feed.feed.title or feed.url
        return "%(title)s: %(id)s (via %(feed_title)s)" % item


########NEW FILE########
__FILENAME__ = client

from logging import getLogger
from hashlib import md5

from irc.client import SimpleIRCClient, ServerConnectionError

from gnotty.conf import settings


def color(nickname):
    """
    Provides a consistent color for a nickname. Uses first 6 chars
    of nickname's md5 hash, and then slightly darkens the rgb values
    for use on a light background.
    """
    _hex = md5(nickname).hexdigest()[:6]
    darken = lambda s: str(int(round(int(s, 16) * .7)))
    return "rgb(%s)" % ",".join([darken(_hex[i:i+2]) for i in range(6)[::2]])


class BaseIRCClient(SimpleIRCClient, object):
    """
    Base class for IRC clients. Handles initial connection and
    channel join. Currently only supports a single channel.
    """

    def __init__(self, host, port, channel, nickname, password):
        SimpleIRCClient.__init__(self)
        self.host = host
        self.port = int(port) if str(port).isdigit() else 6667
        self.channel = channel
        self.nickname = nickname
        self.password = password or None
        self.reconnect()

    def reconnect(self):
        args = (self.host, self.port, self.nickname)
        try:
            self.connect(*args, password=self.password)
            return True
        except ServerConnectionError:
            return False

    def _dispatcher(self, connection, event):
        if not callable(event.arguments):
            # irclib decided to change the event API, so here
            # we make it backward compatible.
            arguments = event.arguments
            event.arguments = lambda: arguments
            event.eventtype = lambda: event.type
            source = event.source
            event.source = lambda: source
        event_args = "".join(event.arguments()).decode("utf-8")
        log = (event.eventtype(), self.nickname, event_args)
        getLogger("irc.dispatch").debug("%s: [%s] %s" % log)
        SimpleIRCClient._dispatcher(self, connection, event)

    def get_nickname(self, event):
        """
        Format a nickname.
        """
        return event.source().split("!")[0]

    def on_welcome(self, connection, event):
        """
        Join the channel once connected to the IRC server.
        """
        connection.join(self.channel, key=settings.IRC_CHANNEL_KEY or "")

    def on_nicknameinuse(self, connection, event):
        """
        Increment a digit on the nickname if it's in use, and
        re-connect.
        """
        digits = ""
        while self.nickname[-1].isdigit():
            digits = self.nickname[-1] + digits
            self.nickname = self.nickname[:-1]
        digits = 1 if not digits else int(digits) + 1
        self.nickname += str(digits)
        self.connect(self.host, self.port, self.nickname)

    def message_channel(self, message):
        """
        Nicer shortcut for sending a message to a channel. Also
        irclib doesn't handle unicode so we bypass its
        privmsg -> send_raw methods and use its socket directly.
        """
        data = "PRIVMSG %s :%s\r\n" % (self.channel, message)
        self.connection.socket.send(data.encode("utf-8"))


class WebSocketIRCClient(BaseIRCClient):
    """
    IRC client that's bridged with a gevent-socketio namespace.
    """

    def __init__(self, host, port, channel, nickname, password, namespace):
        self.nicknames = {}
        self.namespace = namespace
        client_args = (host, port, channel, nickname, password)
        super(WebSocketIRCClient, self).__init__(*client_args)

    def emit_message(self, message):
        """
        Send a message to the channel. We also emit the message
        back to the sender's WebSocket.
        """
        try:
            nickname_color = self.nicknames[self.nickname]
        except KeyError:
            # Only accept messages if we've joined.
            return
        message = message[:settings.MAX_MESSAGE_LENGTH]
        # Handle IRC commands.
        if message.startswith("/"):
            self.connection.send_raw(message.lstrip("/"))
            return
        self.message_channel(message)
        self.namespace.emit("message", self.nickname, message, nickname_color)

    def emit_nicknames(self):
        """
        Send the nickname list to the Websocket. Called whenever the
        nicknames list changes.
        """
        nicknames = [{"nickname": name, "color": color(name)}
                     for name in sorted(self.nicknames.keys())]
        self.namespace.emit("nicknames", nicknames)

    def on_erroneusnickname(self, connection, event):
        """
        Invalid nickname chars/length - report back to the client.
        """
        self.namespace.emit("invalid")

    def on_namreply(self, connection, event):
        """
        Initial list of nicknames received - remove op/voice prefixes,
        and send the list to the WebSocket.
        """
        for nickname in event.arguments()[-1].split():
            nickname = nickname.lstrip("@+")
            self.nicknames[nickname] = color(nickname)
        self.emit_nicknames()

    def on_join(self, connection, event):
        """
        Someone joined the channel - send the nicknames list to the
        WebSocket.
        """
        #from time import sleep; sleep(10)  # Simulate a slow connection
        nickname = self.get_nickname(event)
        nickname_color = color(nickname)
        self.nicknames[nickname] = nickname_color
        self.namespace.emit("join")
        self.namespace.emit("message", nickname, "joins", nickname_color)
        self.emit_nicknames()

    def on_nick(self, connection, event):
        """
        Someone changed their nickname - send the nicknames list to the
        WebSocket.
        """
        old_nickname = self.get_nickname(event)
        old_color = self.nicknames.pop(old_nickname)
        new_nickname = event.target()
        message = "is now known as %s" % new_nickname
        self.namespace.emit("message", old_nickname, message, old_color)
        new_color = color(new_nickname)
        self.nicknames[new_nickname] = new_color
        self.emit_nicknames()
        if self.nickname == old_nickname:
            self.nickname = new_nickname

    def on_quit(self, connection, event):
        """
        Someone left the channel - send the nicknames list to the
        WebSocket.
        """
        nickname = self.get_nickname(event)
        nickname_color = self.nicknames[nickname]
        del self.nicknames[nickname]
        self.namespace.emit("message", nickname, "leaves", nickname_color)
        self.emit_nicknames()

    def on_pubmsg(self, connection, event):
        """
        Messages received in the channel - send them to the WebSocket.
        """
        for message in event.arguments():
            nickname = self.get_nickname(event)
            nickname_color = self.nicknames[nickname]
            self.namespace.emit("message", nickname, message, nickname_color)

########NEW FILE########
__FILENAME__ = conf

from __future__ import with_statement
import logging
from optparse import OptionParser, OptionGroup
import sys

from gnotty import __version__, __version_string__, __url__


parser = OptionParser(usage="%prog [options]", version=__version__)
options = OptionGroup(parser, "")
options.add_option("-a", "--http-host", dest="HTTP_HOST", metavar="HOST",
                  default="127.0.0.1",
                  help="HTTP host address to serve from [default: %default]")
options.add_option("-p", "--http-port", dest="HTTP_PORT", metavar="PORT",
                  default=8080, type=int,
                  help="HTTP port to serve from [default: %default]")
options.add_option("-A", "--irc-host", dest="IRC_HOST", metavar="HOST",
                  default="irc.freenode.net",
                  help="IRC host address to connect to [default: %default]")
options.add_option("-P", "--irc-port", dest="IRC_PORT", metavar="PORT",
                  default=6667, type=int,
                  help="IRC port to connect to [default: %default]")
options.add_option("-C", "--irc-channel", dest="IRC_CHANNEL",
                  metavar="CHANNEL", default="#gnotty",
                  help="IRC channel to join [default: %default]")
options.add_option("-K", "--irc-channel-key", dest="IRC_CHANNEL_KEY",
                  metavar="CHANNEL_KEY", default="",
                  help="Optional key required to access the IRC channel")
options.add_option("-c", "--bot-class", dest="BOT_CLASS",
                  metavar="DOTTED_PYTHON_PATH",
                  default="gnotty.bots.BaseBot",
                  help="Dotted Python path to the IRC client bot class to run "
                       "[default: %default]")
options.add_option("-n", "--bot-nickname", dest="BOT_NICKNAME",
                  metavar="NICKNAME", default="gnotty",
                  help="IRC nickname the bot will use [default: %default]")
options.add_option("-x", "--bot-password", dest="BOT_PASSWORD",
                  metavar="PASSWORD", default="",
                  help="Optional IRC password for the bot")
options.add_option("-L", "--login-required", dest="LOGIN_REQUIRED",
                  action="store_true", default=False,
                  help="Django login required for all URLs (Django only)")
options.add_option("-D", "--daemon", dest="DAEMON", action="store_true",
                  default=False,
                  help="run in daemon mode")
options.add_option("-k", "--kill", dest="KILL", action="store_true",
                  default=False,
                  help="Shuts down a previously started daemon")
options.add_option("-F", "--pid-file", dest="PID_FILE", metavar="FILE_PATH",
                  help="path to write PID file to when in daemon mode")
options.add_option("-l", "--log-level", dest="LOG_LEVEL", metavar="INFO|DEBUG",
                  choices=("INFO", "DEBUG"), default="INFO",
                  help="Log level to use. DEBUG will spew out all IRC data. "
                      "default: %default]")
options.add_option("-f", "--conf-file", dest="CONF_FILE", metavar="FILE_PATH",
                  help="path to a Python config file to load options from")
parser.add_option_group(options)


class Settings(dict):
    """
    Settings object, backed by either Django settings, or CLI args. The
    ``--conf-file`` CLI arg can also be used to specify the path to a
    Python module to load the settings from. Available settings and
    their defaults are defined above by the ``OptionParser`` instance
    used for parsing CLI args.
    """

    def __init__(self):
        """
        Try and initialize with Django settings.
        """
        self.option_list = parser.option_groups[0].option_list
        # Some constants about the software.
        self["GNOTTY_VERSION"] = __version__
        self["GNOTTY_VERSION_STRING"] = __version_string__
        self["GNOTTY_PROJECT_URL"] = __url__
        try:
            from django.conf import settings
            for k, v in parser.defaults.items():
                self[k] = getattr(settings, "GNOTTY_%s" % k, v)
            self.set_max_message_length()
        except ImportError:
            pass

    def set_max_message_length(self):
        extra_message_chars = "#PRIVMSG %s :\r\n" % self["IRC_CHANNEL"]
        self["MAX_MESSAGE_LENGTH"] = 512 - len(extra_message_chars)

    def __getattr__(self, k):
        return self[k]

    def parse_args(self):
        """
        Called from ``gnotty.server.run`` and parses any CLI args
        provided. Also handles loading settings from the Python
        module specified with the ``--conf-file`` arg. CLI args
        take precedence over any settings defined in the Python
        module defined by ``--conf-file``.
        """
        options, _ = parser.parse_args()
        file_settings = {}
        if options.CONF_FILE:
            execfile(options.CONF_FILE, {}, file_settings)
        for option in self.option_list:
            if option.dest:
                file_value = file_settings.get("GNOTTY_%s" % option.dest, None)
                # optparse doesn't seem to provide a way to determine if
                # an option's value was provided as a CLI arg, or if the
                # default is being used, so we manually check sys.argv,
                # since provided CLI args should take precedence over
                # any settings defined in a conf module.
                flags = option._short_opts + option._long_opts
                in_argv = set(flags) & set(sys.argv)
                options_value = getattr(options, option.dest)
                if file_value and not in_argv:
                    self[option.dest] = file_value
                elif in_argv:
                    self[option.dest] = options_value
                else:
                    self[option.dest] = self.get(option.dest, options_value)
        self.set_max_message_length()
        self["STATIC_URL"] = "/static/"
        self["LOG_LEVEL"] = getattr(logging, self["LOG_LEVEL"])


settings = Settings()

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import sys
import os

from settings import PROJECT_ROOT

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../..'))
os.chdir(PROJECT_ROOT)
sys.path.insert(0, os.path.abspath(os.path.join(PROJECT_ROOT, "..")))

if __name__ == "__main__":
    settings_module = "%s.settings" % PROJECT_ROOT.split(os.sep)[-1]
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", settings_module)
    from django.core.management import execute_from_command_line
    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = settings

import os


###################
# Django settings #
###################

PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(PROJECT_ROOT, STATIC_URL.strip('/'))
ROOT_URLCONF = '%s.urls' % PROJECT_ROOT.split(os.sep)[-1]
TEMPLATE_DIRS = (os.path.join(PROJECT_ROOT, 'templates'),)
DEBUG = True
SITE_ID = 1
SECRET_KEY = "change me"
ALLOWED_HOSTS = ["*"]

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'dev.db',
    }
}

INSTALLED_APPS = (
    'gnotty',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.admin',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'django.contrib.messages.context_processors.messages',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.static',
    'django.core.context_processors.media',
    'django.core.context_processors.request',
)

try:
    import south
except ImportError:
    pass
else:
    INSTALLED_APPS += ("south",)


###################
# Gnotty settings #
###################

GNOTTY_HTTP_PORT = 8080
GNOTTY_IRC_HOST = '127.0.0.1'
GNOTTY_IRC_PORT = 6667
GNOTTY_IRC_CHANNEL = '#gnotty'
GNOTTY_IRC_CHANNEL_KEY = None
GNOTTY_BOT_CLASS = 'gnotty.bots.BaseBot'
GNOTTY_BOT_NICKNAME = 'gnotty'
GNOTTY_BOT_PASSWORD = None
GNOTTY_LOGIN_REQUIRED = False


##################
# Local settings #
##################

try:
    from local_settings import *
except ImportError:
    pass

TEMPLATE_DEBUG = DEBUG
GNOTTY_LOG_LEVEL = 'DEBUG' if DEBUG else 'INFO'
GNOTTY_HTTP_HOST = '127.0.0.1' if DEBUG else '0.0.0.0'

########NEW FILE########
__FILENAME__ = urls

from django.conf.urls import patterns, include, url
from django.conf import settings
from django.contrib import admin
from django.shortcuts import redirect


admin.autodiscover()

urlpatterns = patterns('',
    url('^admin/', include(admin.site.urls)),
    url('^irc/', include('gnotty.urls')),
    url('^' + settings.LOGIN_URL.lstrip('/'), 'gnotty.views.login'),
    url('^' + settings.LOGOUT_URL.lstrip('/'), 'gnotty.views.logout'),
    url('^$', lambda r: redirect('gnotty_chat')),
)

########NEW FILE########
__FILENAME__ = gnottify

from gevent.monkey import patch_all
patch_all()

from logging import getLogger, StreamHandler

from django.core.management.base import BaseCommand

from gnotty.conf import settings
from gnotty.models import IRCMessage


class ModelLogger(StreamHandler):
    """
    Logging handler that saves an IRC message to the DB.
    """
    def emit(self, record):
        IRCMessage.objects.create(server=record.server,
                                  channel=record.channel,
                                  nickname=record.nickname,
                                  message=record.msg,
                                  join_or_leave=record.join_or_leave)


class Command(BaseCommand):

    option_list = BaseCommand.option_list + tuple(settings.option_list)

    def handle(self, *args, **options):
        getLogger("irc.message").addHandler(ModelLogger())
        settings.parse_args()
        from gnotty.server import serve_forever
        serve_forever(django=True)

########NEW FILE########
__FILENAME__ = gnottify_runserver

from django.core.management import call_command
from gevent import spawn

from gnotty.management.commands import gnottify


class Command(gnottify.Command):

    def handle(self, *args, **options):
        spawn(lambda: call_command("runserver", *args))
        super(Command, self).handle(*args, **options)

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'IRCMessage'
        db.create_table('gnotty_ircmessage', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('nickname', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('message', self.gf('django.db.models.fields.TextField')()),
            ('server', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('channel', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('message_time', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
        ))
        db.send_create_signal('gnotty', ['IRCMessage'])


    def backwards(self, orm):
        # Deleting model 'IRCMessage'
        db.delete_table('gnotty_ircmessage')


    models = {
        'gnotty.ircmessage': {
            'Meta': {'ordering': "('message_time',)", 'object_name': 'IRCMessage'},
            'channel': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.TextField', [], {}),
            'message_time': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'nickname': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'server': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['gnotty']
########NEW FILE########
__FILENAME__ = 0002_auto__add_field_ircmessage_join_or_leave
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'IRCMessage.join_or_leave'
        db.add_column('gnotty_ircmessage', 'join_or_leave',
                      self.gf('django.db.models.fields.BooleanField')(default=False),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'IRCMessage.join_or_leave'
        db.delete_column('gnotty_ircmessage', 'join_or_leave')


    models = {
        'gnotty.ircmessage': {
            'Meta': {'ordering': "('message_time',)", 'object_name': 'IRCMessage'},
            'channel': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'join_or_leave': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'message': ('django.db.models.fields.TextField', [], {}),
            'message_time': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'nickname': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'server': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['gnotty']
########NEW FILE########
__FILENAME__ = 0003_joins_leaves
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Remember to use orm['appname.ModelName'] rather than "from appname.models..."
        if not db.dry_run:
            orm['gnotty.IRCMessage'].objects.filter(message="joins").update(join_or_leave=True)
            orm['gnotty.IRCMessage'].objects.filter(message="leaves").update(join_or_leave=True)


    def backwards(self, orm):
        "Write your backwards methods here."

    models = {
        'gnotty.ircmessage': {
            'Meta': {'ordering': "('message_time',)", 'object_name': 'IRCMessage'},
            'channel': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'join_or_leave': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'message': ('django.db.models.fields.TextField', [], {}),
            'message_time': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'nickname': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'server': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['gnotty']
    symmetrical = True

########NEW FILE########
__FILENAME__ = models

from django.db import models
from django.utils.translation import ugettext_lazy as _

from gnotty.client import color


class IRCMessage(models.Model):
    """
    An IRC message logged by the DjangoBot from the
    ``run_gnotty`` management command.
    """

    nickname = models.CharField(_("Nickname"), max_length=100)
    message = models.TextField(_("Message"))
    server = models.CharField(_("Server"), max_length=100)
    channel = models.CharField(_("Channel"), max_length=100)
    message_time = models.DateTimeField(_("Time"), auto_now_add=True)
    join_or_leave = models.BooleanField(default=False)

    class Meta:
        verbose_name = _("Message")
        verbose_name_plural = _("Messages")
        ordering = ("message_time",)

    def __unicode__(self):
        return "[%s] %s%s %s: %s" % (self.message_time, self.server,
                                     self.channel, self.nickname,
                                     self.short_message())

    @models.permalink
    def get_absolute_url(self):
        kwargs = {
            "year": self.message_time.year,
            "month": self.message_time.month,
            "day": self.message_time.day,
        }
        return ("gnotty_day", (), kwargs)

    def short_message(self):
        return self.message[:50]
    short_message.short_description = _("Message")

    def color(self):
        return color(self.nickname)

########NEW FILE########
__FILENAME__ = server
#!/usr/bin/env python

from __future__ import with_statement
from gevent import monkey, spawn, sleep
monkey.patch_all()

from Cookie import Cookie
from cgi import FieldStorage
from logging import getLogger, StreamHandler
from mimetypes import guess_type
import os
import sys
from tempfile import gettempdir
from traceback import format_exc

from daemon import daemonize
from socketio import socketio_manage
from socketio.server import SocketIOServer
from socketio.namespace import BaseNamespace

from gnotty.client import WebSocketIRCClient
from gnotty.conf import settings


HTTP_STATUS_TEXT = {
    200: "OK",
    301: "MOVED PERMANENTLY",
    401: "UNAUTHORIZED",
    404: "NOT FOUND",
    500: "INTERNAL SERVER ERROR",
}


class IRCNamespace(BaseNamespace):
    """
    gevent-socketio namespace that's bridged with an IRC client.
    """

    def on_start(self, host, port, channel, nickname, password):
        """
        A WebSocket session has started - create a greenlet to host
        the IRC client, and start it.
        """
        self.client = WebSocketIRCClient(host, port, channel, nickname,
                                         password, self)
        self.spawn(self.client.start)

    def on_message(self, message):
        """
        Message received from a WebSocket - send it to the IRC channel.
        """
        if hasattr(self, "client"):
            self.client.emit_message(message)

    def disconnect(self, *args, **kwargs):
        """
        WebSocket was disconnected - leave the IRC channel.
        """
        quit_message = "%s %s" % (settings.GNOTTY_VERSION_STRING,
                                  settings.GNOTTY_PROJECT_URL)
        self.client.connection.quit(quit_message)
        super(IRCNamespace, self).disconnect(*args, **kwargs)


class IRCApplication(object):

    def __init__(self, django=False):
        """
        Loads and starts the IRC bot for the entire application.
        """
        self.django = django
        self.bot = None
        if settings.BOT_CLASS:
            module_name, class_name = settings.BOT_CLASS.rsplit(".", 1)
            __import__(module_name)
            bot_class = getattr(sys.modules[module_name], class_name)
            self.bot = bot_class(settings.IRC_HOST, settings.IRC_PORT,
                                 settings.IRC_CHANNEL, settings.BOT_NICKNAME,
                                 settings.BOT_PASSWORD)
            spawn(self.bot.start)
            spawn(self.bot_watcher)
        self.logger = getLogger("irc.webhooks")
        self.logger.setLevel(settings.LOG_LEVEL)
        self.logger.addHandler(StreamHandler())

    def bot_watcher(self):
        """
        Thread (greenlet) that will try and reconnect the bot if
        it's not connected.
        """
        default_interval = 5
        interval = default_interval
        while True:
            if not self.bot.connection.connected:
                if self.bot.reconnect():
                    interval = default_interval
                else:
                    interval *= 2
            sleep(interval)

    def respond_webhook(self, environ):
        """
        Passes the request onto a bot with a webhook if the webhook
        path is requested.
        """
        request = FieldStorage(fp=environ["wsgi.input"], environ=environ)
        url = environ["PATH_INFO"]
        params = dict([(k, request[k].value) for k in request])
        try:
            if self.bot is None:
                raise NotImplementedError
            response = self.bot.handle_webhook_event(environ, url, params)
        except NotImplementedError:
            return 404
        except:
            self.logger.debug(format_exc())
            return 500
        return response or 200

    def respond_static(self, environ):
        """
        Serves a static file when Django isn't being used.
        """
        path = os.path.normpath(environ["PATH_INFO"])
        if path == "/":
            content = self.index()
            content_type = "text/html"
        else:
            path = os.path.join(os.path.dirname(__file__), path.lstrip("/"))
            try:
                with open(path, "r") as f:
                    content = f.read()
            except IOError:
                return 404
            content_type = guess_type(path)[0]
        return (200, [("Content-Type", content_type)], content)

    def index(self):
        """
        Loads the chat interface template when Django isn't being
        used, manually dealing with the Django template bits.
        """
        root_dir = os.path.dirname(__file__)
        template_dir = os.path.join(root_dir, "templates", "gnotty")
        with open(os.path.join(template_dir, "base.html"), "r") as f:
            base = f.read()
        with open(os.path.join(template_dir, "chat.html"), "r") as f:
            base = base.replace("{% block content %}", f.read())
        replace = {
            "{% block content %}": "",
            "{% block extrahead %}": "",
            "{% endblock %}": "",
            "{% load gnotty_tags %}": "",
            "{% extends \"gnotty/base.html\" %}": "",
            "{% url gnotty_chat %}": "/",
            "{% gnotty_nav %}": "",
            "{% templatetag openvariable %}": "{{",
            "{% templatetag closevariable %}": "}}",
        }
        for k, v in replace.items():
            base = base.replace(k, v)
        for k, v in settings.items():
            base = base.replace("{{ %s }}" % k, unicode(v or ""))
        return base

    def respond_django(self, environ):
        """
        Tries to redirect to a Django app if someone accesses an
        invalid URL when Django is being used.
        """
        environ["port"] = ""
        if environ["SERVER_NAME"] in ("127.0.0.1", "localhost"):
            environ["port"] = ":8000"
        location = ("%(wsgi.url_scheme)s://" +
            "%(SERVER_NAME)s%(port)s%(PATH_INFO)s") % environ
        return (301, [("Location", location)], None)

    def respond_unauthorized(self, environ):
        """
        Just return unauthorized HTTP status if the
        ``unauthorized`` method returns ``True`` inside
        ``__call__``.
        """
        return 401

    def authorized(self, environ):
        """
        If we're running Django and ``GNOTTY_LOGIN_REQUIRED`` is set
        to ``True``, pull the session cookie from the environment and
        validate that the user is authenticated.
        """
        if self.django and settings.LOGIN_REQUIRED:
            try:
                from django.conf import settings as django_settings
                from django.contrib.auth import SESSION_KEY
                from django.contrib.auth.models import User
                from django.contrib.sessions.models import Session
                from django.core.exceptions import ObjectDoesNotExist
                cookie = Cookie(environ["HTTP_COOKIE"])
                cookie_name = django_settings.SESSION_COOKIE_NAME
                session_key = cookie[cookie_name].value
                session = Session.objects.get(session_key=session_key)
                user_id = session.get_decoded().get(SESSION_KEY)
                user = User.objects.get(id=user_id)
            except (ImportError, KeyError, ObjectDoesNotExist):
                return False
        return True

    def __call__(self, environ, start_response):
        """
        WSGI application handler.
        """
        authorized = self.authorized(environ)
        path = environ["PATH_INFO"]
        if path.startswith("/socket.io/") and authorized:
            socketio_manage(environ, {"": IRCNamespace})
            return
        if not authorized:
            dispatch = self.respond_unauthorized
        elif path.startswith("/webhook/"):
            dispatch = self.respond_webhook
        elif self.django:
            dispatch = self.respond_django
        else:
            dispatch = self.respond_static
        response = dispatch(environ)
        if isinstance(response, int):
            response = (response, [], None)
        elif isinstance(response, basestring):
            response = (200, [], response)
        status, headers, content = response
        status_text = HTTP_STATUS_TEXT.get(status, "")
        headers.append(("Server", settings.GNOTTY_VERSION_STRING))
        start_response("%s %s" % (status, status_text), headers)
        if content is None:
            if status == 200:
                content = ""
            else:
                content = "<h1>%s</h1>" % status_text.title()
        return [content]


def serve_forever(django=False):
    """
    Starts the gevent-socketio server.
    """
    logger = getLogger("irc.dispatch")
    logger.setLevel(settings.LOG_LEVEL)
    logger.addHandler(StreamHandler())
    app = IRCApplication(django)
    server = SocketIOServer((settings.HTTP_HOST, settings.HTTP_PORT), app)
    print "%s [Bot: %s] listening on %s:%s" % (
        settings.GNOTTY_VERSION_STRING,
        app.bot.__class__.__name__,
        settings.HTTP_HOST,
        settings.HTTP_PORT,
    )
    server.serve_forever()


def kill(pid_file):
    """
    Attempts to shut down a previously started daemon.
    """
    try:
        with open(pid_file) as f:
            os.kill(int(f.read()), 9)
        os.remove(pid_file)
    except (IOError, OSError):
        return False
    return True


def run():
    """
    CLI entry point. Parses args and starts the gevent-socketio server.
    """
    settings.parse_args()
    pid_name = "gnotty-%s-%s.pid" % (settings.HTTP_HOST, settings.HTTP_PORT)
    pid_file = settings.PID_FILE or os.path.join(gettempdir(), pid_name)
    if settings.KILL:
        if kill(pid_file):
            print "Daemon killed"
        else:
            print "Could not kill any daemons"
        return
    elif kill(pid_file):
        print "Running daemon killed"
    if settings.DAEMON:
        daemonize(pid_file)
    serve_forever()


if __name__ == "__main__":
    run()

########NEW FILE########
__FILENAME__ = gnotty_tags

from django import template
from django.conf import settings as django_settings
from django.db.models import Min, Max

from gnotty.models import IRCMessage
from gnotty.conf import settings


register = template.Library()


@register.inclusion_tag("gnotty/includes/nav.html", takes_context=True)
def gnotty_nav(context):
    min_max = IRCMessage.objects.aggregate(Min("message_time"),
                                           Max("message_time"))
    if min_max.values()[0]:
        years = range(min_max["message_time__max"].year,
                      min_max["message_time__min"].year - 1, -1)
    else:
        years = []
    context["IRC_CHANNEL"] = settings.IRC_CHANNEL
    context["years"] = years
    context["LOGOUT_URL"] = django_settings.LOGOUT_URL
    return context

########NEW FILE########
__FILENAME__ = urls

from django.conf.urls import patterns, url


archive_pattern = "^archive/"
year_pattern    = archive_pattern + "(?P<year>\d{4})/"
month_pattern   = year_pattern    + "(?P<month>\d{1,2})/"
day_pattern     = month_pattern   + "(?P<day>\d{1,2})/"

urlpatterns = patterns("gnotty.views",
    url("^$", "chat", name="gnotty_chat"),
    url(archive_pattern + "$", "messages", name="gnotty_search"),
    url(year_pattern    + "$", "calendar", name="gnotty_year"),
    url(month_pattern   + "$", "calendar", name="gnotty_month"),
    url(day_pattern     + "$", "messages", name="gnotty_day"),
)

########NEW FILE########
__FILENAME__ = views

from calendar import Calendar, SUNDAY
from datetime import datetime, date, timedelta

from django.contrib import auth
from django.contrib.auth.decorators import login_required
from django.contrib.messages import info, error
from django.core.urlresolvers import reverse
from django.db.models import Q
from django.shortcuts import render, redirect

from gnotty.models import IRCMessage
from gnotty.conf import settings


def hide_joins_and_leaves(request):
    return request.COOKIES.get("gnotty-hide-joins-leaves", "") == "1"


def chat(request, template="gnotty/chat.html"):
    context = dict(settings)
    return render(request, template, context)


def messages(request, year=None, month=None, day=None,
             template="gnotty/messages.html"):
    """
    Show messages for the given query or day.
    """

    query = request.REQUEST.get("q")
    prev_url, next_url = None, None
    messages = IRCMessage.objects.all()
    if hide_joins_and_leaves(request):
        messages = messages.filter(join_or_leave=False)
    if query:
        search = Q(message__icontains=query) | Q(nickname__icontains=query)
        messages = messages.filter(search).order_by("-message_time")
    elif year and month and day:
        messages = messages.filter(message_time__year=year,
                                   message_time__month=month,
                                   message_time__day=day)
        day_delta = timedelta(days=1)
        this_date = date(int(year), int(month), int(day))
        prev_date = this_date - day_delta
        next_date = this_date + day_delta
        prev_url = reverse("gnotty_day", args=prev_date.timetuple()[:3])
        next_url = reverse("gnotty_day", args=next_date.timetuple()[:3])
    else:
        return redirect("gnotty_year", year=datetime.now().year)

    context = dict(settings)
    context["messages"] = messages
    context["prev_url"] = prev_url
    context["next_url"] = next_url
    return render(request, template, context)


def calendar(request, year=None, month=None, template="gnotty/calendar.html"):
    """
    Show calendar months for the given year/month.
    """

    try:
        year = int(year)
    except TypeError:
        year = datetime.now().year
    lookup = {"message_time__year": year}
    if month:
        lookup["message_time__month"] = month
    if hide_joins_and_leaves(request):
        lookup["join_or_leave"] = False

    messages = IRCMessage.objects.filter(**lookup)
    try:
        dates = messages.datetimes("message_time", "day")
    except AttributeError:
        dates = messages.dates("message_time", "day")
    days = [d.date() for d in dates]
    months = []

    if days:
        min_date, max_date = days[0], days[-1]
        days = set(days)
        calendar = Calendar(SUNDAY)
        for m in range(1, 13) if not month else [int(month)]:
            lt_max = m <= max_date.month or year < max_date.year
            gt_min = m >= min_date.month or year > min_date.year
            if lt_max and gt_min:
                weeks = calendar.monthdatescalendar(year, m)
                for w, week in enumerate(weeks):
                    for d, day in enumerate(week):
                        weeks[w][d] = {
                            "date": day,
                            "in_month": day.month == m,
                            "has_messages": day in days,
                        }
                months.append({"month": date(year, m, 1), "weeks": weeks})

    context = dict(settings)
    context["months"] = months
    return render(request, template, context)


if settings.LOGIN_REQUIRED:
    chat     = login_required(chat)
    messages = login_required(messages)
    calendar = login_required(calendar)


def login(request):
    if request.method == "POST":
        user = auth.authenticate(username=request.POST["username"],
                                 password=request.POST["password"])
        if user:
            auth.login(request, user)
            return redirect(request.GET.get("next", "/"))
        error(request, "Invalid username/password")
    return render(request, "gnotty/login.html", {"request": request})


def logout(request):
    auth.logout(request)
    info(request, "You have successfully logged out")
    return redirect("/")

########NEW FILE########
