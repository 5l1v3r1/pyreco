# Level 0

We'll start you out with Level 0, the Secret Safe. The Secret Safe is
designed as a secure place to store all of your secrets. It turns out that
the password to access Level 1 is stored within the Secret Safe. If only you
knew how to [crack safes](http://en.wikipedia.org/wiki/Safe-cracking)...

# Running

- Install node and npm (see http://nodejs.org/)
- Run `npm install` from this directory to install dependencies
- Run `node level00.js` to start the server on port 3000
- Go to [http://localhost:3000](http://localhost:3000) in your browser

# Level 1

Excellent, you are now on Level 1, the Guessing Game. All you
have to do is guess the combination correctly, and you'll be given
the password to access Level 2! We've been assured that this level
has no security vulnerabilities in it (and the machine running the
Guessing Game has no outbound network connectivity, meaning you
wouldn't be able to extract the password anyway), so you'll probably
just have to try all the possible combinations. Or will you...?

# To run

- Put index.php on a server somewhere with the two .txt files in the
  same directory.

# Level 2

You are now on Level 2, the Social Network. Excellent work so far!
Social Networks are all the rage these days, so we decided to build
one for CTF. Please fill out your profile at on the level 2 server.
You may even be able to find the password for Level 3 by doing so.

# To run

- Put index.php on a server somewhere with password.txt file in the
  same directory, chmodded unreadable.

# Level 3

After the fiasco back in Level 0, management has decided to fortify the Secret
Safe into an unbreakable solution (kind of like
[Unbreakable Linux](http://www.oracle.com/us/technologies/linux/ubreakable-enterprise-kernel-linux-173350.html))
The resulting product is Secret Vault, which is so secure that it requires
human intervention to add new secrets.

A beta version has launched with some interesting secrets
(including the password to access Level 4).

# Run

- Run `pip install flask flup`
- Run `python secretvault.py`. This will automatically generate test data for you.
- Visit [http://localhost:5000 ](http://localhost:5000 in your web browser)

# Level 4

The Karma Trader is the world's best way to reward people for good deeds. You
can sign up for an account, and start transferring karma to people who you
think are doing good in the world. In order to ensure you're transferring karma
only to good people, transferring karma to a user will also reveal your
password to him or her.

The very active user **karma_fountain** has infinite karma, making it a ripe
account to obtain (no one will notice a few extra karma trades here and there).
The password for **karma_fountain**'s account will give you access to Level 5.

# To run

- Install bundler: `gem install bundler`
- Run srv.rb: `./srv.rb`
- Point your browser to [http://localhost:4567](http://localhost:4567)

## Karma Fountain

We used [CapserJS](http://casperjs.org/) on top of
[PhantomJS](http://phantomjs.org/) to power the **karma_fountain** user. Run
`capserjs browser.coffee http://localhost:4567` to start it up. It expects to
find the password from the filesystem `public_html/password.txt`.

# Level 5

Many attempts have been made at creating a federated identity system for the
web (see [OpenID](http://openid.net/), for example). However, none of them have
been successful. Until today.

The DomainAuthenticator is based off a novel protocol for establishing
identities. To authenticate to a site, you simply provide it username,
password, and pingback URL. The site posts your credentials to the pingback
URL, which returns either "AUTHENTICATED" or "DENIED". If "AUTHENTICATED", the
site considers you signed in as a user for the pingback domain.

We've been using the Stripe CTF DomainAuthenticator instance it to distribute
the password to access Level 6. If you could only somehow authenticate as a
user of a level05 machine...

To avoid nefarious exploits, the machine hosting the DomainAuthenticator has
very locked down network access. It can only make outbound requests to other
`stripe-ctf.com` servers. Though, you've heard that someone forgot to
internally firewall off the high ports from the Level 2 server.

*NB: During the actual Stripe CTF, we allowed full network access from the
Level 5 server to the Level 2 server.*

# To run

- Install bundler: `gem install bundler`
- Run srv.rb: `./srv.rb`
- Point your browser to [http://localhost:4567](http://localhost:4567)

# Level 6

After Karma Trader from Level 4 was hit with massive karma inflation
(purportedly due to someone flooding the market with massive quantities of
karma), the site had to close its doors. All hope was not lost, however, since
the technology was acquired by a real up-and-comer, Streamer. Streamer is the
self-proclaimed most steamlined way of sharing updates with your friends.

The Streamer engineers, realizing that security holes had led to the demise of
Karma Trader, have greatly beefed up the security of their application. Which
is really too bad, because you've learned that the holder of the password to
access Level 7, **level07-password-holder**, is the first Streamer user.

In addition, **level07-password-holder** is taking a lot of precautions: his or
her computer has no network access besides the Streamer server itself, and his
or her password is a complicated mess, including quotes and apostrophes and the
like.

Fortunately for you, the Streamer engineers have decided to open-source their
application so that other people can run their own Streamer instances.

# To run

- Install bundler: `gem install bundler`
- Run srv.rb: `./srv.rb`
- Point your browser to [http://localhost:4567](http://localhost:4567)

## level07-password-holder

We used [CapserJS](http://casperjs.org/) on top of
[PhantomJS](http://phantomjs.org/) to power the **level07-password-holder**
user. Run `capserjs browser.coffee http://localhost:4567` to start it up. It
expects to find the password from the filesystem `public_html/password.txt`.

# WaffleCopter

WaffleCopter is a new service delivering locally-sourced organic waffles hot
off of vintage waffle irons straight to your location using quad-rotor
GPS-enabled helicopters. The service is modeled after
[TacoCopter](http://tacocopter.com), an innovative and highly successful early
contender in the airborne food delivery industry. WaffleCopter is currently
being tested in private beta in select locations.

Your goal is to order one of the decadent Li√®ge waffles, offered only to the
first premium subscribers of the service.

## The API

The WaffleCopter API is quite simple. All users have a secret API token that is
used to sign POST requests to /v1/orders. Parameters such as the waffle product
code and target GPS coordinates are encoded as if for a query string and placed
in the request body.

## The Code

You can use `client.py` to talk to the API, specifying an appropriate API
endpoint, user id, and secret key. The app itself is `wafflecopter.py`, which
will use a SQLite database created by `initialize_db.py`. To edit flask
settings, just create a `local_settings.py` file. The page templates can be
found under `templates/`.

The provided API client requires the `requests` module, which can be installed
from pip with `pip install requests`. The server requires modules `flask` and
`bcrypt`, which can be installed from pip with `pip install flask py-bcrypt`.

# Level 8

Welcome to the final level, Level 8.

HINT 1: No, really, we're not looking for a timing attack.

HINT 2: Running the server locally is probably a good place to start. Anything
interesting in the output?

Because password theft has become such a rampant problem, a
security firm has decided to create PasswordDB, a new and secure way
of storing and validating passwords. You've recently learned that the
Flag itself is protected in a PasswordDB instance.

PasswordDB exposes a simple JSON API. You just `POST` a payload of the form
`{"password": "password-to-check", "webhooks": ["mysite.com:3000", ...]}` to
PasswordDB, which will respond with a `{"success": true}"` or
`{"success": false}"` to you and your specified webhook endpoints.

(For example, try running `curl <%= url %> -d '{"password": "password-to-check", "webhooks": []}'`.)

In PasswordDB, the password is never stored in a single location or process,
making it the bane of attackers' respective existences. Instead, the password
is "chunked" across multiple processes, called "chunk servers". These may live
on the same machine as the HTTP-accepting "primary server", or for added
security may live on a different machine. PasswordDB comes with built-in
security features such as timing attack prevention and protection against using
unequitable amounts of CPU time (relative to other PasswordDB instances on the
same machine).

As a secure cherry on top, the machine hosting the primary server has very
locked down network access. It can only make outbound requests to other
`stripe-ctf.com` servers. As you learned in Level 5, someone forgot to
internally firewall off the high ports from the Level 2 server. (It's almost
like someone on the inside is helping you &mdash; there's an
[sshd](http://linux.about.com/od/commands/l/blcmdl8_sshd.htm) running on the
Level 2 server as well.)

*NB: During the actual Stripe CTF, the Level 8 server could access all high TCP
ports on the Level 2 server, and the Level 2 server was running an SSHD.*

To maximize adoption, usability is also a goal of PasswordDB. Hence a launcher
script, `password_db_launcher`, has been created for the express purpose of
securing the Flag. It validates that your password looks like a valid Flag and
automatically spins up 4 chunk servers and a primary server.

# Run

- Run `password_db_launcher`. For example:

    ./password_db_launcher 123456789012 127.0.0.1:3000

  will start a PasswordDB instance running on 127.0.0.1:3000 and with
  the Flag set to 123456789012.

- Make sure you're using Twisted 11.1.0

- Connect using curl:

    curl 127.0.0.1:3000 -d '{"password": 123456789012, "webhooks": []}'

# Stripe Capture the Flag: Web Edition

![STRIPE CTF 2.0](https://stripe.com/img/blog/posts/ctf-20/ctf20.png)

This repository contains the source code to the levels from the Stripe CTF 2.0,
which ran from August 22-29, 2012.

https://stripe.com/blog/capture-the-flag-20

https://stripe.com/blog/capturetheflag

