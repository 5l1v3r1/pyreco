__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# picrawler documentation build configuration file, created by
# sphinx-quickstart on Mon Sep 30 21:15:12 2013.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os
import re

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'picrawler'
copyright = u'2013, Studio Ousia'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.

release = re.search("version='([^']+)'",
    open(os.path.join(os.path.dirname(__file__), os.pardir,
         'setup.py')).read().strip()
).group(1)

# The short X.Y version.
version = '.'.join(release.split('.')[:2])

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'picrawlerdoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'picrawler.tex', u'picrawler Documentation',
   u'Ikuya Yamada', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'picrawler', u'picrawler Documentation',
     [u'Ikuya Yamada'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'picrawler', u'picrawler Documentation',
   u'Ikuya Yamada', 'picrawler', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = picloud_connection
# -*- coding: utf-8 -*-

import cloud
import collections
import datetime

from request import Request

REQUEST_QUEUE_PREFIX = 'picrawler_request_'
RESULT_QUEUE_PREFIX = 'picrawler_result_'


class InvalidRequest(Exception):
    pass


class PiCloudConnection(object):
    """Class that represents a connection to PiCloud.

    Usage:

        >>> from picrawler import PiCloudConnection
        >>> with PiCloudConnection() as conn:
        ...     response = conn.send(['http://www.wikipedia.org'])
        ...     print 'status code:', response[0].status_code
        ...     print 'content:', response[0].content[:15]
        status code: 200
        content: <!DOCTYPE html>

    :param int max_parallel_jobs: (optional) The number of parallel jobs to run.
    :param str core_type: (optional) PiCloud core type.
    """

    def __init__(self, max_parallel_jobs=10, core_type='s1'):
        self._max_parallel_jobs = max_parallel_jobs
        self._core_type = core_type

        self._connected = False

    def __enter__(self):
        if not self._connected:
            self.connect()

        return self

    def __exit__(self, type, value, traceback):
        self.close()

    @property
    def is_connected(self):
        return self._connected

    @property
    def request_queue(self):
        return self._request_queue

    @property
    def result_queue(self):
        return self._result_queue

    def connect(self):
        """Establishes a connection to PiCloud."""

        self._initialize_queues()

        self._connected = True

    def close(self):
        """Closes the connection."""

        assert self._connected, 'The connection to PiCloud has not been established.'

        self._destroy_queues()
        cloud.close()

        self._connected = False

    def send(self, req):
        """Sends the requests to PiCloud.

        :param req: Requests to be sended to PiCloud. Must be one of the following:

            * A string that contains a URL
            * A list or a tuple or an iteratable that consists of URL strings
            * A :class:`Request <picrawler.request.Request>` instance
            * An list or a tuple or an iteratable that consists of :class:`Request <picrawler.request.Request>` instance

        :return: List of :class:`BaseResponse <picrawler.response.BaseResponse>` instances.
        """

        assert self._connected, 'The connection to PiCloud has not been established.'

        # covert req into a list of Request instances
        if isinstance(req, basestring):
            requests = [Request(req)]

        elif isinstance(req, Request):
            requests = [req]

        elif isinstance(req, collections.Iterable):
            requests = []
            for request in req:
                if isinstance(request, Request):
                    requests.append(request)
                elif isinstance(request, basestring):
                    requests.append(Request(request))
                else:
                    raise InvalidRequest('Invalid request item')

        else:
            raise InvalidRequest('req must be either an instance of the '
                                 'Request class or an iteratable of Request instances')

        # send requests to the PiCloud queue
        self._request_queue.push(requests)

        responses = self._loop()
        req_resp_map = {}
        for resp in responses:
            req_resp_map[resp.request.id] = resp

        return [req_resp_map.get(r.id) for r in requests]

    def _initialize_queues(self):

        queue_id = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        self._request_queue = cloud.queue.get(REQUEST_QUEUE_PREFIX + queue_id)
        self._result_queue = cloud.queue.get(RESULT_QUEUE_PREFIX + queue_id)

        # attach the request handler to the queue
        self._request_queue.attach(lambda req: req(),
                                   output_queues=[self._result_queue],
                                   max_parallel_jobs=self._max_parallel_jobs,
                                   _type=self._core_type)

    def _destroy_queues(self):

        self._request_queue.delete()
        self._result_queue.delete()

        self._request_queue = None
        self._result_queue = None

    def _loop(self):
        gathered_responses = []

        c = 0
        while True:
            # get the results
            responses = self._result_queue.pop(timeout=0)

            if responses:
                for response in responses:
                    response.run_callback()

                gathered_responses += responses

            # break the loop if completed
            if c % 3 == 0 and self._requests_completed():
                break

            c += 1

        return gathered_responses

    def _requests_completed(self):
        request_queue_info = self._request_queue.info()

        if (request_queue_info['count'] == 0 and
            request_queue_info['processing_jobs'] == 0 and
            request_queue_info['queued_jobs'] == 0):

            # exit the loop if the result queue is empty
            if self._result_queue.count() == 0:
                return True

        return False

########NEW FILE########
__FILENAME__ = request
# -*- coding: utf-8 -*-

import uuid
import requests

from response import Response, ErrorResponse

_success_callbacks = {}
_error_callbacks = {}

SUPPORTED_HTTP_METHODS = frozenset(['get', 'post', 'put', 'delete', 'head', 'options'])


class InvalidHTTPMethod(Exception):
    pass


class InvalidResponse(Exception):
    pass


class Request(object):
    """Class that represents a request to PiCloud.

    :param str url: A URL to be fetched.
    :param str method: Target HTTP method.
        ("GET" or "POST" or "PUT" or "DELETE" or "HEAD" or "OPTIONS")
    :param dict headers: (optional) HTTP headers to send.
    :param dict args: (optional) Additional arguments, that are directly passed
        to `requests <http://docs.python-requests.org>`_. Any arguments that
        supported in `requests <http://docs.python-requests.org>`_ are supported.
    :param function success_callback: (optional) A function called if the
        request is successfully completed.
        A :class:`Response <picrawler.response.Response>` instance is passed as
        the first argument.
    :param function error_callback: (optional) A function called if the request
        is failed. An :class:`ErrorResponse <picrawler.response.ErrorResponse>`
        instance is passed as the first argument.
    """

    def __init__(self, url, method='get', headers={}, args={},
                 success_callback=None, error_callback=None):
        global _success_callbacks, _error_callbacks

        self._id = uuid.uuid1().hex
        self._url = url
        self._method = method.lower()
        self._headers = headers
        self._args = args
        self._success_callback_id = None
        self._error_callback_id = None

        if not self._method in SUPPORTED_HTTP_METHODS:
            raise InvalidHTTPMethod('Unsupported HTTP method')

        # NOTE: because the callback function cannot be pickled,
        # it must be saved locally
        if success_callback:
            self._success_callback_id = uuid.uuid1().hex
            _success_callbacks[self._success_callback_id] = success_callback

        if error_callback:
            self._error_callback_id = uuid.uuid1().hex
            _error_callbacks[self._error_callback_id] = error_callback

    @property
    def id(self):
        return self._id

    @property
    def url(self):
        return self._url

    @property
    def method(self):
        return self._method

    @property
    def headers(self):
        return self._headers

    @property
    def args(self):
        return self._args

    @property
    def success_callback(self):
        global _success_callbacks

        if self._success_callback_id:
            return _success_callbacks.get(self._success_callback_id)
        else:
            return None

    @property
    def error_callback(self):
        global _error_callbacks

        if self._error_callback_id:
            return _error_callbacks.get(self._error_callback_id)
        else:
            return None

    def run_callback(self, response):
        global _success_callbacks, _error_callbacks

        if isinstance(response, Response):
            if self._success_callback_id:
                _success_callbacks[self._success_callback_id](response)
        elif isinstance(response, ErrorResponse):
            if self._error_callback_id:
                _error_callbacks[self._error_callback_id](response)
        else:
            raise InvalidResponse('Invalid response')

    def __call__(self):
        method_func = getattr(requests, self._method)

        try:
            ret = method_func(self._url, headers=self._headers, **self._args)
        except Exception, e:
            return ErrorResponse(self, e)

        return Response(self, ret.status_code, ret.content, ret.headers)

########NEW FILE########
__FILENAME__ = response
# -*- coding: utf-8 -*-

import cPickle as pickle
import zlib


class BaseResponse(object):
    def __init__(self, request):
        self._request = request

    @property
    def request(self):
        return self._request

    def run_callback(self):
        self._request.run_callback(self)

    # override __getstate__ and __setstate__ to reduce the size of a pickled
    # instance by compressing instance attributes using zlib
    def __getstate__(self):
        pickled_dict = pickle.dumps(self.__dict__, protocol=2)
        return zlib.compress(pickled_dict, 9)

    def __setstate__(self, state):
        pickled_dict = zlib.decompress(state)
        self.__dict__ = pickle.loads(pickled_dict)


class Response(BaseResponse):
    """Class that represents a response from PiCloud."""

    def __init__(self, request, status_code, content, headers):
        super(Response, self).__init__(request)

        self._status_code = status_code
        self._headers = headers
        self._content = content

    @property
    def status_code(self):
        """HTTP status code.

        :type: int
        """
        return self._status_code

    @property
    def content(self):
        """HTTP content.

        :type: str
        """
        return self._content

    @property
    def headers(self):
        """HTTP headers.

        :type: dict
        """
        return self._headers


class ErrorResponse(BaseResponse):
    """Class that represents a runtime error occurred on running the job."""

    def __init__(self, request, exception):
        super(ErrorResponse, self).__init__(request)

        self._exception = exception

    @property
    def exception(self):
        """Exception raised in the runtime.

        :type: :class:`Exception`
        """
        return self._exception

########NEW FILE########
__FILENAME__ = rt_cores
# -*- coding: utf-8 -*-

import cloud


class RTCoreRequest(object):
    """A wrapper class that requests real-time cores to PiCloud.

    Usage:
        >>> from picrawler.rt_cores import RTCoreRequest
        >>> with RTCoreRequest(core_type='s1', num_cores=10):
        ...     pass

    :param str core_type: The PiCloud core type.
    :param int num_cores: The number of cores.
    :param int max_duration: (optional) The lifetime of the request, in hours.
    """

    def __init__(self, core_type, num_cores, max_duration=None):
        self._core_type = core_type
        self._num_cores = num_cores
        self._max_duration = max_duration

    def __enter__(self):
        self._request_id = self.request()

        return self

    def __exit__(self, type, value, traceback):
        self.release(self._request_id)

    def request(self):
        """Requests PiCloud's realtime cores.

        :return: Request ID
        """

        req = cloud.realtime.request(self._core_type, self._num_cores,
                                     self._max_duration)
        req_id = req['request_id']

        return req_id

    def release(self, req_id):
        """Releases PiCloud's realtime cores.

        :param int req_id: The request ID.
        """

        cloud.realtime.release(req_id)

########NEW FILE########
__FILENAME__ = test_picloud_connection
# -*- coding: utf-8 -*-

from nose.tools import *
from mock import Mock, patch

from picrawler.picloud_connection import PiCloudConnection
from picrawler import picloud_connection
from picrawler import request


class TestPiCloudConnection(object):
    @patch('picrawler.picloud_connection.cloud')
    def test_context_manager(self, mock_cloud):
        conn = PiCloudConnection()
        with conn:
            ok_(conn.is_connected)

        ok_(not conn.is_connected)

    @patch('picrawler.picloud_connection.cloud')
    def test_connect(self, mock_cloud):
        conn = PiCloudConnection()
        conn.connect()
        ok_(conn.is_connected)
        conn.close()

    @patch('picrawler.picloud_connection.cloud')
    def test_connect_initialize_queues(self, mock_cloud):
        conn = PiCloudConnection(max_parallel_jobs=100, core_type='c1')
        conn.connect()

        eq_(2, mock_cloud.queue.get.call_count)
        call_args = mock_cloud.queue.get.call_args_list

        request_queue_args = call_args[0][0]
        ok_(request_queue_args[0].startswith(picloud_connection.REQUEST_QUEUE_PREFIX))

        result_queue_args = call_args[1][0]
        ok_(result_queue_args[0].startswith(picloud_connection.RESULT_QUEUE_PREFIX))

        eq_(1, conn.request_queue.attach.call_count)
        (args, kwargs) = conn.request_queue.attach.call_args

        eq_([conn.result_queue], kwargs['output_queues'])
        eq_(100, kwargs['max_parallel_jobs'])
        eq_('c1', kwargs['_type'])

    @patch('picrawler.picloud_connection.cloud')
    def test_close(self, mock_cloud):
        conn = PiCloudConnection()
        conn.connect()

        conn.close()

        mock_cloud.close.assert_called_once_with()
        ok_(not conn.is_connected)

    @patch('picrawler.picloud_connection.cloud')
    def test_close_destroy_queues(self, mock_cloud):
        conn = PiCloudConnection()
        conn.connect()

        request_queue = conn.request_queue
        result_queue = conn.result_queue

        conn.close()

        request_queue.delete.assert_called_with()
        eq_(None, conn.request_queue)
        result_queue.delete.assert_called_with()
        eq_(None, conn.result_queue)

    @patch('picrawler.picloud_connection.cloud')
    def test_send(self, mock_cloud):
        conn = PiCloudConnection()
        conn.connect()

        requests = [request.Request('http://dummy') for n in range(3)]
        results = [Mock() for n in range(3)]
        results[0].request.id = requests[1].id
        results[1].request.id = requests[2].id
        results[2].request.id = requests[0].id

        conn._loop = Mock()
        conn._loop.return_value = results

        ret = conn.send(requests)

        conn._request_queue.push.assert_called_once_with(requests)
        conn._loop.assert_called_once_with()
        # results should be sorted in the order of requests
        eq_([results[2], results[0], results[1]], ret)


    @patch('picrawler.picloud_connection.cloud')
    @raises(picloud_connection.InvalidRequest)
    def test_send_with_none(self, mock_cloud):
        conn = PiCloudConnection()
        conn.connect()

        conn.send(None)

    @patch('picrawler.picloud_connection.cloud')
    @raises(picloud_connection.InvalidRequest)
    def test_send_with_invalid_list(self, mock_cloud):
        conn = PiCloudConnection()
        conn.connect()
        req = request.Request('http://dummy')

        conn.send([req, None])

    @patch('picrawler.picloud_connection.cloud')
    def test_loop(self, mock_cloud):
        conn = PiCloudConnection()
        conn.connect()

        mock_request_completed = Mock()
        mock_request_completed.side_effect = [False, True]
        conn._requests_completed = mock_request_completed

        mock_result_queue = Mock()
        result1 = Mock()
        result2 = Mock()
        mock_result_queue.pop.side_effect = [[result1], [result2]] + [None] * 2
        conn._result_queue = mock_result_queue

        ret = conn._loop()

        eq_([result1, result2], ret)
        result1.run_callback.assert_called_once_with()
        result2.run_callback.assert_called_once_with()

    @patch('picrawler.picloud_connection.cloud')
    def test_requests_completed(self, mock_cloud):
        conn = PiCloudConnection()
        conn.connect()

        mock_request_queue = Mock()
        conn._request_queue = mock_request_queue

        mock_result_queue = Mock()
        conn._result_queue = mock_result_queue

        def set_queue_info(request_count=0,
                           request_processing_jobs=0,
                           request_queued_jobs=0,
                           result_count=0):
            mock_request_queue.info.return_value = dict(
                count=request_count,
                processing_jobs=request_processing_jobs,
                queued_jobs=request_queued_jobs
            )
            mock_result_queue.count.return_value = result_count

        set_queue_info()
        ok_(conn._requests_completed())

        set_queue_info(request_count=1)
        ok_(not conn._requests_completed())

        set_queue_info(request_processing_jobs=1)
        ok_(not conn._requests_completed())

        set_queue_info(request_queued_jobs=1)
        ok_(not conn._requests_completed())

        set_queue_info(result_count=1)
        ok_(not conn._requests_completed())

########NEW FILE########
__FILENAME__ = test_request
# -*- coding: utf-8 -*-

from nose.tools import *
from mock import Mock, patch
import re

from picrawler import request
from picrawler.request import Request
from picrawler.response import Response, ErrorResponse


class TestRequest(object):
    def test_constructor(self):
        Request('http://dummy', 'get')

    @raises(request.InvalidHTTPMethod)
    def test_constructor_with_invalid_method(self):
        Request('http://dummy', 'dummy')

    def test_id(self):
        req = Request('http://dummy', 'get')
        ok_(re.match(r'^[0-9a-f]{32}$', req.id))

    def test_url(self):
        req = Request('http://dummy', 'get')
        eq_('http://dummy', req.url)

    def test_method(self):
        req = Request('http://dummy', 'get')
        eq_('get', req.method)

    def test_headers(self):
        req = Request('http://dummy', 'get', headers=dict(n='v'))
        eq_(dict(n='v'), req.headers)

    def test_args(self):
        req = Request('http://dummy', 'get', args=dict(n='v'))
        eq_(dict(n='v'), req.args)

    def test_success_callback(self):
        mock_success_cb = Mock()

        req = Request('http://dummy', success_callback=mock_success_cb)
        eq_(mock_success_cb, req.success_callback)

    def test_success_callback_not_specified(self):
        req = Request('http://dummy')
        eq_(None, req.success_callback)

    def test_error_callback(self):
        mock_error_cb = Mock()

        req = Request('http://dummy', error_callback=mock_error_cb)
        eq_(mock_error_cb, req.error_callback)

    def test_error_callback_not_specified(self):
        req = Request('http://dummy')
        eq_(None, req.error_callback)

    def test_run_success_callback(self):
        mock_success_cb = Mock()

        req = Request('http://dummy', success_callback=mock_success_cb)

        mock_resp = Response(req, 200, 'content', {})
        req.run_callback(mock_resp)

        mock_success_cb.assert_called_once_with(mock_resp)

    def test_run_error_callback(self):
        mock_error_cb = Mock()

        req = Request('http://dummy', error_callback=mock_error_cb)

        mock_resp = ErrorResponse(req, Exception())
        req.run_callback(mock_resp)

        mock_error_cb.assert_called_once_with(mock_resp)

    @raises(request.InvalidResponse)
    def test_run_callback_with_invalid_response(self):
        req = Request('http://dummy')
        req.run_callback({})

    @patch('requests.get')
    def test_call(self, requests_get):
        req = request.Request('http://dummy', 'GET')
        ret = req()

        ok_(isinstance(ret, Response))

        (args, kwargs) = requests_get.call_args
        eq_('http://dummy', args[0])

    @patch('requests.get')
    def test_call_with_error(self, requests_get):
        req = request.Request('http://dummy', 'GET')
        exception = Exception('error')
        requests_get.side_effect = exception

        ret = req()

        ok_(isinstance(ret, ErrorResponse))
        eq_(exception, ret.exception)

########NEW FILE########
__FILENAME__ = test_response
# -*- coding: utf-8 -*-

from nose.tools import *
from mock import Mock
import pickle

from picrawler.response import BaseResponse, Response, ErrorResponse


class TestBaseResponse(object):
    def test_constructor(self):
        request_mock = Mock()
        ins = BaseResponse(request_mock)
        eq_(ins.request, request_mock)

    def test_run_callback(self):
        request_mock = Mock()
        ins = BaseResponse(request_mock)
        ins.run_callback()
        request_mock.run_callback.called_once_with(ins)

    def test_pickle_instance(self):
        request_mock = {}
        ins = BaseResponse(request_mock)
        ins2 = pickle.loads(pickle.dumps(ins))
        eq_(ins.__dict__, ins2.__dict__)


class TestResponse(object):
    def test_constructor(self):
        request_mock = Mock()
        ins = Response(request_mock, 200, 'dummy', dict(name='value'))

        eq_(200, ins.status_code)
        eq_('dummy', ins.content)
        eq_(dict(name='value'), ins.headers)
        eq_(ins.request, request_mock)


class TestErrorResponse(object):
    def test_constructor(self):
        request_mock = Mock()
        exception = Exception('error')
        ins = ErrorResponse(request_mock, exception)

        eq_(exception, ins.exception)
        eq_(ins.request, request_mock)

########NEW FILE########
__FILENAME__ = test_rt_cores
# -*- coding: utf-8 -*-

from nose.tools import *
from mock import patch

from picrawler.rt_cores import RTCoreRequest


class TestRTCoreRequest(object):
    @patch('picrawler.rt_cores.cloud')
    def test_request(self, mock_cloud):
        req = RTCoreRequest('c1', 10, 1)

        mock_cloud.realtime.request.return_value = dict(request_id=10)

        req_id = req.request()

        mock_cloud.realtime.request.assert_called_once_with('c1', 10, 1)
        eq_(10, req_id)

    @patch('picrawler.rt_cores.cloud')
    def test_release_rt_cores(self, mock_cloud):
        req = RTCoreRequest('c1', 10, 1)

        mock_cloud.realtime.request.return_value = dict(request_id=10)

        req_id = req.request()
        req.release(req_id)

        mock_cloud.realtime.release.assert_called_once_with(req_id)

    @patch('picrawler.rt_cores.cloud')
    def test_with_with_statement(self, mock_cloud):
        with RTCoreRequest('c1', 10, 1):
            mock_cloud.realtime.request.assert_called_once_with('c1', 10, 1)
            eq_(0, mock_cloud.realtime.release.call_count)

        eq_(1, mock_cloud.realtime.release.call_count)



########NEW FILE########
