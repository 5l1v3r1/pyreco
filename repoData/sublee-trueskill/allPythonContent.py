__FILENAME__ = conftest
# -*- coding: utf-8 -*-
from __future__ import with_statement

from trueskill.backends import available_backends


backends = available_backends()


def pytest_addoption(parser):
    parser.addoption('--backend', action='append', default=[])


def pytest_generate_tests(metafunc):
    if getattr(metafunc.function, '_various_backends', False):
        available = [None if str(backend).lower() == 'none' else backend
                     for backend in metafunc.config.option.backend or backends]
        selected = metafunc.function._various_backends
        if selected is True:
            parametrized_backends = available
        elif selected is False:
            parametrized_backends = None
        else:
            parametrized_backends = set(available).intersection(selected)
        metafunc.parametrize('backend', parametrized_backends)


def various_backends(backends=None):
    import inspect
    from trueskillhelpers import substituted_trueskill
    if hasattr(backends, '__call__'):
        return various_backends(True)(backends)
    def decorator(f):
        def wrapped(backend, *args, **kwargs):
            if 'backend' in inspect.getargspec(f)[0]:
                kwargs['backend'] = kwargs.get('backend', backend)
            with substituted_trueskill(backend=backend):
                return f(*args, **kwargs)
        wrapped.__name__ = f.__name__
        wrapped.__doc__ = f.__doc__
        wrapped._various_backends = backends
        return wrapped
    return decorator

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# trueskill documentation build configuration file, created by
# sphinx-quickstart on Tue Jan 17 22:33:12 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('_themes'))
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.mathjax']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'trueskill'
copyright = u'2012-2013, Heungsub Lee'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
from trueskill import __version__ as version
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
#pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'trueskill'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {'github_fork': 'sublee/trueskill',
                      'google_analytics': 'UA-28655602-3'}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = 'favicon.ico'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'trueskilldoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'trueskill.tex', u'TrueSkill Documentation',
   u'Heungsub Lee', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'trueskill', u'TrueSkill Documentation',
     [u'Heungsub Lee'], 1)
]

########NEW FILE########
__FILENAME__ = backends
# -*- coding: utf-8 -*-
"""
    trueskill.backends
    ~~~~~~~~~~~~~~~~~~

    Provides mathematical statistics backend chooser.

    :copyright: (c) 2012-2013 by Heungsub Lee.
    :license: BSD, see LICENSE for more details.
"""
from __future__ import absolute_import
import math


__all__ = ['available_backends', 'choose_backend', 'cdf', 'pdf', 'ppf']


def _gen_erfcinv(erfc, math=math):
    """Generates the inverse function of erfc by the given erfc function and
    math module.
    """
    def erfcinv(y):
        """The inverse function of erfc."""
        if y >= 2:
            return -100.
        elif y <= 0:
            return 100.
        zero_point = y < 1
        if not zero_point:
            y = 2 - y
        t = math.sqrt(-2 * math.log(y / 2.))
        x = -0.70711 * \
            ((2.30753 + t * 0.27061) / (1. + t * (0.99229 + t * 0.04481)) - t)
        for i in xrange(2):
            err = erfc(x) - y
            x += err / (1.12837916709551257 * math.exp(-(x ** 2)) - x * err)
        return x if zero_point else -x
    return erfcinv


def _gen_ppf(erfc, math=math):
    """ppf is the inverse function of cdf. This function generates cdf by the
    given erfc and math module.
    """
    erfcinv = _gen_erfcinv(erfc, math)
    def ppf(x, mu=0, sigma=1):
        """The inverse function of cdf."""
        return mu - sigma * math.sqrt(2) * erfcinv(2 * x)
    return ppf


def erfc(x):
    """Complementary error function (via `http://bit.ly/zOLqbc`_)"""
    z = abs(x)
    t = 1. / (1. + z / 2.)
    r = t * math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (
                     0.37409196 + t * (0.09678418 + t * (
                     -0.18628806 + t * (0.27886807 + t * (
                     -1.13520398 + t * (1.48851587 + t * (
                     -0.82215223 + t * 0.17087277)))))))))
    return 2. - r if x < 0 else r


def cdf(x, mu=0, sigma=1):
    """Cumulative distribution function"""
    return 0.5 * erfc(-(x - mu) / (sigma * math.sqrt(2)))


def pdf(x, mu=0, sigma=1):
    """Probability density function"""
    return (1 / math.sqrt(2 * math.pi) * abs(sigma) *
            math.exp(-(((x - mu) / abs(sigma)) ** 2 / 2)))


ppf = _gen_ppf(erfc)


def choose_backend(backend):
    """Returns a tuple containing cdf, pdf, ppf from the chosen backend.

    >>> cdf, pdf, ppf = choose_backend(None)
    >>> cdf(-10)
    7.619853263532764e-24
    >>> cdf, pdf, ppf = choose_backend('mpmath')
    >>> cdf(-10)
    mpf('7.6198530241605255e-24')

    .. versionadded:: 0.3
    """
    if backend is None:  # fallback
        return cdf, pdf, ppf
    elif backend == 'mpmath':
        try:
            import mpmath
        except ImportError:
            raise ImportError('Install "mpmath" to use this backend')
        return mpmath.ncdf, mpmath.npdf, _gen_ppf(mpmath.erfc, math=mpmath)
    elif backend == 'scipy':
        try:
            from scipy.stats import norm
        except ImportError:
            raise ImportError('Install "scipy" to use this backend')
        return norm.cdf, norm.pdf, norm.ppf
    raise ValueError('%r backend is not defined' % backend)


def available_backends():
    """Detects list of available backends. All of defined backends are ``None``
    -- internal implementation, "mpmath", "scipy".

    You can check if the backend is available in the current environment with
    this function::

       if 'mpmath' in available_backends():
           # mpmath can be used in the current environment
           setup(backend='mpmath')

    .. versionadded:: 0.3
    """
    backends = [None]
    for backend in ['mpmath', 'scipy']:
        try:
            __import__(backend)
        except ImportError:
            continue
        backends.append(backend)
    return backends

########NEW FILE########
__FILENAME__ = deprecated
# -*- coding: utf-8 -*-
"""
    trueskill.deprecated
    ~~~~~~~~~~~~~~~~~~~~

    Deprecated features.

    :copyright: (c) 2012-2013 by Heungsub Lee
    :license: BSD, see LICENSE for more details.
"""
from __future__ import absolute_import

from . import Rating, expose, global_env, rate_1vs1, quality_1vs1, DELTA


__all__ = ['transform_ratings', 'match_quality', 'dynamic_draw_probability',
           'ensure_backward_compatibility']


# deprecated functions


def transform_ratings(rating_groups, ranks=None, min_delta=DELTA):
    return global_env().transform_ratings(rating_groups, ranks, min_delta)


def match_quality(rating_groups):
    return global_env().match_quality(rating_groups)


def dynamic_draw_probability(rating1, rating2, env=None):
    """Deprecated. It was an approximation for :func:`quality_1vs1`.

    .. deprecated:: 0.4.1
       Use :func:`quality_1vs1` instead.
    """
    from warnings import warn
    warn('Use quality_1vs1 instead', DeprecationWarning)
    return quality_1vs1(rating1, rating2, env=env)


# deprecated methods


def addattr(obj, attr, value):
    if hasattr(obj, attr):
        raise AttributeError('The attribute already exists')
    return setattr(obj, attr, value)


def ensure_backward_compatibility(TrueSkill, Rating):
    addattr(TrueSkill, 'Rating', TrueSkill_Rating)
    addattr(TrueSkill, 'transform_ratings', TrueSkill_transform_ratings)
    addattr(TrueSkill, 'match_quality', TrueSkill_match_quality)
    addattr(TrueSkill, 'rate_1vs1', TrueSkill_rate_1vs1)
    addattr(TrueSkill, 'quality_1vs1', TrueSkill_quality_1vs1)
    addattr(Rating, 'exposure', Rating_exposure)


def TrueSkill_Rating(self, mu=None, sigma=None):
    """Deprecated. Used to create a :class:`Rating` object.

    .. deprecated:: 0.2
       Override :meth:`create_rating` instead.
    """
    from warnings import warn
    warn('TrueSkill.Rating is now called TrueSkill.create_rating',
         DeprecationWarning)
    return self.create_rating(mu, sigma)


def TrueSkill_transform_ratings(self, rating_groups, ranks=None,
                                min_delta=DELTA):
    """Deprecated. Used to rate the given ratings.

    .. deprecated:: 0.2
       Override :meth:`rate` instead.
    """
    from warnings import warn
    warn('TrueSkill.transform_ratings is now called TrueSkill.rate',
         DeprecationWarning)
    rating_groups = [(r,) if isinstance(r, Rating) else r
                     for r in rating_groups]
    return self.rate(rating_groups, ranks, min_delta=min_delta)


def TrueSkill_match_quality(self, rating_groups):
    """Deprecated. Used to calculate a match quality.

    .. deprecated:: 0.2
       Override :meth:`quality` instead.
    """
    from warnings import warn
    warn('TrueSkill.match_quality is now called TrueSkill.quality',
         DeprecationWarning)
    rating_groups = [(r,) if isinstance(r, Rating) else r
                     for r in rating_groups]
    return self.quality(rating_groups)


def TrueSkill_rate_1vs1(self, rating1, rating2, drawn=False, min_delta=DELTA):
    """Deprecated. Used to rate just a head-to-haed match.

    .. deprecated:: 0.4
       Use :func:`rate_1vs1` instead.
    """
    from warnings import warn
    warn('Use rate_1vs1, a normal function instead', DeprecationWarning)
    return rate_1vs1(rating1, rating2, drawn, min_delta, self)


def TrueSkill_quality_1vs1(self, rating1, rating2):
    """Deprecated. Used to calculate a match quality for a head-to-haed match.

    .. deprecated:: 0.4
       Use :func:`quality_1vs1` instead.
    """
    from warnings import warn
    warn('Use quality_1vs1, a normal function instead', DeprecationWarning)
    return quality_1vs1(rating1, rating2, self)


@property
def Rating_exposure(self):
    """Deprecated. Used to get a value that will go up on the whole.

    .. deprecated:: 0.4
       Use :meth:`TrueSkill.expose` instead.
    """
    from warnings import warn
    warn('Use TrueSkill.expose instead', DeprecationWarning)
    return expose(self)

########NEW FILE########
__FILENAME__ = factorgraph
# -*- coding: utf-8 -*-
"""
    trueskill.factorgraph
    ~~~~~~~~~~~~~~~~~~~~~

    This module contains nodes for the factor graph of TrueSkill algorithm.

    :copyright: (c) 2012-2013 by Heungsub Lee.
    :license: BSD, see LICENSE for more details.
"""
from __future__ import absolute_import
import itertools
import math

from .mathematics import Gaussian, inf


__all__ = ['Variable', 'PriorFactor', 'LikelihoodFactor', 'SumFactor',
           'TruncateFactor']


class Node(object):

    pass


class Variable(Node, Gaussian):

    def __init__(self):
        self.messages = {}
        super(Variable, self).__init__()

    def set(self, val):
        delta = self.delta(val)
        self.pi, self.tau = val.pi, val.tau
        return delta

    def delta(self, other):
        pi_delta = abs(self.pi - other.pi)
        if pi_delta == inf:
            return 0.
        return max(abs(self.tau - other.tau), math.sqrt(pi_delta))

    def update_message(self, factor, pi=0, tau=0, message=None):
        message = message or Gaussian(pi=pi, tau=tau)
        old_message, self[factor] = self[factor], message
        return self.set(self / old_message * message)

    def update_value(self, factor, pi=0, tau=0, value=None):
        value = value or Gaussian(pi=pi, tau=tau)
        old_message = self[factor]
        self[factor] = value * old_message / self
        return self.set(value)

    def __getitem__(self, factor):
        return self.messages[factor]

    def __setitem__(self, factor, message):
        self.messages[factor] = message

    def __repr__(self):
        args = (type(self).__name__, super(Variable, self).__repr__(),
                len(self.messages), '' if len(self.messages) == 1 else 's')
        return '<%s %s with %d connection%s>' % args


class Factor(Node):

    def __init__(self, vars):
        self.vars = vars
        for var in vars:
            var[self] = Gaussian()

    def down(self):
        return 0

    def up(self):
        return 0

    @property
    def var(self):
        assert len(self.vars) == 1
        return self.vars[0]

    def __repr__(self):
        args = (type(self).__name__, len(self.vars),
                '' if len(self.vars) == 1 else 's')
        return '<%s with %d connection%s>' % args


class PriorFactor(Factor):

    def __init__(self, var, val, dynamic=0):
        super(PriorFactor, self).__init__([var])
        self.val = val
        self.dynamic = dynamic

    def down(self):
        sigma = math.sqrt(self.val.sigma ** 2 + self.dynamic ** 2)
        value = Gaussian(self.val.mu, sigma)
        return self.var.update_value(self, value=value)


class LikelihoodFactor(Factor):

    def __init__(self, mean_var, value_var, variance):
        super(LikelihoodFactor, self).__init__([mean_var, value_var])
        self.mean = mean_var
        self.value = value_var
        self.variance = variance

    def down(self):
        # update value
        val = self.mean
        msg = val / self.mean[self]
        pi = 1. / self.variance
        a = pi / (pi + val.pi)
        return self.value.update_message(self, a * msg.pi, a * msg.tau)

    def up(self):
        # update mean
        val = self.value
        msg = val / self.value[self]
        a = 1. / (1 + self.variance * msg.pi)
        return self.mean.update_message(self, a * msg.pi, a * msg.tau)


class SumFactor(Factor):

    def __init__(self, sum_var, term_vars, coeffs):
        super(SumFactor, self).__init__([sum_var] + term_vars)
        self.sum = sum_var
        self.terms = term_vars
        self.coeffs = coeffs

    def down(self):
        vals = self.terms
        msgs = [var[self] for var in vals]
        return self.update(self.sum, vals, msgs, self.coeffs)

    def up(self, index=0):
        coeff = self.coeffs[index]
        coeffs = []
        for x, c in enumerate(self.coeffs):
            try:
                if x == index:
                    coeffs.append(1. / coeff)
                else:
                    coeffs.append(-c / coeff)
            except ZeroDivisionError:
                coeffs.append(0.)
        vals = self.terms[:]
        vals[index] = self.sum
        msgs = [var[self] for var in vals]
        return self.update(self.terms[index], vals, msgs, coeffs)

    def update(self, var, vals, msgs, coeffs):
        pi_inv = 0
        mu = 0
        for val, msg, coeff in itertools.izip(vals, msgs, coeffs):
            div = val / msg
            mu += coeff * div.mu
            if pi_inv == inf:
                continue
            try:
                # numpy.float64 handles floating-point error by different way.
                # For example, it can just warn RuntimeWarning on n/0 problem
                # instead of throwing ZeroDivisionError. So div.pi, the
                # denominator has to be a built-in float.
                pi_inv += coeff ** 2 / float(div.pi)
            except ZeroDivisionError:
                pi_inv = inf
        pi = 1. / pi_inv
        tau = pi * mu
        return var.update_message(self, pi, tau)


class TruncateFactor(Factor):

    def __init__(self, var, v_func, w_func, draw_margin):
        super(TruncateFactor, self).__init__([var])
        self.v_func = v_func
        self.w_func = w_func
        self.draw_margin = draw_margin

    def up(self):
        val = self.var
        msg = self.var[self]
        div = val / msg
        sqrt_pi = math.sqrt(div.pi)
        args = (div.tau / sqrt_pi, self.draw_margin * sqrt_pi)
        v = self.v_func(*args)
        w = self.w_func(*args)
        denom = (1. - w)
        pi, tau = div.pi / denom, (div.tau + sqrt_pi * v) / denom
        return val.update_value(self, pi, tau)

########NEW FILE########
__FILENAME__ = mathematics
# -*- coding: utf-8 -*-
"""
    trueskill.mathematics
    ~~~~~~~~~~~~~~~~~~~~~

    This module contains basic mathematics functions and objects for TrueSkill
    algorithm. If you have not scipy, this module provides the fallback.

    :copyright: (c) 2012-2013 by Heungsub Lee.
    :license: BSD, see LICENSE for more details.
"""
from __future__ import absolute_import
import copy
import math
try:
    from numbers import Number
except ImportError:
    Number = (int, long, float, complex)


__all__ = ['Gaussian', 'Matrix', 'inf']


inf = float('inf')


class Gaussian(object):
    """A model for the normal distribution."""

    #: Precision, the inverse of the variance.
    pi = 0
    #: Precision adjusted mean, the precision multiplied by the mean.
    tau = 0

    def __init__(self, mu=None, sigma=None, pi=0, tau=0):
        if mu is not None:
            if sigma is None:
                raise TypeError('sigma argument is needed')
            elif sigma == 0:
                raise ValueError('sigma**2 should be greater than 0')
            pi = sigma ** -2
            tau = pi * mu
        self.pi = pi
        self.tau = tau

    @property
    def mu(self):
        """A property which returns the mean."""
        return self.pi and self.tau / self.pi

    @property
    def sigma(self):
        """A property which returns the the square root of the variance."""
        return math.sqrt(1 / self.pi) if self.pi else inf

    def __mul__(self, other):
        pi, tau = self.pi + other.pi, self.tau + other.tau
        return Gaussian(pi=pi, tau=tau)

    def __truediv__(self, other):
        pi, tau = self.pi - other.pi, self.tau - other.tau
        return Gaussian(pi=pi, tau=tau)

    __div__ = __truediv__  # for Python 2

    def __eq__(self, other):
        return self.pi == other.pi and self.tau == other.tau

    def __lt__(self, other):
        return self.mu < other.mu

    def __le__(self, other):
        return self.mu <= other.mu

    def __gt__(self, other):
        return self.mu > other.mu

    def __ge__(self, other):
        return self.mu >= other.mu

    def __repr__(self):
        return 'N(mu=%.3f, sigma=%.3f)' % (self.mu, self.sigma)

    def _repr_latex_(self):
        latex = r'\mathcal{ N }( %.3f, %.3f^2 )' % (self.mu, self.sigma)
        return '$%s$' % latex


class Matrix(list):
    """A model for matrix."""

    def __init__(self, src, height=None, width=None):
        if callable(src):
            f, src = src, {}
            size = [height, width]
            if not height:
                def set_height(height):
                    size[0] = height
                size[0] = set_height
            if not width:
                def set_width(width):
                    size[1] = width
                size[1] = set_width
            try:
                for (r, c), val in f(*size):
                    src[r, c] = val
            except TypeError:
                raise TypeError('A callable src must return an interable '
                                'which generates a tuple containing '
                                'coordinate and value')
            height, width = tuple(size)
            if height is None or width is None:
                raise TypeError('A callable src must call set_height and '
                                'set_width if the size is non-deterministic')
        if isinstance(src, list):
            is_number = lambda x: isinstance(x, Number)
            unique_col_sizes = set(map(len, src))
            everything_are_number = filter(is_number, sum(src, []))
            if len(unique_col_sizes) != 1 or not everything_are_number:
                raise ValueError('src must be a rectangular array of numbers')
            two_dimensional_array = src
        elif isinstance(src, dict):
            if not height or not width:
                w = h = 0
                for r, c in src.iterkeys():
                    if not height:
                        h = max(h, r + 1)
                    if not width:
                        w = max(w, c + 1)
                if not height:
                    height = h
                if not width:
                    width = w
            two_dimensional_array = []
            for r in range(height):
                row = []
                two_dimensional_array.append(row)
                for c in range(width):
                    row.append(src.get((r, c), 0))
        else:
            raise TypeError('src must be a list or dict or callable')
        super(Matrix, self).__init__(two_dimensional_array)

    @property
    def height(self):
        return len(self)

    @property
    def width(self):
        return len(self[0])

    def transpose(self):
        height, width = self.height, self.width
        src = {}
        for c in range(width):
            for r in range(height):
                src[c, r] = self[r][c]
        return type(self)(src, height=width, width=height)

    def minor(self, row_n, col_n):
        height, width = self.height, self.width
        if not (0 <= row_n < height):
            raise ValueError('row_n should be between 0 and %d' % height)
        elif not (0 <= col_n < width):
            raise ValueError('col_n should be between 0 and %d' % width)
        two_dimensional_array = []
        for r in range(height):
            if r == row_n:
                continue
            row = []
            two_dimensional_array.append(row)
            for c in range(width):
                if c == col_n:
                    continue
                row.append(self[r][c])
        return type(self)(two_dimensional_array)

    def determinant(self):
        height, width = self.height, self.width
        if height != width:
            raise ValueError('Only square matrix can calculate a determinant')
        tmp, rv = copy.deepcopy(self), 1.
        for c in range(width - 1, 0, -1):
            pivot, r = max((abs(tmp[r][c]), r) for r in range(c + 1))
            pivot = tmp[r][c]
            if not pivot:
                return 0.
            tmp[r], tmp[c] = tmp[c], tmp[r]
            if r != c:
                rv = -rv
            rv *= pivot
            fact = -1. / pivot
            for r in range(c):
                f = fact * tmp[r][c]
                for x in range(c):
                    tmp[r][x] += f * tmp[c][x]
        return rv * tmp[0][0]

    def adjugate(self):
        height, width = self.height, self.width
        if height != width:
            raise ValueError('Only square matrix can be adjugated')
        if height == 2:
            a, b = self[0][0], self[0][1]
            c, d = self[1][0], self[1][1]
            return type(self)([[d, -b], [-c, a]])
        src = {}
        for r in range(height):
            for c in range(width):
                sign = -1 if (r + c) % 2 else 1
                src[r, c] = self.minor(r, c).determinant() * sign
        return type(self)(src, height, width)

    def inverse(self):
        if self.height == self.width == 1:
            return type(self)([[1. / self[0][0]]])
        return (1. / self.determinant()) * self.adjugate()

    def __add__(self, other):
        height, width = self.height, self.width
        if (height, width) != (other.height, other.width):
            raise ValueError('Must be same size')
        src = {}
        for r in range(height):
            for c in range(width):
                src[r, c] = self[r][c] + other[r][c]
        return type(self)(src, height, width)

    def __mul__(self, other):
        if self.width != other.height:
            raise ValueError('Bad size')
        height, width = self.height, other.width
        src = {}
        for r in range(height):
            for c in range(width):
                src[r, c] = sum(self[r][x] * other[x][c]
                                for x in range(self.width))
        return type(self)(src, height, width)

    def __rmul__(self, other):
        if not isinstance(other, Number):
            raise TypeError('The operand should be a number')
        height, width = self.height, self.width
        src = {}
        for r in range(height):
            for c in range(width):
                src[r, c] = other * self[r][c]
        return type(self)(src, height, width)

    def __repr__(self):
        return '%s(%s)' % (type(self).__name__, super(Matrix, self).__repr__())

    def _repr_latex_(self):
        rows = [' && '.join(['%.3f' % cell for cell in row]) for row in self]
        latex = r'\begin{matrix} %s \end{matrix}' % r'\\'.join(rows)
        return '$%s$' % latex

########NEW FILE########
__FILENAME__ = trueskillhelpers
# -*- coding: utf-8 -*-
from __future__ import with_statement
from contextlib import contextmanager
import functools
import inspect
import logging

import trueskill
from trueskill.backends import available_backends
from trueskill.factorgraph import (Variable, Factor, PriorFactor,
                                   LikelihoodFactor, SumFactor)
from trueskill.mathematics import Gaussian


__all__ = ['substituted_trueskill', 'calc_dynamic_draw_probability',
           'factor_graph_logging']


@contextmanager
def substituted_trueskill(*args, **kwargs):
    """Setup the global environment only within the context::

       assert Rating().mu == 25
       with substituted_trueskill(mu=0):
           assert Rating().mu == 0
    """
    env = trueskill.global_env()
    params = [['mu', env.mu], ['sigma', env.sigma], ['beta', env.beta],
              ['tau', env.tau], ['draw_probability', env.draw_probability],
              ['backend', env.backend]]
    # merge settings with previous TrueSkill object
    for x, arg in enumerate(args):
        params[x][1] = arg
    params = dict(params)
    for kw, arg in kwargs.items():
        params[kw] = arg
    try:
        # setup the environment
        yield trueskill.setup(**params)
    finally:
        # revert the environment
        trueskill.setup(env=env)


def calc_dynamic_draw_probability(rating_group1, rating_group2, env=None):
    from trueskill.factorgraph import (Variable, )
    if env is None:
        env = global_env()
    team_perf_vars = []
    for rating_group in [rating_group1, rating_group2]:
        team_perf_var = Variable()
        team_perf_vars.append(team_perf_var)
        perf_vars = []
        for rating in rating_group:
            rating_var, perf_var = Variable(), Variable()
            perf_vars.append(perf_var)
            PriorFactor(rating_var, rating, env.tau).down()
            LikelihoodFactor(rating_var, perf_var, env.beta ** 2).down()
        SumFactor(team_perf_var, perf_vars, [1] * len(perf_vars)).down()
    return env.draw_probability(trueskill.Rating(team_perf_vars[0]),
                                trueskill.Rating(team_perf_vars[1]), env)


@contextmanager
def factor_graph_logging(color=False):
    """In the context, a factor graph prints logs as DEBUG level. It will help
    to follow factor graph running schedule::

       with factor_graph_logging() as logger:
           logger.setLevel(DEBUG)
           logger.addHandler(StreamHandler(sys.stderr))
           rate_1vs1(Rating(), Rating())
    """
    import inspect
    # color mode uses the termcolor module
    if color:
        try:
            from termcolor import colored
        except ImportError:
            raise ImportError('To enable color mode, install termcolor')
    else:
        colored = lambda s, *a, **k: s
    logger = logging.getLogger('TrueSkill')
    orig_factor_init = Factor.__init__
    orig_variable_set = Variable.set
    def repr_factor(factor):
        return '{0}@{1}'.format(type(factor).__name__, id(factor))
    def repr_gauss(gauss):
        return 'N(mu=%.3f, sigma=%.3f, pi=%r, tau=%r)' % \
               (gauss.mu, gauss.sigma, gauss.pi, gauss.tau)
    def r(val):
        if isinstance(val, Factor):
            return repr_factor(val)
        elif isinstance(val, Gaussian):
            return repr_gauss(val)
        else:
            return repr(val)
    def factor_init(self, *args, **kwargs):
        frames = inspect.getouterframes(inspect.currentframe())
        layer_builder_name = frames[2][3]
        assert (layer_builder_name.startswith('build_') and
                layer_builder_name.endswith('_layer'))
        self._layer_name = layer_builder_name[6:].replace('_', ' ').title()
        return orig_factor_init(self, *args, **kwargs)
    def variable_set(self, val):
        old_value = Gaussian(pi=self.pi, tau=self.tau)
        old_messages = dict((fac, Gaussian(pi=msg.pi, tau=msg.tau))
                            for fac, msg in self.messages.items())
        delta = orig_variable_set(self, val)
        # inspect outer frames
        frames = inspect.getouterframes(inspect.currentframe())
        methods = [None, None]
        for frame in frames:
            method = frame[3]
            if method.startswith('update_'):
                methods[0] = method
            elif method in ('up', 'down'):
                methods[1] = method
                break
        factor = frame[0].f_locals['self']
        before = Gaussian(pi=self.pi, tau=self.tau)
        # helpers for logging
        logs = []
        l = logs.append
        bullet = lambda changed: colored(' * ', 'red') if changed else '   '
        # print layer
        if getattr(logger, '_prev_layer_name', None) != factor._layer_name:
            logger._prev_layer_name = factor._layer_name
            l(colored('[{0}]'.format(factor._layer_name), 'blue'))
        # print factor
        l(colored('<{0}.{1}>'.format(r(factor), methods[1]), 'cyan'))
        # print value
        if old_value == self:
            line = '{0}'.format(r(self))
        else:
            line = '{0} -> {1}'.format(r(old_value), r(self))
        l(bullet(methods[0] == 'update_value') + line)
        # print messages
        fmt = '{0}: {1} -> {2}'.format
        for fac, msg in self.messages.items():
            old_msg = old_messages[fac]
            changed = fac is factor and methods[0] == 'update_message'
            if old_msg == msg:
                line = '{0}: {1}'.format(r(fac), r(msg))
            else:
                line = '{0}: {1} -> {2}'.format(r(fac), r(old_msg), r(msg))
            l(bullet(changed) + line)
        # print buffered logs
        map(logger.debug, logs)
        return delta
    try:
        Factor.__init__, Variable.set = factor_init, variable_set
        yield logger
    finally:
        Factor.__init__, Variable.set = orig_factor_init, orig_variable_set

########NEW FILE########
__FILENAME__ = trueskilltests
# -*- coding: utf-8 -*-
from __future__ import with_statement
import warnings

from almost import Approximate
from pytest import deprecated_call, raises

from conftest import various_backends
from trueskill import *


inf = float('inf')
nan = float('nan')


class almost(Approximate):

    def normalize(self, value):
        if isinstance(value, Rating):
            return self.normalize(tuple(value))
        elif isinstance(value, list):
            try:
                if isinstance(value[0][0], Rating):
                    # flatten transformed ratings
                    return list(sum(value, ()))
            except (TypeError, IndexError):
                pass
        return super(almost, self).normalize(value)

    @classmethod
    def wrap(cls, f, *args, **kwargs):
        return lambda *a, **k: cls(f(*a, **k), *args, **kwargs)


_rate = almost.wrap(rate)
_rate_1vs1 = almost.wrap(rate_1vs1)
_quality = almost.wrap(quality)
_quality_1vs1 = almost.wrap(quality_1vs1)


# usage


def test_compatibility_with_another_rating_systems():
    """All rating system modules should implement ``rate_1vs1`` and
    ``quality_1vs1`` to provide shortcuts for 1 vs 1 simple competition games.
    """
    r1, r2 = Rating(30, 3), Rating(20, 2)
    assert quality_1vs1(r1, r2) == quality([(r1,), (r2,)])
    rated = rate([(r1,), (r2,)])
    assert rate_1vs1(r1, r2) == (rated[0][0], rated[1][0])
    rated = rate([(r1,), (r2,)], [0, 0])
    assert rate_1vs1(r1, r2, drawn=True) == (rated[0][0], rated[1][0])


def test_compare_ratings():
    assert Rating(1, 2) == Rating(1, 2)
    assert Rating(1, 2) != Rating(1, 3)
    assert Rating(2, 2) > Rating(1, 2)
    assert Rating(3, 2) >= Rating(1, 2)
    assert Rating(0, 2) < Rating(1, 2)
    assert Rating(-1, 2) <= Rating(1, 2)


def test_rating_to_number():
    assert int(Rating(1, 2)) == 1
    assert float(Rating(1.1, 2)) == 1.1
    assert complex(Rating(1.2, 2)) == 1.2 + 0j
    try:
        assert long(Rating(1, 2)) == long(1)
    except NameError:
        # Python 3 doesn't have `long` anymore
        pass


def test_unsorted_groups():
    t1, t2, t3 = generate_teams([1, 1, 1])
    rated = rate([t1, t2, t3], [2, 1, 0])
    assert almost(rated) == \
        [(18.325, 6.656), (25.000, 6.208), (31.675, 6.656)]


def test_custom_environment():
    env = TrueSkill(draw_probability=.50)
    t1, t2 = generate_teams([1, 1], env=env)
    rated = env.rate([t1, t2])
    assert almost(rated) == [(30.267, 7.077), (19.733, 7.077)]


def test_setup_global_environment():
    try:
        setup(draw_probability=.50)
        t1, t2 = generate_teams([1, 1])
        rated = rate([t1, t2])
        assert almost(rated) == [(30.267, 7.077), (19.733, 7.077)]
    finally:
        # rollback
        setup()


def test_invalid_rating_groups():
    env = TrueSkill()
    with raises(ValueError):
        env.validate_rating_groups([])
    with raises(ValueError):
        env.validate_rating_groups([()])
    # need multiple groups not just one
    with raises(ValueError):
        env.validate_rating_groups([(Rating(),)])
    # empty group is not allowed
    with raises(ValueError):
        env.validate_rating_groups([(Rating(),), ()])
    # all groups should be same structure
    with raises(TypeError):
        env.validate_rating_groups([(Rating(),), {0: Rating()}])


def test_deprecated_methods():
    env = TrueSkill()
    r1, r2, r3 = Rating(), Rating(), Rating()
    deprecated_call(transform_ratings, [(r1,), (r2,), (r3,)])
    deprecated_call(match_quality, [(r1,), (r2,), (r3,)])
    deprecated_call(env.Rating)
    deprecated_call(env.transform_ratings, [(r1,), (r2,), (r3,)])
    deprecated_call(env.match_quality, [(r1,), (r2,), (r3,)])
    deprecated_call(env.rate_1vs1, r1, r2)
    deprecated_call(env.quality_1vs1, r1, r2)
    deprecated_call(lambda: Rating().exposure)
    dyn = TrueSkill(draw_probability=dynamic_draw_probability)
    deprecated_call(dyn.rate, [(r1,), (r2,)])


def test_deprecated_individual_rating_groups():
    r1, r2, r3 = Rating(50, 1), Rating(10, 5), Rating(15, 5)
    with raises(TypeError):
        deprecated_call(rate, [r1, r2, r3])
    with raises(TypeError):
        deprecated_call(quality, [r1, r2, r3])
    assert transform_ratings([r1, r2, r3]) == rate([(r1,), (r2,), (r3,)])
    assert match_quality([r1, r2, r3]) == quality([(r1,), (r2,), (r3,)])
    deprecated_call(transform_ratings, [r1, r2, r3])
    deprecated_call(match_quality, [r1, r2, r3])


def test_rating_tuples():
    r1, r2, r3 = Rating(), Rating(), Rating()
    rated = rate([(r1, r2), (r3,)])
    assert len(rated) == 2
    assert isinstance(rated[0], tuple)
    assert isinstance(rated[1], tuple)
    assert len(rated[0]) == 2
    assert len(rated[1]) == 1
    assert isinstance(rated[0][0], Rating)


def test_rating_dicts():
    class Player(object):
        def __init__(self, name, rating, team):
            self.name = name
            self.rating = rating
            self.team = team
    p1 = Player('Player A', Rating(), 0)
    p2 = Player('Player B', Rating(), 0)
    p3 = Player('Player C', Rating(), 1)
    rated = rate([{p1: p1.rating, p2: p2.rating}, {p3: p3.rating}])
    assert len(rated) == 2
    assert isinstance(rated[0], dict)
    assert isinstance(rated[1], dict)
    assert len(rated[0]) == 2
    assert len(rated[1]) == 1
    assert p1 in rated[0]
    assert p2 in rated[0]
    assert p3 in rated[1]
    assert p1 not in rated[1]
    assert p2 not in rated[1]
    assert p3 not in rated[0]
    assert isinstance(rated[0][p1], Rating)
    p1.rating = rated[p1.team][p1]
    p2.rating = rated[p2.team][p2]
    p3.rating = rated[p3.team][p3]


def test_dont_use_0_for_min_delta():
    with raises(ValueError):
        rate([(Rating(),), (Rating(),)], min_delta=0)


def test_list_instead_of_tuple():
    r1, r2 = Rating(), Rating()
    assert rate([[r1], [r2]]) == rate([(r1,), (r2,)])
    assert quality([[r1], [r2]]) == quality([(r1,), (r2,)])


def test_backend():
    env = TrueSkill(backend=(NotImplemented, NotImplemented, NotImplemented))
    with raises(TypeError):
        env.rate_1vs1(Rating(), Rating())
    with raises(ValueError):
        # '__not_defined__' backend is not defined
        TrueSkill(backend='__not_defined__')


# algorithm


def generate_teams(sizes, env=None):
    rating_cls = Rating if env is None else env.create_rating
    rating_groups = []
    for size in sizes:
        ratings = []
        for x in range(size):
            ratings.append(rating_cls())
        rating_groups.append(tuple(ratings))
    return rating_groups


def generate_individual(size, env=None):
    return generate_teams([1] * size, env=env)


@various_backends
def test_n_vs_n():
    # 1 vs 1
    t1, t2 = generate_teams([1, 1])
    assert _quality([t1, t2]) == 0.447
    assert _rate([t1, t2]) == [(29.396, 7.171), (20.604, 7.171)]
    assert _rate([t1, t2], [0, 0]) == [(25.000, 6.458), (25.000, 6.458)]
    # 2 vs 2
    t1, t2 = generate_teams([2, 2])
    assert _quality([t1, t2]) == 0.447
    assert _rate([t1, t2]) == \
        [(28.108, 7.774), (28.108, 7.774), (21.892, 7.774), (21.892, 7.774)]
    assert _rate([t1, t2], [0, 0]) == \
        [(25.000, 7.455), (25.000, 7.455), (25.000, 7.455), (25.000, 7.455)]
    # 4 vs 4
    t1, t2 = generate_teams([4, 4])
    assert _quality([t1, t2]) == 0.447
    assert _rate([t1, t2]) == \
        [(27.198, 8.059), (27.198, 8.059), (27.198, 8.059), (27.198, 8.059),
         (22.802, 8.059), (22.802, 8.059), (22.802, 8.059), (22.802, 8.059)]


@various_backends
def test_1_vs_n():
    t1, = generate_teams([1])
    # 1 vs 2
    t2, = generate_teams([2])
    assert _quality([t1, t2]) == 0.135
    assert _rate([t1, t2]) == \
        [(33.730, 7.317), (16.270, 7.317), (16.270, 7.317)]
    assert _rate([t1, t2], [0, 0]) == \
        [(31.660, 7.138), (18.340, 7.138), (18.340, 7.138)]
    # 1 vs 3
    t2, = generate_teams([3])
    assert _quality([t1, t2]) == 0.012
    assert _rate([t1, t2]) == \
        [(36.337, 7.527), (13.663, 7.527), (13.663, 7.527), (13.663, 7.527)]
    assert almost(rate([t1, t2], [0, 0]), 2) == \
        [(34.990, 7.455), (15.010, 7.455), (15.010, 7.455), (15.010, 7.455)]
    # 1 vs 7
    t2, = generate_teams([7])
    assert _quality([t1, t2]) == 0
    assert _rate([t1, t2]) == \
        [(40.582, 7.917), (9.418, 7.917), (9.418, 7.917), (9.418, 7.917),
         (9.418, 7.917), (9.418, 7.917), (9.418, 7.917), (9.418, 7.917)]


@various_backends
def test_individual():
    # 3 players
    players = generate_individual(3)
    assert _quality(players) == 0.200
    assert _rate(players) == \
        [(31.675, 6.656), (25.000, 6.208), (18.325, 6.656)]
    assert _rate(players, [0] * 3) == \
        [(25.000, 5.698), (25.000, 5.695), (25.000, 5.698)]
    # 4 players
    players = generate_individual(4)
    assert _quality(players) == 0.089
    assert _rate(players) == \
        [(33.207, 6.348), (27.401, 5.787), (22.599, 5.787), (16.793, 6.348)]
    # 5 players
    players = generate_individual(5)
    assert _quality(players) == 0.040
    assert _rate(players) == \
        [(34.363, 6.136), (29.058, 5.536), (25.000, 5.420), (20.942, 5.536),
         (15.637, 6.136)]
    # 8 players
    players = generate_individual(8)
    assert _quality(players) == 0.004
    assert _rate(players, [0] * 8) == \
        [(25.000, 4.592), (25.000, 4.583), (25.000, 4.576), (25.000, 4.573),
         (25.000, 4.573), (25.000, 4.576), (25.000, 4.583), (25.000, 4.592)]
    # 16 players
    players = generate_individual(16)
    assert _rate(players) == \
        [(40.539, 5.276), (36.810, 4.711), (34.347, 4.524), (32.336, 4.433),
         (30.550, 4.380), (28.893, 4.349), (27.310, 4.330), (25.766, 4.322),
         (24.234, 4.322), (22.690, 4.330), (21.107, 4.349), (19.450, 4.380),
         (17.664, 4.433), (15.653, 4.524), (13.190, 4.711), (9.461, 5.276)]


@various_backends
def test_multiple_teams():
    # 2 vs 4 vs 2
    t1 = (Rating(40, 4), Rating(45, 3))
    t2 = (Rating(20, 7), Rating(19, 6), Rating(30, 9), Rating(10, 4))
    t3 = (Rating(50, 5), Rating(30, 2))
    assert _quality([t1, t2, t3]) == 0.367
    assert _rate([t1, t2, t3], [0, 1, 1]) == \
        [(40.877, 3.840), (45.493, 2.934), (19.609, 6.396), (18.712, 5.625),
         (29.353, 7.673), (9.872, 3.891), (48.830, 4.590), (29.813, 1.976)]
    # 1 vs 2 vs 1
    t1 = (Rating(),)
    t2 = (Rating(), Rating())
    t3 = (Rating(),)
    assert _quality([t1, t2, t3]) == 0.047


@various_backends
def test_upset():
    # 1 vs 1
    t1, t2 = (Rating(),), (Rating(50, 12.5),)
    assert _quality([t1, t2]) == 0.110
    assert _rate([t1, t2], [0, 0]) == [(31.662, 7.137), (35.010, 7.910)]
    # 2 vs 2
    t1 = (Rating(20, 8), Rating(25, 6))
    t2 = (Rating(35, 7), Rating(40, 5))
    assert _quality([t1, t2]) == 0.084
    assert _rate([t1, t2]) == \
        [(29.698, 7.008), (30.455, 5.594), (27.575, 6.346), (36.211, 4.768)]
    # 3 vs 2
    t1 = (Rating(28, 7), Rating(27, 6), Rating(26, 5))
    t2 = (Rating(30, 4), Rating(31, 3))
    assert _quality([t1, t2]) == 0.254
    assert _rate([t1, t2], [0, 1]) == \
        [(28.658, 6.770), (27.484, 5.856), (26.336, 4.917), (29.785, 3.958),
         (30.879, 2.983)]
    assert _rate([t1, t2], [1, 0]) == \
        [(21.840, 6.314), (22.474, 5.575), (22.857, 4.757), (32.012, 3.877),
         (32.132, 2.949)]
    # 8 players
    players = [(Rating(10, 8),), (Rating(15, 7),), (Rating(20, 6),),
               (Rating(25, 5),), (Rating(30, 4),), (Rating(35, 3),),
               (Rating(40, 2),), (Rating(45, 1),)]
    assert _quality(players) == 0.000
    assert _rate(players) == \
        [(35.135, 4.506), (32.585, 4.037), (31.329, 3.756), (30.984, 3.453),
         (31.751, 3.064), (34.051, 2.541), (38.263, 1.849), (44.118, 0.983)]


@various_backends
def test_partial_play():
    t1, t2 = (Rating(),), (Rating(), Rating())
    # each results from C# Skills:
    assert rate([t1, t2], weights=[(1,), (1, 1)]) == rate([t1, t2])
    assert _rate([t1, t2], weights=[(1,), (1, 1)]) == \
        [(33.730, 7.317), (16.270, 7.317), (16.270, 7.317)]
    assert _rate([t1, t2], weights=[(0.5,), (0.5, 0.5)]) == \
        [(33.939, 7.312), (16.061, 7.312), (16.061, 7.312)]
    assert _rate([t1, t2], weights=[(1,), (0, 1)]) == \
        [(29.440, 7.166), (25.000, 8.333), (20.560, 7.166)]
    assert _rate([t1, t2], weights=[(1,), (0.5, 1)]) == \
        [(32.417, 7.056), (21.291, 8.033), (17.583, 7.056)]
    # match quality of partial play
    t1, t2, t3 = (Rating(),), (Rating(), Rating()), (Rating(),)
    assert _quality([t1, t2, t3], [(1,), (0.25, 0.75), (1,)]) == 0.2
    assert _quality([t1, t2, t3], [(1,), (0.8, 0.9), (1,)]) == 0.0809


@various_backends
def test_partial_play_with_weights_dict():
    t1, t2 = (Rating(),), (Rating(), Rating())
    assert rate([t1, t2], weights={(0, 0): 0.5, (1, 0): 0.5, (1, 1): 0.5}) == \
        rate([t1, t2], weights=[[0.5], [0.5, 0.5]])
    assert rate([t1, t2], weights={(1, 0): 0}) == \
        rate([t1, t2], weights=[[1], [0, 1]])
    assert rate([t1, t2], weights={(1, 0): 0.5}) == \
        rate([t1, t2], weights=[[1], [0.5, 1]])


@various_backends
def test_microsoft_research_example():
    # http://research.microsoft.com/en-us/projects/trueskill/details.aspx
    alice, bob, chris, darren, eve, fabien, george, hillary = \
        Rating(), Rating(), Rating(), Rating(), \
        Rating(), Rating(), Rating(), Rating()
    _rated = rate([{'alice': alice}, {'bob': bob}, {'chris': chris},
                   {'darren': darren}, {'eve': eve}, {'fabien': fabien},
                   {'george': george}, {'hillary': hillary}])
    rated = {}
    list(map(rated.update, _rated))
    assert almost(rated['alice']) == (36.771, 5.749)
    assert almost(rated['bob']) == (32.242, 5.133)
    assert almost(rated['chris']) == (29.074, 4.943)
    assert almost(rated['darren']) == (26.322, 4.874)
    assert almost(rated['eve']) == (23.678, 4.874)
    assert almost(rated['fabien']) == (20.926, 4.943)
    assert almost(rated['george']) == (17.758, 5.133)
    assert almost(rated['hillary']) == (13.229, 5.749)


@various_backends
def test_dynamic_draw_probability():
    from trueskillhelpers import calc_dynamic_draw_probability as calc
    def assert_predictable_draw_probability(r1, r2, drawn=False):
        dyn = TrueSkill(draw_probability=dynamic_draw_probability)
        sta = TrueSkill(draw_probability=calc((r1,), (r2,), dyn))
        assert dyn.rate_1vs1(r1, r2, drawn)== sta.rate_1vs1(r1, r2, drawn)
    assert_predictable_draw_probability(Rating(100), Rating(10))
    assert_predictable_draw_probability(Rating(10), Rating(100))
    assert_predictable_draw_probability(Rating(10), Rating(100), drawn=True)
    assert_predictable_draw_probability(Rating(25), Rating(25))
    assert_predictable_draw_probability(Rating(25), Rating(25), drawn=True)
    assert_predictable_draw_probability(Rating(-25), Rating(125))
    assert_predictable_draw_probability(Rating(125), Rating(-25))
    assert_predictable_draw_probability(Rating(-25), Rating(125), drawn=True)
    assert_predictable_draw_probability(Rating(25, 10), Rating(25, 0.1))


# functions


@various_backends
def test_exposure():
    env = TrueSkill()
    assert env.expose(env.create_rating()) == 0
    env = TrueSkill(1000, 200)
    assert env.expose(env.create_rating()) == 0


# mathematics


def test_valid_gaussian():
    from trueskill.mathematics import Gaussian
    with raises(TypeError):  # sigma argument is needed
        Gaussian(0)
    with raises(ValueError):  # sigma**2 should be greater than 0
        Gaussian(0, 0)


def test_valid_matrix():
    from trueskill.mathematics import Matrix
    with raises(TypeError):  # src must be a list or dict or callable
        Matrix(None)
    with raises(ValueError):  # src must be a rectangular array of numbers
        Matrix([])
    with raises(ValueError):  # src must be a rectangular array of numbers
        Matrix([[1, 2, 3], [4, 5]])
    with raises(TypeError):
        # A callable src must return an interable which generates a tuple
        # containing coordinate and value
        Matrix(lambda: None)


def test_matrix_from_dict():
    from trueskill.mathematics import Matrix
    mat = Matrix({(0, 0): 1, (4, 9): 1})
    assert mat.height == 5
    assert mat.width == 10
    assert mat[0][0] == 1
    assert mat[0][1] == 0
    assert mat[4][9] == 1
    assert mat[4][8] == 0


def test_matrix_from_item_generator():
    from trueskill.mathematics import Matrix
    def gen_matrix(height, width):
        yield (0, 0), 1
        yield (height - 1, width - 1), 1
    mat = Matrix(gen_matrix, 5, 10)
    assert mat.height == 5
    assert mat.width == 10
    assert mat[0][0] == 1
    assert mat[0][1] == 0
    assert mat[4][9] == 1
    assert mat[4][8] == 0
    with raises(TypeError):
        # A callable src must call set_height and set_width if the size is
        # non-deterministic
        Matrix(gen_matrix)
    def gen_and_set_size_matrix(set_height, set_width):
        set_height(5)
        set_width(10)
        return [((0, 0), 1), ((4, 9), 1)]
    mat = Matrix(gen_and_set_size_matrix)
    assert mat.height == 5
    assert mat.width == 10
    assert mat[0][0] == 1
    assert mat[0][1] == 0
    assert mat[4][9] == 1
    assert mat[4][8] == 0


def test_matrix_operations():
    from trueskill.mathematics import Matrix
    assert Matrix([[1, 2], [3, 4]]).inverse() == \
        Matrix([[-2.0, 1.0], [1.5, -0.5]])
    assert Matrix([[1, 2], [3, 4]]).determinant() == -2
    assert Matrix([[1, 2], [3, 4]]).adjugate() == Matrix([[4, -2], [-3, 1]])
    with raises(ValueError):  # Bad size
        assert Matrix([[1, 2], [3, 4]]) * Matrix([[5, 6]])
    assert Matrix([[1, 2], [3, 4]]) * Matrix([[5, 6, 7], [8, 9, 10]]) == \
        Matrix([[21, 24, 27], [47, 54, 61]])
    with raises(ValueError):  # Must be same size
        Matrix([[1, 2], [3, 4]]) + Matrix([[5, 6, 7], [8, 9, 10]])
    assert Matrix([[1, 2], [3, 4]]) + Matrix([[5, 6], [7, 8]]) == \
        Matrix([[6, 8], [10, 12]])


# reported bugs


@various_backends
def test_issue3():
    """The `issue #3`_, opened by @youknowone.

    These inputs led to ZeroDivisionError before 0.1.4. Also another TrueSkill
    implementations cannot calculate this case.

    .. _issue #3: https://github.com/sublee/trueskill/issues/3
    """
    # @konikos's case 1
    t1 = (Rating(42.234, 3.728), Rating(43.290, 3.842))
    t2 = (Rating(16.667, 0.500), Rating(16.667, 0.500), Rating(16.667, 0.500),
          Rating(16.667, 0.500), Rating(16.667, 0.500), Rating(16.667, 0.500),
          Rating(16.667, 0.500), Rating(16.667, 0.500), Rating(16.667, 0.500),
          Rating(16.667, 0.500), Rating(16.667, 0.500), Rating(16.667, 0.500),
          Rating(16.667, 0.500), Rating(16.667, 0.500), Rating(16.667, 0.500))
    rate([t1, t2], [6, 5])
    # @konikos's case 2
    t1 = (Rating(25.000, 0.500), Rating(25.000, 0.500), Rating(25.000, 0.500),
          Rating(25.000, 0.500), Rating(33.333, 0.500), Rating(33.333, 0.500),
          Rating(33.333, 0.500), Rating(33.333, 0.500), Rating(41.667, 0.500),
          Rating(41.667, 0.500), Rating(41.667, 0.500), Rating(41.667, 0.500))
    t2 = (Rating(42.234, 3.728), Rating(43.291, 3.842))
    rate([t1, t2], [0, 28])


@various_backends(['scipy'])
def test_issue4():
    """The `issue #4`_, opened by @sublee.

    numpy.float64 handles floating-point error by different way. For example,
    it can just warn RuntimeWarning on n/0 problem instead of throwing
    ZeroDivisionError.

    .. _issue #4: https://github.com/sublee/trueskill/issues/4
    """
    import numpy
    r1, r2 = Rating(105.247, 0.439), Rating(27.030, 0.901)
    # make numpy to raise FloatingPointError instead of warning
    # RuntimeWarning
    old_settings = numpy.seterr(divide='raise')
    try:
        rate([(r1,), (r2,)])
    finally:
        numpy.seterr(**old_settings)


@various_backends([None, 'scipy'])
def test_issue5(backend):
    """The `issue #5`_, opened by @warner121.

    This error occurs when a winner has too low rating than a loser. Basically
    Python cannot calculate correct result but mpmath_ can. I added ``backend``
    option to :class:`TrueSkill` class. If it is set to 'mpmath' then the
    problem will have gone.

    The result of TrueSkill calculator by Microsoft is N(-273.092, 2.683) and
    N(-75.830, 2.080), of C# Skills by Moserware is N(NaN, 2.6826) and
    N(NaN, 2.0798). I choose Microsoft's result as an expectation for the test
    suite.

    .. _issue #5: https://github.com/sublee/trueskill/issues/5
    .. _mpmath: http://mpmath.googlecode.com/
    """
    assert _quality_1vs1(Rating(-323.263, 2.965), Rating(-48.441, 2.190)) == 0
    with raises(FloatingPointError):
        rate_1vs1(Rating(-323.263, 2.965), Rating(-48.441, 2.190))
    assert _quality_1vs1(Rating(), Rating(1000)) == 0
    with raises(FloatingPointError):
        rate_1vs1(Rating(), Rating(1000))


@various_backends(['mpmath'])
def test_issue5_with_mpmath():
    _rate_1vs1 = almost.wrap(rate_1vs1, 0)
    assert _quality_1vs1(Rating(-323.263, 2.965), Rating(-48.441, 2.190)) == 0
    assert _rate_1vs1(Rating(-323.263, 2.965), Rating(-48.441, 2.190)) == \
        [(-273.361, 2.683), (-75.683, 2.080)]
    assert _quality_1vs1(Rating(), Rating(1000)) == 0
    assert _rate_1vs1(Rating(), Rating(1000)) == \
        [(415.298, 6.455), (609.702, 6.455)]


@various_backends(['mpmath'])
def test_issue5_with_more_extreme():
    """If the input is more extreme, 'mpmath' backend also made an exception.
    But we can avoid the problem with higher precision.
    """
    import mpmath
    try:
        dps = mpmath.mp.dps
        with raises(FloatingPointError):
            rate_1vs1(Rating(), Rating(1000000))
        mpmath.mp.dps = 50
        assert almost(rate_1vs1(Rating(), Rating(1000000)), prec=-1) == \
            [(400016.896, 6.455), (600008.104, 6.455)]
        with raises(FloatingPointError):
            rate_1vs1(Rating(), Rating(1000000000000))
        mpmath.mp.dps = 100
        assert almost(rate_1vs1(Rating(), Rating(1000000000000)), prec=-7) == \
            [(400001600117.693, 6.455), (599998399907.307, 6.455)]
    finally:
        mpmath.mp.dps = dps

########NEW FILE########
