This archive contains the standard Python documentation in GNU info
format.  Five manuals are included:

    python-ref.info*	Python Reference Manual
    python-mac.info*	Python Macintosh Modules
    python-lib.info*	Python Library Reference
    python-ext.info*	Extending and Embedding the Python Interpreter
    python-api.info*	Python/C API Reference
    python-tut.info*	Python Tutorial

The file python.dir is a fragment of a "dir" file that can be used to
incorporate these documents into an existing GNU info installation:
insert the contents of this file into the "dir" or "localdir" file at
an appropriate point and copy the python-*.info* files to the same
directory.

Thanks go to Milan Zamazal <pdm@freesoft.cz> for providing this
conversion to the info format.

Questions and comments on these documents should be directed to
python-docs@python.org.

These scripts and Makefile fragment are used to convert the Python
documentation in LaTeX format to XML.

This material is preliminary and incomplete.  Python 2.0 is required.

To convert all documents to XML:

	cd Doc/
	make -f tools/sgmlconv/Makefile

To convert one document to XML:

	cd Doc/<document-dir>
	make -f ../tools/sgmlconv/make.rules TOOLSDIR=../tools

Please send comments and bug reports to python-docs@python.org.


What do the tools do?
---------------------

latex2esis.py
    Reads in a conversion specification written in XML
    (conversion.xml), reads a LaTeX document fragment, and interprets
    the markup according to the specification.  The output is a stream
    of ESIS events like those created by the nsgmls SGML parser, but
    is *not* guaranteed to represent a single tree!  This is done to
    allow conversion per entity rather than per document.  Since many
    of the LaTeX files for the Python documentation contain two
    sections on closely related modules, it is important to allow both
    of the resulting <section> elements to exist in the same output
    stream.  Additionally, since comments are not supported in ESIS,
    comments are converted to <COMMENT> elements, which might exist at
    the same level as the top-level content elements.

    The output of latex2esis.py gets saved as <filename>.esis1.

docfixer.py
    This is the really painful part of the conversion.  Well, it's the 
    second really painful part, but more of the pain is specific to
    the structure of the Python documentation and desired output
    rather than to the parsing of LaTeX markup.

    This script loads the ESIS data created by latex2esis.py into a
    DOM document *fragment* (remember, the latex2esis.py output may
    not be well-formed).  Once loaded, it walks over the tree many
    times looking for a variety of possible specific
    micro-conversions.  Most of the code is not in any way "general".
    After processing the fragment, a new ESIS data stream is written
    out.  Like the input, it may not represent a well-formed
    document, but does represent a parsed entity.

    The output of docfixer.py is what gets saved in <filename>.esis.

esis2sgml.py
    Reads an ESIS stream and convert to SGML or XML.  This also
    converts <COMMENT> elements to real comments.  This works quickly
    because there's not much to actually do.

I've finally gotten around to writing some examples :-)

They aren't many, but at least it's something. If you write any, feel free to
send them to me and I will add themn.


certgen.py - Certificate generation module
==========================================

Example module with three functions:
  createKeyPair     - Create a public/private key pair
  createCertRequest - Create a certificate request
  createCertificate - Create a certificate given a cert request
In fact, I created the certificates and keys in the 'simple' directory with
the script mk_simple_certs.py


simple - Simple client/server example
=====================================

Start the server with
    python server.py PORT
and start clients with
    python client.py HOST PORT

The server is a simple echo server, anything a client sends, it sends back.


proxy.py - Example of an SSL-enabled proxy
==========================================

The proxy example demonstrate how to use set_connect_state to start
talking SSL over an already connected socket.

Usage: python proxy.py server[:port] proxy[:port]

Contributed by Mihai Ibanescu


SecureXMLRPCServer.py - SSL-enabled version of SimpleXMLRPCServer
=================================================================

This acts exactly like SimpleXMLRPCServer from the standard python library,
but uses secure connections. The technique and classes should work for any
SocketServer style server. However, the code has not been extensively tested.

Contributed by Michal Wallace


To use this example, first generate keys and certificates for both the
client and the server.  You can do this with the script in the directory
above this one, mk_simple_certs.py.

This directory contains client and server examples for the "Server Name
Indication" (SNI) feature.

Run server.py with no arguments.  It will accept one client connection and
then exit.  It has two certificates it can use, one for "example.invalid"
and another for "another.invalid".  If a client indicates one of these names
to it, it will use the corresponding certificate for that connection (if a
client doesn't indicate a name or indicates another name, it won't try to
use any certificate).

Run client.py with one argument, the server name to indicate.  For example:

  $ python client.py example.invalid
  Connecting... connected ('127.0.0.1', 8443)
  Server subject is <X509Name object '/OU=Security/O=pyOpenSSL/CN=example.invalid/ST=New York/C=US/emailAddress=invalid@example.invalid/L=New York'>
  $

Depending on what hostname is supplied, the server will select a different
certificate to use and the client output will be different.


pyOpenSSL - A Python wrapper around the OpenSSL library
------------------------------------------------------------------------------

See the file INSTALL for installation instructions.

I appreciate bug reports and patches.  Please visit
<http://bugs.launchpad.net/pyopenssl>.

Frankencert - Adversarial Testing of Certificate Validation in SSL/TLS Implementations
=======================================================================================

###What are frankencerts?
Frankencerts are specially crafted SSL certificates for testing certificate 
validation code in SSL/TLS implementations. The technique is described in 
detail in the 2014 IEEE Symposium on Security and Privacy (Oakland) paper -
*Using Frankencerts for Automated Adversarial Testing of Certificate Validation 
in SSL/TLS Implementations* by Chad Brubaker, Suman Jana, Baishakhi Ray, 
Sarfraz Khurshid, and Vitaly Shmatikov. 


###Why is frankencert generator useful?
Frankencert generator is essentially a smart fuzzer for testing SSL/TLS 
certificate validation code. If you are a developer who is implementing 
any sort of SSL/TLS certificate validation code (either as part of an SSL/TLS 
library or an application), you can use the frankencert generator to 
auto-generate different test certificates involving complex corner cases. 

We have successfully used frankencerts to find serious vulnerabilities 
in GnuTLS, PolarSSL, CyaSSL, and MatrixSSL as described in our Oakland 
2014 paper. We also found several discrepancies between how different 
SSL/TLS implementations report errors back to the user. For example, 
when presented with an expired, self-signed certificate, NSS, Chrome on 
Linux, and Safari report that the certificate has expired but not that 
the issuer is invalid.


###How do frankencerts work?
The basic idea of frankencerts is to take a bunch of certificates as seeds 
and use random mutations on different fields and extensions to create new 
test certificates (frankencerts). Using frankencerts as server-side inputs 
into an SSL/TLS handshake can help systematically test correctness of the 
certificate validation code.

###Installation and Usage
- Install OpenSSL libraries and utilities if you don't have them already.

- The frankencert generator needs a modified version of PyOpenSSL. 
   We have included the source for our modified version of PyOpenSSL. 
   You will need to install it in order to use the frankencert generator. 
   First, uninstall any other version of PyOpenSSL that you may have 
   installed on your computer. Go to the `pyOpenSSL-0.13` directory and 
   build/install PyOpenSSL by issuing `sudo python setup.py install`.

- Once you have the patched pyOpenSSL set up, to generate frankencerts, 
   use the `franken_generate.py` script: `python franken_generate.py 
   seed_certs_dir ca_cert output_dir count [config_file]`.

   The arguments are explained below.

    - `seed_certs_dir`: Frankencert generator needs a set of seed certificates. 
       Any SSL cert in PEM fromat can act as a seed cert. `seed_certs_dir`
       can be any directory containing the seed certs stored as PEM files.
   
       You can either use tools like ZMap (https://zmap.io/) to collect SSL seed 
       certificates, or use some of the SSL certs available from https://www.eff.org/observatory.
       Please note that these are not our tools and repositories - you may want
       to contact their respective developers and maintainers to ensure that your
       usage of the certificates they collected is compatible with the intended purpose.
       You do not need access to the corresponding private keys to use the certs 
       as seeds. 
   
       For your convenience, we have included a tarball containing around 1000 seed 
       certificates in `utils/sample_seed_certs.tar.gz`. 

    - `ca_cert`: You will also need to create a self-signed CA certificate to sign 
       the frankencerts. You can either use the included sample CA certificate 
       `utils/rootCA_key_cert.pem` or use the `utils/create_new_ca.sh` script to 
       create your own root CA. For any root CA that you use for frankencert 
       generation, make sure that your SSL certificate validation code treats 
       its certificate as a trusted root certificate.
       
       VERY IMPORTANT: this root certificate should be trusted ONLY during testing.
       If you accidentally or intentionally deploy SSL/TLS with this certificate still 
       among the trusted root certificates, your SSL/TLS connections may be vulnerable 
       to server impersonation and man-in-the-middle attacks. Be sure to REMOVE this 
       certificate from your trusted root certificates once the testing is finished.

    - `output_dir`: It will contain the generated frankencerts. The frankencerts 
       will be named as `frankencert-<number>.pem`. 

    - `count`: Number of frankencerts to be generated. 

    - `config_file`: An optional argument to tune the frankencert generation process.
      Take a look at the `utils/sample_franken.conf` for a sample config file.

- To test your SSL/TLS client with the generated frankencerts, you should use 
  the `utils/test_ssl_server.py` script to set up an SSL server that can present 
  the generated frankencerts as part of the SSL handshake. 

- If you want to perform differential testing (i.e. compare your SSL/TLS client's 
  behavior with other libraries' behaviors for a given franekencert), you can do 
  so by running SSL clients using those libraries and connecting to a server serving 
  the frankencert. The following example shows how to do this for OpenSSL.
    - Start a SSL server serving the target frankencert using: `./test_ssl_server.py frankencert_name port_no`,
      where `frankencert_name` is the path of the target frankencert and `port_no` is the port the server
      will listen to.
    - Use the command `openssl s_client -CAfile ca_cert -connect host_name:port_no`  to connect to 
      the server and check the certificate verification result printed on the console. The `ca_cert` argument 
      should be the CA certificate you used to generate the frankencert, `port_no` should be the same one that 
      you used for running `test_ssl_server`, and `host_name` should be either localhost or the name of 
      the host running the `test_ssl_server` script. 
  
  NOTE: We plan to make the automated scripts that we used for differential testing available soon. 

### Project structure
 - The `frankengen` directory contains the frankencert generator code
 - Our patched version of pyOpenSSL is inside `pyOpenSSL-0.13` directory
 - Several useful tools are included in `utils`
    - `cert_print.py`: a tool for printing frankencerts. It requires OpenSSL
      to be installed and present in the path.
    - `rootCA_key_cert.pem`: private key and self-signed cert of a sample CA
      that can be used for signing frankencerts.
    - `create_new_ca.sh`: a script for creating new CA with a self-signed cert.
      It creates the output cert and private key in `rootCA.pem` (requires OpenSSL). 
    - `test_ssl_server.py`: a sample SSL/TLS server for presenting frankencerts 
      to SSL/TLS clients
    - `sample_seed_certs.tar.gz`: Some sample certs that may be used as seeds for 
      frankencert generation. 
    - `sample_franken.conf`: A sample config file that can be used to tune 
      different parameters of the frankencert generation process. 


