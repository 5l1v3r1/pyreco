__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# validictory documentation build configuration file, created by
# sphinx-quickstart on Wed Mar  9 12:09:00 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'validictory'
copyright = u'2013, James Turk'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.9'
# The full version, including alpha/beta/rc tags.
release = '0.9.3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'validictorydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'validictory.tex', u'validictory Documentation',
   u'James Turk', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'validictory', u'validictory Documentation',
     [u'James Turk'], 1)
]

########NEW FILE########
__FILENAME__ = test_apply_default
from unittest import TestCase

import validictory


def validate_with_apply_default_to_data(data, schema):
    return validictory.validate(
        data,
        schema,
        required_by_default=False,
        apply_default_to_data=True
    )


class TestItemDefaults(TestCase):
    """ recognize a "default" keyword in a schema as a fallback for
    missing properties as described in
    http://json-schema.org/latest/json-schema-validation.html#anchor101
    """

    def test_property_default_is_applied(self):
        schema = {
            "type": "object",
            "properties": {
                "foo": {
                    "default": "bar"
                },
                "baz": {
                    "type": "integer"
                }
            }
        }

        data = {'baz': 2}

        validate_with_apply_default_to_data(data, schema)

        # Note: data was changed!
        self.assertEqual(data, {"foo": "bar", "baz": 2})

    def test_property_default_denied_if_wrong_type_for_default(self):
        schema = {
            "type": "object",
            "properties": {
                "foo": {
                    "type": "integer",
                    "default": "bar"
                }
            }
        }

        data = {}

        # from specification:
        # "There are no restrictions placed on the value of this keyword."
        # "It is RECOMMENDED that a default value be
        # valid against the associated schema."
        self.assertRaises(
            validictory.SchemaError,
            validate_with_apply_default_to_data,
            data,
            schema
        )

        # the original data is unchanged
        self.assertEqual(data, {})

    def test_property_default_with_wrong_default_raises_error_if_unused(self):
        schema = {
            "type": "object",
            "properties": {
                "foo": {
                    "type": "integer",
                    "default": "bar"
                }
            }
        }

        data = {'foo': 1}

        # The SchemaError is still raised because the schema is still wrong
        # even if the property is contained in the data
        self.assertRaises(
            validictory.SchemaError,
            validate_with_apply_default_to_data,
            data,
            schema
        )

        # the original data is unchanged
        self.assertEqual(data, {'foo': 1})

########NEW FILE########
__FILENAME__ = test_disallow_unknown_properties
from unittest import TestCase

import validictory


class TestDisallowUnknownProperties(TestCase):

    def setUp(self):
        self.data_simple = {"name": "john doe", "age": 42}
        self.schema_simple = {
            "type": "object",
            "properties": {
                "name": {"type": "string"},
                "age": {"type": "integer"}
            },
        }

        self.data_complex = {
            "inv_number": "123",
            "rows": [
                {
                    "sku": "ab-456",
                    "desc": "a description",
                    "price": 100.45
                },
                {
                    "sku": "xy-123",
                    "desc": "another description",
                    "price": 999.00
                }
            ]
        }
        self.schema_complex = {
            "type": "object",
            "properties": {
                "inv_number": {"type": "string"},
                "rows": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "sku": {"type": "string"},
                            "desc": {"type": "string"},
                            "price": {"type": "number"}
                        }
                    },
                }
            }
        }

    def test_disallow_unknown_properties_pass(self):
        try:
            validictory.validate(self.data_simple, self.schema_simple,
                                 disallow_unknown_properties=True)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_disallow_unknown_properties_fail(self):
        self.data_simple["sex"] = "male"
        self.assertRaises(validictory.SchemaError, validictory.validate,
                          self.data_simple, self.schema_simple,
                          disallow_unknown_properties=True)

    def test_disallow_unknown_properties_complex_pass(self):
        try:
            validictory.validate(self.data_complex, self.schema_complex,
                                 disallow_unknown_properties=True)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_disallow_unknown_properties_complex_fail(self):
        newrow = {"sku": "789", "desc": "catch me if you can", "price": 1,
                  "rice": 666}
        self.data_complex["rows"].append(newrow)
        self.assertRaises(validictory.SchemaError, validictory.validate,
                          self.data_complex, self.schema_complex,
                          disallow_unknown_properties=True)

########NEW FILE########
__FILENAME__ = test_fail_fast
from unittest import TestCase

import validictory


class TestFailFast(TestCase):

    def test_multi_error(self):
        schema = {
            "type": "object",
            "properties": {
                "name": {"type": "string"},
                "age": {"type": "integer"}
            },
        }
        data = {"name": 2, "age": "fourty-two"}

        # ensure it raises an error
        self.assertRaises(validictory.ValidationError, validictory.validate,
                          data, schema, fail_fast=True)

        # ensure it raises a MultiError
        self.assertRaises(validictory.MultipleValidationError, validictory.validate,
                          data, schema, fail_fast=False)

        # ensure that the MultiError has 2 errors
        try:
            validictory.validate(data, schema, fail_fast=False)
        except validictory.MultipleValidationError as mve:
            assert len(mve.errors) == 2

    def test_multi_error_in_list(self):
        schema = {
            "type": "object",
            "properties": {
                "words": {"type": "array", "items": {"type": "string"}},
            },
        }
        data = {"words": ["word", 32, 2.1, True]}

        # ensure it raises an error
        self.assertRaises(validictory.ValidationError, validictory.validate,
                          data, schema, fail_fast=True)

        # ensure it raises a MultiError
        self.assertRaises(validictory.MultipleValidationError, validictory.validate,
                          data, schema, fail_fast=False)

        # ensure that the MultiError has 3 errors since 3 of the items were bad
        try:
            validictory.validate(data, schema, fail_fast=False)
        except validictory.MultipleValidationError as mve:
            assert len(mve.errors) == 3

    def test_multi_error_with_format(self):
        schema = {
            "type": "object",
            "properties": {
                "date": {"type": "string", "format": "date"},
                "time": {"type": "string", "format": "time"}
            },
        }
        data = {"date": "2011-02-99", "time": "30:00:00"}

        # ensure it raises an error
        self.assertRaises(validictory.ValidationError, validictory.validate,
                          data, schema, fail_fast=True)

        # ensure it raises a MultiError
        self.assertRaises(validictory.MultipleValidationError, validictory.validate,
                          data, schema, fail_fast=False)

        # ensure that the MultiError has 2 errors
        try:
            validictory.validate(data, schema, fail_fast=False)
        except validictory.MultipleValidationError as mve:
            assert len(mve.errors) == 2

########NEW FILE########
__FILENAME__ = test_items
from unittest import TestCase
import pytest

import validictory


class TestItems(TestCase):
    schema1 = {
        "type": "array",
        "items": {"type": "string"}
    }

    schema2 = {
        "type": "array",
        "items": [{"type": "integer"}, {"type": "string"}, {"type": "boolean"}]
    }

    schema3 = {
        "type": "array",
        "items": ({"type": "integer"}, {"type": "string"}, {"type": "boolean"})
    }

    def test_items_single_pass(self):
        data = ["string", "another string", "mystring"]
        data2 = ["JSON Schema is cool", "yet another string"]

        try:
            validictory.validate(data, self.schema1)
            validictory.validate(data2, self.schema1)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_items_single_fail(self):
        data = ["string", "another string", 1]
        self.assertRaises(ValueError, validictory.validate, data, self.schema1)

    def test_items_multiple_pass(self):
        data = [1, "More strings?", True]
        data2 = [12482, "Yes, more strings", False]

        try:
            validictory.validate(data, self.schema2)
            validictory.validate(data2, self.schema2)
            validictory.validate(tuple(data), self.schema3)
            validictory.validate(tuple(data2), self.schema3)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_items_multiple_fail(self):
        data = [1294, "Ok. I give up"]
        data2 = [1294, "Ok. I give up", "Not a boolean"]
        self.assertRaises(ValueError, validictory.validate, data, self.schema2)
        self.assertRaises(ValueError, validictory.validate, data2,
                          self.schema2)

    def test_items_descriptive_fail(self):
        data = [1294]
        try:
            validictory.validate(data, self.schema1)
        except ValueError as e:
            # warning should mention list item, not _data
            assert 'list item' in str(e)


class TestAdditionalItems(TestCase):

    schema1 = {
        "type": "array",
        "items": [{"type": "integer"}, {"type": "string"},
                  {"type": "boolean"}],
        "additionalItems": False
    }

    schema2 = {
        "type": "array",
        "items": [{"type": "integer"}, {"type": "string"},
                  {"type": "boolean"}],
        "additionalItems": True
    }

    schema3 = {
        "type": "array",
        "items": [{"type": "integer"}, {"type": "string"},
                  {"type": "boolean"}],
        "additionalItems": {"type": "number"}
    }

    schema4 = {
        "type": "array",
        "items": [{"type": "integer"}, {"type": "string"},
                  {"type": "boolean"}],
        "additionalItems": {"type": ["number", "boolean"]}
    }

    def test_additionalItems_false_no_additional_items_pass(self):
        data = [12482, "Yes, more strings", False]

        try:
            validictory.validate(data, self.schema1)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_additionalItems_false_additional_items_fail(self):
        data = [12482, "Yes, more strings", False, "I don't belong here"]
        pytest.raises(ValueError, validictory.validate, data, self.schema1)

    def test_additionalItems_pass(self):
        data = [12482, "Yes, more strings", False, ["I'm"],
                {"also": "allowed!"}]
        try:
            validictory.validate(data, self.schema2)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_additionalItems_schema_pass(self):
        data = [12482, "Yes, more strings", False, 13.37, 47.11]
        try:
            validictory.validate(data, self.schema3)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_additionalItems_schema_fail(self):
        data = [12482, "Yes, more strings", False, 13.37, "I'm not allowed"]
        self.assertRaises(ValueError, validictory.validate, data, self.schema3)

    def test_additionalItems_multischema_pass(self):
        data = [12482, "Yes, more strings", False, 13.37, 47.11, True, False]
        try:
            validictory.validate(data, self.schema4)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_additionalItems_multischema_fail(self):
        data = [12482, "Yes, more strings", False, 13.37, True, "I'm not allowed"]
        pytest.raises(ValueError, validictory.validate, data, self.schema4)

########NEW FILE########
__FILENAME__ = test_other
from unittest import TestCase

import validictory


class TestSchemaErrors(TestCase):

    def setUp(self):
        self.valid_desc = {"description": "My Description for My Schema"}
        self.invalid_desc = {"description": 1233}
        self.valid_title = {"title": "My Title for My Schema"}
        self.invalid_title = {"title": 1233}
        # doesn't matter what this is
        self.data = "whatever"

    def test_description_pass(self):
        try:
            validictory.validate(self.data, self.valid_desc)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_description_fail(self):
        self.assertRaises(ValueError, validictory.validate, self.data,
                          self.invalid_desc)

    def test_title_pass(self):
        try:
            validictory.validate(self.data, self.valid_title)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_title_fail(self):
        self.assertRaises(ValueError, validictory.validate, self.data,
                          self.invalid_title)

    def test_invalid_type(self):
        expected = "Type for field 'bar' must be 'dict', got: 'str'"
        data = {'bar': False}
        schema = {"type": "object", "required": True,
                  "properties": {"bar": "foo"}}
        try:
            validictory.validate(data, schema)
            result = None
        except Exception as e:
            result = e.__str__()
        self.assertEqual(expected, result)


class TestFieldValidationErrors(TestCase):
    def setUp(self):
        self.schema = {"type": "object", "required": True,
                       "properties": {"bar": {"type": "integer"}}}

        self.data = {"bar": "faz"}

    def test(self):
        try:
            validictory.validate(self.data, self.schema)
        except validictory.FieldValidationError as e:
            self.assertEqual(e.fieldname, "bar")
            self.assertEqual(e.value, "faz")
        else:
            self.fail("No Exception")

########NEW FILE########
__FILENAME__ = test_properties
from unittest import TestCase

import validictory


class TestProperties(TestCase):
    props = {
        "prop01": {"type": "string"},
        "prop02": {"type": "number", "required": False},
        "prop03": {"type": "integer"},
        "prop04": {"type": "boolean"},
        "prop05": {
            "type": "object",
            "required": False,
            "properties": {
                "subprop01": {"type": "string"},
                "subprop02": {"type": "string", "required": True}
            }
        }
    }
    schema = {"type": "object", "properties": props}

    def test_properties1(self):

        data = {
            "prop01": "test",
            "prop02": 1.20,
            "prop03": 1,
            "prop04": True,
            "prop05": {
                "subprop01": "test",
                "subprop02": "test2",
            }
        }

        try:
            validictory.validate(data, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_properties2(self):

        data = {
            "prop01": "test",
            "prop02": 1.20,
            "prop03": 1,
            "prop04": True
        }

        try:
            validictory.validate(data, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_properties3(self):
        data = {
            "prop02": 1.60,
            "prop05": {
                "subprop01": "test"
            }
        }

        self.assertRaises(ValueError, validictory.validate, data, self.schema)


class TestPatternProperties(TestCase):
    schema = {'patternProperties': {'[abc]': {'type': 'boolean'}}}

    def test_patternproperties_pass(self):
        data = {'a': True}

        try:
            validictory.validate(data, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_patternproperties_nonmatch(self):
        data = {'a': True, 'd': 'foo'}

        try:
            validictory.validate(data, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_patternproperties_nested(self):
        schema = {'patternProperties': {'[abc]': {
            'patternProperties': {'[abc]': {'type': 'boolean'}}
        }}}

        data = {'a': {'b': False}}

        try:
            validictory.validate(data, schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_patternproperties_fail_multiple(self):
        data = {'a': True, 'b': False, 'c': 'foo'}
        self.assertRaises(ValueError, validictory.validate, data, self.schema)

    def test_patternproperties_fail(self):
        data = {'a': 12}
        self.assertRaises(ValueError, validictory.validate, data, self.schema)

    def test_patternproperties_missing(self):
        schema = {'properties': {'patprops': {
            'required': False, 'type': 'object',
            'patternProperties': {'[abc]': {'required': True,
                                            'type': 'array'}}
        }}}
        data = {'id': 1}
        try:
            validictory.validate(data, schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)


class TestAdditionalProperties(TestCase):
    def test_no_properties(self):
        schema = {"additionalProperties": {"type": "integer"}}

        for x in [1, 89, 48, 32, 49, 42]:
            try:
                data = {"prop": x}
                validictory.validate(data, schema)
            except ValueError as e:
                self.fail("Unexpected failure: %s" % e)

        # failures
        for x in [1.2, "bad", {"test": "blah"}, [32, 49], None, True]:
            self.assertRaises(ValueError, validictory.validate, {"prop": x},
                              schema)

    def test_with_properties(self):
        schema = {
            "properties": {
                "prop1": {"type": "integer"},
                "prop2": {"type": "string"}
            },
            "additionalProperties": {"type": ["string", "number"]}
        }

        for x in [1, "test", 48, "ok", 4.9, 42]:
            try:
                data = {
                    "prop1": 123,
                    "prop2": "this is prop2",
                    "prop3": x
                }
                validictory.validate(data, schema)
            except ValueError as e:
                self.fail("Unexpected failure: %s" % e)

        # failures
        for x in [{"test": "blah"}, [32, 49], None, True]:
            data = {
                "prop1": 123,
                "prop2": "this is prop2",
                "prop3": x
            }
            self.assertRaises(ValueError, validictory.validate, data, schema)

    def test_with_pattern_properties(self):
        schema = {
            "patternProperties": {
                "[a-c]": {
                    "type": "string"}
            }, "additionalProperties": False,
        }
        data = {"a": "test"}

        try:
            validictory.validate(data, schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

        # failures
        data = {"d": "test"}
        self.assertRaises(ValueError, validictory.validate, data, schema)

        data = {"a": "test", "d": "test"}
        self.assertRaises(ValueError, validictory.validate, data, schema)

    def test_true(self):
        schema = {"additionalProperties": True}

        for x in [1.2, 1, {"test": "blah"}, [32, 49], None, True, "blah"]:
            try:
                validictory.validate({"prop": x}, schema)
            except ValueError as e:
                self.fail("Unexpected failure: %s" % e)

    def test_false(self):
        schema = {"additionalProperties": False}

        for x in ["bad", {"test": "blah"}, [32.42, 494242], None, True, 1.34]:
            self.assertRaises(ValueError, validictory.validate, {"prop": x},
                              schema)

    def test_false_with_type_string(self):
        schema = {
            "type": ["object", "string"],
            "properties": {
                "key": {"type": "string"}
            },
            "additionalProperties": False
        }

        for data in ["foobar", {'key': 'value'}]:
            try:
                validictory.validate(data, schema)
            except ValueError as e:
                self.fail("Unexpected failure: %s" % e)

        # failures
        for data in [['foo', 'bar'], None, True, {'roses': 'red'}]:
            self.assertRaises(ValueError, validictory.validate, data, schema)


class TestDependencies(TestCase):
    props = {
        "prop01": {"type": "string", "required": False},
        "prop02": {"type": "number", "required": False,
                   "dependencies": "prop01"}
    }
    schema = {"type": "object", "properties": props}

    props_array = {
        "prop01": {"type": "string", "required": False},
        "prop02": {"type": "string", "required": False},
        "prop03": {"type": "number", "required": False,
                   "dependencies": ["prop01", "prop02"]}
    }
    schema_array = {"type": "object", "properties": props_array}

    def test_dependencies_pass(self):
        data1 = {}
        data2 = {"prop01": "test"}
        data3 = {"prop01": "test", "prop02": 2}
        data4 = {"prop01": "a", "prop02": "b", "prop03": 7}

        try:
            validictory.validate(data1, self.schema)
            validictory.validate(data2, self.schema)
            validictory.validate(data3, self.schema)
            validictory.validate(data4, self.schema_array)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_dependencies_fail(self):
        data1 = {"prop02": 2}
        data2 = {"prop01": "x", "prop03": 7}

        self.assertRaises(ValueError, validictory.validate, data1, self.schema)
        self.assertRaises(ValueError, validictory.validate, data2,
                          self.schema_array)


class TestRequired(TestCase):
    props = {
        "prop_def": {"type": "string"},
        "prop_opt": {"type": "number", "required": False},
        "prop_req": {"type": "boolean", "required": True}
    }
    schema = {"type": "object", "properties": props}

    def_and_req = {"prop_def": "test", "prop_req": False}
    req_only = {"prop_req": True}
    opt_only = {"prop_opt": 7}

    def test_required_pass(self):
        try:
            # should pass if def and req are there
            validictory.validate(self.def_and_req, self.schema)
            # should pass if default is missing but req_by_default=False
            validictory.validate(self.req_only, self.schema,
                                 required_by_default=False)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_required_fail(self):
        # missing required should always fail
        self.assertRaises(ValueError, validictory.validate, self.opt_only,
                          self.schema)
        self.assertRaises(ValueError, validictory.validate, self.opt_only,
                          self.schema, required_by_default=False)
        # missing the default, fail if required_by_default=True
        self.assertRaises(ValueError, validictory.validate, self.req_only,
                          self.schema)

########NEW FILE########
__FILENAME__ = test_schema_schema
from unittest import TestCase

import validictory

schema = {
    "$schema": "http://json-schema.org/draft-03/schema#",
    "id": "http://json-schema.org/draft-03/schema#",
    "type": "object",

    "properties": {
        "type": {
            "type": ["string", "array"],
            "items": {
                "type": ["string", {"$ref": "#"}]
            },
            "uniqueItems": True,
            "default": "any"
        },

        "properties": {
            "type": "object",
            "additionalProperties": {"$ref": "#"},
            "default": {}
        },

        "patternProperties": {
            "type": "object",
            "additionalProperties": {"$ref": "#"},
            "default": {}
        },

        "additionalProperties": {
            "type": [{"$ref": "#"}, "boolean"],
            "default": {}
        },

        "items": {
            "type": [{"$ref": "#"}, "array"],
            "items": {"$ref": "#"},
            "default": {}
        },

        "additionalItems": {
            "type": [{"$ref": "#"}, "boolean"],
            "default": {}
        },

        "required": {
            "type": "boolean",
            "default": False
        },

        "dependencies": {
            "type": "object",
            "additionalProperties": {
                "type": ["string", "array", {"$ref": "#"}],
                "items": {
                    "type": "string"
                }
            },
            "default": {}
        },

        "minimum": {
            "type": "number"
        },

        "maximum": {
            "type": "number"
        },

        "exclusiveMinimum": {
            "type": "boolean",
            "default": False
        },

        "exclusiveMaximum": {
            "type": "boolean",
            "default": False
        },

        "minItems": {
            "type": "integer",
            "minimum": 0,
            "default": 0
        },

        "maxItems": {
            "type": "integer",
            "minimum": 0
        },

        "uniqueItems": {
            "type": "boolean",
            "default": False
        },

        "pattern": {
            "type": "string",
            "format": "regex"
        },

        "minLength": {
            "type": "integer",
            "minimum": 0,
            "default": 0
        },

        "maxLength": {
            "type": "integer"
        },

        "enum": {
            "type": "array",
            "minItems": 1,
            "uniqueItems": True
        },

        "default": {
            "type": "any"
        },

        "title": {
            "type": "string"
        },

        "description": {
            "type": "string"
        },

        "format": {
            "type": "string"
        },

        "divisibleBy": {
            "type": "number",
            "minimum": 0,
            "exclusiveMinimum": True,
            "default": 1
        },

        "disallow": {
            "type": ["string", "array"],
            "items": {
                "type": ["string", {"$ref": "#"}]
            },
            "uniqueItems": True
        },

        "extends": {
            "type": [{"$ref": "#"}, "array"],
            "items": {"$ref": "#"},
            "default": {}
        },

        "id": {
            "type": "string",
            "format": "uri"
        },

        "$ref": {
            "type": "string",
            "format": "uri"
        },

        "$schema": {
            "type": "string",
            "format": "uri"
        }
    },

    "dependencies": {
        "exclusiveMinimum": "minimum",
        "exclusiveMaximum": "maximum"
    },

    "default": {}
}


class TestSchemaSchema(TestCase):

    def test_schema(self):
        validictory.validate(schema, schema, required_by_default=False)

########NEW FILE########
__FILENAME__ = test_type
from unittest import TestCase
from decimal import Decimal
import datetime
import sys

if sys.version_info[0] == 3:
    unicode_str = '\u2603'
else:
    unicode_str = unicode('snowman')


import validictory


class TestType(TestCase):
    def test_schema(self):
        schema = {
            "type": [
                {"type": "array", "minItems": 10},
                {"type": "string", "pattern": "^0+$"}
            ]
        }

        data1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        data2 = "0"
        data3 = 1203

        for x in [data1, data2]:
            try:
                validictory.validate(x, schema)
            except ValueError as e:
                self.fail("Unexpected failure: %s" % e)

        self.assertRaises(ValueError, validictory.validate, data3, schema)

    def _test_type(self, typename, valids, invalids):
        for x in valids:
            try:
                validictory.validate(x, {"type": typename})
            except ValueError as e:
                self.fail("Unexpected failure: %s" % e)

        for x in invalids:
            self.assertRaises(ValueError, validictory.validate, x,
                              {"type": typename})

    def test_integer(self):
        valid_ints = [1, -89, 420000]
        invalid_ints = [1.2, "bad", {"test": "blah"}, [32, 49], None, True]
        self._test_type('integer', valid_ints, invalid_ints)

    def test_string(self):
        valids = ["abc", unicode_str]
        invalids = [1.2, 1, {"test": "blah"}, [32, 49], None, True]
        self._test_type('string', valids, invalids)

    def test_number(self):
        valids = [1.2, -89.42, 48, -32, Decimal('25.25')]
        invalids = ["bad", {"test": "blah"}, [32.42, 494242], None, True]
        self._test_type('number', valids, invalids)

    def test_boolean(self):
        valids = [True, False]
        invalids = [1.2, "False", {"test": "blah"}, [32, 49], None, 1, 0]
        self._test_type('boolean', valids, invalids)

    def test_UserDict_is_object(self):
        # A UserDict (and similar classes) are not dicts, but they're dict-like
        # and should be treated as objects

        try:
            # Python 2
            from UserDict import UserDict
        except ImportError:
            # Python 3
            from collections import UserDict

        valids = [UserDict({"a": "b"})]
        invalids = []
        self._test_type('object', valids, invalids)

    def test_object(self):
        valids = [{"blah": "test"}, {"this": {"blah": "test"}}, {1: 2, 10: 20}]
        invalids = [1.2, "bad", 123, [32, 49], None, True]
        self._test_type('object', valids, invalids)

    def test_array(self):
        valids = [[1, 89], [48, {"test": "blah"}, "49", 42], (47, 11)]
        invalids = [1.2, "bad", {"test": "blah"}, 1234, None, True]
        self._test_type('array', valids, invalids)

    def test_null(self):
        valids = [None]
        invalids = [1.2, "bad", {"test": "blah"}, [32, 49], 1284, True]
        self._test_type('null', valids, invalids)

    def test_any(self):
        valids = [1.2, "bad", {"test": "blah"}, [32, 49], None, 1284, True]
        self._test_type('any', valids, [])

    def test_default(self):
        # test default value (same as any really)
        valids = [1.2, "bad", {"test": "blah"}, [32, 49], None, 1284, True]
        for x in valids:
            try:
                validictory.validate(x, {})
            except ValueError as e:
                self.fail("Unexpected failure: %s" % e)

    def test_multi(self):
        types = ["null", "integer", "string"]
        valids = [None, 42, "string"]
        invalids = [1.2, {"test": "blah"}, [32, 49], True]
        self._test_type(types, valids, invalids)
        self._test_type(tuple(types), valids, invalids)


class TestDisallow(TestType):
    def _test_type(self, typename, valids, invalids):
        for x in invalids:
            try:
                validictory.validate(x, {"disallow": typename})
            except ValueError as e:
                self.fail("Unexpected failure: %s" % e)

        for x in valids:
            self.assertRaises(ValueError, validictory.validate, x,
                              {"disallow": typename})


class DateValidator(validictory.validator.SchemaValidator):

    def validate_type_date(self, value):
        return isinstance(value, datetime.date)

    def validate_type_datetime(self, value):
        return isinstance(value, datetime.datetime)


class TestCustomType(TestCase):
    def test_date(self):
        self._test_type('date', [datetime.date.today()],
                        [2010, '2010'])

    def test_datetime(self):
        self._test_type('datetime', [datetime.datetime.now()],
                        [2010, '2010', datetime.date.today()])

    def test_either(self):
        self._test_type(['datetime', 'date'],
                        [datetime.date.today(), datetime.datetime.now()],
                        [2010, '2010'])

    def _test_type(self, typename, valids, invalids):
        validator = DateValidator()
        for x in valids:
            try:
                validator.validate(x, {"type": typename})
            except ValueError as e:
                self.fail("Unexpected failure: %s" % e)

        for x in invalids:
            self.assertRaises(ValueError, validator.validate, x,
                              {"type": typename})

########NEW FILE########
__FILENAME__ = test_values
"""
    Tests that test the value of individual items
"""

from unittest import TestCase

import validictory


class TestEnum(TestCase):
    schema = {"enum": ["test", True, 123, ["???"]]}
    schema2 = {"enum": ("test", True, 123, ["???"])}

    def test_enum_pass(self):
        data = ["test", True, 123, ["???"]]
        try:
            for item in data:
                validictory.validate(item, self.schema)
                validictory.validate(item, self.schema2)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_enum_fail(self):
        data = "unknown"

        self.assertRaises(ValueError, validictory.validate, data, self.schema)


class TestPattern(TestCase):

    # match simplified regular expression for an e-mail address
    schema = {"pattern":
              "^[A-Za-z0-9][A-Za-z0-9\.]*@([A-Za-z0-9]+\.)+[A-Za-z0-9]+$"}

    def test_pattern_pass(self):
        data = "my.email01@gmail.com"

        try:
            validictory.validate(data, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_pattern_pass_nonstring(self):
        data = 123

        try:
            validictory.validate(data, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_pattern_fail(self):
        data = "whatever"

        self.assertRaises(ValueError, validictory.validate, data, self.schema)


def validate_format_contains_spaces(validator, fieldname, value,
                                    format_option):
    if ' ' in value:
        return

    raise validictory.FieldValidationError(
        "Value %(value)r of field '%(fieldname)s' does not contain any spaces,"
        "but it should" % locals(), fieldname, value)


class TestFormat(TestCase):

    schema_datetime = {"format": "date-time"}
    schema_date = {"format": "date"}
    schema_time = {"format": "time"}
    schema_utcmillisec = {"format": "utc-millisec"}
    schema_ip = {"format": "ip-address"}
    schema_spaces = {"format": "spaces"}

    def test_format_datetime_pass(self):
        data = "2011-01-13T10:56:53Z"

        try:
            validictory.validate(data, self.schema_datetime)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_format_date_pass(self):
        data = "2011-01-13"

        try:
            validictory.validate(data, self.schema_date)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_format_time_pass(self):
        data = "10:56:53"

        try:
            validictory.validate(data, self.schema_time)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_format_utcmillisec_pass(self):
        try:
            validictory.validate(1294915735, self.schema_utcmillisec)
            validictory.validate(1294915735.0, self.schema_utcmillisec)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_format_datetime_nonexisting_day_fail(self):
        data = "2013-13-13T00:00:00Z"

        self.assertRaises(ValueError, validictory.validate, data,
                          self.schema_datetime)

    def test_format_datetime_feb29_fail(self):
        data = "2011-02-29T00:00:00Z"

        self.assertRaises(ValueError, validictory.validate, data,
                          self.schema_datetime)

    def test_format_datetime_notutc_fail(self):
        data = "2011-01-13T10:56:53+01: 00"

        self.assertRaises(ValueError, validictory.validate, data,
                          self.schema_datetime)

    def test_format_datetime_fail(self):
        data = "whatever"
        self.assertRaises(ValueError, validictory.validate, data,
                          self.schema_datetime)

    def test_format_datetime_bad_type(self):
        data = 3
        self.assertRaises(ValueError, validictory.validate, data,
                          self.schema_datetime)

    def test_format_date_fail(self):
        data = "whatever"
        self.assertRaises(ValueError, validictory.validate, data,
                          self.schema_date)

    def test_format_time_fail(self):
        data = "whatever"
        self.assertRaises(ValueError, validictory.validate, data,
                          self.schema_time)

    def test_format_utcmillisec_fail(self):
        data = "whatever"
        self.assertRaises(ValueError, validictory.validate, data,
                          self.schema_utcmillisec)

    def test_format_utcmillisec_negative_fail(self):
        data = -1
        self.assertRaises(ValueError, validictory.validate, data,
                          self.schema_utcmillisec)

    def test_format_ip_pass(self):
        valids = ["0.0.0.0", "255.255.255.255"]
        for ip in valids:
            try:
                validictory.validate(ip, self.schema_ip)
            except ValueError as e:
                self.fail("Unexpected failure: %s" % e)

    def test_format_ip_fail(self):
        invalids = [1.2, "bad", {"test": "blah"}, [32, 49], 1284, True,
                    "-0.-0.-0.-0", "-1.-1.-1.-1", "256.256.256.256"]
        for ip in invalids:
            self.assertRaises(ValueError, validictory.validate, ip,
                              self.schema_ip)

    def test_format_required_false(self):
        schema = {
            'type': 'object',
            'properties': {
                'startdate': {'type': 'string', 'format': 'date-time',
                              'required': False}
            }
        }
        try:
            validictory.validate({}, schema, required_by_default=False)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_format_custom_unregistered_pass(self):
        data = 'No-spaces-here'

        try:
            # no custom validator installed, so no error
            validictory.validate(data, self.schema_spaces)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_format_custom_instantiated_pass(self):
        data = 'Here are spaces'

        validator = validictory.SchemaValidator(
            {'spaces': validate_format_contains_spaces})

        try:
            # validator installed, but data validates
            validator.validate(data, self.schema_spaces)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_format_custom_registered_pass(self):
        data = 'Here are spaces'

        validator = validictory.SchemaValidator()
        validator.register_format_validator('spaces',
                                            validate_format_contains_spaces)

        try:
            # validator registered, but data validates
            validator.validate(data, self.schema_spaces)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_format_custom_registered_fail(self):
        data = 'No-spaces-here'

        validator = validictory.SchemaValidator(
            {'spaces': validate_format_contains_spaces})

        # validator registered, but data does not conform
        self.assertRaises(ValueError, validator.validate, data,
                          self.schema_spaces)


class TestUniqueItems(TestCase):

    schema = {"uniqueItems": True}
    schema_false = {"uniqueItems": False}

    def test_uniqueitems_pass(self):
        data = [1, 2, 3]

        try:
            validictory.validate(data, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_uniqueitems_pass_string(self):
        data = ['1', '2', '3']

        try:
            validictory.validate(data, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_uniqueitems_pass_nested_array(self):
        '''
        uniqueItems only applies for the array it was specified on and not to
        all datastructures nested within.
        '''
        data = [[1, [5, 5]], [2, [5, 5]]]

        try:
            validictory.validate(data, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_uniqueitems_pass_not_an_array(self):
        data = 13  # it's pretty unique

        try:
            validictory.validate(data, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_uniqueitems_pass_different_types(self):
        data = [1, "1"]

        try:
            validictory.validate(data, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_uniqueitems_false_pass(self):
        data = [1, 1, 1]

        try:
            validictory.validate(data, self.schema_false)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_uniqueitems_fail(self):
        data = [1, 1, 1]

        self.assertRaises(ValueError, validictory.validate, data, self.schema)

    def test_uniqueitems_fail_nested_arrays(self):
        data = [[1, 2, 3], [1, 2, 3]]

        self.assertRaises(ValueError, validictory.validate, data, self.schema)

    def test_uniqueitems_fail_nested_objects(self):
        data = [{'one': 1, 'two': 2}, {'one': 1, 'two': 2}]

        self.assertRaises(ValueError, validictory.validate, data, self.schema)

    def test_uniqueitems_fail_null(self):
        data = [None, None]

        self.assertRaises(ValueError, validictory.validate, data, self.schema)


class TestMaximum(TestCase):
    props = {
        "prop01": {"type": "number", "maximum": 10},
        "prop02": {"type": "integer", "maximum": 20}
    }
    props_exclusive = {
        "prop": {"type": "integer", "maximum": 20, "exclusiveMaximum": True},
    }
    schema = {"type": "object", "properties": props}
    schema_exclusive = {"type": "object", "properties": props_exclusive}

    def test_maximum_pass(self):
        # Test less than
        data1 = {"prop01": 5, "prop02": 10}
        # Test equal
        data2 = {"prop01": 10, "prop02": 20}

        try:
            validictory.validate(data1, self.schema)
            validictory.validate(data2, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_maximum_exclusive_pass(self):
        # Test less than
        data = {"prop": 19}

        try:
            validictory.validate(data, self.schema_exclusive)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_maximum_fail(self):
        # Test number
        data1 = {"prop01": 11, "prop02": 19}
        # Test integer
        data2 = {"prop01": 9, "prop02": 21}

        self.assertRaises(ValueError, validictory.validate, data1, self.schema)
        self.assertRaises(ValueError, validictory.validate, data2, self.schema)

    def test_maximum_exclusive_fail(self):
        # Test equal
        data = {"prop": 20}

        self.assertRaises(ValueError, validictory.validate, data,
                          self.schema_exclusive)


class TestMinimum(TestCase):
    props = {
        "prop01": {"type": "number", "minimum": 10},
        "prop02": {"type": "integer", "minimum": 20}
    }
    props_exclusive = {
        "prop": {"type": "integer", "minimum": 20, "exclusiveMinimum": True},
    }
    schema = {"type": "object", "properties": props}
    schema_exclusive = {"type": "object", "properties": props_exclusive}

    def test_minimum_pass(self):
        # Test greater than
        data1 = {"prop01": 21, "prop02": 21}
        # Test equal
        data2 = {"prop01": 10, "prop02": 20}

        try:
            validictory.validate(data1, self.schema)
            validictory.validate(data2, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_minimum_exclusive_pass(self):
        # Test greater than
        data = {"prop": 21}

        try:
            validictory.validate(data, self.schema_exclusive)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_minimum_fail(self):
        # Test number
        data1 = {"prop01": 9, "prop02": 21}
        # Test integer
        data2 = {"prop01": 10, "prop02": 19}

        self.assertRaises(ValueError, validictory.validate, data1, self.schema)
        self.assertRaises(ValueError, validictory.validate, data2, self.schema)

    def test_minimum_exclusive_fail(self):
        # Test equal
        data = {"prop": 20}

        self.assertRaises(ValueError, validictory.validate, data,
                          self.schema_exclusive)


class TestMinLength(TestCase):
    schema = {"minLength": 4}

    def test_minLength_pass(self):
        # str-equal, str-gt, list-equal, list-gt
        data = ['test', 'string', [1, 2, 3, 4], [0, 0, 0, 0, 0]]

        try:
            for item in data:
                validictory.validate(item, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_minLength_pass_nonstring(self):
        # test when data is not a string
        data1 = 123

        try:
            validictory.validate(data1, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_minLength_fail(self):
        # test equal
        data = ["car", [1, 2, 3]]

        for item in data:
            self.assertRaises(ValueError, validictory.validate, data,
                              self.schema)


class TestMaxLength(TestCase):
    schema = {"maxLength": 4}

    def test_maxLength_pass(self):
        # str-equal, str-lt, list-equal, list-lt
        data = ["test", "car", [1, 2, 3, 4], [0, 0, 0]]
        try:
            for item in data:
                validictory.validate(item, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_maxLength_pass_nonstring(self):
        # test when data is not a string
        data1 = 12345

        try:
            validictory.validate(data1, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_maxLength_fail(self):
        data = ["string", [1, 2, 3, 4, 5]]
        for item in data:
            self.assertRaises(ValueError, validictory.validate, item,
                              self.schema)


class TestBlank(TestCase):

    def test_blank_default_false(self):
        schema = {
            "type": "object",
            "properties": {
                "key": {
                    "type": "string",
                    "required": True,
                }
            }
        }
        try:
            validictory.validate({"key": "value"}, {}, blank_by_default=False)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

        self.assertRaises(ValueError, validictory.validate, {"key": ""},
                          schema)

    def test_blank_default_true(self):
        schema = {
            "type": "object",
            "properties": {
                "key": {
                    "type": "string",
                    "required": True,
                }
            }
        }
        try:
            validictory.validate({"key": ""}, schema, blank_by_default=True)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_blank_false(self):
        schema = {"blank": False}
        try:
            validictory.validate("test", schema, blank_by_default=True)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

        self.assertRaises(ValueError, validictory.validate, "", schema)

    def test_blank_true(self):
        try:
            validictory.validate("", {"blank": True}, blank_by_default=False)
            validictory.validate("test", {"blank": True},
                                 blank_by_default=False)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)


class TestDivisibleBy(TestCase):
    schema = {'type': 'number', 'divisibleBy': 12}
    schema0 = {'type': 'number', 'divisibleBy': 0}

    def test_divisibleBy_pass(self):
        data = 60
        try:
            validictory.validate(data, self.schema)
        except ValueError as e:
            self.fail("Unexpected failure: %s" % e)

    def test_divisibleBy_fail(self):
        data = 13
        self.assertRaises(ValueError, validictory.validate, data, self.schema)

    def test_divisibleBy_ZeroDivisionError_fail(self):
        data = 60
        self.assertRaises(ValueError, validictory.validate, data, self.schema0)

########NEW FILE########
__FILENAME__ = validator
import re
import sys
import copy
import socket
from datetime import datetime
from decimal import Decimal
from collections import Mapping, Container

if sys.version_info[0] == 3:
    _str_type = str
    _int_types = (int,)
else:
    _str_type = basestring
    _int_types = (int, long)


class SchemaError(ValueError):
    """ errors encountered in processing a schema (subclass of :class:`ValueError`) """


class ValidationError(ValueError):
    """ validation errors encountered during validation (subclass of :class:`ValueError`) """


class FieldValidationError(ValidationError):
    """
    Validation error that refers to a specific field and has `fieldname` and `value` attributes.
    """
    def __init__(self, message, fieldname, value):
        message = "Value {!r} for field '{}' {}".format(value, fieldname, message)
        super(FieldValidationError, self).__init__(message)
        self.fieldname = fieldname
        self.value = value


class DependencyValidationError(ValidationError):
    """
    Validation error that refers to a missing dependency
    """
    def __init__(self, message):
        super(DependencyValidationError, self).__init__(message)


class RequiredFieldValidationError(ValidationError):
    """
    Validation error that refers to a missing field
    """
    def __init__(self, message):
        super(RequiredFieldValidationError, self).__init__(message)


class MultipleValidationError(ValidationError):
    def __init__(self, errors):
        msg = "{} validation errors:\n{}".format(len(errors), '\n'.join(str(e) for e in errors))
        super(MultipleValidationError, self).__init__(msg)
        self.errors = errors


def _generate_datetime_validator(format_option, dateformat_string):
    def validate_format_datetime(validator, fieldname, value, format_option):
        try:
            datetime.strptime(value, dateformat_string)
        except:
            msg = "is not in '{format_option}' format"
            raise FieldValidationError(msg.format(format_option=format_option), fieldname, value)

    return validate_format_datetime

validate_format_date_time = _generate_datetime_validator('date-time', '%Y-%m-%dT%H:%M:%SZ')
validate_format_date = _generate_datetime_validator('date', '%Y-%m-%d')
validate_format_time = _generate_datetime_validator('time', '%H:%M:%S')


def validate_format_utc_millisec(validator, fieldname, value, format_option):
    if not isinstance(value, _int_types + (float, Decimal)) or value <= 0:
        msg = "is not a positive number"
        raise FieldValidationError(msg, fieldname, value)


def validate_format_ip_address(validator, fieldname, value, format_option):
    try:
        # Make sure we expect "X.X.X.X" as socket.inet_aton() converts "1" to "0.0.0.1"
        socket.inet_aton(value)
        ip = len(value.split('.')) == 4
    except:
        ip = False
    if not ip:
        msg = "is not a ip-address"
        raise FieldValidationError(msg, fieldname, value)


DEFAULT_FORMAT_VALIDATORS = {
    'date-time': validate_format_date_time,
    'date': validate_format_date,
    'time': validate_format_time,
    'utc-millisec': validate_format_utc_millisec,
    'ip-address': validate_format_ip_address,
}


class SchemaValidator(object):
    '''
    Validator largely based upon the JSON Schema proposal but useful for
    validating arbitrary python data structures.

    :param format_validators: optional dictionary of custom format validators
    :param required_by_default: defaults to True, set to False to make
        ``required`` schema attribute False by default.
    :param blank_by_default: defaults to False, set to True to make ``blank``
        schema attribute True by default.
    :param disallow_unknown_properties: defaults to False, set to True to
        disallow properties not listed in the schema definition
    :param apply_default_to_data: defaults to False, set to True to modify the
        data in case the schema definition includes a "default" property
    '''

    def __init__(self, format_validators=None, required_by_default=True,
                 blank_by_default=False, disallow_unknown_properties=False,
                 apply_default_to_data=False, fail_fast=True):

        self._format_validators = {}
        self._errors = []

        # add the default format validators
        for key, value in DEFAULT_FORMAT_VALIDATORS.items():
            self.register_format_validator(key, value)

        # register any custom format validators if they were provided
        if format_validators:
            for key, value in format_validators.items():
                self.register_format_validator(key, value)
        self.required_by_default = required_by_default
        self.blank_by_default = blank_by_default
        self.disallow_unknown_properties = disallow_unknown_properties
        self.apply_default_to_data = apply_default_to_data
        self.fail_fast = fail_fast

    def register_format_validator(self, format_name, format_validator_fun):
        self._format_validators[format_name] = format_validator_fun

    def validate_type_string(self, val):
        return isinstance(val, _str_type)

    def validate_type_integer(self, val):
        return type(val) in _int_types

    def validate_type_number(self, val):
        return type(val) in _int_types + (float, Decimal,)

    def validate_type_boolean(self, val):
        return type(val) == bool

    def validate_type_object(self, val):
        return isinstance(val, Mapping) or (hasattr(val, 'keys') and hasattr(val, 'items'))

    def validate_type_array(self, val):
        return isinstance(val, (list, tuple))

    def validate_type_null(self, val):
        return val is None

    def validate_type_any(self, val):
        return True

    def _error(self, desc, value, fieldname, exctype=FieldValidationError, **params):
        params['value'] = value
        params['fieldname'] = fieldname
        message = desc.format(**params)

        if exctype == FieldValidationError:
            err = FieldValidationError(message, fieldname, value)
        elif exctype == DependencyValidationError:
            err = DependencyValidationError(message)
        elif exctype == RequiredFieldValidationError:
            err = RequiredFieldValidationError(message)

        if self.fail_fast:
            raise err
        else:
            self._errors.append(err)

    def _validate_unknown_properties(self, schema, data, fieldname):
        schema_properties = set(schema)
        data_properties = set(data)
        delta = data_properties - schema_properties
        if delta:
            unknowns = ', '.join(['"{}"'.format(x) for x in delta])
            raise SchemaError('Unknown properties for field "{fieldname}": {unknowns}'.format(
                fieldname=fieldname, unknowns=unknowns))

    def validate_type(self, x, fieldname, schema, path, fieldtype=None):
        ''' Validates that the fieldtype specified is correct for the given data '''

        # We need to know if the field exists or if it's just Null
        fieldexists = True
        try:
            value = x[fieldname]
        except KeyError:
            fieldexists = False
            value = None

        if fieldtype and fieldexists:
            if isinstance(fieldtype, (list, tuple)):
                # Match if type matches any one of the types in the list
                datavalid = False
                errorlist = []
                for eachtype in fieldtype:
                    try:
                        self.validate_type(x, fieldname, eachtype, path, eachtype)
                        datavalid = True
                        break
                    except ValidationError as err:
                        errorlist.append(err)
                if not datavalid:
                    self._error("doesn't match any of {numsubtypes} subtypes in {fieldtype}; "
                                "errorlist = {errorlist!r}",
                                value, fieldname, numsubtypes=len(fieldtype), fieldtype=fieldtype,
                                errorlist=errorlist)
            elif isinstance(fieldtype, dict):
                try:
                    self.__validate(fieldname, x, fieldtype, path)
                except ValueError as e:
                    raise e
            else:
                try:
                    type_checker = getattr(self, 'validate_type_' + fieldtype)
                except AttributeError:
                    raise SchemaError("Field type '{}' is not supported.".format(fieldtype))

                if not type_checker(value):
                    self._error("is not of type {fieldtype}", value, fieldname,
                                fieldtype=fieldtype)

    def validate_properties(self, x, fieldname, schema, path, properties=None):
        ''' Validates properties of a JSON object by processing the object's schema recursively '''
        value = x.get(fieldname)
        if value is not None:
            if isinstance(value, dict):
                if isinstance(properties, dict):

                    if self.disallow_unknown_properties:
                        self._validate_unknown_properties(properties, value, fieldname)

                    for eachProp in properties:
                        self.__validate(eachProp, value, properties.get(eachProp), path)
                else:
                    raise SchemaError("Properties definition of field '{}' is not an object"
                                      .format(fieldname))

    def validate_items(self, x, fieldname, schema, path, items=None):
        '''
        Validates that all items in the list for the given field match the given schema
        '''
        if x.get(fieldname) is not None:
            value = x.get(fieldname)
            if isinstance(value, (list, tuple)):
                if isinstance(items, (list, tuple)):
                    if 'additionalItems' not in schema and len(items) != len(value):
                        self._error("is not of same length as schema list", value, fieldname)
                    else:
                        for itemIndex in range(len(items)):
                            try:
                                self.__validate("_data", {"_data": value[itemIndex]},
                                                items[itemIndex], path)
                            except FieldValidationError as e:
                                raise type(e)("Failed to validate field '%s' list schema: %s" %
                                              (fieldname, e), fieldname, e.value)
                elif isinstance(items, dict):
                    for eachItem in value:
                        if self.disallow_unknown_properties and 'properties' in items:
                            self._validate_unknown_properties(items['properties'], eachItem,
                                                              fieldname)

                        self.__validate("[list item]", {"[list item]": eachItem}, items, path)
                else:
                    raise SchemaError("Properties definition of field '{}' is "
                                      "not a list or an object".format(fieldname))

    def validate_required(self, x, fieldname, schema, path, required):
        ''' Validates that the given field is present if required is True '''
        # Make sure the field is present
        if fieldname not in x and required:
            self._error("Required field '{fieldname}' is missing", None, fieldname,
                        exctype=RequiredFieldValidationError)

    def validate_blank(self, x, fieldname, schema, path, blank=False):
        ''' Validates that the given field is not blank if blank=False '''
        value = x.get(fieldname)
        if isinstance(value, _str_type) and not blank and not value:
            self._error("cannot be blank'", value, fieldname)

    def validate_patternProperties(self, x, fieldname, schema, path, patternproperties=None):

        if patternproperties is None:
            patternproperties = {}

        value_obj = x.get(fieldname, {})

        for pattern, schema in patternproperties.items():
            for key, value in value_obj.items():
                if re.match(pattern, key):
                    self.__validate("_data", {"_data": value}, schema, path)

    def validate_additionalItems(self, x, fieldname, schema, path, additionalItems=False):
        value = x.get(fieldname)

        if not isinstance(value, (list, tuple)):
            return

        if isinstance(additionalItems, bool):
            if additionalItems or 'items' not in schema:
                return
            elif len(value) != len(schema['items']):
                self._error("is not of same length as schema list", value, fieldname)

        remaining = value[len(schema['items']):]
        if len(remaining) > 0:
            self.__validate("_data", {"_data": remaining}, {"items": additionalItems}, path)

    def validate_additionalProperties(self, x, fieldname, schema, path, additionalProperties=None):
        '''
        Validates additional properties of a JSON object that were not
        specifically defined by the properties property
        '''

        # Shouldn't be validating additionalProperties on non-dicts
        value = x.get(fieldname)
        if not isinstance(value, dict):
            return

        # If additionalProperties is the boolean value True then we accept
        # any additional properties.
        if isinstance(additionalProperties, bool) and additionalProperties:
            return

        value = x.get(fieldname)
        if isinstance(additionalProperties, (dict, bool)):
            properties = schema.get("properties")
            patterns = schema["patternProperties"].keys() if 'patternProperties' in schema else []
            if properties is None:
                properties = {}
            if value is None:
                value = {}
            for eachProperty in value:
                if (eachProperty not in properties and not
                        any(re.match(p, eachProperty) for p in patterns)):
                    # If additionalProperties is the boolean value False
                    # then we don't accept any additional properties.
                    if additionalProperties is False:
                        self._error("contains additional property '{prop}' not defined by "
                                    "'properties' or 'patternProperties' and additionalProperties "
                                    " is False", value, fieldname, prop=eachProperty)
                    self.__validate(eachProperty, value, additionalProperties, path)
        else:
            raise SchemaError("additionalProperties schema definition for "
                              "field '{}' is not an object".format(fieldname))

    def validate_dependencies(self, x, fieldname, schema, path, dependencies=None):
        if x.get(fieldname) is not None:

            # handle cases where dependencies is a string or list of strings
            if isinstance(dependencies, _str_type):
                dependencies = [dependencies]
            if isinstance(dependencies, (list, tuple)):
                for dependency in dependencies:
                    if dependency not in x:
                        self._error("Field '{dependency}' is required by field '{fieldname}'",
                                    None, fieldname, dependency=dependency,
                                    exctype=DependencyValidationError)
            elif isinstance(dependencies, dict):
                # NOTE: the version 3 spec is really unclear on what this means
                # based on the meta-schema I'm assuming that it should check
                # that if a key exists, the appropriate value exists
                for k, v in dependencies.items():
                    if k in x and v not in x:
                        self._error("Field '{k}' is required by field '{v}'", None, fieldname,
                                    k=k, v=v, exctype=DependencyValidationError)
            else:
                raise SchemaError("'dependencies' must be a string, list of strings, or dict")

    def validate_minimum(self, x, fieldname, schema, path, minimum=None):
        ''' Validates that the field is longer than or equal to the minimum length if specified '''

        exclusive = schema.get('exclusiveMinimum', False)

        if x.get(fieldname) is not None:
            value = x.get(fieldname)
            if value is not None:
                if (type(value) in (int, float) and
                    (not exclusive and value < minimum) or
                        (exclusive and value <= minimum)):
                    self._error("is less than minimum value: {minimum}", value, fieldname,
                                minimum=minimum)

    def validate_maximum(self, x, fieldname, schema, path, maximum=None):
        '''
        Validates that the field is shorter than or equal to the maximum length if specified.
        '''

        exclusive = schema.get('exclusiveMaximum', False)

        if x.get(fieldname) is not None:
            value = x.get(fieldname)
            if value is not None:
                if (type(value) in (int, float) and
                    (not exclusive and value > maximum) or
                        (exclusive and value >= maximum)):
                    self._error("is greater than maximum value: {maximum}", value, fieldname,
                                maximum=maximum)

    def validate_maxLength(self, x, fieldname, schema, path, length=None):
        '''
        Validates that the value of the given field is shorter than or equal
        to the specified length
        '''
        value = x.get(fieldname)
        if isinstance(value, (_str_type, list, tuple)) and len(value) > length:
            self._error("must have length less than or equal to {length}", value, fieldname,
                        length=length)

    def validate_minLength(self, x, fieldname, schema, path, length=None):
        '''
        Validates that the value of the given field is longer than or equal to the specified length
        '''
        value = x.get(fieldname)
        if isinstance(value, (_str_type, list, tuple)) and len(value) < length:
            self._error("must have length greater than or equal to {length}", value, fieldname,
                        length=length)

    validate_minItems = validate_minLength
    validate_maxItems = validate_maxLength

    def validate_format(self, x, fieldname, schema, path, format_option=None):
        '''
        Validates the format of primitive data types
        '''
        value = x.get(fieldname)

        format_validator = self._format_validators.get(format_option, None)

        if format_validator and value:
            try:
                format_validator(self, fieldname, value, format_option)
            except FieldValidationError as fve:
                if self.fail_fast:
                    raise
                else:
                    self._errors.append(fve)

        # TODO: warn about unsupported format ?

    def validate_pattern(self, x, fieldname, schema, path, pattern=None):
        '''
        Validates that the given field, if a string, matches the given regular expression.
        '''
        value = x.get(fieldname)
        if isinstance(value, _str_type) and not re.match(pattern, value):
            self._error("does not match regular expression '{pattern}'", value, fieldname,
                        pattern=pattern)

    def validate_uniqueItems(self, x, fieldname, schema, path, uniqueItems=False):
        '''
        Validates that all items in an array instance MUST be unique
        (contains no two identical values).
        '''

        # If additionalProperties is the boolean value True then we accept
        # any additional properties.
        if isinstance(uniqueItems, bool) and not uniqueItems:
            return

        values = x.get(fieldname)

        if not isinstance(values, (list, tuple)):
            return

        hashables = set()
        unhashables = []

        for value in values:
            if isinstance(value, (list, dict)):
                container, add = unhashables, unhashables.append
            else:
                container, add = hashables, hashables.add

            if value in container:
                self._error("is not unique", value, fieldname)
            else:
                add(value)

    def validate_enum(self, x, fieldname, schema, path, options=None):
        '''
        Validates that the value of the field is equal to one of the specified option values
        '''
        value = x.get(fieldname)
        if value is not None:
            if callable(options):
                options = options(x)
            if not isinstance(options, Container):
                raise SchemaError("Enumeration {!r} for field '{}' must be a container".format(
                                  options, fieldname))
            if value not in options:
                self._error("is not in the enumeration: {options!r}", value, fieldname,
                            options=options)

    def validate_title(self, x, fieldname, schema, path, title=None):
        if not isinstance(title, (_str_type, type(None))):
            raise SchemaError("The title for field '{}' must be a string".format(fieldname))

    def validate_description(self, x, fieldname, schema, path, description=None):
        if not isinstance(description, (_str_type, type(None))):
            raise SchemaError("The description for field '{}' must be a string".format(fieldname))

    def validate_divisibleBy(self, x, fieldname, schema, path, divisibleBy=None):
        value = x.get(fieldname)

        if not self.validate_type_number(value):
            return

        if divisibleBy == 0:
            raise SchemaError("'{!r}' <- divisibleBy can not be 0".format(schema))

        if value % divisibleBy != 0:
            self._error("is not divisible by '{divisibleBy}'.", x.get(fieldname), fieldname,
                        divisibleBy=divisibleBy)

    def validate_disallow(self, x, fieldname, schema, path, disallow=None):
        '''
        Validates that the value of the given field does not match the disallowed type.
        '''
        try:
            self.validate_type(x, fieldname, schema, path, disallow)
        except ValidationError:
            return
        self._error("is disallowed for field '{fieldname}'", x.get(fieldname), fieldname,
                    disallow=disallow)

    def validate(self, data, schema):
        '''
        Validates a piece of json data against the provided json-schema.
        '''
        self.__validate("data", {"data": data}, schema, ())
        if self._errors:
            raise MultipleValidationError(self._errors)

    def __validate(self, fieldname, data, schema, path):

        if schema is not None:
            if not isinstance(schema, dict):
                raise SchemaError("Type for field '%s' must be 'dict', got: '%s'" %
                                  (fieldname, type(schema).__name__))

            newschema = copy.copy(schema)

            if 'required' not in schema:
                newschema['required'] = self.required_by_default
            if 'blank' not in schema:
                newschema['blank'] = self.blank_by_default

            # iterate over schema and call all validators
            for schemaprop in newschema:
                validatorname = "validate_" + schemaprop
                validator = getattr(self, validatorname, None)
                if validator:
                    validator(data, fieldname, schema, path, newschema.get(schemaprop))

            if self.apply_default_to_data and 'default' in schema:
                try:
                    self.validate_type(x={'_ds': schema['default']}, fieldname='_ds',
                                       schema=schema,
                                       fieldtype=schema['type'] if 'type' in schema else None,
                                       path=path)
                except FieldValidationError as exc:
                    raise SchemaError(exc)

                if fieldname not in data:
                    data[fieldname] = schema['default']

        return data

########NEW FILE########
