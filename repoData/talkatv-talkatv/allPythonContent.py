__FILENAME__ = config
# This file should be considered public domain
################################################################################
## # # # # # # # # # # # # ## DO NOT EDIT THIS FILE ## # # # # # # # # # # # ###
################################################################################
# IF YOU WISH TO MAKE CHANGES, COPY THIS FILE TO ./config_local.py AND APPLY
# THE CHANGES, THEN RESTART THE APPLICATION.
################################################################################
import os
import bcrypt

REPO_ROOT = os.path.dirname(__file__)

# This generates a different salt every time you start the application.
# This means that session cookies will expire. For production deployments you
# should consider replacing this with
# SECRET_KEY = 'your-own-custom-secret-salt'
SECRET_KEY = bcrypt.gensalt()

SQLALCHEMY_DATABASE_URI = 'sqlite:///{0}/talkatv.db'.format(
        REPO_ROOT)

OPENID_FS_STORE_PATH = os.path.join(REPO_ROOT, 'openid-data')

WSGI_BIND_ADDR = '127.0.0.1', 45474

CORS_ALLOW_ORIGIN = '*'
CORS_MAX_AGE = 3600
CORS_ALLOW_HEADERS = 'Accept, Content-Type, Connection, Cookie'
CORS_ALLOW_METHODS = 'GET, POST'
CORS_ALLOW_CREDENTIALS = 'true'

# EMAIL
NOTIFICATION_ADDR = 'notifications@talka.tv'

# SMTP
SMTP_SSL = False
SMTP_HOST = 'localhost'
SMTP_PORT = None  # None == use default port
SMTP_USER = ''
SMTP_PASS = ''

########NEW FILE########
__FILENAME__ = dbupdate
#!/usr/bin/env python
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import logging

from mig import run
from mig.models import MigrationData

from talkatv import db
from talkatv.models import MODELS
from talkatv.migrations import MIGRATIONS

root_log = logging.getLogger()
root_log.setLevel(logging.DEBUG)
logging.basicConfig()

_log = logging.getLogger(__name__)


def check_or_create_mig_data():
    if not db.engine.dialect.has_table(db.session, 'mig__data'):
        _log.info('Creating MigrationData table...')
        MigrationData.__table__.create(db.engine)

        # Create the first migration, so that mig doesn't init.
        migration = MigrationData(name=u'__main__', version=0)
        db.session.add(migration)
        db.session.commit()


if __name__ == '__main__':
    if db.engine.dialect.has_table(db.session, 'user'):
        # The DB is already populated, check if migrations are active
        check_or_create_mig_data()

    run(db.engine, u'__main__', MODELS, MIGRATIONS)

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# talkatv documentation build configuration file, created by
# sphinx-quickstart on Wed Aug 15 13:03:42 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('../../'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'sphinx.ext.todo', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'talkatv'
copyright = u'2012, talkatv contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.0.1'
# The full version, including alpha/beta/rc tags.
release = '0.0.1-dev'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'pydoctheme'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
sys.path.append(os.path.abspath('_themes'))
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'talkatvdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'talkatv.tex', u'talkatv Documentation',
   u'talkatv contributors', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'talkatv', u'talkatv Documentation',
     [u'talkatv contributors'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'talkatv', u'talkatv Documentation',
   u'talkatv contributors', 'talkatv', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = gentestsig
#!/usr/bin/python2.4
#
# Copyright 2009 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Generate a simple signature from known plaintext."""

import magicsig.magicsigalg as magicsigalg

__author__ = 'jpanzer@google.com (John Panzer)'

_test_keypair = ('RSA.mVgY8RN6URBTstndvmUUPb4UZTdwvwmddSKE5z_jvKUEK6yk1'
                 'u3rrC9yN8k6FilGj9K0eeUPe2hf4Pj-5CmHww=='
                 '.AQAB'
                 '.Lgy_yL3hsLBngkFdDw1Jy9TmSRMiH6yihYetQ8jy-jZXdsZXd8V5'
                 'ub3kuBHHk4M39i3TduIkcrjcsiWQb77D8Q==')

_test_text = unicode('One small splash for a salmon, one giant '
                     'leap for salmonkind!', 'utf-8').encode('utf-8')

def log(s):
  print s

if __name__ == '__main__':
  signer = magicsigalg.SignatureAlgRsaSha256(_test_keypair)
  logger = ''
  sig = signer.Sign(_test_text, log)
  print "Message: [%s]" % _test_text
  print "Key: [%s]" % _test_keypair
  print "Signature: [%s]" % sig

########NEW FILE########
__FILENAME__ = magicsigalg
#!/usr/bin/python2.4
#
# Copyright 2009 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Implementation of Magic Signatures low level operations.

See Magic Signatures RFC for specification.  This implements
the cryptographic layer of the spec, essentially signing and
verifying byte buffers using a public key algorithm.
"""

__author__ = 'jpanzer@google.com (John Panzer)'


import base64
import re

# PyCrypto: Note that this is not available in the
# downloadable GAE SDK, must be installed separately.
# See http://code.google.com/p/googleappengine/issues/detail?id=2493
# for why this is most easily installed under the
# project's path rather than somewhere more sane.
import Crypto.PublicKey
import Crypto.PublicKey.RSA
from Crypto.Util import number

import hashlib


# Note that PyCrypto is a very low level library and its documentation
# leaves something to be desired.  As a cheat sheet, for the RSA
# algorithm, here's a decoding of terminology:
#     n - modulus (public)
#     e - public exponent
#     d - private exponent
#     (n, e) - public key
#     (n, d) - private key
#     (p, q) - the (private) primes from which the keypair is derived.

# Thus a public key is a tuple (n,e) and a public/private key pair
# is a tuple (n,e,d).  Often the exponent is 65537 so for convenience
# we default e=65537 in this code.


def GenSampleSignature(text):
  """Demo using a hard coded, test public/private keypair."""
  demo_keypair = ('RSA.mVgY8RN6URBTstndvmUUPb4UZTdwvwmddSKE5z_jvKUEK6yk1'
                  'u3rrC9yN8k6FilGj9K0eeUPe2hf4Pj-5CmHww=='
                  '.AQAB'
                  '.Lgy_yL3hsLBngkFdDw1Jy9TmSRMiH6yihYetQ8jy-jZXdsZXd8V5'
                  'ub3kuBHHk4M39i3TduIkcrjcsiWQb77D8Q==')

  signer = SignatureAlgRsaSha256(demo_keypair)
  return signer.Sign(text)


# Utilities
def _NumToB64(num):
  """Turns a bignum into a urlsafe base64 encoded string."""
  return base64.urlsafe_b64encode(number.long_to_bytes(num))


def _B64ToNum(b64):
  """Turns a urlsafe base64 encoded string into a bignum."""
  return number.bytes_to_long(base64.urlsafe_b64decode(b64))

# Patterns for parsing serialized keys
_WHITESPACE_RE = re.compile(r'\s+')
_KEY_RE = re.compile(
    r"""RSA\.
      (?P<mod>[^\.]+)
      \.
      (?P<exp>[^\.]+)
      (?:\.
        (?P<private_exp>[^\.]+)
      )?""",
    re.VERBOSE)


# Implementation of the Magic Envelope signature algorithm
class SignatureAlgRsaSha256(object):
  """Signature algorithm for RSA-SHA256 Magic Envelope."""

  def __init__(self, rsa_key):
    """Initializes algorithm with key information.

    Args:
      rsa_key: Key in either string form or a tuple in the
               format expected by Crypto.PublicKey.RSA.
    Raises:
      ValueError: The input format was incorrect.
    """
    if isinstance(rsa_key, tuple):
      self.keypair = Crypto.PublicKey.RSA.construct(rsa_key)
    else:
      self._InitFromString(rsa_key)

  def ToString(self, full_key_pair=True):
    """Serializes key to a safe string storage format.

    Args:
      full_key_pair: Whether to save the private key portion as well.
    Returns:
      The string representation of the key in the format:

        RSA.mod.exp[.optional_private_exp]

      Each component is a urlsafe-base64 encoded representation of
      the corresponding RSA key field.
    """
    mod = _NumToB64(self.keypair.n)
    exp = '.' + _NumToB64(self.keypair.e)
    private_exp = ''
    if full_key_pair and self.keypair.d:
      private_exp = '.' + _NumToB64(self.keypair.d)
    return 'RSA.' + mod + exp + private_exp

  def _InitFromString(self, text):
    """Parses key from a standard string storage format.

    Args:
      text: The key in text form.  See ToString for description
        of expected format.
    Raises:
      ValueError: The input format was incorrect.
    """
    # First, remove all whitespace:
    text = re.sub(_WHITESPACE_RE, '', text)

    # Parse out the period-separated components
    match = _KEY_RE.match(text)
    if not match:
      raise ValueError('Badly formatted key string: "%s"', text)

    private_exp = match.group('private_exp')
    if private_exp:
      private_exp = _B64ToNum(private_exp)
    else:
      private_exp = None
    self.keypair = Crypto.PublicKey.RSA.construct(
        (_B64ToNum(match.group('mod')),
         _B64ToNum(match.group('exp')),
         private_exp))

  def GetName(self):
    """Returns string identifier for algorithm used."""
    return 'RSA-SHA256'

  def _MakeEmsaMessageSha256(self, msg, modulus_size, logf=None):
    """Algorithm EMSA_PKCS1-v1_5 from PKCS 1 version 2.

    This is derived from keyczar code, and implements the
    additional ASN.1 compatible magic header bytes and
    padding needed to implement PKCS1-v1_5.

    Args:
      msg: The message to sign.
      modulus_size: The size of the key (in bits) used.
    Returns:
      The byte sequence of the message to be signed.
    """
    magic_sha256_header = [0x30, 0x31, 0x30, 0xd, 0x6, 0x9, 0x60, 0x86, 0x48,
                           0x1, 0x65, 0x3, 0x4, 0x2, 0x1, 0x5, 0x0, 0x4, 0x20]

    hash_of_msg = hashlib.sha256(msg).digest() #???

    self._Log(logf, 'sha256 digest of msg %s: [%s]' % (msg, hash_of_msg.encode('hex')))

    encoded = ''.join([chr(c) for c in magic_sha256_header]) + hash_of_msg

    msg_size_bits = modulus_size + 8-(modulus_size % 8)  # Round up to next byte

    pad_string = chr(0xFF) * (msg_size_bits / 8 - len(encoded) - 3)
    return chr(0) + chr(1) + pad_string + chr(0) + encoded

  def _Log(self, logf, s):
    """Append message to log if log exists."""
    if logf:
      logf(s + '\n')

  def Sign(self, bytes_to_sign, logf=None):
    """Signs the bytes using PKCS-v1_5.

    Args:
      bytes_to_sign: The bytes to be signed.
    Returns:
      The signature in base64url encoded format.
    """
    # Implements PKCS1-v1_5 w/SHA256 over the bytes, and returns
    # the result as a base64url encoded bignum.

    self._Log(logf, 'bytes_to_sign = [%s]' % bytes_to_sign.encode('hex'))

    self._Log(logf, 'keypair size : %s' % self.keypair.size())

    # Generate the PKCS1-v1_5 compatible message, which includes
    # magic ASN.1 bytes and padding:
    emsa_msg = self._MakeEmsaMessageSha256(bytes_to_sign, self.keypair.size(), logf)
    # TODO(jpanzer): Check whether we need to use max keysize above
    # or just keypair.size

    self._Log(logf, 'emsa_msg = [%s]' % emsa_msg.encode('hex'))

    # Compute the signature:
    signature_long = self.keypair.sign(emsa_msg, None)[0]

    # Encode the signature as armored text:
    signature_bytes = number.long_to_bytes(signature_long)

    self._Log(logf, 'signature_bytes = [%s]' % signature_bytes.encode('hex'))

    return base64.urlsafe_b64encode(signature_bytes).encode('utf-8')

  def Verify(self, signed_bytes, signature_b64):
    """Determines the validity of a signature over a signed buffer of bytes.

    Args:
      signed_bytes: string The buffer of bytes the signature_b64 covers.
      signature_b64: string The putative signature, base64-encoded, to check.
    Returns:
      True if the request validated, False otherwise.
    """
    # Generate the PKCS1-v1_5 compatible message, which includes
    # magic ASN.1 bytes and padding:
    emsa_msg = self._MakeEmsaMessageSha256(signed_bytes,
                                           self.keypair.size())

    # Get putative signature:
    putative_signature = base64.urlsafe_b64decode(signature_b64.encode('utf-8'))
    putative_signature = number.bytes_to_long(putative_signature)

    # Verify signature given public key:
    return self.keypair.verify(emsa_msg, (putative_signature,))

########NEW FILE########
__FILENAME__ = magicsigalg_test
#!/usr/bin/python2.4
#
# Copyright 2009 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for magicsigalg.py."""

__author__ = 'jpanzer@google.com (John Panzer)'

import re
import unittest
try:
  import google3  # GOOGLE local modification
except ImportError:
  pass
import magicsig.magicsigalg as magicsigalg  # GOOGLE local mod


def _StripWS(s):
  """Strips all whitespace from a string."""
  return re.sub('\s+', '', s)


class TestMagicSigAlg(unittest.TestCase):
  """Tests magicsigalg module."""

  _test_publickey = ('RSA.mVgY8RN6URBTstndvmUUPb4UZTdwvwmddSKE5z_jvKUEK6yk1'
                     'u3rrC9yN8k6FilGj9K0eeUPe2hf4Pj-5CmHww==.AQAB')

  _test_keypair = ('RSA.mVgY8RN6URBTstndvmUUPb4UZTdwvwmddSKE5z_jvKUEK6yk1'
                   'u3rrC9yN8k6FilGj9K0eeUPe2hf4Pj-5CmHww=='
                   '.AQAB'
                   '.Lgy_yL3hsLBngkFdDw1Jy9TmSRMiH6yihYetQ8jy-jZXdsZXd8V5'
                   'ub3kuBHHk4M39i3TduIkcrjcsiWQb77D8Q==')

  def setUp(self):
    # Well known keys to use for testing:
    self.signer = magicsigalg.SignatureAlgRsaSha256(self._test_keypair)
    self.verifier = magicsigalg.SignatureAlgRsaSha256(self._test_publickey)

  def testNumberSerialization(self):
    # Just for extra paranoia, as the underlying libraries don't have tests:
    self.assertEquals(magicsigalg._NumToB64(1), 'AQ==')

    # This will fail if someone swaps to little endian by accident:
    self.assertEquals(magicsigalg._NumToB64(65537), 'AQAB')

    # Test round tripping of a realistically large number:
    n = pow(2, 2048) + 42
    b64 = magicsigalg._NumToB64(n)
    self.assertEquals(magicsigalg._B64ToNum(b64), n)

  def testBadKey(self):
    # Bad input should raise appropriate exceptions
    self.assertRaises(ValueError,
                      magicsigalg.SignatureAlgRsaSha256, 'Barney the dinosaur')
    self.assertRaises(TypeError,
                      magicsigalg.SignatureAlgRsaSha256, 42)

  def testRsaSignature(self):
    text = unicode('One small splash for a salmon, one giant '
                   'leap for salmonkind!', 'utf-8').encode('utf-8')
    sig = self.signer.Sign(text)

    # The just-signed (text,sig) tuple should validate:
    self.assertTrue(self.verifier.Verify(text, sig))

    # Even tiny modifications to the text should not validate:
    self.assertFalse(self.verifier.Verify(text+'a', sig))

  def testSerialization(self):
    # Round tripping should produce equal strings, modulo whitespace.
    self.assertEquals(_StripWS(self.signer.ToString()),
                      _StripWS(self._test_keypair))
    self.assertEquals(_StripWS(self.verifier.ToString()),
                      _StripWS(self._test_publickey))
    self.assertNotEquals(_StripWS(self.signer.ToString()),
                         _StripWS(self.verifier.ToString()))

if __name__ == '__main__':
  unittest.main()

########NEW FILE########
__FILENAME__ = magicsig_example
#!/usr/bin/python2.4
#
# Copyright 2009 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Command line example of magic signatures."""

__author__ = 'jpanzer@google.com (John Panzer)'

import re
import unittest
try:
  import google3  # GOOGLE local modification
except ImportError:
  pass
import magicsig


TEST_PRIVATE_KEY = ('RSA.mVgY8RN6URBTstndvmUUPb4UZTdwvwmddSKE5z_jvKUEK6yk1'
                    'u3rrC9yN8k6FilGj9K0eeUPe2hf4Pj-5CmHww=='
                    '.AQAB'
                    '.Lgy_yL3hsLBngkFdDw1Jy9TmSRMiH6yihYetQ8jy-jZXdsZXd8V5'
                    'ub3kuBHHk4M39i3TduIkcrjcsiWQb77D8Q==')


class DemoMagicEnvelope():
  """Demos the Envelope class."""

  class MockKeyRetriever(magicsig.KeyRetriever):
    def LookupPublicKey(self, signer_uri):
      assert signer_uri
      return TEST_PRIVATE_KEY

  test_atom = """<?xml version='1.0' encoding='UTF-8'?>
<entry xmlns='http://www.w3.org/2005/Atom'>
  <id>tag:example.com,2009:cmt-0.44775718</id>
  <author><name>Test</name><uri>acct:test@example.com</uri></author>
  <content>Salmon swim upstream!</content>
  <title>Salmon swim upstream!</title>
  <updated>2009-12-18T20:04:03Z</updated>
</entry>"""

  #def setUp(self):
  #  self.protocol = magicsig.MagicEnvelopeProtocol()
  #  self.protocol.key_retriever = self.MockKeyRetriever()

  def dump(self):
    envelope = magicsig.Envelope(
        raw_data_to_sign=self.test_atom,
        signer_uri='acct:test@example.com',
        signer_key=TEST_PRIVATE_KEY,
        data_type='application/atom+xml',
        encoding='base64url',
        alg='RSA-SHA256')

    # Turn envelope into text:
    xml = envelope.ToXML()

    # And provenanced Atom:
    atom = envelope.ToAtom()

    print "Original data:\n%s\n" % self.test_atom
    print "Magic Envelope:\n%s\n" % xml
    print "Atom with provenance:\n%s\n" % atom


if __name__ == '__main__':
  DemoMagicEnvelope().dump()

########NEW FILE########
__FILENAME__ = magicsig_test
#!/usr/bin/python2.4
#
# Copyright 2009 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for magicsig.py."""

__author__ = 'jpanzer@google.com (John Panzer)'

import re
import unittest
try:
  import google3  # GOOGLE local modification
except ImportError:
  pass
import magicsig

#import sys


def _StripWS(s):
  """Strips all whitespace from a string."""
  return re.sub('\s+', '', s)


class TestMagicEnvelopeProtocol(unittest.TestCase):
  """Tests Magic Envelope protocol."""

  class MockKeyRetriever(magicsig.KeyRetriever):
    def LookupPublicKey(self, signer_uri):
      assert signer_uri
      return  ('RSA.mVgY8RN6URBTstndvmUUPb4UZTdwvwmddSKE5z_jvKUEK6yk1'
               'u3rrC9yN8k6FilGj9K0eeUPe2hf4Pj-5CmHww=='
               '.AQAB'
               '.Lgy_yL3hsLBngkFdDw1Jy9TmSRMiH6yihYetQ8jy-jZXdsZXd8V5'
               'ub3kuBHHk4M39i3TduIkcrjcsiWQb77D8Q==')

  magicenv = None
  test_atom = """<?xml version='1.0' encoding='UTF-8'?>
    <entry xmlns='http://www.w3.org/2005/Atom'>
    <id>tag:example.com,2009:cmt-0.44775718</id>
      <author><name>test@example.com</name><uri>acct:test@example.com</uri>
      </author>
      <content>Salmon swim upstream!</content>
      <title>Salmon swim upstream!</title>
      <updated>2009-12-18T20:04:03Z</updated>
    </entry>
  """

  test_atom_multi_author = """<?xml version='1.0' encoding='UTF-8'?>
    <entry xmlns='http://www.w3.org/2005/Atom'>
    <id>tag:example.com,2009:cmt-0.44775718</id>
      <author><name>alice@example.com</name><uri>acct:alice@example.com</uri>
      </author>
      <author><name>bob@example.com</name><uri>acct:bob@example.com</uri>
      </author>
      <content>Salmon swim upstream!</content>
      <title>Salmon swim upstream!</title>
      <updated>2009-12-18T20:04:03Z</updated>
    </entry>
  """

  def setUp(self):
    self.magicenv = magicsig.MagicEnvelopeProtocol()
    self.magicenv.key_retriever = self.MockKeyRetriever()

  def testGetSignerURI(self):
    # Trival case of one author:
    a = self.magicenv.GetSignerURI(self.test_atom)
    self.assertEquals(a, 'acct:test@example.com')

    # Multi author case:
    a = self.magicenv.GetSignerURI(self.test_atom_multi_author)
    self.assertEquals(a, 'acct:alice@example.com')

  def testIsAllowedSigner(self):
    # Check that we can recognize the author
    self.assertTrue(self.magicenv.IsAllowedSigner(self.test_atom,
                                                  'acct:test@example.com'))

    # Method requires a real URI
    self.assertFalse(self.magicenv.IsAllowedSigner(self.test_atom,
                                                   'test@example.com'))

    # We recognize only the first of multiple authors
    self.assertTrue(self.magicenv.IsAllowedSigner(self.test_atom_multi_author,
                                                  'acct:alice@example.com'))
    self.assertFalse(self.magicenv.IsAllowedSigner(self.test_atom_multi_author,
                                                   'acct:bob@example.com'))

  def testNormalizeUserIds(self):
    id1 = 'http://example.com'
    id2 = 'https://www.example.org/bob'
    id3 = 'acct:bob@example.org'
    em3 = 'bob@example.org'

    self.assertEquals(magicsig.NormalizeUserIdToUri(id1), id1)
    self.assertEquals(magicsig.NormalizeUserIdToUri(id2), id2)
    self.assertEquals(magicsig.NormalizeUserIdToUri(id3), id3)
    self.assertEquals(magicsig.NormalizeUserIdToUri(em3), id3)
    self.assertEquals(magicsig.NormalizeUserIdToUri(' '+id1+' '), id1)


TEST_PRIVATE_KEY = ('RSA.mVgY8RN6URBTstndvmUUPb4UZTdwvwmddSKE5z_jvKUEK6yk1'
                    'u3rrC9yN8k6FilGj9K0eeUPe2hf4Pj-5CmHww=='
                    '.AQAB'
                    '.Lgy_yL3hsLBngkFdDw1Jy9TmSRMiH6yihYetQ8jy-jZXdsZXd8V5'
                    'ub3kuBHHk4M39i3TduIkcrjcsiWQb77D8Q==')


class TestMagicEnvelope(unittest.TestCase):
  """Tests the Envelope class."""

  class MockKeyRetriever(magicsig.KeyRetriever):
    def LookupPublicKey(self, signer_uri):
      assert signer_uri
      return TEST_PRIVATE_KEY

  test_atom = """<?xml version='1.0' encoding='UTF-8'?>
    <entry xmlns='http://www.w3.org/2005/Atom'>
    <id>tag:example.com,2009:cmt-0.44775718</id>
      <author><name>test@example.com</name><uri>acct:test@example.com</uri>
      </author>
      <content>Salmon swim upstream!</content>
      <title>Salmon swim upstream!</title>
      <updated>2009-12-18T20:04:03Z</updated>
    </entry>
  """

  def setUp(self):
    self.protocol = magicsig.MagicEnvelopeProtocol()
    self.protocol.key_retriever = self.MockKeyRetriever()

  def testInvalidEnvelopes(self):
    self.assertRaises(magicsig.EnvelopeError, magicsig.Envelope, 'blah')
    try:
      magicsig.Envelope(foo=5, biff=23)
      # Should never get here
      self.assertTrue(None)
    except magicsig.Error:
      pass
      # e = sys.exc_info()[1]
      #print "Exception: %s" % e
      #print "Invalid envelope: %s" % e.invalid_envelope

  def testSigning(self):
    envelope = magicsig.Envelope(
        self.protocol,
        raw_data_to_sign=self.test_atom,
        signer_uri='acct:test@example.com',
        signer_key=TEST_PRIVATE_KEY,
        data_type='application/atom+xml',
        encoding='base64url',
        alg='RSA-SHA256')

    # Turn envelope into text:
    xml = envelope.ToXML()

    # Now round-trip it:
    magicsig.Envelope(
        self.protocol,
        mime_type='application/magic-envelope+xml',
        document=xml)

    # Getting here without an exception is success.

  def testToAtom(self):
    envelope = magicsig.Envelope(
        self.protocol,
        raw_data_to_sign=self.test_atom,
        signer_uri='acct:test@example.com',
        signer_key=TEST_PRIVATE_KEY,
        data_type='application/atom+xml',
        encoding='base64url',
        alg='RSA-SHA256')

    text = envelope.ToAtom()

    assert re.search('atom:entry',text)
    assert re.search('me:provenance',text)
    assert re.search('test@example\.com',text)

  def testTampering(self):
    envelope = magicsig.Envelope(
        self.protocol,
        raw_data_to_sign=self.test_atom,
        signer_uri='acct:test@example.com',
        signer_key=TEST_PRIVATE_KEY,
        data_type='application/atom+xml',
        encoding='base64url',
        alg='RSA-SHA256')

    xml = envelope.ToXML()

    self.assertRaises(Exception,
                      magicsig.Envelope,
                      self.protocol,
                      mime_type='application/magic-envelope+xml',
                      document=re.sub('U2FsbW9', 'U2GsbW9', xml))

if __name__ == '__main__':
  unittest.main()

########NEW FILE########
__FILENAME__ = run
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import subprocess

from talkatv import app


DOCS_DIR = os.path.join(
        os.path.dirname(os.path.dirname(__file__)),
        'docs')


def build_docs():
    try:
        app.logger.info('Building docs')
        subprocess.check_call(['make', 'html'], cwd=DOCS_DIR)
    except subprocess.CalledProcessError:
        app.logger.warn('Couldn\'t build docs')

if __name__ == '__main__':
    app.run(port=4547)

########NEW FILE########
__FILENAME__ = views
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from flask import request, json, abort, g

from talkatv import app
from talkatv.decorators import require_active_login
from talkatv.models import Item
from talkatv.tools.cors import jsonify, allow_all_origins
from talkatv.item import get_or_add_item
from talkatv.api import get_context, post_comment


@app.route('/api/comments', methods=['GET', 'POST', 'OPTIONS'])
@require_active_login(['POST'])
def api_comments():
    if request.method == 'OPTIONS':
        # We're dealing with a pre-flight request
        return jsonify(status='OK', _allow_origin_cb=allow_all_origins)

    if request.method == 'POST':
        post_data = json.loads(request.data)

        item = Item.query.filter_by(id=post_data['item']).first()

        if not item:
            return abort(404)

        comment = post_comment(item, post_data, g.user)

        return jsonify(
                comment=comment.as_dict(),
                status='OK',
                _allow_origin_cb=allow_all_origins)

    if not request.args.get('item_url'):
        return abort(404)

    item = get_or_add_item(
            request.args.get('item_url'),
            request.args.get('item_title'))

    return_data = get_context(item)

    return jsonify(_allow_origin_cb=allow_all_origins,
            **return_data)


@app.route('/api/check-login', methods=['GET', 'OPTIONS'])
def check_login():
    if g.user:
        return jsonify(status='OK', _allow_origin_cb=allow_all_origins)
    else:
        return jsonify(status=False, _allow_origin_cb=allow_all_origins)

########NEW FILE########
__FILENAME__ = views
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from flask import render_template, abort, request, redirect, url_for

from talkatv import app
from talkatv.models import Item
from talkatv.api import get_context


@app.route('/comment/list/<int:item_id>')
@app.route('/comment/list/')
def comment_list(item_id=None):
    item = None

    if item_id:
        item = Item.query.filter_by(id=item_id).first()

        if item is None:
            return abort(404)
    else:
        if request.args.get('url'):
            item = Item.query.filter_by(url=request.args.get('url')).first()

            app.logger.debug('item by args[\'url\']: {0}'.format(item))

            if item:
                return redirect(url_for('comment_list', item_id=item.id))

        elif request.headers.get('Referer'):
            item = Item.query.filter_by(url=request.headers.get('Referer'))\
                    .first()

            if item:
                return redirect(url_for('comment_list', item_id=item.id))
            else:
                return abort(404)

    if item is None:
        return abort(404)

    comment_context = get_context(item)

    return render_template('talkatv/comment/list.html',
            comment_context=comment_context)

########NEW FILE########
__FILENAME__ = decorators
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from flask import g, abort, request
from functools import wraps


class require_active_login(object):
    def __init__(self, methods=[]):
        self.methods = methods

    def __call__(self, controller):
        @wraps(controller)
        def wrapper(*args, **kw):
            if g.user is None:
                if not len(self.methods) or request.method in self.methods:
                    return abort(403)

            return controller(*args, **kw)

        return wrapper

########NEW FILE########
__FILENAME__ = filters
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import urllib

from jinja2 import Markup

from talkatv import app


@app.template_filter('urlencode')
def urlencode_filter(s):
    if type(s) == 'Markup':
        s = s.unescape()
    s = s.encode('utf8')
    s = urllib.quote_plus(s)
    return Markup(s)

########NEW FILE########
__FILENAME__ = forms
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from pywebfinger import finger

from flask import g

from flask.ext.wtf import Form, html5, TextField, PasswordField, HiddenField, \
        validators
from talkatv.models import User, Item, Comment, OpenID
from talkatv.tools.redirect import RedirectForm


class RegistrationForm(Form):
    username = TextField('Username', [validators.Required()])
    password = PasswordField('Password', [validators.Optional()])
    email = html5.EmailField('Email', [validators.Required()])

    def __init__(self, *args, **kw):
        Form.__init__(self, *args, **kw)
        self.user = None

    def validate(self):
        if not Form.validate(self):
            return False

        if not self.password.data and not self.openid.data:
            self.errors.append(
                    'You must include either password or an OpenID URL')
            return False

        user = User.query.filter_by(username=self.username.data).first()

        if user is not None:
            self.username.errors.append('User already exists.')

        return True


class ProfileForm(Form):
    '''
    Edit user profile form
    '''
    username = TextField('Username', [validators.Required()])
    email = html5.EmailField('Email', [validators.Required()])
    openid = html5.URLField('OpenID', [validators.Optional()])

    def __init__(self, *args, **kw):
        Form.__init__(self, *args, **kw)

    def validate(self):
        if not Form.validate(self):
            return False

        user_exists = User.query.filter(
                User.username==self.username.data).filter(
                        User.email!=g.user.email).count()

        if user_exists:
            self.username.errors.append(
                    'The username "{0}" is already taken'.format(
                        self.username.data))
            return False

        email_exists = User.query.filter(
                User.email==self.email.data).filter(
                        User.username!=g.user.username).count()

        if email_exists:
            self.email.errors.append(
                    'The email "{0}" is already taken'.format(
                        self.email.data))
            return False

        return True


class ChangePasswordForm(Form):
    password = PasswordField('Password',
            [validators.Optional()])
    new_password = PasswordField('New password', [validators.Required()])

    def __init__(self, *args, **kw):
        Form.__init__(self, *args, **kw)

    def validate(self):
        if not Form.validate(self):
            return False

        if g.user.password is not None:
            if not g.user.check_password(self.password.data):
                self.password.errors.append('Invalid password')

        return True


class ItemForm(Form):
    url = TextField('Page URL', [validators.Required()])
    title = TextField('Page title', [validators.Required()])

    def __init__(self, *args, **kwargs):
        Form.__init__(self, *args, **kwargs)
        self.item = None

    def validate(self):
        if not Form.validate(self):
            return False

        item = Item.query.filter_by(url=self.url.data).first()

        if item is not None:
            self.url.errors.append('That URL already exists')
            return False

        return True


class SiteForm(Form):
    url = html5.URLField('URL', [validators.Required()])
    name = TextField('Name', [validators.Optional()])


class LoginForm(RedirectForm):
    username = TextField('Username', [validators.Optional()])
    password = PasswordField('Password', [validators.Optional()])
    openid = TextField('OpenID', [validators.Optional()],
            description=u'An OpenID URL or a webfinger identity')

    def __init__(self, *args, **kwargs):
        Form.__init__(self, *args, **kwargs)
        RedirectForm.__init__(self, *args, **kwargs)
        self.user = None

    def validate(self):
        if not Form.validate(self):
            return False

        user = None

        openid_identifier = None

        # Account for webfinger addresses in OpenID input and fetch the OpenID
        # identifier from the webfinger identity
        if '@' in self.openid.data:
            webfinger = finger(self.openid.data)

            if not webfinger.open_id:
                self.webfinger.errors.append(
                        'Can\'t find any OpenID identifier for {0}'.format(
                            self.webfinger.data))
            else:
                openid_identifier = webfinger.open_id

        self.openid.data = self.openid.data or openid_identifier

        if openid_identifier or self.openid.data:
            openid = OpenID.query.filter_by(url=self.openid.data).first()

            if not openid:
                self.openid.errors.append('Unknown OpenID URL {0}'.format(
                    self.openid.data))
                return False
            else:
                user = openid.user

        if self.username.data and self.password.data:
            user = User.query.filter_by(username=self.username.data).first()

            if user is None:
                self.username.errors.append('Unknown username')
            elif not user.check_password(self.password.data):
                self.password.errors.append('Invalid password')

        if user:
            self.user = user
            return True

        return False

########NEW FILE########
__FILENAME__ = migrations
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from mig import RegisterMigration

from sqlalchemy import MetaData, Table, Column, Integer, Unicode, DateTime, \
        ForeignKey

MIGRATIONS = {}


@RegisterMigration(1, MIGRATIONS)
def create_site_table(db_conn):
    metadata = MetaData(bind=db_conn.bind)

    user_table = Table('user', metadata, autoload=True,
            autoload_with=db_conn.bind)

    site_table = Table('site', metadata,
            Column('id', Integer, primary_key=True),
            Column('domain', Unicode),
            Column('owner_id', Integer, ForeignKey(user_table.columns['id'])))

    site_table.create()

    db_conn.commit()


@RegisterMigration(2, MIGRATIONS)
def item_add_site_id(db_conn):
    metadata = MetaData(bind=db_conn.bind)

    item_table = Table('item', metadata, autoload=True)
    site_table = Table('site', metadata, autoload=True)

    site_id_col = Column('site_id', Integer, ForeignKey(
        site_table.columns['id']))

    site_id_col.create(item_table)

    db_conn.commit()


@RegisterMigration(3, MIGRATIONS)
def add_site_created_remove_item_owner(db_conn):
    metadata = MetaData(bind=db_conn.bind)

    site_table = Table('site', metadata, autoload=True)

    created_col = Column('created', DateTime)

    created_col.create(site_table)

    item_table = Table('item', metadata, autoload=True)

    item_table.columns['owner_id'].drop()

    db_conn.commit()


@RegisterMigration(4, MIGRATIONS)
def comment_add_reply_to_id(db):
    metadata = MetaData(bind=db.bind)

    comment_table = Table('comment', metadata, autoload=True)
    reply_to_column = Column('reply_to_id', Integer, ForeignKey('comment.id'))

    reply_to_column.create(comment_table)

    db.commit()

########NEW FILE########
__FILENAME__ = models
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import bcrypt

from datetime import datetime

from migrate import changeset
assert changeset  # silence code analysers

from talkatv import db
from talkatv.comment import parse_comment


class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(60), unique=True)
    email = db.Column(db.String(255), unique=True)
    password = db.Column(db.String(60))

    def __init__(self, username, email, password=None, openid=None):
        self.username = username
        self.email = email

        if password:
            self.set_password(password)

        if openid:
            self.openid = openid

    def __repr__(self):
        return '<User {0}>'.format(self.username)

    def set_password(self, password):
        self.password = bcrypt.hashpw(password, bcrypt.gensalt())

    def check_password(self, password):
        return bcrypt.hashpw(password, self.password) == self.password


class OpenID(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    url = db.Column(db.String())
    created = db.Column(db.DateTime)

    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    user = db.relationship('User',
            backref=db.backref('openids', lazy='dynamic'))

    def __init__(self, user, url):
        self.created = datetime.utcnow()
        self.user = user
        self.url = url


class Item(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String())
    url = db.Column(db.String(), unique=True)
    created = db.Column(db.DateTime)

    site_id = db.Column(db.Integer, db.ForeignKey('site.id'))
    site = db.relationship('Site',
            backref=db.backref('items', lazy='dynamic'))

    def __init__(self, url, title, site=None):
        if site:
            self.site = site

        self.title = title
        self.url = url

        self.created = datetime.utcnow()

    def __repr__(self):
        return '<Item {0} ({1})>'.format(
                self.url,
                self.site.owner.username if self.site else None)

    def as_dict(self):
        me = {
                'id': self.id,
                'title': self.title,
                'url': self.url,
                'created': self.created.isoformat()}
        if self.site:
            me.update({'owner': self.site.owner.id})

        return me


class Site(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    created = db.Column(db.DateTime)
    domain = db.Column(db.String)

    owner_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    owner = db.relationship('User',
            backref=db.backref('sites', lazy='dynamic'))

    def __init__(self, owner, domain):
        self.owner = owner
        self.domain = domain

        self.created = datetime.utcnow()

    def __repr__(self):
        return '<Site {0} ({1})>'.format(
                self.domain,
                self.owner.username)


class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    created = db.Column(db.DateTime)
    text = db.Column(db.String())

    item_id = db.Column(db.Integer, db.ForeignKey('item.id'))
    item = db.relationship('Item',
            backref=db.backref('comments', lazy='dynamic'))

    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    user = db.relationship('User',
            backref=db.backref('comments', lazy='dynamic'))

    reply_to_id = db.Column(db.Integer, db.ForeignKey('comment.id'))
    reply_to = db.relationship('Comment', remote_side=[id],
            backref=db.backref('replies', lazy='dynamic'))

    def __init__(self, item, user, text, reply_to=None):
        self.item = item
        self.user = user
        self.text = text

        if reply_to:
            if reply_to is int:
                self.reply_to_id = reply_to
            else:
                self.reply_to = reply_to

        self.created = datetime.utcnow()

    def __repr__(self):
        return '<Comment {0} ({1})>'.format(
                self.text[:25] + ('...' if len(self.text) > 25 else ''),
                self.user.username)

    def as_dict(self):
        me = {
                'id': self.id,
                'item': self.item.id,
                'user_id': self.user.id,
                'username': self.user.username,
                'text': self.text,
                'html': parse_comment(self.text),
                'reply_to': self.reply_to_id,
                'created': self.created.isoformat()}
        return me

MODELS = [
        User,
        Comment,
        Item,
        OpenID,
        Site]

########NEW FILE########
__FILENAME__ = views
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from flask import g, flash, request, url_for, redirect, render_template

from talkatv import app, db
from talkatv.decorators import require_active_login
from talkatv.forms import ProfileForm, ChangePasswordForm
from talkatv.models import OpenID, User


@app.route('/profile/edit', methods=['GET', 'POST'])
@require_active_login()
def edit_profile():
    '''
    Edit profile

    - Save profile data
    - Add OpenID
    '''
    form = ProfileForm()

    if form.validate_on_submit():
        openid = OpenID.query.filter_by(url=form.openid.data).first()

        if not openid and form.openid.data:
            openid = OpenID(g.user, form.openid.data)

        if form.username.data and not form.username.data == g.user.username:
            g.user.username = form.username.data
            flash('Your username has been changed to {0}'.format(
                form.username.data),
                    'info')

        if form.email.data and not form.email.data == g.user.email:
            g.user.email = form.email.data
            flash('Your email has been changed to {0}'.format(form.email.data), 'info')

        db.session.commit()
        return redirect(url_for('edit_profile'))

    else:
        form.username.data = request.args.get('username',
                getattr(g.user, 'username', form.username.data))
        form.email.data = request.args.get('email',
                getattr(g.user, 'email', form.email.data))

        if not g.user.openids.count():
            form.openid.data = request.args.get('openid', form.openid.data)
        else:
            form.openid.data = request.args.get('openid',
                g.user.openids.first().url)

    return render_template('talkatv/profile/edit.html', form=form)


@app.route('/profile/change-password', methods=['GET', 'POST'])
@require_active_login()
def change_password():
    form = ChangePasswordForm()

    if form.validate_on_submit():
        if g.user.password is None or \
                g.user.check_password(form.password.data):
            g.user.set_password(form.new_password.data)

            db.session.commit()

            flash('Your password has been changed!', 'success')
            return redirect(url_for('change_password'))

    return render_template('talkatv/profile/change-password.html', form=form)

########NEW FILE########
__FILENAME__ = views
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from flask import request

from magicsig import Envelope
from lxml import etree
from xml.etree import ElementTree
from StringIO import StringIO

from talkatv import app
from talkatv.tools.cors import jsonify, allow_all_origins


@app.route('/salmon/replies', methods=['POST'])
def salmon_all():
    '''
    Salmon endpoint. See http://www.salmon-protocol.org/
    '''
    # Parse the salmon slap
    envelope = Envelope(
            document=request.data,
            mime_type=request.headers['content-type'])

    # Get the xml.etree.ElementTree for the published entry
    slap_xml = envelope.GetParsedData()
    slap_xml = etree.parse(
            StringIO(ElementTree.tostring(slap_xml.getroot())))

    root_em = slap_xml.getroot()

    ATOM_NS = '{http://www.w3.org/2005/Atom}'

    comment = {
            'author_name': root_em.find(ATOM_NS + 'author').find(
                ATOM_NS + 'name').text,
            'author_uri': root_em.find(ATOM_NS + 'author').find(
                ATOM_NS + 'uri').text,
            'id': root_em.find(ATOM_NS + 'id').text,
            'content': root_em.find(ATOM_NS + 'content').text,
            'title': root_em.find(ATOM_NS + 'title').text,
            'updated': root_em.find(ATOM_NS + 'updated').text}

    return jsonify(_allow_origin_cb=allow_all_origins, **comment)

########NEW FILE########
__FILENAME__ = forms
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import re

from flask.ext.wtf import Form, html5, TextField, validators


class SiteForm(Form):
    domain = TextField('Domain', [validators.Required()])

    def __init__(self, *args, **kw):
        Form.__init__(self, *args, **kw)

    def validate(self):
        if not Form.validate(self):
            return False

        if not re.match(r'^[a-z0-9.-]+$', self.domain.data):
            self.domain.errors.append(
                    'The domain name may only contain alphanumeric\
                    characters and hyphens or dots.')

            return False

        if not '.' in self.domain.data:
            self.domain.errors.append(
                    'Valid domains usually have at least one dot (.) in them')
            return False

        return True

########NEW FILE########
__FILENAME__ = views
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from flask import g, render_template, flash

from talkatv.decorators import require_active_login
from talkatv.site.forms import SiteForm
from talkatv.models import Site, Item
from talkatv import app, db


@app.route('/site/add', methods=['GET', 'POST'])
@require_active_login()
def add_site():
    form = SiteForm()

    if form.validate_on_submit():
        site = Site(g.user, form.domain.data)

        items = Item.query.filter(Item.url.ilike('%{0}%'.format(
            form.domain.data)))

        for item in items.all():
            item.site = site
            db.session.commit()

        flash('''Site added, {0} items registered
        as belonging to the domain'''.format(items.count()))

        db.session.add(site)
        db.session.commit()

    return render_template('talkatv/site/add.html', form=form)

@app.route('/site/list')
@require_active_login()
def list_sites():
    sites = Site.query.filter(Site.owner==g.user).all()

    return render_template('talkatv/site/list.html', sites=sites)

########NEW FILE########
__FILENAME__ = auth
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from flask import g, session


def set_active_user(user):
    '''
    Set the active user
    '''
    g.user = user
    session['user_id'] = user.id
    return True

########NEW FILE########
__FILENAME__ = cors
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from urlparse import urlparse, urlunparse

import flask

from flask import request
from talkatv import app


def jsonify(_allow_origin_cb=None, **kw):
    response = flask.jsonify(**kw)

    callback = request.args.get('callback')

    if callback:
        response.response.insert(0, '{0}('.format(callback))
        response.response.append(');')

    if _allow_origin_cb and 'Origin' in request.headers:
        origin = _allow_origin_cb(request.headers['Origin'])
        if origin:
            response.headers['Access-Control-Allow-Origin'] = origin
    else:
        response.headers['Access-Control-Allow-Origin'] = \
                app.config['CORS_ALLOW_ORIGIN']

    response.headers['Access-Control-Allow-Credentials'] = \
            app.config['CORS_ALLOW_CREDENTIALS']
    response.headers['Access-Control-Max-Age'] = \
            app.config['CORS_MAX_AGE']
    response.headers['Access-Control-Allow-Headers'] = \
            app.config['CORS_ALLOW_HEADERS']
    response.headers['Access-Control-Allow-Methods'] = \
            app.config['CORS_ALLOW_METHODS']

    return response


def allow_all_origins(origin):
    '''
    This can be used to allow all origins, since * is prohibited if you use
    CORS with withCreadentials = true;

    Example:
        desqus.tools.cors.jsonify(_allow_origin_cb=allow_all_origins, **data)
    '''
    app.logger.debug('Allowing origin {0}'.format(origin))
    return origin

########NEW FILE########
__FILENAME__ = redirect
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from urlparse import urlparse, urljoin
from flask import request, url_for, redirect
from flask.ext.wtf import Form, HiddenField


def is_safe_url(target):
    return True

    # TODO disabled this form for easy redirection, any complications?
    ref_url = urlparse(request.host_url)
    test_url = urlparse(urljoin(request.host_url, target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc


def get_redirect_target():
    for target in request.args.get('next'), request.referrer:
        if not target:
            continue
        if is_safe_url(target):
            return target


class RedirectForm(Form):
    next = HiddenField()

    def __init__(self, *args, **kwargs):
        Form.__init__(self, *args, **kwargs)

        if not self.next.data:
            self.next.data = get_redirect_target() or ''

    def redirect(self, endpoint='index', **values):
        if is_safe_url(self.next.data):
            return redirect(self.next.data)

        target = get_redirect_target()
        return redirect(target or url_for(endpoint, **values))

########NEW FILE########
__FILENAME__ = views
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os

from talkatv import app, oid, db

from flask import render_template, flash, session, url_for, redirect, \
        request, g

from talkatv.forms import LoginForm, RegistrationForm
from talkatv.models import User, Item, OpenID
from talkatv.tools.auth import set_active_user


@app.before_request
def lookup_current_user():
    g.user = None
    if 'user_id' in session:
        user = User.query.filter_by(id=session['user_id']).first()

        if user is None:
            del session['user_id']
        else:
            set_active_user(user)


@app.route('/')
def index():
    return render_template('talkatv/index.html')


if 'SENTRY_PUBLIC_DSN' in app.config:
    from flask import Response

    @app.route('/talkatv.js')
    @app.route('/static/js/talkatv.js')
    def include_raven_js():
        # TODO this is an ugly solution.
        #zepto = open('extlib/zepto/zepto.js').read()
        jquery = open('extlib/jquery/jquery-1.8.1.js').read()
        raven = open('extlib/raven/raven-0.5.2.js').read()
        raven_config = 'Raven.config(\'{0}\');'.format(
                app.config['SENTRY_PUBLIC_DSN'])
        talkatv = open('extlib/talkatv-client/talkatv.js').read()

        response = Response('\n/* -- DIVIDER -- */\n'.join([
            jquery, raven, raven_config, talkatv]))
        response.mimetype = 'application/javascript'
        return response


@app.route('/login', methods=['GET', 'POST'])
@oid.loginhandler
def login():
    if g.user is not None:
        return redirect(url_for('index'))

    form = LoginForm()

    if form.validate_on_submit():
        flash(u'Logged in as {0}'.format(form.user.username), 'info')
        session['user_id'] = form.user.id
        return form.redirect('index')
    elif form.openid.data:
        return oid.try_login(form.openid.data, ask_for=['email', 'nickname'])

    return render_template('talkatv/login.html', form=form)


@oid.after_login
def openid_postlogin(resp):
    openid = OpenID.query.filter_by(url=resp.identity_url).first()

    if openid is not None:
        # Assume that an OpenID is always connected to a user
        user = openid.user

        flash(u'Welcome, {0}!'.format(user.username), 'info')

        set_active_user(user)

        return redirect(oid.get_next_url())

    registered_users = User.query.count()
    tmp_user_handle = 'user{0}'.format(registered_users + 1)

    user = User(tmp_user_handle,
           '{0}@localhost'.format(tmp_user_handle))
    openid = OpenID(user, resp.identity_url)

    db.session.add(user)
    db.session.add(openid)
    db.session.commit()

    flash(u'Please confirm your profile details', 'success')

    set_active_user(user)

    return redirect(url_for('edit_profile', next=oid.get_next_url(),
        username=resp.nickname,
        email=resp.email,
        openid=resp.identity_url))


@app.route('/register', methods=['GET', 'POST'])
def register():
    '''
    Regular user/password registration
    '''
    if g.user:
        return redirect(url_for('index'))

    form = RegistrationForm()

    form.username.data = request.args.get('username', form.username.data)
    form.email.data = request.args.get('email', form.email.data)

    if form.validate_on_submit():
        user = User(form.username.data, form.email.data, form.password.data)

        db.session.add(user)
        db.session.commit()

        set_active_user(user)

        flash(u'Welcome, {0}!'.format(user.username), 'success')

        return redirect(url_for('index'))

    return render_template('talkatv/register.html', form=form)


@app.route('/item/list')
@app.route('/item/list/page/<int:page>')
def item_list(page=1):
    page = Item.query.order_by(Item.created.desc()).paginate(
            page,
            app.config.get('ITEMS_PER_PAGE', 20))

    return render_template('talkatv/item-list.html', items_page=page)


@app.route('/logout')
def logout():
    del session['user_id']
    flash(u'You have been logged out.')
    return redirect(url_for('index'))

########NEW FILE########
__FILENAME__ = _version
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

__version__ = '0.0.1.dev'

########NEW FILE########
__FILENAME__ = wsgi
#!/usr/bin/env python
# talkatv - Commenting backend for static pages
# Copyright (C) 2012  talkatv contributors, see AUTHORS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import logging

from flup.server.fcgi import WSGIServer
from talkatv import app

# Explicitly set app.debug to false, otherwise flask will swallow any exceptions
# that are raised from the app.
app.debug = False

if __name__ == '__main__':
    # Set up logging, even though app.debug is off we'll probably want the logs.
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter(app.debug_log_format))
    app.logger.addHandler(handler)
    app.logger.setLevel(logging.DEBUG)

    app.logger.info('Starting WSGI server on {0}'.format(
        app.config['WSGI_BIND_ADDR']))
    WSGIServer(app, bindAddress=app.config['WSGI_BIND_ADDR']).run()

########NEW FILE########
