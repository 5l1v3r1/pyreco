__FILENAME__ = wamp
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

__all__ = ['ApplicationSession',
           'ApplicationSessionFactory',
           'ApplicationRunner',
           'RouterSession',
           'RouterSessionFactory']

import sys

import asyncio
from asyncio.tasks import iscoroutine
from asyncio import Future

from autobahn.wamp import protocol
from autobahn.websocket.protocol import parseWsUrl
from autobahn.wamp.types import ComponentConfig
from autobahn.asyncio.websocket import WampWebSocketClientFactory



class FutureMixin:
   """
   Mixin for Asyncio style Futures.
   """

   def _create_future(self):
      return Future()

   def _as_future(self, fun, *args, **kwargs):
      try:
         res = fun(*args, **kwargs)
      except Exception as e:
         f = Future()
         f.set_exception(e)
         return f
      else:
         if isinstance(res, Future):
            return res
         elif iscoroutine(res):
            return asyncio.Task(res)
         else:
            f = Future()
            f.set_result(res)
            return f

   def _resolve_future(self, future, value):
      future.set_result(value)

   def _reject_future(self, future, value):
      future.set_exception(value)

   def _add_future_callbacks(self, future, callback, errback):
      def done(f):
         try:
            res = f.result()
            callback(res)
         except Exception as e:
            errback(e)
      return future.add_done_callback(done)

   def _gather_futures(self, futures, consume_exceptions = True):
      return asyncio.gather(*futures, return_exceptions = consume_exceptions)



class ApplicationSession(FutureMixin, protocol.ApplicationSession):
   """
   WAMP application session for asyncio-based applications.
   """


class ApplicationSessionFactory(FutureMixin, protocol.ApplicationSessionFactory):
   """
   WAMP application session factory for asyncio-based applications.
   """
   session = ApplicationSession



class RouterSession(FutureMixin, protocol.RouterSession):
   """
   WAMP router session for asyncio-based applications.
   """


class RouterSessionFactory(FutureMixin, protocol.RouterSessionFactory):
   """
   WAMP router session factory for asyncio-based applications.
   """
   session = RouterSession



class ApplicationRunner:
   """
   This class is a convenience tool mainly for development and quick hosting
   of WAMP application components.

   It can host a WAMP application component in a WAMP-over-WebSocket client
   connecting to a WAMP router.
   """

   def __init__(self, url, realm, extra = None,
      debug = False, debug_wamp = False, debug_app = False):
      """
      Constructor.

      :param url: The WebSocket URL of the WAMP router to connect to (e.g. `ws://somehost.com:8090/somepath`)
      :type url: str
      :param realm: The WAMP realm to join the application session to.
      :type realm: str
      :param extra: Optional extra configuration to forward to the application component.
      :type extra: dict
      :param debug: Turn on low-level debugging.
      :type debug: bool
      :param debug_wamp: Turn on WAMP-level debugging.
      :type debug_wamp: bool
      :param debug_app: Turn on app-level debugging.
      :type debug_app: bool
      """
      self.url = url
      self.realm = realm
      self.extra = extra or dict()
      self.debug = debug
      self.debug_wamp = debug_wamp
      self.debug_app = debug_app
      self.make = None


   def run(self, make):
      """
      Run the application component.

      :param make: A factory that produces instances of :class:`autobahn.asyncio.wamp.ApplicationSession`
                   when called with an instance of :class:`autobahn.wamp.types.ComponentConfig`.
      :type make: callable
      """
      ## 1) factory for use ApplicationSession
      def create():
         cfg = ComponentConfig(self.realm, self.extra)
         try:
            session = make(cfg)
         except Exception:
            ## the app component could not be created .. fatal
            print(traceback.format_exc())
            asyncio.get_event_loop().stop()

         session.debug_app = self.debug_app
         return session

      isSecure, host, port, resource, path, params = parseWsUrl(self.url)
      
      ## 2) create a WAMP-over-WebSocket transport client factory
      transport_factory = WampWebSocketClientFactory(create, url = self.url,
         debug = self.debug, debug_wamp = self.debug_wamp)

      ## 3) start the client
      loop = asyncio.get_event_loop()
      coro = loop.create_connection(transport_factory, host, port)
      loop.run_until_complete(coro)

      ## 4) now enter the asyncio event loop
      loop.run_forever()
      loop.close()

########NEW FILE########
__FILENAME__ = websocket
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ['WebSocketServerProtocol',
           'WebSocketServerFactory',
           'WebSocketClientProtocol',
           'WebSocketClientFactory']

from collections import deque

import asyncio
from asyncio.tasks import iscoroutine
from asyncio import Future

from autobahn.wamp import websocket
from autobahn.websocket import protocol
from autobahn.websocket import http


def yields(value):
   """
   Return True iff the value yields.

   See: http://stackoverflow.com/questions/20730248/maybedeferred-analog-with-asyncio
   """
   return isinstance(value, Future) or iscoroutine(value)



class WebSocketAdapterProtocol(asyncio.Protocol):
   """
   Adapter class for Asyncio WebSocket client and server protocols.
   """

   def connection_made(self, transport):
      self.transport = transport

      self.receive_queue = deque()
      self._consume()

      peer = transport.get_extra_info('peername')
      try:
         self.peer = "%s:%d" % (peer[0], peer[1])
      except:
         ## eg Unix Domain sockets don't have host/port
         self.peer = str(peer)

      self._connectionMade()


   def connection_lost(self, exc):
      self._connectionLost(exc)
      self.transport = None


   def _consume(self):
      self.waiter = Future()

      def process(_):
         while len(self.receive_queue):
            data = self.receive_queue.popleft()
            if self.transport:
               try:
                  self._dataReceived(data)
               except Exception as e:
                  raise e
                  #print("WebSocketAdapterProtocol._consume: {}".format(e))
            else:
               print("WebSocketAdapterProtocol._consume: no transport")
         self._consume()

      self.waiter.add_done_callback(process)


   def data_received(self, data):
      self.receive_queue.append(data)
      if not self.waiter.done():
         self.waiter.set_result(None)


   def _closeConnection(self, abort = False):
      self.transport.close()


   def _onOpen(self):
      res = self.onOpen()
      if yields(res):
         asyncio.async(res)

   def _onMessageBegin(self, isBinary):
      res = self.onMessageBegin(isBinary)
      if yields(res):
         asyncio.async(res)

   def _onMessageFrameBegin(self, length):
      res = self.onMessageFrameBegin(length)
      if yields(res):
         asyncio.async(res)

   def _onMessageFrameData(self, payload):
      res = self.onMessageFrameData(payload)
      if yields(res):
         asyncio.async(res)

   def _onMessageFrameEnd(self):
      res = self.onMessageFrameEnd()
      if yields(res):
         asyncio.async(res)

   def _onMessageFrame(self, payload):
      res = self.onMessageFrame(payload)
      if yields(res):
         asyncio.async(res)

   def _onMessageEnd(self):
      res = self.onMessageEnd()
      if yields(res):
         asyncio.async(res)

   def _onMessage(self, payload, isBinary):
      res = self.onMessage(payload, isBinary)
      if yields(res):
         asyncio.async(res)

   def _onPing(self, payload):
      res = self.onPing(payload)
      if yields(res):
         asyncio.async(res)

   def _onPong(self, payload):
      res = self.onPong(payload)
      if yields(res):
         asyncio.async(res)

   def _onClose(self, wasClean, code, reason):
      res = self.onClose(wasClean, code, reason)
      if yields(res):
         asyncio.async(res)


   def registerProducer(self, producer, streaming):
      raise Exception("not implemented")



class WebSocketServerProtocol(WebSocketAdapterProtocol, protocol.WebSocketServerProtocol):
   """
   Base class for Asyncio WebSocket server protocols.
   """

   def _onConnect(self, request):
      ## onConnect() will return the selected subprotocol or None
      ## or a pair (protocol, headers) or raise an HttpException
      ##
      try:
         res = self.onConnect(request)
         #if yields(res):
         #  res = yield from res
      except http.HttpException as exc:
         self.failHandshake(exc.reason, exc.code)
      except Exception as exc:
         self.failHandshake(http.INTERNAL_SERVER_ERROR[1], http.INTERNAL_SERVER_ERROR[0])
      else:
         self.succeedHandshake(res)



class WebSocketClientProtocol(WebSocketAdapterProtocol, protocol.WebSocketClientProtocol):
   """
   Base class for Asyncio WebSocket client protocols.
   """

   def _onConnect(self, response):
      res = self.onConnect(response)
      if yields(res):
         asyncio.async(res)



class WebSocketAdapterFactory:
   """
   Adapter class for Asyncio WebSocket client and server factories.
   """

   def _log(self, msg):
      print(msg)


   def _callLater(self, delay, fun):
      return self.loop.call_later(delay, fun)


   def __call__(self):
      proto = self.protocol()
      proto.factory = self
      return proto



class WebSocketServerFactory(WebSocketAdapterFactory, protocol.WebSocketServerFactory):
   """
   Base class for Asyncio WebSocket server factories.
   """

   def __init__(self, *args, **kwargs):
      """
      In addition to all arguments to the constructor of
      :class:`autobahn.websocket.protocol.WebSocketServerFactory`,
      you can supply a `loop` keyword argument to specify the
      Asyncio loop to be used.
      """
      if 'loop' in kwargs:
         if kwargs['loop']:
            self.loop = kwargs['loop']
         else:
            self.loop = asyncio.get_event_loop()
         del kwargs['loop']
      else:
         self.loop = asyncio.get_event_loop()

      protocol.WebSocketServerFactory.__init__(self, *args, **kwargs)



class WebSocketClientFactory(WebSocketAdapterFactory, protocol.WebSocketClientFactory):
   """
   Base class for Asyncio WebSocket client factories.
   """

   def __init__(self, *args, **kwargs):
      """
      In addition to all arguments to the constructor of
      :class:`autobahn.websocket.protocol.WebSocketClientFactory`,
      you can supply a `loop` keyword argument to specify the
      Asyncio loop to be used.
      """
      if 'loop' in kwargs:
         if kwargs['loop']:
            self.loop = kwargs['loop']
         else:
            self.loop = asyncio.get_event_loop()
         del kwargs['loop']
      else:
         self.loop = asyncio.get_event_loop()

      protocol.WebSocketClientFactory.__init__(self, *args, **kwargs)



class WampWebSocketServerProtocol(websocket.WampWebSocketServerProtocol, WebSocketServerProtocol):
   pass



class WampWebSocketServerFactory(websocket.WampWebSocketServerFactory, WebSocketServerFactory):

   protocol = WampWebSocketServerProtocol

   def __init__(self, factory, *args, **kwargs):

      if 'serializers' in kwargs:
         serializers = kwargs['serializers']
         del kwargs['serializers']
      else:
         serializers = None

      if 'debug_wamp' in kwargs:
         debug_wamp = kwargs['debug_wamp']
         del kwargs['debug_wamp']
      else:
         debug_wamp = False

      websocket.WampWebSocketServerFactory.__init__(self, factory, serializers, debug_wamp = debug_wamp)

      kwargs['protocols'] = self._protocols

      WebSocketServerFactory.__init__(self, *args, **kwargs)



class WampWebSocketClientProtocol(websocket.WampWebSocketClientProtocol, WebSocketClientProtocol):
   pass



class WampWebSocketClientFactory(websocket.WampWebSocketClientFactory, WebSocketClientFactory):

   protocol = WampWebSocketClientProtocol

   def __init__(self, factory, *args, **kwargs):

      if 'serializers' in kwargs:
         serializers = kwargs['serializers']
         del kwargs['serializers']
      else:
         serializers = None

      if 'debug_wamp' in kwargs:
         debug_wamp = kwargs['debug_wamp']
         del kwargs['debug_wamp']
      else:
         debug_wamp = False

      websocket.WampWebSocketClientFactory.__init__(self, factory, serializers, debug_wamp = debug_wamp)

      kwargs['protocols'] = self._protocols

      WebSocketClientFactory.__init__(self, *args, **kwargs)

########NEW FILE########
__FILENAME__ = choosereactor
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ['install_optimal_reactor','install_reactor']


def install_optimal_reactor():
   """
   Try to install the optimal Twisted reactor for platform.
   """
   import sys

   if 'bsd' in sys.platform or sys.platform.startswith('darwin'):
      try:
         v = sys.version_info
         if v[0] == 1 or (v[0] == 2 and v[1] < 6) or (v[0] == 2 and v[1] == 6 and v[2] < 5):
            raise Exception("Python version too old (%s)" % sys.version)
         from twisted.internet import kqreactor
         kqreactor.install()
      except Exception as e:
         print("""
   WARNING: Running on BSD or Darwin, but cannot use kqueue Twisted reactor.

    => %s

   To use the kqueue Twisted reactor, you will need:

     1. Python >= 2.6.5 or PyPy > 1.8
     2. Twisted > 12.0

   Note the use of >= and >.

   Will let Twisted choose a default reactor (potential performance degradation).
   """ % str(e))
         pass

   if sys.platform in ['win32']:
      try:
         from twisted.application.reactors import installReactor
         installReactor("iocp")
      except Exception as e:
         print("""
   WARNING: Running on Windows, but cannot use IOCP Twisted reactor.

    => %s

   Will let Twisted choose a default reactor (potential performance degradation).
   """ % str(e))

   if sys.platform.startswith('linux'):
      try:
         from twisted.internet import epollreactor
         epollreactor.install()
      except Exception as e:
         print("""
   WARNING: Running on Linux, but cannot use Epoll Twisted reactor.

    => %s

   Will let Twisted choose a default reactor (potential performance degradation).
   """ % str(e))



def install_reactor(explicitReactor = None, verbose = False):
   """
   Install Twisted reactor.

   :param explicitReactor: If provided, install this reactor. Else, install optimal reactor.
   :type explicitReactor: obj
   :param verbose: If `True`, print what happens.
   :type verbose: bool
   """
   import sys

   if explicitReactor:
      ## install explicitly given reactor
      ##
      from twisted.application.reactors import installReactor
      print("Trying to install explicitly specified Twisted reactor '%s'" % explicitReactor)
      try:
         installReactor(explicitReactor)
      except Exception as e:
         print("Could not install Twisted reactor %s%s" % (explicitReactor, ' ["%s"]' % e if verbose else ''))
         sys.exit(1)
   else:
      ## automatically choose optimal reactor
      ##
      if verbose:
         print("Automatically choosing optimal Twisted reactor")
      install_optimal_reactor()

   ## now the reactor is installed, import it
   from twisted.internet import reactor

   if verbose:
      from twisted.python.reflect import qual
      print("Running Twisted reactor %s" % qual(reactor.__class__))

   return reactor

########NEW FILE########
__FILENAME__ = flashpolicy
###############################################################################
##
##  Copyright 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ("FlashPolicyProtocol", "FlashPolicyFactory",)


import re

from twisted.internet.protocol import Protocol, Factory


class FlashPolicyProtocol(Protocol):
   """
   Flash Player 9 (version 9.0.124.0 and above) implements a strict new access
   policy for Flash applications that make Socket or XMLSocket connections to
   a remote host. It now requires the presence of a socket policy file
   on the server.

   We want this to support the Flash WebSockets bridge which is needed for
   older browser, in particular MSIE9/8.

   See:
      * `Autobahn WebSocket fallbacks example <https://github.com/tavendo/AutobahnPython/tree/master/examples/twisted/websocket/echo_wsfallbacks>`_
      * `Flash policy files background <http://www.lightsphere.com/dev/articles/flash_socket_policy.html>`_
   """

   REQUESTPAT = re.compile("^\s*<policy-file-request\s*/>")
   REQUESTMAXLEN = 200
   REQUESTTIMEOUT = 5
   POLICYFILE = """<?xml version="1.0"?><cross-domain-policy><allow-access-from domain="*" to-ports="%d" /></cross-domain-policy>"""

   def __init__(self, allowedPort):
      """
      Ctor.

      :param allowedPort: The port to which Flash player should be allowed to connect.
      :type allowedPort: int
      """
      self.allowedPort = allowedPort
      self.received = ""
      self.dropConnection = None


   def connectionMade(self):
      ## DoS protection
      ##
      def dropConnection():
         self.transport.abortConnection()
         self.dropConnection = None
      self.dropConnection = self.factory.reactor.callLater(FlashPolicyProtocol.REQUESTTIMEOUT, dropConnection)


   def connectionLost(self, reason):
      if self.dropConnection:
         self.dropConnection.cancel()
         self.dropConnection = None


   def dataReceived(self, data):
      self.received += data
      if FlashPolicyProtocol.REQUESTPAT.match(self.received):
         ## got valid request: send policy file
         ##
         self.transport.write(FlashPolicyProtocol.POLICYFILE % self.allowedPort)
         self.transport.loseConnection()
      elif len(self.received) > FlashPolicyProtocol.REQUESTMAXLEN:
         ## possible DoS attack
         ##
         self.transport.abortConnection()
      else:
         ## need more data
         ##
         pass


class FlashPolicyFactory(Factory):

   def __init__(self, allowedPort, reactor = None):
      """
      Ctor.

      :param allowedPort: The port to which Flash player should be allowed to connect.
      :type allowedPort: int
      :param reactor: Twisted reactor to use. If not given, autoimport.
      :type reactor: obj
      """
      ## lazy import to avoid reactor install upon module import
      if reactor is None:
         from twisted.internet import reactor
      self.reactor = reactor

      self.allowedPort = allowedPort


   def buildProtocol(self, addr):
      proto = FlashPolicyProtocol(self.allowedPort)
      proto.factory = self
      return proto

########NEW FILE########
__FILENAME__ = forwarder
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from twisted.python import usage
from twisted.internet.defer import inlineCallbacks
from twisted.internet.protocol import Factory, Protocol
from twisted.internet.endpoints import clientFromString, serverFromString
from twisted.application import service



class DestEndpointForwardingProtocol(Protocol):

   def connectionMade(self):
      #print("DestEndpointForwardingProtocol.connectionMade")
      pass

   def dataReceived(self, data):
      #print("DestEndpointForwardingProtocol.dataReceived: {}".format(data))
      if self.factory._sourceProtocol:
         self.factory._sourceProtocol.transport.write(data)

   def connectionLost(self, reason):
      #print("DestEndpointForwardingProtocol.connectionLost")
      if self.factory._sourceProtocol:
         self.factory._sourceProtocol.transport.loseConnection()



class DestEndpointForwardingFactory(Factory):

   def __init__(self, sourceProtocol):
      self._sourceProtocol = sourceProtocol
      self._proto = None

   def buildProtocol(self, addr):
      self._proto = DestEndpointForwardingProtocol()
      self._proto.factory = self
      return self._proto



class EndpointForwardingProtocol(Protocol):

   @inlineCallbacks
   def connectionMade(self):
      #print("EndpointForwardingProtocol.connectionMade")
      self._destFactory = DestEndpointForwardingFactory(self)
      self._destEndpoint = clientFromString(self.factory.service._reactor,
                                            self.factory.service._destEndpointDescriptor)
      self._destEndpointPort = yield self._destEndpoint.connect(self._destFactory)

   def dataReceived(self, data):
      #print("EndpointForwardingProtocol.dataReceived: {}".format(data))
      if self._destFactory._proto:
         self._destFactory._proto.transport.write(data)

   def connectionLost(self, reason):
      #print("EndpointForwardingProtocol.connectionLost")
      if self._destFactory._proto:
         self._destFactory._proto.transport.loseConnection()



class EndpointForwardingService(service.Service):

   def __init__(self, endpointDescriptor, destEndpointDescriptor, reactor = None):
      if reactor is None:
         from twisted.internet import reactor
      self._reactor = reactor
      self._endpointDescriptor = endpointDescriptor
      self._destEndpointDescriptor = destEndpointDescriptor

   @inlineCallbacks
   def startService(self):
      factory = Factory.forProtocol(EndpointForwardingProtocol)
      factory.service = self
      self._endpoint = serverFromString(self._reactor, self._endpointDescriptor)
      self._endpointPort = yield self._endpoint.listen(factory)

   def stopService(self):
      return self._endpointPort.stopListening()



class Options(usage.Options):
   synopsis = "[options]"
   longdesc = 'Endpoint Forwarder.'
   optParameters = [
      ["endpoint", "e", None, "Source endpoint."],
      ["dest_endpoint", "d", None,"Destination endpoint."]
   ]



def makeService(config):
   service = EndpointForwardingService(config['endpoint'], config['dest_endpoint'])
   return service

########NEW FILE########
__FILENAME__ = rawsocket
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import


__all__= ['WampRawSocketServerProtocol',
          'WampRawSocketClientProtocol',
          'WampRawSocketServerFactory',
          'WampRawSocketClientFactory']

from twisted.python import log
from twisted.internet.protocol import Factory
from twisted.protocols.basic import Int32StringReceiver
from twisted.internet.error import ConnectionDone

from autobahn.wamp.exception import ProtocolError, SerializationError, TransportLost

import binascii



class WampRawSocketProtocol(Int32StringReceiver):
   """
   Base class for WAMP-over-Raw transport mixins.
   """

   def connectionMade(self):
      if self.factory.debug:
         log.msg("WAMP-over-RawSocket connection made")
      try:
         self._session = self.factory._factory()
         self._session.onOpen(self)
      except Exception as e:
         ## Exceptions raised in onOpen are fatal ..
         if self.factory.debug:
            log.msg("ApplicationSession constructor / onOpen raised ({})".format(e))
         self.abort()


   def connectionLost(self, reason):
      if self.factory.debug:
         log.msg("WAMP-over-RawSocket connection lost: reason = '{}'".format(reason))
      try:
         wasClean = isinstance(reason.value, ConnectionDone)
         self._session.onClose(wasClean)
      except Exception as e:
         ## silently ignore exceptions raised here ..
         if self.factory.debug:
            log.msg("ApplicationSession.onClose raised ({})".format(e))
      self._session = None


   def stringReceived(self, payload):
      if self.factory.debug:
         log.msg("RX octets: {}".format(binascii.hexlify(payload)))
      try:         
         msg = self.factory._serializer.unserialize(payload)
         if self.factory.debug:
            log.msg("RX WAMP message: {}".format(msg))
         self._session.onMessage(msg)

      except ProtocolError as e:
         if self.factory.debug:
            log.msg("WAMP Protocol Error ({}) - aborting connection".format(e))
         self.abort()

      except Exception as e:
         if self.factory.debug:
            log.msg("WAMP Internal Error ({}) - aborting connection".format(e))
         self.abort()


   def send(self, msg):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransport.send`
      """
      if self.isOpen():
         if self.factory.debug:
            log.msg("TX WAMP message: {}".format(msg))
         try:
            bytes, _ = self.factory._serializer.serialize(msg)
         except Exception as e:
            ## all exceptions raised from above should be serialization errors ..
            raise SerializationError("Unable to serialize WAMP application payload ({})".format(e))
         else:            
            self.sendString(bytes)
            if self.factory.debug:
               log.msg("TX octets: {}".format(binascii.hexlify(bytes)))
      else:
         raise TransportLost()


   def isOpen(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransport.isOpen`
      """
      return self._session is not None


   def close(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransport.close`
      """
      if self.isOpen():
         self.transport.loseConnection()
      else:
         raise TransportLost()


   def abort(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransport.abort`
      """
      if self.isOpen():
         if hasattr(self.transport, 'abortConnection'):
            ## ProcessProtocol lacks abortConnection()
            self.transport.abortConnection()
         else:
            self.transport.loseConnection()
      else:
         raise TransportLost()



class WampRawSocketServerProtocol(WampRawSocketProtocol):
   """
   Mixin for WAMP-over-RawSocket server transports.
   """



class WampRawSocketClientProtocol(WampRawSocketProtocol):
   """
   Mixin for WAMP-over-RawSocket client transports.
   """



class WampRawSocketFactory(Factory):
   """
   Base class for WAMP-over-RawSocket transport factory mixins.
   """

   def __init__(self, factory, serializer, debug = False):
      """
      :param factory: A callable that produces instances that implement
                      :class:`autobahn.wamp.interfaces.ITransportHandler`
      :type factory: callable
      :param serializer: A WAMP serializer to use. A serializer must implement
                         :class:`autobahn.wamp.interfaces.ISerializer`.
      type serializer: list
      """
      assert(callable(factory))
      self._factory = factory
      self._serializer = serializer
      self.debug = debug



class WampRawSocketServerFactory(WampRawSocketFactory):
   """
   Mixin for WAMP-over-RawSocket server transport factories.
   """
   protocol = WampRawSocketServerProtocol



class WampRawSocketClientFactory(WampRawSocketFactory):
   """
   Mixin for WAMP-over-RawSocket client transport factories.
   """
   protocol = WampRawSocketClientProtocol

########NEW FILE########
__FILENAME__ = resource
###############################################################################
##
##  Copyright (C) 2012-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ("WebSocketResource",
           "HTTPChannelHixie76Aware",
           "WSGIRootResource",)


from zope.interface import implementer

from twisted.protocols.policies import ProtocolWrapper
try:
   from twisted.web.error import NoResource
except:
   ## starting from Twisted 12.2, NoResource has moved
   from twisted.web.resource import NoResource
from twisted.web.resource import IResource, Resource

## The following imports reactor at module level
## See: https://twistedmatrix.com/trac/ticket/6849
from twisted.web.http import HTTPChannel

## .. and this also, since it imports t.w.http
##
from twisted.web.server import NOT_DONE_YET



class HTTPChannelHixie76Aware(HTTPChannel):
   """
   Hixie-76 is deadly broken. It includes 8 bytes of body, but then does not
   set content-length header. This hacked HTTPChannel injects the missing
   HTTP header upon detecting Hixie-76. We need this since otherwise
   Twisted Web will silently ignore the body.

   To use this, set `protocol = HTTPChannelHixie76Aware` on your
   `twisted.web.server.Site <http://twistedmatrix.com/documents/current/api/twisted.web.server.Site.html>`_ instance.

   See:
      * `Autobahn Twisted Web site example <https://github.com/tavendo/AutobahnPython/tree/master/examples/twisted/websocket/echo_site>`_
   """

   def headerReceived(self, line):
      header = line.split(':')[0].lower()
      if header == "sec-websocket-key1" and not self._transferDecoder:
         HTTPChannel.headerReceived(self, "Content-Length: 8")
      HTTPChannel.headerReceived(self, line)



class WSGIRootResource(Resource):
   """
   Root resource when you want a WSGI resource be the default serving
   resource for a Twisted Web site, but have subpaths served by
   different resources.

   This is a hack needed since
   `twisted.web.wsgi.WSGIResource <http://twistedmatrix.com/documents/current/api/twisted.web.wsgi.WSGIResource.html>`_.
   does not provide a `putChild()` method.

   See also:
      * `Autobahn Twisted Web WSGI example <https://github.com/tavendo/AutobahnPython/tree/master/examples/twisted/websocket/echo_wsgi>`_
      * `Original hack <http://blog.vrplumber.com/index.php?/archives/2426-Making-your-Twisted-resources-a-url-sub-tree-of-your-WSGI-resource....html>`_
   """

   def __init__(self, wsgiResource, children):
      """
      Creates a Twisted Web root resource.

      :param wsgiResource:
      :type wsgiResource: Instance of `twisted.web.wsgi.WSGIResource <http://twistedmatrix.com/documents/current/api/twisted.web.wsgi.WSGIResource.html>`_.
      :param children: A dictionary with string keys constituting URL subpaths, and Twisted Web resources as values.
      :type children: dict
      """
      Resource.__init__(self)
      self._wsgiResource = wsgiResource
      self.children = children

   def getChild(self, path, request):
      request.prepath.pop()
      request.postpath.insert(0, path)
      return self._wsgiResource



@implementer(IResource)
class WebSocketResource(object):
   """
   A Twisted Web resource for WebSocket. This resource needs to be instantiated
   with a factory derived from WebSocketServerFactory.
   """

   isLeaf = True

   def __init__(self, factory):
      """
      Ctor.

      :param factory: An instance of :class:`autobahn.twisted.websocket.WebSocketServerFactory`.
      :type factory: obj
      """
      self._factory = factory


   def getChildWithDefault(self, name, request):
      """
      This resource cannot have children, hence this will always fail.
      """
      return NoResource("No such child resource.")


   def putChild(self, path, child):
      """
      This resource cannot have children, hence this is always ignored.
      """
      pass


   def render(self, request):
      """
      Render the resource. This will takeover the transport underlying
      the request, create a WebSocketServerProtocol and let that do
      any subsequent communication.
      """

      ## Create Autobahn WebSocket protocol.
      ##
      protocol = self._factory.buildProtocol(request.transport.getPeer())
      if not protocol:
         ## If protocol creation fails, we signal "internal server error"
         request.setResponseCode(500)
         return ""

      ## Take over the transport from Twisted Web
      ##
      transport, request.transport = request.transport, None

      ## Connect the transport to our protocol. Once #3204 is fixed, there
      ## may be a cleaner way of doing this.
      ## http://twistedmatrix.com/trac/ticket/3204
      ##
      if isinstance(transport, ProtocolWrapper):
         ## i.e. TLS is a wrapping protocol
         transport.wrappedProtocol = protocol
      else:
         transport.protocol = protocol
      protocol.makeConnection(transport)

      ## We recreate the request and forward the raw data. This is somewhat
      ## silly (since Twisted Web already did the HTTP request parsing
      ## which we will do a 2nd time), but it's totally non-invasive to our
      ## code. Maybe improve this.
      ##
      data = "%s %s HTTP/1.1\x0d\x0a" % (request.method, request.uri)
      for h in request.requestHeaders.getAllRawHeaders():
         data += "%s: %s\x0d\x0a" % (h[0], ",".join(h[1]))
      data += "\x0d\x0a"
      data += request.content.read() # we need this for Hixie-76
      protocol.dataReceived(data)

      return NOT_DONE_YET

########NEW FILE########
__FILENAME__ = util
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from twisted.internet.defer import Deferred


def sleep(delay, reactor = None):
   """
   Inline sleep for use in Twisted inlineCallbacks.
   """
   if not reactor:
      from twisted.internet import reactor
   d = Deferred()
   reactor.callLater(delay, d.callback, None)
   return d

########NEW FILE########
__FILENAME__ = wamp
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

__all__ = ['ApplicationSession',
           'ApplicationSessionFactory',
           'ApplicationRunner',
           'RouterSession',
           'RouterSessionFactory']

import sys

from twisted.python import log
from twisted.internet.defer import Deferred, maybeDeferred, DeferredList
from twisted.internet.endpoints import clientFromString

from autobahn.wamp import protocol
from autobahn.websocket.protocol import parseWsUrl
from autobahn.wamp.types import ComponentConfig
from autobahn.twisted.websocket import WampWebSocketClientFactory



class FutureMixin:
   """
   Mixin for Twisted style Futures ("Deferreds").
   """

   def _create_future(self):
      return Deferred()

   def _as_future(self, fun, *args, **kwargs):
      return maybeDeferred(fun, *args, **kwargs)

   def _resolve_future(self, future, value):
      future.callback(value)

   def _reject_future(self, future, value):
      future.errback(value)

   def _add_future_callbacks(self, future, callback, errback):
      return future.addCallbacks(callback, errback)

   def _gather_futures(self, futures, consume_exceptions = True):
      return DeferredList(futures, consumeErrors = consume_exceptions)



class ApplicationSession(FutureMixin, protocol.ApplicationSession):
   """
   WAMP application session for Twisted-based applications.
   """



class ApplicationSessionFactory(FutureMixin, protocol.ApplicationSessionFactory):
   """
   WAMP application session factory for Twisted-based applications.
   """
   session = ApplicationSession



class RouterSession(FutureMixin, protocol.RouterSession):
   """
   WAMP router session for Twisted-based applications.
   """



class RouterSessionFactory(FutureMixin, protocol.RouterSessionFactory):
   """
   WAMP router session factory for Twisted-based applications.
   """
   session = RouterSession



class ApplicationRunner:
   """
   This class is a convenience tool mainly for development and quick hosting
   of WAMP application components.

   It can host a WAMP application component in a WAMP-over-WebSocket client
   connecting to a WAMP router.
   """

   def __init__(self, url, realm, extra = None,
      debug = False, debug_wamp = False, debug_app = False):
      """
      Constructor.

      :param url: The WebSocket URL of the WAMP router to connect to (e.g. `ws://somehost.com:8090/somepath`)
      :type url: str
      :param realm: The WAMP realm to join the application session to.
      :type realm: str
      :param extra: Optional extra configuration to forward to the application component.
      :type extra: dict
      :param debug: Turn on low-level debugging.
      :type debug: bool
      :param debug_wamp: Turn on WAMP-level debugging.
      :type debug_wamp: bool
      :param debug_app: Turn on app-level debugging.
      :type debug_app: bool
      """
      self.url = url
      self.realm = realm
      self.extra = extra or dict()
      self.debug = debug
      self.debug_wamp = debug_wamp
      self.debug_app = debug_app
      self.make = None


   def run(self, make):
      """
      Run the application component.

      :param make: A factory that produces instances of :class:`autobahn.asyncio.wamp.ApplicationSession`
                   when called with an instance of :class:`autobahn.wamp.types.ComponentConfig`.
      :type make: callable
      """
      from twisted.internet import reactor

      ## 0) start logging to console
      if self.debug or self.debug_wamp or self.debug_app:
         log.startLogging(sys.stdout)

      ## 1) factory for use ApplicationSession
      def create():
         cfg = ComponentConfig(self.realm, self.extra)
         try:
            session = make(cfg)
         except Exception:
            ## the app component could not be created .. fatal
            log.err()
            reactor.stop()

         session.debug_app = self.debug_app
         return session

      isSecure, host, port, resource, path, params = parseWsUrl(self.url)

      ## 2) create a WAMP-over-WebSocket transport client factory
      transport_factory = WampWebSocketClientFactory(create, url = self.url,
         debug = self.debug, debug_wamp = self.debug_wamp)

      ## 3) start the client from a Twisted endpoint
      client = clientFromString(reactor, "tcp:{}:{}".format(host, port))
      client.connect(transport_factory)

      ## 4) now enter the Twisted reactor loop
      reactor.run()

########NEW FILE########
__FILENAME__ = websocket
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

__all__ = ['WebSocketServerProtocol',
           'WebSocketServerFactory',
           'WebSocketClientProtocol',
           'WebSocketClientFactory',
           'WrappingWebSocketServerFactory',
           'WrappingWebSocketClientFactory',
           'listenWS',
           'connectWS',
           'WampWebSocketServerProtocol',
           'WampWebSocketServerFactory',
           'WampWebSocketClientProtocol',
           'WampWebSocketClientFactory']


from base64 import b64encode, b64decode

from zope.interface import implementer

import twisted.internet.protocol
from twisted.internet.defer import maybeDeferred
from twisted.python import log
from twisted.internet.interfaces import ITransport

from autobahn.wamp import websocket
from autobahn.websocket import protocol
from autobahn.websocket import http

from autobahn.websocket.compress import PerMessageDeflateOffer, \
                                        PerMessageDeflateOfferAccept, \
                                        PerMessageDeflateResponse, \
                                        PerMessageDeflateResponseAccept


class WebSocketAdapterProtocol(twisted.internet.protocol.Protocol):
   """
   Adapter class for Twisted WebSocket client and server protocols.
   """

   def connectionMade(self):
      ## the peer we are connected to
      try:
         peer = self.transport.getPeer()
      except:
         ## ProcessProtocols lack getPeer()
         self.peer = "?"
      else:
         try:
            self.peer = "%s:%d" % (peer.host, peer.port)
         except:
            ## eg Unix Domain sockets don't have host/port
            self.peer = str(peer)

      self._connectionMade()

      ## Set "Nagle"
      try:
         self.transport.setTcpNoDelay(self.tcpNoDelay)
      except:
         ## eg Unix Domain sockets throw Errno 22 on this
         pass


   def connectionLost(self, reason):
      self._connectionLost(reason)


   def dataReceived(self, data):
      self._dataReceived(data)


   def _closeConnection(self, abort = False):
      if abort and hasattr(self.transport, 'abortConnection'):
         ## ProcessProtocol lacks abortConnection()
         self.transport.abortConnection()
      else:
         self.transport.loseConnection()


   def _onOpen(self):
      self.onOpen()

   def _onMessageBegin(self, isBinary):
      self.onMessageBegin(isBinary)

   def _onMessageFrameBegin(self, length):
      self.onMessageFrameBegin(length)

   def _onMessageFrameData(self, payload):
      self.onMessageFrameData(payload)

   def _onMessageFrameEnd(self):
      self.onMessageFrameEnd()

   def _onMessageFrame(self, payload):
      self.onMessageFrame(payload)

   def _onMessageEnd(self):
      self.onMessageEnd()

   def _onMessage(self, payload, isBinary):
      self.onMessage(payload, isBinary)

   def _onPing(self, payload):
      self.onPing(payload)

   def _onPong(self, payload):
      self.onPong(payload)

   def _onClose(self, wasClean, code, reason):
      self.onClose(wasClean, code, reason)


   def registerProducer(self, producer, streaming):
      """
      Register a Twisted producer with this protocol.

      Modes: Hybi, Hixie

      :param producer: A Twisted push or pull producer.
      :type producer: object
      :param streaming: Producer type.
      :type streaming: bool
      """
      self.transport.registerProducer(producer, streaming)



class WebSocketServerProtocol(WebSocketAdapterProtocol, protocol.WebSocketServerProtocol):
   """
   Base class for Twisted WebSocket server protocols.
   """

   def _onConnect(self, request):
      ## onConnect() will return the selected subprotocol or None
      ## or a pair (protocol, headers) or raise an HttpException
      ##
      res = maybeDeferred(self.onConnect, request)

      res.addCallback(self.succeedHandshake)

      def forwardError(failure):
         if failure.check(http.HttpException):
            return self.failHandshake(failure.value.reason, failure.value.code)
         else:
            if self.debug:
               self.factory._log("Unexpected exception in onConnect ['%s']" % failure.value)
            return self.failHandshake(http.INTERNAL_SERVER_ERROR[1], http.INTERNAL_SERVER_ERROR[0])

      res.addErrback(forwardError)



class WebSocketClientProtocol(WebSocketAdapterProtocol, protocol.WebSocketClientProtocol):
   """
   Base class for Twisted WebSocket client protocols.
   """

   def _onConnect(self, response):
      self.onConnect(response)



class WebSocketAdapterFactory:
   """
   Adapter class for Twisted WebSocket client and server factories.
   """

   def _log(self, msg):
      log.msg(msg)


   def _callLater(self, delay, fun):
      return self.reactor.callLater(delay, fun)



class WebSocketServerFactory(WebSocketAdapterFactory, protocol.WebSocketServerFactory, twisted.internet.protocol.ServerFactory):
   """
   Base class for Twisted WebSocket server factories.

   .. seealso:: `twisted.internet.protocol.ServerFactory <http://twistedmatrix.com/documents/current/api/twisted.internet.protocol.ServerFactory.html>`_
   """

   def __init__(self, *args, **kwargs):
      """
      In addition to all arguments to the constructor of
      :class:`autobahn.websocket.protocol.WebSocketServerFactory`,
      you can supply a `reactor` keyword argument to specify the
      Twisted reactor to be used.
      """
      ## lazy import to avoid reactor install upon module import
      if 'reactor' in kwargs:
         if kwargs['reactor']:
            self.reactor = kwargs['reactor']
         else:
            from twisted.internet import reactor
            self.reactor = reactor
         del kwargs['reactor']
      else:
         from twisted.internet import reactor
         self.reactor = reactor

      protocol.WebSocketServerFactory.__init__(self, *args, **kwargs)



class WebSocketClientFactory(WebSocketAdapterFactory, protocol.WebSocketClientFactory, twisted.internet.protocol.ClientFactory):
   """
   Base class for Twisted WebSocket client factories.

   .. seealso:: `twisted.internet.protocol.ClientFactory <http://twistedmatrix.com/documents/current/api/twisted.internet.protocol.ClientFactory.html>`_
   """

   def __init__(self, *args, **kwargs):
      """
      In addition to all arguments to the constructor of
      :class:`autobahn.websocket.protocol.WebSocketClientFactory`,
      you can supply a `reactor` keyword argument to specify the
      Twisted reactor to be used.
      """
      ## lazy import to avoid reactor install upon module import
      if 'reactor' in kwargs:
         if kwargs['reactor']:
            self.reactor = kwargs['reactor']
         else:
            from twisted.internet import reactor
            self.reactor = reactor
         del kwargs['reactor']
      else:
         from twisted.internet import reactor
         self.reactor = reactor

      protocol.WebSocketClientFactory.__init__(self, *args, **kwargs)



@implementer(ITransport)
class WrappingWebSocketAdapter:
   """
   An adapter for stream-based transport over WebSocket.

   This follows "websockify" (https://github.com/kanaka/websockify)
   and should be compatible with that.

   It uses WebSocket subprotocol negotiation and 2+ subprotocols:
     - binary (or a compatible subprotocol)
     - base64

   Octets are either transmitted as the payload of WebSocket binary
   messages when using the 'binary' subprotocol (or an alternative
   binary compatible subprotocol), or encoded with Base64
   and then transmitted as the payload of WebSocket text messages when
   using the 'base64' subprotocol.
   """

   def onConnect(self, requestOrResponse):

      ## Negotiate either the 'binary' or the 'base64' WebSocket subprotocol
      ##
      if isinstance(requestOrResponse, protocol.ConnectionRequest):
         request = requestOrResponse
         for p in request.protocols:
            if p in self.factory._subprotocols:
               self._binaryMode = (p != 'base64')
               return p
         raise http.HttpException(http.NOT_ACCEPTABLE[0], "this server only speaks %s WebSocket subprotocols" % self.factory._subprotocols)
      elif isinstance(requestOrResponse, protocol.ConnectionResponse):
         response = requestOrResponse
         if response.protocol not in self.factory._subprotocols:
            self.failConnection(protocol.WebSocketProtocol.CLOSE_STATUS_CODE_PROTOCOL_ERROR, "this client only speaks %s WebSocket subprotocols" % self.factory._subprotocols)
         self._binaryMode = (response.protocol != 'base64')
      else:
         ## should not arrive here
         raise Exception("logic error")

   def onOpen(self):
      self._proto.connectionMade()

   def onMessage(self, payload, isBinary):
      if isBinary != self._binaryMode:
         self.failConnection(protocol.WebSocketProtocol.CLOSE_STATUS_CODE_UNSUPPORTED_DATA, "message payload type does not match the negotiated subprotocol")
      else:
         if not isBinary:
            try:
               payload = b64decode(payload)
            except Exception as e:
               self.failConnection(protocol.WebSocketProtocol.CLOSE_STATUS_CODE_INVALID_PAYLOAD, "message payload base64 decoding error: {}".format(e))
         #print("forwarding payload: {}".format(binascii.hexlify(payload)))
         self._proto.dataReceived(payload)

   def onClose(self, wasClean, code, reason):
      self._proto.connectionLost(None)

   def write(self, data):
      #print("sending payload: {}".format(binascii.hexlify(data)))
      ## part of ITransport
      assert(type(data) == bytes)
      if self._binaryMode:
         self.sendMessage(data, isBinary = True)
      else:
         data = b64encode(data)
         self.sendMessage(data, isBinary = False)

   def writeSequence(self, data):
      ## part of ITransport
      for d in data:
         self.write(data)

   def loseConnection(self):
      ## part of ITransport
      self.sendClose()



class WrappingWebSocketServerProtocol(WrappingWebSocketAdapter, WebSocketServerProtocol):
   """
   Server protocol for stream-based transport over WebSocket.
   """



class WrappingWebSocketClientProtocol(WrappingWebSocketAdapter, WebSocketClientProtocol):
   """
   Client protocol for stream-based transport over WebSocket.
   """



class WrappingWebSocketServerFactory(WebSocketServerFactory):
   """
   Wrapping server factory for stream-based transport over WebSocket.
   """

   def __init__(self,
                factory,
                url,
                reactor = None,
                enableCompression = True,
                autoFragmentSize = 0,
                subprotocol = None,
                debug = False):
      """
      Constructor.

      :param factory: Stream-based factory to be wrapped.
      :type factory: A subclass of `twisted.internet.protocol.Factory`
      :param url: WebSocket URL of the server this server factory will work for.
      :type url: str
      """
      self._factory = factory
      self._subprotocols = ['binary', 'base64']
      if subprotocol:
          self._subprotocols.append(subprotocol)

      WebSocketServerFactory.__init__(self,
         url = url,
         reactor = reactor,
         protocols = self._subprotocols,
         debug = debug)

      ## automatically fragment outgoing traffic into WebSocket frames
      ## of this size
      self.setProtocolOptions(autoFragmentSize = autoFragmentSize)

      ## play nice and perform WS closing handshake
      self.setProtocolOptions(failByDrop = False)

      if enableCompression:
         ## Enable WebSocket extension "permessage-deflate".
         ##

         ## Function to accept offers from the client ..
         def accept(offers):
            for offer in offers:
               if isinstance(offer, PerMessageDeflateOffer):
                  return PerMessageDeflateOfferAccept(offer)

         self.setProtocolOptions(perMessageCompressionAccept = accept)


   def buildProtocol(self, addr):
      proto = WrappingWebSocketServerProtocol()
      proto.factory = self
      proto._proto = self._factory.buildProtocol(addr)
      proto._proto.transport = proto
      return proto


   def startFactory(self):
      self._factory.startFactory()
      WebSocketServerFactory.startFactory(self)


   def stopFactory(self):
      self._factory.stopFactory()
      WebSocketServerFactory.stopFactory(self)



class WrappingWebSocketClientFactory(WebSocketClientFactory):
   """
   Wrapping client factory for stream-based transport over WebSocket.
   """

   def __init__(self,
                factory,
                url,
                reactor = None,
                enableCompression = True,
                autoFragmentSize = 0,
                subprotocol = None,
                debug = False):
      """
      Constructor.

      :param factory: Stream-based factory to be wrapped.
      :type factory: A subclass of `twisted.internet.protocol.Factory`
      :param url: WebSocket URL of the server this client factory will connect to.
      :type url: str
      """
      self._factory = factory
      self._subprotocols = ['binary', 'base64']
      if subprotocol:
          self._subprotocols.append(subprotocol)

      WebSocketClientFactory.__init__(self,
         url = url,
         reactor = reactor,
         protocols = self._subprotocols,
         debug = debug)

      ## automatically fragment outgoing traffic into WebSocket frames
      ## of this size
      self.setProtocolOptions(autoFragmentSize = autoFragmentSize)

      ## play nice and perform WS closing handshake
      self.setProtocolOptions(failByDrop = False)

      if enableCompression:
         ## Enable WebSocket extension "permessage-deflate".
         ##

         ## The extensions offered to the server ..
         offers = [PerMessageDeflateOffer()]
         self.setProtocolOptions(perMessageCompressionOffers = offers)

         ## Function to accept responses from the server ..
         def accept(response):
            if isinstance(response, PerMessageDeflateResponse):
               return PerMessageDeflateResponseAccept(response)

         self.setProtocolOptions(perMessageCompressionAccept = accept)


   def buildProtocol(self, addr):
      proto = WrappingWebSocketClientProtocol()
      proto.factory = self
      proto._proto = self._factory.buildProtocol(addr)
      proto._proto.transport = proto
      return proto



def connectWS(factory, contextFactory = None, timeout = 30, bindAddress = None):
   """
   Establish WebSocket connection to a server. The connection parameters like target
   host, port, resource and others are provided via the factory.

   :param factory: The WebSocket protocol factory to be used for creating client protocol instances.
   :type factory: An :class:`autobahn.websocket.WebSocketClientFactory` instance.
   :param contextFactory: SSL context factory, required for secure WebSocket connections ("wss").
   :type contextFactory: A `twisted.internet.ssl.ClientContextFactory <http://twistedmatrix.com/documents/current/api/twisted.internet.ssl.ClientContextFactory.html>`_ instance.
   :param timeout: Number of seconds to wait before assuming the connection has failed.
   :type timeout: int
   :param bindAddress: A (host, port) tuple of local address to bind to, or None.
   :type bindAddress: tuple

   :returns: obj -- An object which implements `twisted.interface.IConnector <http://twistedmatrix.com/documents/current/api/twisted.internet.interfaces.IConnector.html>`_.
   """
   ## lazy import to avoid reactor install upon module import
   if hasattr(factory, 'reactor'):
      reactor = factory.reactor
   else:
      from twisted.internet import reactor

   if factory.proxy is not None:
      if factory.isSecure:
         raise Exception("WSS over explicit proxies not implemented")
      else:
         conn = reactor.connectTCP(factory.proxy['host'], factory.proxy['port'], factory, timeout, bindAddress)
   else:
      if factory.isSecure:
         if contextFactory is None:
            # create default client SSL context factory when none given
            from twisted.internet import ssl
            contextFactory = ssl.ClientContextFactory()
         conn = reactor.connectSSL(factory.host, factory.port, factory, contextFactory, timeout, bindAddress)
      else:
         conn = reactor.connectTCP(factory.host, factory.port, factory, timeout, bindAddress)
   return conn



def listenWS(factory, contextFactory = None, backlog = 50, interface = ''):
   """
   Listen for incoming WebSocket connections from clients. The connection parameters like
   listening port and others are provided via the factory.

   :param factory: The WebSocket protocol factory to be used for creating server protocol instances.
   :type factory: An :class:`autobahn.websocket.WebSocketServerFactory` instance.
   :param contextFactory: SSL context factory, required for secure WebSocket connections ("wss").
   :type contextFactory: A twisted.internet.ssl.ContextFactory.
   :param backlog: Size of the listen queue.
   :type backlog: int
   :param interface: The interface (derived from hostname given) to bind to, defaults to '' (all).
   :type interface: str

   :returns: obj -- An object that implements `twisted.interface.IListeningPort <http://twistedmatrix.com/documents/current/api/twisted.internet.interfaces.IListeningPort.html>`_.
   """
   ## lazy import to avoid reactor install upon module import
   if hasattr(factory, 'reactor'):
      reactor = factory.reactor
   else:
      from twisted.internet import reactor

   if factory.isSecure:
      if contextFactory is None:
         raise Exception("Secure WebSocket listen requested, but no SSL context factory given")
      listener = reactor.listenSSL(factory.port, factory, contextFactory, backlog, interface)
   else:
      listener = reactor.listenTCP(factory.port, factory, backlog, interface)
   return listener



class WampWebSocketServerProtocol(websocket.WampWebSocketServerProtocol, WebSocketServerProtocol):
   pass



class WampWebSocketServerFactory(websocket.WampWebSocketServerFactory, WebSocketServerFactory):

   protocol = WampWebSocketServerProtocol

   def __init__(self, factory, *args, **kwargs):

      if 'serializers' in kwargs:
         serializers = kwargs['serializers']
         del kwargs['serializers']
      else:
         serializers = None

      if 'debug_wamp' in kwargs:
         debug_wamp = kwargs['debug_wamp']
         del kwargs['debug_wamp']
      else:
         debug_wamp = False

      websocket.WampWebSocketServerFactory.__init__(self, factory, serializers, debug_wamp = debug_wamp)

      kwargs['protocols'] = self._protocols

      WebSocketServerFactory.__init__(self, *args, **kwargs)



class WampWebSocketClientProtocol(websocket.WampWebSocketClientProtocol, WebSocketClientProtocol):
   pass



class WampWebSocketClientFactory(websocket.WampWebSocketClientFactory, WebSocketClientFactory):

   protocol = WampWebSocketClientProtocol

   def __init__(self, factory, *args, **kwargs):

      if 'serializers' in kwargs:
         serializers = kwargs['serializers']
         del kwargs['serializers']
      else:
         serializers = None

      if 'debug_wamp' in kwargs:
         debug_wamp = kwargs['debug_wamp']
         del kwargs['debug_wamp']
      else:
         debug_wamp = False

      websocket.WampWebSocketClientFactory.__init__(self, factory, serializers, debug_wamp = debug_wamp)

      kwargs['protocols'] = self._protocols

      WebSocketClientFactory.__init__(self, *args, **kwargs)

########NEW FILE########
__FILENAME__ = util
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

__all__ = ("utcnow",
           "parseutc",
           "utcstr",
           "id",
           "newid",
           "rtime",
           "Stopwatch",
           "Tracker",)


import time
import random
import sys
from datetime import datetime
from pprint import pformat



def utcnow():
   """
   Get current time in UTC as ISO 8601 string.

   :returns str -- Current time as string in ISO 8601 format.
   """
   now = datetime.utcnow()
   return now.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z"



def utcstr(ts):
   """
   Format UTC timestamp in ISO 8601 format.

   :param ts: Timestamp.
   :type ts: instance of datetime.
   :returns str -- Timestamp formatted in ISO 8601 format.
   """
   if ts:
      return ts.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z"
   else:
      return ts



def parseutc(s):
   """
   Parse an ISO 8601 combined date and time string, like i.e. 2011-11-23T12:23Z
   into a UTC datetime instance.

   @deprecated: Use the iso8601 module (eg, iso8601.parse_date("2014-05-23T13:03:44.123Z"))
   """
   try:
      return datetime.strptime(s, "%Y-%m-%dT%H:%M:%SZ")
   except:
      return None



def id():
   """
   Generate a new random object ID from range [0, 2**53]. The upper bound 2**53
   is chosen since it is the maximum integer that can be represented as
   a IEEE double such that all smaller integers are representable as well.
   Hence, IDs can be safely used with languages that use IEEE double as their
   main (or only) number type (JavaScript, Lua, ..).
   """
   return random.randint(0, 9007199254740992)



def newid(len = 16):
   """
   Generate a new random object ID.
   """
   return ''.join([random.choice("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_") for i in xrange(len)])



## Select the most precise walltime measurement function available
## on the platform
##
if sys.platform.startswith('win'):
   ## On Windows, this function returns wall-clock seconds elapsed since the
   ## first call to this function, as a floating point number, based on the
   ## Win32 function QueryPerformanceCounter(). The resolution is typically
   ## better than one microsecond
   rtime = time.clock
   _ = rtime()
else:
   ## On Unix-like platforms, this used the first available from this list:
   ## (1) gettimeofday() -- resolution in microseconds
   ## (2) ftime() -- resolution in milliseconds
   ## (3) time() -- resolution in seconds
   rtime = time.time



class Stopwatch:
   """
   Stopwatch based on walltime. Can be used to do code timing and uses the
   most precise walltime measurement available on the platform. This is
   a very light-weight object, so create/dispose is very cheap.
   """

   def __init__(self, start = True):
      """
      Creates a new stopwatch and by default immediately starts (= resumes) it.
      """
      self._elapsed = 0
      if start:
         self._started = rtime()
         self._running = True
      else:
         self._started = None
         self._running = False

   def elapsed(self):
      """
      Return total time elapsed in seconds during which the stopwatch was running.
      """
      if self._running:
         now = rtime()
         return self._elapsed + (now - self._started)
      else:
         return self._elapsed

   def pause(self):
      """
      Pauses the stopwatch and returns total time elapsed in seconds during which
      the stopwatch was running.
      """
      if self._running:
         now = rtime()
         self._elapsed += now - self._started
         self._running = False
         return self._elapsed
      else:
         return self._elapsed

   def resume(self):
      """
      Resumes a paused stopwatch and returns total elapsed time in seconds
      during which the stopwatch was running.
      """
      if not self._running:
         self._started = rtime()
         self._running = True
         return self._elapsed
      else:
         now = rtime()
         return self._elapsed + (now - self._started)

   def stop(self):
      """
      Stops the stopwatch and returns total time elapsed in seconds during which
      the stopwatch was (previously) running.
      """
      elapsed = self.pause()
      self._elapsed = 0
      self._started = None
      self._running = False
      return elapsed



class Tracker:

   def __init__(self, tracker, tracked):
      """
      """
      self.tracker = tracker
      self.tracked = tracked
      self._timings = {}
      self._stopwatch = Stopwatch()


   def track(self, key):
      """
      Track elapsed for key.

      :param key: Key under which to track the timing.
      :type key: str
      """
      self._timings[key] = self._stopwatch.elapsed()


   def diff(self, startKey, endKey, format = True):
      """
      Get elapsed difference between two previously tracked keys.

      :param startKey: First key for interval (older timestamp).
      :type startKey: str
      :param endKey: Second key for interval (younger timestamp).
      :type endKey: str
      :param format: If `True`, format computed time period and return string.
      :type format: bool

      :returns: float or str -- Computed time period in seconds (or formatted string).
      """
      if endKey in self._timings and startKey in self._timings:
         d = self._timings[endKey] - self._timings[startKey]
         if format:
            if d < 0.00001: # 10us
               s = "%d ns" % round(d * 1000000000.)
            elif d < 0.01: # 10ms
               s = "%d us" % round(d * 1000000.)
            elif d < 10: # 10s
               s = "%d ms" % round(d * 1000.)
            else:
               s = "%d s" % round(d)
            return s.rjust(8)
         else:
            return d
      else:
         if format:
            return "n.a.".rjust(8)
         else:
            return None


   def __getitem__(self, key):
      return self._timings.get(key, None)


   def __iter__(self):
      return self._timings.__iter__(self)


   def __str__(self):
      return pformat(self._timings)



class EqualityMixin:

   def __eq__(self, other):
      if not isinstance(other, self.__class__):
         return False
      # we only want the actual message data attributes (not eg _serialize)
      for k in self.__dict__:
         if not k.startswith('_'):
            if not self.__dict__[k] == other.__dict__[k]:
               return False
      return True
      #return (isinstance(other, self.__class__) and self.__dict__ == other.__dict__)


   def __ne__(self, other):
      return not self.__eq__(other)

########NEW FILE########
__FILENAME__ = broker
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from autobahn import util
from autobahn.wamp import types
from autobahn.wamp import role
from autobahn.wamp import message
from autobahn.wamp.exception import ApplicationError
from autobahn.wamp.interfaces import IBroker

from autobahn.wamp.message import _URI_PAT_STRICT_NON_EMPTY, _URI_PAT_LOOSE_NON_EMPTY



class Broker:
   """
   Basic WAMP broker, implements :class:`autobahn.wamp.interfaces.IBroker`.
   """

   def __init__(self, realm, options = None):
      """
      Constructor.

      :param realm: The realm this broker is working for.
      :type realm: str
      :param options: Router options.
      :type options: Instance of :class:`autobahn.wamp.types.RouterOptions`.
      """
      self.realm = realm
      self._options = options or types.RouterOptions()

      ## map: session -> set(subscription)
      ## needed for removeSession
      self._session_to_subscriptions = {}

      ## map: session_id -> session
      ## needed for exclude/eligible
      self._session_id_to_session = {}

      ## map: topic -> (subscription, set(session))
      ## needed for PUBLISH and SUBSCRIBE
      self._topic_to_sessions = {}

      ## map: subscription -> (topic, set(session))
      ## needed for UNSUBSCRIBE
      self._subscription_to_sessions = {}

      ## check all topic URIs with strict rules
      self._option_uri_strict = self._options.uri_check == types.RouterOptions.URI_CHECK_STRICT

      ## supported features from "WAMP Advanced Profile"
      self._role_features = role.RoleBrokerFeatures(publisher_identification = True, subscriber_blackwhite_listing = True, publisher_exclusion = True)


   def attach(self, session):
      """
      Implements :func:`autobahn.wamp.interfaces.IBroker.attach`
      """
      assert(session not in self._session_to_subscriptions)

      self._session_to_subscriptions[session] = set()
      self._session_id_to_session[session._session_id] = session


   def detach(self, session):
      """
      Implements :func:`autobahn.wamp.interfaces.IBroker.detach`
      """
      assert(session in self._session_to_subscriptions)

      for subscription in self._session_to_subscriptions[session]:
         topic, subscribers = self._subscription_to_sessions[subscription]
         subscribers.discard(session)
         if not subscribers:
            del self._subscription_to_sessions[subscription]
         _, subscribers = self._topic_to_sessions[topic]
         subscribers.discard(session)
         if not subscribers:
            del self._topic_to_sessions[topic]

      del self._session_to_subscriptions[session]
      del self._session_id_to_session[session._session_id]


   def processPublish(self, session, publish):
      """
      Implements :func:`autobahn.wamp.interfaces.IBroker.processPublish`
      """
      assert(session in self._session_to_subscriptions)

      ## check topic URI
      ##
      if (not self._option_uri_strict and not  _URI_PAT_LOOSE_NON_EMPTY.match(publish.topic)) or \
         (    self._option_uri_strict and not _URI_PAT_STRICT_NON_EMPTY.match(publish.topic)):

         if publish.acknowledge:
            reply = message.Error(message.Publish.MESSAGE_TYPE, publish.request, ApplicationError.INVALID_URI, ["publish with invalid topic URI '{}'".format(publish.topic)])
            session._transport.send(reply)

         return

      if publish.topic in self._topic_to_sessions and self._topic_to_sessions[publish.topic]:

         ## initial list of receivers are all subscribers ..
         ##
         subscription, receivers = self._topic_to_sessions[publish.topic]

         ## filter by "eligible" receivers
         ##
         if publish.eligible:
            eligible = []
            for s in publish.eligible:
               if s in self._session_id_to_session:
                  eligible.append(self._session_id_to_session[s])
            
            receivers = set(eligible) & receivers

         ## remove "excluded" receivers
         ##
         if publish.exclude:
            exclude = []
            for s in publish.exclude:
               if s in self._session_id_to_session:
                  exclude.append(self._session_id_to_session[s])
            if exclude:
               receivers = receivers - set(exclude)

         ## remove publisher
         ##
         if publish.excludeMe is None or publish.excludeMe:
         #   receivers.discard(session) # bad: this would modify our actual subscriber list
            me_also = False
         else:
            me_also = True

      else:
         subscription, receivers, me_also = None, [], False

      publication = util.id()

      ## send publish acknowledge when requested
      ##
      if publish.acknowledge:
         msg = message.Published(publish.request, publication)
         session._transport.send(msg)

      ## if receivers is non-empty, dispatch event ..
      ##
      if receivers:
         if publish.discloseMe:
            publisher = session._session_id
         else:
            publisher = None
         msg = message.Event(subscription,
                             publication,
                             args = publish.args,
                             kwargs = publish.kwargs,
                             publisher = publisher)
         for receiver in receivers:
            if me_also or receiver != session:
               ## the subscribing session might have been lost in the meantime ..
               if receiver._transport:
                  receiver._transport.send(msg)


   def processSubscribe(self, session, subscribe):
      """
      Implements :func:`autobahn.wamp.interfaces.IBroker.processSubscribe`
      """
      assert(session in self._session_to_subscriptions)

      ## check topic URI
      ##
      if (not self._option_uri_strict and not  _URI_PAT_LOOSE_NON_EMPTY.match(subscribe.topic)) or \
         (    self._option_uri_strict and not _URI_PAT_STRICT_NON_EMPTY.match(subscribe.topic)):

         reply = message.Error(message.Subscribe.MESSAGE_TYPE, subscribe.request, ApplicationError.INVALID_URI, ["subscribe for invalid topic URI '{}'".format(subscribe.topic)])

      else:

         if not subscribe.topic in self._topic_to_sessions:
            subscription = util.id()
            self._topic_to_sessions[subscribe.topic] = (subscription, set())

         subscription, subscribers = self._topic_to_sessions[subscribe.topic]

         if not session in subscribers:
            subscribers.add(session)

         if not subscription in self._subscription_to_sessions:
            self._subscription_to_sessions[subscription] = (subscribe.topic, set())

         _, subscribers = self._subscription_to_sessions[subscription]
         if not session in subscribers:
            subscribers.add(session)

         if not subscription in self._session_to_subscriptions[session]:
            self._session_to_subscriptions[session].add(subscription)

         reply = message.Subscribed(subscribe.request, subscription)

      session._transport.send(reply)


   def processUnsubscribe(self, session, unsubscribe):
      """
      Implements :func:`autobahn.wamp.interfaces.IBroker.processUnsubscribe`
      """
      assert(session in self._session_to_subscriptions)

      if unsubscribe.subscription in self._subscription_to_sessions:

         topic, subscribers = self._subscription_to_sessions[unsubscribe.subscription]

         subscribers.discard(session)

         if not subscribers:
            del self._subscription_to_sessions[unsubscribe.subscription]

         _, subscribers = self._topic_to_sessions[topic]

         subscribers.discard(session)

         if not subscribers:
            del self._topic_to_sessions[topic]

         self._session_to_subscriptions[session].discard(unsubscribe.subscription)

         reply = message.Unsubscribed(unsubscribe.request)

      else:
         reply = message.Error(message.Unsubscribe.MESSAGE_TYPE, unsubscribe.request, ApplicationError.NO_SUCH_SUBSCRIPTION)

      session._transport.send(reply)



IBroker.register(Broker)

########NEW FILE########
__FILENAME__ = dealer
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from autobahn import util
from autobahn.wamp import types
from autobahn.wamp import role
from autobahn.wamp import message
from autobahn.wamp.exception import ProtocolError, ApplicationError
from autobahn.wamp.interfaces import IDealer

from autobahn.wamp.message import _URI_PAT_STRICT_NON_EMPTY, _URI_PAT_LOOSE_NON_EMPTY



class Dealer:
   """
   Basic WAMP dealer, implements :class:`autobahn.wamp.interfaces.IDealer`.
   """

   def __init__(self, realm, options):
      """
      Constructor.

      :param realm: The realm this dealer is working for.
      :type realm: str
      :param options: Router options.
      :type options: Instance of :class:`autobahn.wamp.types.RouterOptions`.
      """
      self.realm = realm
      self._options = options or types.RouterOptions()

      ## map: session -> set(registration)
      ## needed for removeSession
      self._session_to_registrations = {}

      ## map: session_id -> session
      ## needed for exclude/eligible
      self._session_id_to_session = {}

      ## map: procedure -> (registration, session)
      self._procs_to_regs = {}

      ## map: registration -> procedure
      self._regs_to_procs = {}

      ## pending callee invocation requests
      self._invocations = {}

      ## check all procedure URIs with strict rules
      self._option_uri_strict = self._options.uri_check == types.RouterOptions.URI_CHECK_STRICT

      ## supported features from "WAMP Advanced Profile"
      self._role_features = role.RoleDealerFeatures(caller_identification = True, progressive_call_results = True)


   def attach(self, session):
      """
      Implements :func:`autobahn.wamp.interfaces.IDealer.attach`
      """
      assert(session not in self._session_to_registrations)

      self._session_to_registrations[session] = set()
      self._session_id_to_session[session._session_id] = session


   def detach(self, session):
      """
      Implements :func:`autobahn.wamp.interfaces.IDealer.detach`
      """
      assert(session in self._session_to_registrations)

      for registration in self._session_to_registrations[session]:
         del self._procs_to_regs[self._regs_to_procs[registration]]
         del self._regs_to_procs[registration]

      del self._session_to_registrations[session]
      del self._session_id_to_session[session._session_id]


   def processRegister(self, session, register):
      """
      Implements :func:`autobahn.wamp.interfaces.IDealer.processRegister`
      """
      assert(session in self._session_to_registrations)

      ## check procedure URI
      ##
      if (not self._option_uri_strict and not  _URI_PAT_LOOSE_NON_EMPTY.match(register.procedure)) or \
         (    self._option_uri_strict and not _URI_PAT_STRICT_NON_EMPTY.match(register.procedure)):

         reply = message.Error(message.Register.MESSAGE_TYPE, register.request, ApplicationError.INVALID_URI, ["register for invalid procedure URI '{}'".format(register.procedure)])

      else:

         if not register.procedure in self._procs_to_regs:
            registration_id = util.id()
            self._procs_to_regs[register.procedure] = (registration_id, session, register.discloseCaller)
            self._regs_to_procs[registration_id] = register.procedure

            self._session_to_registrations[session].add(registration_id)

            reply = message.Registered(register.request, registration_id)
         else:
            reply = message.Error(message.Register.MESSAGE_TYPE, register.request, ApplicationError.PROCEDURE_ALREADY_EXISTS, ["register for already registered procedure URI '{}'".format(register.procedure)])

      session._transport.send(reply)


   def processUnregister(self, session, unregister):
      """
      Implements :func:`autobahn.wamp.interfaces.IDealer.processUnregister`
      """
      assert(session in self._session_to_registrations)

      if unregister.registration in self._regs_to_procs:
         del self._procs_to_regs[self._regs_to_procs[unregister.registration]]
         del self._regs_to_procs[unregister.registration]

         self._session_to_registrations[session].discard(unregister.registration)

         reply = message.Unregistered(unregister.request)
      else:
         reply = message.Error(message.Unregister.MESSAGE_TYPE, unregister.request, ApplicationError.NO_SUCH_REGISTRATION)

      session._transport.send(reply)


   def processCall(self, session, call):
      """
      Implements :func:`autobahn.wamp.interfaces.IDealer.processCall`
      """
      assert(session in self._session_to_registrations)

      ## check procedure URI
      ##
      if (not self._option_uri_strict and not  _URI_PAT_LOOSE_NON_EMPTY.match(call.procedure)) or \
         (    self._option_uri_strict and not _URI_PAT_STRICT_NON_EMPTY.match(call.procedure)):

         reply = message.Error(message.Register.MESSAGE_TYPE, call.request, ApplicationError.INVALID_URI, ["call with invalid procedure URI '{}'".format(call.procedure)])
         session._transport.send(reply)

      else:

         if call.procedure in self._procs_to_regs:
            registration_id, endpoint_session, discloseCaller = self._procs_to_regs[call.procedure]

            request_id = util.id()

            if discloseCaller or call.discloseMe:
               caller = session._session_id
               authid = session._authid
               authrole = session._authrole
               authmethod = session._authmethod
            else:
               caller = None
               authid = None
               authrole = None
               authmethod = None

            invocation = message.Invocation(request_id,
                                            registration_id,
                                            args = call.args,
                                            kwargs = call.kwargs,
                                            timeout = call.timeout,
                                            receive_progress = call.receive_progress,
                                            caller = caller,
                                            authid = authid,
                                            authrole = authrole,
                                            authmethod = authmethod)

            self._invocations[request_id] = (call, session)
            endpoint_session._transport.send(invocation)
         else:
            reply = message.Error(message.Call.MESSAGE_TYPE, call.request, ApplicationError.NO_SUCH_PROCEDURE, ["no procedure '{}' registered".format(call.procedure)])
            session._transport.send(reply)


   def processCancel(self, session, cancel):
      """
      Implements :func:`autobahn.wamp.interfaces.IDealer.processCancel`
      """
      assert(session in self._session_to_registrations)

      raise Exception("not implemented")


   def processYield(self, session, yield_):
      """
      Implements :func:`autobahn.wamp.interfaces.IDealer.processYield`
      """
      assert(session in self._session_to_registrations)

      if yield_.request in self._invocations:
         call_msg, call_session = self._invocations[yield_.request]
         msg = message.Result(call_msg.request, args = yield_.args, kwargs = yield_.kwargs, progress = yield_.progress)

         ## the calling session might have been lost in the meantime ..
         if call_session._transport:
            call_session._transport.send(msg)

         if not yield_.progress:
            del self._invocations[yield_.request]
      else:
         raise ProtocolError("Dealer.onYield(): YIELD received for non-pending request ID {}".format(yield_.request))


   def processInvocationError(self, session, error):
      """
      Implements :func:`autobahn.wamp.interfaces.IDealer.processInvocationError`
      """
      assert(session in self._session_to_registrations)

      if error.request in self._invocations:
         call_msg, call_session = self._invocations[error.request]
         msg = message.Error(message.Call.MESSAGE_TYPE, call_msg.request, error.error, args = error.args, kwargs = error.kwargs)

         ## the calling session might have been lost in the meantime ..
         if call_session._transport:
            call_session._transport.send(msg)

         del self._invocations[error.request]
      else:
         raise ProtocolError("Dealer.onInvocationError(): ERROR received for non-pending request_type {} and request ID {}".format(error.request_type, error.request))



IDealer.register(Dealer)

########NEW FILE########
__FILENAME__ = exception
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from autobahn.wamp import error



class Error(RuntimeError):
   """
   Base class for all exceptions related to WAMP.
   """
   def __init__(self, reason):
      """
      Constructor.

      :param reason: Description of WAMP error that occurred (for logging purposes).
      :type reason: str
      """
      RuntimeError.__init__(self, reason)




class SessionNotReady(Error):
   """
   """



class SerializationError(Error):
   """
   Exception raised when the WAMP serializer could not serialize the
   application payload (args or kwargs for `CALL`, `PUBLISH`, etc).
   """


class ProtocolError(Error):
   """
   Exception raised when WAMP protocol was violated. Protocol errors
   are fatal and are handled by the WAMP implementation. They are
   not supposed to be handled at the application level.
   """



class TransportLost(Error):
   """
   Exception raised when transport was lost or is not connected.
   """
   def __init__(self):
      Error.__init__(self, "WAMP transport lost")



class ApplicationError(Error):
   """
   Base class for all exceptions that can/may be handled
   at the application level.
   """
   NOT_AUTHORIZED             = u"wamp.error.not_authorized"
   INVALID_ARGUMENT           = u"wamp.error.invalid_argument"
   INVALID_URI                = u"wamp.error.invalid_uri"
   DISCLOSE_ME_NOT_ALLOWED    = u"wamp.error.disclose_me.not_allowed"
   PROCEDURE_ALREADY_EXISTS   = u"wamp.error.procedure_already_exists"
   NO_SUCH_REALM              = u"wamp.error.no_such_realm"
   SYSTEM_SHUTDOWN            = u"wamp.error.system_shutdown"
   CLOSE_REALM                = u"wamp.error.close_realm"
   GOODBYE_AND_OUT            = u"wamp.error.goodbye_and_out"
   NO_SUCH_REGISTRATION       = u"wamp.error.no_such_registration"
   NO_SUCH_SUBSCRIPTION       = u"wamp.error.no_such_subscription"
   NO_SUCH_PROCEDURE          = u"wamp.error.no_such_procedure"
   CANCELED                   = u"wamp.error.canceled"

   def __init__(self, error, *args, **kwargs):
      """
      Constructor.

      :param error: The URI of the error that occurred, e.g. `wamp.error.not_authorized`.
      :type error: str
      """
      Exception.__init__(self, *args)
      self.kwargs = kwargs
      self.error = error


   def __str__(self):
      if self.kwargs and 'traceback' in self.kwargs:
         tb = ':\n' + '\n'.join(self.kwargs.pop('traceback')) + '\n'
         self.kwargs['traceback'] = '...'
      else:
         tb = ''
      return "ApplicationError('{}', args = {}, kwargs = {}){}".format(self.error, self.args, self.kwargs, tb)



#class GenericException(Exception)

@error("wamp.error.not_authorized")
class NotAuthorized(Exception):
   """
   Not authorized to perform the respective action.
   """


@error("wamp.error.invalid_topic")
class InvalidTopic(Exception):
   """
   The topic to publish or subscribe to is invalid.
   """


class CallError(ApplicationError):
   """
   Remote procedure call errors.
   """

   def __init__(self, error, problem):
      """
      Constructor.

      :param error: The URI of the error that occurred, e.g. "com.myapp.error.no_such_user".
      :type error: str
      :param problem: Any application-level details for the error that occurred.
      :type problem: obj
      """
      ApplicationError.__init__(self, error)
      self.problem = problem



class CanceledError(ApplicationError):
   """
   Error for canceled calls.
   """

   def __init__(self):
      """
      Constructor.
      """
      ApplicationError.__init__(self, ApplicationError.CANCELED)

########NEW FILE########
__FILENAME__ = http
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import json
from collections import deque

from twisted.python import log
from twisted.web.resource import Resource, NoResource

## Each of the following 2 trigger a reactor import at module level
from twisted.web import http
from twisted.web.server import NOT_DONE_YET

from autobahn.util import newid

from protocol import WampProtocol, parseSubprotocolIdentifier



class WampHttpResourceSessionSend(Resource):
   """
   A Web resource for sending via XHR that is part of a WampHttpResourceSession.
   """

   def __init__(self, parent):
      """
      """
      Resource.__init__(self)

      self._parent = parent
      self._debug = self._parent._parent._debug
      self.reactor = self._parent.reactor


   def render_POST(self, request):
      """
      WAMP message send.
      """
      payload = request.content.read()
      try:
         if self._debug:
            log.msg("WAMP session data received (transport ID %s): %s" % (self._parent._transportid, payload))
         self._parent.onMessage(payload, False)
      except Exception as e:
         request.setHeader('content-type', 'text/plain; charset=UTF-8')
         request.setResponseCode(http.BAD_REQUEST)
         return "could not unserialize WAMP message [%s]" % e

      request.setResponseCode(http.NO_CONTENT)
      self._parent._parent.setStandardHeaders(request)
      request.setHeader('content-type', 'application/json; charset=utf-8')

      self._parent._isalive = True
      return ""



class WampHttpResourceSessionReceive(Resource):
   """
   A Web resource for receiving via XHR that is part of a WampHttpResourceSession.
   """

   def __init__(self, parent):
      """
      """
      Resource.__init__(self)

      self._parent = parent
      self._debug = self._parent._parent._debug
      self.reactor = self._parent._parent.reactor

      self._queue = deque()
      self._request = None
      self._killed = False

      if self._debug:
         def logqueue():
            if not self._killed:
               log.msg("WAMP session send queue length (transport ID %s): %s" % (self._parent._transportid, len(self._queue)))
               if not self._request:
                  log.msg("WAMP session has no XHR poll request (transport ID %s)" % self._parent._transportid)
               self.reactor.callLater(1, logqueue)
         logqueue()


   def queue(self, data):
      self._queue.append(data)
      self._trigger()


   def _kill(self):
      if self._request:
         self._request.finish()
         self._request = None
      self._killed = True


   def _trigger(self):
      if self._request and len(self._queue):

         ## batched sending of queued messages
         ##
         self._request.write('[')

         while len(self._queue) > 0:
            msg = self._queue.popleft()
            self._request.write(msg)
            if len(self._queue):
               self._request.write(',')

         self._request.write(']')

         self._request.finish()
         self._request = None


   def render_POST(self, request):

      self._parent._parent.setStandardHeaders(request)
      request.setHeader('content-type', 'application/json; charset=utf-8')

      self._request = request

      def cancel(err):
         if self._debug:
            log.msg("WAMP session XHR poll request gone (transport ID %s" % self._parent._transportid)
         self._request = None

      request.notifyFinish().addErrback(cancel)

      self._parent._isalive = True
      self._trigger()

      return NOT_DONE_YET



class WampHttpResourceSession(Resource, WampProtocol):
   """
   A Web resource representing an open WAMP session.
   """

   def __init__(self, parent, transportid, serializer):
      """
      Create a new Web resource representing a WAMP session.

      :param parent: The WAMP Web base resource.
      :type parent: Instance of WampHttpResource.
      :param serializer: The WAMP serializer in use for this session.
      :type serializer: An instance of WampSerializer.
      """
      Resource.__init__(self)

      self._parent = parent
      self._debug = self._parent._debug
      self.reactor = self._parent.reactor


      self._transportid = transportid
      self._serializer = serializer

      self._send = WampHttpResourceSessionSend(self)
      self._receive = WampHttpResourceSessionReceive(self)

      self.putChild("send", self._send)
      self.putChild("receive", self._receive)


      killAfter = self._parent._killAfter
      self._isalive = False

      def killIfDead():
         if not self._isalive:
            if self._debug:
               log.msg("killing inactive WAMP session (transport ID %s)" % self._transportid)

            self.onClose(False, 5000, "Session inactive")
            self._receive._kill()
            del self._parent._transports[self._transportid]
         else:
            if self._debug:
               log.msg("WAMP session still alive (transport ID %s)" % self._transportid)

            self._isalive = False
            self.reactor.callLater(killAfter, killIfDead)

      self.reactor.callLater(killAfter, killIfDead)

      if self._debug:
         log.msg("WAMP session resource initialized (transport ID %s)" % self._transportid)

      self.onOpen()


   def sendMessage(self, bytes, isBinary):
      if self._debug:
         log.msg("WAMP session send bytes (transport ID %s): %s" % (self._transportid, bytes))
      self._receive.queue(bytes)



class WampHttpResourceOpen(Resource):
   """
   A Web resource for creating new WAMP sessions.
   """

   def __init__(self, parent):
      """
      """
      Resource.__init__(self)
      self._parent = parent
      self._debug = self._parent._debug
      self.reactor = self._parent.reactor


   def _failRequest(self, request, msg):
      request.setHeader('content-type', 'text/plain; charset=UTF-8')
      request.setResponseCode(http.BAD_REQUEST)
      return msg


   def render_POST(self, request):
      """
      Request to create a new WAMP session.
      """
      self._parent.setStandardHeaders(request)

      payload = request.content.read()

      try:
         options = json.loads(payload)
      except Exception as e:
         return self._failRequest(request, "could not parse WAMP session open request body [%s]" % e)

      if type(options) != dict:
         return self._failRequest(request, "invalid type for WAMP session open request [was '%s', expected dictionary]" % type(options))

      if not options.has_key('protocols'):
         return self._failRequest(request, "missing attribute 'protocols' in WAMP session open request")

      protocol = None
      for p in options['protocols']:
         version, serializerId = parseSubprotocolIdentifier(p)
         if version == 2 and serializerId in self._parent._serializers.keys():
            serializer = self._parent._serializers[serializerId]
            protocol = p
            break

      request.setHeader('content-type', 'application/json; charset=utf-8')

      transportid = newid()

      ## create instance of WampHttpResourceSession or subclass thereof ..
      ##
      self._parent._transports[transportid] = self._parent.protocol(self._parent, transportid, serializer)

      ret = {'transport': transportid, 'protocol': protocol}

      return json.dumps(ret)



class WampHttpResource(Resource):
   """
   A WAMP Web base resource.
   """

   protocol = WampHttpResourceSession


   def __init__(self,
                serializers = None,
                timeout = 10,
                killAfter = 30,
                queueLimitBytes = 128 * 1024,
                queueLimitMessages = 100,
                debug = False,
                reactor = None):
      """
      Create new HTTP WAMP Web resource.

      :param serializers: List of WAMP serializers.
      :type serializers: List of WampSerializer objects.
      :param timeout: XHR polling timeout in seconds.
      :type timeout: int
      :param killAfter: Kill WAMP session after inactivity in seconds.
      :type killAfter: int
      :param queueLimitBytes: Kill WAMP session after accumulation of this many bytes in send queue (XHR poll).
      :type queueLimitBytes: int
      :param queueLimitMessages: Kill WAMP session after accumulation of this many message in send queue (XHR poll).
      :type queueLimitMessages: int
      :param debug: Enable debug logging.
      :type debug: bool
      """
      ## lazy import to avoid reactor install upon module import
      if reactor is None:
         from twisted.internet import reactor
      self.reactor = reactor

      Resource.__init__(self)

      self._debug = debug
      self._timeout = timeout
      self._killAfter = killAfter
      self._queueLimitBytes = queueLimitBytes
      self._queueLimitMessages = queueLimitMessages

      if serializers is None:
         serializers = [WampJsonSerializer()]

      self._serializers = {}
      for ser in serializers:
         self._serializers[ser.SERIALIZER_ID] = ser

      self._transports = {}

      ## <Base URL>/open
      ##
      self.putChild("open", WampHttpResourceOpen(self))

      if self._debug:
         log.msg("WampHttpResource initialized")


   def getChild(self, name, request):
      """
      Returns send/receive resource for transport.

      <Base URL>/<Transport ID>/send
      <Base URL>/<Transport ID>/receive
      """
      if name not in self._transports:
         return NoResource("No WAMP transport '%s'" % name)

      if len(request.postpath) != 1 or request.postpath[0] not in ['send', 'receive']:
         return NoResource("Invalid WAMP transport operation '%s'" % request.postpath[0])

      return self._transports[name]


   def setStandardHeaders(self, request):
      """
      Set standard HTTP response headers.
      """
      origin = request.getHeader("Origin")
      if origin is None or origin == "null":
         origin = "*"
      request.setHeader('access-control-allow-origin', origin)
      request.setHeader('access-control-allow-credentials', 'true')
      request.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0')

      headers = request.getHeader('Access-Control-Request-Headers')
      if headers is not None:
         request.setHeader('Access-Control-Allow-Headers', headers)

########NEW FILE########
__FILENAME__ = interfaces
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import abc
import six



@six.add_metaclass(abc.ABCMeta)
class IObjectSerializer(object):
   """
   Raw Python object serialization and unserialization. Object serializers are
   used by classes implementing WAMP serializers, that is instances of
   :class:`autobahn.wamp.interfaces.ISerializer`.
   """


   @abc.abstractproperty
   def BINARY(self):
      """
      Flag to indicate if serializer requires a binary clean
      transport or if UTF8 transparency is sufficient.
      """


   @abc.abstractmethod
   def serialize(self, obj):
      """
      Serialize an object to a byte string.

      :param obj: Object to serialize.
      :type obj: Any serializable type.

      :returns: str -- Serialized byte string.
      """

   @abc.abstractmethod
   def unserialize(self, bytes):
      """
      Unserialize an object from a byte string.

      :param bytes: Object to serialize.
      :type bytes: Any serializable type.

      :returns: obj -- Any type that can be unserialized.
      """



@six.add_metaclass(abc.ABCMeta)
class IMessage(object):
   """
   A WAMP message.
   """

   @abc.abstractproperty
   def MESSAGE_TYPE(self):
      """
      WAMP message type code.
      """


   @abc.abstractmethod
   def marshal(self):
      """
      Marshal this object into a raw message for subsequent serialization to bytes.

      :returns: list -- The serialized raw message.
      """


   #@abc.abstractstaticmethod ## FIXME: this is Python 3 only
   def parse(wmsg):
      """
      Factory method that parses a unserialized raw message (as returned byte
      :func:`autobahn.interfaces.ISerializer.unserialize`) into an instance
      of this class.

      :returns: obj -- An instance of this class. 
      """
   

   @abc.abstractmethod
   def serialize(self, serializer):
      """
      Serialize this object into a wire level bytestring representation and cache
      the resulting bytestring. If the cache already contains an entry for the given
      serializer, return the cached representation directly.

      :param serializer: The wire level serializer to use.
      :type serializer: An instance that implements :class:`autobahn.interfaces.ISerializer`

      :returns: bytes -- The serialized bytes.
      """


   @abc.abstractmethod
   def uncache(self):
      """
      Resets the serialization cache.
      """


   @abc.abstractmethod
   def __eq__(self, other):
      """
      Message equality. This does an attribute-wise comparison (but skips attributes
      that start with "_").
      """


   @abc.abstractmethod
   def __ne__(self, other):
      """
      Message inequality (just the negate of message equality).
      """


   @abc.abstractmethod
   def __str__(self):
      """
      Returns text representation of this message.

      :returns: str -- Human readable representation (e.g. for logging or debugging purposes).
      """



@six.add_metaclass(abc.ABCMeta)
class ISerializer(object):
   """
   WAMP message serialization and unserialization.
   """

   @abc.abstractproperty
   def MESSAGE_TYPE_MAP(self):
      """
      Mapping of WAMP message type codes to WAMP message classes.
      """


   @abc.abstractproperty
   def SERIALIZER_ID(self):
      """
      The WAMP serialization format ID.
      """


   @abc.abstractmethod
   def serialize(self, message):
      """
      Serializes a WAMP message to bytes to be sent to a transport.

      :param message: An instance that implements :class:`autobahn.wamp.interfaces.IMessage`
      :type message: obj

      :returns: tuple -- A pair `(bytes, isBinary)`.
      """


   @abc.abstractmethod
   def unserialize(self, bytes, isBinary):
      """
      Unserializes bytes from a transport and parses a WAMP message.

      :param bytes: Byte string from wire.
      :type bytes: bytes

      :returns: obj -- An instance that implements :class:`autobahn.wamp.interfaces.IMessage`.
      """



@six.add_metaclass(abc.ABCMeta)
class ITransport(object):
   """
   A WAMP transport is a bidirectional, full-duplex, reliable, ordered,
   message-based channel.
   """

   @abc.abstractmethod
   def send(self, message):
      """
      Send a WAMP message over the transport to the peer. If the transport is
      not open, this raises :class:`autobahn.wamp.exception.TransportLost`.

      :param message: An instance that implements :class:`autobahn.wamp.interfaces.IMessage`
      :type message: obj      
      """


   @abc.abstractmethod
   def isOpen(self):
      """
      Check if the transport is open for messaging.

      :returns: bool -- `True`, if the transport is open.
      """


   @abc.abstractmethod
   def close(self):
      """
      Close the transport regularily. The transport will perform any
      closing handshake if applicable. This should be used for any
      application initiated closing.
      """


   @abc.abstractmethod
   def abort(self):
      """
      Abort the transport abruptly. The transport will be destroyed as
      fast as possible, and without playing nice to the peer. This should
      only be used in case of fatal errors, protocol violations or possible
      detected attacks.
      """



@six.add_metaclass(abc.ABCMeta)
class ITransportHandler(object):

   @abc.abstractmethod
   def onOpen(self, transport):
      """
      Callback fired when transport is open.

      :param transport: An instance that implements :class:`autobahn.wamp.interfaces.ITransport`
      :type transport: obj      
      """


   @abc.abstractmethod
   def onMessage(self, message):
      """
      Callback fired when a WAMP message was received.

      :param message: An instance that implements :class:`autobahn.wamp.interfaces.IMessage`
      :type message: obj
      """


   @abc.abstractmethod
   def onClose(self, wasClean):
      """
      Callback fired when the transport has been closed.

      :param wasClean: Indicates if the transport has been closed regularily.
      :type wasClean: bool
      """



@six.add_metaclass(abc.ABCMeta)
class ISession(object):
   """
   Base interface for WAMP sessions.
   """

   @abc.abstractmethod
   def onConnect(self):
      """
      Callback fired when the transport this session will run over has been established.
      """


   @abc.abstractmethod
   def join(self, realm):
      """
      Attach the session to the given realm. A session is open as soon as it is attached to a realm.
      """


   @abc.abstractmethod
   def onJoin(self, details):
      """
      Callback fired when WAMP session has been established.

      :param details: Session information.
      :type details: Instance of :class:`autobahn.wamp.types.SessionDetails`.
      """


   @abc.abstractmethod
   def leave(self, reason = None, message = None):
      """
      Actively close this WAMP session.

      :param reason: An optional URI for the closing reason.
      :type reason: str
      :param message: An optional (human readable) closing message, intended for
                      logging purposes.
      :type message: str
      """


   @abc.abstractmethod
   def onLeave(self, details):
      """
      Callback fired when WAMP session has is closed

      :param details: Close information.
      :type details: Instance of :class:`autobahn.wamp.types.CloseDetails`.
      """


   @abc.abstractmethod
   def disconnect(self):
      """
      Close the underlying transport.
      """


   @abc.abstractmethod
   def onDisconnect(self):
      """
      Callback fired when underlying transport has been closed.
      """


   @abc.abstractmethod
   def define(self, exception, error = None):
      """
      Defines an exception for a WAMP error in the context of this WAMP session.

      :param exception: The exception class to define an error mapping for.
      :type exception: A class that derives of ``Exception``.
      :param error: The URI (or URI pattern) the exception class should be mapped for.
                    Iff the ``exception`` class is decorated, this must be ``None``.
      :type error: str
      """



class ICaller(ISession):
   """
   Interface for WAMP peers implementing role *Caller*.
   """

   @abc.abstractmethod
   def call(self, procedure, *args, **kwargs):
      """
      Call a remote procedure.

      This will return a Deferred/Future, that when resolved, provides the actual result.

      If the result is a single positional return value, it'll be returned "as-is". If the
      result contains multiple positional return values or keyword return values,
      the result is wrapped in an instance of :class:`autobahn.wamp.types.CallResult`.

      If the call fails, the returned Deferred/Future will be rejected with an instance
      of :class:`autobahn.wamp.exception.ApplicationError`.

      If the *Caller* and *Dealer* implementations support cancelling of calls, the call may
      be canceled by canceling the returned Deferred/Future.

      If ``kwargs`` contains an ``options`` keyword argument that is an instance of
      :class:`autobahn.wamp.types.CallOptions`, this will provide
      specific options for the call to perform.

      :param procedure: The URI of the remote procedure to be called, e.g. `com.myapp.hello`.
      :type procedure: str
      :param args: Any positional arguments for the call.
      :type args: list
      :param kwargs: Any keyword arguments for the call.
      :type kwargs: dict

      :returns: obj -- A Deferred/Future for the call result -
                       an instance of :class:`twisted.internet.defer.Deferred` (when running under Twisted) or
                       an instance of :class:`asyncio.Future` (when running under asyncio).
      """



@six.add_metaclass(abc.ABCMeta)
class IRegistration(object):
   """
   Represents a registration of an endpoint.
   """

   @abc.abstractproperty
   def id(self):
      """
      The WAMP registration ID for this registration.
      """

   @abc.abstractproperty
   def id(self):
      """
      Flag indicating if registration is active.
      """


   @abc.abstractmethod
   def unregister(self):
      """
      Unregister this registration that was previously created from
      :func:`autobahn.wamp.interfaces.ICallee.register`.

      After a registration has been unregistered, calls won't get routed
      to the endpoint any more.

      This will return a Deferred/Future, that when resolved signals
      successful unregistration.

      If the unregistration fails, the returned Deferred/Future will be rejected
      with an instance of :class:`autobahn.wamp.exception.ApplicationError`.

      :returns: obj -- A Deferred/Future for the unregistration -
                       an instance of :class:`twisted.internet.defer.Deferred` (when running under Twisted)
                       or an instance of :class:`asyncio.Future` (when running under asyncio).
      """



class ICallee(ISession):
   """
   Interface for WAMP peers implementing role *Callee*.
   """

   @abc.abstractmethod
   def register(self, endpoint, procedure = None, options = None):
      """
      Register an endpoint for a procedure to (subsequently) receive calls
      calling that procedure.

      If ``endpoint`` is a callable (function, method or object that implements ``__call__``),
      then `procedure` must be provided and an instance of
      :class:`twisted.internet.defer.Deferred` (when running on Twisted) or an instance
      of :class:`asyncio.Future` (when running on asyncio) is returned.

      If the registration succeeds the Deferred/Future will resolve to an object
      that implements :class:`autobahn.wamp.interfaces.Registration`.

      If the registration fails the Deferred/Future will reject with an instance
      of :class:`autobahn.wamp.exception.ApplicationError`.

      If ``endpoint`` is an object, then each of the object's methods that are decorated
      with :func:`autobahn.wamp.procedure` are registered as procedure endpoints, and a list of
      Deferreds/Futures is returned that each resolves or rejects as above.

      :param endpoint: The endpoint or endpoint object called under the procedure.
      :type endpoint: callable
      :param procedure: When `endpoint` is a single event handler, the URI (or URI pattern)
                    of the procedure to register for. When ``endpoint`` is an endpoint
                    object, this value is ignored (and should be ``None``).
      :type procedure: str
      :param options: Options for registering.
      :type options: An instance of :class:`autobahn.wamp.types.RegisterOptions`.

      :returns: obj -- A (list of) Deferred(s)/Future(s) for the registration(s) -
                       instance(s) of :class:`twisted.internet.defer.Deferred` (when
                       running under Twisted) or instance(s) of :class:`asyncio.Future`
                       (when running under asyncio).
      """



@six.add_metaclass(abc.ABCMeta)
class IPublication(object):
   """
   Represents a publication of an event. This is used with acknowledged publications.
   """

   @abc.abstractproperty
   def id(self):
      """
      The WAMP publication ID for this publication.
      """



class IPublisher(ISession):
   """
   Interface for WAMP peers implementing role *Publisher*.
   """

   @abc.abstractmethod
   def publish(self, topic, *args, **kwargs):
      """
      Publish an event to a topic.

      If ``kwargs`` contains an ``options`` keyword argument that is an instance of
      :class:`autobahn.wamp.types.PublishOptions`, this will provide
      specific options for the publish to perform.

      If publication acknowledgement is requested via ``options.acknowledge == True``,
      this function returns a Deferred/Future:

        - if the publication succeeds the Deferred/Future will resolve to an object
          that implements :class:`autobahn.wamp.interfaces.IPublication`.

        - if the publication fails the Deferred/Future will reject with an instance
          of :class:`autobahn.wamp.exception.ApplicationError`.

      :param topic: The URI of the topic to publish to, e.g. `com.myapp.mytopic1`.
      :type topic: str
      :param args: Arbitrary application payload for the event (positional arguments).
      :type args: list
      :param kwargs: Arbitrary application payload for the event (keyword arguments).
      :type kwargs: dict

      :returns: obj -- `None` for non-acknowledged publications or,
                       for acknowledged publications, an instance of
                       :class:`twisted.internet.defer.Deferred` (when running under Twisted)
                       or an instance of :class:`asyncio.Future` (when running under asyncio).
      """



@six.add_metaclass(abc.ABCMeta)
class ISubscription(object):
   """
   Represents a subscription to a topic.
   """

   @abc.abstractproperty
   def id(self):
      """
      The WAMP subscription ID for this subscription.
      """


   @abc.abstractproperty
   def active(self):
      """
      Flag indicating if subscription is active.
      """


   @abc.abstractmethod
   def unsubscribe(self):
      """
      Unsubscribe this subscription that was previously created from
      :func:`autobahn.wamp.interfaces.ISubscriber.subscribe`.

      After a subscription has been unsubscribed, events won't get
      routed to the handler anymore.

      This will return a Deferred/Future, that when resolved signals
      successful unsubscription.

      If the unsubscription fails, the returned Deferred/Future will be rejected
      with an instance of :class:`autobahn.wamp.exception.ApplicationError`.

      :returns: obj -- A Deferred/Future for the unsubscription -
                       an instance of :class:`twisted.internet.defer.Deferred` (when running under Twisted)
                       or an instance of :class:`asyncio.Future` (when running under asyncio).
      """



class ISubscriber(ISession):
   """
   Interface for WAMP peers implementing role *Subscriber*.
   """

   @abc.abstractmethod
   def subscribe(self, handler, topic = None, options = None):
      """
      Subscribe to a topic and subsequently receive events published to that topic.

      If ``handler`` is a callable (function, method or object that implements ``__call__``),
      then `topic` must be provided and an instance of
      :class:`twisted.internet.defer.Deferred` (when running on Twisted) or an instance
      of :class:`asyncio.Future` (when running on asyncio) is returned.

      If the subscription succeeds the Deferred/Future will resolve to an object
      that implements :class:`autobahn.wamp.interfaces.ISubscription`.

      If the subscription fails the Deferred/Future will reject with an instance
      of :class:`autobahn.wamp.exception.ApplicationError`.

      If ``handler`` is an object, then each of the object's methods that are decorated
      with :func:`autobahn.wamp.topic` are subscribed as event handlers, and a list of
      Deferreds/Futures is returned that each resolves or rejects as above.

      :param handler: The event handler or handler object to receive events.
      :type handler: callable or obj
      :param topic: When `handler` is a single event handler, the URI (or URI pattern)
                    of the topic to subscribe to. When `handler` is an event handler
                    object, this value is ignored (and should be `None`).
      :type topic: str
      :param options: Options for subscribing.
      :type options: An instance of :class:`autobahn.wamp.types.SubscribeOptions`.

      :returns: obj -- A (list of) Deferred(s)/Future(s) for the subscription(s) -
                       instance(s) of :class:`twisted.internet.defer.Deferred` (when
                       running under Twisted) or instance(s) of :class:`asyncio.Future`
                       (when running under asyncio).
      """



@six.add_metaclass(abc.ABCMeta)
class IRouterBase(object):

   @abc.abstractproperty
   def factory(self):
      """
      The router factory this router was created from.
      """


   @abc.abstractproperty
   def realm(self):
      """
      The WAMP realm this router handles.
      """


   @abc.abstractmethod
   def attach(self, session):
      """
      Attach a WAMP application session to this router.

      :param session: Application session to add.
      :type session: An instance that implements :class:`autobahn.wamp.interfaces.ISession`
      """


   @abc.abstractmethod
   def detach(self, session):
      """
      Detach a WAMP application session from this router.

      :param session: Application session to remove.
      :type session: An instance that implements :class:`autobahn.wamp.interfaces.ISession`
      """



class IRouter(IRouterBase):

   @abc.abstractmethod
   def process(self, session, message):
      """
      Process a WAMP message received on the given session.

      :param session: Application session to remove.
      :type session: An instance that implements :class:`autobahn.wamp.interfaces.ISession`     
      :param message: An instance that implements :class:`autobahn.wamp.interfaces.IMessage`
      :type message: obj
      """



class IBroker(IRouterBase):
   """
   WAMP broker interface. Brokers are responsible for event routing
   """

   @abc.abstractmethod
   def processPublish(self, session, publish):
      """
      """


   @abc.abstractmethod
   def processSubscribe(self, session, subscribe):
      """
      """


   @abc.abstractmethod
   def processUnsubscribe(self, session, unsubscribe):
      """
      """



class IDealer(IRouterBase):
   """
   WAMP dealer interface. Dealers are responsible for call routing.
   """

   @abc.abstractmethod
   def processRegister(self, session, register):
      """
      """


   @abc.abstractmethod
   def processUnregister(self, session, unregister):
      """
      """


   @abc.abstractmethod
   def processCall(self, session, call):
      """
      """


   @abc.abstractmethod
   def processCancel(self, session, cancel):
      """
      """


   @abc.abstractmethod
   def processYield(self, session, yield_):
      """
      """


   @abc.abstractmethod
   def processInvocationError(self, session, error):
      """
      """



@six.add_metaclass(abc.ABCMeta)
class IRouterFactory(object):

   @abc.abstractmethod
   def get(self, realm):
      """
      Get router for responsible for given realm.
      """

########NEW FILE########
__FILENAME__ = message
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

__all__ = ['Hello',
           'Welcome',
           'Abort',
           'Challenge',
           'Authenticate',
           'Goodbye',
           'Heartbeat'
           'Error',
           'Publish',
           'Published',
           'Subscribe',
           'Subscribed',
           'Unsubscribe',
           'Unsubscribed',
           'Event',
           'Call',
           'Cancel',
           'Result',
           'Register',
           'Registered',
           'Unregister',
           'Unregistered',
           'Invocation',
           'Interrupt',
           'Yield']


import re
import six

import autobahn
from autobahn import util
from autobahn.wamp.exception import ProtocolError
from autobahn.wamp.interfaces import IMessage
from autobahn.wamp.role import ROLE_NAME_TO_CLASS


## strict URI check allowing empty URI components
_URI_PAT_STRICT = re.compile(r"^(([0-9a-z_]{2,}\.)|\.)*([0-9a-z_]{2,})?$")

## loose URI check allowing empty URI components
_URI_PAT_LOOSE = re.compile(r"^(([^\s\.#]+\.)|\.)*([^\s\.#]+)?$")


## strict URI check disallowing empty URI components
_URI_PAT_STRICT_NON_EMPTY = re.compile(r"^([0-9a-z_]{2,}\.)*([0-9a-z_]{2,})?$")

## loose URI check disallowing empty URI components
_URI_PAT_LOOSE_NON_EMPTY = re.compile(r"^([^\s\.#]+\.)*([^\s\.#]+)?$")



def check_or_raise_uri(value, message):
   if type(value) != six.text_type:
      raise ProtocolError("{}: invalid type {} for URI".format(message, type(value)))
   if not _URI_PAT_LOOSE.match(value):
      raise ProtocolError("{}: invalid value '{}' for URI".format(message, value))
   return value



def check_or_raise_id(value, message):
   if type(value) not in six.integer_types:
      raise ProtocolError("{}: invalid type {} for ID".format(message, type(value)))
   if value < 0 or value > 9007199254740992: # 2**53
      raise ProtocolError("{}: invalid value {} for ID".format(message, value))
   return value



def check_or_raise_extra(value, message):
   if type(value) != dict:
      raise ProtocolError("{}: invalid type {}".format(message, type(value)))
   for k in value.keys():
      if type(k) != six.text_type:
         raise ProtocolError("{}: invalid type {} for key '{}'".format(message, type(k), k))
   return value



class Message(util.EqualityMixin):
   """
   WAMP message base class. This is not supposed to be instantiated.
   """

   def __init__(self):
      """
      Base constructor.
      """
      ## serialization cache: mapping from ISerializer instances
      ## to serialized bytes
      ##
      self._serialized = {}


   def uncache(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.uncache`
      """
      self._serialized = {}


   def serialize(self, serializer):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.serialize`
      """
      ## only serialize if not cached ..
      if not serializer in self._serialized:
         self._serialized[serializer] = serializer.serialize(self.marshal())
      return self._serialized[serializer]



IMessage.register(Message)



class Hello(Message):
   """
   A WAMP `HELLO` message.

   Format: `[HELLO, Realm|uri, Details|dict]`
   """

   MESSAGE_TYPE = 1
   """
   The WAMP message code for this type of message.
   """


   def __init__(self, realm, roles, authmethods = None):
      """
      Message constructor.

      :param realm: The URI of the WAMP realm to join.
      :type realm: str
      :param roles: The WAMP roles to announce.
      :type roles: list of :class:`autobahn.wamp.role.RoleFeatures`
      """
      assert(type(realm) == six.text_type)
      assert(type(roles) == list)
      for role in roles:
         assert(isinstance(role, autobahn.wamp.role.RoleFeatures))
      if authmethods:
         assert(type(authmethods) == list)
         for authmethod in authmethods:
            assert(type(authmethod) == six.text_type)

      Message.__init__(self)
      self.realm = realm
      self.roles = roles
      self.authmethods = authmethods


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Hello.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for HELLO".format(len(wmsg)))

      realm = check_or_raise_uri(wmsg[1], "'realm' in HELLO")
      details = check_or_raise_extra(wmsg[2], "'details' in HELLO")

      roles = []

      if not u'roles' in details:
         raise ProtocolError("missing mandatory roles attribute in options in HELLO")

      details_roles = check_or_raise_extra(details[u'roles'], "'roles' in 'details' in HELLO")

      if len(details_roles) == 0:
         raise ProtocolError("empty 'roles' in 'details' in HELLO")

      for role in details_roles:
         if role not in ROLE_NAME_TO_CLASS:
            raise ProtocolError("invalid role '{}' in 'roles' in 'details' in HELLO".format(role))

         details_role = check_or_raise_extra(details_roles[role], "role '{}' in 'roles' in 'details' in HELLO".format(role))

         if u'features' in details_role:
            details_role_features = check_or_raise_extra(details_role[u'features'], "'features' in role '{}' in 'roles' in 'details' in HELLO".format(role))

            ## FIXME: skip unknown attributes
            role_features = ROLE_NAME_TO_CLASS[role](**details_role[u'features'])

         else:
            role_features = ROLE_NAME_TO_CLASS[role]()

         roles.append(role_features)

      authmethods = None
      if u'authmethods' in details:
         details_authmethods = details[u'authmethods']
         if type(details_authmethods) != list:
            raise ProtocolError("invalid type {} for 'authmethods' detail in HELLO".format(type(details_authmethods)))

         for auth_method in details_authmethods:
            if type(auth_method) != six.text_type:
               raise ProtocolError("invalid type {} for item in 'authmethods' detail in HELLO".format(type(auth_method)))

         authmethods = details_authmethods

      obj = Hello(realm, roles, authmethods)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      details = {u'roles': {}}
      for role in self.roles:
         details[u'roles'][role.ROLE] = {}
         for feature in role.__dict__:
            if not feature.startswith('_') and feature != 'ROLE' and getattr(role, feature) is not None:
               if not u'features' in details[u'roles'][role.ROLE]:
                  details[u'roles'][role.ROLE] = {u'features': {}}
               details[u'roles'][role.ROLE][u'features'][six.u(feature)] = getattr(role, feature)

      if self.authmethods:
         details[u'authmethods'] = self.authmethods

      return [Hello.MESSAGE_TYPE, self.realm, details]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP HELLO Message (realm = {}, roles = {}, authmethods = {})".format(self.realm, self.roles, self.authmethods)



class Welcome(Message):
   """
   A WAMP `WELCOME` message.

   Format: `[WELCOME, Session|id, Details|dict]`
   """

   MESSAGE_TYPE = 2
   """
   The WAMP message code for this type of message.
   """


   def __init__(self, session, roles, authid = None, authrole = None, authmethod = None):
      """
      Message constructor.

      :param session: The WAMP session ID the other peer is assigned.
      :type session: int
      """
      assert(type(session) in six.integer_types)
      assert(type(roles) == list)
      for role in roles:
         assert(isinstance(role, autobahn.wamp.role.RoleFeatures))
      assert(authid is None or type(authid) == six.text_type)
      assert(authrole is None or type(authrole) == six.text_type)
      assert(authmethod is None or type(authmethod) == six.text_type)

      Message.__init__(self)
      self.session = session
      self.roles = roles
      self.authid = authid
      self.authrole = authrole
      self.authmethod = authmethod


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Welcome.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for WELCOME".format(len(wmsg)))

      session = check_or_raise_id(wmsg[1], "'session' in WELCOME")
      details = check_or_raise_extra(wmsg[2], "'details' in WELCOME")

      authid = details.get(u'authid', None)
      authrole = details.get(u'authrole', None)
      authmethod = details.get(u'authmethod', None)

      roles = []

      if not u'roles' in details:
         raise ProtocolError("missing mandatory roles attribute in options in WELCOME")

      details_roles = check_or_raise_extra(details['roles'], "'roles' in 'details' in WELCOME")

      if len(details_roles) == 0:
         raise ProtocolError("empty 'roles' in 'details' in WELCOME")

      for role in details_roles:
         if role not in ROLE_NAME_TO_CLASS:
            raise ProtocolError("invalid role '{}' in 'roles' in 'details' in WELCOME".format(role))

         if u'features' in details_roles[role]:
            details_role_features = check_or_raise_extra(details_roles[role][u'features'], "'features' in role '{}' in 'roles' in 'details' in WELCOME".format(role))

            ## FIXME: skip unknown attributes
            role_features = ROLE_NAME_TO_CLASS[role](**details_roles[role][u'features'])

         else:
            role_features = ROLE_NAME_TO_CLASS[role]()

         roles.append(role_features)

      obj = Welcome(session, roles, authid, authrole, authmethod)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      details = {
         u'roles': {}
      }

      if self.authid:
         details[u'authid'] = self.authid

      if self.authrole:
         details[u'authrole'] = self.authrole

      if self.authrole:
         details[u'authmethod'] = self.authmethod

      for role in self.roles:
         details[u'roles'][role.ROLE] = {}
         for feature in role.__dict__:
            if not feature.startswith('_') and feature != 'ROLE' and getattr(role, feature) is not None:
               if not u'features' in details[u'roles'][role.ROLE]:
                  details[u'roles'][role.ROLE] = {u'features': {}}
               details[u'roles'][role.ROLE][u'features'][six.u(feature)] = getattr(role, feature)

      return [Welcome.MESSAGE_TYPE, self.session, details]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP WELCOME Message (session = {}, roles = {}, authid = {}, authrole = {}, authmethod = {})".format(self.session, self.roles, self.authid, self.authrole, self.authmethod)



class Abort(Message):
   """
   A WAMP `ABORT` message.

   Format: `[ABORT, Details|dict, Reason|uri]`
   """

   MESSAGE_TYPE = 3
   """
   The WAMP message code for this type of message.
   """

   def __init__(self, reason, message = None):
      """
      Message constructor.

      :param reason: WAMP or application error URI for aborting reason.
      :type reason: str
      :param message: Optional human-readable closing message, e.g. for logging purposes.
      :type message: str
      """
      assert(type(reason) == six.text_type)
      assert(message is None or type(message) == six.text_type)

      Message.__init__(self)
      self.reason = reason
      self.message = message


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Abort.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for ABORT".format(len(wmsg)))

      details = check_or_raise_extra(wmsg[1], "'details' in ABORT")
      reason = check_or_raise_uri(wmsg[2], "'reason' in ABORT")

      message = None

      if u'message' in details:

         details_message = details[u'message']
         if type(details_message) != six.text_type:
            raise ProtocolError("invalid type {} for 'message' detail in ABORT".format(type(details_message)))

         message = details_message

      obj = Abort(reason, message)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      details = {}
      if self.message:
         details[u'message'] = self.message

      return [Abort.MESSAGE_TYPE, details, self.reason]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP ABORT Message (message = {}, reason = {})".format(self.message, self.reason)



class Challenge(Message):
   """
   A WAMP `CHALLENGE` message.

   Format: `[CHALLENGE, Method|string, Extra|dict]`
   """

   MESSAGE_TYPE = 4
   """
   The WAMP message code for this type of message.
   """


   def __init__(self, method, extra = {}):
      """
      Message constructor.

      :param method: The authentication method.
      :type method: str
      :param extra: Authentication method specific information.
      :type extra: dict
      """
      assert(type(method) == six.text_type)
      assert(type(extra) == dict)

      Message.__init__(self)
      self.method = method
      self.extra = extra


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Challenge.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for CHALLENGE".format(len(wmsg)))

      method = wmsg[1]
      if type(method) != str:
         raise ProtocolError("invalid type {} for 'method' in CHALLENGE".format(type(method)))

      extra = check_or_raise_extra(wmsg[2], "'extra' in CHALLENGE")

      obj = Challenge(method, extra)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      return [Challenge.MESSAGE_TYPE, self.method, self.extra]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP CHALLENGE Message (method = {}, extra = {})".format(self.method, self.extra)



class Authenticate(Message):
   """
   A WAMP `AUTHENTICATE` message.

   Format: `[AUTHENTICATE, Signature|string, Extra|dict]`
   """

   MESSAGE_TYPE = 5
   """
   The WAMP message code for this type of message.
   """


   def __init__(self, signature):
      """
      Message constructor.

      :param signature: The signature for the authentication challenge.
      :type signature: str
      """
      assert(type(signature) == six.text_type)

      Message.__init__(self)
      self.signature = signature


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Authenticate.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for AUTHENTICATE".format(len(wmsg)))

      signature = wmsg[1]
      if type(signature) != six.text_type:
         raise ProtocolError("invalid type {} for 'signature' in AUTHENTICATE".format(type(signature)))

      extra = check_or_raise_extra(wmsg[2], "'extra' in AUTHENTICATE")

      obj = Authenticate(signature)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      extra = {}
      return [Authenticate.MESSAGE_TYPE, self.signature, extra]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP AUTHENTICATE Message (signature = {})".format(self.signature)



class Goodbye(Message):
   """
   A WAMP `GOODBYE` message.

   Format: `[GOODBYE, Details|dict, Reason|uri]`
   """

   MESSAGE_TYPE = 6
   """
   The WAMP message code for this type of message.
   """

   DEFAULT_REASON = u"wamp.goodbye.normal"
   """
   Default WAMP closing reason.
   """


   def __init__(self, reason = DEFAULT_REASON, message = None):
      """
      Message constructor.

      :param reason: Optional WAMP or application error URI for closing reason.
      :type reason: str
      :param message: Optional human-readable closing message, e.g. for logging purposes.
      :type message: str
      """
      assert(type(reason) == six.text_type)
      assert(message is None or type(message) == six.text_type)

      Message.__init__(self)
      self.reason = reason
      self.message = message


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Goodbye.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for GOODBYE".format(len(wmsg)))

      details = check_or_raise_extra(wmsg[1], "'details' in GOODBYE")
      reason = check_or_raise_uri(wmsg[2], "'reason' in GOODBYE")

      message = None

      if u'message' in details:

         details_message = details[u'message']
         if type(details_message) != six.text_type:
            raise ProtocolError("invalid type {} for 'message' detail in GOODBYE".format(type(details_message)))

         message = details_message

      obj = Goodbye(reason, message)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      details = {}
      if self.message:
         details[u'message'] = self.message

      return [Goodbye.MESSAGE_TYPE, details, self.reason]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP GOODBYE Message (message = {}, reason = {})".format(self.message, self.reason)



class Heartbeat(Message):
   """
   A WAMP `HEARTBEAT` message.

   Formats:

     * `[HEARTBEAT, Incoming|integer, Outgoing|integer]`
     * `[HEARTBEAT, Incoming|integer, Outgoing|integer, Discard|string]`
   """

   MESSAGE_TYPE = 7
   """
   The WAMP message code for this type of message.
   """


   def __init__(self, incoming, outgoing, discard = None):
      """
      Message constructor.

      :param incoming: Last incoming heartbeat processed from peer.
      :type incoming: int
      :param outgoing: Outgoing heartbeat.
      :type outgoing: int
      :param discard: Optional data that is discared by peer.
      :type discard: str
      """
      assert(type(incoming) in six.integer_types)
      assert(type(outgoing) in six.integer_types)
      assert(discard is None or type(discard) == six.text_type)

      Message.__init__(self)
      self.incoming = incoming
      self.outgoing = outgoing
      self.discard = discard


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Heartbeat.MESSAGE_TYPE)

      if len(wmsg) not in [3, 4]:
         raise ProtocolError("invalid message length {} for HEARTBEAT".format(len(wmsg)))

      incoming = wmsg[1]

      if type(incoming) not in six.integer_types:
         raise ProtocolError("invalid type {} for 'incoming' in HEARTBEAT".format(type(incoming)))

      if incoming < 0: # must be non-negative
         raise ProtocolError("invalid value {} for 'incoming' in HEARTBEAT".format(incoming))

      outgoing = wmsg[2]

      if type(outgoing) not in six.integer_types:
         raise ProtocolError("invalid type {} for 'outgoing' in HEARTBEAT".format(type(outgoing)))

      if outgoing <= 0: # must be positive
         raise ProtocolError("invalid value {} for 'outgoing' in HEARTBEAT".format(outgoing))

      discard = None
      if len(wmsg) > 3:
         discard = wmsg[3]
         if type(discard) != six.text_type:
            raise ProtocolError("invalid type {} for 'discard' in HEARTBEAT".format(type(discard)))

      obj = Heartbeat(incoming, outgoing, discard = discard)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      if self.discard:
         return [Heartbeat.MESSAGE_TYPE, self.incoming, self.outgoing, self.discard]
      else:
         return [Heartbeat.MESSAGE_TYPE, self.incoming, self.outgoing]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP HEARTBEAT Message (incoming {}, outgoing = {}, len(discard) = {})".format(self.incoming, self.outgoing, len(self.discard) if self.discard else None)



class Error(Message):
   """
   A WAMP `ERROR` message.

   Formats:
     * `[ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict, Error|uri]`
     * `[ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict, Error|uri, Arguments|list]`
     * `[ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict, Error|uri, Arguments|list, ArgumentsKw|dict]`
   """

   MESSAGE_TYPE = 8
   """
   The WAMP message code for this type of message.
   """


   def __init__(self, request_type, request, error, args = None, kwargs = None):
      """
      Message constructor.

      :param request_type: The WAMP message type code for the original request.
      :type request_type: int
      :param request: The WAMP request ID of the original request (`Call`, `Subscribe`, ...) this error occured for.
      :type request: int
      :param error: The WAMP or application error URI for the error that occured.
      :type error: str
      :param args: Positional values for application-defined exception.
                   Must be serializable using any serializers in use.
      :type args: list
      :param kwargs: Keyword values for application-defined exception.
                     Must be serializable using any serializers in use.
      :type kwargs: dict
      """
      assert(type(request_type) in six.integer_types)
      assert(type(request) in six.integer_types)
      assert(type(error) == six.text_type)
      assert(args is None or type(args) in [list, tuple])
      assert(kwargs is None or type(kwargs) == dict)

      Message.__init__(self)
      self.request_type = request_type
      self.request = request
      self.error = error
      self.args = args
      self.kwargs = kwargs


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Error.MESSAGE_TYPE)

      if len(wmsg) not in (5, 6, 7):
         raise ProtocolError("invalid message length {} for ERROR".format(len(wmsg)))

      request_type = wmsg[1]
      if type(request_type) not in six.integer_types:
         raise ProtocolError("invalid type {} for 'request_type' in ERROR".format(request_type))

      if request_type not in [Subscribe.MESSAGE_TYPE,
                              Unsubscribe.MESSAGE_TYPE,
                              Publish.MESSAGE_TYPE,
                              Register.MESSAGE_TYPE,
                              Unregister.MESSAGE_TYPE,
                              Call.MESSAGE_TYPE,
                              Invocation.MESSAGE_TYPE]:
         raise ProtocolError("invalid value {} for 'request_type' in ERROR".format(request_type))

      request = check_or_raise_id(wmsg[2], "'request' in ERROR")
      details = check_or_raise_extra(wmsg[3], "'details' in ERROR")
      error = check_or_raise_uri(wmsg[4], "'error' in ERROR")

      args = None
      if len(wmsg) > 5:
         args = wmsg[5]
         if type(args) != list:
            raise ProtocolError("invalid type {} for 'args' in ERROR".format(type(args)))

      kwargs = None
      if len(wmsg) > 6:
         kwargs = wmsg[6]
         if type(kwargs) != dict:
            raise ProtocolError("invalid type {} for 'kwargs' in ERROR".format(type(kwargs)))

      obj = Error(request_type, request, error, args = args, kwargs = kwargs)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      details = {}

      if self.kwargs:
         return [self.MESSAGE_TYPE, self.request_type, self.request, details, self.error, self.args, self.kwargs]
      elif self.args:
         return [self.MESSAGE_TYPE, self.request_type, self.request, details, self.error, self.args]
      else:
         return [self.MESSAGE_TYPE, self.request_type, self.request, details, self.error]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP Error Message (request_type = {}, request = {}, error = {}, args = {}, kwargs = {})".format(self.request_type, self.request, self.error, self.args, self.kwargs)



class Publish(Message):
   """
   A WAMP `PUBLISH` message.

   Formats:
     * `[PUBLISH, Request|id, Options|dict, Topic|uri]`
     * `[PUBLISH, Request|id, Options|dict, Topic|uri, Arguments|list]`
     * `[PUBLISH, Request|id, Options|dict, Topic|uri, Arguments|list, ArgumentsKw|dict]`
   """

   MESSAGE_TYPE = 16
   """
   The WAMP message code for this type of message.
   """

   def __init__(self,
                request,
                topic,
                args = None,
                kwargs = None,
                acknowledge = None,
                excludeMe = None,
                exclude = None,
                eligible = None,
                discloseMe = None):
      """
      Message constructor.

      :param request: The WAMP request ID of this request.
      :type request: int
      :param topic: The WAMP or application URI of the PubSub topic the event should
                    be published to.
      :type topic: str
      :param args: Positional values for application-defined event payload.
                   Must be serializable using any serializers in use.
      :type args: list
      :param kwargs: Keyword values for application-defined event payload.
                     Must be serializable using any serializers in use.
      :type kwargs: dict
      :param acknowledge: If True, acknowledge the publication with a success or
                          error response.
      :type acknowledge: bool
      :param excludeMe: If True, exclude the publisher from receiving the event, even
                        if he is subscribed (and eligible).
      :type excludeMe: bool
      :param exclude: List of WAMP session IDs to exclude from receiving this event.
      :type exclude: list
      :param eligible: List of WAMP session IDs eligible to receive this event.
      :type eligible: list
      :param discloseMe: If True, request to disclose the publisher of this event
                         to subscribers.
      :type discloseMe: bool
      """
      assert(type(request) in six.integer_types)
      assert(type(topic) == six.text_type)
      assert(args is None or type(args) in [list, tuple])
      assert(kwargs is None or type(kwargs) == dict)
      assert(acknowledge is None or type(acknowledge) == bool)
      assert(excludeMe is None or type(excludeMe) == bool)
      assert(exclude is None or type(exclude) == list)
      assert(eligible is None or type(eligible) == list)
      assert(discloseMe is None or type(discloseMe) == bool)

      Message.__init__(self)
      self.request = request
      self.topic = topic
      self.args = args
      self.kwargs = kwargs
      self.acknowledge = acknowledge
      self.excludeMe = excludeMe
      self.exclude = exclude
      self.eligible = eligible
      self.discloseMe = discloseMe


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Publish.MESSAGE_TYPE)

      if len(wmsg) not in (4, 5, 6):
         raise ProtocolError("invalid message length {} for PUBLISH".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in PUBLISH")
      options = check_or_raise_extra(wmsg[2], "'options' in PUBLISH")
      topic = check_or_raise_uri(wmsg[3], "'topic' in PUBLISH")

      args = None
      if len(wmsg) > 4:
         args = wmsg[4]
         if type(args) != list:
            raise ProtocolError("invalid type {} for 'args' in PUBLISH".format(type(args)))

      kwargs = None
      if len(wmsg) > 5:
         kwargs = wmsg[5]
         if type(kwargs) != dict:
            raise ProtocolError("invalid type {} for 'kwargs' in PUBLISH".format(type(kwargs)))

      acknowledge = None
      excludeMe = None
      exclude = None
      eligible = None
      discloseMe = None

      if u'acknowledge' in options:

         option_acknowledge = options[u'acknowledge']
         if type(option_acknowledge) != bool:
            raise ProtocolError("invalid type {} for 'acknowledge' option in PUBLISH".format(type(option_acknowledge)))

         acknowledge = option_acknowledge

      if u'exclude_me' in options:

         option_excludeMe = options[u'exclude_me']
         if type(option_excludeMe) != bool:
            raise ProtocolError("invalid type {} for 'exclude_me' option in PUBLISH".format(type(option_excludeMe)))

         excludeMe = option_excludeMe

      if u'exclude' in options:

         option_exclude = options[u'exclude']
         if type(option_exclude) != list:
            raise ProtocolError("invalid type {} for 'exclude' option in PUBLISH".format(type(option_exclude)))

         for sessionId in option_exclude:
            if type(sessionId) not in six.integer_types:
               raise ProtocolError("invalid type {} for value in 'exclude' option in PUBLISH".format(type(sessionId)))

         exclude = option_exclude

      if u'eligible' in options:

         option_eligible = options[u'eligible']
         if type(option_eligible) != list:
            raise ProtocolError("invalid type {} for 'eligible' option in PUBLISH".format(type(option_eligible)))

         for sessionId in option_eligible:
            if type(sessionId) not in six.integer_types:
               raise ProtocolError("invalid type {} for value in 'eligible' option in PUBLISH".format(type(sessionId)))

         eligible = option_eligible

      if u'disclose_me' in options:

         option_discloseMe = options[u'disclose_me']
         if type(option_discloseMe) != bool:
            raise ProtocolError("invalid type {} for 'disclose_me' option in PUBLISH".format(type(option_discloseMe)))

         discloseMe = option_discloseMe

      obj = Publish(request,
                    topic,
                    args = args,
                    kwargs = kwargs,
                    acknowledge = acknowledge,
                    excludeMe = excludeMe,
                    exclude = exclude,
                    eligible = eligible,
                    discloseMe = discloseMe)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      options = {}

      if self.acknowledge is not None:
         options[u'acknowledge'] = self.acknowledge
      if self.excludeMe is not None:
         options[u'exclude_me'] = self.excludeMe
      if self.exclude is not None:
         options[u'exclude'] = self.exclude
      if self.eligible is not None:
         options[u'eligible'] = self.eligible
      if self.discloseMe is not None:
         options[u'disclose_me'] = self.discloseMe

      if self.kwargs:
         return [Publish.MESSAGE_TYPE, self.request, options, self.topic, self.args, self.kwargs]
      elif self.args:
         return [Publish.MESSAGE_TYPE, self.request, options, self.topic, self.args]
      else:
         return [Publish.MESSAGE_TYPE, self.request, options, self.topic]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP PUBLISH Message (request = {}, topic = {}, args = {}, kwargs = {}, acknowledge = {}, excludeMe = {}, exclude = {}, eligible = {}, discloseMe = {})".format(self.request, self.topic, self.args, self.kwargs, self.acknowledge, self.excludeMe, self.exclude, self.eligible, self.discloseMe)



class Published(Message):
   """
   A WAMP `PUBLISHED` message.

   Format: `[PUBLISHED, PUBLISH.Request|id, Publication|id]`
   """

   MESSAGE_TYPE = 17
   """
   The WAMP message code for this type of message.
   """

   def __init__(self, request, publication):
      """
      Message constructor.

      :param request: The request ID of the original `PUBLISH` request.
      :type request: int
      :param publication: The publication ID for the published event.
      :type publication: int
      """
      assert(type(request) in six.integer_types)
      assert(type(publication) in six.integer_types)

      Message.__init__(self)
      self.request = request
      self.publication = publication


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Published.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for PUBLISHED".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in PUBLISHED")
      publication = check_or_raise_id(wmsg[2], "'publication' in PUBLISHED")

      obj = Published(request, publication)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      return [Published.MESSAGE_TYPE, self.request, self.publication]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP PUBLISHED Message (request = {}, publication = {})".format(self.request, self.publication)



class Subscribe(Message):
   """
   A WAMP `SUBSCRIBE` message.

   Format: `[SUBSCRIBE, Request|id, Options|dict, Topic|uri]`
   """

   MESSAGE_TYPE = 32
   """
   The WAMP message code for this type of message.
   """

   MATCH_EXACT = u'exact'
   MATCH_PREFIX = u'prefix'
   MATCH_WILDCARD = u'wildcard'

   def __init__(self, request, topic, match = MATCH_EXACT):
      """
      Message constructor.

      :param request: The WAMP request ID of this request.
      :type request: int
      :param topic: The WAMP or application URI of the PubSub topic to subscribe to.
      :type topic: str
      :param match: The topic matching method to be used for the subscription.
      :type match: str
      """
      assert(type(request) in six.integer_types)
      assert(type(topic) == six.text_type)
      assert(match is None or type(match) == six.text_type)
      assert(match is None or match in [self.MATCH_EXACT, self.MATCH_PREFIX, self.MATCH_WILDCARD])

      Message.__init__(self)
      self.request = request
      self.topic = topic
      self.match = match


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Subscribe.MESSAGE_TYPE)

      if len(wmsg) != 4:
         raise ProtocolError("invalid message length {} for SUBSCRIBE".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in SUBSCRIBE")
      options = check_or_raise_extra(wmsg[2], "'options' in SUBSCRIBE")
      topic = check_or_raise_uri(wmsg[3], "'topic' in SUBSCRIBE")

      match = Subscribe.MATCH_EXACT

      if u'match' in options:

         option_match = options[u'match']
         if type(option_match) != six.text_type:
            raise ProtocolError("invalid type {} for 'match' option in SUBSCRIBE".format(type(option_match)))

         if option_match not in [Subscribe.MATCH_EXACT, Subscribe.MATCH_PREFIX, Subscribe.MATCH_WILDCARD]:
            raise ProtocolError("invalid value {} for 'match' option in SUBSCRIBE".format(option_match))

         match = option_match

      obj = Subscribe(request, topic, match)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      options = {}

      if self.match and self.match != Subscribe.MATCH_EXACT:
         options[u'match'] = self.match

      return [Subscribe.MESSAGE_TYPE, self.request, options, self.topic]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP SUBSCRIBE Message (request = {}, topic = {}, match = {})".format(self.request, self.topic, self.match)



class Subscribed(Message):
   """
   A WAMP `SUBSCRIBED` message.

   Format: `[SUBSCRIBED, SUBSCRIBE.Request|id, Subscription|id]`
   """

   MESSAGE_TYPE = 33
   """
   The WAMP message code for this type of message.
   """

   def __init__(self, request, subscription):
      """
      Message constructor.

      :param request: The request ID of the original `SUBSCRIBE` request.
      :type request: int
      :param subscription: The subscription ID for the subscribed topic (or topic pattern).
      :type subscription: int
      """
      assert(type(request) in six.integer_types)
      assert(type(subscription) in six.integer_types)

      Message.__init__(self)
      self.request = request
      self.subscription = subscription


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Subscribed.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for SUBSCRIBED".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in SUBSCRIBED")
      subscription = check_or_raise_id(wmsg[2], "'subscription' in SUBSCRIBED")

      obj = Subscribed(request, subscription)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      return [Subscribed.MESSAGE_TYPE, self.request, self.subscription]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP SUBSCRIBED Message (request = {}, subscription = {})".format(self.request, self.subscription)



class Unsubscribe(Message):
   """
   A WAMP `UNSUBSCRIBE` message.

   Format: `[UNSUBSCRIBE, Request|id, SUBSCRIBED.Subscription|id]`
   """

   MESSAGE_TYPE = 34
   """
   The WAMP message code for this type of message.
   """


   def __init__(self, request, subscription):
      """
      Message constructor.

      :param request: The WAMP request ID of this request.
      :type request: int
      :param subscription: The subscription ID for the subscription to unsubscribe from.
      :type subscription: int
      """
      assert(type(request) in six.integer_types)
      assert(type(subscription) in six.integer_types)

      Message.__init__(self)
      self.request = request
      self.subscription = subscription


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Unsubscribe.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for WAMP UNSUBSCRIBE".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in UNSUBSCRIBE")
      subscription = check_or_raise_id(wmsg[2], "'subscription' in UNSUBSCRIBE")

      obj = Unsubscribe(request, subscription)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      return [Unsubscribe.MESSAGE_TYPE, self.request, self.subscription]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP UNSUBSCRIBE Message (request = {}, subscription = {})".format(self.request, self.subscription)



class Unsubscribed(Message):
   """
   A WAMP `UNSUBSCRIBED` message.

   Format: `[UNSUBSCRIBED, UNSUBSCRIBE.Request|id]`
   """

   MESSAGE_TYPE = 35
   """
   The WAMP message code for this type of message.
   """

   def __init__(self, request):
      """
      Message constructor.

      :param request: The request ID of the original `UNSUBSCRIBE` request.
      :type request: int
      """
      assert(type(request) in six.integer_types)

      Message.__init__(self)
      self.request = request


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Unsubscribed.MESSAGE_TYPE)

      if len(wmsg) != 2:
         raise ProtocolError("invalid message length {} for UNSUBSCRIBED".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in UNSUBSCRIBED")

      obj = Unsubscribed(request)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      return [Unsubscribed.MESSAGE_TYPE, self.request]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP UNSUBSCRIBED Message (request = {})".format(self.request)



class Event(Message):
   """
   A WAMP `EVENT` message.

   Formats:

     * `[EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id, Details|dict]`
     * `[EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id, Details|dict, PUBLISH.Arguments|list]`
     * `[EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id, Details|dict, PUBLISH.Arguments|list, PUBLISH.ArgumentsKw|dict]`
   """

   MESSAGE_TYPE = 36
   """
   The WAMP message code for this type of message.
   """


   def __init__(self, subscription, publication, args = None, kwargs = None, publisher = None):
      """
      Message constructor.

      :param subscription: The subscription ID this event is dispatched under.
      :type subscription: int
      :param publication: The publication ID of the dispatched event.
      :type publication: int
      :param args: Positional values for application-defined exception.
                   Must be serializable using any serializers in use.
      :type args: list
      :param kwargs: Keyword values for application-defined exception.
                     Must be serializable using any serializers in use.
      :type kwargs: dict
      :param publisher: If present, the WAMP session ID of the publisher of this event.
      :type publisher: str
      """
      assert(type(subscription) in six.integer_types)
      assert(type(publication) in six.integer_types)
      assert(args is None or type(args) in [list, tuple])
      assert(kwargs is None or type(kwargs) == dict)
      assert(publisher is None or type(publisher) in six.integer_types)

      Message.__init__(self)
      self.subscription = subscription
      self.publication = publication
      self.args = args
      self.kwargs = kwargs
      self.publisher = publisher


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Event.MESSAGE_TYPE)

      if len(wmsg) not in (4, 5, 6):
         raise ProtocolError("invalid message length {} for EVENT".format(len(wmsg)))

      subscription = check_or_raise_id(wmsg[1], "'subscription' in EVENT")
      publication = check_or_raise_id(wmsg[2], "'publication' in EVENT")
      details = check_or_raise_extra(wmsg[3], "'details' in EVENT")

      args = None
      if len(wmsg) > 4:
         args = wmsg[4]
         if type(args) != list:
            raise ProtocolError("invalid type {} for 'args' in EVENT".format(type(args)))

      kwargs = None
      if len(wmsg) > 5:
         kwargs = wmsg[5]
         if type(kwargs) != dict:
            raise ProtocolError("invalid type {} for 'kwargs' in EVENT".format(type(kwargs)))

      publisher = None
      if u'publisher' in details:

         detail_publisher = details[u'publisher']
         if type(detail_publisher) not in six.integer_types:
            raise ProtocolError("invalid type {} for 'publisher' detail in EVENT".format(type(detail_publisher)))

         publisher = detail_publisher

      obj = Event(subscription,
                  publication,
                  args = args,
                  kwargs = kwargs,
                  publisher = publisher)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      details = {}

      if self.publisher is not None:
         details[u'publisher'] = self.publisher

      if self.kwargs:
         return [Event.MESSAGE_TYPE, self.subscription, self.publication, details, self.args, self.kwargs]
      elif self.args:
         return [Event.MESSAGE_TYPE, self.subscription, self.publication, details, self.args]
      else:
         return [Event.MESSAGE_TYPE, self.subscription, self.publication, details]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP EVENT Message (subscription = {}, publication = {}, args = {}, kwargs = {}, publisher = {})".format(self.subscription, self.publication, self.args, self.kwargs, self.publisher)



class Call(Message):
   """
   A WAMP `CALL` message.

   Formats:
     * `[CALL, Request|id, Options|dict, Procedure|uri]`
     * `[CALL, Request|id, Options|dict, Procedure|uri, Arguments|list]`
     * `[CALL, Request|id, Options|dict, Procedure|uri, Arguments|list, ArgumentsKw|dict]`
   """

   MESSAGE_TYPE = 48
   """
   The WAMP message code for this type of message.
   """

   def __init__(self,
                request,
                procedure,
                args = None,
                kwargs = None,
                timeout = None,
                receive_progress = None,
                discloseMe = None):
      """
      Message constructor.

      :param request: The WAMP request ID of this request.
      :type request: int
      :param procedure: The WAMP or application URI of the procedure which should be called.
      :type procedure: str
      :param args: Positional values for application-defined call arguments.
                   Must be serializable using any serializers in use.
      :type args: list
      :param kwargs: Keyword values for application-defined call arguments.
                     Must be serializable using any serializers in use.
      :param timeout: If present, let the callee automatically cancel
                      the call after this ms.
      :type timeout: int
      """
      assert(type(request) in six.integer_types)
      assert(type(procedure) == six.text_type)
      assert(args is None or type(args) in [list, tuple])
      assert(kwargs is None or type(kwargs) == dict)
      assert(timeout is None or type(timeout) in six.integer_types)
      assert(receive_progress is None or type(receive_progress) == bool)
      assert(discloseMe is None or type(discloseMe) == bool)

      Message.__init__(self)
      self.request = request
      self.procedure = procedure
      self.args = args
      self.kwargs = kwargs
      self.timeout = timeout
      self.receive_progress = receive_progress
      self.discloseMe = discloseMe


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Call.MESSAGE_TYPE)

      if len(wmsg) not in (4, 5, 6):
         raise ProtocolError("invalid message length {} for CALL".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in CALL")
      options = check_or_raise_extra(wmsg[2], "'options' in CALL")
      procedure = check_or_raise_uri(wmsg[3], "'procedure' in CALL")

      args = None
      if len(wmsg) > 4:
         args = wmsg[4]
         if type(args) != list:
            raise ProtocolError("invalid type {} for 'args' in CALL".format(type(args)))

      kwargs = None
      if len(wmsg) > 5:
         kwargs = wmsg[5]
         if type(kwargs) != dict:
            raise ProtocolError("invalid type {} for 'kwargs' in CALL".format(type(kwargs)))

      timeout = None
      if u'timeout' in options:

         option_timeout = options[u'timeout']
         if type(option_timeout) not in six.integer_types:
            raise ProtocolError("invalid type {} for 'timeout' option in CALL".format(type(option_timeout)))

         if option_timeout < 0:
            raise ProtocolError("invalid value {} for 'timeout' option in CALL".format(option_timeout))

         timeout = option_timeout

      receive_progress = None
      if u'receive_progress' in options:

         option_receive_progress = options[u'receive_progress']
         if type(option_receive_progress) != bool:
            raise ProtocolError("invalid type {} for 'receive_progress' option in CALL".format(type(option_receive_progress)))

         receive_progress = option_receive_progress

      discloseMe = None
      if u'disclose_me' in options:

         option_discloseMe = options[u'disclose_me']
         if type(option_discloseMe) != bool:
            raise ProtocolError("invalid type {} for 'disclose_me' option in CALL".format(type(option_discloseMe)))

         discloseMe = option_discloseMe

      obj = Call(request,
                 procedure,
                 args = args,
                 kwargs = kwargs,
                 timeout = timeout,
                 receive_progress = receive_progress,
                 discloseMe = discloseMe)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      options = {}

      if self.timeout is not None:
         options[u'timeout'] = self.timeout

      if self.receive_progress is not None:
         options[u'receive_progress'] = self.receive_progress

      if self.discloseMe is not None:
         options[u'disclose_me'] = self.discloseMe

      if self.kwargs:
         return [Call.MESSAGE_TYPE, self.request, options, self.procedure, self.args, self.kwargs]
      elif self.args:
         return [Call.MESSAGE_TYPE, self.request, options, self.procedure, self.args]
      else:
         return [Call.MESSAGE_TYPE, self.request, options, self.procedure]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP CALL Message (request = {}, procedure = {}, args = {}, kwargs = {}, timeout = {}, receive_progress = {}, discloseMe = {})".format(self.request, self.procedure, self.args, self.kwargs, self.timeout, self.receive_progress, self.discloseMe)



class Cancel(Message):
   """
   A WAMP `CANCEL` message.

   Format: `[CANCEL, CALL.Request|id, Options|dict]`
   """

   MESSAGE_TYPE = 49
   """
   The WAMP message code for this type of message.
   """

   SKIP = u'skip'
   ABORT = u'abort'
   KILL = u'kill'


   def __init__(self, request, mode = None):
      """
      Message constructor.

      :param request: The WAMP request ID of the original `CALL` to cancel.
      :type request: int
      :param mode: Specifies how to cancel the call (`"skip"`, `"abort"` or `"kill"`).
      :type mode: str
      """
      assert(type(request) in six.integer_types)
      assert(mode is None or type(mode) == six.text_type)
      assert(mode is None or mode in [self.SKIP, self.ABORT, self.KILL])

      Message.__init__(self)
      self.request = request
      self.mode = mode


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Cancel.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for CANCEL".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in CANCEL")
      options = check_or_raise_extra(wmsg[2], "'options' in CANCEL")

      ## options
      ##
      mode = None

      if u'mode' in options:

         option_mode = options[u'mode']
         if type(option_mode) != six.text_type:
            raise ProtocolError("invalid type {} for 'mode' option in CANCEL".format(type(option_mode)))

         if option_mode not in [Cancel.SKIP, Cancel.ABORT, Cancel.KILL]:
            raise ProtocolError("invalid value '{}' for 'mode' option in CANCEL".format(option_mode))

         mode = option_mode

      obj = Cancel(request, mode = mode)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      options = {}

      if self.mode is not None:
         options[u'mode'] = self.mode

      return [Cancel.MESSAGE_TYPE, self.request, options]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP CANCEL Message (request = {}, mode = '{}'')".format(self.request, self.mode)



class Result(Message):
   """
   A WAMP `RESULT` message.

   Formats:
     * `[RESULT, CALL.Request|id, Details|dict]`
     * `[RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list]`
     * `[RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list, YIELD.ArgumentsKw|dict]`
   """

   MESSAGE_TYPE = 50
   """
   The WAMP message code for this type of message.
   """

   def __init__(self, request, args = None, kwargs = None, progress = None):
      """
      Message constructor.

      :param request: The request ID of the original `CALL` request.
      :type request: int
      :param args: Positional values for application-defined event payload.
                   Must be serializable using any serializers in use.
      :type args: list
      :param kwargs: Keyword values for application-defined event payload.
                     Must be serializable using any serializers in use.
      :type kwargs: dict
      :param progress: If `True`, this result is a progressive call result, and subsequent
                       results (or a final error) will follow.
      :type progress: bool
      """
      assert(type(request) in six.integer_types)
      assert(args is None or type(args) in [list, tuple])
      assert(kwargs is None or type(kwargs) == dict)
      assert(progress is None or type(progress) == bool)

      Message.__init__(self)
      self.request = request
      self.args = args
      self.kwargs = kwargs
      self.progress = progress


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Result.MESSAGE_TYPE)

      if len(wmsg) not in (3, 4, 5):
         raise ProtocolError("invalid message length {} for RESULT".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in RESULT")
      details = check_or_raise_extra(wmsg[2], "'details' in RESULT")

      args = None
      if len(wmsg) > 3:
         args = wmsg[3]
         if type(args) != list:
            raise ProtocolError("invalid type {} for 'args' in RESULT".format(type(args)))

      kwargs = None
      if len(wmsg) > 4:
         kwargs = wmsg[4]
         if type(kwargs) != dict:
            raise ProtocolError("invalid type {} for 'kwargs' in RESULT".format(type(kwargs)))

      progress = None

      if u'progress' in details:

         detail_progress = details[u'progress']
         if type(detail_progress) != bool:
            raise ProtocolError("invalid type {} for 'progress' option in RESULT".format(type(detail_progress)))

         progress = detail_progress

      obj = Result(request, args = args, kwargs = kwargs, progress = progress)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      details = {}

      if self.progress is not None:
         details[u'progress'] = self.progress

      if self.kwargs:
         return [Result.MESSAGE_TYPE, self.request, details, self.args, self.kwargs]
      elif self.args:
         return [Result.MESSAGE_TYPE, self.request, details, self.args]
      else:
         return [Result.MESSAGE_TYPE, self.request, details]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP RESULT Message (request = {}, args = {}, kwargs = {}, progress = {})".format(self.request, self.args, self.kwargs, self.progress)



class Register(Message):
   """
   A WAMP `REGISTER` message.

   Format: `[REGISTER, Request|id, Options|dict, Procedure|uri]`
   """

   MESSAGE_TYPE = 64
   """
   The WAMP message code for this type of message.
   """

   def __init__(self, request, procedure, pkeys = None, discloseCaller = None):
      """
      Message constructor.

      :param request: The WAMP request ID of this request.
      :type request: int
      :param procedure: The WAMP or application URI of the RPC endpoint provided.
      :type procedure: str
      :param pkeys: The endpoint can work for this list of application partition keys.
      :type pkeys: list
      """
      assert(type(request) in six.integer_types)
      assert(type(procedure) == six.text_type)
      assert(pkeys is None or type(pkeys) == list)
      if pkeys:
         for k in pkeys:
            assert(type(k) in six.integer_types)
      assert(discloseCaller is None or type(discloseCaller) == bool)

      Message.__init__(self)
      self.request = request
      self.procedure = procedure
      self.pkeys = pkeys
      self.discloseCaller = discloseCaller


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Register.MESSAGE_TYPE)

      if len(wmsg) != 4:
         raise ProtocolError("invalid message length {} for REGISTER".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in REGISTER")
      options = check_or_raise_extra(wmsg[2], "'options' in REGISTER")
      procedure = check_or_raise_uri(wmsg[3], "'procedure' in REGISTER")

      pkeys = None
      discloseCaller = None

      if u'pkeys' in options:

         option_pkeys = options[u'pkeys']
         if type(option_pkeys) != list:
            raise ProtocolError("invalid type {} for 'pkeys' option in REGISTER".format(type(option_pkeys)))

         for pk in option_pkeys:
            if type(pk) not in six.integer_types:
               raise ProtocolError("invalid type for value '{}' in 'pkeys' option in REGISTER".format(type(pk)))

         pkeys = option_pkeys


      if u'disclose_caller' in options:

         option_discloseCaller = options[u'disclose_caller']
         if type(option_discloseCaller) != bool:
            raise ProtocolError("invalid type {} for 'disclose_caller' option in REGISTER".format(type(option_discloseCaller)))

         discloseCaller = option_discloseCaller

      obj = Register(request, procedure, pkeys = pkeys, discloseCaller = discloseCaller)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      options = {}

      if self.pkeys is not None:
         options[u'pkeys'] = self.pkeys

      if self.discloseCaller is not None:
         options[u'disclose_caller'] = self.discloseCaller

      return [Register.MESSAGE_TYPE, self.request, options, self.procedure]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP REGISTER Message (request = {}, procedure = {}, pkeys = {}, discloseCaller = {})".format(self.request, self.procedure, self.pkeys, self.discloseCaller)



class Registered(Message):
   """
   A WAMP `REGISTERED` message.

   Format: `[REGISTERED, REGISTER.Request|id, Registration|id]`
   """

   MESSAGE_TYPE = 65
   """
   The WAMP message code for this type of message.
   """

   def __init__(self, request, registration):
      """
      Message constructor.

      :param request: The request ID of the original `REGISTER` request.
      :type request: int
      :param registration: The registration ID for the registered procedure (or procedure pattern).
      :type registration: int
      """
      assert(type(request) in six.integer_types)
      assert(type(registration) in six.integer_types)

      Message.__init__(self)
      self.request = request
      self.registration = registration


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Registered.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for REGISTERED".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in REGISTERED")
      registration = check_or_raise_id(wmsg[2], "'registration' in REGISTERED")

      obj = Registered(request, registration)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      return [Registered.MESSAGE_TYPE, self.request, self.registration]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP REGISTERED Message (request = {}, registration = {})".format(self.request, self.registration)



class Unregister(Message):
   """
   A WAMP Unprovide message.

   Format: `[UNREGISTER, Request|id, REGISTERED.Registration|id]`
   """

   MESSAGE_TYPE = 66
   """
   The WAMP message code for this type of message.
   """


   def __init__(self, request, registration):
      """
      Message constructor.

      :param request: The WAMP request ID of this request.
      :type request: int
      :param registration: The registration ID for the registration to unregister.
      :type registration: int
      """
      assert(type(request) in six.integer_types)
      assert(type(registration) in six.integer_types)

      Message.__init__(self)
      self.request = request
      self.registration = registration


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Unregister.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for WAMP UNREGISTER".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in UNREGISTER")
      registration = check_or_raise_id(wmsg[2], "'registration' in UNREGISTER")

      obj = Unregister(request, registration)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      return [Unregister.MESSAGE_TYPE, self.request, self.registration]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP UNREGISTER Message (request = {}, registration = {})".format(self.request, self.registration)



class Unregistered(Message):
   """
   A WAMP `UNREGISTERED` message.

   Format: `[UNREGISTERED, UNREGISTER.Request|id]`
   """

   MESSAGE_TYPE = 67
   """
   The WAMP message code for this type of message.
   """

   def __init__(self, request):
      """
      Message constructor.

      :param request: The request ID of the original `UNREGISTER` request.
      :type request: int
      """
      assert(type(request) in six.integer_types)

      Message.__init__(self)
      self.request = request


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Unregistered.MESSAGE_TYPE)

      if len(wmsg) != 2:
         raise ProtocolError("invalid message length {} for UNREGISTER".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in UNREGISTER")

      obj = Unregistered(request)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      return [Unregistered.MESSAGE_TYPE, self.request]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP UNREGISTER Message (request = {})".format(self.request)



class Invocation(Message):
   """
   A WAMP `INVOCATION` message.

   Formats:
     * `[INVOCATION, Request|id, REGISTERED.Registration|id, Details|dict]`
     * `[INVOCATION, Request|id, REGISTERED.Registration|id, Details|dict, CALL.Arguments|list]`
     * `[INVOCATION, Request|id, REGISTERED.Registration|id, Details|dict, CALL.Arguments|list, CALL.ArgumentsKw|dict]`
   """

   MESSAGE_TYPE = 68
   """
   The WAMP message code for this type of message.
   """


   def __init__(self,
                request,
                registration,
                args = None,
                kwargs = None,
                timeout = None,
                receive_progress = None,
                caller = None,
                authid = None,
                authrole = None,
                authmethod = None):
      """
      Message constructor.

      :param request: The WAMP request ID of this request.
      :type request: int
      :param registration: The registration ID of the endpoint to be invoked.
      :type registration: int
      :param args: Positional values for application-defined event payload.
                   Must be serializable using any serializers in use.
      :type args: list
      :param kwargs: Keyword values for application-defined event payload.
                     Must be serializable using any serializers in use.
      :type kwargs: dict
      :param timeout: If present, let the callee automatically cancels
                      the invocation after this ms.
      :type timeout: int
      """
      assert(type(request) in six.integer_types)
      assert(type(registration) in six.integer_types)
      assert(args is None or type(args) in [list, tuple])
      assert(kwargs is None or type(kwargs) == dict)
      assert(timeout is None or type(timeout) in six.integer_types)
      assert(receive_progress is None or type(receive_progress) == bool)
      assert(caller is None or type(caller) in six.integer_types)
      assert(authid is None or type(authid) == six.text_type)
      assert(authrole is None or type(authrole) == six.text_type)
      assert(authmethod is None or type(authmethod) == six.text_type)

      Message.__init__(self)
      self.request = request
      self.registration = registration
      self.args = args
      self.kwargs = kwargs
      self.timeout = timeout
      self.receive_progress = receive_progress
      self.caller = caller
      self.authid = authid
      self.authrole = authrole
      self.authmethod = authmethod


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Invocation.MESSAGE_TYPE)

      if len(wmsg) not in (4, 5, 6):
         raise ProtocolError("invalid message length {} for INVOCATION".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in INVOCATION")
      registration = check_or_raise_id(wmsg[2], "'registration' in INVOCATION")
      details = check_or_raise_extra(wmsg[3], "'details' in INVOCATION")

      args = None
      if len(wmsg) > 4:
         args = wmsg[4]
         if type(args) != list:
            raise ProtocolError("invalid type {} for 'args' in INVOCATION".format(type(args)))

      kwargs = None
      if len(wmsg) > 5:
         kwargs = wmsg[5]
         if type(kwargs) != dict:
            raise ProtocolError("invalid type {} for 'kwargs' in INVOCATION".format(type(kwargs)))

      timeout = None
      if u'timeout' in details:

         detail_timeout = details[u'timeout']
         if type(detail_timeout) not in six.integer_types:
            raise ProtocolError("invalid type {} for 'timeout' detail in INVOCATION".format(type(detail_timeout)))

         if detail_timeout < 0:
            raise ProtocolError("invalid value {} for 'timeout' detail in INVOCATION".format(detail_timeout))

         timeout = detail_timeout

      receive_progress = None
      if u'receive_progress' in details:

         detail_receive_progress = details[u'receive_progress']
         if type(detail_receive_progress) != bool:
            raise ProtocolError("invalid type {} for 'receive_progress' detail in INVOCATION".format(type(detail_receive_progress)))

         receive_progress = detail_receive_progress

      caller = None
      if u'caller' in details:

         detail_caller = details[u'caller']
         if type(detail_caller) not in six.integer_types:
            raise ProtocolError("invalid type {} for 'caller' detail in INVOCATION".format(type(detail_caller)))

         caller = detail_caller

      authid = None
      if u'authid' in details:

         detail_authid = details[u'authid']
         if type(detail_authid) != six.text_type:
            raise ProtocolError("invalid type {} for 'authid' detail in INVOCATION".format(type(detail_authid)))

         authid = detail_authid

      authrole = None
      if u'authrole' in details:

         detail_authrole = details[u'authrole']
         if type(detail_authrole) != six.text_type:
            raise ProtocolError("invalid type {} for 'authrole' detail in INVOCATION".format(type(detail_authrole)))

         authrole = detail_authrole

      authmethod = None
      if u'authmethod' in details:

         detail_authmethod = details[u'authmethod']
         if type(detail_authrole) != six.text_type:
            raise ProtocolError("invalid type {} for 'authmethod' detail in INVOCATION".format(type(detail_authrole)))

         authmethod = detail_authmethod

      obj = Invocation(request,
                       registration,
                       args = args,
                       kwargs = kwargs,
                       timeout = timeout,
                       receive_progress = receive_progress,
                       caller = caller,
                       authid = authid,
                       authrole = authrole,
                       authmethod = authmethod)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      options = {}

      if self.timeout is not None:
         options[u'timeout'] = self.timeout

      if self.receive_progress is not None:
         options[u'receive_progress'] = self.receive_progress

      if self.caller is not None:
         options[u'caller'] = self.caller

      if self.authid is not None:
         options[u'authid'] = self.authid

      if self.authrole is not None:
         options[u'authrole'] = self.authrole

      if self.authmethod is not None:
         options[u'authmethod'] = self.authmethod

      if self.kwargs:
         return [Invocation.MESSAGE_TYPE, self.request, self.registration, options, self.args, self.kwargs]
      elif self.args:
         return [Invocation.MESSAGE_TYPE, self.request, self.registration, options, self.args]
      else:
         return [Invocation.MESSAGE_TYPE, self.request, self.registration, options]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP INVOCATION Message (request = {}, registration = {}, args = {}, kwargs = {}, timeout = {}, receive_progress = {}, caller = {}, authid = {}, authrole = {}, authmethod = {})".format(self.request, self.registration, self.args, self.kwargs, self.timeout, self.receive_progress, self.caller, self.authid, self.authrole, self.authmethod)



class Interrupt(Message):
   """
   A WAMP `INTERRUPT` message.

   Format: `[INTERRUPT, INVOCATION.Request|id, Options|dict]`
   """

   MESSAGE_TYPE = 69
   """
   The WAMP message code for this type of message.
   """

   ABORT = u'abort'
   KILL = u'kill'


   def __init__(self, request, mode = None):
      """
      Message constructor.

      :param request: The WAMP request ID of the original `INVOCATION` to interrupt.
      :type request: int
      :param mode: Specifies how to interrupt the invocation (`"abort"` or `"kill"`).
      :type mode: str
      """
      assert(type(request) in six.integer_types)
      assert(mode is None or type(mode) == six.text_type)
      assert(mode is None or mode in [self.ABORT, self.KILL])

      Message.__init__(self)
      self.request = request
      self.mode = mode


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Interrupt.MESSAGE_TYPE)

      if len(wmsg) != 3:
         raise ProtocolError("invalid message length {} for INTERRUPT".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in INTERRUPT")
      options = check_or_raise_extra(wmsg[2], "'options' in INTERRUPT")

      ## options
      ##
      mode = None

      if u'mode' in options:

         option_mode = options[u'mode']
         if type(option_mode) != six.text_type:
            raise ProtocolError("invalid type {} for 'mode' option in INTERRUPT".format(type(option_mode)))

         if option_mode not in [Interrupt.ABORT, Interrupt.KILL]:
            raise ProtocolError("invalid value '{}' for 'mode' option in INTERRUPT".format(option_mode))

         mode = option_mode

      obj = Interrupt(request, mode = mode)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      options = {}

      if self.mode is not None:
         options[u'mode'] = self.mode

      return [Interrupt.MESSAGE_TYPE, self.request, options]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP INTERRUPT Message (request = {}, mode = '{}'')".format(self.request, self.mode)



class Yield(Message):
   """
   A WAMP `YIELD` message.

   Formats:
     * `[YIELD, INVOCATION.Request|id, Options|dict]`
     * `[YIELD, INVOCATION.Request|id, Options|dict, Arguments|list]`
     * `[YIELD, INVOCATION.Request|id, Options|dict, Arguments|list, ArgumentsKw|dict]`
   """

   MESSAGE_TYPE = 70
   """
   The WAMP message code for this type of message.
   """


   def __init__(self, request, args = None, kwargs = None, progress = None):
      """
      Message constructor.

      :param request: The WAMP request ID of the original call.
      :type request: int
      :param args: Positional values for application-defined event payload.
                   Must be serializable using any serializers in use.
      :type args: list
      :param kwargs: Keyword values for application-defined event payload.
                     Must be serializable using any serializers in use.
      :type kwargs: dict
      :param progress: If `True`, this result is a progressive invocation result, and subsequent
                       results (or a final error) will follow.
      :type progress: bool
      """
      assert(type(request) in six.integer_types)
      assert(args is None or type(args) in [list, tuple])
      assert(kwargs is None or type(kwargs) == dict)
      assert(progress is None or type(progress) == bool)

      Message.__init__(self)
      self.request = request
      self.args = args
      self.kwargs = kwargs
      self.progress = progress


   @staticmethod
   def parse(wmsg):
      """
      Verifies and parses an unserialized raw message into an actual WAMP message instance.

      :param wmsg: The unserialized raw message.
      :type wmsg: list

      :returns obj -- An instance of this class.
      """
      ## this should already be verified by WampSerializer.unserialize
      ##
      assert(len(wmsg) > 0 and wmsg[0] == Yield.MESSAGE_TYPE)

      if len(wmsg) not in (3, 4, 5):
         raise ProtocolError("invalid message length {} for YIELD".format(len(wmsg)))

      request = check_or_raise_id(wmsg[1], "'request' in YIELD")
      options = check_or_raise_extra(wmsg[2], "'options' in YIELD")

      args = None
      if len(wmsg) > 3:
         args = wmsg[3]
         if type(args) != list:
            raise ProtocolError("invalid type {} for 'args' in YIELD".format(type(args)))

      kwargs = None
      if len(wmsg) > 4:
         kwargs = wmsg[4]
         if type(kwargs) != dict:
            raise ProtocolError("invalid type {} for 'kwargs' in YIELD".format(type(kwargs)))

      progress = None

      if u'progress' in options:

         option_progress = options[u'progress']
         if type(option_progress) != bool:
            raise ProtocolError("invalid type {} for 'progress' option in YIELD".format(type(option_progress)))

         progress = option_progress

      obj = Yield(request, args = args, kwargs = kwargs, progress = progress)

      return obj


   def marshal(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.marshal`
      """
      options = {}

      if self.progress is not None:
         options[u'progress'] = self.progress

      if self.kwargs:
         return [Yield.MESSAGE_TYPE, self.request, options, self.args, self.kwargs]
      elif self.args:
         return [Yield.MESSAGE_TYPE, self.request, options, self.args]
      else:
         return [Yield.MESSAGE_TYPE, self.request, options]


   def __str__(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IMessage.__str__`
      """
      return "WAMP YIELD Message (request = {}, args = {}, kwargs = {}, progress = {})".format(self.request, self.args, self.kwargs, self.progress)

########NEW FILE########
__FILENAME__ = protocol
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

import inspect
import six
from six import StringIO

from autobahn.wamp.interfaces import ISession, \
                                     IPublication, \
                                     IPublisher, \
                                     ISubscription, \
                                     ISubscriber, \
                                     ICaller, \
                                     IRegistration, \
                                     ICallee, \
                                     ITransportHandler

from autobahn import util
from autobahn import wamp
from autobahn.wamp import uri
from autobahn.wamp import message
from autobahn.wamp import types
from autobahn.wamp import role
from autobahn.wamp import exception
from autobahn.wamp.exception import ProtocolError, SessionNotReady
from autobahn.wamp.types import SessionDetails



class Endpoint:
   """
   """

   def __init__(self, obj, fn, procedure, options = None):
      self.obj = obj
      self.fn = fn
      self.procedure = procedure
      self.options = options



class Handler:
   """
   """

   def __init__(self, obj, fn, topic, details_arg = None):
      self.obj = obj
      self.fn = fn
      self.topic = topic
      self.details_arg = details_arg



class Publication:
   """
   Object representing a publication.
   This class implements :class:`autobahn.wamp.interfaces.IPublication`.
   """
   def __init__(self, publicationId):
      self.id = publicationId



IPublication.register(Publication)



class Subscription:
   """
   Object representing a subscription.
   This class implements :class:`autobahn.wamp.interfaces.ISubscription`.
   """
   def __init__(self, session, subscriptionId):
      self._session = session
      self.active = True
      self.id = subscriptionId

   def unsubscribe(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ISubscription.unsubscribe`
      """
      return self._session._unsubscribe(self)



ISubscription.register(Subscription)



class Registration:
   """
   Object representing a registration.
   This class implements :class:`autobahn.wamp.interfaces.IRegistration`.
   """
   def __init__(self, session, registrationId):
      self._session = session
      self.active = True
      self.id = registrationId

   def unregister(self):
      """
      Implements :func:`autobahn.wamp.interfaces.IRegistration.unregister`
      """
      return self._session._unregister(self)



IRegistration.register(Registration)



class BaseSession:
   """
   WAMP session base class.

   This class implements:

     * :class:`autobahn.wamp.interfaces.ISession`
   """

   def __init__(self):
      """
      Ctor.
      """
      ## this is for library level debugging
      self.debug = False

      ## this is for app level debugging. exceptions raised in user code
      ## will get logged (that is, when invoking remoted procedures or
      ## when invoking event handlers)
      self.debug_app = False

      ## this is for marshalling traceback from exceptions thrown in user
      ## code within WAMP error messages (that is, when invoking remoted
      ## procedures)
      self.traceback_app = False

      ## mapping of exception classes to WAMP error URIs
      self._ecls_to_uri_pat = {}

      ## mapping of WAMP error URIs to exception classes
      self._uri_to_ecls = {}

      ## session authentication information
      ##
      self._authid = None
      self._authrole = None
      self._authmethod = None


   def onConnect(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.onConnect`
      """


   def onJoin(self, details):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.onJoin`
      """


   def onLeave(self, details):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.onLeave`
      """


   def onDisconnect(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.onDisconnect`
      """


   def define(self, exception, error = None):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.define`
      """
      if error is None:
         assert(hasattr(exception, '_wampuris'))
         self._ecls_to_uri_pat[exception] = exception._wampuris
         self._uri_to_ecls[exception._wampuris[0].uri()] = exception
      else:
         assert(not hasattr(exception, '_wampuris'))
         self._ecls_to_uri_pat[exception] = [uri.Pattern(six.u(error), uri.Pattern.URI_TARGET_HANDLER)]
         self._uri_to_ecls[six.u(error)] = exception


   def _message_from_exception(self, request_type, request, exc, tb = None):
      """
      Create a WAMP error message from an exception.

      :param request_type: The request type this WAMP error message is for.
      :type request_type: int
      :param request: The request ID this WAMP error message is for.
      :type request: int
      :param exc: The exception.
      :type exc: Instance of :class:`Exception` or subclass thereof.
      :param tb: Optional traceback. If present, it'll be included with the WAMP error message.
      :type tb: list or None
      """
      args = None
      if hasattr(exc, 'args'):
         args = list(exc.args) # make sure tuples are made into lists

      kwargs = None
      if hasattr(exc, 'kwargs'):
         kwargs = exc.kwargs

      if tb:
         if kwargs:
            kwargs['traceback'] = tb
         else:
            kwargs = {'traceback': tb}

      if isinstance(exc, exception.ApplicationError):
         error = exc.error if type(exc.error) == six.text_type else six.u(exc.error)
      else:
         if exc.__class__ in self._ecls_to_uri_pat:
            error = self._ecls_to_uri_pat[exc.__class__][0]._uri
         else:
            error = u"wamp.error.runtime_error"

      msg = message.Error(request_type, request, error, args, kwargs)

      return msg


   def _exception_from_message(self, msg):
      """
      Create a user (or generic) exception from a WAMP error message.

      :param msg: A WAMP error message.
      :type msg: Instance of :class:`autobahn.wamp.message.Error`
      """

      # FIXME:
      # 1. map to ecls based on error URI wildcard/prefix
      # 2. extract additional args/kwargs from error URI

      exc = None

      if msg.error in self._uri_to_ecls:
         ecls = self._uri_to_ecls[msg.error]
         try:
            ## the following might fail, eg. TypeError when
            ## signature of exception constructor is incompatible
            ## with args/kwargs or when the exception constructor raises
            if msg.kwargs:
               if msg.args:
                  exc = ecls(*msg.args, **msg.kwargs)
               else:
                  exc = ecls(**msg.kwargs)
            else:
               if msg.args:
                  exc = ecls(*msg.args)
               else:
                  exc = ecls()
         except Exception as e:
            ## FIXME: log e
            pass

      if not exc:
         ## the following ctor never fails ..
         if msg.kwargs:
            if msg.args:
               exc = exception.ApplicationError(msg.error, *msg.args, **msg.kwargs)
            else:
               exc = exception.ApplicationError(msg.error, **msg.kwargs)
         else:
            if msg.args:
               exc = exception.ApplicationError(msg.error, *msg.args)
            else:
               exc = exception.ApplicationError(msg.error)

      return exc



ISession.register(BaseSession)



class ApplicationSession(BaseSession):
   """
   WAMP endpoint session.

   This class implements:

     * :class:`autobahn.wamp.interfaces.IPublisher`
     * :class:`autobahn.wamp.interfaces.ISubscriber`
     * :class:`autobahn.wamp.interfaces.ICaller`
     * :class:`autobahn.wamp.interfaces.ICallee`
     * :class:`autobahn.wamp.interfaces.ITransportHandler`
   """

   def __init__(self, config = types.ComponentConfig(u"anonymous")):
      """
      Constructor.
      """
      BaseSession.__init__(self)
      self.config = config

      self._transport = None
      self._session_id = None
      self._realm = None

      self._session_id = None
      self._goodbye_sent = False
      self._transport_is_closing = False

      ## outstanding requests
      self._publish_reqs = {}
      self._subscribe_reqs = {}
      self._unsubscribe_reqs = {}
      self._call_reqs = {}
      self._register_reqs = {}
      self._unregister_reqs = {}

      ## subscriptions in place
      self._subscriptions = {}

      ## registrations in place
      self._registrations = {}

      ## incoming invocations
      self._invocations = {}


   def onOpen(self, transport):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransportHandler.onOpen`
      """
      self._transport = transport
      self.onConnect()


   def onConnect(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.onConnect`
      """
      self.join(self.config.realm)


   def join(self, realm):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.join`
      """
      if six.PY2 and type(realm) == str:
         realm = six.u(realm)

      if self._session_id:
         raise Exception("already joined")

      self._goodbye_sent = False

      roles = [
         role.RolePublisherFeatures(),
         role.RoleSubscriberFeatures(),
         role.RoleCallerFeatures(),
         role.RoleCalleeFeatures()
      ]

      msg = message.Hello(realm, roles)
      self._realm = realm
      self._transport.send(msg)


   def disconnect(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.disconnect`
      """
      if self._transport:
         self._transport.close()
      else:
         raise Exception("transport disconnected")


   def onMessage(self, msg):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransportHandler.onMessage`
      """
      if self._session_id is None:

         ## the first message MUST be WELCOME
         if isinstance(msg, message.Welcome):
            self._session_id = msg.session

            details = SessionDetails(self._realm, self._session_id, msg.authid, msg.authrole, msg.authmethod)
            self._as_future(self.onJoin, details)
            #self.onJoin(details)
         else:
            raise ProtocolError("Received {} message, and session is not yet established".format(msg.__class__))

      else:

         if isinstance(msg, message.Goodbye):
            if not self._goodbye_sent:
               ## the peer wants to close: send GOODBYE reply
               reply = message.Goodbye()
               self._transport.send(reply)

            self._session_id = None

            ## fire callback and close the transport
            self.onLeave(types.CloseDetails(msg.reason, msg.message))

         ## consumer messages
         ##
         elif isinstance(msg, message.Event):

            if msg.subscription in self._subscriptions:

               handler = self._subscriptions[msg.subscription]

               if handler.details_arg:
                  if not msg.kwargs:
                     msg.kwargs = {}
                  msg.kwargs[handler.details_arg] = types.EventDetails(publication = msg.publication, publisher = msg.publisher)

               try:
                  if handler.obj:
                     if msg.kwargs:
                        if msg.args:
                           handler.fn(handler.obj, *msg.args, **msg.kwargs)
                        else:
                           handler.fn(handler.obj, **msg.kwargs)
                     else:
                        if msg.args:
                           handler.fn(handler.obj, *msg.args)
                        else:
                           handler.fn(handler.obj)
                  else:
                     if msg.kwargs:
                        if msg.args:
                           handler.fn(*msg.args, **msg.kwargs)
                        else:
                           handler.fn(**msg.kwargs)
                     else:
                        if msg.args:
                           handler.fn(*msg.args)
                        else:
                           handler.fn()

               except Exception as e:
                  if self.debug_app:
                     print("Failure while firing event handler {} subscribed under '{}' ({}):".format(handler.fn, handler.topic, msg.subscription))
                     print(err)

            else:
               raise ProtocolError("EVENT received for non-subscribed subscription ID {}".format(msg.subscription))

         elif isinstance(msg, message.Published):

            if msg.request in self._publish_reqs:
               d, opts = self._publish_reqs.pop(msg.request)
               p = Publication(msg.publication)
               self._resolve_future(d, p)
            else:
               raise ProtocolError("PUBLISHED received for non-pending request ID {}".format(msg.request))

         elif isinstance(msg, message.Subscribed):

            if msg.request in self._subscribe_reqs:
               d, obj, fn, topic, options = self._subscribe_reqs.pop(msg.request)
               if options:
                  self._subscriptions[msg.subscription] = Handler(obj, fn, topic, options.details_arg)
               else:
                  self._subscriptions[msg.subscription] = Handler(obj, fn, topic)
               s = Subscription(self, msg.subscription)
               self._resolve_future(d, s)
            else:
               raise ProtocolError("SUBSCRIBED received for non-pending request ID {}".format(msg.request))

         elif isinstance(msg, message.Unsubscribed):

            if msg.request in self._unsubscribe_reqs:
               d, subscription = self._unsubscribe_reqs.pop(msg.request)
               if subscription.id in self._subscriptions:
                  del self._subscriptions[subscription.id]
               subscription.active = False
               self._resolve_future(d, None)
            else:
               raise ProtocolError("UNSUBSCRIBED received for non-pending request ID {}".format(msg.request))

         elif isinstance(msg, message.Result):

            if msg.request in self._call_reqs:

               if msg.progress:

                  ## progressive result
                  ##
                  _, opts = self._call_reqs[msg.request]
                  if opts.onProgress:
                     try:
                        if msg.kwargs:
                           if msg.args:
                              opts.onProgress(*msg.args, **msg.kwargs)
                           else:
                              opts.onProgress(**msg.kwargs)
                        else:
                           if msg.args:
                              opts.onProgress(*msg.args)
                           else:
                              opts.onProgress()
                     except Exception as e:
                        ## silently drop exceptions raised in progressive results handlers
                        if self.debug:
                           print("Exception raised in progressive results handler: {}".format(e))
                  else:
                     ## silently ignore progressive results
                     pass
               else:

                  ## final result
                  ##
                  d, opts = self._call_reqs.pop(msg.request)
                  if msg.kwargs:
                     if msg.args:
                        res = types.CallResult(*msg.args, **msg.kwargs)
                     else:
                        res = types.CallResult(**msg.kwargs)
                     self._resolve_future(d, res)
                  else:
                     if msg.args:
                        if len(msg.args) > 1:
                           res = types.CallResult(*msg.args)
                           self._resolve_future(d, res)
                        else:
                           self._resolve_future(d, msg.args[0])
                     else:
                        self._resolve_future(d, None)
            else:
               raise ProtocolError("RESULT received for non-pending request ID {}".format(msg.request))

         elif isinstance(msg, message.Invocation):

            if msg.request in self._invocations:

               raise ProtocolError("INVOCATION received for request ID {} already invoked".format(msg.request))

            else:

               if msg.registration not in self._registrations:

                  raise ProtocolError("INVOCATION received for non-registered registration ID {}".format(msg.registration))

               else:
                  endpoint = self._registrations[msg.registration]

                  if endpoint.options and endpoint.options.details_arg:

                     if not msg.kwargs:
                        msg.kwargs = {}

                     if msg.receive_progress:
                        def progress(*args, **kwargs):
                           progress_msg = message.Yield(msg.request, args = args, kwargs = kwargs, progress = True)
                           self._transport.send(progress_msg)
                     else:
                        progress = None

                     msg.kwargs[endpoint.options.details_arg] = types.CallDetails(progress, caller = msg.caller, authid = msg.authid, authrole = msg.authrole, authmethod = msg.authmethod)

                  if endpoint.obj:
                     if msg.kwargs:
                        if msg.args:
                           d = self._as_future(endpoint.fn, endpoint.obj, *msg.args, **msg.kwargs)
                        else:
                           d = self._as_future(endpoint.fn, endpoint.obj, **msg.kwargs)
                     else:
                        if msg.args:
                           d = self._as_future(endpoint.fn, endpoint.obj, *msg.args)
                        else:
                           d = self._as_future(endpoint.fn, endpoint.obj)
                  else:
                     if msg.kwargs:
                        if msg.args:
                           d = self._as_future(endpoint.fn, *msg.args, **msg.kwargs)
                        else:
                           d = self._as_future(endpoint.fn, **msg.kwargs)
                     else:
                        if msg.args:
                           d = self._as_future(endpoint.fn, *msg.args)
                        else:
                           d = self._as_future(endpoint.fn)

                  def success(res):
                     del self._invocations[msg.request]

                     if isinstance(res, types.CallResult):
                        reply = message.Yield(msg.request, args = res.results, kwargs = res.kwresults)
                     else:
                        reply = message.Yield(msg.request, args = [res])
                     self._transport.send(reply)

                  def error(err):
                     if self.traceback_app:
                        ## if asked to marshal the traceback within the WAMP error message, extract it
                        tb = StringIO()
                        err.printTraceback(file = tb)
                        tb = tb.getvalue().splitlines()
                     else:
                        tb = None

                     if self.debug_app:
                        print("Failure while invoking procedure {} registered under '{}' ({}):".format(endpoint.fn, endpoint.procedure, msg.registration))
                        print(err)

                     del self._invocations[msg.request]

                     if hasattr(err, 'value'):
                        exc = err.value
                     else:
                        exc = err
                     reply = self._message_from_exception(message.Invocation.MESSAGE_TYPE, msg.request, exc, tb)
                     self._transport.send(reply)

                  self._invocations[msg.request] = d

                  self._add_future_callbacks(d, success, error)

         elif isinstance(msg, message.Interrupt):

            if msg.request not in self._invocations:
               raise ProtocolError("INTERRUPT received for non-pending invocation {}".format(msg.request))
            else:
               try:
                  self._invocations[msg.request].cancel()
               except Exception as e:
                  if self.debug:
                     print("could not cancel call {}".format(msg.request))
               finally:
                  del self._invocations[msg.request]

         elif isinstance(msg, message.Registered):

            if msg.request in self._register_reqs:
               d, obj, fn, procedure, options = self._register_reqs.pop(msg.request)
               self._registrations[msg.registration] = Endpoint(obj, fn, procedure, options)
               r = Registration(self, msg.registration)
               self._resolve_future(d, r)
            else:
               raise ProtocolError("REGISTERED received for non-pending request ID {}".format(msg.request))

         elif isinstance(msg, message.Unregistered):

            if msg.request in self._unregister_reqs:
               d, registration = self._unregister_reqs.pop(msg.request)
               if registration.id in self._registrations:
                  del self._registrations[registration.id]
               registration.active = False
               self._resolve_future(d, None)
            else:
               raise ProtocolError("UNREGISTERED received for non-pending request ID {}".format(msg.request))

         elif isinstance(msg, message.Error):

            d = None

            ## ERROR reply to PUBLISH
            ##
            if msg.request_type == message.Publish.MESSAGE_TYPE and msg.request in self._publish_reqs:
               d = self._publish_reqs.pop(msg.request)[0]

            ## ERROR reply to SUBSCRIBE
            ##
            elif msg.request_type == message.Subscribe.MESSAGE_TYPE and msg.request in self._subscribe_reqs:
               d = self._subscribe_reqs.pop(msg.request)[0]

            ## ERROR reply to UNSUBSCRIBE
            ##
            elif msg.request_type == message.Unsubscribe.MESSAGE_TYPE and msg.request in self._unsubscribe_reqs:
               d = self._unsubscribe_reqs.pop(msg.request)[0]

            ## ERROR reply to REGISTER
            ##
            elif msg.request_type == message.Register.MESSAGE_TYPE and msg.request in self._register_reqs:
               d = self._register_reqs.pop(msg.request)[0]

            ## ERROR reply to UNREGISTER
            ##
            elif msg.request_type == message.Unregister.MESSAGE_TYPE and msg.request in self._unregister_reqs:
               d = self._unregister_reqs.pop(msg.request)[0]

            ## ERROR reply to CALL
            ##
            elif msg.request_type == message.Call.MESSAGE_TYPE and msg.request in self._call_reqs:
               d = self._call_reqs.pop(msg.request)[0]

            if d:
               self._reject_future(d, self._exception_from_message(msg))
            else:
               raise ProtocolError("WampAppSession.onMessage(): ERROR received for non-pending request_type {} and request ID {}".format(msg.request_type, msg.request))

         elif isinstance(msg, message.Heartbeat):

            pass ## FIXME

         else:

            raise ProtocolError("Unexpected message {}".format(msg.__class__))


   def onClose(self, wasClean):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransportHandler.onClose`
      """
      self._transport = None

      if self._session_id:

         ## fire callback and close the transport
         try:
            self.onLeave(types.CloseDetails())
         except Exception as e:
            if self.debug:
               print("exception raised in onLeave callback: {}".format(e))

         self._session_id = None

      self.onDisconnect()


   def onJoin(self, details):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.onJoin`
      """


   def onLeave(self, details):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.onLeave`
      """
      self.disconnect()


   def leave(self, reason = None, log_message = None):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.leave`
      """
      if not self._session_id:
         raise Exception("not joined")

      if not self._goodbye_sent:
         if not reason:
            reason = u"wamp.close.normal"
         msg = wamp.message.Goodbye(reason = reason, message = log_message)
         self._transport.send(msg)
         self._goodbye_sent = True
      else:
         raise SessionNotReady("Already requested to close the session")


   def publish(self, topic, *args, **kwargs):
      """
      Implements :func:`autobahn.wamp.interfaces.IPublisher.publish`
      """
      if six.PY2 and type(topic) == str:
         topic = six.u(topic)
      assert(type(topic) == six.text_type)

      if not self._transport:
         raise exception.TransportLost()

      request = util.id()

      if 'options' in kwargs and isinstance(kwargs['options'], types.PublishOptions):
         opts = kwargs.pop('options')
         msg = message.Publish(request, topic, args = args, kwargs = kwargs, **opts.options)
      else:
         opts = None
         msg = message.Publish(request, topic, args = args, kwargs = kwargs)

      if opts and opts.options['acknowledge'] == True:
         d = self._create_future()
         self._publish_reqs[request] = d, opts
         self._transport.send(msg)
         return d
      else:
         self._transport.send(msg)
         return


   def subscribe(self, handler, topic = None, options = None):
      """
      Implements :func:`autobahn.wamp.interfaces.ISubscriber.subscribe`
      """
      assert((callable(handler) and topic is not None) or hasattr(handler, '__class__'))
      if topic and six.PY2 and type(topic) == str:
         topic = six.u(topic)
      assert(topic is None or type(topic) == six.text_type)
      assert(options is None or isinstance(options, types.SubscribeOptions))

      if not self._transport:
         raise exception.TransportLost()

      def _subscribe(obj, handler, topic, options):
         request = util.id()

         d = self._create_future()
         self._subscribe_reqs[request] = (d, obj, handler, topic, options)

         if options is not None:
            msg = message.Subscribe(request, topic, **options.options)
         else:
            msg = message.Subscribe(request, topic)

         self._transport.send(msg)
         return d

      if callable(handler):
         ## register a single handler
         ##
         return _subscribe(None, handler, topic, options)

      else:
         ## register all methods on an object
         ## decorated with "wamp.topic"
         ##
         dl = []

         test = lambda x: inspect.ismethod(x) or inspect.isfunction(x)
         for k in inspect.getmembers(handler.__class__, test):
            proc = k[1]
            if "_wampuris" in proc.__dict__:
               pat = proc.__dict__["_wampuris"][0]
               if pat.is_handler():
                  uri = pat.uri()
                  dl.append(_subscribe(handler, proc, uri, options))
         return self._gather_futures(dl, consume_exceptions = True)


   def _unsubscribe(self, subscription):
      """
      Called from :meth:`autobahn.wamp.protocol.Subscription.unsubscribe`
      """
      assert(isinstance(subscription, Subscription))
      assert(subscription.active)
      assert(subscription.id in self._subscriptions)

      if not self._transport:
         raise exception.TransportLost()

      request = util.id()

      d = self._create_future()
      self._unsubscribe_reqs[request] = (d, subscription)

      msg = message.Unsubscribe(request, subscription.id)

      self._transport.send(msg)
      return d


   def call(self, procedure, *args, **kwargs):
      """
      Implements :func:`autobahn.wamp.interfaces.ICaller.call`
      """
      if six.PY2 and type(procedure) == str:
         procedure = six.u(procedure)
      assert(isinstance(procedure, six.text_type))

      if not self._transport:
         raise exception.TransportLost()

      request = util.id()

      if 'options' in kwargs and isinstance(kwargs['options'], types.CallOptions):
         opts = kwargs.pop('options')
         msg = message.Call(request, procedure, args = args, kwargs = kwargs, **opts.options)
      else:
         opts = None
         msg = message.Call(request, procedure, args = args, kwargs = kwargs)

      ## FIXME
      #def canceller(_d):
      #   cancel_msg = message.Cancel(request)
      #   self._transport.send(cancel_msg)
      #d = Deferred(canceller)
      d = self._create_future()
      self._call_reqs[request] = d, opts

      self._transport.send(msg)
      return d


   def register(self, endpoint, procedure = None, options = None):
      """
      Implements :func:`autobahn.wamp.interfaces.ICallee.register`
      """
      assert((callable(endpoint) and procedure is not None) or hasattr(endpoint, '__class__'))
      if procedure and six.PY2 and type(procedure) == str:
         procedure = six.u(procedure)
      assert(procedure is None or type(procedure) == six.text_type)
      assert(options is None or isinstance(options, types.RegisterOptions))

      if not self._transport:
         raise exception.TransportLost()

      def _register(obj, endpoint, procedure, options):
         request = util.id()

         d = self._create_future()
         self._register_reqs[request] = (d, obj, endpoint, procedure, options)

         if options is not None:
            msg = message.Register(request, procedure, **options.options)
         else:
            msg = message.Register(request, procedure)

         self._transport.send(msg)
         return d

      if callable(endpoint):
         ## register a single callable
         ##
         return _register(None, endpoint, procedure, options)

      else:
         ## register all methods on an object
         ## decorated with "wamp.procedure"
         ##
         dl = []

         test = lambda x: inspect.ismethod(x) or inspect.isfunction(x)
         for k in inspect.getmembers(endpoint.__class__, test):
            proc = k[1]
            if "_wampuris" in proc.__dict__:
               pat = proc.__dict__["_wampuris"][0]
               if pat.is_endpoint():
                  uri = pat.uri()
                  dl.append(_register(endpoint, proc, uri, options))
         return self._gather_futures(dl, consume_exceptions = True)


   def _unregister(self, registration):
      """
      Called from :meth:`autobahn.wamp.protocol.Registration.unregister`
      """
      assert(isinstance(registration, Registration))
      assert(registration.active)
      assert(registration.id in self._registrations)

      if not self._transport:
         raise exception.TransportLost()

      request = util.id()

      d = self._create_future()
      self._unregister_reqs[request] = (d, registration)

      msg = message.Unregister(request, registration.id)

      self._transport.send(msg)
      return d



IPublisher.register(ApplicationSession)
ISubscriber.register(ApplicationSession)
ICaller.register(ApplicationSession)
#ICallee.register(ApplicationSession) ## FIXME: ".register" collides with the ABC "register" method
ITransportHandler.register(ApplicationSession)



class ApplicationSessionFactory:
   """
   WAMP endpoint session factory.
   """

   session = ApplicationSession
   """
   WAMP application session class to be used in this factory.
   """

   def __init__(self, config = types.ComponentConfig(u"anonymous")):
      """
      Ctor.

      :param config: The default component configuration.
      :type config: instance of :class:`autobahn.wamp.types.ComponentConfig`
      """
      self.config = config


   def __call__(self):
      """
      Creates a new WAMP application session.

      :returns: -- An instance of the WAMP application session class as
                   given by `self.session`.
      """
      session = self.session(self.config)
      session.factory = self
      return session



class RouterApplicationSession:
   """
   Wraps an application session to run directly attached to a WAMP router (broker+dealer).
   """

   def __init__(self, session, routerFactory):
      """
      Wrap an application session and add it to the given broker and dealer.

      :param session: Application session to wrap.
      :type session: An instance that implements :class:`autobahn.wamp.interfaces.ISession`
      :param routerFactory: The router factory to associate this session with.
      :type routerFactory: An instance that implements :class:`autobahn.wamp.interfaces.IRouterFactory`
      """

      ## remember router we are wrapping the app session for
      ##
      self._routerFactory = routerFactory
      self._router = None

      ## remember wrapped app session
      ##
      self._session = session

      ## set fake transport on session ("pass-through transport")
      ##
      self._session._transport = self

      self._session.onConnect()


   def isOpen(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransport.isOpen`
      """


   def close(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransport.close`
      """
      if self._router:
         self._router.detach(self._session)


   def abort(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransport.abort`
      """


   def send(self, msg):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransport.send`
      """
      if isinstance(msg, message.Hello):

         self._router = self._routerFactory.get(msg.realm)

         ## fake session ID assignment (normally done in WAMP opening handshake)
         self._session._session_id = util.id()

         ## add app session to router
         self._router.attach(self._session)

         ## fake app session open
         ##
         details = SessionDetails(self._session._realm, self._session._session_id)
         self._session._as_future(self._session.onJoin, details)
         #self._session.onJoin(details)


      ## app-to-router
      ##
      elif isinstance(msg, message.Publish) or \
           isinstance(msg, message.Subscribe) or \
           isinstance(msg, message.Unsubscribe) or \
           isinstance(msg, message.Call) or \
           isinstance(msg, message.Yield) or \
           isinstance(msg, message.Register) or \
           isinstance(msg, message.Unregister) or \
           isinstance(msg, message.Cancel) or \
          (isinstance(msg, message.Error) and
               msg.request_type == message.Invocation.MESSAGE_TYPE):

         ## deliver message to router
         ##
         self._router.process(self._session, msg)

      ## router-to-app
      ##
      elif isinstance(msg, message.Event) or \
           isinstance(msg, message.Invocation) or \
           isinstance(msg, message.Result) or \
           isinstance(msg, message.Published) or \
           isinstance(msg, message.Subscribed) or \
           isinstance(msg, message.Unsubscribed) or \
           isinstance(msg, message.Registered) or \
           isinstance(msg, message.Unregistered) or \
          (isinstance(msg, message.Error) and (
               msg.request_type == message.Call.MESSAGE_TYPE or
               msg.request_type == message.Cancel.MESSAGE_TYPE or
               msg.request_type == message.Register.MESSAGE_TYPE or
               msg.request_type == message.Unregister.MESSAGE_TYPE or
               msg.request_type == message.Publish.MESSAGE_TYPE or
               msg.request_type == message.Subscribe.MESSAGE_TYPE or
               msg.request_type == message.Unsubscribe.MESSAGE_TYPE)):

         ## deliver message to app session
         ##
         self._session.onMessage(msg)

      else:
         ## should not arrive here
         ##
         raise Exception("RouterApplicationSession.send: unhandled message {}".format(msg))



class RouterSession(BaseSession):
   """
   WAMP router session.

   This class implements:

     * :class:`autobahn.wamp.interfaces.ITransportHandler`
   """

   def __init__(self, routerFactory):
      """
      Constructor.
      """
      BaseSession.__init__(self)
      self._transport = None

      self._router_factory = routerFactory
      self._router = None
      self._realm = None

      self._goodbye_sent = False
      self._transport_is_closing = False


   def onOpen(self, transport):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransportHandler.onOpen`
      """
      self._transport = transport

      self._realm = None
      self._session_id = None

      ## session authentication information
      ##
      self._authid = None
      self._authrole = None
      self._authmethod = None


   def onHello(self, realm, details):
      return types.Accept()


   def onAuthenticate(self, signature, extra):
      return types.Accept()


   def onMessage(self, msg):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransportHandler.onMessage`
      """
      if self._session_id is None:

         def welcome(realm, authid = None, authrole = None, authmethod = None):
            self._session_id = util.id()
            self._goodbye_sent = False

            self._router = self._router_factory.get(realm)
            if not self._router:
               raise Exception("no such realm")

            self._authid = authid
            self._authrole = authrole
            self._authmethod = authmethod

            roles = self._router.attach(self)

            msg = message.Welcome(self._session_id, roles, authid = authid, authrole = authrole, authmethod = authmethod)
            self._transport.send(msg)

            self.onJoin(SessionDetails(self._realm, self._session_id, self._authid, self._authrole, self._authmethod))

         ## the first message MUST be HELLO
         if isinstance(msg, message.Hello):

            self._realm = msg.realm

            details = types.HelloDetails(msg.roles, msg.authmethods)

            d = self._as_future(self.onHello, self._realm, details)

            def success(res):
               msg = None

               if isinstance(res, types.Accept):
                  welcome(self._realm, res.authid, res.authrole, res.authmethod)

               elif isinstance(res, types.Challenge):
                  msg = message.Challenge(res.method, res.extra)

               elif isinstance(res, types.Deny):
                  msg = message.Abort(res.reason, res.message)

               else:
                  pass

               if msg:
                  self._transport.send(msg)

            def failed(err):
               print(err.value)

            self._add_future_callbacks(d, success, failed)

         elif isinstance(msg, message.Authenticate):

            d = self._as_future(self.onAuthenticate, msg.signature, {})

            def success(res):
               msg = None

               if isinstance(res, types.Accept):
                  welcome(self._realm, res.authid, res.authrole, res.authmethod)

               elif isinstance(res, types.Deny):
                  msg = message.Abort(res.reason, res.message)

               else:
                  pass

               if msg:
                  self._transport.send(msg)

            def failed(err):
               print(err.value)

            self._add_future_callbacks(d, success, failed)

         else:
            raise ProtocolError("Received {} message, and session is not yet established".format(msg.__class__))

      else:

         if isinstance(msg, message.Hello):
            raise ProtocolError("HELLO message received, while session is already established")

         elif isinstance(msg, message.Goodbye):
            if not self._goodbye_sent:
               ## the peer wants to close: send GOODBYE reply
               reply = message.Goodbye()
               self._transport.send(reply)

            ## fire callback and close the transport
            self.onLeave(types.CloseDetails(msg.reason, msg.message))

            self._router.detach(self)

            self._session_id = None

            #self._transport.close()

         elif isinstance(msg, message.Heartbeat):

            pass ## FIXME

         else:

            self._router.process(self, msg)


   def onClose(self, wasClean):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransportHandler.onClose`
      """
      self._transport = None

      if self._session_id:

         ## fire callback and close the transport
         try:
            self.onLeave(types.CloseDetails())
         except Exception as e:
            if self.debug:
               print("exception raised in onLeave callback: {}".format(e))

         self._router.detach(self)

         self._session_id = None

      self._authid = None
      self._authrole = None
      self._authmethod = None


   def onJoin(self, details):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.onJoin`
      """


   def onLeave(self, details):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.onLeave`
      """


   def leave(self, reason = None, message = None):
      """
      Implements :func:`autobahn.wamp.interfaces.ISession.leave`
      """
      if not self._goodbye_sent:
         msg = wamp.message.Goodbye(reason = reason, message = message)
         self._transport.send(msg)
         self._goodbye_sent = True
      else:
         raise SessionNotReady("Already requested to close the session")



ITransportHandler.register(RouterSession)



class RouterSessionFactory:
   """
   WAMP router session factory.
   """

   session = RouterSession
   """
   WAMP router session class to be used in this factory.
   """


   def __init__(self, routerFactory):
      """
      Constructor.
      """
      self._routerFactory = routerFactory
      self._app_sessions = {}


   def add(self, session):
      """
      Adds a WAMP application session to run directly in this router.

      :param: session: A WAMP application session.
      :type session: A instance of a class that derives of :class:`autobahn.wamp.protocol.WampAppSession`
      """
      #router = self._routerFactory.get(session.realm)
      self._app_sessions[session] = RouterApplicationSession(session, self._routerFactory)


   def remove(self, session):
      """
      Removes a WAMP application session running directly in this router.
      """
      if session in self._app_sessions:
         self._app_sessions[session]._session.disconnect()
         del self._app_sessions[session]



   def __call__(self):
      """
      Creates a new WAMP router session.

      :returns: -- An instance of the WAMP router session class as
                   given by `self.session`.
      """
      session = self.session(self._routerFactory)
      session.factory = session
      return session

########NEW FILE########
__FILENAME__ = role
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

__all__ = ['RoleFeatures',
           'RoleBrokerFeatures',
           'RoleSubscriberFeatures',
           'RolePublisherFeatures',
           'RoleDealerFeatures',
           'RoleCallerFeatures',
           'RoleCalleeFeatures',
           'ROLE_NAME_TO_CLASS']


import json, types
from autobahn import util
from autobahn.wamp.exception import ProtocolError


class RoleFeatures(util.EqualityMixin):

   ROLE = None

   def __str__(self):
      return json.dumps(self.__dict__)

   def _check_all_bool(self):
      ## check feature attributes
      for k in self.__dict__:
         if not k.startswith('_') and k != 'ROLE':
            if getattr(self, k) is not None and type(getattr(self, k)) != bool:
               raise ProtocolError("invalid type {} for feature '{}' for role '{}'".format(getattr(self, k), k, self.ROLE))



class RoleCommonPubSubFeatures(RoleFeatures):

   def __init__(self,
                publisher_identification = None,
                partitioned_pubsub = None):

      self.publisher_identification = publisher_identification
      self.partitioned_pubsub = partitioned_pubsub



class RoleBrokerFeatures(RoleCommonPubSubFeatures):
   
   ROLE = u'broker'

   def __init__(self,
                subscriber_blackwhite_listing = None,
                publisher_exclusion = None,
                publication_trustlevels = None,
                pattern_based_subscription = None,
                subscriber_metaevents = None,
                subscriber_list = None,
                event_history = None,
                **kwargs):
      self.subscriber_blackwhite_listing = subscriber_blackwhite_listing
      self.publisher_exclusion = publisher_exclusion
      self.publication_trustlevels = publication_trustlevels
      self.pattern_based_subscription = pattern_based_subscription
      self.subscriber_metaevents = subscriber_metaevents
      self.subscriber_list = subscriber_list
      self.event_history = event_history
      RoleCommonPubSubFeatures.__init__(self, **kwargs)
      self._check_all_bool()



class RoleSubscriberFeatures(RoleCommonPubSubFeatures):
   
   ROLE = u'subscriber'

   def __init__(self,
                publication_trustlevels = None,
                pattern_based_subscription = None,
                subscriber_metaevents = None,
                subscriber_list = None,
                event_history = None,
                **kwargs):
      self.publication_trustlevels = publication_trustlevels
      self.pattern_based_subscription = pattern_based_subscription
      self.subscriber_metaevents = subscriber_metaevents
      self.subscriber_list = subscriber_list
      self.event_history = event_history
      RoleCommonPubSubFeatures.__init__(self, **kwargs)
      self._check_all_bool()



class RolePublisherFeatures(RoleCommonPubSubFeatures):
   
   ROLE = u'publisher'

   def __init__(self,
                subscriber_blackwhite_listing = None,
                publisher_exclusion = None,
                **kwargs):
      self.subscriber_blackwhite_listing = subscriber_blackwhite_listing
      self.publisher_exclusion = publisher_exclusion
      RoleCommonPubSubFeatures.__init__(self, **kwargs)
      self._check_all_bool()



class RoleCommonRpcFeatures(RoleFeatures):

   def __init__(self,
                caller_identification = None,
                partitioned_rpc = None,
                call_timeout = None,
                call_canceling = None,
                progressive_call_results = None):
      self.caller_identification = caller_identification
      self.partitioned_rpc = partitioned_rpc
      self.call_timeout = call_timeout
      self.call_canceling = call_canceling
      self.progressive_call_results = progressive_call_results



class RoleDealerFeatures(RoleCommonRpcFeatures):

   ROLE = u'dealer'

   def __init__(self,
                callee_blackwhite_listing = None,
                caller_exclusion = None,
                call_trustlevels = None,
                pattern_based_registration = None,
                **kwargs):
      self.callee_blackwhite_listing = callee_blackwhite_listing
      self.caller_exclusion = caller_exclusion
      self.call_trustlevels = call_trustlevels
      self.pattern_based_registration = pattern_based_registration  
      RoleCommonRpcFeatures.__init__(self, **kwargs)
      self._check_all_bool()



class RoleCallerFeatures(RoleCommonRpcFeatures):

   ROLE = u'caller'

   def __init__(self,
                callee_blackwhite_listing = None,
                caller_exclusion = None,
                **kwargs):
      self.callee_blackwhite_listing = callee_blackwhite_listing
      self.caller_exclusion = caller_exclusion
      RoleCommonRpcFeatures.__init__(self, **kwargs)
      self._check_all_bool()



class RoleCalleeFeatures(RoleCommonRpcFeatures):

   ROLE = u'callee'

   def __init__(self,
                call_trustlevels = None,
                pattern_based_registration = None,
                **kwargs):
      self.call_trustlevels = call_trustlevels
      self.pattern_based_registration = pattern_based_registration  
      RoleCommonRpcFeatures.__init__(self, **kwargs)
      self._check_all_bool()



ROLE_NAME_TO_CLASS = {
   u'broker': RoleBrokerFeatures,
   u'subscriber': RoleSubscriberFeatures,
   u'publisher': RolePublisherFeatures,
   u'dealer': RoleDealerFeatures,
   u'caller': RoleCallerFeatures,
   u'callee': RoleCalleeFeatures,
}

########NEW FILE########
__FILENAME__ = router
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from autobahn.wamp import types
from autobahn.wamp import role
from autobahn.wamp import message
from autobahn.wamp.exception import ProtocolError
from autobahn.wamp.broker import Broker
from autobahn.wamp.dealer import Dealer
from autobahn.wamp.interfaces import IRouter, IRouterFactory


class Router:
   """
   Basic WAMP router.

   This class implements :class:`autobahn.wamp.interfaces.IRouter`.
   """

   def __init__(self, factory, realm, options = None):
      """
      Ctor.

      :param factory: The router factory this router was created by.
      :type factory: Object that implements :class:`autobahn.wamp.interfaces.IRouterFactory`..
      :param realm: The realm this router is working for.
      :type realm: str
      :param options: Router options.
      :type options: Instance of :class:`autobahn.wamp.types.RouterOptions`.
      """
      self.debug = False
      self.factory = factory
      self.realm = realm
      self._options = options or types.RouterOptions()
      self._broker = Broker(realm, self._options)
      self._dealer = Dealer(realm, self._options)
      self._attached = 0


   def attach(self, session):
      """
      Implements :func:`autobahn.wamp.interfaces.IRouter.attach`
      """
      self._broker.attach(session)
      self._dealer.attach(session)
      self._attached += 1

      return [self._broker._role_features, self._dealer._role_features]


   def detach(self, session):
      """
      Implements :func:`autobahn.wamp.interfaces.IRouter.detach`
      """
      self._broker.detach(session)
      self._dealer.detach(session)
      self._attached -= 1
      if not self._attached:
         self.factory.onLastDetach(self)


   def process(self, session, msg):
      """
      Implements :func:`autobahn.wamp.interfaces.IRouter.process`
      """
      if self.debug:
         print("Router.process: {}".format(msg))

      ## Broker
      ##
      if isinstance(msg, message.Publish):
         self._broker.processPublish(session, msg)

      elif isinstance(msg, message.Subscribe):
         self._broker.processSubscribe(session, msg)

      elif isinstance(msg, message.Unsubscribe):
         self._broker.processUnsubscribe(session, msg)

      ## Dealer
      ##
      elif isinstance(msg, message.Register):
         self._dealer.processRegister(session, msg)

      elif isinstance(msg, message.Unregister):
         self._dealer.processUnregister(session, msg)

      elif isinstance(msg, message.Call):
         self._dealer.processCall(session, msg)

      elif isinstance(msg, message.Cancel):
         self._dealer.processCancel(session, msg)

      elif isinstance(msg, message.Yield):
         self._dealer.processYield(session, msg)

      elif isinstance(msg, message.Error) and msg.request_type == message.Invocation.MESSAGE_TYPE:
         self._dealer.processInvocationError(session, msg)

      else:
         raise ProtocolError("Unexpected message {}".format(msg.__class__))



IRouter.register(Router)



class RouterFactory:
   """
   Basic WAMP Router factory.

   This class implements :class:`autobahn.wamp.interfaces.IRouterFactory`.
   """

   def __init__(self, options = None, debug = False):
      """
      Ctor.

      :param options: Default router options.
      :type options: Instance of :class:`autobahn.wamp.types.RouterOptions`.      
      """
      self._routers = {}
      self.debug = debug
      self._options = options or types.RouterOptions()


   def get(self, realm):
      """
      Implements :func:`autobahn.wamp.interfaces.IRouterFactory.get`
      """
      if not realm in self._routers:
         self._routers[realm] = Router(self, realm, self._options)
         if self.debug:
            print("Router created for realm '{}'".format(realm))
      return self._routers[realm]


   def onLastDetach(self, router):
      assert(router.realm in self._routers)
      del self._routers[router.realm]
      if self.debug:
         print("Router destroyed for realm '{}'".format(router.realm))



IRouterFactory.register(RouterFactory)

########NEW FILE########
__FILENAME__ = serializer
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

__all__ = ['Serializer',
           'JsonObjectSerializer',
           'JsonSerializer']

import six

from autobahn.wamp.interfaces import IObjectSerializer, ISerializer
from autobahn.wamp.exception import ProtocolError
from autobahn.wamp import message



class Serializer:
   """
   Base class for WAMP serializers. A WAMP serializer is the core glue between
   parsed WAMP message objects and the bytes on wire (the transport).
   """

   MESSAGE_TYPE_MAP = {
      message.Hello.MESSAGE_TYPE:           message.Hello,
      message.Welcome.MESSAGE_TYPE:         message.Welcome,
      message.Abort.MESSAGE_TYPE:           message.Abort,
      message.Challenge.MESSAGE_TYPE:       message.Challenge,
      message.Authenticate.MESSAGE_TYPE:    message.Authenticate,
      message.Goodbye.MESSAGE_TYPE:         message.Goodbye,
      message.Heartbeat.MESSAGE_TYPE:       message.Heartbeat,
      message.Error.MESSAGE_TYPE:           message.Error,

      message.Publish.MESSAGE_TYPE:         message.Publish,
      message.Published.MESSAGE_TYPE:       message.Published,

      message.Subscribe.MESSAGE_TYPE:       message.Subscribe,
      message.Subscribed.MESSAGE_TYPE:      message.Subscribed,
      message.Unsubscribe.MESSAGE_TYPE:     message.Unsubscribe,
      message.Unsubscribed.MESSAGE_TYPE:    message.Unsubscribed,
      message.Event.MESSAGE_TYPE:           message.Event,

      message.Call.MESSAGE_TYPE:            message.Call,
      message.Cancel.MESSAGE_TYPE:          message.Cancel,
      message.Result.MESSAGE_TYPE:          message.Result,

      message.Register.MESSAGE_TYPE:        message.Register,
      message.Registered.MESSAGE_TYPE:      message.Registered,
      message.Unregister.MESSAGE_TYPE:      message.Unregister,
      message.Unregistered.MESSAGE_TYPE:    message.Unregistered,
      message.Invocation.MESSAGE_TYPE:      message.Invocation,
      message.Interrupt.MESSAGE_TYPE:       message.Interrupt,
      message.Yield.MESSAGE_TYPE:           message.Yield
   }
   """
   Mapping of WAMP message type codes to WAMP message classes.
   """


   def __init__(self, serializer):
      """
      Constructor.

      :param serializer: The object serializer to use for WAMP wire-level serialization.
      :type serializer: An object that implements :class:`autobahn.interfaces.IObjectSerializer`.
      """
      self._serializer = serializer


   def serialize(self, msg):
      """
      Implements :func:`autobahn.wamp.interfaces.ISerializer.serialize`
      """
      return msg.serialize(self._serializer), self._serializer.BINARY


   def unserialize(self, payload, isBinary = None):
      """
      Implements :func:`autobahn.wamp.interfaces.ISerializer.unserialize`
      """
      if isBinary is not None:
         if isBinary != self._serializer.BINARY:
            raise ProtocolError("invalid serialization of WAMP message (binary {}, but expected {})".format(isBinary, self._serializer.BINARY))

      try:
         raw_msg = self._serializer.unserialize(payload)
      except Exception as e:
         raise ProtocolError("invalid serialization of WAMP message ({})".format(e))

      if type(raw_msg) != list:
         raise ProtocolError("invalid type {} for WAMP message".format(type(raw_msg)))

      if len(raw_msg) == 0:
         raise ProtocolError("missing message type in WAMP message")

      message_type = raw_msg[0]

      if type(message_type) != int:
         raise ProtocolError("invalid type {} for WAMP message type".format(type(message_type)))

      Klass = self.MESSAGE_TYPE_MAP.get(message_type)

      if Klass is None:
         raise ProtocolError("invalid WAMP message type {}".format(message_type))

      ## this might again raise `ProtocolError` ..
      msg = Klass.parse(raw_msg)

      return msg


##
## JSON serialization is always supported
##
import json

class JsonObjectSerializer:

   BINARY = False

   def serialize(self, obj):
      """
      Implements :func:`autobahn.wamp.interfaces.IObjectSerializer.serialize`
      """
      s = json.dumps(obj, separators = (',',':'))
      if six.PY3:
         return s.encode('utf8')
      else:
         return s


   def unserialize(self, payload):
      """
      Implements :func:`autobahn.wamp.interfaces.IObjectSerializer.unserialize`
      """
      if six.PY3:
         return json.loads(payload.decode('utf8'))
      else:
         return json.loads(payload)



IObjectSerializer.register(JsonObjectSerializer)



class JsonSerializer(Serializer):

   SERIALIZER_ID = "json"

   def __init__(self):
      Serializer.__init__(self, JsonObjectSerializer())



ISerializer.register(JsonSerializer)




##
## MsgPack serialization depends on the `msgpack` package being available
##
try:
   import msgpack
except ImportError:
   pass
else:

   class MsgPackObjectSerializer:

      BINARY = True
      """
      Flag that indicates whether this serializer needs a binary clean transport.
      """

      ENABLE_V5 = True
      """
      Enable version 5 of the MsgPack specification (which differentiates
      between strings and binary).
      """

      def serialize(self, obj):
         """
         Implements :func:`autobahn.wamp.interfaces.IObjectSerializer.serialize`
         """
         return msgpack.packb(obj, use_bin_type = self.ENABLE_V5)


      def unserialize(self, payload):
         """
         Implements :func:`autobahn.wamp.interfaces.IObjectSerializer.unserialize`
         """
         return msgpack.unpackb(payload, encoding = 'utf-8')


   IObjectSerializer.register(MsgPackObjectSerializer)


   __all__.append('MsgPackObjectSerializer')



   class MsgPackSerializer(Serializer):

      SERIALIZER_ID = "msgpack"

      def __init__(self):
         Serializer.__init__(self, MsgPackObjectSerializer())

   
   ISerializer.register(MsgPackSerializer)


   __all__.append('MsgPackSerializer')

########NEW FILE########
__FILENAME__ = test_component
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from twisted.trial import unittest
#import unittest

from autobahn import wamp
from autobahn.wamp import message
from autobahn.wamp import role
from autobahn.wamp import serializer


import sys
import io
import six
import datetime

from twisted.python import log
from twisted.internet.defer import inlineCallbacks, Deferred, DeferredList
from twisted.internet.endpoints import serverFromString
from twisted.internet.endpoints import clientFromString

from autobahn.wamp import router
from autobahn.twisted.util import sleep
from autobahn.twisted import wamp, websocket


class CaseComponent(wamp.ApplicationSession):
   """
   Application code goes here. This is an example component that calls
   a remote procedure on a WAMP peer, subscribes to a topic to receive
   events, and then stops the world after some events.
   """

   def __init__(self, config, done):
      wamp.ApplicationSession.__init__(self, config)
      self._done = done
      self.stop = False
      self._logline = 1
      self.finished = False

   def log(self, *args):
      if len(args) > 1:
         sargs = ", ".join(str(s) for s in args)
      elif len(args) == 1:
         sargs = args[0]
      else:
         sargs = "-"

      msg = u'= : {:>3} : {:<20} : {}'.format(self._logline, self.__class__.__name__, sargs)
      self._logline += 1
      print(msg)
      self.config.dlog.append(msg)
      if self.config.log and not self.config.log.closed:
         self.config.log.write(msg + "\n")
         self.config.log.flush()
      else:
         print("log already closed")

   def finish(self):
      if not self.finished:
         self._done.callback(None)
         self.finished = True
         self.disconnect()
      else:
         print("already finished")



class Case1_Backend(CaseComponent):

   @inlineCallbacks
   def onJoin(self, details):

      self.log("joined")

      def add2(x, y):
         self.log("add2 invoked: {}, {}".format(x, y))
         return x + y

      yield self.register(add2, 'com.mathservice.add2')
      self.log("add2 registered")

      self.finish()



class Case1_Frontend(CaseComponent):

   @inlineCallbacks
   def onJoin(self, details):

      self.log("joined")

      try:
         res = yield self.call('com.mathservice.add2', 2, 3)
      except Exception as e:
         self.log("call error: {}".format(e))
      else:
         self.log("call result: {}".format(res))

      self.finish()



class Case2_Backend(CaseComponent):

   @inlineCallbacks
   def onJoin(self, details):

      self.log("joined")

      def ping():
         self.log("ping() is invoked")
         return

      def add2(a, b):
         self.log("add2() is invoked", a, b)
         return a + b

      def stars(nick = "somebody", stars = 0):
         self.log("stars() is invoked", nick, stars)
         return u"{} starred {}x".format(nick, stars)

      def orders(product, limit = 5):
         self.log("orders() is invoked", product, limit)
         return [u"Product {}".format(i) for i in range(50)][:limit]

      def arglen(*args, **kwargs):
         self.log("arglen() is invoked", args, kwargs)
         return [len(args), len(kwargs)]

      yield self.register(ping, u'com.arguments.ping')
      yield self.register(add2, u'com.arguments.add2')
      yield self.register(stars, u'com.arguments.stars')
      yield self.register(orders, u'com.arguments.orders')
      yield self.register(arglen, u'com.arguments.arglen')

      self.log("procedures registered")

      yield sleep(3)

      self.log("finishing")

      self.finish()


from autobahn.twisted.util import sleep

class Case2_Frontend(CaseComponent):

   @inlineCallbacks
   def onJoin(self, details):

      self.log("joined")

      yield sleep(1)

      yield self.call(u'com.arguments.ping')
      self.log("Pinged!")

      res = yield self.call(u'com.arguments.add2', 2, 3)
      self.log("Add2: {}".format(res))

      starred = yield self.call(u'com.arguments.stars')
      self.log("Starred 1: {}".format(starred))

      starred = yield self.call(u'com.arguments.stars', nick = u'Homer')
      self.log("Starred 2: {}".format(starred))

      starred = yield self.call(u'com.arguments.stars', stars = 5)
      self.log("Starred 3: {}".format(starred))

      starred = yield self.call(u'com.arguments.stars', nick = u'Homer', stars = 5)
      self.log("Starred 4: {}".format(starred))

      orders = yield self.call(u'com.arguments.orders', u'coffee')
      self.log("Orders 1: {}".format(orders))

      orders = yield self.call(u'com.arguments.orders', u'coffee', limit = 10)
      self.log("Orders 2: {}".format(orders))

      arglengths = yield self.call(u'com.arguments.arglen')
      self.log("Arglen 1: {}".format(arglengths))

      arglengths = yield self.call(u'com.arguments.arglen', 1, 2, 3)
      self.log("Arglen 1: {}".format(arglengths))

      arglengths = yield self.call(u'com.arguments.arglen', a = 1, b = 2, c = 3)
      self.log("Arglen 2: {}".format(arglengths))

      arglengths = yield self.call(u'com.arguments.arglen', 1, 2, 3, a = 1, b = 2, c = 3)
      self.log("Arglen 3: {}".format(arglengths))

      self.log("finishing")

      self.finish()


if False:
   class TestRpc(unittest.TestCase):

      def setUp(self):
         self.debug = False
         self.realm = "realm1"
         self.transport = "websocket"
         self.url = "ws://127.0.0.1:8080"
         self.client = "tcp:127.0.0.1:8080"
         self.server = "tcp:8080"


      def test_minimal(self):

         embedded_components, client_components = [], [Case2_Backend, Case2_Frontend]

         ## create a WAMP router factory
         ##
         from autobahn.wamp.router import RouterFactory
         router_factory = RouterFactory()


         ## create a WAMP router session factory
         ##
         from autobahn.twisted.wamp import RouterSessionFactory
         session_factory = RouterSessionFactory(router_factory)



         ## .. and create and add an WAMP application session to
         ## run next to the router
         ##
         from autobahn.wamp import types

         config = types.ComponentConfig(realm = self.realm,
            extra = {
               'caselog': 'case1.log'
            }
         )
         try:
            log = io.open('caselog.log', 'w')
         except Exception as e:
            print(e)
   #      log = io.open(config.extra['caselog'], 'w')
         config.log = log
         config.dlog = []
         config.components = []

         config.all_done = []

         for C in embedded_components:
            one_done = Deferred()
            config.all_done.append(one_done)
            c = C(config, one_done)
            config.components.append(c)
            session_factory.add(c)

         if self.transport == "websocket":

            ## create a WAMP-over-WebSocket transport server factory
            ##
            from autobahn.twisted.websocket import WampWebSocketServerFactory
            transport_factory = WampWebSocketServerFactory(session_factory, debug_wamp = self.debug)
            transport_factory.setProtocolOptions(failByDrop = False, openHandshakeTimeout = 0, closeHandshakeTimeout = 0)

         elif self.transport in ['rawsocket-json', 'rawsocket-msgpack']:

            ## create a WAMP-over-RawSocket transport server factory
            ##
            if self.transport == 'rawsocket-msgpack':
               from autobahn.wamp.serializer import MsgPackSerializer
               serializer = MsgPackSerializer()
            elif self.transport == 'rawsocket-json':
               from autobahn.wamp.serializer import JsonSerializer
               serializer = JsonSerializer()
            else:
               raise Exception("should not arrive here")

            from autobahn.twisted.rawsocket import WampRawSocketServerFactory
            transport_factory = WampRawSocketServerFactory(session_factory, serializer, debug = self.debug)

         else:
            raise Exception("should not arrive here")


         from autobahn.twisted.websocket import WampWebSocketClientFactory, WampWebSocketClientProtocol

         ## start the server from an endpoint
         ##
         from twisted.internet import reactor
         server = serverFromString(reactor, self.server)
         d = server.listen(transport_factory)

         def onlisten(port):
            config.port = port

         d.addCallback(onlisten)

         clients = []
         clients_d = []
         for C in client_components:
            ## create a WAMP application session factory
            ##
            from autobahn.twisted.wamp import ApplicationSessionFactory
            session_factory = ApplicationSessionFactory(config)

            one_done = Deferred()
            config.all_done.append(one_done)

            def make_make(Klass, done):
               def make(config):
                  c = Klass(config, done)
                  config.components.append(c)
                  return c
               return make

            ## .. and set the session class on the factory
            ##
            session_factory.session = make_make(C, one_done)

            if self.transport == "websocket":

               from autobahn.wamp.serializer import JsonSerializer

               serializers = [JsonSerializer()]

               ## create a WAMP-over-WebSocket transport client factory
               ##
               transport_factory = WampWebSocketClientFactory(session_factory, serializers = serializers, url = self.url, debug_wamp = self.debug)

               if True:
                  def maker(Klass):
                     class TestClientProtocol(WampWebSocketClientProtocol):
                        def onOpen(self):
                           self.txcnt = 0
                           self.rxcnt = 0
                           WampWebSocketClientProtocol.onOpen(self)

                        def sendMessage(self, bytes, isBinary):
                           self.txcnt += 1
                           print("> : {:>3} : {:<20} : {}".format(self.txcnt, Klass.__name__, bytes))
                           WampWebSocketClientProtocol.sendMessage(self, bytes, isBinary)

                        def onMessage(self, bytes, isBinary):
                           self.rxcnt += 1
                           print("< : {:>3} : {:<20} : {}".format(self.rxcnt, Klass.__name__, bytes))
                           WampWebSocketClientProtocol.onMessage(self, bytes, isBinary)
                     return TestClientProtocol

                  transport_factory.protocol = maker(C)
               else:
                  transport_factory.protocol = WampWebSocketClientProtocol

               transport_factory.setProtocolOptions(failByDrop = False, openHandshakeTimeout = 0, closeHandshakeTimeout = 0)

            elif self.transport in ['rawsocket-json', 'rawsocket-msgpack']:

               ## create a WAMP-over-RawSocket transport client factory
               ##
               if self.transport == 'rawsocket-msgpack':
                  from autobahn.wamp.serializer import MsgPackSerializer
                  serializer = MsgPackSerializer()
               elif self.transport == 'rawsocket-json':
                  from autobahn.wamp.serializer import JsonSerializer
                  serializer = JsonSerializer()
               else:
                  raise Exception("should not arrive here")

               from autobahn.twisted.rawsocket import WampRawSocketClientFactory
               transport_factory = WampRawSocketClientFactory(session_factory, serializer, debug = self.debug)


            ## start the client from an endpoint
            ##
            cl = clientFromString(reactor, self.client)
            clients_d.append(cl.connect(transport_factory))

            clients.append(cl)

         config.connected_clients = None

         def client_connected(res):
            config.connected_clients = [proto for success, proto in res if success]

         DeferredList(clients_d).addCallback(client_connected)


         d = DeferredList(config.all_done, consumeErrors = True)
         #d = config.components[1]._done

         def done(res):
            log.flush()
            log.close()
            if config.port:
               config.port.stopListening()
            if config.connected_clients:
               for proto in config.connected_clients:
                  proto.transport.abortConnection()
            print("Log length: {}".format(len(config.dlog)))
            print(config.dlog)
            #from twisted.internet import reactor
            #reactor.callLater(1, reactor.stop)

         def error(err):
            print(err)

         d.addCallbacks(done, error)

   #      d2 = Deferred()

         return d


if __name__ == '__main__':
   unittest.main()

########NEW FILE########
__FILENAME__ = test_message
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from twisted.trial import unittest
#import unittest

from autobahn.wamp import role
from autobahn.wamp import message
from autobahn.wamp.exception import ProtocolError


class TestErrorMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Error(message.Call.MESSAGE_TYPE, 123456, u'com.myapp.error1')
      msg = e.marshal()
      self.assertEqual(len(msg), 5)
      self.assertEqual(msg[0], message.Error.MESSAGE_TYPE)
      self.assertEqual(msg[1], message.Call.MESSAGE_TYPE)
      self.assertEqual(msg[2], 123456)
      self.assertEqual(msg[3], {})
      self.assertEqual(msg[4], u'com.myapp.error1')

      e = message.Error(message.Call.MESSAGE_TYPE, 123456, u'com.myapp.error1', args = [1, 2, 3], kwargs = {u'foo': 23, u'bar': u'hello'})
      msg = e.marshal()
      self.assertEqual(len(msg), 7)
      self.assertEqual(msg[0], message.Error.MESSAGE_TYPE)
      self.assertEqual(msg[1], message.Call.MESSAGE_TYPE)
      self.assertEqual(msg[2], 123456)
      self.assertEqual(msg[3], {})
      self.assertEqual(msg[4], u'com.myapp.error1')
      self.assertEqual(msg[5], [1, 2, 3])
      self.assertEqual(msg[6], {u'foo': 23, u'bar': u'hello'})


   def test_parse_and_marshal(self):
      wmsg = [message.Error.MESSAGE_TYPE, message.Call.MESSAGE_TYPE, 123456, {}, u'com.myapp.error1']
      msg = message.Error.parse(wmsg)
      self.assertIsInstance(msg, message.Error)
      self.assertEqual(msg.request_type, message.Call.MESSAGE_TYPE)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.error, u'com.myapp.error1')
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Error.MESSAGE_TYPE, message.Call.MESSAGE_TYPE, 123456, {}, u'com.myapp.error1', [1, 2, 3], {u'foo': 23,  u'bar':  u'hello'}]
      msg = message.Error.parse(wmsg)
      self.assertIsInstance(msg, message.Error)
      self.assertEqual(msg.request_type, message.Call.MESSAGE_TYPE)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.error, u'com.myapp.error1')
      self.assertEqual(msg.args, [1, 2, 3])
      self.assertEqual(msg.kwargs, {u'foo': 23,  u'bar':  u'hello'})
      self.assertEqual(msg.marshal(), wmsg)



class TestSubscribeMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Subscribe(123456, u'com.myapp.topic1')
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Subscribe.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {})
      self.assertEqual(msg[3], u'com.myapp.topic1')

      e = message.Subscribe(123456, u'com.myapp.topic1', match = message.Subscribe.MATCH_PREFIX)
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Subscribe.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {u'match': u'prefix'})
      self.assertEqual(msg[3], u'com.myapp.topic1')


   def test_parse_and_marshal(self):
      wmsg = [message.Subscribe.MESSAGE_TYPE, 123456, {}, u'com.myapp.topic1']
      msg = message.Subscribe.parse(wmsg)
      self.assertIsInstance(msg, message.Subscribe)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.topic, u'com.myapp.topic1')
      self.assertEqual(msg.match, message.Subscribe.MATCH_EXACT)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Subscribe.MESSAGE_TYPE, 123456, {u'match': u'prefix'}, u'com.myapp.topic1']
      msg = message.Subscribe.parse(wmsg)
      self.assertIsInstance(msg, message.Subscribe)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.topic, u'com.myapp.topic1')
      self.assertEqual(msg.match, message.Subscribe.MATCH_PREFIX)
      self.assertEqual(msg.marshal(), wmsg)



class TestSubscribedMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Subscribed(123456, 789123)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Subscribed.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], 789123)


   def test_parse_and_marshal(self):
      wmsg = [message.Subscribed.MESSAGE_TYPE, 123456, 789123]
      msg = message.Subscribed.parse(wmsg)
      self.assertIsInstance(msg, message.Subscribed)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.subscription, 789123)
      self.assertEqual(msg.marshal(), wmsg)



class TestUnsubscribeMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Unsubscribe(123456, 789123)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Unsubscribe.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], 789123)


   def test_parse_and_marshal(self):
      wmsg = [message.Unsubscribe.MESSAGE_TYPE, 123456, 789123]
      msg = message.Unsubscribe.parse(wmsg)
      self.assertIsInstance(msg, message.Unsubscribe)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.subscription, 789123)
      self.assertEqual(msg.marshal(), wmsg)



class TestUnsubscribedMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Unsubscribed(123456)
      msg = e.marshal()
      self.assertEqual(len(msg), 2)
      self.assertEqual(msg[0], message.Unsubscribed.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)


   def test_parse_and_marshal(self):
      wmsg = [message.Unsubscribed.MESSAGE_TYPE, 123456]
      msg = message.Unsubscribed.parse(wmsg)
      self.assertIsInstance(msg, message.Unsubscribed)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.marshal(), wmsg)



class TestPublishMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Publish(123456, u'com.myapp.topic1')
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Publish.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {})
      self.assertEqual(msg[3], u'com.myapp.topic1')

      e = message.Publish(123456, u'com.myapp.topic1', args = [1, 2, 3], kwargs = {u'foo': 23,  u'bar':  u'hello'})
      msg = e.marshal()
      self.assertEqual(len(msg), 6)
      self.assertEqual(msg[0], message.Publish.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {})
      self.assertEqual(msg[3], u'com.myapp.topic1')
      self.assertEqual(msg[4], [1, 2, 3])
      self.assertEqual(msg[5], {u'foo': 23,  u'bar':  u'hello'})

      e = message.Publish(123456, u'com.myapp.topic1', excludeMe = False, exclude = [300], eligible = [100, 200, 300], discloseMe = True)
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Publish.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {u'exclude_me': False, u'disclose_me': True, u'exclude': [300], u'eligible': [100, 200, 300]})
      self.assertEqual(msg[3], u'com.myapp.topic1')


   def test_parse_and_marshal(self):
      wmsg = [message.Publish.MESSAGE_TYPE, 123456, {}, u'com.myapp.topic1']
      msg = message.Publish.parse(wmsg)
      self.assertIsInstance(msg, message.Publish)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.topic, u'com.myapp.topic1')
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.excludeMe, None)
      self.assertEqual(msg.exclude, None)
      self.assertEqual(msg.eligible, None)
      self.assertEqual(msg.discloseMe, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Publish.MESSAGE_TYPE, 123456, {}, u'com.myapp.topic1', [1, 2, 3], {u'foo': 23,  u'bar':  u'hello'}]
      msg = message.Publish.parse(wmsg)
      self.assertIsInstance(msg, message.Publish)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.topic, u'com.myapp.topic1')
      self.assertEqual(msg.args, [1, 2, 3])
      self.assertEqual(msg.kwargs, {u'foo': 23,  u'bar':  u'hello'})
      self.assertEqual(msg.excludeMe, None)
      self.assertEqual(msg.exclude, None)
      self.assertEqual(msg.eligible, None)
      self.assertEqual(msg.discloseMe, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Publish.MESSAGE_TYPE, 123456, {u'exclude_me': False, u'disclose_me': True, u'exclude': [300], u'eligible': [100, 200, 300]}, u'com.myapp.topic1']
      msg = message.Publish.parse(wmsg)
      self.assertIsInstance(msg, message.Publish)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.topic, u'com.myapp.topic1')
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.excludeMe, False)
      self.assertEqual(msg.exclude, [300])
      self.assertEqual(msg.eligible, [100, 200, 300])
      self.assertEqual(msg.discloseMe, True)
      self.assertEqual(msg.marshal(), wmsg)



class TestPublishedMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Published(123456, 789123)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Published.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], 789123)


   def test_parse_and_marshal(self):
      wmsg = [message.Published.MESSAGE_TYPE, 123456, 789123]
      msg = message.Published.parse(wmsg)
      self.assertIsInstance(msg, message.Published)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.publication, 789123)
      self.assertEqual(msg.marshal(), wmsg)



class TestEventMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Event(123456, 789123)
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Event.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], 789123)
      self.assertEqual(msg[3], {})

      e = message.Event(123456, 789123, args = [1, 2, 3], kwargs = {u'foo': 23,  u'bar':  u'hello'})
      msg = e.marshal()
      self.assertEqual(len(msg), 6)
      self.assertEqual(msg[0], message.Event.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], 789123)
      self.assertEqual(msg[3], {})
      self.assertEqual(msg[4], [1, 2, 3])
      self.assertEqual(msg[5], {u'foo': 23,  u'bar':  u'hello'})

      e = message.Event(123456, 789123, publisher = 300)
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Event.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], 789123)
      self.assertEqual(msg[3], {u'publisher': 300})


   def test_parse_and_marshal(self):
      wmsg = [message.Event.MESSAGE_TYPE, 123456, 789123, {}]
      msg = message.Event.parse(wmsg)
      self.assertIsInstance(msg, message.Event)
      self.assertEqual(msg.subscription, 123456)
      self.assertEqual(msg.publication, 789123)
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.publisher, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Event.MESSAGE_TYPE, 123456, 789123, {}, [1, 2, 3], {u'foo': 23,  u'bar':  u'hello'}]
      msg = message.Event.parse(wmsg)
      self.assertIsInstance(msg, message.Event)
      self.assertEqual(msg.subscription, 123456)
      self.assertEqual(msg.publication, 789123)
      self.assertEqual(msg.args, [1, 2, 3])
      self.assertEqual(msg.kwargs, {u'foo': 23,  u'bar':  u'hello'})
      self.assertEqual(msg.publisher, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Event.MESSAGE_TYPE, 123456, 789123, {u'publisher': 300}]
      msg = message.Event.parse(wmsg)
      self.assertIsInstance(msg, message.Event)
      self.assertEqual(msg.subscription, 123456)
      self.assertEqual(msg.publication, 789123)
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.publisher, 300)
      self.assertEqual(msg.marshal(), wmsg)



class TestRegisterMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Register(123456, u'com.myapp.procedure1')
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Register.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {})
      self.assertEqual(msg[3], u'com.myapp.procedure1')

      e = message.Register(123456, u'com.myapp.procedure1', pkeys = [10, 11, 12])
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Register.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {u'pkeys': [10, 11, 12]})
      self.assertEqual(msg[3], u'com.myapp.procedure1')


   def test_parse_and_marshal(self):
      wmsg = [message.Register.MESSAGE_TYPE, 123456, {}, u'com.myapp.procedure1']
      msg = message.Register.parse(wmsg)
      self.assertIsInstance(msg, message.Register)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.procedure, u'com.myapp.procedure1')
      self.assertEqual(msg.pkeys, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Register.MESSAGE_TYPE, 123456, {u'pkeys': [10, 11, 12]}, u'com.myapp.procedure1']
      msg = message.Register.parse(wmsg)
      self.assertIsInstance(msg, message.Register)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.procedure, u'com.myapp.procedure1')
      self.assertEqual(msg.pkeys, [10, 11, 12])
      self.assertEqual(msg.marshal(), wmsg)



class TestRegisteredMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Registered(123456, 789123)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Registered.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], 789123)


   def test_parse_and_marshal(self):
      wmsg = [message.Registered.MESSAGE_TYPE, 123456, 789123]
      msg = message.Registered.parse(wmsg)
      self.assertIsInstance(msg, message.Registered)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.registration, 789123)
      self.assertEqual(msg.marshal(), wmsg)



class TestUnregisterMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Unregister(123456, 789123)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Unregister.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], 789123)


   def test_parse_and_marshal(self):
      wmsg = [message.Unregister.MESSAGE_TYPE, 123456, 789123]
      msg = message.Unregister.parse(wmsg)
      self.assertIsInstance(msg, message.Unregister)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.registration, 789123)
      self.assertEqual(msg.marshal(), wmsg)



class TestUnregisteredMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Unregistered(123456)
      msg = e.marshal()
      self.assertEqual(len(msg), 2)
      self.assertEqual(msg[0], message.Unregistered.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)


   def test_parse_and_marshal(self):
      wmsg = [message.Unregistered.MESSAGE_TYPE, 123456]
      msg = message.Unregistered.parse(wmsg)
      self.assertIsInstance(msg, message.Unregistered)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.marshal(), wmsg)



class TestCallMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Call(123456, u'com.myapp.procedure1')
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Call.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {})
      self.assertEqual(msg[3], u'com.myapp.procedure1')

      e = message.Call(123456, u'com.myapp.procedure1', args = [1, 2, 3], kwargs = {u'foo': 23,  u'bar':  u'hello'})
      msg = e.marshal()
      self.assertEqual(len(msg), 6)
      self.assertEqual(msg[0], message.Call.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {})
      self.assertEqual(msg[3], u'com.myapp.procedure1')
      self.assertEqual(msg[4], [1, 2, 3])
      self.assertEqual(msg[5], {u'foo': 23,  u'bar':  u'hello'})

      e = message.Call(123456, u'com.myapp.procedure1', timeout = 10000)
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Call.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {u'timeout': 10000})
      self.assertEqual(msg[3], u'com.myapp.procedure1')


   def test_parse_and_marshal(self):
      wmsg = [message.Call.MESSAGE_TYPE, 123456, {}, u'com.myapp.procedure1']
      msg = message.Call.parse(wmsg)
      self.assertIsInstance(msg, message.Call)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.procedure, u'com.myapp.procedure1')
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.timeout, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Call.MESSAGE_TYPE, 123456, {}, u'com.myapp.procedure1', [1, 2, 3], {u'foo': 23,  u'bar':  u'hello'}]
      msg = message.Call.parse(wmsg)
      self.assertIsInstance(msg, message.Call)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.procedure, u'com.myapp.procedure1')
      self.assertEqual(msg.args, [1, 2, 3])
      self.assertEqual(msg.kwargs, {u'foo': 23,  u'bar':  u'hello'})
      self.assertEqual(msg.timeout, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Call.MESSAGE_TYPE, 123456, {u'timeout': 10000}, u'com.myapp.procedure1']
      msg = message.Call.parse(wmsg)
      self.assertIsInstance(msg, message.Call)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.procedure, u'com.myapp.procedure1')
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.timeout, 10000)
      self.assertEqual(msg.marshal(), wmsg)



class TestCancelMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Cancel(123456)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Cancel.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {})

      e = message.Cancel(123456, mode = message.Cancel.KILL)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Cancel.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {u'mode': message.Cancel.KILL})


   def test_parse_and_marshal(self):
      wmsg = [message.Cancel.MESSAGE_TYPE, 123456, {}]
      msg = message.Cancel.parse(wmsg)
      self.assertIsInstance(msg, message.Cancel)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.mode, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Cancel.MESSAGE_TYPE, 123456, {u'mode': message.Cancel.KILL}]
      msg = message.Cancel.parse(wmsg)
      self.assertIsInstance(msg, message.Cancel)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.mode, message.Cancel.KILL)
      self.assertEqual(msg.marshal(), wmsg)



class TestResultMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Result(123456)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Result.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {})

      e = message.Result(123456, args = [1, 2, 3], kwargs = {u'foo': 23,  u'bar':  u'hello'})
      msg = e.marshal()
      self.assertEqual(len(msg), 5)
      self.assertEqual(msg[0], message.Result.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {})
      self.assertEqual(msg[3], [1, 2, 3])
      self.assertEqual(msg[4], {u'foo': 23,  u'bar':  u'hello'})

      e = message.Result(123456, progress = True)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Result.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {u'progress': True})


   def test_parse_and_marshal(self):
      wmsg = [message.Result.MESSAGE_TYPE, 123456, {}]
      msg = message.Result.parse(wmsg)
      self.assertIsInstance(msg, message.Result)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.progress, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Result.MESSAGE_TYPE, 123456, {}, [1, 2, 3], {u'foo': 23,  u'bar':  u'hello'}]
      msg = message.Result.parse(wmsg)
      self.assertIsInstance(msg, message.Result)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.args, [1, 2, 3])
      self.assertEqual(msg.kwargs, {u'foo': 23,  u'bar':  u'hello'})
      self.assertEqual(msg.progress, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Result.MESSAGE_TYPE, 123456, {u'progress': True}]
      msg = message.Result.parse(wmsg)
      self.assertIsInstance(msg, message.Result)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.progress, True)
      self.assertEqual(msg.marshal(), wmsg)



class TestInvocationMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Invocation(123456, 789123)
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Invocation.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], 789123)
      self.assertEqual(msg[3], {})

      e = message.Invocation(123456, 789123, args = [1, 2, 3], kwargs = {u'foo': 23,  u'bar':  u'hello'})
      msg = e.marshal()
      self.assertEqual(len(msg), 6)
      self.assertEqual(msg[0], message.Invocation.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], 789123)
      self.assertEqual(msg[3], {})
      self.assertEqual(msg[4], [1, 2, 3])
      self.assertEqual(msg[5], {u'foo': 23,  u'bar':  u'hello'})

      e = message.Invocation(123456, 789123, timeout = 10000)
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Invocation.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], 789123)
      self.assertEqual(msg[3], {u'timeout': 10000})


   def test_parse_and_marshal(self):
      wmsg = [message.Invocation.MESSAGE_TYPE, 123456, 789123, {}]
      msg = message.Invocation.parse(wmsg)
      self.assertIsInstance(msg, message.Invocation)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.registration, 789123)
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.timeout, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Invocation.MESSAGE_TYPE, 123456, 789123, {}, [1, 2, 3], {u'foo': 23,  u'bar':  u'hello'}]
      msg = message.Invocation.parse(wmsg)
      self.assertIsInstance(msg, message.Invocation)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.registration, 789123)
      self.assertEqual(msg.args, [1, 2, 3])
      self.assertEqual(msg.kwargs, {u'foo': 23,  u'bar':  u'hello'})
      self.assertEqual(msg.timeout, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Invocation.MESSAGE_TYPE, 123456, 789123, {u'timeout': 10000}]
      msg = message.Invocation.parse(wmsg)
      self.assertIsInstance(msg, message.Invocation)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.registration, 789123)
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.timeout, 10000)
      self.assertEqual(msg.marshal(), wmsg)



class TestInterruptMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Interrupt(123456)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Interrupt.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {})

      e = message.Interrupt(123456, mode = message.Interrupt.KILL)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Interrupt.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {u'mode': message.Interrupt.KILL})


   def test_parse_and_marshal(self):
      wmsg = [message.Interrupt.MESSAGE_TYPE, 123456, {}]
      msg = message.Interrupt.parse(wmsg)
      self.assertIsInstance(msg, message.Interrupt)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.mode, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Interrupt.MESSAGE_TYPE, 123456, {u'mode': message.Interrupt.KILL}]
      msg = message.Interrupt.parse(wmsg)
      self.assertIsInstance(msg, message.Interrupt)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.mode, message.Interrupt.KILL)
      self.assertEqual(msg.marshal(), wmsg)



class TestYieldMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Yield(123456)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Yield.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {})

      e = message.Yield(123456, args = [1, 2, 3], kwargs = {u'foo': 23,  u'bar':  u'hello'})
      msg = e.marshal()
      self.assertEqual(len(msg), 5)
      self.assertEqual(msg[0], message.Yield.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {})
      self.assertEqual(msg[3], [1, 2, 3])
      self.assertEqual(msg[4], {u'foo': 23,  u'bar':  u'hello'})

      e = message.Yield(123456, progress = True)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Yield.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123456)
      self.assertEqual(msg[2], {u'progress': True})


   def test_parse_and_marshal(self):
      wmsg = [message.Yield.MESSAGE_TYPE, 123456, {}]
      msg = message.Yield.parse(wmsg)
      self.assertIsInstance(msg, message.Yield)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.progress, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Yield.MESSAGE_TYPE, 123456, {}, [1, 2, 3], {u'foo': 23,  u'bar':  u'hello'}]
      msg = message.Yield.parse(wmsg)
      self.assertIsInstance(msg, message.Yield)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.args, [1, 2, 3])
      self.assertEqual(msg.kwargs, {u'foo': 23,  u'bar':  u'hello'})
      self.assertEqual(msg.progress, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Yield.MESSAGE_TYPE, 123456, {u'progress': True}]
      msg = message.Yield.parse(wmsg)
      self.assertIsInstance(msg, message.Yield)
      self.assertEqual(msg.request, 123456)
      self.assertEqual(msg.args, None)
      self.assertEqual(msg.kwargs, None)
      self.assertEqual(msg.progress, True)
      self.assertEqual(msg.marshal(), wmsg)



class TestHelloMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Hello(u"realm1", [role.RoleBrokerFeatures()])
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Hello.MESSAGE_TYPE)
      self.assertEqual(msg[1], u"realm1")
      self.assertEqual(msg[2], {u'roles': {u'broker': {}}})

      e = message.Hello(u"realm1", [role.RoleBrokerFeatures(subscriber_blackwhite_listing = True)])
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Hello.MESSAGE_TYPE)
      self.assertEqual(msg[1], u"realm1")
      self.assertEqual(msg[2], {u'roles': {u'broker': {u'features': {u'subscriber_blackwhite_listing': True}}}})


   def test_parse_and_marshal(self):
      wmsg = [message.Hello.MESSAGE_TYPE, u"realm1", {u'roles': {u'broker': {}}}]
      msg = message.Hello.parse(wmsg)
      self.assertIsInstance(msg, message.Hello)
      self.assertEqual(msg.realm, u"realm1")
      self.assertEqual(msg.roles, [role.RoleBrokerFeatures()])
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Hello.MESSAGE_TYPE, u"realm1", {u'roles': {u'broker': {u'features': {u'subscriber_blackwhite_listing': True}}}}]
      msg = message.Hello.parse(wmsg)
      self.assertIsInstance(msg, message.Hello)
      self.assertEqual(msg.realm, u"realm1")
      self.assertEqual(msg.roles, [role.RoleBrokerFeatures(subscriber_blackwhite_listing = True)])
      self.assertEqual(msg.marshal(), wmsg)

   def test_str(self):
      e = message.Hello(u"realm1", [role.RoleBrokerFeatures()])
      self.assertIsInstance(str(e), str)



class TestGoodbyeMessage(unittest.TestCase):

   def test_ctor(self):
      reason = u'wamp.error.system_shutdown'
      reason_msg = u'The host is shutting down now.'

      e = message.Goodbye()
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Goodbye.MESSAGE_TYPE)
      self.assertEqual(msg[1], {})
      self.assertEqual(msg[2], message.Goodbye.DEFAULT_REASON)

      e = message.Goodbye(reason = reason)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Goodbye.MESSAGE_TYPE)
      self.assertEqual(msg[1], {})
      self.assertEqual(msg[2], reason)

      e = message.Goodbye(reason = reason, message = reason_msg)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Goodbye.MESSAGE_TYPE)
      self.assertEqual(msg[1], {u'message': reason_msg})
      self.assertEqual(msg[2], reason)


   def test_parse_and_marshal(self):
      reason = u'wamp.error.system_shutdown'
      reason_msg = u'The host is shutting down now.'

      wmsg = [message.Goodbye.MESSAGE_TYPE]
      self.assertRaises(ProtocolError, message.Goodbye.parse, wmsg)

      wmsg = [message.Goodbye.MESSAGE_TYPE, reason]
      self.assertRaises(ProtocolError, message.Goodbye.parse, wmsg)

      wmsg = [message.Goodbye.MESSAGE_TYPE, {u'message': 100}, reason]
      self.assertRaises(ProtocolError, message.Goodbye.parse, wmsg)

      wmsg = [message.Goodbye.MESSAGE_TYPE, {}, reason]
      msg = message.Goodbye.parse(wmsg)
      self.assertIsInstance(msg, message.Goodbye)
      self.assertEqual(msg.reason, reason)
      self.assertEqual(msg.message, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Goodbye.MESSAGE_TYPE, {u'message': reason_msg}, reason]
      msg = message.Goodbye.parse(wmsg)
      self.assertIsInstance(msg, message.Goodbye)
      self.assertEqual(msg.reason, reason)
      self.assertEqual(msg.message, reason_msg)
      self.assertEqual(msg.marshal(), wmsg)

   def test_str(self):
      e = message.Goodbye(reason = u'wamp.error.system_shutdown', message = u'The host is shutting down now.')
      self.assertIsInstance(str(e), str)



class TestHeartbeatMessage(unittest.TestCase):

   def test_ctor(self):
      e = message.Heartbeat(123, 456)
      msg = e.marshal()
      self.assertEqual(len(msg), 3)
      self.assertEqual(msg[0], message.Heartbeat.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123)
      self.assertEqual(msg[2], 456)

      e = message.Heartbeat(123, 456, u"discard me")
      msg = e.marshal()
      self.assertEqual(len(msg), 4)
      self.assertEqual(msg[0], message.Heartbeat.MESSAGE_TYPE)
      self.assertEqual(msg[1], 123)
      self.assertEqual(msg[2], 456)
      self.assertEqual(msg[3], u"discard me")


   def test_parse_and_marshal(self):
      wmsg = [message.Heartbeat.MESSAGE_TYPE]
      self.assertRaises(ProtocolError, message.Heartbeat.parse, wmsg)

      wmsg = [message.Heartbeat.MESSAGE_TYPE, 100]
      self.assertRaises(ProtocolError, message.Heartbeat.parse, wmsg)

      wmsg = [message.Heartbeat.MESSAGE_TYPE, 100, u"foo"]
      self.assertRaises(ProtocolError, message.Heartbeat.parse, wmsg)

      wmsg = [message.Heartbeat.MESSAGE_TYPE, 100, 0]
      self.assertRaises(ProtocolError, message.Heartbeat.parse, wmsg)

      wmsg = [message.Heartbeat.MESSAGE_TYPE, 100, 100, 100]
      self.assertRaises(ProtocolError, message.Heartbeat.parse, wmsg)

      wmsg = [message.Heartbeat.MESSAGE_TYPE, 123, 456]
      msg = message.Heartbeat.parse(wmsg)
      self.assertIsInstance(msg, message.Heartbeat)
      self.assertEqual(msg.incoming, 123)
      self.assertEqual(msg.outgoing, 456)
      self.assertEqual(msg.discard, None)
      self.assertEqual(msg.marshal(), wmsg)

      wmsg = [message.Heartbeat.MESSAGE_TYPE, 123, 456, u"discard me"]
      msg = message.Heartbeat.parse(wmsg)
      self.assertIsInstance(msg, message.Heartbeat)
      self.assertEqual(msg.incoming, 123)
      self.assertEqual(msg.outgoing, 456)
      self.assertEqual(msg.discard, u"discard me")
      self.assertEqual(msg.marshal(), wmsg)

   def test_str(self):
      e = message.Heartbeat(123, 456, u"discard me")
      self.assertIsInstance(str(e), str)



if __name__ == '__main__':
   unittest.main()

########NEW FILE########
__FILENAME__ = test_protocol
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from twisted.trial import unittest
#import unittest
from twisted.internet.defer import Deferred, inlineCallbacks

from autobahn import wamp
from autobahn.wamp import message
from autobahn.wamp import serializer
from autobahn.wamp import protocol
from autobahn.wamp import role
from autobahn import util
from autobahn.wamp.exception import ApplicationError, NotAuthorized, InvalidTopic
from autobahn.wamp import types

from autobahn.twisted.wamp import ApplicationSession


class MockTransport:

   def __init__(self, handler):
      self._log = False
      self._handler = handler
      self._serializer = serializer.JsonSerializer()
      self._registrations = {}
      self._invocations = {}

      self._handler.onOpen(self)

      self._my_session_id = util.id()

      roles = [
         role.RoleBrokerFeatures(),
         role.RoleDealerFeatures()
      ]

      msg = message.Welcome(self._my_session_id, roles)
      self._handler.onMessage(msg)

   def send(self, msg):
      if self._log:
         bytes, isbinary = self._serializer.serialize(msg)
         print("Send: {}".format(bytes))

      reply = None

      if isinstance(msg, message.Publish):
         if msg.topic.startswith(u'com.myapp'):
            if msg.acknowledge:
               reply = message.Published(msg.request, util.id())
         elif len(msg.topic) == 0:
            reply = message.Error(message.Publish.MESSAGE_TYPE, msg.request, u'wamp.error.invalid_topic')
         else:
            reply = message.Error(message.Publish.MESSAGE_TYPE, msg.request, u'wamp.error.not_authorized')

      elif isinstance(msg, message.Call):
         if msg.procedure == u'com.myapp.procedure1':
            reply = message.Result(msg.request, args = [100])
         elif msg.procedure == u'com.myapp.procedure2':
            reply = message.Result(msg.request, args = [1, 2, 3])
         elif msg.procedure == u'com.myapp.procedure3':
            reply = message.Result(msg.request, args = [1, 2, 3], kwargs = {u'foo': u'bar', u'baz': 23})

         elif msg.procedure.startswith(u'com.myapp.myproc'):
            registration = self._registrations[msg.procedure]
            request = util.id()
            self._invocations[request] = msg.request
            reply = message.Invocation(request, registration, args = msg.args, kwargs = msg.kwargs)
         else:
            reply = message.Error(message.Call.MESSAGE_TYPE, msg.request, u'wamp.error.no_such_procedure')

      elif isinstance(msg, message.Yield):
         if self._invocations.has_key(msg.request):
            request = self._invocations[msg.request]
            reply = message.Result(request, args = msg.args, kwargs = msg.kwargs)

      elif isinstance(msg, message.Subscribe):
         reply = message.Subscribed(msg.request, util.id())

      elif isinstance(msg, message.Unsubscribe):
         reply = message.Unsubscribed(msg.request)

      elif isinstance(msg, message.Register):
         registration = util.id()
         self._registrations[msg.procedure] = registration
         reply = message.Registered(msg.request, registration)

      elif isinstance(msg, message.Unregister):
         reply = message.Unregistered(msg.request)

      if reply:
         if self._log:
            bytes, isbinary = self._serializer.serialize(reply)
            print("Receive: {}".format(bytes))
         self._handler.onMessage(reply)

   def isOpen(self):
      return True

   def close(self):
      pass

   def abort(self):
      pass



class TestPublisher(unittest.TestCase):

   @inlineCallbacks
   def test_publish(self):
      handler = ApplicationSession()
      transport = MockTransport(handler)

      publication = yield handler.publish('com.myapp.topic1')
      self.assertEqual(publication, None)

      publication = yield handler.publish('com.myapp.topic1', 1, 2, 3)
      self.assertEqual(publication, None)

      publication = yield handler.publish('com.myapp.topic1', 1, 2, 3, foo = 23, bar = 'hello')
      self.assertEqual(publication, None)

      publication = yield handler.publish('com.myapp.topic1', options = types.PublishOptions(excludeMe = False))
      self.assertEqual(publication, None)

      publication = yield handler.publish('com.myapp.topic1', 1, 2, 3, foo = 23, bar = 'hello', options = types.PublishOptions(excludeMe = False, exclude = [100, 200, 300]))
      self.assertEqual(publication, None)


   @inlineCallbacks
   def test_publish_acknowledged(self):
      handler = ApplicationSession()
      transport = MockTransport(handler)

      publication = yield handler.publish('com.myapp.topic1', options = types.PublishOptions(acknowledge = True))
      self.assertTrue(type(publication.id) in (int, long))

      publication = yield handler.publish('com.myapp.topic1', 1, 2, 3, options = types.PublishOptions(acknowledge = True))
      self.assertTrue(type(publication.id) in (int, long))

      publication = yield handler.publish('com.myapp.topic1', 1, 2, 3, foo = 23, bar = 'hello', options = types.PublishOptions(acknowledge = True))
      self.assertTrue(type(publication.id) in (int, long))

      publication = yield handler.publish('com.myapp.topic1', options = types.PublishOptions(excludeMe = False, acknowledge = True))
      self.assertTrue(type(publication.id) in (int, long))

      publication = yield handler.publish('com.myapp.topic1', 1, 2, 3, foo = 23, bar = 'hello', options = types.PublishOptions(excludeMe = False, exclude = [100, 200, 300], acknowledge = True))
      self.assertTrue(type(publication.id) in (int, long))


   @inlineCallbacks
   def test_publish_undefined_exception(self):
      handler = ApplicationSession()
      transport = MockTransport(handler)

      options = types.PublishOptions(acknowledge = True)

      yield self.assertFailure(handler.publish(u'de.myapp.topic1', options = options), ApplicationError)
      yield self.assertFailure(handler.publish(u'', options = options), ApplicationError)


   @inlineCallbacks
   def test_publish_defined_exception(self):
      handler = ApplicationSession()
      transport = MockTransport(handler)

      options = types.PublishOptions(acknowledge = True)

      handler.define(NotAuthorized)
      yield self.assertFailure(handler.publish(u'de.myapp.topic1', options = options), NotAuthorized)

      handler.define(InvalidTopic)
      yield self.assertFailure(handler.publish(u'', options = options), InvalidTopic)


   @inlineCallbacks
   def test_call(self):
      handler = ApplicationSession()
      transport = MockTransport(handler)

      res = yield handler.call('com.myapp.procedure1')
      self.assertEqual(res, 100)

      res = yield handler.call('com.myapp.procedure1', 1, 2, 3)
      self.assertEqual(res, 100)

      res = yield handler.call('com.myapp.procedure1', 1, 2, 3, foo = 23, bar = 'hello')
      self.assertEqual(res, 100)

      res = yield handler.call('com.myapp.procedure1', options = types.CallOptions(timeout = 10000))
      self.assertEqual(res, 100)

      res = yield handler.call('com.myapp.procedure1', 1, 2, 3, foo = 23, bar = 'hello', options = types.CallOptions(timeout = 10000))
      self.assertEqual(res, 100)


   @inlineCallbacks
   def test_call_with_complex_result(self):
      handler = ApplicationSession()
      transport = MockTransport(handler)

      res = yield handler.call('com.myapp.procedure2')
      self.assertIsInstance(res, types.CallResult)
      self.assertEqual(res.results, (1, 2, 3))
      self.assertEqual(res.kwresults, {})

      res = yield handler.call('com.myapp.procedure3')
      self.assertIsInstance(res, types.CallResult)
      self.assertEqual(res.results, (1, 2, 3))
      self.assertEqual(res.kwresults, {'foo':'bar', 'baz': 23})


   @inlineCallbacks
   def test_subscribe(self):
      handler = ApplicationSession()
      transport = MockTransport(handler)

      def on_event(*args, **kwargs):
         print("got event", args, kwargs)

      subscription = yield handler.subscribe(on_event, 'com.myapp.topic1')
      self.assertTrue(type(subscription.id) in (int, long))

      subscription = yield handler.subscribe(on_event, 'com.myapp.topic1', options = types.SubscribeOptions(match = 'wildcard'))
      self.assertTrue(type(subscription.id) in (int, long))


   @inlineCallbacks
   def test_unsubscribe(self):
      handler = ApplicationSession()
      transport = MockTransport(handler)

      def on_event(*args, **kwargs):
         print("got event", args, kwargs)

      subscription = yield handler.subscribe(on_event, 'com.myapp.topic1')
      yield subscription.unsubscribe()


   @inlineCallbacks
   def test_register(self):
      handler = ApplicationSession()
      transport = MockTransport(handler)

      def on_call(*args, **kwargs):
         print("got call", args, kwargs)

      registration = yield handler.register(on_call, 'com.myapp.procedure1')
      self.assertTrue(type(registration.id) in (int, long))

      registration = yield handler.register(on_call, 'com.myapp.procedure1', options = types.RegisterOptions(pkeys = [0, 1, 2]))
      self.assertTrue(type(registration.id) in (int, long))


   @inlineCallbacks
   def test_unregister(self):
      handler = ApplicationSession()
      transport = MockTransport(handler)

      def on_call(*args, **kwargs):
         print("got call", args, kwargs)

      registration = yield handler.register(on_call, 'com.myapp.procedure1')
      yield registration.unregister()


   @inlineCallbacks
   def test_invoke(self):
      handler = ApplicationSession()
      transport = MockTransport(handler)

      def myproc1():
         return 23

      yield handler.register(myproc1, 'com.myapp.myproc1')

      res = yield handler.call('com.myapp.myproc1')
      self.assertEqual(res, 23)


   # ## variant 1: works
   # def test_publish1(self):
   #    d = self.handler.publish('de.myapp.topic1')
   #    self.assertFailure(d, ApplicationError)

   # ## variant 2: works
   # @inlineCallbacks
   # def test_publish2(self):
   #    yield self.assertFailure(self.handler.publish('de.myapp.topic1'), ApplicationError)

   # ## variant 3: does NOT work
   # @inlineCallbacks
   # def test_publish3(self):
   #    with self.assertRaises(ApplicationError):
   #       yield self.handler.publish('de.myapp.topic1')


if __name__ == '__main__':
   unittest.main()

########NEW FILE########
__FILENAME__ = test_protocol_peer
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from twisted.trial import unittest
#import unittest

from autobahn import wamp
from autobahn.wamp import message
from autobahn.wamp import exception
from autobahn.wamp import protocol



class TestPeerExceptions(unittest.TestCase):

   def test_exception_from_message(self):
      session = protocol.BaseSession()

      @wamp.error("com.myapp.error1")
      class AppError1(Exception):
         pass

      @wamp.error("com.myapp.error2")
      class AppError2(Exception):
         pass

      session.define(AppError1)
      session.define(AppError2)

      ## map defined errors to user exceptions
      ##
      emsg = message.Error(message.Call.MESSAGE_TYPE, 123456, u'com.myapp.error1')
      exc = session._exception_from_message(emsg)
      self.assertIsInstance(exc, AppError1)
      self.assertEqual(exc.args, ())

      emsg = message.Error(message.Call.MESSAGE_TYPE, 123456, u'com.myapp.error2')
      exc = session._exception_from_message(emsg)
      self.assertIsInstance(exc, AppError2)
      self.assertEqual(exc.args, ())

      ## map undefined error to (generic) exception
      ##
      emsg = message.Error(message.Call.MESSAGE_TYPE, 123456, u'com.myapp.error3')
      exc = session._exception_from_message(emsg)
      self.assertIsInstance(exc, exception.ApplicationError)
      self.assertEqual(exc.error, u'com.myapp.error3')
      self.assertEqual(exc.args, ())
      self.assertEqual(exc.kwargs, {})

      emsg = message.Error(message.Call.MESSAGE_TYPE, 123456, u'com.myapp.error3', args = [1, 2, u'hello'])
      exc = session._exception_from_message(emsg)
      self.assertIsInstance(exc, exception.ApplicationError)
      self.assertEqual(exc.error, u'com.myapp.error3')
      self.assertEqual(exc.args, (1, 2, u'hello'))
      self.assertEqual(exc.kwargs, {})

      emsg = message.Error(message.Call.MESSAGE_TYPE, 123456, u'com.myapp.error3', args = [1, 2, u'hello'], kwargs = {u'foo': 23, u'bar': u'baz'})
      exc = session._exception_from_message(emsg)
      self.assertIsInstance(exc, exception.ApplicationError)
      self.assertEqual(exc.error, u'com.myapp.error3')
      self.assertEqual(exc.args, (1, 2, u'hello'))
      self.assertEqual(exc.kwargs, {u'foo': 23, u'bar': u'baz'})


   def test_message_from_exception(self):
      session = protocol.BaseSession()

      @wamp.error("com.myapp.error1")
      class AppError1(Exception):
         pass

      @wamp.error("com.myapp.error2")
      class AppError2(Exception):
         pass

      session.define(AppError1)
      session.define(AppError2)

      exc = AppError1()
      msg = session._message_from_exception(message.Call.MESSAGE_TYPE, 123456, exc)

      self.assertEqual(msg.marshal(), [message.Error.MESSAGE_TYPE, message.Call.MESSAGE_TYPE, 123456, {}, "com.myapp.error1"])


if __name__ == '__main__':
   unittest.main()

########NEW FILE########
__FILENAME__ = test_serializer
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from twisted.trial import unittest
#import unittest

from autobahn import wamp
from autobahn.wamp import message
from autobahn.wamp import role
from autobahn.wamp import serializer


def generate_test_messages():
   return [
      message.Hello(u"realm1", [role.RoleBrokerFeatures()]),
      message.Goodbye(),
      message.Heartbeat(123, 456),
      message.Yield(123456),
      message.Yield(123456, args = [1, 2, 3], kwargs = {u'foo': 23, u'bar': u'hello'}),
      message.Yield(123456, progress = True),
      message.Interrupt(123456),
      message.Interrupt(123456, mode = message.Interrupt.KILL),
      message.Invocation(123456, 789123),
      message.Invocation(123456, 789123, args = [1, 2, 3], kwargs = {u'foo': 23, u'bar': u'hello'}),
      message.Invocation(123456, 789123, timeout = 10000),
      message.Result(123456),
      message.Result(123456, args = [1, 2, 3], kwargs = {u'foo': 23, u'bar': u'hello'}),
      message.Result(123456, progress = True),
      message.Cancel(123456),
      message.Cancel(123456, mode = message.Cancel.KILL),
      message.Call(123456, u'com.myapp.procedure1'),
      message.Call(123456, u'com.myapp.procedure1', args = [1, 2, 3], kwargs = {u'foo': 23, u'bar': u'hello'}),
      message.Call(123456, u'com.myapp.procedure1', timeout = 10000),
      message.Unregistered(123456),
      message.Unregister(123456, 789123),
      message.Registered(123456, 789123),
      message.Register(123456, u'com.myapp.procedure1'),
      message.Register(123456, u'com.myapp.procedure1', pkeys = [10, 11, 12]),
      message.Event(123456, 789123),
      message.Event(123456, 789123, args = [1, 2, 3], kwargs = {u'foo': 23, u'bar': u'hello'}),
      message.Event(123456, 789123, publisher = 300),
      message.Published(123456, 789123),
      message.Publish(123456, u'com.myapp.topic1'),
      message.Publish(123456, u'com.myapp.topic1', args = [1, 2, 3], kwargs = {u'foo': 23, u'bar': u'hello'}),
      message.Publish(123456, u'com.myapp.topic1', excludeMe = False, exclude = [300], eligible = [100, 200, 300], discloseMe = True),
      message.Unsubscribed(123456),
      message.Unsubscribe(123456, 789123),
      message.Subscribed(123456, 789123),
      message.Subscribe(123456, u'com.myapp.topic1'),
      message.Subscribe(123456, u'com.myapp.topic1', match = message.Subscribe.MATCH_PREFIX),
      message.Error(message.Call.MESSAGE_TYPE, 123456, u'com.myapp.error1'),
      message.Error(message.Call.MESSAGE_TYPE, 123456, u'com.myapp.error1', args = [1, 2, 3], kwargs = {u'foo': 23, u'bar': u'hello'})
   ]



class TestSerializer(unittest.TestCase):

   def setUp(self):
      self.serializers = []
      self.serializers.append(serializer.JsonSerializer())
      self.serializers.append(serializer.MsgPackSerializer())


   def test_roundtrip(self):
      for msg in generate_test_messages():
         for serializer in self.serializers:

            ## serialize message
            bytes, binary = serializer.serialize(msg)

            ## unserialize message again
            msg2 = serializer.unserialize(bytes, binary)

            ## must be equal: message roundtrips via the serializer
            self.assertEqual(msg, msg2)


   def test_caching(self):
      for msg in generate_test_messages():
         ## message serialization cache is initially empty
         self.assertEqual(msg._serialized, {})
         for serializer in self.serializers:

            ## verify message serialization is not yet cached
            self.assertFalse(serializer._serializer in msg._serialized)
            bytes, binary = serializer.serialize(msg)

            ## now the message serialization must be cached
            self.assertTrue(serializer._serializer in msg._serialized)
            self.assertEqual(msg._serialized[serializer._serializer], bytes)

            ## and after resetting the serialization cache, message
            ## serialization is gone
            msg.uncache()
            self.assertFalse(serializer._serializer in msg._serialized)



if __name__ == '__main__':
   unittest.main()

########NEW FILE########
__FILENAME__ = test_uri_pattern
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from twisted.trial import unittest
#import unittest

#from autobahn import wamp2 as wamp
from autobahn import wamp
from autobahn.wamp.uri import Pattern



class TestUris(unittest.TestCase):

   def setUp(self):
      pass

   def tearDown(self):
      pass

   def test_invalid_uris(self):
      for u in [u"",
                u"123",
                u"com.myapp.<product:foo>.update",
                u"com.myapp.<123:int>.update",
                u"com.myapp.<:product>.update",
                u"com.myapp.<product:>.update",
                u"com.myapp.<int:>.update",
                ]:
         self.assertRaises(Exception, Pattern, u, Pattern.URI_TARGET_ENDPOINT)

   def test_valid_uris(self):
      for u in [u"com.myapp.proc1",
                u"com.myapp.<product:int>.update",
                ]:
         p = Pattern(u, Pattern.URI_TARGET_ENDPOINT)
         self.assertIsInstance(p, Pattern)

   def test_parse_uris(self):
      tests = [
         (u"com.myapp.<product:int>.update", [
            (u"com.myapp.0.update", {u'product': 0}),
            (u"com.myapp.123456.update", {u'product': 123456}),
            (u"com.myapp.aaa.update", None),
            (u"com.myapp..update", None),
            (u"com.myapp.0.delete", None),
            ]
         ),
         (u"com.myapp.<product:string>.update", [
            (u"com.myapp.box.update", {u'product': u'box'}),
            (u"com.myapp.123456.update", {u'product': u'123456'}),
            (u"com.myapp..update", None),
            ]
         )
      ]
      for test in tests:
         pat = Pattern(test[0], Pattern.URI_TARGET_ENDPOINT)
         for ptest in test[1]:
            uri = ptest[0]
            kwargs_should = ptest[1]
            if kwargs_should is not None:
               args_is, kwargs_is = pat.match(uri)
               self.assertEqual(kwargs_is, kwargs_should)
            else:
               self.assertRaises(Exception, pat.match, uri)



class TestDecorators(unittest.TestCase):

   def test_decorate_endpoint(self):

      @wamp.procedure("com.calculator.square")
      def square(x):
         pass

      self.assertTrue(hasattr(square, '_wampuris'))
      self.assertTrue(type(square._wampuris) == list)
      self.assertEqual(len(square._wampuris), 1)
      self.assertIsInstance(square._wampuris[0], Pattern)
      self.assertTrue(square._wampuris[0].is_endpoint())
      self.assertFalse(square._wampuris[0].is_handler())
      self.assertFalse(square._wampuris[0].is_exception())
      self.assertEqual(square._wampuris[0].uri(), "com.calculator.square")
      self.assertEqual(square._wampuris[0]._type, Pattern.URI_TYPE_EXACT)

      @wamp.procedure("com.myapp.product.<product:int>.update")
      def update_product(product = None, label = None):
         pass

      self.assertTrue(hasattr(update_product, '_wampuris'))
      self.assertTrue(type(update_product._wampuris) == list)
      self.assertEqual(len(update_product._wampuris), 1)
      self.assertIsInstance(update_product._wampuris[0], Pattern)
      self.assertTrue(update_product._wampuris[0].is_endpoint())
      self.assertFalse(update_product._wampuris[0].is_handler())
      self.assertFalse(update_product._wampuris[0].is_exception())
      self.assertEqual(update_product._wampuris[0].uri(), "com.myapp.product.<product:int>.update")
      self.assertEqual(update_product._wampuris[0]._type, Pattern.URI_TYPE_WILDCARD)

      @wamp.procedure("com.myapp.<category:string>.<id:int>.update")
      def update(category = None, id = None):
         pass

      self.assertTrue(hasattr(update, '_wampuris'))
      self.assertTrue(type(update._wampuris) == list)
      self.assertEqual(len(update._wampuris), 1)
      self.assertIsInstance(update._wampuris[0], Pattern)
      self.assertTrue(update._wampuris[0].is_endpoint())
      self.assertFalse(update._wampuris[0].is_handler())
      self.assertFalse(update._wampuris[0].is_exception())
      self.assertEqual(update._wampuris[0].uri(), "com.myapp.<category:string>.<id:int>.update")
      self.assertEqual(update._wampuris[0]._type, Pattern.URI_TYPE_WILDCARD)


   def test_decorate_handler(self):

      @wamp.topic("com.myapp.on_shutdown")
      def on_shutdown():
         pass

      self.assertTrue(hasattr(on_shutdown, '_wampuris'))
      self.assertTrue(type(on_shutdown._wampuris) == list)
      self.assertEqual(len(on_shutdown._wampuris), 1)
      self.assertIsInstance(on_shutdown._wampuris[0], Pattern)
      self.assertFalse(on_shutdown._wampuris[0].is_endpoint())
      self.assertTrue(on_shutdown._wampuris[0].is_handler())
      self.assertFalse(on_shutdown._wampuris[0].is_exception())
      self.assertEqual(on_shutdown._wampuris[0].uri(), "com.myapp.on_shutdown")
      self.assertEqual(on_shutdown._wampuris[0]._type, Pattern.URI_TYPE_EXACT)

      @wamp.topic("com.myapp.product.<product:int>.on_update")
      def on_product_update(product = None, label = None):
         pass

      self.assertTrue(hasattr(on_product_update, '_wampuris'))
      self.assertTrue(type(on_product_update._wampuris) == list)
      self.assertEqual(len(on_product_update._wampuris), 1)
      self.assertIsInstance(on_product_update._wampuris[0], Pattern)
      self.assertFalse(on_product_update._wampuris[0].is_endpoint())
      self.assertTrue(on_product_update._wampuris[0].is_handler())
      self.assertFalse(on_product_update._wampuris[0].is_exception())
      self.assertEqual(on_product_update._wampuris[0].uri(), "com.myapp.product.<product:int>.on_update")
      self.assertEqual(on_product_update._wampuris[0]._type, Pattern.URI_TYPE_WILDCARD)

      @wamp.topic("com.myapp.<category:string>.<id:int>.on_update")
      def on_update(category = None, id = None, label = None):
         pass

      self.assertTrue(hasattr(on_update, '_wampuris'))
      self.assertTrue(type(on_update._wampuris) == list)
      self.assertEqual(len(on_update._wampuris), 1)
      self.assertIsInstance(on_update._wampuris[0], Pattern)
      self.assertFalse(on_update._wampuris[0].is_endpoint())
      self.assertTrue(on_update._wampuris[0].is_handler())
      self.assertFalse(on_update._wampuris[0].is_exception())
      self.assertEqual(on_update._wampuris[0].uri(), "com.myapp.<category:string>.<id:int>.on_update")
      self.assertEqual(on_update._wampuris[0]._type, Pattern.URI_TYPE_WILDCARD)


   def test_decorate_exception(self):

      @wamp.error("com.myapp.error")
      class AppError(Exception):
         pass

      self.assertTrue(hasattr(AppError, '_wampuris'))
      self.assertTrue(type(AppError._wampuris) == list)
      self.assertEqual(len(AppError._wampuris), 1)
      self.assertIsInstance(AppError._wampuris[0], Pattern)
      self.assertFalse(AppError._wampuris[0].is_endpoint())
      self.assertFalse(AppError._wampuris[0].is_handler())
      self.assertTrue(AppError._wampuris[0].is_exception())
      self.assertEqual(AppError._wampuris[0].uri(), "com.myapp.error")
      self.assertEqual(AppError._wampuris[0]._type, Pattern.URI_TYPE_EXACT)

      @wamp.error("com.myapp.product.<product:int>.product_inactive")
      class ProductInactiveError(Exception):
         pass

      self.assertTrue(hasattr(ProductInactiveError, '_wampuris'))
      self.assertTrue(type(ProductInactiveError._wampuris) == list)
      self.assertEqual(len(ProductInactiveError._wampuris), 1)
      self.assertIsInstance(ProductInactiveError._wampuris[0], Pattern)
      self.assertFalse(ProductInactiveError._wampuris[0].is_endpoint())
      self.assertFalse(ProductInactiveError._wampuris[0].is_handler())
      self.assertTrue(ProductInactiveError._wampuris[0].is_exception())
      self.assertEqual(ProductInactiveError._wampuris[0].uri(), "com.myapp.product.<product:int>.product_inactive")
      self.assertEqual(ProductInactiveError._wampuris[0]._type, Pattern.URI_TYPE_WILDCARD)

      @wamp.error("com.myapp.<category:string>.<product:int>.inactive")
      class ObjectInactiveError(Exception):
         pass

      self.assertTrue(hasattr(ObjectInactiveError, '_wampuris'))
      self.assertTrue(type(ObjectInactiveError._wampuris) == list)
      self.assertEqual(len(ObjectInactiveError._wampuris), 1)
      self.assertIsInstance(ObjectInactiveError._wampuris[0], Pattern)
      self.assertFalse(ObjectInactiveError._wampuris[0].is_endpoint())
      self.assertFalse(ObjectInactiveError._wampuris[0].is_handler())
      self.assertTrue(ObjectInactiveError._wampuris[0].is_exception())
      self.assertEqual(ObjectInactiveError._wampuris[0].uri(), "com.myapp.<category:string>.<product:int>.inactive")
      self.assertEqual(ObjectInactiveError._wampuris[0]._type, Pattern.URI_TYPE_WILDCARD)


   def test_match_decorated_endpoint(self):

      @wamp.procedure("com.calculator.square")
      def square(x):
         return x

      args, kwargs = square._wampuris[0].match("com.calculator.square")
      self.assertEqual(square(666, **kwargs), 666)

      @wamp.procedure("com.myapp.product.<product:int>.update")
      def update_product(product = None, label = None):
         return product, label

      args, kwargs = update_product._wampuris[0].match("com.myapp.product.123456.update")
      kwargs['label'] = "foobar"
      self.assertEqual(update_product(**kwargs), (123456, "foobar"))

      @wamp.procedure("com.myapp.<category:string>.<id:int>.update")
      def update(category = None, id = None, label = None):
         return category, id, label

      args, kwargs = update._wampuris[0].match("com.myapp.product.123456.update")
      kwargs['label'] = "foobar"
      self.assertEqual(update(**kwargs), ("product", 123456, "foobar"))


   def test_match_decorated_handler(self):

      @wamp.topic("com.myapp.on_shutdown")
      def on_shutdown():
         pass

      args, kwargs = on_shutdown._wampuris[0].match("com.myapp.on_shutdown")
      self.assertEqual(on_shutdown(**kwargs), None)

      @wamp.topic("com.myapp.product.<product:int>.on_update")
      def on_product_update(product = None, label = None):
         return product, label

      args, kwargs = on_product_update._wampuris[0].match("com.myapp.product.123456.on_update")
      kwargs['label'] = "foobar"
      self.assertEqual(on_product_update(**kwargs), (123456, "foobar"))

      @wamp.topic("com.myapp.<category:string>.<id:int>.on_update")
      def on_update(category = None, id = None, label = None):
         return category, id, label

      args, kwargs = on_update._wampuris[0].match("com.myapp.product.123456.on_update")
      kwargs['label'] = "foobar"
      self.assertEqual(on_update(**kwargs), ("product", 123456, "foobar"))


   def test_match_decorated_exception(self):

      @wamp.error("com.myapp.error")
      class AppError(Exception):

         def __init__(self, msg):
            Exception.__init__(self, msg)

         def __eq__(self, other):
            return self.__class__ == other.__class__ and \
                   self.args == other.args

      args, kwargs = AppError._wampuris[0].match("com.myapp.error")
      self.assertEqual(AppError("fuck", **kwargs), AppError("fuck"))


      @wamp.error("com.myapp.product.<product:int>.product_inactive")
      class ProductInactiveError(Exception):

         def __init__(self, msg, product = None):
            Exception.__init__(self, msg)
            self.product = product

         def __eq__(self, other):
            return self.__class__ == other.__class__ and \
                   self.args == other.args and \
                   self.product == other.product

      args, kwargs = ProductInactiveError._wampuris[0].match("com.myapp.product.123456.product_inactive")
      self.assertEqual(ProductInactiveError("fuck", **kwargs), ProductInactiveError("fuck", 123456))


      @wamp.error("com.myapp.<category:string>.<product:int>.inactive")
      class ObjectInactiveError(Exception):

         def __init__(self, msg, category = None, product = None):
            Exception.__init__(self, msg)
            self.category = category
            self.product = product

         def __eq__(self, other):
            return self.__class__ == other.__class__ and \
                   self.args == other.args and \
                   self.category == other.category and \
                   self.product == other.product

      args, kwargs = ObjectInactiveError._wampuris[0].match("com.myapp.product.123456.inactive")
      self.assertEqual(ObjectInactiveError("fuck", **kwargs), ObjectInactiveError("fuck", "product", 123456))



class KwException(Exception):
   def __init__(self, *args, **kwargs):
      Exception.__init__(self, *args)
      self.kwargs = kwargs

# what if the WAMP error message received
# contains args/kwargs that cannot be
# consumed by the constructor of the exception
# class defined for the WAMP error URI?

# 1. we can bail out (but we are already signaling an error)
# 2. we can require a generic constructor
# 3. we can map only unconsumed args/kwargs to generic attributes
# 4. we can silently drop unconsumed args/kwargs


def getargs(fun):
   try:
      argspec = inspect.getargspec(fun)
   except:
      if fun == Exception.__init__:
         # `inspect.getargspec(Exception.__init__)` does work on PyPy, but not
         # on CPython, since `Exception.__init__` is C code in CPython that
         # cannot be reflected upon.
         argspec = inspect.ArgSpec(args = ['self'], varargs = 'args', keywords = None, defaults = None)
      else:
         raise Exception("could not inspect function {}".format(fun))

   args = argspec.args[:-len(argspec.defaults)]
   kwargs = argspec.args[-len(argspec.defaults):]

   return args, kwargs, argspec.varargs, argspec.keywords


class MockSession:

   def __init__(self):
      self._ecls_to_uri_pat = {}
      self._uri_to_ecls = {}


   def define(self, exception, error = None):
      if error is None:
         assert(hasattr(exception, '_wampuris'))
         self._ecls_to_uri_pat[exception] = exception._wampuris
         self._uri_to_ecls[exception._wampuris[0].uri()] = exception
      else:
         assert(not hasattr(exception, '_wampuris'))
         self._ecls_to_uri_pat[exception] = [Pattern(error, Pattern.URI_TARGET_HANDLER)]
         self._uri_to_ecls[error] = exception


   def map_error(self, error, args = [], kwargs = {}):

      # FIXME:
      # 1. map to ecls based on error URI wildcard/prefix
      # 2. extract additional args/kwargs from error URI

      if self._uri_to_ecls.has_key(error):
         ecls = self._uri_to_ecls[error]
         try:
            ## the following might fail, eg. TypeError when
            ## signature of exception constructor is incompatible
            ## with args/kwargs or when the exception constructor raises
            if kwargs:
               if args:
                  exc = ecls(*args, **kwargs)
               else:
                  exc = ecls(**kwargs)
            else:
               if args:
                  exc = ecls(*args)
               else:
                  exc = ecls()
         except Exception as e:
            ## FIXME: log e
            exc = KwException(error, *args, **kwargs)
      else:
         ## this never fails
         exc = KwException(error, *args, **kwargs)
      return exc



class TestDecoratorsAdvanced(unittest.TestCase):

   def test_decorate_exception_non_exception(self):

      def test():
         @wamp.error("com.test.error")
         class Foo:
            pass

      self.assertRaises(Exception, test)


   def test_decorate_endpoint_multiple(self):

      @wamp.procedure("com.oldapp.oldproc")
      @wamp.procedure("com.calculator.square")
      def square(x):
         pass

      self.assertTrue(hasattr(square, '_wampuris'))
      self.assertTrue(type(square._wampuris) == list)
      self.assertEqual(len(square._wampuris), 2)

      for i in range(2):
         self.assertIsInstance(square._wampuris[i], Pattern)
         self.assertTrue(square._wampuris[i].is_endpoint())
         self.assertFalse(square._wampuris[i].is_handler())
         self.assertFalse(square._wampuris[i].is_exception())
         self.assertEqual(square._wampuris[i]._type, Pattern.URI_TYPE_EXACT)

      self.assertEqual(square._wampuris[0].uri(), "com.calculator.square")
      self.assertEqual(square._wampuris[1].uri(), "com.oldapp.oldproc")


   def test_marshal_decorated_exception(self):

      @wamp.error("com.myapp.error")
      class AppError(Exception):
         pass

      try:
         raise AppError("fuck")
      except Exception as e:
         self.assertEqual(e._wampuris[0].uri(), "com.myapp.error")


      @wamp.error("com.myapp.product.<product:int>.product_inactive")
      class ProductInactiveError(Exception):

         def __init__(self, msg, product = None):
            Exception.__init__(self, msg)
            self.product = product

      try:
         raise ProductInactiveError("fuck", 123456)
      except Exception as e:
         self.assertEqual(e._wampuris[0].uri(), "com.myapp.product.<product:int>.product_inactive")

      class AppErrorUndecorated(Exception):
         pass

      session = MockSession()
      session.define(AppError)


   def test_define_exception_undecorated(self):

      session = MockSession()

      class AppError(Exception):
         pass

      ## defining an undecorated exception requires
      ## an URI to be provided
      self.assertRaises(Exception, session.define, AppError)

      session.define(AppError, u"com.myapp.error")

      exc = session.map_error(u"com.myapp.error")
      self.assertIsInstance(exc, AppError)


   def test_define_exception_decorated(self):

      session = MockSession()

      @wamp.error("com.myapp.error")
      class AppError(Exception):
         pass

      ## when defining a decorated exception
      ## an URI must not be provided
      self.assertRaises(Exception, session.define, AppError, "com.myapp.error")

      session.define(AppError)

      exc = session.map_error("com.myapp.error")
      self.assertIsInstance(exc, AppError)


   def test_map_exception_undefined(self):

      session = MockSession()

      exc = session.map_error("com.myapp.error")
      self.assertIsInstance(exc, Exception)


   def test_map_exception_args(self):

      session = MockSession()

      @wamp.error("com.myapp.error")
      class AppError(Exception):
         pass

      @wamp.error("com.myapp.error.product_inactive")
      class ProductInactiveError(Exception):
         def __init__(self, product = None):
            self.product = product

      ## define exceptions in mock session
      session.define(AppError)
      session.define(ProductInactiveError)

      for test in [
         #("com.myapp.foo.error", [], {}, KwException),
         ("com.myapp.error", [], {}, AppError),
         ("com.myapp.error", ["you are doing it wrong"], {}, AppError),
         ("com.myapp.error", ["you are doing it wrong", 1, 2, 3], {}, AppError),

         ("com.myapp.error.product_inactive", [], {}, ProductInactiveError),
         ("com.myapp.error.product_inactive", [], {"product": 123456}, ProductInactiveError),
         ]:
         error, args, kwargs, ecls = test
         exc = session.map_error(error, args, kwargs)

         self.assertIsInstance(exc, ecls)
         self.assertEqual(list(exc.args), args)



if __name__ == '__main__':
   unittest.main()

########NEW FILE########
__FILENAME__ = types
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

import six


class ComponentConfig:
   def __init__(self, realm = None, extra = None):
      if six.PY2 and type(realm) == str:
         realm = six.u(realm)
      self.realm = realm
      self.extra = extra



class RouterOptions:
   URI_CHECK_LOOSE = "loose"
   URI_CHECK_STRICT = "strict"

   def __init__(self, uri_check = None):
      self.uri_check = uri_check or RouterOptions.URI_CHECK_STRICT



class HelloReturn:
   """
   Base class for HELLO return information.
   """


class Accept(HelloReturn):
   """
   Information to accept a HELLO.
   """

   def __init__(self, authid = None, authrole = None, authmethod = None):
      if six.PY2:
         if type(authid) == str:
            authid = six.u(authid)
         if type(authrole) == str:
            authrole = six.u(authrole)
         if type(authmethod) == str:
            authmethod = six.u(authmethod)

      assert(authid is None or type(authid) == six.text_type)
      assert(authrole is None or type(authrole) == six.text_type)
      assert(authmethod is None or type(authmethod) == six.text_type)

      self.authid = authid
      self.authrole = authrole
      self.authmethod = authmethod



class Deny(HelloReturn):
   """
   Information to deny a HELLO.
   """

   def __init__(self, reason = u"wamp.error.not_authorized", message = None):
      if six.PY2:
         if type(reason) == str:
            reason = six.u(reason)
         if type(message) == str:
            message = six.u(message)

      assert(type(reason) == six.text_type)
      assert(message is None or type(message) == six.text_type)

      self.reason = reason
      self.message = message



class Challenge(HelloReturn):
   def __init__(self, method, extra = {}):
      if six.PY2:
         if type(method) == str:
            method = six.u(method)

      self.method = method
      self.extra = extra



class HelloDetails:
   def __init__(self, roles = None, authmethods = None):
      self.roles = roles
      self.authmethods = authmethods



class SessionDetails:
   """
   Provides details for a WAMP session, provided in
   :func:`autobahn.wamp.interfaces.IAppSession.onSessionOpen`.
   """

   def __init__(self, realm, session, authid = None, authrole = None, authmethod = None):
      """
      Ctor.

      :param session: WAMP session ID of this session.
      :type session: int
      """
      self.realm = realm
      self.session = session
      self.authid = authid
      self.authrole = authrole
      self.authmethod = authmethod

   def __str__(self):
      return "SessionDetails(realm = {}, session = {}, authid = {}, authrole = {}, authmethod = {})".format(self.realm, self.session, self.authid, self.authrole, self.authmethod)



class CloseDetails:
   """
   Provides details on closing of a WAMP session, provided in
   :func:`autobahn.wamp.interfaces.IAppSession.onSessionClose`.
   """

   def __init__(self, reason = None, message = None):
      self.reason = reason
      self.message = message



class SubscribeOptions:
   """
   Used to provide options for subscribing in
   :func:`autobahn.wamp.interfaces.ISubscriber.subscribe`.
   """

   def __init__(self, match = None, details_arg = None):
      """
      :param match: The topic matching method to be used for the subscription.
      :type match: str
      :param details_arg: When invoking the handler, provide event details
                          in this keyword argument to the callable.
      :type details_arg: str
      """
      assert(match is None or (type(match) == str and match in ['exact', 'prefix', 'wildcard']))
      assert(details_arg is None or type(details_arg) == str)

      self.details_arg = details_arg
      if match and six.PY2 and type(match) == str:
         match = six.u(match)
      self.options = {'match': match}



class EventDetails:
   """
   Provides details on an event when calling an event handler
   previously registered.
   """
   def __init__(self, publication, publisher = None):
      """
      Ctor.

      :param publication: The publication ID of the event (always present).
      :type publication: int
      :param publisher: The WAMP session ID of the original publisher of this event.
      :type publisher: int
      """
      self.publication = publication
      self.publisher = publisher



class PublishOptions:
   """
   Used to provide options for subscribing in
   :func:`autobahn.wamp.interfaces.IPublisher.publish`.
   """

   def __init__(self,
                acknowledge = None,
                excludeMe = None,
                exclude = None,
                eligible = None,
                discloseMe = None):
      """
      Constructor.

      :param acknowledge: If True, acknowledge the publication with a success or
                          error response.
      :type acknowledge: bool
      :param excludeMe: If True, exclude the publisher from receiving the event, even
                        if he is subscribed (and eligible).
      :type excludeMe: bool
      :param exclude: List of WAMP session IDs to exclude from receiving this event.
      :type exclude: list
      :param eligible: List of WAMP session IDs eligible to receive this event.
      :type eligible: list
      :param discloseMe: If True, request to disclose the publisher of this event
                         to subscribers.
      :type discloseMe: bool
      """
      assert(acknowledge is None or type(acknowledge) == bool)
      assert(excludeMe is None or type(excludeMe) == bool)
      assert(exclude is None or (type(exclude) == list and all(type(x) in six.integer_types for x in exclude)))
      assert(eligible is None or (type(eligible) == list and all(type(x) in six.integer_types for x in eligible)))
      assert(discloseMe is None or type(discloseMe) == bool)

      self.options = {
         'acknowledge': acknowledge,
         'excludeMe': excludeMe,
         'exclude': exclude,
         'eligible': eligible,
         'discloseMe': discloseMe
      }



class RegisterOptions:
   """
   Used to provide options for registering in
   :func:`autobahn.wamp.interfaces.ICallee.register`.
   """

   def __init__(self, details_arg = None, pkeys = None, discloseCaller = None):
      """
      Ctor.

      :param details_arg: When invoking the endpoint, provide call details
                          in this keyword argument to the callable.
      :type details_arg: str
      """
      self.details_arg = details_arg
      self.options = {
         'pkeys': pkeys,
         'discloseCaller': discloseCaller
      }



class CallDetails:
   """
   Provides details on a call when an endpoint previously
   registered is being called and opted to receive call details.
   """

   def __init__(self, progress = None, caller = None, authid = None, authrole = None, authmethod = None):
      """
      Ctor.

      :param progress: A callable that will receive progressive call results.
      :type progress: callable
      :param caller: The WAMP session ID of the caller, if the latter is disclosed.
      :type caller: int
      :param authid: The authentication ID of the caller.
      :type authid: str
      :param authrole: The authentication role of the caller.
      :type authrole: str
      """
      self.progress = progress
      self.caller = caller
      self.authid = authid
      self.authrole = authrole
      self.authmethod = authmethod

   def __str__(self):
      return "CallDetails(progress = {}, caller = {}, authid = {}, authrole = {}, authmethod = {})".format(self.progress, self.caller, self.authid, self.authrole, self.authmethod)



class CallOptions:
   """
   Used to provide options for calling with :func:`autobahn.wamp.interfaces.ICaller.call`.
   """

   def __init__(self,
                onProgress = None,
                timeout = None,
                discloseMe = None,
                runOn = None):
      """
      Constructor.

      :param onProgress: A callback that will be called when the remote endpoint
                         called yields interim call progress results.
      :type onProgress: a callable
      :param timeout: Time in seconds after which the call should be automatically cancelled.
      :type timeout: float
      :param discloseMe: Request to disclose the identity of the caller (it's WAMP session ID)
                         to Callees. Note that a Dealer, depending on Dealer configuration, might
                         reject the request, or might disclose the Callee's identity without
                         a request to do so.
      :type discloseMe: bool
      :param runOn: If present (non-None), indicates a distributed call. Distributed calls allows
                    to run a call issued by a Caller on one or more endpoints implementing the
                    called procedure. Permissible value are: "all", "any" and "partition".
                    If `runOne == "partition"`, then `runPartitions` MUST be present.
      :type runOn: str
      """
      assert(onProgress is None or callable(onProgress))
      assert(timeout is None or (type(timeout) in list(six.integer_types) + [float] and timeout > 0))
      assert(discloseMe is None or type(discloseMe) == bool)
      assert(runOn is None or (type(runOn) == six.text_type and runOn in [u"all", u"any", u"partition"]))

      self.options = {
         'timeout': timeout,
         'discloseMe': discloseMe
      }

      self.onProgress = onProgress
      if onProgress:
         self.options['receive_progress'] = True



class CallResult:
   """
   Wrapper for remote procedure call results that contain multiple positional
   return values or keyword return values.
   """

   def __init__(self, *results, **kwresults):
      """
      Constructor.

      :param results: The positional result values.
      :type results: list
      :param kwresults: The keyword result values.
      :type kwresults: dict
      """
      self.results = results
      self.kwresults = kwresults

   def __str__(self):
      return "CallResult(results = {}, kwresults = {})".format(self.results, self.kwresults)

########NEW FILE########
__FILENAME__ = uri
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import re
import six

# TODO:
# suffix matches
# args + kwargs
# uuid converter
# multiple URI patterns per decorated object
# classes: Pattern, EndpointPattern, ..

class Pattern:
   """
   A WAMP URI Pattern.
   """

   URI_TARGET_ENDPOINT = 1
   URI_TARGET_HANDLER = 2
   URI_TARGET_EXCEPTION = 3

   URI_TYPE_EXACT = 1
   URI_TYPE_PREFIX = 2
   URI_TYPE_WILDCARD = 3

   _URI_COMPONENT = re.compile(r"^[a-z][a-z0-9_]*$")
   _URI_NAMED_COMPONENT = re.compile(r"^<([a-z][a-z0-9_]*)>$")
   _URI_NAMED_CONVERTED_COMPONENT = re.compile(r"^<([a-z][a-z0-9_]*):([a-z]*)>$")


   def __init__(self, uri, target):
      """
      Constructor for WAMP URI pattern.

      :param uri: The URI or URI pattern, e.g. `"com.myapp.product.<product:int>.update"`.
      :type uri: str
      :param target: The target for this pattern: a procedure endpoint (a callable),
                     an event handler (a callable) or an exception (a class).
      """
      assert(type(uri) == six.text_type)
      assert(target in [Pattern.URI_TARGET_ENDPOINT,
                        Pattern.URI_TARGET_HANDLER,
                        Pattern.URI_TARGET_EXCEPTION])

      components = uri.split('.')
      pl = []
      nc = {}
      i = 0
      for component in components:

         match = Pattern._URI_NAMED_CONVERTED_COMPONENT.match(component)
         if match:
            ctype = match.groups()[1]
            if ctype not in ['string', 'int', 'suffix']:
               raise Exception("invalid URI")

            if ctype == 'suffix' and i != len(components) - 1:
               raise Exception("invalid URI")

            name = match.groups()[0]
            if name in nc:
               raise Exception("invalid URI")

            if ctype in ['string', 'suffix']:
               nc[name] = str
            elif ctype == 'int':
               nc[name] = int
            else:
               # should not arrive here
               raise Exception("logic error")

            pl.append("(?P<{}>[a-z0-9_]+)".format(name))
            continue

         match = Pattern._URI_NAMED_COMPONENT.match(component)
         if match:
            name = match.groups()[0]
            if name in nc:
               raise Exception("invalid URI")

            nc[name] = str
            pl.append("(?P<{}>[a-z][a-z0-9_]*)".format(name))
            continue

         match = Pattern._URI_COMPONENT.match(component)
         if match:
            pl.append(component)
            continue

         raise Exception("invalid URI")

      if nc:
         # URI pattern
         self._type = Pattern.URI_TYPE_WILDCARD
         p = "^" + "\.".join(pl) + "$"
         self._pattern = re.compile(p)
         self._names = nc
      else:
         # exact URI
         self._type = Pattern.URI_TYPE_EXACT
         self._pattern = None
         self._names = None
      self._uri = uri
      self._target = target


   def uri(self):
      """
      Returns the original URI (pattern) for this pattern.

      :returns str -- The URI (pattern), e.g. `"com.myapp.product.<product:int>.update"`.
      """
      return self._uri


   def match(self, uri):
      """
      Match the given (fully qualified) URI according to this pattern
      and return extracted args and kwargs.

      :param uri: The URI to match, e.g. `"com.myapp.product.123456.update"`.
      :type uri: str

      :returns tuple -- A tuple `(args, kwargs)`
      """
      args = []
      kwargs = {}
      if self._type == Pattern.URI_TYPE_EXACT:
         return args, kwargs
      elif self._type == Pattern.URI_TYPE_WILDCARD:
         match = self._pattern.match(uri)
         if match:
            for key in self._names:
               val = match.group(key)
               val = self._names[key](val)
               kwargs[key] = val
            return args, kwargs
         else:
            raise Exception("no match")


   def is_endpoint(self):
      """
      Check if this pattern is for a procedure endpoint.

      :returns bool -- `True`, iff this pattern is for a procedure endpoint.
      """
      return self._target == Pattern.URI_TARGET_ENDPOINT


   def is_handler(self):
      """
      Check if this pattern is for an event handler.

      :returns bool -- `True`, iff this pattern is for an event handler.
      """
      return self._target == Pattern.URI_TARGET_HANDLER


   def is_exception(self):
      """
      Check if this pattern is for an exception.

      :returns bool -- `True`, iff this pattern is for an exception.
      """
      return self._target == Pattern.URI_TARGET_EXCEPTION

########NEW FILE########
__FILENAME__ = websocket
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import


__all__= ['WampWebSocketServerProtocol',
          'WampWebSocketClientProtocol',
          'WampWebSocketServerFactory',
          'WampWebSocketClientFactory']

from autobahn.websocket import protocol
from autobahn.websocket import http

from autobahn.wamp.interfaces import ITransport
from autobahn.wamp.exception import ProtocolError, SerializationError, TransportLost

import traceback



class WampWebSocketProtocol:
   """
   Base class for WAMP-over-WebSocket transport mixins.
   """

   def _bailout(self, code, reason):
      if self.factory.debug_wamp:
         print("Failing WAMP-over-WebSocket transport: code = {}, reason = '{}'".format(code, reason))
      self.failConnection(code, reason)


   def onOpen(self):
      """
      Callback from :func:`autobahn.websocket.interfaces.IWebSocketChannel.onOpen`
      """
      ## WebSocket connection established. Now let the user WAMP session factory
      ## create a new WAMP session and fire off session open callback.
      try:
         self._session = self.factory._factory()
         self._session.onOpen(self)
      except Exception as e:
         if self.factory.debug_wamp:
            traceback.print_exc()
         ## Exceptions raised in onOpen are fatal ..
         reason = "WAMP Internal Error ({})".format(e)
         self._bailout(protocol.WebSocketProtocol.CLOSE_STATUS_CODE_INTERNAL_ERROR, reason = reason)


   def onClose(self, wasClean, code, reason):
      """
      Callback from :func:`autobahn.websocket.interfaces.IWebSocketChannel.onClose`
      """
      ## WebSocket connection lost - fire off the WAMP
      ## session close callback
      try:
         if self.factory.debug_wamp:
            print("WAMP-over-WebSocket transport lost: wasClean = {}, code = {}, reason = '{}'".format(wasClean, code, reason))
         self._session.onClose(wasClean)
      except Exception as e:
         ## silently ignore exceptions raised here ..
         if self.factory.debug_wamp:
            traceback.print_exc()
      self._session = None


   def onMessage(self, payload, isBinary):
      """
      Callback from :func:`autobahn.websocket.interfaces.IWebSocketChannel.onMessage`
      """
      try:
         msg = self._serializer.unserialize(payload, isBinary)
         if self.factory.debug_wamp:
            print("RX {}".format(msg))
         self._session.onMessage(msg)

      except ProtocolError as e:
         if self.factory.debug_wamp:
            traceback.print_exc()
         reason = "WAMP Protocol Error ({})".format(e)
         self._bailout(protocol.WebSocketProtocol.CLOSE_STATUS_CODE_PROTOCOL_ERROR, reason = reason)

      except Exception as e:
         if self.factory.debug_wamp:
            traceback.print_exc()
         reason = "WAMP Internal Error ({})".format(e)
         self._bailout(protocol.WebSocketProtocol.CLOSE_STATUS_CODE_INTERNAL_ERROR, reason = reason)


   def send(self, msg):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransport.send`
      """
      if self.isOpen():
         try:
            if self.factory.debug_wamp:
               print("TX {}".format(msg))
            bytes, isBinary = self._serializer.serialize(msg)
         except Exception as e:
            ## all exceptions raised from above should be serialization errors ..
            raise SerializationError("Unable to serialize WAMP application payload ({})".format(e))
         else:
            self.sendMessage(bytes, isBinary)
      else:
         raise TransportLost()


   def isOpen(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransport.isOpen`
      """
      return self._session is not None


   def close(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransport.close`
      """
      if self.isOpen():
         self.sendClose(protocol.WebSocketProtocol.CLOSE_STATUS_CODE_NORMAL)
      else:
         raise TransportLost()


   def abort(self):
      """
      Implements :func:`autobahn.wamp.interfaces.ITransport.abort`
      """
      if self.isOpen():
         self._bailout(protocol.WebSocketProtocol.CLOSE_STATUS_CODE_GOING_AWAY)
      else:
         raise TransportLost()



ITransport.register(WampWebSocketProtocol)



def parseSubprotocolIdentifier(subprotocol):
   try:
      s = subprotocol.split('.')
      if s[0] != "wamp":
         raise Exception("invalid protocol %s" % s[0])
      version = int(s[1])
      serializerId = s[2]
      return version, serializerId
   except:
      return None, None



class WampWebSocketServerProtocol(WampWebSocketProtocol):
   """
   Mixin for WAMP-over-WebSocket server transports.
   """

   STRICT_PROTOCOL_NEGOTIATION = True

   def onConnect(self, request):
      """
      Callback from :func:`autobahn.websocket.interfaces.IWebSocketChannel.onConnect`
      """
      headers = {}
      for subprotocol in request.protocols:
         version, serializerId = parseSubprotocolIdentifier(subprotocol)
         if version == 2 and serializerId in self.factory._serializers.keys():
            self._serializer = self.factory._serializers[serializerId]
            return subprotocol, headers

      if self.STRICT_PROTOCOL_NEGOTIATION:
         raise http.HttpException(http.BAD_REQUEST[0], "This server only speaks WebSocket subprotocols %s" % ', '.join(self.factory.protocols))
      else:
         ## assume wamp.2.json
         self._serializer = self.factory._serializers['json']
         return None, headers



class WampWebSocketClientProtocol(WampWebSocketProtocol):
   """
   Mixin for WAMP-over-WebSocket client transports.
   """

   STRICT_PROTOCOL_NEGOTIATION = True

   def onConnect(self, response):
      """
      Callback from :func:`autobahn.websocket.interfaces.IWebSocketChannel.onConnect`
      """
      if response.protocol not in self.factory.protocols:
         if self.STRICT_PROTOCOL_NEGOTIATION:
            raise Exception("Server does not speak any of the WebSocket subprotocols we requested (%s)." % ', '.join(self.factory.protocols))
         else:
            ## assume wamp.2.json
            serializerId = 'json'
      else:
         version, serializerId = parseSubprotocolIdentifier(response.protocol)
      
      self._serializer = self.factory._serializers[serializerId]



class WampWebSocketFactory:
   """
   Base class for WAMP-over-WebSocket transport factory mixins.
   """

   def __init__(self, factory, serializers = None, debug_wamp = False):
      """
      :param factory: A callable that produces instances that implement
                      :class:`autobahn.wamp.interfaces.ITransportHandler`
      :type factory: callable
      :param serializers: A list of WAMP serializers to use (or None for default
                          serializers). Serializers must implement
                         :class:`autobahn.wamp.interfaces.ISerializer`.
      type serializers: list
      """
      assert(callable(factory))
      self._factory = factory

      self.debug_wamp = debug_wamp

      if serializers is None:
         serializers = []

         ## try MsgPack WAMP serializer
         try:
            from autobahn.wamp.serializer import MsgPackSerializer
            serializers.append(MsgPackSerializer())
         except ImportError:
            pass

         ## try JSON WAMP serializer
         try:
            from autobahn.wamp.serializer import JsonSerializer
            serializers.append(JsonSerializer())
         except ImportError:
            pass

         if not serializers:
            raise Exception("could not import any WAMP serializers")

      self._serializers = {}
      for ser in serializers:
         self._serializers[ser.SERIALIZER_ID] = ser

      self._protocols = ["wamp.2.%s" % ser.SERIALIZER_ID for ser in serializers]



class WampWebSocketServerFactory(WampWebSocketFactory):
   """
   Mixin for WAMP-over-WebSocket server transport factories.
   """



class WampWebSocketClientFactory(WampWebSocketFactory):
   """
   Mixin for WAMP-over-WebSocket client transport factories.
   """

########NEW FILE########
__FILENAME__ = pbkdf2
# -*- coding: utf-8 -*-
"""
    pbkdf2
    ~~~~~~

    This module implements pbkdf2 for Python.  It also has some basic
    tests that ensure that it works.  The implementation is straightforward
    and uses stdlib only stuff and can be easily be copy/pasted into
    your favourite application.

    Use this as replacement for bcrypt that does not need a c implementation
    of a modified blowfish crypto algo.

    Example usage:

    >>> pbkdf2_hex('what i want to hash', 'the random salt')
    'fa7cc8a2b0a932f8e6ea42f9787e9d36e592e0c222ada6a9'

    How to use this:

    1.  Use a constant time string compare function to compare the stored hash
        with the one you're generating::

            def safe_str_cmp(a, b):
                if len(a) != len(b):
                    return False
                rv = 0
                for x, y in izip(a, b):
                    rv |= ord(x) ^ ord(y)
                return rv == 0

    2.  Use `os.urandom` to generate a proper salt of at least 8 byte.
        Use a unique salt per hashed password.

    3.  Store ``algorithm$salt:costfactor$hash`` in the database so that
        you can upgrade later easily to a different algorithm if you need
        one.  For instance ``PBKDF2-256$thesalt:10000$deadbeef...``.


    :copyright: (c) Copyright 2011 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
"""

__all__ = ("pbkdf2_hex",
           "pbkdf2_bin",)

import sys
PY3 = sys.version_info >= (3,)


import hmac
import hashlib
from struct import Struct
from operator import xor
from itertools import starmap

if PY3:
   izip = zip
else:
   from itertools import izip, starmap

_pack_int = Struct('>I').pack


def pbkdf2_hex(data, salt, iterations=1000, keylen=24, hashfunc=None):
    """Like :func:`pbkdf2_bin` but returns a hex encoded string."""
    return pbkdf2_bin(data, salt, iterations, keylen, hashfunc).encode('hex')


def pbkdf2_bin(data, salt, iterations=1000, keylen=24, hashfunc=None):
    """Returns a binary digest for the PBKDF2 hash algorithm of `data`
    with the given `salt`.  It iterates `iterations` time and produces a
    key of `keylen` bytes.  By default SHA-1 is used as hash function,
    a different hashlib `hashfunc` can be provided.
    """
    hashfunc = hashfunc or hashlib.sha1
    mac = hmac.new(data, None, hashfunc)
    def _pseudorandom(x, mac=mac):
        h = mac.copy()
        h.update(x)
        return map(ord, h.digest())
    buf = []
    for block in xrange(1, -(-keylen // mac.digest_size) + 1):
        rv = u = _pseudorandom(salt + _pack_int(block))
        for i in xrange(iterations - 1):
            u = _pseudorandom(''.join(map(chr, u)))
            rv = starmap(xor, izip(rv, u))
        buf.extend(rv)
    return ''.join(map(chr, buf))[:keylen]


def test():
    failed = []
    def check(data, salt, iterations, keylen, expected):
        rv = pbkdf2_hex(data, salt, iterations, keylen)
        if rv != expected:
            print('Test failed:')
            print('  Expected:   %s' % expected)
            print('  Got:        %s' % rv)
            print('  Parameters:')
            print('    data=%s' % data)
            print('    salt=%s' % salt)
            print('    iterations=%d' % iterations)
            print()
            failed.append(1)

    # From RFC 6070
    check('password', 'salt', 1, 20,
          '0c60c80f961f0e71f3a9b524af6012062fe037a6')
    check('password', 'salt', 2, 20,
          'ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957')
    check('password', 'salt', 4096, 20,
          '4b007901b765489abead49d926f721d065a429c1')
    check('passwordPASSWORDpassword', 'saltSALTsaltSALTsaltSALTsaltSALTsalt',
          4096, 25, '3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038')
    check('pass\x00word', 'sa\x00lt', 4096, 16,
          '56fa6aa75548099dcc37d7f03425e0c3')
    # This one is from the RFC but it just takes for ages
    ##check('password', 'salt', 16777216, 20,
    ##      'eefe3d61cd4da4e4e9945b3d6ba2158c2634e984')

    # From Crypt-PBKDF2
    check('password', 'ATHENA.MIT.EDUraeburn', 1, 16,
          'cdedb5281bb2f801565a1122b2563515')
    check('password', 'ATHENA.MIT.EDUraeburn', 1, 32,
          'cdedb5281bb2f801565a1122b25635150ad1f7a04bb9f3a333ecc0e2e1f70837')
    check('password', 'ATHENA.MIT.EDUraeburn', 2, 16,
          '01dbee7f4a9e243e988b62c73cda935d')
    check('password', 'ATHENA.MIT.EDUraeburn', 2, 32,
          '01dbee7f4a9e243e988b62c73cda935da05378b93244ec8f48a99e61ad799d86')
    check('password', 'ATHENA.MIT.EDUraeburn', 1200, 32,
          '5c08eb61fdf71e4e4ec3cf6ba1f5512ba7e52ddbc5e5142f708a31e2e62b1e13')
    check('X' * 64, 'pass phrase equals block size', 1200, 32,
          '139c30c0966bc32ba55fdbf212530ac9c5ec59f1a452f5cc9ad940fea0598ed1')
    check('X' * 65, 'pass phrase exceeds block size', 1200, 32,
          '9ccad6d468770cd51b10e6a68721be611a8b4d282601db3b36be9246915ec82a')

    raise SystemExit(bool(failed))


if __name__ == '__main__':
    test()

########NEW FILE########
__FILENAME__ = prefixmap
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ("PrefixMap",)


class PrefixMap:
   """
   Provides a two-way mapping between CURIEs (Compact URI Expressions) and
   full URIs. See http://www.w3.org/TR/curie/.
   """

   def __init__(self):
      self.index = {}
      self.rindex = {}

      ## add a couple of well-know prefixes
      ##
      #self.set("owl", "http://www.w3.org/2002/07/owl#")
      #self.set("rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#")
      #self.set("rdfs", "http://www.w3.org/2000/01/rdf-schema#")
      #self.set("rdfa", "http://www.w3.org/ns/rdfa#")
      #self.set("xhv", "http://www.w3.org/1999/xhtml/vocab#")
      #self.set("xml", "http://www.w3.org/XML/1998/namespace")
      #self.set("xsd", "http://www.w3.org/2001/XMLSchema#")


   def get(self, prefix):
      """
      Returns the URI for the prefix or None if prefix has no mapped URI.

      :param prefix: Prefix to map.
      :type prefix: str
      :returns: str -- Mapped URI for prefix or None.
      """
      return self.index.get(prefix, None)


   def set(self, prefix, uri):
      """
      Set mapping of prefix to URI.

      :param prefix: Prefix to be mapped.
      :type prefix: str
      :param uri: URI the prefix is to be mapped to.
      :type uri: str
      """
      self.index[prefix] = uri
      self.rindex[uri] = prefix


   def setDefault(self, uri):
      """
      Set default URI mapping of empty prefix (prefix of length 0).

      :param uri: URI the empty prefix to be mapped to (i.e. :label should map to uri:label).
      :type str
      """
      self.set("", uri)


   def remove(self, prefix):
      """
      Remove mapping of prefix to URI.

      :param prefix: Prefix for which mapping should be removed.
      :type str
      """
      uri = self.index.get(prefix, None)
      if uri:
         del self.index[prefix]
         del self.rindex[uri]


   def resolve(self, curie):
      """
      Resolve given CURIE to full URI.

      :param curie: CURIE (i.e. "rdf:label").
      :type curie: str
      :returns: str -- Full URI for CURIE or None.
      """
      i = curie.find(":")
      if i > 0:
         prefix = curie[:i]
         if self.index.has_key(prefix):
            return self.index[prefix] + curie[i+1:]
      return None


   def resolveOrPass(self, curieOrUri):
      """
      Resolve given CURIE/URI and return string verbatim if cannot be resolved.

      :param curieOrUri: CURIE or URI.
      :type curieOrUri: str
      :returns: str -- Full URI for CURIE or original string.
      """
      u = self.resolve(curieOrUri)
      if u:
         return u
      else:
         return curieOrUri


   def shrink(self, uri):
      """
      Shrink given URI to CURIE. If no appropriate prefix mapping is available,
      return original URI.

      :param uri: URI to shrink.
      :type uri: str
      :returns str -- CURIE or original URI.
      """
      for i in xrange(len(uri), 1, -1):
         u = uri[:i]
         p = self.rindex.get(u, None)
         if p:
            return p + ":" + uri[i:]
      return uri


if __name__ == '__main__':
   m = PrefixMap()
   print(m.resolve("http://www.w3.org/1999/02/22-rdf-syntax-ns#label"))
   print(m.resolve("rdf:label"))
   print(m.resolve("foobar:label"))
   print(m.shrink("http://www.w3.org/1999/02/22-rdf-syntax-ns#"))
   print(m.shrink("http://www.w3.org/1999/02/22-rdf-syntax-ns#label"))
   print(m.shrink("http://foobar.org#label"))

########NEW FILE########
__FILENAME__ = protocol
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

import sys
PY3 = sys.version_info >= (3,)


__all__ = ("WampProtocol",
           "WampFactory",
           "WampServerProtocol",
           "WampServerFactory",
           "WampClientProtocol",
           "WampClientFactory",
           "WampCraProtocol",
           "WampCraClientProtocol",
           "WampCraServerProtocol",
           "json_lib",
           "json_loads",
           "json_dumps",)


import inspect, types
import traceback

if PY3:
   from io import StringIO
else:
   import StringIO

import hashlib, hmac, binascii, random

from twisted.python import log
from twisted.internet.defer import Deferred, \
                                   maybeDeferred

from autobahn import __version__

from autobahn.websocket.protocol import WebSocketProtocol, \
                                        Timings
from autobahn.websocket import http
from autobahn.twisted.websocket import WebSocketClientProtocol, \
                                       WebSocketClientFactory, \
                                       WebSocketServerFactory, \
                                       WebSocketServerProtocol
from autobahn.wamp1.pbkdf2 import pbkdf2_bin
from autobahn.wamp1.prefixmap import PrefixMap
from autobahn.util import utcnow, newid


def exportRpc(arg = None):
   """
   Decorator for RPC'ed callables.
   """
   ## decorator without argument
   if type(arg) is types.FunctionType:
      arg._autobahn_rpc_id = arg.__name__
      return arg
   ## decorator with argument
   else:
      def inner(f):
         f._autobahn_rpc_id = arg
         return f
      return inner

def exportSub(arg, prefixMatch = False):
   """
   Decorator for subscription handlers.
   """
   def inner(f):
      f._autobahn_sub_id = arg
      f._autobahn_sub_prefix_match = prefixMatch
      return f
   return inner

def exportPub(arg, prefixMatch = False):
   """
   Decorator for publication handlers.
   """
   def inner(f):
      f._autobahn_pub_id = arg
      f._autobahn_pub_prefix_match = prefixMatch
      return f
   return inner


class WampProtocol:
   """
   WAMP protocol base class. Mixin for WampServerProtocol and WampClientProtocol.
   """

   URI_WAMP_BASE = "http://api.wamp.ws/"
   """
   WAMP base URI for WAMP predefined things.
   """

   URI_WAMP_ERROR = URI_WAMP_BASE + "error#"
   """
   Prefix for WAMP errors.
   """

   URI_WAMP_PROCEDURE = URI_WAMP_BASE + "procedure#"
   """
   Prefix for WAMP predefined RPC endpoints.
   """

   URI_WAMP_TOPIC = URI_WAMP_BASE + "topic#"
   """
   Prefix for WAMP predefined PubSub topics.
   """

   URI_WAMP_ERROR_GENERIC = URI_WAMP_ERROR + "generic"
   """
   WAMP error URI for generic errors.
   """

   DESC_WAMP_ERROR_GENERIC = "generic error"
   """
   Description for WAMP generic errors.
   """

   URI_WAMP_ERROR_INTERNAL = URI_WAMP_ERROR + "internal"
   """
   WAMP error URI for internal errors.
   """

   DESC_WAMP_ERROR_INTERNAL = "internal error"
   """
   Description for WAMP internal errors.
   """

   URI_WAMP_ERROR_NO_SUCH_RPC_ENDPOINT = URI_WAMP_ERROR + "NoSuchRPCEndpoint"
   """
   WAMP error URI for RPC endpoint not found.
   """

   WAMP_PROTOCOL_VERSION         = 1
   """
   WAMP version this server speaks. Versions are numbered consecutively
   (integers, no gaps).
   """

   MESSAGE_TYPEID_WELCOME        = 0
   """
   Server-to-client welcome message containing session ID.
   """

   MESSAGE_TYPEID_PREFIX         = 1
   """
   Client-to-server message establishing a URI prefix to be used in CURIEs.
   """

   MESSAGE_TYPEID_CALL           = 2
   """
   Client-to-server message initiating an RPC.
   """

   MESSAGE_TYPEID_CALL_RESULT    = 3
   """
   Server-to-client message returning the result of a successful RPC.
   """

   MESSAGE_TYPEID_CALL_ERROR     = 4
   """
   Server-to-client message returning the error of a failed RPC.
   """

   MESSAGE_TYPEID_SUBSCRIBE      = 5
   """
   Client-to-server message subscribing to a topic.
   """

   MESSAGE_TYPEID_UNSUBSCRIBE    = 6
   """
   Client-to-server message unsubscribing from a topic.
   """

   MESSAGE_TYPEID_PUBLISH        = 7
   """
   Client-to-server message publishing an event to a topic.
   """

   MESSAGE_TYPEID_EVENT          = 8
   """
   Server-to-client message providing the event of a (subscribed) topic.
   """

   def connectionMade(self):
      self.debugWamp = self.factory.debugWamp
      self.debugApp = self.factory.debugApp
      self.prefixes = PrefixMap()
      self.calls = {}
      self.procs = {}


   def connectionLost(self, reason):
      pass


   def _protocolError(self, reason):
      if self.debugWamp:
         log.msg("Closing Wamp session on protocol violation : %s" % reason)

      ## FIXME: subprotocols are probably not supposed to close with CLOSE_STATUS_CODE_PROTOCOL_ERROR
      ##
      self.protocolViolation("Wamp RPC/PubSub protocol violation ('%s')" % reason)


   def shrink(self, uri, passthrough = False):
      """
      Shrink given URI to CURIE according to current prefix mapping.
      If no appropriate prefix mapping is available, return original URI.

      :param uri: URI to shrink.
      :type uri: str

      :returns str -- CURIE or original URI.
      """
      return self.prefixes.shrink(uri)


   def resolve(self, curieOrUri, passthrough = False):
      """
      Resolve given CURIE/URI according to current prefix mapping or return
      None if cannot be resolved.

      :param curieOrUri: CURIE or URI.
      :type curieOrUri: str

      :returns: str -- Full URI for CURIE or None.
      """
      return self.prefixes.resolve(curieOrUri)


   def resolveOrPass(self, curieOrUri):
      """
      Resolve given CURIE/URI according to current prefix mapping or return
      string verbatim if cannot be resolved.

      :param curieOrUri: CURIE or URI.
      :type curieOrUri: str

      :returns: str -- Full URI for CURIE or original string.
      """
      return self.prefixes.resolveOrPass(curieOrUri)


   def serializeMessage(self, msg):
      """
      Delegate message serialization to the factory.
      :param msg: The message to be serialized.
      :type msg: str
      :return: The serialized message.
      """
      return self.factory._serialize(msg)


   def registerForRpc(self, obj, baseUri = "", methods = None):
      """
      Register an service object for RPC. A service object has methods
      which are decorated using @exportRpc.

      :param obj: The object to be registered (in this WebSockets session) for RPC.
      :type obj: Object with methods decorated using @exportRpc.
      :param baseUri: Optional base URI which is prepended to method names for export.
      :type baseUri: String.
      :param methods: If not None, a list of unbound class methods corresponding to obj
                     which should be registered. This can be used to register only a subset
                     of the methods decorated with @exportRpc.
      :type methods: List of unbound class methods.
      """
      for k in inspect.getmembers(obj.__class__, inspect.ismethod):
         if k[1].__dict__.has_key("_autobahn_rpc_id"):
            if methods is None or k[1] in methods:
               uri = baseUri + k[1].__dict__["_autobahn_rpc_id"]
               proc = k[1]
               self.registerMethodForRpc(uri, obj, proc)


   def registerMethodForRpc(self, uri, obj, proc):
      """
      Register a method of an object for RPC.

      :param uri: URI to register RPC method under.
      :type uri: str
      :param obj: The object on which to register a method for RPC.
      :type obj: object
      :param proc: Unbound object method to register RPC for.
      :type proc: unbound method
      """
      self.procs[uri] = (obj, proc, False)
      if self.debugWamp:
         log.msg("registered remote method on %s" % uri)


   def registerProcedureForRpc(self, uri, proc):
      """
      Register a (free standing) function/procedure for RPC.

      :param uri: URI to register RPC function/procedure under.
      :type uri: str
      :param proc: Free-standing function/procedure.
      :type proc: callable
      """
      self.procs[uri] = (None, proc, False)
      if self.debugWamp:
         log.msg("registered remote procedure on %s" % uri)


   def registerHandlerMethodForRpc(self, uri, obj, handler, extra = None):
      """
      Register a handler on an object for RPC.

      :param uri: URI to register RPC method under.
      :type uri: str
      :param obj: The object on which to register the RPC handler
      :type obj: object
      :param proc: Unbound object method to register RPC for.
      :type proc: unbound method
      :param extra: Optional extra data that will be given to the handler at call time.
      :type extra: object
      """
      self.procs[uri] = (obj, handler, True, extra)
      if self.debugWamp:
         log.msg("registered remote handler method on %s" % uri)


   def registerHandlerProcedureForRpc(self, uri, handler, extra = None):
      """
      Register a (free standing) handler for RPC.

      :param uri: URI to register RPC handler under.
      :type uri: str
      :param proc: Free-standing handler
      :type proc: callable
      :param extra: Optional extra data that will be given to the handler at call time.
      :type extra: object
      """
      self.procs[uri] = (None, handler, True, extra)
      if self.debugWamp:
         log.msg("registered remote handler procedure on %s" % uri)


   def procForUri(self, uri):
      """
      Returns the procedure specification for `uri` or None, if it does not exist.

      :param uri: URI to be checked.
      :type uri: str
      :returns: The procedure specification for `uri`, if it exists,
                `None` otherwise.
      """
      return self.procs[uri] if uri in self.procs else None


   def onBeforeCall(self, callid, uri, args, isRegistered):
      """
      Callback fired before executing incoming RPC. This can be used for
      logging, statistics tracking or redirecting RPCs or argument mangling i.e.

      The default implementation just returns the incoming URI/args.

      :param uri: RPC endpoint URI (fully-qualified).
      :type uri: str
      :param args: RPC arguments array.
      :type args: list
      :param isRegistered: True, iff RPC endpoint URI is registered in this session.
      :type isRegistered: bool
      :returns pair -- Must return URI/Args pair.
      """
      return uri, args


   def onAfterCallSuccess(self, result, call):
      """
      Callback fired after executing incoming RPC with success, but before
      sending the RPC success message.

      The default implementation will just return `result` to the client.

      :param result: Result returned for executing the incoming RPC.
      :type result: Anything returned by the user code for the endpoint.
      :param call: WAMP call object for incoming RPC.
      :type call: instance of Call
      :returns obj -- Result send back to client.
      """
      return result


   def onAfterCallError(self, error, call):
      """
      Callback fired after executing incoming RPC with failure, but before
      sending the RPC error message.

      The default implementation will just return `error` to the client.

      :param error: Error that occurred during incomnig RPC call execution.
      :type error: Instance of twisted.python.failure.Failure
      :param call: WAMP call object for incoming RPC.
      :type call: instance of Call
      :returns twisted.python.failure.Failure -- Error sent back to client.
      """
      return error


   def onAfterSendCallSuccess(self, msg, call):
      """
      Callback fired after sending RPC success message.

      :param msg: Serialized WAMP message.
      :type msg: str
      :param call: WAMP call object for incoming RPC.
      :type call: instance of Call
      """
      pass


   def onAfterSendCallError(self, msg, call):
      """
      Callback fired after sending RPC error message.

      :param msg: Serialized WAMP message.
      :type msg: str
      :param call: WAMP call object for incoming RPC.
      :type call: instance of Call
      """
      pass


   def call(self, *args):
      """
      Perform a remote-procedure call (RPC). The first argument is the procedure
      URI (mandatory). Subsequent positional arguments can be provided (must be
      JSON serializable). The return value is a Twisted Deferred.
      """

      if len(args) < 1:
         raise Exception("missing procedure URI")

      if type(args[0]) not in [unicode, str]:
         raise Exception("invalid type for procedure URI")

      procuri = args[0]
      while True:
         callid = newid()
         if not self.calls.has_key(callid):
            break
      d = Deferred()
      self.calls[callid] = d
      msg = [WampProtocol.MESSAGE_TYPEID_CALL, callid, procuri]
      msg.extend(args[1:])

      try:
         o = self.factory._serialize(msg)
      except:
         raise Exception("call argument(s) not JSON serializable")

      self.sendMessage(o)
      return d



## use Ultrajson (https://github.com/esnme/ultrajson) if available
##
try:
   import ujson
   json_lib = ujson
   json_loads = ujson.loads
   json_dumps = lambda x: ujson.dumps(x, ensure_ascii = False)
except:
   import json
   json_lib = json
   json_loads = json.loads
   json_dumps = json.dumps



class WampFactory:
   """
   WAMP factory base class. Mixin for WampServerFactory and WampClientFactory.
   """

   def __init__(self):
      if self.debugWamp:
         log.msg("Using JSON processor '%s'" % json_lib.__name__)


   def _serialize(self, obj):
      """
      Default object serializer.
      """
      return json_dumps(obj)


   def _unserialize(self, bytes):
      """
      Default object deserializer.
      """
      return json_loads(bytes)



class WampServerProtocol(WebSocketServerProtocol, WampProtocol):
   """
   Server factory for Wamp RPC/PubSub.
   """

   SUBSCRIBE = 1
   PUBLISH = 2

   def onSessionOpen(self):
      """
      Callback fired when WAMP session was fully established.
      """
      pass


   def onOpen(self):
      """
      Default implementation for WAMP connection opened sends
      Welcome message containing session ID.
      """
      self.session_id = newid()

      ## include traceback as error detail for RPC errors with
      ## no error URI - that is errors returned with URI_WAMP_ERROR_GENERIC
      self.includeTraceback = False

      msg = [WampProtocol.MESSAGE_TYPEID_WELCOME,
             self.session_id,
             WampProtocol.WAMP_PROTOCOL_VERSION,
             "Autobahn/%s" % __version__]
      o = self.factory._serialize(msg)
      self.sendMessage(o)

      self.factory._addSession(self, self.session_id)
      self.onSessionOpen()


   def onConnect(self, connectionRequest):
      """
      Default implementation for WAMP connection acceptance:
      check if client announced WAMP subprotocol, and only accept connection
      if client did so.
      """
      for p in connectionRequest.protocols:
         if p in self.factory.protocols:
            return (p, {}) # return (protocol, headers)
      raise http.HttpException(http.BAD_REQUEST[0], "this server only speaks WAMP")


   def connectionMade(self):
      WebSocketServerProtocol.connectionMade(self)
      WampProtocol.connectionMade(self)

      ## RPCs registered in this session (a URI map of (object, procedure)
      ## pairs for object methods or (None, procedure) for free standing procedures)
      self.procs = {}

      ## Publication handlers registered in this session (a URI map of (object, pubHandler) pairs
      ## pairs for object methods (handlers) or (None, None) for topic without handler)
      self.pubHandlers = {}

      ## Subscription handlers registered in this session (a URI map of (object, subHandler) pairs
      ## pairs for object methods (handlers) or (None, None) for topic without handler)
      self.subHandlers = {}

      self.handlerMapping = {
         self.MESSAGE_TYPEID_CALL: CallHandler(self, self.prefixes),
         self.MESSAGE_TYPEID_CALL_RESULT: CallResultHandler(self, self.prefixes),
         self.MESSAGE_TYPEID_CALL_ERROR: CallErrorHandler(self, self.prefixes)}


   def connectionLost(self, reason):
      self.factory._unsubscribeClient(self)
      self.factory._removeSession(self)

      WampProtocol.connectionLost(self, reason)
      WebSocketServerProtocol.connectionLost(self, reason)


   def sendMessage(self,
                   payload,
                   binary = False,
                   payload_frag_size = None,
                   sync = False,
                   doNotCompress = False):
      if self.debugWamp:
         log.msg("TX WAMP: %s" % str(payload))
      WebSocketServerProtocol.sendMessage(self,
                                          payload,
                                          binary,
                                          payload_frag_size,
                                          sync,
                                          doNotCompress)


   def _getPubHandler(self, topicUri):
      ## Longest matching prefix based resolution of (full) topic URI to
      ## publication handler.
      ## Returns a 5-tuple (consumedUriPart, unconsumedUriPart, handlerObj, handlerProc, prefixMatch)
      ##
      for i in xrange(len(topicUri), -1, -1):
         tt = topicUri[:i]
         if self.pubHandlers.has_key(tt):
            h = self.pubHandlers[tt]
            return (tt, topicUri[i:], h[0], h[1], h[2])
      return None


   def _getSubHandler(self, topicUri):
      ## Longest matching prefix based resolution of (full) topic URI to
      ## subscription handler.
      ## Returns a 5-tuple (consumedUriPart, unconsumedUriPart, handlerObj, handlerProc, prefixMatch)
      ##
      for i in xrange(len(topicUri), -1, -1):
         tt = topicUri[:i]
         if self.subHandlers.has_key(tt):
            h = self.subHandlers[tt]
            return (tt, topicUri[i:], h[0], h[1], h[2])
      return None


   def registerForPubSub(self, topicUri, prefixMatch = False, pubsub = PUBLISH | SUBSCRIBE):
      """
      Register a topic URI as publish/subscribe channel in this session.

      :param topicUri: Topic URI to be established as publish/subscribe channel.
      :type topicUri: str
      :param prefixMatch: Allow to match this topic URI by prefix.
      :type prefixMatch: bool
      :param pubsub: Allow publication and/or subscription.
      :type pubsub: WampServerProtocol.PUB, WampServerProtocol.SUB, WampServerProtocol.PUB | WampServerProtocol.SUB
      """
      if pubsub & WampServerProtocol.PUBLISH:
         self.pubHandlers[topicUri] = (None, None, prefixMatch)
         if self.debugWamp:
            log.msg("registered topic %s for publication (match by prefix = %s)" % (topicUri, prefixMatch))
      if pubsub & WampServerProtocol.SUBSCRIBE:
         self.subHandlers[topicUri] = (None, None, prefixMatch)
         if self.debugWamp:
            log.msg("registered topic %s for subscription (match by prefix = %s)" % (topicUri, prefixMatch))


   def registerHandlerForPubSub(self, obj, baseUri = ""):
      """
      Register a handler object for PubSub. A handler object has methods
      which are decorated using @exportPub and @exportSub.

      :param obj: The object to be registered (in this WebSockets session) for PubSub.
      :type obj: Object with methods decorated using @exportPub and @exportSub.
      :param baseUri: Optional base URI which is prepended to topic names for export.
      :type baseUri: String.
      """
      for k in inspect.getmembers(obj.__class__, inspect.ismethod):
         if k[1].__dict__.has_key("_autobahn_pub_id"):
            uri = baseUri + k[1].__dict__["_autobahn_pub_id"]
            prefixMatch = k[1].__dict__["_autobahn_pub_prefix_match"]
            proc = k[1]
            self.registerHandlerForPub(uri, obj, proc, prefixMatch)
         elif k[1].__dict__.has_key("_autobahn_sub_id"):
            uri = baseUri + k[1].__dict__["_autobahn_sub_id"]
            prefixMatch = k[1].__dict__["_autobahn_sub_prefix_match"]
            proc = k[1]
            self.registerHandlerForSub(uri, obj, proc, prefixMatch)


   def registerHandlerForSub(self, uri, obj, proc, prefixMatch = False):
      """
      Register a method of an object as subscription handler.

      :param uri: Topic URI to register subscription handler for.
      :type uri: str
      :param obj: The object on which to register a method as subscription handler.
      :type obj: object
      :param proc: Unbound object method to register as subscription handler.
      :type proc: unbound method
      :param prefixMatch: Allow to match this topic URI by prefix.
      :type prefixMatch: bool
      """
      self.subHandlers[uri] = (obj, proc, prefixMatch)
      if not self.pubHandlers.has_key(uri):
         self.pubHandlers[uri] = (None, None, False)
      if self.debugWamp:
         log.msg("registered subscription handler for topic %s" % uri)


   def registerHandlerForPub(self, uri, obj, proc, prefixMatch = False):
      """
      Register a method of an object as publication handler.

      :param uri: Topic URI to register publication handler for.
      :type uri: str
      :param obj: The object on which to register a method as publication handler.
      :type obj: object
      :param proc: Unbound object method to register as publication handler.
      :type proc: unbound method
      :param prefixMatch: Allow to match this topic URI by prefix.
      :type prefixMatch: bool
      """
      self.pubHandlers[uri] = (obj, proc, prefixMatch)
      if not self.subHandlers.has_key(uri):
         self.subHandlers[uri] = (None, None, False)
      if self.debugWamp:
         log.msg("registered publication handler for topic %s" % uri)


   def dispatch(self, topicUri, event, exclude = [], eligible = None):
      """
      Dispatch an event for a topic to all clients subscribed to
      and authorized for that topic.

      Optionally, exclude list of clients and/or only consider clients
      from explicit eligibles. In other words, the event is delivered
      to the set

         (subscribers - excluded) & eligible

      :param topicUri: URI of topic to publish event to.
      :type topicUri: str
      :param event: Event to dispatch.
      :type event: obj
      :param exclude: Optional list of clients (WampServerProtocol instances) to exclude.
      :type exclude: list of obj
      :param eligible: Optional list of clients (WampServerProtocol instances) eligible at all (or None for all).
      :type eligible: list of obj

      :returns twisted.internet.defer.Deferred -- Will be fired when event was
      dispatched to all subscribers. The return value provided to the deferred
      is a pair (delivered, requested), where delivered = number of actual
      receivers, and requested = number of (subscribers - excluded) & eligible.
      """
      return self.factory.dispatch(topicUri, event, exclude, eligible)


   def onMessage(self, msg, binary):
      """
      Handle WAMP messages received from WAMP client.
      """

      if self.debugWamp:
         log.msg("RX WAMP: %s" % str(msg))

      if not binary:
         try:
            obj = self.factory._unserialize(msg)
            if type(obj) == list:

               msgtype = obj[0]

               ### XXX Replace check by try...except when all handlers
               ### XXX are in place. Exception handling should create
               ### XXX a protocolError message about unsupported
               ### XXX message type
               if msgtype in [WampProtocol.MESSAGE_TYPEID_CALL,
                              WampProtocol.MESSAGE_TYPEID_CALL_RESULT,
                              WampProtocol.MESSAGE_TYPEID_CALL_ERROR]:
                  self.handlerMapping[msgtype].handleMessage(obj)

               ### XXX Move remaining code to appropriate handlers

               ## Subscribe Message
               ##
               elif msgtype == WampProtocol.MESSAGE_TYPEID_SUBSCRIBE:
                  topicUri = self.prefixes.resolveOrPass(obj[1]) ### PFX - remove
                  h = self._getSubHandler(topicUri)
                  if h:
                     ## either exact match or prefix match allowed
                     if h[1] == "" or h[4]:

                        ## direct topic
                        if h[2] is None and h[3] is None:
                           self.factory._subscribeClient(self, topicUri)

                        ## topic handled by subscription handler
                        else:
                           ## handler is object method
                           if h[2]:
                              a = maybeDeferred(h[3], h[2], str(h[0]), str(h[1]))

                           ## handler is free standing procedure
                           else:
                              a = maybeDeferred(h[3], str(h[0]), str(h[1]))

                           def fail(failure):
                              if self.debugWamp:
                                 log.msg("exception during custom subscription handler: %s" % failure)

                           def done(result):
                              ## only subscribe client if handler did return True
                              if result:
                                 self.factory._subscribeClient(self, topicUri)

                           a.addCallback(done).addErrback(fail)
                     else:
                        if self.debugWamp:
                           log.msg("topic %s matches only by prefix and prefix match disallowed" % topicUri)
                  else:
                     if self.debugWamp:
                        log.msg("no topic / subscription handler registered for %s" % topicUri)

               ## Unsubscribe Message
               ##
               elif msgtype == WampProtocol.MESSAGE_TYPEID_UNSUBSCRIBE:
                  topicUri = self.prefixes.resolveOrPass(obj[1]) ### PFX - remove
                  self.factory._unsubscribeClient(self, topicUri)

               ## Publish Message
               ##
               elif msgtype == WampProtocol.MESSAGE_TYPEID_PUBLISH:
                  topicUri = self.prefixes.resolveOrPass(obj[1]) ### PFX - remove
                  h = self._getPubHandler(topicUri)
                  if h:
                     ## either exact match or prefix match allowed
                     if h[1] == "" or h[4]:

                        ## Event
                        ##
                        event = obj[2]

                        ## Exclude Sessions List
                        ##
                        exclude = [self] # exclude publisher by default
                        if len(obj) >= 4:
                           if type(obj[3]) == bool:
                              if not obj[3]:
                                 exclude = []
                           elif type(obj[3]) == list:
                              ## map session IDs to protos
                              exclude = self.factory.sessionIdsToProtos(obj[3])
                           else:
                              ## FIXME: invalid type
                              pass

                        ## Eligible Sessions List
                        ##
                        eligible = None # all sessions are eligible by default
                        if len(obj) >= 5:
                           if type(obj[4]) == list:
                              ## map session IDs to protos
                              eligible = self.factory.sessionIdsToProtos(obj[4])
                           else:
                              ## FIXME: invalid type
                              pass

                        ## direct topic
                        if h[2] is None and h[3] is None:
                           self.factory.dispatch(topicUri, event, exclude, eligible)

                        ## topic handled by publication handler
                        else:
                           ## handler is object method
                           if h[2]:
                              e = maybeDeferred(h[3], h[2], str(h[0]), str(h[1]), event)

                           ## handler is free standing procedure
                           else:
                              e = maybeDeferred(h[3], str(h[0]), str(h[1]), event)

                           def fail(failure):
                              if self.debugWamp:
                                 log.msg("exception during custom publication handler: %s" % failure)

                           def done(result):
                              ## only dispatch event if handler did return event
                              if result:
                                 self.factory.dispatch(topicUri, result, exclude, eligible)

                           e.addCallback(done).addErrback(fail)
                     else:
                        if self.debugWamp:
                           log.msg("topic %s matches only by prefix and prefix match disallowed" % topicUri)
                  else:
                     if self.debugWamp:
                        log.msg("no topic / publication handler registered for %s" % topicUri)

               ## Define prefix to be used in CURIEs
               ##
               elif msgtype == WampProtocol.MESSAGE_TYPEID_PREFIX:
                  prefix = obj[1]
                  uri = obj[2]
                  self.prefixes.set(prefix, uri) ### PFX - remove whole block (this msg type won't survive)

               else:
                  log.msg("unknown message type")
            else:
               log.msg("msg not a list")
         except Exception as e:
            traceback.print_exc()
      else:
         log.msg("binary message")



class WampServerFactory(WebSocketServerFactory, WampFactory):
   """
   Server factory for Wamp RPC/PubSub.
   """

   protocol = WampServerProtocol
   """
   Twisted protocol used by default for WAMP servers.
   """

   def __init__(self,
                url,
                debug = False,
                debugCodePaths = False,
                debugWamp = False,
                debugApp = False,
                externalPort = None,
                reactor = None):
      self.debugWamp = debugWamp
      self.debugApp = debugApp
      WebSocketServerFactory.__init__(self,
                                      url,
                                      protocols = ["wamp"],
                                      debug = debug,
                                      debugCodePaths = debugCodePaths,
                                      externalPort = externalPort,
                                      reactor = reactor)
      WampFactory.__init__(self)


   def onClientSubscribed(self, proto, topicUri):
      """
      Callback fired when peer was (successfully) subscribed on some topic.

      :param proto: Peer protocol instance subscribed.
      :type proto: Instance of WampServerProtocol.
      :param topicUri: Fully qualified, resolved URI of topic subscribed.
      :type topicUri: str
      """
      pass


   def _subscribeClient(self, proto, topicUri):
      """
      Called from proto to subscribe client for topic.
      """
      if not self.subscriptions.has_key(topicUri):
         self.subscriptions[topicUri] = set()
         if self.debugWamp:
            log.msg("subscriptions map created for topic %s" % topicUri)
      if not proto in self.subscriptions[topicUri]:
         self.subscriptions[topicUri].add(proto)
         if self.debugWamp:
            log.msg("subscribed peer %s on topic %s" % (proto.peer, topicUri))
         self.onClientSubscribed(proto, topicUri)
      else:
         if self.debugWamp:
            log.msg("peer %s already subscribed on topic %s" % (proto.peer, topicUri))


   def onClientUnsubscribed(self, proto, topicUri):
      """
      Callback fired when peer was (successfully) unsubscribed from some topic.

      :param proto: Peer protocol instance unsubscribed.
      :type proto: Instance of WampServerProtocol.
      :param topicUri: Fully qualified, resolved URI of topic unsubscribed.
      :type topicUri: str
      """
      pass


   def _unsubscribeClient(self, proto, topicUri = None):
      """
      Called from proto to unsubscribe client from topic.
      """
      if topicUri:
         if self.subscriptions.has_key(topicUri) and proto in self.subscriptions[topicUri]:
            self.subscriptions[topicUri].discard(proto)
            if self.debugWamp:
               log.msg("unsubscribed peer %s from topic %s" % (proto.peer, topicUri))
            if len(self.subscriptions[topicUri]) == 0:
               del self.subscriptions[topicUri]
               if self.debugWamp:
                  log.msg("topic %s removed from subscriptions map - no one subscribed anymore" % topicUri)
            self.onClientUnsubscribed(proto, topicUri)
         else:
            if self.debugWamp:
               log.msg("peer %s not subscribed on topic %s" % (proto.peer, topicUri))
      else:
         for topicUri, subscribers in self.subscriptions.items():
            if proto in subscribers:
               subscribers.discard(proto)
               if self.debugWamp:
                  log.msg("unsubscribed peer %s from topic %s" % (proto.peer, topicUri))
               if len(subscribers) == 0:
                  del self.subscriptions[topicUri]
                  if self.debugWamp:
                     log.msg("topic %s removed from subscriptions map - no one subscribed anymore" % topicUri)
               self.onClientUnsubscribed(proto, topicUri)
         if self.debugWamp:
            log.msg("unsubscribed peer %s from all topics" % (proto.peer))


   def dispatch(self, topicUri, event, exclude = [], eligible = None):
      """
      Dispatch an event to all peers subscribed to the event topic.

      :param topicUri: Topic to publish event to.
      :type topicUri: str
      :param event: Event to publish (must be JSON serializable).
      :type event: obj
      :param exclude: List of WampServerProtocol instances to exclude from receivers.
      :type exclude: List of obj
      :param eligible: List of WampServerProtocol instances eligible as receivers (or None for all).
      :type eligible: List of obj

      :returns twisted.internet.defer.Deferred -- Will be fired when event was
      dispatched to all subscribers. The return value provided to the deferred
      is a pair (delivered, requested), where delivered = number of actual
      receivers, and requested = number of (subscribers - excluded) & eligible.
      """
      if self.debugWamp:
         log.msg("publish event %s for topicUri %s" % (str(event), topicUri))

      d = Deferred()

      if self.subscriptions.has_key(topicUri) and len(self.subscriptions[topicUri]) > 0:

         ## FIXME: this might break ordering of event delivery from a
         ## receiver perspective. We might need to have send queues
         ## per receiver OR do recvs = deque(sorted(..))

         ## However, see http://twistedmatrix.com/trac/ticket/1396

         if eligible is not None:
            subscrbs = set(eligible) & self.subscriptions[topicUri]
         else:
            subscrbs = self.subscriptions[topicUri]

         if len(exclude) > 0:
            recvs = subscrbs - set(exclude)
         else:
            recvs = subscrbs

         l = len(recvs)
         if l > 0:

            ## ok, at least 1 subscriber not excluded and eligible
            ## => prepare message for mass sending
            ##
            o = [WampProtocol.MESSAGE_TYPEID_EVENT, topicUri, event]
            try:
               msg = self._serialize(o)
               if self.debugWamp:
                  log.msg("serialized event msg: " + str(msg))
            except Exception as e:
               raise Exception("invalid type for event - serialization failed [%s]" % e)

            preparedMsg = self.prepareMessage(msg)

            ## chunked sending of prepared message
            ##
            self._sendEvents(preparedMsg, recvs.copy(), 0, l, d)

         else:
            ## receivers list empty after considering exlude and eligible sessions
            ##
            d.callback((0, 0))
      else:
         ## no one subscribed on topic
         ##
         d.callback((0, 0))

      return d


   def _sendEvents(self, preparedMsg, recvs, delivered, requested, d):
      """
      Delivers events to receivers in chunks and reenters the reactor
      in-between, so that other stuff can run.
      """
      ## deliver a batch of events
      done = False
      for i in xrange(0, 256):
         try:
            proto = recvs.pop()
            if proto.state == WebSocketProtocol.STATE_OPEN:
               try:
                  proto.sendPreparedMessage(preparedMsg)
               except:
                  pass
               else:
                  if self.debugWamp:
                     log.msg("delivered event to peer %s" % proto.peer)
                  delivered += 1
         except KeyError:
            # all receivers done
            done = True
            break

      if not done:
         ## if there are receivers left, redo
         self.reactor.callLater(0, self._sendEvents, preparedMsg, recvs, delivered, requested, d)
      else:
         ## else fire final result
         d.callback((delivered, requested))


   def _addSession(self, proto, session_id):
      """
      Add proto for session ID.
      """
      if not self.protoToSessions.has_key(proto):
         self.protoToSessions[proto] = session_id
      else:
         raise Exception("logic error - dublicate _addSession for protoToSessions")
      if not self.sessionsToProto.has_key(session_id):
         self.sessionsToProto[session_id] = proto
      else:
         raise Exception("logic error - dublicate _addSession for sessionsToProto")


   def _removeSession(self, proto):
      """
      Remove session by proto.
      """
      if self.protoToSessions.has_key(proto):
         session_id = self.protoToSessions[proto]
         del self.protoToSessions[proto]
         if self.sessionsToProto.has_key(session_id):
            del self.sessionsToProto[session_id]


   def sessionIdToProto(self, sessionId):
      """
      Map WAMP session ID to connected protocol instance (object of type WampServerProtocol).

      :param sessionId: WAMP session ID to be mapped.
      :type sessionId: str

      :returns obj -- WampServerProtocol instance or None.
      """
      return self.sessionsToProto.get(sessionId, None)


   def sessionIdsToProtos(self, sessionIds):
      """
      Map WAMP session IDs to connected protocol instances (objects of type WampServerProtocol).

      :param sessionIds: List of session IDs to be mapped.
      :type sessionIds: list of str

      :returns list -- List of WampServerProtocol instances corresponding to the WAMP session IDs.
      """
      protos = []
      for s in sessionIds:
         if self.sessionsToProto.has_key(s):
            protos.append(self.sessionsToProto[s])
      return protos


   def protoToSessionId(self, proto):
      """
      Map connected protocol instance (object of type WampServerProtocol) to WAMP session ID.

      :param proto: Instance of WampServerProtocol to be mapped.
      :type proto: obj of WampServerProtocol

      :returns str -- WAMP session ID or None.
      """
      return self.protoToSessions.get(proto, None)


   def protosToSessionIds(self, protos):
      """
      Map connected protocol instances (objects of type WampServerProtocol) to WAMP session IDs.

      :param protos: List of instances of WampServerProtocol to be mapped.
      :type protos: list of WampServerProtocol

      :returns list -- List of WAMP session IDs corresponding to the protos.
      """
      sessionIds = []
      for p in protos:
         if self.protoToSessions.has_key(p):
            sessionIds.append(self.protoToSessions[p])
      return sessionIds


   def startFactory(self):
      """
      Called by Twisted when the factory starts up. When overriding, make
      sure to call the base method.
      """
      if self.debugWamp:
         log.msg("WampServerFactory starting")
      self.subscriptions = {}
      self.protoToSessions = {}
      self.sessionsToProto = {}


   def stopFactory(self):
      """
      Called by Twisted when the factory shuts down. When overriding, make
      sure to call the base method.
      """
      if self.debugWamp:
         log.msg("WampServerFactory stopped")



class WampClientProtocol(WebSocketClientProtocol, WampProtocol):
   """
   Twisted client protocol for WAMP.
   """

   def onSessionOpen(self):
      """
      Callback fired when WAMP session was fully established. Override
      in derived class.
      """
      pass


   def onOpen(self):
      ## do nothing here .. onSessionOpen is only fired when welcome
      ## message was received (and thus session ID set)
      pass


   def onConnect(self, connectionResponse):
      if connectionResponse.protocol not in self.factory.protocols:
         raise Exception("server does not speak WAMP")


   def connectionMade(self):
      WebSocketClientProtocol.connectionMade(self)
      WampProtocol.connectionMade(self)

      self.subscriptions = {}

      self.handlerMapping = {
         self.MESSAGE_TYPEID_CALL: CallHandler(self, self.prefixes),
         self.MESSAGE_TYPEID_CALL_RESULT: CallResultHandler(self, self.prefixes),
         self.MESSAGE_TYPEID_CALL_ERROR: CallErrorHandler(self, self.prefixes)}


   def connectionLost(self, reason):
      WampProtocol.connectionLost(self, reason)
      WebSocketClientProtocol.connectionLost(self, reason)


   def sendMessage(self, payload):
      if self.debugWamp:
         log.msg("TX WAMP: %s" % str(payload))
      WebSocketClientProtocol.sendMessage(self, payload)


   def onMessage(self, msg, binary):
      """Internal method to handle WAMP messages received from WAMP server."""

      ## WAMP is text message only
      ##
      if binary:
         self._protocolError("binary WebSocket message received")
         return

      if self.debugWamp:
         log.msg("RX WAMP: %s" % str(msg))

      ## WAMP is proper JSON payload
      ##
      try:
         obj = self.factory._unserialize(msg)
      except Exception as e:
         self._protocolError("WAMP message payload could not be unserialized [%s]" % e)
         return

      ## Every WAMP message is a list
      ##
      if type(obj) != list:
         self._protocolError("WAMP message payload not a list")
         return

      ## Every WAMP message starts with an integer for message type
      ##
      if len(obj) < 1:
         self._protocolError("WAMP message without message type")
         return
      if type(obj[0]) != int:
         self._protocolError("WAMP message type not an integer")
         return

      ## WAMP message type
      ##
      msgtype = obj[0]

      ## Valid WAMP message types received by WAMP clients
      ##
      if msgtype not in [WampProtocol.MESSAGE_TYPEID_WELCOME,
                         WampProtocol.MESSAGE_TYPEID_CALL,
                         WampProtocol.MESSAGE_TYPEID_CALL_RESULT,
                         WampProtocol.MESSAGE_TYPEID_CALL_ERROR,
                         WampProtocol.MESSAGE_TYPEID_EVENT]:
         self._protocolError("invalid WAMP message type %d" % msgtype)
         return

      if msgtype in [WampProtocol.MESSAGE_TYPEID_CALL,
                     WampProtocol.MESSAGE_TYPEID_CALL_RESULT,
                     WampProtocol.MESSAGE_TYPEID_CALL_ERROR]:
         self.handlerMapping[msgtype].handleMessage(obj)

      ## WAMP EVENT
      ##
      elif msgtype == WampProtocol.MESSAGE_TYPEID_EVENT:
         ## Topic
         ##
         if len(obj) != 3:
            self._protocolError("WAMP EVENT message invalid length %d" % len(obj))
            return
         if type(obj[1]) not in [unicode, str]:
            self._protocolError("invalid type for <topic> in WAMP EVENT message")
            return
         unresolvedTopicUri = str(obj[1])
         topicUri = self.prefixes.resolveOrPass(unresolvedTopicUri) ### PFX - remove

         ## Fire PubSub Handler
         ##
         if self.subscriptions.has_key(topicUri):
            event = obj[2]
            self.subscriptions[topicUri](topicUri, event)
         else:
            ## event received for non-subscribed topic (could be because we
            ## just unsubscribed, and server already sent out event for
            ## previous subscription)
            pass

      ## WAMP WELCOME
      ##
      elif msgtype == WampProtocol.MESSAGE_TYPEID_WELCOME:
         ## Session ID
         ##
         if len(obj) < 2:
            self._protocolError("WAMP WELCOME message invalid length %d" % len(obj))
            return
         if type(obj[1]) not in [unicode, str]:
            self._protocolError("invalid type for <sessionid> in WAMP WELCOME message")
            return
         self.session_id = str(obj[1])

         ## WAMP Protocol Version
         ##
         if len(obj) > 2:
            if type(obj[2]) not in [int]:
               self._protocolError("invalid type for <version> in WAMP WELCOME message")
               return
            else:
               self.session_protocol_version = obj[2]
         else:
            self.session_protocol_version = None

         ## Server Ident
         ##
         if len(obj) > 3:
            if type(obj[3]) not in [unicode, str]:
               self._protocolError("invalid type for <server> in WAMP WELCOME message")
               return
            else:
               self.session_server = obj[3]
         else:
            self.session_server = None

         self.onSessionOpen()

      else:
         raise Exception("logic error")


   def prefix(self, prefix, uri):
      """
      Establishes a prefix to be used in `CURIEs <http://en.wikipedia.org/wiki/CURIE>`_
      instead of URIs having that prefix for both client-to-server and
      server-to-client messages.

      :param prefix: Prefix to be used in CURIEs.
      :type prefix: str
      :param uri: URI that this prefix will resolve to.
      :type uri: str
      """

      if type(prefix) != str:
         raise Exception("invalid type for prefix")

      if type(uri) not in [unicode, str]:
         raise Exception("invalid type for URI")

      if self.prefixes.get(prefix):  ### PFX - keep
         raise Exception("prefix already defined")

      self.prefixes.set(prefix, uri) ### PFX - keep

      msg = [WampProtocol.MESSAGE_TYPEID_PREFIX, prefix, uri]

      self.sendMessage(self.factory._serialize(msg))


   def publish(self, topicUri, event, excludeMe = None, exclude = None, eligible = None):
      """
      Publish an event under a topic URI. The latter may be abbreviated using a
      CURIE which has been previously defined using prefix(). The event must
      be JSON serializable.

      :param topicUri: The topic URI or CURIE.
      :type topicUri: str
      :param event: Event to be published (must be JSON serializable) or None.
      :type event: value
      :param excludeMe: When True, don't deliver the published event to myself (when I'm subscribed).
      :type excludeMe: bool
      :param exclude: Optional list of session IDs to exclude from receivers.
      :type exclude: list of str
      :param eligible: Optional list of session IDs to that are eligible as receivers.
      :type eligible: list of str
      """

      if type(topicUri) not in [unicode, str]:
         raise Exception("invalid type for parameter 'topicUri' - must be string (was %s)" % type(topicUri))

      if excludeMe is not None:
         if type(excludeMe) != bool:
            raise Exception("invalid type for parameter 'excludeMe' - must be bool (was %s)" % type(excludeMe))

      if exclude is not None:
         if type(exclude) != list:
            raise Exception("invalid type for parameter 'exclude' - must be list (was %s)" % type(exclude))

      if eligible is not None:
         if type(eligible) != list:
            raise Exception("invalid type for parameter 'eligible' - must be list (was %s)" % type(eligible))

      if exclude is not None or eligible is not None:
         if exclude is None:
            if excludeMe is not None:
               if excludeMe:
                  exclude = [self.session_id]
               else:
                  exclude = []
            else:
               exclude = [self.session_id]
         if eligible is not None:
            msg = [WampProtocol.MESSAGE_TYPEID_PUBLISH, topicUri, event, exclude, eligible]
         else:
            msg = [WampProtocol.MESSAGE_TYPEID_PUBLISH, topicUri, event, exclude]
      else:
         if excludeMe:
            msg = [WampProtocol.MESSAGE_TYPEID_PUBLISH, topicUri, event]
         else:
            msg = [WampProtocol.MESSAGE_TYPEID_PUBLISH, topicUri, event, excludeMe]

      try:
         o = self.factory._serialize(msg)
      except:
         raise Exception("invalid type for parameter 'event' - not JSON serializable")

      self.sendMessage(o)


   def subscribe(self, topicUri, handler):
      """
      Subscribe to topic. When already subscribed, will overwrite the handler.

      :param topicUri: URI or CURIE of topic to subscribe to.
      :type topicUri: str
      :param handler: Event handler to be invoked upon receiving events for topic.
      :type handler: Python callable, will be called as in <callable>(eventUri, event).
      """
      if type(topicUri) not in [unicode, str]:
         raise Exception("invalid type for parameter 'topicUri' - must be string (was %s)" % type(topicUri))

      if not hasattr(handler, '__call__'):
         raise Exception("invalid type for parameter 'handler' - must be a callable (was %s)" % type(handler))

      turi = self.prefixes.resolveOrPass(topicUri) ### PFX - keep
      if not self.subscriptions.has_key(turi):
         msg = [WampProtocol.MESSAGE_TYPEID_SUBSCRIBE, topicUri]
         o = self.factory._serialize(msg)
         self.sendMessage(o)
      self.subscriptions[turi] = handler


   def unsubscribe(self, topicUri):
      """
      Unsubscribe from topic. Will do nothing when currently not subscribed to the topic.

      :param topicUri: URI or CURIE of topic to unsubscribe from.
      :type topicUri: str
      """
      if type(topicUri) not in [unicode, str]:
         raise Exception("invalid type for parameter 'topicUri' - must be string (was %s)" % type(topicUri))

      turi = self.prefixes.resolveOrPass(topicUri) ### PFX - keep
      if self.subscriptions.has_key(turi):
         msg = [WampProtocol.MESSAGE_TYPEID_UNSUBSCRIBE, topicUri]
         o = self.factory._serialize(msg)
         self.sendMessage(o)
         del self.subscriptions[turi]



class WampClientFactory(WebSocketClientFactory, WampFactory):
   """
   Twisted client factory for WAMP.
   """

   protocol = WampClientProtocol

   def __init__(self,
                url,
                debug = False,
                debugCodePaths = False,
                debugWamp = False,
                debugApp = False,
                reactor = None):
      self.debugWamp = debugWamp
      self.debugApp = debugApp
      WebSocketClientFactory.__init__(self,
                                      url,
                                      protocols = ["wamp"],
                                      debug = debug,
                                      debugCodePaths = debugCodePaths,
                                      reactor = reactor)
      WampFactory.__init__(self)


   def startFactory(self):
      """
      Called by Twisted when the factory starts up. When overriding, make
      sure to call the base method.
      """
      if self.debugWamp:
         log.msg("WebSocketClientFactory starting")


   def stopFactory(self):
      """
      Called by Twisted when the factory shuts down. When overriding, make
      sure to call the base method.
      """
      if self.debugWamp:
         log.msg("WebSocketClientFactory stopped")



class WampCraProtocol(WampProtocol):
   """
   Base class for WAMP Challenge-Response Authentication protocols (client and server).

   WAMP-CRA is a cryptographically strong challenge response authentication
   protocol based on HMAC-SHA256.

   The protocol performs in-band authentication of WAMP clients to WAMP servers.

   WAMP-CRA does not introduce any new WAMP protocol level message types, but
   implements the authentication handshake via standard WAMP RPCs with well-known
   procedure URIs and signatures.
   """

   def deriveKey(secret, extra = None):
      """
      Computes a derived cryptographic key from a password according to PBKDF2
      http://en.wikipedia.org/wiki/PBKDF2.

      The function will only return a derived key if at least 'salt' is
      present in the 'extra' dictionary. The complete set of attributes
      that can be set in 'extra':

         salt: The salt value to be used.
         iterations: Number of iterations of derivation algorithm to run.
         keylen: Key length to derive.

      :returns str -- The derived key or the original secret.
      """
      if type(extra) == dict and extra.has_key('salt'):
         salt = str(extra['salt'])
         iterations = int(extra.get('iterations', 10000))
         keylen = int(extra.get('keylen', 32))
         b = pbkdf2_bin(secret, salt, iterations, keylen, hashlib.sha256)
         return binascii.b2a_base64(b).strip()
      else:
         return secret

   deriveKey = staticmethod(deriveKey)


   def authSignature(self, authChallenge, authSecret = None, authExtra = None):
      """
      Compute the authentication signature from an authentication challenge and a secret.

      :param authChallenge: The authentication challenge.
      :type authChallenge: str
      :param authSecret: The authentication secret.
      :type authSecret: str
      :authExtra: Extra authentication information for salting the secret. (salt, keylen,
              iterations)
      :type authExtra: dict

      :returns str -- The authentication signature.
      """
      if authSecret is None:
         authSecret = ""
      if isinstance(authSecret, unicode):
         authSecret = authSecret.encode('utf8')
      authSecret = WampCraProtocol.deriveKey(authSecret, authExtra)
      h = hmac.new(authSecret, authChallenge, hashlib.sha256)
      sig = binascii.b2a_base64(h.digest()).strip()
      return sig



class WampCraClientProtocol(WampClientProtocol, WampCraProtocol):
   """
   Simple, authenticated WAMP client protocol.

   The client can perform WAMP-Challenge-Response-Authentication ("WAMP-CRA") to authenticate
   itself to a WAMP server. The server needs to implement WAMP-CRA also of course.
   """

   def authenticate(self, authKey = None, authExtra = None, authSecret = None):
      """
      Authenticate the WAMP session to server.

      :param authKey: The key of the authentication credentials, something like a user or application name.
      :type authKey: str
      :param authExtra: Any extra authentication information.
      :type authExtra: dict
      :param authSecret: The secret of the authentication credentials, something like the user password or application secret key.
      :type authsecret: str

      :returns Deferred -- Deferred that fires upon authentication success (with permissions) or failure.
      """

      def _onAuthChallenge(challenge):
         if authKey is not None:
            challengeObj =  self.factory._unserialize(challenge)
            if 'authextra' in challengeObj:
                authExtra = challengeObj['authextra']
                sig = self.authSignature(challenge, authSecret, authExtra)
            else:
                sig = self.authSignature(challenge, authSecret)
         else:
            sig = None
         d = self.call(WampProtocol.URI_WAMP_PROCEDURE + "auth", sig)
         return d

      d = self.call(WampProtocol.URI_WAMP_PROCEDURE + "authreq", authKey, authExtra)
      d.addCallback(_onAuthChallenge)
      return d



class WampCraServerProtocol(WampServerProtocol, WampCraProtocol):
   """
   Simple, authenticating WAMP server protocol.

   The server lets clients perform WAMP-Challenge-Response-Authentication ("WAMP-CRA")
   to authenticate. The clients need to implement WAMP-CRA also of course.

   To implement an authenticating server, override:

      * getAuthSecret
      * getAuthPermissions
      * onAuthenticated

   in your class deriving from this class.
   """

   clientAuthTimeout = 0
   """
   Client authentication timeout in seconds or 0 for infinite. A client
   must perform authentication after the initial WebSocket handshake within
   this timeout or the connection is failed.
   """

   clientAuthAllowAnonymous = True
   """
   Allow anonymous client authentication. When this is set to True, a client
   may "authenticate" as anonymous.
   """


   def getAuthPermissions(self, authKey, authExtra):
      """
      Get the permissions the session is granted when the authentication succeeds
      for the given key / extra information.

      Override in derived class to implement your authentication.

      A permissions object is structured like this::

         {'permissions': {'rpc': [
                                    {'uri':  / RPC Endpoint URI - String /,
                                     'call': / Allow to call? - Boolean /}
                                 ],
                          'pubsub': [
                                       {'uri':    / PubSub Topic URI / URI prefix - String /,
                                        'prefix': / URI matched by prefix? - Boolean /,
                                        'pub':    / Allow to publish? - Boolean /,
                                        'sub':    / Allow to subscribe? - Boolean /}
                                    ]
                          }
         }

      You can add custom information to this object. The object will be provided again
      when the client authentication succeeded in :meth:`onAuthenticated`.

      :param authKey: The authentication key.
      :type authKey: str
      :param authExtra: Authentication extra information.
      :type authExtra: dict

      :returns obj or Deferred -- Return a permissions object or None when no permissions granted.
      """
      return None


   def getAuthSecret(self, authKey):
      """
      Get the authentication secret for an authentication key, i.e. the
      user password for the user name. Return None when the authentication
      key does not exist.

      Override in derived class to implement your authentication.

      :param authKey: The authentication key.
      :type authKey: str

      :returns str or Deferred -- The authentication secret for the key or None when the key does not exist.
      """
      return None


   def onAuthTimeout(self):
      """
      Fired when the client does not authenticate itself in time. The default implementation
      will simply fail the connection.

      May be overridden in derived class.
      """
      if not self._clientAuthenticated:
         log.msg("failing connection upon client authentication timeout [%s secs]" % self.clientAuthTimeout)
         self.failConnection()


   def onAuthenticated(self, authKey, permissions):
      """
      Fired when client authentication was successful.

      Override in derived class and register PubSub topics and/or RPC endpoints.

      :param authKey: The authentication key the session was authenticated for.
      :type authKey: str
      :param permissions: The permissions object returned from :meth:`getAuthPermissions`.
      :type permissions: obj
      """
      pass


   def registerForPubSubFromPermissions(self, permissions):
      """
      Register topics for PubSub from auth permissions.

      :param permissions: The permissions granted to the now authenticated client.
      :type permissions: list
      """
      for p in permissions['pubsub']:
         ## register topics for the clients
         ##
         pubsub = (WampServerProtocol.PUBLISH if p['pub'] else 0) | \
                  (WampServerProtocol.SUBSCRIBE if p['sub'] else 0)
         topic = p['uri']
         if self.pubHandlers.has_key(topic) or self.subHandlers.has_key(topic):
            ## FIXME: handle dups!
            log.msg("DUPLICATE TOPIC PERMISSION !!! " + topic)
         self.registerForPubSub(topic, p['prefix'], pubsub)


   def onSessionOpen(self):
      """
      Called when WAMP session has been established, but not yet authenticated. The default
      implementation will prepare the session allowing the client to authenticate itself.
      """

      ## register RPC endpoints for WAMP-CRA authentication
      ##
      self.registerForRpc(self, WampProtocol.URI_WAMP_PROCEDURE, [WampCraServerProtocol.authRequest,
                                                                  WampCraServerProtocol.auth])

      ## reset authentication state
      ##
      self._clientAuthenticated = False
      self._clientPendingAuth = None
      self._clientAuthTimeoutCall = None

      ## client authentication timeout
      ##
      if self.clientAuthTimeout > 0:
         self._clientAuthTimeoutCall = self.factory.reactor.callLater(self.clientAuthTimeout, self.onAuthTimeout)


   @exportRpc("authreq")
   def authRequest(self, authKey = None, extra = None):
      """
      RPC endpoint for clients to initiate the authentication handshake.

      :param authKey: Authentication key, such as user name or application name.
      :type authKey: str
      :param extra: Authentication extra information.
      :type extra: dict

      :returns str -- Authentication challenge. The client will need to create an authentication signature from this.
      """

      ## check authentication state
      ##
      if self._clientAuthenticated:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "already-authenticated"), "already authenticated")
      if self._clientPendingAuth is not None:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "authentication-already-requested"), "authentication request already issues - authentication pending")

      ## check extra
      ##
      if extra:
         if type(extra) != dict:
            raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "invalid-argument"), "extra not a dictionary (was %s)." % str(type(extra)))
      else:
         extra = {}
      #for k in extra:
      #   if type(extra[k]) not in [str, unicode, int, long, float, bool, types.NoneType]:
      #      raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "invalid-argument"), "attribute '%s' in extra not a primitive type (was %s)" % (k, str(type(extra[k]))))

      ## check authKey
      ##
      if authKey is None and not self.clientAuthAllowAnonymous:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "anonymous-auth-forbidden"), "authentication as anonymous forbidden")

      if type(authKey) not in [str, unicode, types.NoneType]:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "invalid-argument"), "authentication key must be a string (was %s)" % str(type(authKey)))

      d = maybeDeferred(self.getAuthSecret, authKey)

      def onGetAuthSecretOk(authSecret, authKey, extra):
         if authKey is not None and authSecret is None:
            raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "no-such-authkey"), "authentication key '%s' does not exist." % authKey)

         ## each authentication request gets a unique authid, which can only be used (later) once!
         ##
         authid = newid()

         ## create authentication challenge
         ##
         info = {}
         info['authid'] = authid
         info['authkey'] = authKey
         info['timestamp'] = utcnow()
         info['sessionid'] = self.session_id
         info['extra'] = extra

         pp = maybeDeferred(self.getAuthPermissions, authKey, extra)

         def onAuthPermissionsOk(res):
            if res is None:
               res = {'permissions': {}}
               res['permissions'] = {'pubsub': [], 'rpc': []}
            info['permissions'] = res['permissions']
            if 'authextra' in res:
                info['authextra'] = res['authextra']

            if authKey:
               ## authenticated session
               ##
               infoser = self.factory._serialize(info)
               sig = self.authSignature(infoser, authSecret)

               self._clientPendingAuth = (info, sig, res)
               return infoser
            else:
               ## anonymous session
               ##
               self._clientPendingAuth = (info, None, res)
               return None

         def onAuthPermissionsError(e):
            raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "auth-permissions-error"), str(e))

         pp.addCallbacks(onAuthPermissionsOk, onAuthPermissionsError)

         return pp

      d.addCallback(onGetAuthSecretOk, authKey, extra)
      return d


   @exportRpc("auth")
   def auth(self, signature = None):
      """
      RPC endpoint for clients to actually authenticate after requesting authentication and computing
      a signature from the authentication challenge.

      :param signature: Authentication signature computed by the client.
      :type signature: str

      :returns list -- A list of permissions the client is granted when authentication was successful.
      """

      ## check authentication state
      ##
      if self._clientAuthenticated:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "already-authenticated"), "already authenticated")
      if self._clientPendingAuth is None:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "no-authentication-requested"), "no authentication previously requested")

      ## check signature
      ##
      if type(signature) not in [str, unicode, types.NoneType]:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "invalid-argument"), "signature must be a string or None (was %s)" % str(type(signature)))
      if self._clientPendingAuth[1] != signature:
         ## delete pending authentication, so that no retries are possible. authid is only valid for 1 try!!
         ##
         self._clientPendingAuth = None

         ## notify the client of failed authentication, but only after a random,
         ## exponentially distributed delay. this (further) protects against
         ## timing attacks
         ##
         d = Deferred()
         def fail():
            ## FIXME: (optionally) drop the connection instead of returning RPC error?
            ##
            d.errback(Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "invalid-signature"), "signature for authentication request is invalid"))
         failDelaySecs = random.expovariate(1.0 / 0.8) # mean = 0.8 secs
         self.factory.reactor.callLater(failDelaySecs, fail)
         return d

      ## at this point, the client has successfully authenticated!

      ## get the permissions we determined earlier
      ##
      perms = self._clientPendingAuth[2]

      ## delete auth request and mark client as authenticated
      ##
      authKey = self._clientPendingAuth[0]['authkey']
      self._clientAuthenticated = True
      self._clientPendingAuth = None
      if self._clientAuthTimeoutCall is not None:
         self._clientAuthTimeoutCall.cancel()
         self._clientAuthTimeoutCall = None

      ## fire authentication callback
      ##
      self.onAuthenticated(authKey, perms)

      ## return permissions to client
      ##
      return perms['permissions']



class Call:
   """
   Thin-wrapper for incoming RPCs provided to call handlers registered via

     - registerHandlerMethodForRpc
     - registerHandlerProcedureForRpc
   """


   def __init__(self,
             proto,
             callid,
             uri,
             args,
             extra = None):
      self.proto = proto
      self.callid = callid
      self.uri = uri
      self.args = args
      self.extra = extra
      self.timings = None



class Handler(object):
   """
   A handler for a certain class of messages.
   """


   typeid = None


   def __init__(self, proto, prefixes):
      """
      Remember protocol and prefix map in instance variables.
      """
      self.proto = proto
      self.prefixes = prefixes


   def handleMessage(self, msg_parts):
      """
      Template method for handling a message.

      Check if the correct handler for the message type was
      called. Afterwards, assign all relevant parts of the message to
      instance variables and call the (overridden) method
      _handleMessage to actually handle the message.
      """
      msgtype = msg_parts[0]
      if self.typeid:
         assert msgtype == self.typeid, \
             "Message type %s does not match type id %s" % (msgtype,
                                                            self.typeid)
      else:
         assert False, \
             "No typeid defined for %s" % self.__class__.__name__

      if self._messageIsValid(msg_parts):
         self._parseMessageParts(msg_parts)
         self._handleMessage()


   def _parseMessageParts(self, msg_parts):
      """
      Assign the message parts to instance variables.
      Has to be overridden in subclasses.
      """
      raise NotImplementedError

   def _messageIsValid(self, msg_parts):
      """
      Check if the message parts have expected properties (type, etc.).
      Has to be overridden in subclasses.
      """
      raise NotImplementedError


   def _handleMessage(self):
      """
      Handle a specific kind of message.
      Has to be overridden in subclasses.
      """
      raise NotImplementedError


   def maybeTrackTimings(self, call, msg):
      """
      Track timings, if desired.
      """
      if self.proto.trackTimings:
         self.proto.doTrack(msg)
         call.timings = self.proto.trackedTimings
         self.proto.trackedTimings = Timings()



class CallHandler(Handler):
   """
   A handler for incoming RPC calls.
   """

   typeid = WampProtocol.MESSAGE_TYPEID_CALL


   def _messageIsValid(self, msg_parts):
      callid, uri = msg_parts[1:3]
      if not isinstance(callid, (str, unicode)):
         self.proto._protocolError(
            ("WAMP CALL message with invalid type %s for "
            "<callid>") % type(callid))
         return False

      if not isinstance(uri, (str, unicode)):
         self.proto._protocolError(
            ("WAMP CALL message with invalid type %s for "
            "<uri>") % type(uri))
         return False

      return True


   def _parseMessageParts(self, msg_parts):
      """
      Parse message and create call object.
      """
      self.callid = msg_parts[1]
      self.uri = self.prefixes.resolveOrPass(msg_parts[2]) ### PFX - remove
      self.args = msg_parts[3:]


   def _handleMessage(self):
      """
      Perform the RPC call and attach callbacks to its deferred object.
      """
      call = self._onBeforeCall()

      ## execute incoming RPC
      d = maybeDeferred(self._callProcedure, call)

      ## register callback and errback with extra argument call
      d.addCallbacks(self._onAfterCallSuccess,
                     self._onAfterCallError,
                     callbackArgs = (call,),
                     errbackArgs = (call,))


   def _onBeforeCall(self):
      """
      Create call object to move around call data
      """
      uri, args = self.proto.onBeforeCall(self.callid, self.uri, self.args, bool(self.proto.procForUri(self.uri)))

      call = Call(self.proto, self.callid, uri, args)
      self.maybeTrackTimings(call, "onBeforeCall")
      return call


   def _callProcedure(self, call):
      """
      Actually performs the call of a procedure invoked via RPC.
      """
      m = self.proto.procForUri(call.uri)
      if m is None:
         raise Exception(WampProtocol.URI_WAMP_ERROR_NO_SUCH_RPC_ENDPOINT, "No RPC endpoint registered for %s." % call.uri)

      obj, method_or_proc, is_handler = m[:3]
      if not is_handler:
         return self._performProcedureCall(call, obj, method_or_proc)
      else:
         call.extra = m[3]
         return self._delegateToRpcHandler(call, obj, method_or_proc)


   def _performProcedureCall(self, call, obj, method_or_proc):
      """
      Perform a RPC method / procedure call.
      """
      cargs = tuple(call.args) if call.args else ()
      if obj:
         ## call object method
         return method_or_proc(obj, *cargs)
      else:
         ## call free-standing function/procedure
         return method_or_proc(*cargs)


   def _delegateToRpcHandler(self, call, obj, method_or_proc):
      """
      Delegate call to RPC handler.
      """
      if obj:
         ## call RPC handler on object
         return method_or_proc(obj, call)
      else:
         ## call free-standing RPC handler
         return method_or_proc(call)


   def _onAfterCallSuccess(self, result, call):
      """
      Execute custom success handler and send call result.
      """
      ## track timing and fire user callback
      self.maybeTrackTimings(call, "onAfterCallSuccess")
      call.result = self.proto.onAfterCallSuccess(result, call)

      ## send out WAMP message
      self._sendCallResult(call)


   def _onAfterCallError(self, error, call):
      """
      Execute custom error handler and send call error.
      """
      ## track timing and fire user callback
      self.maybeTrackTimings(call, "onAfterCallError")
      call.error = self.proto.onAfterCallError(error, call)

      ## send out WAMP message
      self._sendCallError(call)


   def _sendCallResult(self, call):
      """
      Marshal and send a RPC success result.
      """
      msg = [WampProtocol.MESSAGE_TYPEID_CALL_RESULT, call.callid, call.result]
      try:
         rmsg = self.proto.serializeMessage(msg)
      except:
         raise Exception("call result not JSON serializable")
      else:
         ## now actually send WAMP message
         self.proto.sendMessage(rmsg)

         ## track timing and fire user callback
         self.maybeTrackTimings(call, "onAfterSendCallSuccess")
         self.proto.onAfterSendCallSuccess(rmsg, call)


   def _sendCallError(self, call):
      """
      Marshal and send a RPC error result.
      """
      killsession = False
      rmsg = None
      try:
         error_info, killsession = self._extractErrorInfo(call)
         rmsg = self._assembleErrorMessage(call, *error_info)
      except Exception as e:
         rmsg = self._handleProcessingError(call, e)
      finally:
         if rmsg:
            ## now actually send WAMP message
            self.proto.sendMessage(rmsg)

            ## track timing and fire user callback
            self.maybeTrackTimings(call, "onAfterSendCallError")
            self.proto.onAfterSendCallError(rmsg, call)

            if killsession:
               self.proto.sendClose(3000, "killing WAMP session upon request by application exception")
         else:
            raise Exception("fatal: internal error in CallHandler._sendCallError")


   def _extractErrorInfo(self, call):
      """
      Extract error information from the call.
      """
      ## get error args and len
      ##
      eargs = call.error.value.args
      nargs = len(eargs)

      if nargs > 4:
         raise Exception("invalid args length %d for exception" % nargs)

      ## erroruri & errordesc
      ##
      if nargs == 0:
         erroruri = WampProtocol.URI_WAMP_ERROR_GENERIC
         errordesc = WampProtocol.DESC_WAMP_ERROR_GENERIC
      elif nargs == 1:
         erroruri = WampProtocol.URI_WAMP_ERROR_GENERIC
         errordesc = eargs[0]
      else:
         erroruri = eargs[0]
         errordesc = eargs[1]

      ## errordetails
      ##
      errordetails = None
      if nargs >= 3:
         errordetails = eargs[2]
      elif self.proto.includeTraceback:
         try:
            ## we'd like to do ..
            #tb = call.error.getTraceback()

            ## .. but the implementation in Twisted
            ## http://twistedmatrix.com/trac/browser/tags/releases/twisted-13.1.0/twisted/python/failure.py#L529
            ## uses cStringIO which cannot handle Unicode string in tracebacks. Hence we do our own:
            io = StringIO.StringIO()
            call.error.printTraceback(file = io)
            tb = io.getvalue()

         except Exception as ie:
            print("INTERNAL ERROR [_extractErrorInfo / getTraceback()]: %s" % ie)
            traceback.print_stack()
         else:
            errordetails = tb.splitlines()

      ## killsession
      ##
      killsession = False
      if nargs >= 4:
         killsession = eargs[3]

      ## recheck all error component types
      ##
      if type(erroruri) not in [str, unicode]:
         raise Exception("invalid type %s for errorUri" % type(erroruri))

      if type(errordesc) not in [str, unicode]:
         raise Exception("invalid type %s for errorDesc" % type(errordesc))

      ## errordetails must be JSON serializable. If not, we get exception later in sendMessage.
      ## We don't check here, since the only way would be to serialize to JSON and
      ## then we'd serialize twice (here and in sendMessage)

      if type(killsession) not in [bool, types.NoneType]:
         raise Exception("invalid type %s for killSession" % type(killsession))

      return (erroruri, errordesc, errordetails), killsession


   def _assembleErrorMessage(self, call, erroruri, errordesc, errordetails):
      """
      Assemble a WAMP RPC error message.
      """
      if errordetails is not None:
         msg = [WampProtocol.MESSAGE_TYPEID_CALL_ERROR,
                call.callid,
                self.prefixes.shrink(erroruri), ### PFX - remove
                errordesc,
                errordetails]
      else:
         msg = [WampProtocol.MESSAGE_TYPEID_CALL_ERROR,
                call.callid,
                self.prefixes.shrink(erroruri), ### PFX - remove
                errordesc]

      ## serialize message. this can fail if errorDetails is not
      ## serializable
      try:
         rmsg = self.proto.serializeMessage(msg)
      except Exception as e:
         raise Exception(
            "invalid object for errorDetails - not serializable (%s)" %
            str(e))

      return rmsg


   def _handleProcessingError(self, call, e):
      """
      Create a message describing what went wrong during processing an
      exception.
      """
      msg = [WampProtocol.MESSAGE_TYPEID_CALL_ERROR,
             call.callid,
              ### PFX - remove
             self.prefixes.shrink(WampProtocol.URI_WAMP_ERROR_INTERNAL),
             str(e)]

      if self.proto.includeTraceback:
         try:
            tb = call.error.getTraceback()
         except Exception as ie:
            ## FIXME: find out why this can fail with
            ## "'unicode' does not have the buffer interface"
            print("INTERNAL ERROR (getTraceback): %s" % ie)
         else:
            msg.append(tb.splitlines())

      result = self.proto.serializeMessage(msg)
      return result




class CallResultHandler(Handler):
   """
   A handler for to RPC call results.
   """

   typeid = WampProtocol.MESSAGE_TYPEID_CALL_RESULT


   def _messageIsValid(self, msg_parts):
      if len(msg_parts) < 2:
         self.proto._protocolError(
            "WAMP CALL_RESULT message without <callid>")
         return False
      if len(msg_parts) != 3:
         self.proto._protocolError(
            "WAMP CALL_RESULT message with invalid length %d" % len(msg_parts))
         return False

      if type(msg_parts[1]) not in [unicode, str]:
         self.proto._protocolError(
            ("WAMP CALL_RESULT message with invalid type %s for "
            "<callid>") % type(msg_parts[1]))
         return False

      return True


   def _parseMessageParts(self, msg_parts):
      """
      Extract call result from message parts.
      """
      self.callid = str(msg_parts[1])
      self.result = msg_parts[2]


   def _handleMessage(self):
      ## Pop and process Call Deferred
      ##
      d = self.proto.calls.pop(self.callid, None)
      if d:
         ## WAMP CALL_RESULT
         ##
         d.callback(self.result)
      else:
         if self.proto.debugWamp:
            log.msg("callid not found for received call result message")



class CallErrorHandler(Handler):

   typeid = WampProtocol.MESSAGE_TYPEID_CALL_ERROR


   def _messageIsValid(self, msg_parts):
      if len(msg_parts) not in [4, 5]:
         self.proto._protocolError(
            "call error message invalid length %d" % len(msg_parts))
         return False

      ## Error URI
      ##
      if type(msg_parts[2]) not in [unicode, str]:
         self.proto._protocolError(
            "invalid type %s for errorUri in call error message" %
            str(type(msg_parts[2])))
         return False

      ## Error Description
      ##
      if type(msg_parts[3]) not in [unicode, str]:
         self.proto._protocolError(
            "invalid type %s for errorDesc in call error message" %
            str(type(msg_parts[3])))
         return False

      return True


   def _parseMessageParts(self, msg_parts):
      """
      Extract error information from message parts.
      """
      self.callid = str(msg_parts[1])
      self.erroruri = str(msg_parts[2])
      self.errordesc = str(msg_parts[3])

      ## Error Details
      ##
      if len(msg_parts) > 4:
         self.errordetails = msg_parts[4]
      else:
         self.errordetails = None


   def _handleMessage(self):
      """
      Fire Call Error Deferred.
      """
      ##
      ## Pop and process Call Deferred
      d = self.proto.calls.pop(self.callid, None)
      if d:
         e = Exception()
         e.args = (self.erroruri, self.errordesc, self.errordetails)
         d.errback(e)
      else:
         if self.proto.debugWamp:
            log.msg("callid not found for received call error message")

########NEW FILE########
__FILENAME__ = compress
###############################################################################
##
##  Copyright 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import


__all__ = ["PerMessageCompressOffer",
           "PerMessageCompressOfferAccept",
           "PerMessageCompressResponse",
           "PerMessageCompressResponseAccept",
           "PerMessageCompress",

           "PerMessageDeflateOffer",
           "PerMessageDeflateOfferAccept",
           "PerMessageDeflateResponse",
           "PerMessageDeflateResponseAccept",
           "PerMessageDeflate",

           "PerMessageBzip2Offer",
           "PerMessageBzip2OfferAccept",
           "PerMessageBzip2Response",
           "PerMessageBzip2ResponseAccept",
           "PerMessageBzip2",

           "PERMESSAGE_COMPRESSION_EXTENSION"
           ]

from autobahn.websocket.compress_base import *
from autobahn.websocket.compress_deflate import *
from autobahn.websocket.compress_bzip2 import *


## class for "permessage-deflate" and "permessage-bzip2" are always available
##
PERMESSAGE_COMPRESSION_EXTENSION = {

   PerMessageDeflateMixin.EXTENSION_NAME: {
      'Offer': PerMessageDeflateOffer,
      'OfferAccept': PerMessageDeflateOfferAccept,
      'Response': PerMessageDeflateResponse,
      'ResponseAccept': PerMessageDeflateResponseAccept,
      'PMCE': PerMessageDeflate},

   PerMessageBzip2Mixin.EXTENSION_NAME: {
      'Offer': PerMessageBzip2Offer,
      'OfferAccept': PerMessageBzip2OfferAccept,
      'Response': PerMessageBzip2Response,
      'ResponseAccept': PerMessageBzip2ResponseAccept,
      'PMCE': PerMessageBzip2}
}


## include "permessage-snappy" classes if Snappy is available
##
try:
   import snappy
   from autobahn.websocket.compress_snappy import *
   PMCE = {
      'Offer': PerMessageSnappyOffer,
      'OfferAccept': PerMessageSnappyOfferAccept,
      'Response': PerMessageSnappyResponse,
      'ResponseAccept': PerMessageSnappyResponseAccept,
      'PMCE': PerMessageSnappy
   }
   PERMESSAGE_COMPRESSION_EXTENSION[PerMessageSnappyMixin.EXTENSION_NAME] = PMCE

   __all__.extend(["PerMessageSnappyOffer",
                   "PerMessageSnappyOfferAccept",
                   "PerMessageSnappyResponse",
                   "PerMessageSnappyResponseAccept",
                   "PerMessageSnappy"])

except ImportError:
   pass

########NEW FILE########
__FILENAME__ = compress_base
###############################################################################
##
##  Copyright 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ["PerMessageCompressOffer",
           "PerMessageCompressOfferAccept",
           "PerMessageCompressResponse",
           "PerMessageCompressResponseAccept",
           "PerMessageCompress"]


class PerMessageCompressOffer:
   """
   Base class for WebSocket compression parameter client offers.
   """
   pass



class PerMessageCompressOfferAccept:
   """
   Base class for WebSocket compression parameter client offer accepts by the server.
   """
   pass



class PerMessageCompressResponse:
   """
   Base class for WebSocket compression parameter server responses.
   """
   pass



class PerMessageCompressResponseAccept:
   """
   Base class for WebSocket compression parameter server response accepts by client.
   """
   pass



class PerMessageCompress:
   """
   Base class for WebSocket compression negotiated parameters.
   """
   pass

########NEW FILE########
__FILENAME__ = compress_bzip2
###############################################################################
##
##  Copyright 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import


__all__ = ["PerMessageBzip2Mixin",
           "PerMessageBzip2Offer",
           "PerMessageBzip2OfferAccept",
           "PerMessageBzip2Response",
           "PerMessageBzip2ResponseAccept",
           "PerMessageBzip2"]


import bz2

from autobahn.websocket.compress_base import PerMessageCompressOffer, \
                                             PerMessageCompressOfferAccept, \
                                             PerMessageCompressResponse, \
                                             PerMessageCompressResponseAccept, \
                                             PerMessageCompress


class PerMessageBzip2Mixin:
   """
   Mixin class for this extension.
   """

   EXTENSION_NAME = "permessage-bzip2"
   """
   Name of this WebSocket extension.
   """

   COMPRESS_LEVEL_PERMISSIBLE_VALUES = [1, 2, 3, 4, 5, 6, 7, 8, 9]
   """
   Permissible value for compression level parameter.
   """



class PerMessageBzip2Offer(PerMessageCompressOffer, PerMessageBzip2Mixin):
   """
   Set of extension parameters for `permessage-bzip2` WebSocket extension
   offered by a client to a server.
   """

   @classmethod
   def parse(Klass, params):
      """
      Parses a WebSocket extension offer for `permessage-bzip2` provided by a client to a server.

      :param params: Output from :method:`autobahn.websocket.WebSocketProtocol._parseExtensionsHeader`.
      :type params: list

      :returns: object -- A new instance of :class:`autobahn.compress.PerMessageBzip2Offer`.
      """
      ## extension parameter defaults
      ##
      acceptMaxCompressLevel = False
      requestMaxCompressLevel = 0

      ##
      ## verify/parse client ("client-to-server direction") parameters of permessage-bzip2 offer
      ##
      for p in params:

         if len(params[p]) > 1:
            raise Exception("multiple occurence of extension parameter '%s' for extension '%s'" % (p, Klass.EXTENSION_NAME))

         val = params[p][0]

         if p == 'client_max_compress_level':
            if val != True:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               acceptMaxCompressLevel = True

         elif p == 'server_max_compress_level':
            try:
               val = int(val)
            except:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            if val not in PerMessageBzip2Mixin.COMPRESS_LEVEL_PERMISSIBLE_VALUES:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               requestMaxCompressLevel = val

         else:
            raise Exception("illegal extension parameter '%s' for extension '%s'" % (p, Klass.EXTENSION_NAME))

      offer = Klass(acceptMaxCompressLevel,
                    requestMaxCompressLevel)
      return offer


   def __init__(self,
                acceptMaxCompressLevel = True,
                requestMaxCompressLevel = 0):
      """
      Constructor.

      :param acceptMaxCompressLevel: Iff true, client accepts "maximum compression level" parameter.
      :type acceptMaxCompressLevel: bool
      :param requestMaxCompressLevel: Iff non-zero, client requests given "maximum compression level" - must be 1-9.
      :type requestMaxCompressLevel: int
      """
      if type(acceptMaxCompressLevel) != bool:
         raise Exception("invalid type %s for acceptMaxCompressLevel" % type(acceptMaxCompressLevel))

      self.acceptMaxCompressLevel = acceptMaxCompressLevel

      if requestMaxCompressLevel != 0 and requestMaxCompressLevel not in self.COMPRESS_LEVEL_PERMISSIBLE_VALUES:
         raise Exception("invalid value %s for requestMaxCompressLevel - permissible values %s" % (requestMaxCompressLevel, self.COMPRESS_LEVEL_PERMISSIBLE_VALUES))

      self.requestMaxCompressLevel = requestMaxCompressLevel


   def getExtensionString(self):
      """
      Returns the WebSocket extension configuration string as sent to the server.

      :returns: str -- PMCE configuration string.
      """
      pmceString = self.EXTENSION_NAME
      if self.acceptMaxCompressLevel:
         pmceString += "; client_max_compress_level"
      if self.requestMaxCompressLevel != 0:
         pmceString += "; server_max_compress_level=%d" % self.requestMaxCompressLevel
      return pmceString


   def __json__(self):
      """
      Returns a JSON serializable object representation.

      :returns: object -- JSON serializable represention.
      """
      return {'extension': self.EXTENSION_NAME,
              'acceptMaxCompressLevel': self.acceptMaxCompressLevel,
              'requestMaxCompressLevel': self.requestMaxCompressLevel}


   def __repr__(self):
      """
      Returns Python object representation that can be eval'ed to reconstruct the object.

      :returns: str -- Python string representation.
      """
      return "PerMessageBzip2Offer(acceptMaxCompressLevel = %s, requestMaxCompressLevel = %s)" % (self.acceptMaxCompressLevel, self.requestMaxCompressLevel)



class PerMessageBzip2OfferAccept(PerMessageCompressOfferAccept, PerMessageBzip2Mixin):
   """
   Set of parameters with which to accept an `permessage-bzip2` offer
   from a client by a server.
   """

   def __init__(self,
                offer,
                requestMaxCompressLevel = 0,
                compressLevel = None):
      """
      Constructor.

      :param offer: The offer being accepted.
      :type offer: Instance of :class:`autobahn.compress.PerMessageBzip2Offer`.
      :param requestMaxCompressLevel: Iff non-zero, server requests given "maximum compression level" - must be 1-9.
      :type requestMaxCompressLevel: int
      :param compressLevel: Override server ("server-to-client direction") compress level (this must be compatible with offer).
      :type compressLevel: int
      """
      if not isinstance(offer, PerMessageBzip2Offer):
         raise Exception("invalid type %s for offer" % type(offer))

      self.offer = offer

      if requestMaxCompressLevel != 0 and requestMaxCompressLevel not in self.COMPRESS_LEVEL_PERMISSIBLE_VALUES:
         raise Exception("invalid value %s for requestMaxCompressLevel - permissible values %s" % (requestMaxCompressLevel, self.COMPRESS_LEVEL_PERMISSIBLE_VALUES))

      if requestMaxCompressLevel != 0 and not offer.acceptMaxCompressLevel:
         raise Exception("invalid value %s for requestMaxCompressLevel - feature unsupported by client" % requestMaxCompressLevel)

      self.requestMaxCompressLevel = requestMaxCompressLevel

      if compressLevel is not None:
         if compressLevel not in self.COMPRESS_LEVEL_PERMISSIBLE_VALUES:
            raise Exception("invalid value %s for compressLevel - permissible values %s" % (compressLevel, self.COMPRESS_LEVEL_PERMISSIBLE_VALUES))

         if offer.requestMaxCompressLevel != 0 and compressLevel > offer.requestMaxCompressLevel:
            raise Exception("invalid value %s for compressLevel - client requested lower maximum value" % compressLevel)

      self.compressLevel = compressLevel


   def getExtensionString(self):
      """
      Returns the WebSocket extension configuration string as sent to the server.

      :returns: str -- PMCE configuration string.
      """
      pmceString = self.EXTENSION_NAME
      if self.offer.requestMaxCompressLevel != 0:
         pmceString += "; server_max_compress_level=%d" % self.offer.requestMaxCompressLevel
      if self.requestMaxCompressLevel != 0:
         pmceString += "; client_max_compress_level=%d" % self.requestMaxCompressLevel
      return pmceString


   def __json__(self):
      """
      Returns a JSON serializable object representation.

      :returns: object -- JSON serializable represention.
      """
      return {'extension': self.EXTENSION_NAME,
              'offer': self.offer.__json__(),
              'requestMaxCompressLevel': self.requestMaxCompressLevel,
              'compressLevel': self.compressLevel}


   def __repr__(self):
      """
      Returns Python object representation that can be eval'ed to reconstruct the object.

      :returns: str -- Python string representation.
      """
      return "PerMessageBzip2Accept(offer = %s, requestMaxCompressLevel = %s, compressLevel = %s)" % (self.offer.__repr__(), self.requestMaxCompressLevel, self.compressLevel)



class PerMessageBzip2Response(PerMessageCompressResponse, PerMessageBzip2Mixin):
   """
   Set of parameters for `permessage-bzip2` responded by server.
   """

   @classmethod
   def parse(Klass, params):
      """
      Parses a WebSocket extension response for `permessage-bzip2` provided by a server to a client.

      :param params: Output from :method:`autobahn.websocket.WebSocketProtocol._parseExtensionsHeader`.
      :type params: list

      :returns: object -- A new instance of :class:`autobahn.compress.PerMessageBzip2Response`.
      """
      client_max_compress_level = 0
      server_max_compress_level = 0

      for p in params:

         if len(params[p]) > 1:
            raise Exception("multiple occurence of extension parameter '%s' for extension '%s'" % (p, Klass.EXTENSION_NAME))

         val = params[p][0]

         if p == 'client_max_compress_level':
            try:
               val = int(val)
            except:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            if val not in PerMessageBzip2Mixin.COMPRESS_LEVEL_PERMISSIBLE_VALUES:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               client_max_compress_level = val

         elif p == 'server_max_compress_level':
            try:
               val = int(val)
            except:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            if val not in PerMessageBzip2Mixin.COMPRESS_LEVEL_PERMISSIBLE_VALUES:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               server_max_compress_level = val

         else:
            raise Exception("illegal extension parameter '%s' for extension '%s'" % (p, Klass.EXTENSION_NAME))

      response = Klass(client_max_compress_level,
                       server_max_compress_level)
      return response


   def __init__(self,
                client_max_compress_level,
                server_max_compress_level):
      self.client_max_compress_level = client_max_compress_level
      self.server_max_compress_level = server_max_compress_level


   def __json__(self):
      """
      Returns a JSON serializable object representation.

      :returns: object -- JSON serializable represention.
      """
      return {'extension': self.EXTENSION_NAME,
              'client_max_compress_level': self.client_max_compress_level,
              'server_max_compress_level': self.server_max_compress_level}


   def __repr__(self):
      """
      Returns Python object representation that can be eval'ed to reconstruct the object.

      :returns: str -- Python string representation.
      """
      return "PerMessageBzip2Response(client_max_compress_level = %s, server_max_compress_level = %s)" % (self.client_max_compress_level, self.server_max_compress_level)



class PerMessageBzip2ResponseAccept(PerMessageCompressResponseAccept, PerMessageBzip2Mixin):
   """
   Set of parameters with which to accept an `permessage-bzip2` response
   from a server by a client.
   """

   def __init__(self,
                response,
                compressLevel = None):
      """
      Constructor.

      :param response: The response being accepted.
      :type response: Instance of :class:`autobahn.compress.PerMessageBzip2Response`.
      :param compressLevel: Override client ("client-to-server direction") compress level (this must be compatible with response).
      :type compressLevel: int
      """
      if not isinstance(response, PerMessageBzip2Response):
         raise Exception("invalid type %s for response" % type(response))

      self.response = response

      if compressLevel is not None:
         if compressLevel not in self.WINDOW_SIZE_PERMISSIBLE_VALUES:
            raise Exception("invalid value %s for compressLevel - permissible values %s" % (compressLevel, self.COMPRESS_LEVEL_PERMISSIBLE_VALUES))

         if response.client_max_compress_level != 0 and compressLevel > response.client_max_compress_level:
            raise Exception("invalid value %s for compressLevel - server requested lower maximum value" % compressLevel)

      self.compressLevel = compressLevel


   def __json__(self):
      """
      Returns a JSON serializable object representation.

      :returns: object -- JSON serializable represention.
      """
      return {'extension': self.EXTENSION_NAME,
              'response': self.response.__json__(),
              'compressLevel': self.compressLevel}


   def __repr__(self):
      """
      Returns Python object representation that can be eval'ed to reconstruct the object.

      :returns: str -- Python string representation.
      """
      return "PerMessageBzip2ResponseAccept(response = %s, compressLevel = %s)" % (self.response.__repr__(), self.compressLevel)



class PerMessageBzip2(PerMessageCompress, PerMessageBzip2Mixin):
   """
   `permessage-bzip2` WebSocket extension processor.
   """
   DEFAULT_COMPRESS_LEVEL = 9

   @classmethod
   def createFromResponseAccept(Klass, isServer, accept):
      pmce = Klass(isServer,
                   accept.response.server_max_compress_level,
                   accept.compressLevel if accept.compressLevel is not None else accept.response.client_max_compress_level)
      return pmce


   @classmethod
   def createFromOfferAccept(Klass, isServer, accept):
      pmce = Klass(isServer,
                   accept.compressLevel if accept.compressLevel is not None else accept.offer.requestMaxCompressLevel,
                   accept.requestMaxCompressLevel)
      return pmce


   def __init__(self,
                isServer,
                server_max_compress_level,
                client_max_compress_level):
      self._isServer = isServer
      self._compressor = None
      self._decompressor = None

      self.server_max_compress_level = server_max_compress_level if server_max_compress_level != 0 else self.DEFAULT_COMPRESS_LEVEL
      self.client_max_compress_level = client_max_compress_level if client_max_compress_level != 0 else self.DEFAULT_COMPRESS_LEVEL


   def __json__(self):
      return {'extension': self.EXTENSION_NAME,
              'isServer': self._isServer,
              'server_max_compress_level': self.server_max_compress_level,
              'client_max_compress_level': self.client_max_compress_level}


   def __repr__(self):
      return "PerMessageBzip2(isServer = %s, server_max_compress_level = %s, client_max_compress_level = %s)" % (self._isServer, self.server_max_compress_level, self.client_max_compress_level)


   def startCompressMessage(self):
      if self._isServer:
         if self._compressor is None:
            self._compressor = bz2.BZ2Compressor(self.server_max_compress_level)
      else:
         if self._compressor is None:
            self._compressor = bz2.BZ2Compressor(self.client_max_compress_level)


   def compressMessageData(self, data):
      return self._compressor.compress(data)


   def endCompressMessage(self):
      data = self._compressor.flush()

      ## there seems to be no "flush without close stream", and after
      ## full flush, compressor must not be reused
      self._compressor = None

      return data


   def startDecompressMessage(self):
      if self._decompressor is None:
         self._decompressor = bz2.BZ2Decompressor()


   def decompressMessageData(self, data):
      return self._decompressor.decompress(data)


   def endDecompressMessage(self):
      self._decompressor = None

########NEW FILE########
__FILENAME__ = compress_deflate
###############################################################################
##
##  Copyright 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import


__all__ = ["PerMessageDeflateMixin",
           "PerMessageDeflateOffer",
           "PerMessageDeflateOfferAccept",
           "PerMessageDeflateResponse",
           "PerMessageDeflateResponseAccept",
           "PerMessageDeflate"]


import zlib

from autobahn.websocket.compress_base import PerMessageCompressOffer, \
                                             PerMessageCompressOfferAccept, \
                                             PerMessageCompressResponse, \
                                             PerMessageCompressResponseAccept, \
                                             PerMessageCompress


class PerMessageDeflateMixin:
   """
   Mixin class for this extension.
   """

   EXTENSION_NAME = "permessage-deflate"
   """
   Name of this WebSocket extension.
   """

   WINDOW_SIZE_PERMISSIBLE_VALUES = [8, 9, 10, 11, 12, 13, 14, 15]
   """
   Permissible value for window size parameter.
   Higher values use more memory, but produce smaller output. The default is 15.
   """

   MEM_LEVEL_PERMISSIBLE_VALUES = [1, 2, 3, 4, 5, 6, 7, 8, 9]
   """
   Permissible value for memory level parameter.
   Higher values use more memory, but are faster and produce smaller output. The default is 8.
   """


class PerMessageDeflateOffer(PerMessageCompressOffer, PerMessageDeflateMixin):
   """
   Set of extension parameters for `permessage-deflate` WebSocket extension
   offered by a client to a server.
   """

   @classmethod
   def parse(Klass, params):
      """
      Parses a WebSocket extension offer for `permessage-deflate` provided by a client to a server.

      :param params: Output from :method:`autobahn.websocket.WebSocketProtocol._parseExtensionsHeader`.
      :type params: list

      :returns: object -- A new instance of :class:`autobahn.compress.PerMessageDeflateOffer`.
      """

      ## extension parameter defaults
      ##
      acceptMaxWindowBits = False
      acceptNoContextTakeover = True
      #acceptNoContextTakeover = False # FIXME: this may change in draft
      requestMaxWindowBits = 0
      requestNoContextTakeover = False

      ##
      ## verify/parse client ("client-to-server direction") parameters of permessage-deflate offer
      ##
      for p in params:

         if len(params[p]) > 1:
            raise Exception("multiple occurence of extension parameter '%s' for extension '%s'" % (p, Klass.EXTENSION_NAME))

         val = params[p][0]

         if p == 'client_max_window_bits':
            if val != True:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               acceptMaxWindowBits = True

         elif p == 'client_no_context_takeover':
            if val != True:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               acceptNoContextTakeover = True

         elif p == 'server_max_window_bits':
            try:
               val = int(val)
            except:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               if val not in PerMessageDeflateMixin.WINDOW_SIZE_PERMISSIBLE_VALUES:
                  raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
               else:
                  requestMaxWindowBits = val

         elif p == 'server_no_context_takeover':
            if val != True:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               requestNoContextTakeover = True

         else:
            raise Exception("illegal extension parameter '%s' for extension '%s'" % (p, Klass.EXTENSION_NAME))

      offer = Klass(acceptNoContextTakeover,
                    acceptMaxWindowBits,
                    requestNoContextTakeover,
                    requestMaxWindowBits)
      return offer


   def __init__(self,
                acceptNoContextTakeover = True,
                acceptMaxWindowBits = True,
                requestNoContextTakeover = False,
                requestMaxWindowBits = 0):
      """
      Constructor.

      :param acceptNoContextTakeover: Iff true, client accepts "no context takeover" feature.
      :type acceptNoContextTakeover: bool
      :param acceptMaxWindowBits: Iff true, client accepts setting "max window size".
      :type acceptMaxWindowBits: bool
      :param requestNoContextTakeover: Iff true, client request "no context takeover" feature.
      :type requestNoContextTakeover: bool
      :param requestMaxWindowBits: Iff non-zero, client requests given "max window size" - must be 8-15.
      :type requestMaxWindowBits: int
      """
      if type(acceptNoContextTakeover) != bool:
         raise Exception("invalid type %s for acceptNoContextTakeover" % type(acceptNoContextTakeover))

      self.acceptNoContextTakeover = acceptNoContextTakeover

      if type(acceptMaxWindowBits) != bool:
         raise Exception("invalid type %s for acceptMaxWindowBits" % type(acceptMaxWindowBits))

      self.acceptMaxWindowBits = acceptMaxWindowBits

      if type(requestNoContextTakeover) != bool:
         raise Exception("invalid type %s for requestNoContextTakeover" % type(requestNoContextTakeover))

      self.requestNoContextTakeover = requestNoContextTakeover

      if requestMaxWindowBits != 0 and requestMaxWindowBits not in self.WINDOW_SIZE_PERMISSIBLE_VALUES:
         raise Exception("invalid value %s for requestMaxWindowBits - permissible values %s" % (requestMaxWindowBits, self.WINDOW_SIZE_PERMISSIBLE_VALUES))

      self.requestMaxWindowBits = requestMaxWindowBits


   def getExtensionString(self):
      """
      Returns the WebSocket extension configuration string as sent to the server.

      :returns: str -- PMCE configuration string.
      """
      pmceString = self.EXTENSION_NAME
      if self.acceptNoContextTakeover:
         pmceString += "; client_no_context_takeover"
      if self.acceptMaxWindowBits:
         pmceString += "; client_max_window_bits"
      if self.requestNoContextTakeover:
         pmceString += "; server_no_context_takeover"
      if self.requestMaxWindowBits != 0:
         pmceString += "; server_max_window_bits=%d" % self.requestMaxWindowBits
      return pmceString


   def __json__(self):
      """
      Returns a JSON serializable object representation.

      :returns: object -- JSON serializable represention.
      """
      return {'extension': self.EXTENSION_NAME,
              'acceptNoContextTakeover': self.acceptNoContextTakeover,
              'acceptMaxWindowBits': self.acceptMaxWindowBits,
              'requestNoContextTakeover': self.requestNoContextTakeover,
              'requestMaxWindowBits': self.requestMaxWindowBits}


   def __repr__(self):
      """
      Returns Python object representation that can be eval'ed to reconstruct the object.

      :returns: str -- Python string representation.
      """
      return "PerMessageDeflateOffer(acceptNoContextTakeover = %s, acceptMaxWindowBits = %s, requestNoContextTakeover = %s, requestMaxWindowBits = %s)" % (self.acceptNoContextTakeover, self.acceptMaxWindowBits, self.requestNoContextTakeover, self.requestMaxWindowBits)



class PerMessageDeflateOfferAccept(PerMessageCompressOfferAccept, PerMessageDeflateMixin):
   """
   Set of parameters with which to accept an `permessage-deflate` offer
   from a client by a server.
   """

   def __init__(self,
                offer,
                requestNoContextTakeover = False,
                requestMaxWindowBits = 0,
                noContextTakeover = None,
                windowBits = None,
                memLevel = None):
      """
      Constructor.

      :param offer: The offer being accepted.
      :type offer: Instance of :class:`autobahn.compress.PerMessageDeflateOffer`.
      :param requestNoContextTakeover: Iff true, server request "no context takeover" feature.
      :type requestNoContextTakeover: bool
      :param requestMaxCompressLevel: Iff non-zero, server requests given "maximum compression level" - must be 1-9.
      :type requestMaxCompressLevel: int
      :param noContextTakeover: Override server ("server-to-client direction") context takeover (this must be compatible with offer).
      :type noContextTakeover: bool
      :param windowBits: Override server ("server-to-client direction") window size (this must be compatible with offer).
      :type windowBits: int
      :param memLevel: Set server ("server-to-client direction") memory level.
      :type memLevel: int
      """
      if not isinstance(offer, PerMessageDeflateOffer):
         raise Exception("invalid type %s for offer" % type(offer))

      self.offer = offer

      if type(requestNoContextTakeover) != bool:
         raise Exception("invalid type %s for requestNoContextTakeover" % type(requestNoContextTakeover))

      if requestNoContextTakeover and not offer.acceptNoContextTakeover:
         raise Exception("invalid value %s for requestNoContextTakeover - feature unsupported by client" % requestNoContextTakeover)

      self.requestNoContextTakeover = requestNoContextTakeover

      if requestMaxWindowBits != 0 and requestMaxWindowBits not in self.WINDOW_SIZE_PERMISSIBLE_VALUES:
         raise Exception("invalid value %s for requestMaxWindowBits - permissible values %s" % (requestMaxWindowBits, self.WINDOW_SIZE_PERMISSIBLE_VALUES))

      if requestMaxWindowBits != 0 and not offer.acceptMaxWindowBits:
         raise Exception("invalid value %s for requestMaxWindowBits - feature unsupported by client" % requestMaxWindowBits)

      self.requestMaxWindowBits = requestMaxWindowBits

      if noContextTakeover is not None:
         if type(noContextTakeover) != bool:
            raise Exception("invalid type %s for noContextTakeover" % type(noContextTakeover))

         if offer.requestNoContextTakeover and not noContextTakeover:
            raise Exception("invalid value %s for noContextTakeover - client requested feature" % noContextTakeover)

      self.noContextTakeover = noContextTakeover

      if windowBits is not None:
         if windowBits not in self.WINDOW_SIZE_PERMISSIBLE_VALUES:
            raise Exception("invalid value %s for windowBits - permissible values %s" % (windowBits, self.WINDOW_SIZE_PERMISSIBLE_VALUES))

         if offer.requestMaxWindowBits != 0 and windowBits > offer.requestMaxWindowBits:
            raise Exception("invalid value %s for windowBits - client requested lower maximum value" % windowBits)

      self.windowBits = windowBits

      if memLevel is not None:
         if memLevel not in self.MEM_LEVEL_PERMISSIBLE_VALUES:
            raise Exception("invalid value %s for memLevel - permissible values %s" % (memLevel, self.MEM_LEVEL_PERMISSIBLE_VALUES))

      self.memLevel = memLevel


   def getExtensionString(self):
      """
      Returns the WebSocket extension configuration string as sent to the server.

      :returns: str -- PMCE configuration string.
      """
      pmceString = self.EXTENSION_NAME
      if self.offer.requestNoContextTakeover:
         pmceString += "; server_no_context_takeover"
      if self.offer.requestMaxWindowBits != 0:
         pmceString += "; server_max_window_bits=%d" % self.offer.requestMaxWindowBits
      if self.requestNoContextTakeover:
         pmceString += "; client_no_context_takeover"
      if self.requestMaxWindowBits != 0:
         pmceString += "; client_max_window_bits=%d" % self.requestMaxWindowBits
      return pmceString


   def __json__(self):
      """
      Returns a JSON serializable object representation.

      :returns: object -- JSON serializable represention.
      """
      return {'extension': self.EXTENSION_NAME,
              'offer': self.offer.__json__(),
              'requestNoContextTakeover': self.requestNoContextTakeover,
              'requestMaxWindowBits': self.requestMaxWindowBits,
              'noContextTakeover': self.noContextTakeover,
              'windowBits': self.windowBits,
              'memLevel': memLevel}


   def __repr__(self):
      """
      Returns Python object representation that can be eval'ed to reconstruct the object.

      :returns: str -- Python string representation.
      """
      return "PerMessageDeflateOfferAccept(offer = %s, requestNoContextTakeover = %s, requestMaxWindowBits = %s, noContextTakeover = %s, windowBits = %s, memLevel = %s)" % (self.offer.__repr__(), self.requestNoContextTakeover, self.requestMaxWindowBits, self.noContextTakeover, self.windowBits, self.memLevel)



class PerMessageDeflateResponse(PerMessageCompressResponse, PerMessageDeflateMixin):
   """
   Set of parameters for `permessage-deflate` responded by server.
   """

   @classmethod
   def parse(Klass, params):
      """
      Parses a WebSocket extension response for `permessage-deflate` provided by a server to a client.

      :param params: Output from :method:`autobahn.websocket.WebSocketProtocol._parseExtensionsHeader`.
      :type params: list

      :returns: object -- A new instance of :class:`autobahn.compress.PerMessageDeflateResponse`.
      """
      client_max_window_bits = 0
      client_no_context_takeover = False
      server_max_window_bits = 0
      server_no_context_takeover = False

      for p in params:

         if len(params[p]) > 1:
            raise Exception("multiple occurence of extension parameter '%s' for extension '%s'" % (p, Klass.EXTENSION_NAME))

         val = params[p][0]

         if p == 'client_max_window_bits':
            try:
               val = int(val)
            except:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               if val not in PerMessageDeflateMixin.WINDOW_SIZE_PERMISSIBLE_VALUES:
                  raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
               else:
                  client_max_window_bits = val

         elif p == 'client_no_context_takeover':
            if val != True:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               client_no_context_takeover = True

         elif p == 'server_max_window_bits':
            try:
               val = int(val)
            except:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               if val not in PerMessageDeflateMixin.WINDOW_SIZE_PERMISSIBLE_VALUES:
                  raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
               else:
                  server_max_window_bits = val

         elif p == 'server_no_context_takeover':
            if val != True:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               server_no_context_takeover = True

         else:
            raise Exception("illegal extension parameter '%s' for extension '%s'" % (p, Klass.EXTENSION_NAME))

      response = Klass(client_max_window_bits,
                       client_no_context_takeover,
                       server_max_window_bits,
                       server_no_context_takeover)
      return response


   def __init__(self,
                client_max_window_bits,
                client_no_context_takeover,
                server_max_window_bits,
                server_no_context_takeover):
      self.client_max_window_bits = client_max_window_bits
      self.client_no_context_takeover = client_no_context_takeover
      self.server_max_window_bits = server_max_window_bits
      self.server_no_context_takeover = server_no_context_takeover


   def __json__(self):
      """
      Returns a JSON serializable object representation.

      :returns: object -- JSON serializable represention.
      """
      return {'extension': self.EXTENSION_NAME,
              'client_max_window_bits': self.client_max_window_bits,
              'client_no_context_takeover': self.client_no_context_takeover,
              'server_max_window_bits': self.server_max_window_bits,
              'server_no_context_takeover': self.server_no_context_takeover}


   def __repr__(self):
      """
      Returns Python object representation that can be eval'ed to reconstruct the object.

      :returns: str -- Python string representation.
      """
      return "PerMessageDeflateResponse(client_max_window_bits = %s, client_no_context_takeover = %s, server_max_window_bits = %s, server_no_context_takeover = %s)" % (self.client_max_window_bits, self.client_no_context_takeover, self.server_max_window_bits, self.server_no_context_takeover)


class PerMessageDeflateResponseAccept(PerMessageCompressResponseAccept, PerMessageDeflateMixin):
   """
   Set of parameters with which to accept an `permessage-deflate` response
   from a server by a client.
   """

   def __init__(self,
                response,
                noContextTakeover = None,
                windowBits = None,
                memLevel = None):
      """
      Constructor.

      :param response: The response being accepted.
      :type response: Instance of :class:`autobahn.compress.PerMessageDeflateResponse`.
      :param noContextTakeover: Override client ("client-to-server direction") context takeover (this must be compatible with response).
      :type noContextTakeover: bool
      :param windowBits: Override client ("client-to-server direction") window size (this must be compatible with response).
      :type windowBits: int
      :param memLevel: Set client ("client-to-server direction") memory level.
      :type memLevel: int
      """
      if not isinstance(response, PerMessageDeflateResponse):
         raise Exception("invalid type %s for response" % type(response))

      self.response = response

      if noContextTakeover is not None:
         if type(noContextTakeover) != bool:
            raise Exception("invalid type %s for noContextTakeover" % type(noContextTakeover))

         if response.client_no_context_takeover and not noContextTakeover:
            raise Exception("invalid value %s for noContextTakeover - server requested feature" % noContextTakeover)

      self.noContextTakeover = noContextTakeover

      if windowBits is not None:
         if windowBits not in self.WINDOW_SIZE_PERMISSIBLE_VALUES:
            raise Exception("invalid value %s for windowBits - permissible values %s" % (windowBits, self.WINDOW_SIZE_PERMISSIBLE_VALUES))

         if response.client_max_window_bits != 0 and windowBits > response.client_max_window_bits:
            raise Exception("invalid value %s for windowBits - server requested lower maximum value" % windowBits)

      self.windowBits = windowBits

      if memLevel is not None:
         if memLevel not in self.MEM_LEVEL_PERMISSIBLE_VALUES:
            raise Exception("invalid value %s for memLevel - permissible values %s" % (memLevel, self.MEM_LEVEL_PERMISSIBLE_VALUES))

      self.memLevel = memLevel


   def __json__(self):
      """
      Returns a JSON serializable object representation.

      :returns: object -- JSON serializable represention.
      """
      return {'extension': self.EXTENSION_NAME,
              'response': self.response.__json__(),
              'noContextTakeover': self.noContextTakeover,
              'windowBits': self.windowBits,
              'memLevel': self.memLevel}


   def __repr__(self):
      """
      Returns Python object representation that can be eval'ed to reconstruct the object.

      :returns: str -- Python string representation.
      """
      return "PerMessageDeflateResponseAccept(response = %s, noContextTakeover = %s, windowBits = %s, memLevel = %s)" % (self.response.__repr__(), self.noContextTakeover, self.windowBits, self.memLevel)



class PerMessageDeflate(PerMessageCompress, PerMessageDeflateMixin):
   """
   `permessage-deflate` WebSocket extension processor.
   """
   DEFAULT_WINDOW_BITS = zlib.MAX_WBITS
   DEFAULT_MEM_LEVEL = 8


   @classmethod
   def createFromResponseAccept(Klass, isServer, accept):
      ## accept: instance of PerMessageDeflateResponseAccept
      pmce = Klass(isServer,
                   accept.response.server_no_context_takeover,
                   accept.noContextTakeover if accept.noContextTakeover is not None else accept.response.client_no_context_takeover,
                   accept.response.server_max_window_bits,
                   accept.windowBits if accept.windowBits is not None else accept.response.client_max_window_bits,
                   accept.memLevel)
      return pmce


   @classmethod
   def createFromOfferAccept(Klass, isServer, accept):
      ## accept: instance of PerMessageDeflateOfferAccept
      pmce = Klass(isServer,
                   accept.noContextTakeover if accept.noContextTakeover is not None else accept.offer.requestNoContextTakeover,
                   accept.requestNoContextTakeover,
                   accept.windowBits if accept.windowBits is not None else accept.offer.requestMaxWindowBits,
                   accept.requestMaxWindowBits,
                   accept.memLevel)
      return pmce


   def __init__(self,
                isServer,
                server_no_context_takeover,
                client_no_context_takeover,
                server_max_window_bits,
                client_max_window_bits,
                mem_level):
      self._isServer = isServer

      self.server_no_context_takeover = server_no_context_takeover
      self.client_no_context_takeover = client_no_context_takeover

      self.server_max_window_bits = server_max_window_bits if server_max_window_bits != 0 else self.DEFAULT_WINDOW_BITS
      self.client_max_window_bits = client_max_window_bits if client_max_window_bits != 0 else self.DEFAULT_WINDOW_BITS

      self.mem_level = mem_level if mem_level else self.DEFAULT_MEM_LEVEL

      self._compressor = None
      self._decompressor = None


   def __json__(self):
      return {'extension': self.EXTENSION_NAME,
              'isServer': self._isServer,
              'server_no_context_takeover': self.server_no_context_takeover,
              'client_no_context_takeover': self.client_no_context_takeover,
              'server_max_window_bits': self.server_max_window_bits,
              'client_max_window_bits': self.client_max_window_bits,
              'mem_level': self.mem_level}


   def __repr__(self):
      return "PerMessageDeflate(isServer = %s, server_no_context_takeover = %s, client_no_context_takeover = %s, server_max_window_bits = %s, client_max_window_bits = %s, mem_level = %s)" % (self._isServer, self.server_no_context_takeover, self.client_no_context_takeover, self.server_max_window_bits, self.client_max_window_bits, self.mem_level)


   def startCompressMessage(self):
      # compressobj([level[, method[, wbits[, memlevel[, strategy]]]]])
      # http://bugs.python.org/issue19278
      # http://hg.python.org/cpython/rev/c54c8e71b79a
      #
      if self._isServer:
         if self._compressor is None or self.server_no_context_takeover:
            self._compressor = zlib.compressobj(zlib.Z_DEFAULT_COMPRESSION, zlib.DEFLATED, -self.server_max_window_bits, self.mem_level)
      else:
         if self._compressor is None or self.client_no_context_takeover:
            self._compressor = zlib.compressobj(zlib.Z_DEFAULT_COMPRESSION, zlib.DEFLATED, -self.client_max_window_bits, self.mem_level)


   def compressMessageData(self, data):
      return self._compressor.compress(data)


   def endCompressMessage(self):
      data = self._compressor.flush(zlib.Z_SYNC_FLUSH)
      return data[:-4]


   def startDecompressMessage(self):
      if self._isServer:
         if self._decompressor is None or self.client_no_context_takeover:
            self._decompressor = zlib.decompressobj(-self.client_max_window_bits)
      else:
         if self._decompressor is None or self.server_no_context_takeover:
            self._decompressor = zlib.decompressobj(-self.server_max_window_bits)


   def decompressMessageData(self, data):
      return self._decompressor.decompress(data)


   def endDecompressMessage(self):
      ## Eat stripped LEN and NLEN field of a non-compressed block added
      ## for Z_SYNC_FLUSH.
      ##
      self._decompressor.decompress(b'\x00\x00\xff\xff')

########NEW FILE########
__FILENAME__ = compress_snappy
###############################################################################
##
##  Copyright 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import


__all__ = ["PerMessageSnappyMixin",
           "PerMessageSnappyOffer",
           "PerMessageSnappyOfferAccept",
           "PerMessageSnappyResponse",
           "PerMessageSnappyResponseAccept",
           "PerMessageSnappy"]


import snappy

from autobahn.websocket.compress_base import PerMessageCompressOffer, \
                                             PerMessageCompressOfferAccept, \
                                             PerMessageCompressResponse, \
                                             PerMessageCompressResponseAccept, \
                                             PerMessageCompress


class PerMessageSnappyMixin:
   """
   Mixin class for this extension.
   """

   EXTENSION_NAME = "permessage-snappy"
   """
   Name of this WebSocket extension.
   """



class PerMessageSnappyOffer(PerMessageCompressOffer, PerMessageSnappyMixin):
   """
   Set of extension parameters for `permessage-snappy` WebSocket extension
   offered by a client to a server.
   """

   @classmethod
   def parse(Klass, params):
      """
      Parses a WebSocket extension offer for `permessage-snappy` provided by a client to a server.

      :param params: Output from :method:`autobahn.websocket.WebSocketProtocol._parseExtensionsHeader`.
      :type params: list

      :returns: object -- A new instance of :class:`autobahn.compress.PerMessageSnappyOffer`.
      """
      ## extension parameter defaults
      ##
      acceptNoContextTakeover = False
      requestNoContextTakeover = False

      ##
      ## verify/parse client ("client-to-server direction") parameters of permessage-snappy offer
      ##
      for p in params:

         if len(params[p]) > 1:
            raise Exception("multiple occurence of extension parameter '%s' for extension '%s'" % (p, Klass.EXTENSION_NAME))

         val = params[p][0]

         if p == 'client_no_context_takeover':
            if val != True:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               acceptNoContextTakeover = True

         elif p == 'server_no_context_takeover':
            if val != True:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               requestNoContextTakeover = True

         else:
            raise Exception("illegal extension parameter '%s' for extension '%s'" % (p, Klass.EXTENSION_NAME))

      offer = Klass(acceptNoContextTakeover,
                    requestNoContextTakeover)
      return offer


   def __init__(self,
                acceptNoContextTakeover = True,
                requestNoContextTakeover = False):
      """
      Constructor.

      :param acceptNoContextTakeover: Iff true, client accepts "no context takeover" feature.
      :type acceptNoContextTakeover: bool
      :param requestNoContextTakeover: Iff true, client request "no context takeover" feature.
      :type requestNoContextTakeover: bool
      """
      if type(acceptNoContextTakeover) != bool:
         raise Exception("invalid type %s for acceptNoContextTakeover" % type(acceptNoContextTakeover))

      self.acceptNoContextTakeover = acceptNoContextTakeover

      if type(requestNoContextTakeover) != bool:
         raise Exception("invalid type %s for requestNoContextTakeover" % type(requestNoContextTakeover))

      self.requestNoContextTakeover = requestNoContextTakeover


   def getExtensionString(self):
      """
      Returns the WebSocket extension configuration string as sent to the server.

      :returns: str -- PMCE configuration string.
      """
      pmceString = self.EXTENSION_NAME
      if self.acceptNoContextTakeover:
         pmceString += "; client_no_context_takeover"
      if self.requestNoContextTakeover:
         pmceString += "; server_no_context_takeover"
      return pmceString


   def __json__(self):
      """
      Returns a JSON serializable object representation.

      :returns: object -- JSON serializable represention.
      """
      return {'extension': self.EXTENSION_NAME,
              'acceptNoContextTakeover': self.acceptNoContextTakeover,
              'requestNoContextTakeover': self.requestNoContextTakeover}


   def __repr__(self):
      """
      Returns Python object representation that can be eval'ed to reconstruct the object.

      :returns: str -- Python string representation.
      """
      return "PerMessageSnappyOffer(acceptNoContextTakeover = %s, requestNoContextTakeover = %s)" % (self.acceptNoContextTakeover, self.requestNoContextTakeover)



class PerMessageSnappyOfferAccept(PerMessageCompressOfferAccept, PerMessageSnappyMixin):
   """
   Set of parameters with which to accept an `permessage-snappy` offer
   from a client by a server.
   """

   def __init__(self,
                offer,
                requestNoContextTakeover = False,
                noContextTakeover = None):
      """
      Constructor.

      :param offer: The offer being accepted.
      :type offer: Instance of :class:`autobahn.compress.PerMessageSnappyOffer`.
      :param requestNoContextTakeover: Iff true, server request "no context takeover" feature.
      :type requestNoContextTakeover: bool
      :param noContextTakeover: Override server ("server-to-client direction") context takeover (this must be compatible with offer).
      :type noContextTakeover: bool
      """
      if not isinstance(offer, PerMessageSnappyOffer):
         raise Exception("invalid type %s for offer" % type(offer))

      self.offer = offer

      if type(requestNoContextTakeover) != bool:
         raise Exception("invalid type %s for requestNoContextTakeover" % type(requestNoContextTakeover))

      if requestNoContextTakeover and not offer.acceptNoContextTakeover:
         raise Exception("invalid value %s for requestNoContextTakeover - feature unsupported by client" % requestNoContextTakeover)

      self.requestNoContextTakeover = requestNoContextTakeover

      if noContextTakeover is not None:
         if type(noContextTakeover) != bool:
            raise Exception("invalid type %s for noContextTakeover" % type(noContextTakeover))

         if offer.requestNoContextTakeover and not noContextTakeover:
            raise Exception("invalid value %s for noContextTakeover - client requested feature" % noContextTakeover)

      self.noContextTakeover = noContextTakeover


   def getExtensionString(self):
      """
      Returns the WebSocket extension configuration string as sent to the server.

      :returns: str -- PMCE configuration string.
      """
      pmceString = self.EXTENSION_NAME
      if self.offer.requestNoContextTakeover:
         pmceString += "; server_no_context_takeover"
      if self.requestNoContextTakeover:
         pmceString += "; client_no_context_takeover"
      return pmceString


   def __json__(self):
      """
      Returns a JSON serializable object representation.

      :returns: object -- JSON serializable represention.
      """
      return {'extension': self.EXTENSION_NAME,
              'offer': self.offer.__json__(),
              'requestNoContextTakeover': self.requestNoContextTakeover,
              'noContextTakeover': self.noContextTakeover}


   def __repr__(self):
      """
      Returns Python object representation that can be eval'ed to reconstruct the object.

      :returns: str -- Python string representation.
      """
      return "PerMessageSnappyAccept(offer = %s, requestNoContextTakeover = %s, noContextTakeover = %s)" % (self.offer.__repr__(), self.requestNoContextTakeover, self.noContextTakeover)



class PerMessageSnappyResponse(PerMessageCompressResponse, PerMessageSnappyMixin):
   """
   Set of parameters for `permessage-snappy` responded by server.
   """

   @classmethod
   def parse(Klass, params):
      """
      Parses a WebSocket extension response for `permessage-snappy` provided by a server to a client.

      :param params: Output from :method:`autobahn.websocket.WebSocketProtocol._parseExtensionsHeader`.
      :type params: list

      :returns: object -- A new instance of :class:`autobahn.compress.PerMessageSnappyResponse`.
      """
      client_no_context_takeover = False
      server_no_context_takeover = False

      for p in params:

         if len(params[p]) > 1:
            raise Exception("multiple occurence of extension parameter '%s' for extension '%s'" % (p, Klass.EXTENSION_NAME))

         val = params[p][0]

         if p == 'client_no_context_takeover':
            if val != True:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               client_no_context_takeover = True

         elif p == 'server_no_context_takeover':
            if val != True:
               raise Exception("illegal extension parameter value '%s' for parameter '%s' of extension '%s'" % (val, p, Klass.EXTENSION_NAME))
            else:
               server_no_context_takeover = True

         else:
            raise Exception("illegal extension parameter '%s' for extension '%s'" % (p, Klass.EXTENSION_NAME))

      response = Klass(client_no_context_takeover,
                       server_no_context_takeover)
      return response


   def __init__(self,
                client_no_context_takeover,
                server_no_context_takeover):
      self.client_no_context_takeover = client_no_context_takeover
      self.server_no_context_takeover = server_no_context_takeover


   def __json__(self):
      """
      Returns a JSON serializable object representation.

      :returns: object -- JSON serializable represention.
      """
      return {'extension': self.EXTENSION_NAME,
              'client_no_context_takeover': self.client_no_context_takeover,
              'server_no_context_takeover': self.server_no_context_takeover}


   def __repr__(self):
      """
      Returns Python object representation that can be eval'ed to reconstruct the object.

      :returns: str -- Python string representation.
      """
      return "PerMessageSnappyResponse(client_no_context_takeover = %s, server_no_context_takeover = %s)" % (self.client_no_context_takeover, self.server_no_context_takeover)



class PerMessageSnappyResponseAccept(PerMessageCompressResponseAccept, PerMessageSnappyMixin):
   """
   Set of parameters with which to accept an `permessage-snappy` response
   from a server by a client.
   """

   def __init__(self,
                response,
                noContextTakeover = None):
      """
      Constructor.

      :param response: The response being accepted.
      :type response: Instance of :class:`autobahn.compress.PerMessageSnappyResponse`.
      :param noContextTakeover: Override client ("client-to-server direction") context takeover (this must be compatible with response).
      :type noContextTakeover: bool
      """
      if not isinstance(response, PerMessageSnappyResponse):
         raise Exception("invalid type %s for response" % type(response))

      self.response = response

      if noContextTakeover is not None:
         if type(noContextTakeover) != bool:
            raise Exception("invalid type %s for noContextTakeover" % type(noContextTakeover))

         if response.client_no_context_takeover and not noContextTakeover:
            raise Exception("invalid value %s for noContextTakeover - server requested feature" % noContextTakeover)

      self.noContextTakeover = noContextTakeover


   def __json__(self):
      """
      Returns a JSON serializable object representation.

      :returns: object -- JSON serializable represention.
      """
      return {'extension': self.EXTENSION_NAME,
              'response': self.response.__json__(),
              'noContextTakeover': self.noContextTakeover}


   def __repr__(self):
      """
      Returns Python object representation that can be eval'ed to reconstruct the object.

      :returns: str -- Python string representation.
      """
      return "PerMessageSnappyResponseAccept(response = %s, noContextTakeover = %s)" % (self.response.__repr__(), self.noContextTakeover)



class PerMessageSnappy(PerMessageCompress, PerMessageSnappyMixin):
   """
   `permessage-snappy` WebSocket extension processor.
   """

   @classmethod
   def createFromResponseAccept(Klass, isServer, accept):
      pmce = Klass(isServer,
                   accept.response.server_no_context_takeover,
                   accept.noContextTakeover if accept.noContextTakeover is not None else accept.response.client_no_context_takeover)
      return pmce


   @classmethod
   def createFromOfferAccept(Klass, isServer, accept):
      pmce = Klass(isServer,
                   accept.noContextTakeover if accept.noContextTakeover is not None else accept.offer.requestNoContextTakeover,
                   accept.requestNoContextTakeover)
      return pmce


   def __init__(self,
                isServer,
                server_no_context_takeover,
                client_no_context_takeover):
      self._isServer = isServer
      self.server_no_context_takeover = server_no_context_takeover
      self.client_no_context_takeover = client_no_context_takeover

      self._compressor = None
      self._decompressor = None


   def __json__(self):
      return {'extension': self.EXTENSION_NAME,
              'server_no_context_takeover': self.server_no_context_takeover,
              'client_no_context_takeover': self.client_no_context_takeover}


   def __repr__(self):
      return "PerMessageSnappy(isServer = %s, server_no_context_takeover = %s, client_no_context_takeover = %s)" % (self._isServer, self.server_no_context_takeover, self.client_no_context_takeover)


   def startCompressMessage(self):
      if self._isServer:
         if self._compressor is None or self.server_no_context_takeover:
            self._compressor = snappy.StreamCompressor()
      else:
         if self._compressor is None or self.client_no_context_takeover:
            self._compressor = snappy.StreamCompressor()


   def compressMessageData(self, data):
      return self._compressor.add_chunk(data)


   def endCompressMessage(self):
      return ""


   def startDecompressMessage(self):
      if self._isServer:
         if self._decompressor is None or self.client_no_context_takeover:
            self._decompressor = snappy.StreamDecompressor()
      else:
         if self._decompressor is None or self.server_no_context_takeover:
            self._decompressor = snappy.StreamDecompressor()


   def decompressMessageData(self, data):
      return self._decompressor.decompress(data)


   def endDecompressMessage(self):
      pass

########NEW FILE########
__FILENAME__ = http
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

##
## HTTP Status Codes
##
## Source: http://en.wikipedia.org/wiki/List_of_HTTP_status_codes
## Adapted on 2011/10/11
##

##
## 1xx Informational
##
## Request received, continuing process.
##
## This class of status code indicates a provisional response, consisting only of
## the Status-Line and optional headers, and is terminated by an empty line.
## Since HTTP/1.0 did not define any 1xx status codes, servers must not send
## a 1xx response to an HTTP/1.0 client except under experimental conditions.
##

CONTINUE                 = (100, "Continue",
                            "This means that the server has received the request headers, and that the client should proceed to send the request body (in the case of a request for which a body needs to be sent; for example, a POST request). If the request body is large, sending it to a server when a request has already been rejected based upon inappropriate headers is inefficient. To have a server check if the request could be accepted based on the request's headers alone, a client must send Expect: 100-continue as a header in its initial request[2] and check if a 100 Continue status code is received in response before continuing (or receive 417 Expectation Failed and not continue).")
SWITCHING_PROTOCOLS      = (101, "Switching Protocols",
                            "This means the requester has asked the server to switch protocols and the server is acknowledging that it will do so.")
PROCESSING               = (102, "Processing (WebDAV) (RFC 2518)",
                            "As a WebDAV request may contain many sub-requests involving file operations, it may take a long time to complete the request. This code indicates that the server has received and is processing the request, but no response is available yet.[3] This prevents the client from timing out and assuming the request was lost.")
CHECKPOINT               = (103, "Checkpoint",
                            "This code is used in the Resumable HTTP Requests Proposal to resume aborted PUT or POST requests.")
REQUEST_URI_TOO_LONG     = (122, "Request-URI too long",
                            "This is a non-standard IE7-only code which means the URI is longer than a maximum of 2083 characters.[5][6] (See code 414.)")

##
## 2xx Success
##
## This class of status codes indicates the action requested by the client was
## received, understood, accepted and processed successfully.
##

OK                       = (200, "OK",
                            "Standard response for successful HTTP requests. The actual response will depend on the request method used. In a GET request, the response will contain an entity corresponding to the requested resource. In a POST request the response will contain an entity describing or containing the result of the action.")
CREATED                  = (201, "Created",
                            "The request has been fulfilled and resulted in a new resource being created.")
ACCEPTED                 = (202, "Accepted",
                            "The request has been accepted for processing, but the processing has not been completed. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place.")
NON_AUTHORATIVE          = (203, "Non-Authoritative Information (since HTTP/1.1)",
                            "The server successfully processed the request, but is returning information that may be from another source.")
NO_CONTENT               = (204, "No Content",
                            "The server successfully processed the request, but is not returning any content.")
RESET_CONTENT            = (205, "Reset Content",
                            "The server successfully processed the request, but is not returning any content. Unlike a 204 response, this response requires that the requester reset the document view.")
PARTIAL_CONTENT          = (206, "Partial Content",
                            "The server is delivering only part of the resource due to a range header sent by the client. The range header is used by tools like wget to enable resuming of interrupted downloads, or split a download into multiple simultaneous streams.")
MULTI_STATUS             = (207, "Multi-Status (WebDAV) (RFC 4918)",
                            "The message body that follows is an XML message and can contain a number of separate response codes, depending on how many sub-requests were made.")
IM_USED                  = (226, "IM Used (RFC 3229)",
                            "The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.")

##
## 3xx Redirection
##
## The client must take additional action to complete the request.
##
## This class of status code indicates that further action needs to be taken
## by the user agent in order to fulfil the request. The action required may
## be carried out by the user agent without interaction with the user if and
## only if the method used in the second request is GET or HEAD. A user agent
## should not automatically redirect a request more than five times, since such
## redirections usually indicate an infinite loop.
##

MULTIPLE_CHOICES         = (300, "Multiple Choices",
                            "Indicates multiple options for the resource that the client may follow. It, for instance, could be used to present different format options for video, list files with different extensions, or word sense disambiguation.")
MOVED_PERMANENTLY        = (301, "Moved Permanently",
                            "This and all future requests should be directed to the given URI.")
FOUND                    = (302, "Found",
                            "This is an example of industrial practice contradicting the standard. HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect (the original describing phrase was 'Moved Temporarily', but popular browsers implemented 302 with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307 to distinguish between the two behaviours. However, some Web applications and frameworks use the 302 status code as if it were the 303.")
SEE_OTHER                = (303, "See Other (since HTTP/1.1)",
                            "The response to the request can be found under another URI using a GET method. When received in response to a POST (or PUT/DELETE), it should be assumed that the server has received the data and the redirect should be issued with a separate GET message.")
NOT_MODIFIED             = (304, "Not Modified",
                            "Indicates the resource has not been modified since last requested.[2] Typically, the HTTP client provides a header like the If-Modified-Since header to provide a time against which to compare. Using this saves bandwidth and reprocessing on both the server and client, as only the header data must be sent and received in comparison to the entirety of the page being re-processed by the server, then sent again using more bandwidth of the server and client.")
USE_PROXY                = (305, "Use Proxy (since HTTP/1.1)",
                            "Many HTTP clients (such as Mozilla[11] and Internet Explorer) do not correctly handle responses with this status code, primarily for security reasons.")
SWITCH_PROXY             = (306, "Switch Proxy",
                            "No longer used. Originally meant 'Subsequent requests should use the specified proxy'.")
TEMPORARY_REDIRECT       = (307, "Temporary Redirect (since HTTP/1.1)",
                            "In this occasion, the request should be repeated with another URI, but future requests can still use the original URI.[2] In contrast to 303, the request method should not be changed when reissuing the original request. For instance, a POST request must be repeated using another POST request.")
RESUME_INCOMPLETE        = (308, "Resume Incomplete",
                            "This code is used in the Resumable HTTP Requests Proposal to resume aborted PUT or POST requests.")

##
## 4xx Client Error
##
## The 4xx class of status code is intended for cases in which the client
## seems to have erred. Except when responding to a HEAD request, the server
## should include an entity containing an explanation of the error situation,
## and whether it is a temporary or permanent condition. These status codes are
## applicable to any request method. User agents should display any included
## entity to the user. These are typically the most common error codes
## encountered while online.
##

BAD_REQUEST              = (400, "Bad Request",
                            "The request cannot be fulfilled due to bad syntax.")
UNAUTHORIZED             = (401, "Unauthorized",
                            "Similar to 403 Forbidden, but specifically for use when authentication is possible but has failed or not yet been provided.[2] The response must include a WWW-Authenticate header field containing a challenge applicable to the requested resource. See Basic access authentication and Digest access authentication.")
PAYMENT_REQUIRED         = (402, "Payment Required",
                            "Reserved for future use.[2] The original intention was that this code might be used as part of some form of digital cash or micropayment scheme, but that has not happened, and this code is not usually used. As an example of its use, however, Apple's MobileMe service generates a 402 error if the MobileMe account is delinquent.")
FORBIDDEN                = (403, "Forbidden",
                            "The request was a legal request, but the server is refusing to respond to it.[2] Unlike a 401 Unauthorized response, authenticating will make no difference.[2]")
NOT_FOUND                = (404, "Not Found",
                            "The requested resource could not be found but may be available again in the future.[2] Subsequent requests by the client are permissible.")
METHOD_NOT_ALLOWED       = (405, "Method Not Allowed",
                            "A request was made of a resource using a request method not supported by that resource;[2] for example, using GET on a form which requires data to be presented via POST, or using PUT on a read-only resource.")
NOT_ACCEPTABLE           = (406, "Not Acceptable",
                            "The requested resource is only capable of generating content not acceptable according to the Accept headers sent in the request.")
PROXY_AUTH_REQUIRED      = (407, "Proxy Authentication Required",
                            "The client must first authenticate itself with the proxy.")
REQUEST_TIMEOUT          = (408, "Request Timeout",
                            "The server timed out waiting for the request. According to W3 HTTP specifications: 'The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.'")
CONFLICT                 = (409, "Conflict",
                            "Indicates that the request could not be processed because of conflict in the request, such as an edit conflict.")
GONE                     = (410, "Gone",
                            "Indicates that the resource requested is no longer available and will not be available again.[2] This should be used when a resource has been intentionally removed and the resource should be purged. Upon receiving a 410 status code, the client should not request the resource again in the future. Clients such as search engines should remove the resource from their indices. Most use cases do not require clients and search engines to purge the resource, and a '404 Not Found' may be used instead.")
LENGTH_REQUIRED          = (411, "Length Required",
                            "The request did not specify the length of its content, which is required by the requested resource.")
PRECONDITION_FAILED      = (412, "Precondition Failed",
                            "The server does not meet one of the preconditions that the requester put on the request.")
REQUEST_ENTITY_TOO_LARGE = (413, "Request Entity Too Large",
                            "The request is larger than the server is willing or able to process.")
REQUEST_URI_TOO_LARGE    = (414, "Request-URI Too Long",
                            "The URI provided was too long for the server to process.")
UNSUPPORTED_MEDIA_TYPE   = (415, "Unsupported Media Type",
                            "The request entity has a media type which the server or resource does not support. For example, the client uploads an image as image/svg+xml, but the server requires that images use a different format.")
INVALID_REQUEST_RANGE    = (416, "Requested Range Not Satisfiable",
                            "The client has asked for a portion of the file, but the server cannot supply that portion.[2] For example, if the client asked for a part of the file that lies beyond the end of the file.")
EXPECTATION_FAILED       = (417, "Expectation Failed",
                            "The server cannot meet the requirements of the Expect request-header field.")
TEAPOT                   = (418, "I'm a teapot (RFC 2324)",
                            "This code was defined in 1998 as one of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol, and is not expected to be implemented by actual HTTP servers.")
UNPROCESSABLE_ENTITY     = (422, "Unprocessable Entity (WebDAV) (RFC 4918)",
                            "The request was well-formed but was unable to be followed due to semantic errors.")
LOCKED                   = (423, "Locked (WebDAV) (RFC 4918)",
                            "The resource that is being accessed is locked.")
FAILED_DEPENDENCY        = (424, "Failed Dependency (WebDAV) (RFC 4918)",
                            "The request failed due to failure of a previous request (e.g. a PROPPATCH).")
UNORDERED_COLLECTION     = (425, "Unordered Collection (RFC 3648)",
                            "Defined in drafts of 'WebDAV Advanced Collections Protocol', but not present in 'Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol'.")
UPGRADE_REQUIRED         = (426, "Upgrade Required (RFC 2817)",
                            "The client should switch to a different protocol such as TLS/1.0.")
NO_RESPONSE              = (444, "No Response",
                            "A Nginx HTTP server extension. The server returns no information to the client and closes the connection (useful as a deterrent for malware).")
RETRY_WITH               = (449, "Retry With",
                            "A Microsoft extension. The request should be retried after performing the appropriate action.")
PARANTAL_BLOCKED         = (450, "Blocked by Windows Parental Controls",
                            "A Microsoft extension. This error is given when Windows Parental Controls are turned on and are blocking access to the given webpage.")
CLIENT_CLOSED_REQUEST    = (499, "Client Closed Request",
                            "An Nginx HTTP server extension. This code is introduced to log the case when the connection is closed by client while HTTP server is processing its request, making server unable to send the HTTP header back.")


##
## 5xx Server Error
##
## The server failed to fulfill an apparently valid request.
##
## Response status codes beginning with the digit "5" indicate cases in which
## the server is aware that it has encountered an error or is otherwise incapable
## of performing the request. Except when responding to a HEAD request, the server
## should include an entity containing an explanation of the error situation, and
## indicate whether it is a temporary or permanent condition. Likewise, user agents
## should display any included entity to the user. These response codes are
## applicable to any request method.
##

INTERNAL_SERVER_ERROR    = (500, "Internal Server Error",
                            "A generic error message, given when no more specific message is suitable.")
NOT_IMPLEMENTED          = (501, "Not Implemented",
                            "The server either does not recognise the request method, or it lacks the ability to fulfill the request.")
BAD_GATEWAY              = (502, "Bad Gateway",
                            "The server was acting as a gateway or proxy and received an invalid response from the upstream server.")
SERVICE_UNAVAILABLE      = (503, "Service Unavailable",
                            "The server is currently unavailable (because it is overloaded or down for maintenance). Generally, this is a temporary state.")
GATEWAY_TIMEOUT          = (504, "Gateway Timeout",
                            "The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.")
UNSUPPORTED_HTTP_VERSION = (505, "HTTP Version Not Supported",
                            "The server does not support the HTTP protocol version used in the request.")
VARIANT_ALSO_NEGOTIATES  = (506, "Variant Also Negotiates (RFC 2295)",
                            "Transparent content negotiation for the request results in a circular reference.")
INSUFFICIENT_STORAGE     = (507, "Insufficient Storage (WebDAV)(RFC 4918)",
                            "The server is unable to store the representation needed to complete the request.")
BANDWIDTH_LIMIT_EXCEEDED = (509, "Bandwidth Limit Exceeded (Apache bw/limited extension)",
                            "This status code, while used by many servers, is not specified in any RFCs.")
NOT_EXTENDED             = (510, "Not Extended (RFC 2774)",
                            "Further extensions to the request are required for the server to fulfill it.")
NETWORK_READ_TIMEOUT     = (598, "Network read timeout error (Informal convention)",
                            "This status code is not specified in any RFCs, but is used by some HTTP proxies to signal a network read timeout behind the proxy to a client in front of the proxy.")
NETWORK_CONNECT_TIMEOUT  = (599, "Network connect timeout error (Informal convention)",
                            "This status code is not specified in any RFCs, but is used by some HTTP proxies to signal a network connect timeout behind the proxy to a client in front of the proxy.")



class HttpException(Exception):
   """
   Throw an instance of this class to deny a WebSocket connection
   during handshake in :meth:`autobahn.websocket.protocol.WebSocketServerProtocol.onConnect`.
   """

   def __init__(self, code, reason):
      """
      Constructor.

      :param code: HTTP error code.
      :type code: int
      :param reason: HTTP error reason.
      :type reason: str
      """
      self.code = code
      self.reason = reason

########NEW FILE########
__FILENAME__ = interfaces
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ['IWebSocketChannel',
           'IWebSocketChannelFrameApi',
           'IWebSocketChannelStreamingApi']

import abc
import six


@six.add_metaclass(abc.ABCMeta)
class IWebSocketChannel(object):
   """
   A WebSocket channel is a bidirectional, full-duplex, ordered, reliable message channel
   over a WebSocket connection as specified in RFC6455.

   This interface defines a message-based API to WebSocket plus auxiliary hooks
   and methods.
   """

   @abc.abstractmethod
   def onConnect(self, requestOrResponse):
      """
      Callback fired during WebSocket opening handshake when a client connects (with
      request from client) or when server connection established (with response from
      server).

      :param requestOrResponse: Connection request or response.
      :type requestOrResponse: Instance of :class:`autobahn.websocket.protocol.ConnectionRequest`
                               or :class:`autobahn.websocket.protocol.ConnectionResponse`.
      """


   @abc.abstractmethod
   def onOpen(self):
      """
      Callback fired when the initial WebSocket opening handshake was completed.
      You now can send and receive WebSocket messages.
      """


   @abc.abstractmethod
   def sendMessage(self, payload, isBinary = False, fragmentSize = None, sync = False, doNotCompress = False):
      """
      Send a WebSocket message.

      You can send text or binary messages, and optionally specifiy a payload fragment size.
      When the latter is given, the payload will be split up into WebSocket frames each with
      payload length `<= fragmentSize`.

      :param payload: The message payload.
      :type payload: bytes
      :param isBinary: `True` iff payload is binary, else the payload must be UTF-8 encoded text.
      :type isBinary: bool
      :param fragmentSize: Fragment message into WebSocket fragments of this size.
      :type fragmentSize: int
      :param sync: Iff `True`, try to force data onto the wire immediately. Note: do NOT use
                   this normally unless you know what you are doing. Performance likely will
                   suffer significantly. This feature is mainly here for use by Autobahn|Testsuite.
      :type sync: bool
      :param doNotCompress: Iff `True`, never compress this message. This only applies to
                            Hybi-Mode and only when WebSocket compression has been negotiated on
                            the WebSocket connection. Use when you know the payload 
                            uncompressible (e.g. encrypted or already compressed).
      :type doNotCompress: bool
      """


   @abc.abstractmethod
   def onMessage(self, payload, isBinary):
      """
      Callback fired when a complete WebSocket message was received.

      :param payload: Message payload (UTF-8 encoded text or binary). Can also be empty when
                      the WebSocket message contained no payload.
      :type payload: bytes
      :param isBinary: `True` iff payload is binary, else the payload is UTF-8 encoded text.
      :type isBinary: bool
      """


   @abc.abstractmethod
   def sendClose(self, code = None, reason = None):
      """
      Starts a WebSocket closing handshake tearing down the WebSocket connection.

      :param code: An optional close status code (`1000` for normal close or `3000-4999` for
                   application specific close).
      :type code: int
      :param reason: An optional close reason (a string that when present, a status
                     code MUST also be present).
      :type reason: str
      """


   @abc.abstractmethod
   def onClose(self, wasClean, code, reason):
      """
      Callback fired when the WebSocket connection has been closed (WebSocket closing
      handshake has been finished or the connection was closed uncleanly).

      :param wasClean: True, iff the WebSocket connection was closed cleanly.
      :type wasClean: bool
      :param code: None or close status code (as sent by the WebSocket peer).
      :type code: int
      :param reason: None or close reason (as sent by the WebSocket peer).
      :type reason: str
      """


   @abc.abstractmethod
   def sendPreparedMessage(self, preparedMsg):
      """
      Send a message that was previously prepared with :func:`autobahn.websocket.protocol.WebSocketFactory.prepareMessage`.

      :param prepareMessage: A previsouly prepared message.
      :type prepareMessage: Instance of :class:`autobahn.websocket.protocol.PreparedMessage`.
      """


   @abc.abstractmethod
   def sendPing(self, payload = None):
      """
      Send a WebSocket ping to the peer.

      A peer is expected to pong back the payload a soon as "practical". When more than
      one ping is outstanding at a peer, the peer may elect to respond only to the last ping.

      :param payload: An (optional) arbitrary payload of length `<126` octets.
      :type payload: bytes
      """


   @abc.abstractmethod
   def onPing(self, payload):
      """
      Callback fired when a WebSocket ping was received. A default implementation responds
      by sending a WebSocket pong.

      :param payload: Payload of ping (when there was any). Can be arbitrary, up to `125` octets.
      :type payload: bytes
      """


   @abc.abstractmethod
   def sendPong(self, payload = None):
      """
      Send a WebSocket pong to the peer.

      A WebSocket pong may be sent unsolicited. This serves as a unidirectional heartbeat.
      A response to an unsolicited pong is "not expected".

      :param payload: An (optional) arbitrary payload of length < 126 octets.
      :type payload: bytes
      """


   @abc.abstractmethod
   def onPong(self, payload):
      """
      Callback fired when a WebSocket pong was received. A default implementation does nothing.

      :param payload: Payload of pong (when there was any). Can be arbitrary, up to 125 octets.
      :type payload: bytes
      """



class IWebSocketChannelFrameApi(IWebSocketChannel):
   """
   Frame-based API to a WebSocket channel.
   """

   @abc.abstractmethod
   def onMessageBegin(self, isBinary):
      """
      Callback fired when receiving of a new WebSocket message has begun.

      :param isBinary: `True` iff payload is binary, else the payload is UTF-8 encoded text.
      :type isBinary: bool
      """


   @abc.abstractmethod
   def onMessageFrame(self, payload):
      """
      Callback fired when a complete WebSocket message frame for a previously begun
      WebSocket message has been received.

      :param payload: Message frame payload (a list of chunks received).
      :type payload: list of bytes
      """


   @abc.abstractmethod
   def onMessageEnd(self):
      """
      Callback fired when a WebSocket message has been completely received (the last
      WebSocket frame for that message has been received).
      """


   @abc.abstractmethod
   def beginMessage(self, isBinary = False, doNotCompress = False):
      """
      Begin sending a new WebSocket message.

      :param isBinary: `True` iff payload is binary, else the payload must be UTF-8 encoded text.
      :type isBinary: bool
      :param doNotCompress: Iff `True`, never compress this message. This only applies to
                            Hybi-Mode and only when WebSocket compression has been negotiated on
                            the WebSocket connection. Use when you know the payload 
                            uncompressible (e.g. encrypted or already compressed).
      :type doNotCompress: bool
      """


   @abc.abstractmethod
   def sendMessageFrame(self, payload, sync = False):
      """
      When a message has been previously begun, send a complete message frame in one go.

      :param payload: The message frame payload. When sending a text message, the payload must
                      be UTF-8 encoded already.
      :type payload: bytes
      :param sync: Iff `True`, try to force data onto the wire immediately. Note: do NOT use
                   this normally unless you know what you are doing. Performance likely will
                   suffer significantly. This feature is mainly here for use by Autobahn|Testsuite.
      :type sync: bool
      """


   @abc.abstractmethod
   def endMessage(self):
      """
      End a message previously begun message. No more frames may be sent (for that message).
      You have to begin a new message before sending again.
      """



class IWebSocketChannelStreamingApi(IWebSocketChannelFrameApi):
   """
   Streaming API to a WebSocket channel.
   """

   @abc.abstractmethod
   def onMessageFrameBegin(self, length):
      """
      Callback fired when receiving a new message frame has begun.
      A default implementation will prepare to buffer message frame data.

      :param length: Payload length of message frame which is subsequently received.
      :type length: int
      """


   @abc.abstractmethod
   def onMessageFrameData(self, payload):
      """
      Callback fired when receiving data within a previously begun message frame.
      A default implementation will buffer data for frame.

      :param payload: Partial payload for message frame.
      :type payload: bytes
      """


   @abc.abstractmethod
   def onMessageFrameEnd(self):
      """
      Callback fired when a previously begun message frame has been completely received.
      A default implementation will flatten the buffered frame data and
      fire `onMessageFrame`.
      """


   @abc.abstractmethod
   def beginMessageFrame(self, length):
      """
      Begin sending a new message frame.

      :param length: Length of the frame which is to be started. Must be `>= 0` and `<= 2^63`.
      :type length: int
      """


   @abc.abstractmethod
   def sendMessageFrameData(self, payload, sync = False):
      """
      Send out data when within a message frame (message was begun, frame was begun).
      Note that the frame is automatically ended when enough data has been sent.
      In other words, there is no `endMessageFrame`, since you have begun the frame
      specifying the frame length, which implicitly defined the frame end. This is different
      from messages, which you begin *and* end explicitly , since a message can contain
      an unlimited number of frames.

      :param payload: Frame payload to send.
      :type payload: bytes
      :param sync: Iff `True`, try to force data onto the wire immediately. Note: do NOT use
                   this normally unless you know what you are doing. Performance likely will
                   suffer significantly. This feature is mainly here for use by Autobahn|Testsuite.
      :type sync: bool

      :returns: int -- When the currently sent message frame is still incomplete,
                       returns octets remaining to be sent. When the frame is complete,
                       returns `0`, when `< 0`, the amount of unconsumed data in payload
                       argument.
      """

########NEW FILE########
__FILENAME__ = protocol
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

__all__ = ["createWsUrl",
           "parseWsUrl",

           "ConnectionRequest",
           "ConnectionResponse",
           "Timings",

           "WebSocketProtocol",
           "WebSocketFactory",
           "WebSocketServerProtocol",
           "WebSocketServerFactory",
           "WebSocketClientProtocol",
           "WebSocketClientFactory"]

import binascii
import hashlib
import base64
import struct
import random
import os
import pickle
import copy
import json
import six

from pprint import pformat
from collections import deque

from autobahn import __version__

from autobahn.websocket.interfaces import IWebSocketChannel, \
                                          IWebSocketChannelFrameApi, \
                                          IWebSocketChannelStreamingApi

from autobahn.util import Stopwatch
from autobahn.websocket.utf8validator import Utf8Validator
from autobahn.websocket.xormasker import XorMaskerNull, createXorMasker
from autobahn.websocket.compress import *
from autobahn.websocket import http

from six.moves import urllib

## The Python urlparse module currently does not contain the ws/wss
## schemes, so we add those dynamically (which is a hack of course).
## Since the urllib from six.moves does not seem to expose the stuff
## we monkey patch here, we do it manually.
##
## Important: if you change this stuff (you shouldn't), make sure
## _all_ our unit tests for WS URLs succeed
##
if not six.PY3:
   ## Python 2
   import urlparse
else:
   ## Python 3
   from urllib import parse as urlparse

wsschemes = ["ws", "wss"]
urlparse.uses_relative.extend(wsschemes)
urlparse.uses_netloc.extend(wsschemes)
urlparse.uses_params.extend(wsschemes)
urlparse.uses_query.extend(wsschemes)
urlparse.uses_fragment.extend(wsschemes)



def createWsUrl(hostname, port = None, isSecure = False, path = None, params = None):
   """
   Create a WebSocket URL from components.

   :param hostname: WebSocket server hostname.
   :type hostname: str
   :param port: WebSocket service port or None (to select default ports 80/443 depending on isSecure).
   :type port: int
   :param isSecure: Set True for secure WebSocket ("wss" scheme).
   :type isSecure: bool
   :param path: Path component of addressed resource (will be properly URL escaped).
   :type path: str
   :param params: A dictionary of key-values to construct the query component of the addressed resource (will be properly URL escaped).
   :type params: dict

   :returns: str -- Constructed WebSocket URL.
   """
   if port is not None:
      netloc = "%s:%d" % (hostname, port)
   else:
      if isSecure:
         netloc = "%s:443" % hostname
      else:
         netloc = "%s:80" % hostname
   if isSecure:
      scheme = "wss"
   else:
      scheme = "ws"
   if path is not None:
      ppath = urllib.parse.quote(path)
   else:
      ppath = "/"
   if params is not None:
      query = urllib.parse.urlencode(params)
   else:
      query = None
   return urllib.parse.urlunparse((scheme, netloc, ppath, None, query, None))



def parseWsUrl(url):
   """
   Parses as WebSocket URL into it's components and returns a tuple (isSecure, host, port, resource, path, params).

   isSecure is a flag which is True for wss URLs.
   host is the hostname or IP from the URL.
   port is the port from the URL or standard port derived from scheme (ws = 80, wss = 443).
   resource is the /resource name/ from the URL, the /path/ together with the (optional) /query/ component.
   path is the /path/ component properly unescaped.
   params is the /query) component properly unescaped and returned as dictionary.

   :param url: A valid WebSocket URL, i.e. `ws://localhost:9000/myresource?param1=23&param2=666`
   :type url: str

   :returns: tuple -- A tuple (isSecure, host, port, resource, path, params)
   """
   parsed = urlparse.urlparse(url)
   if not parsed.hostname or parsed.hostname == "":
      raise Exception("invalid WebSocket URL: missing hostname")
   if parsed.scheme not in ["ws", "wss"]:
      raise Exception("invalid WebSocket URL: bogus protocol scheme '%s'" % parsed.scheme)
   if parsed.port is None or parsed.port == "":
      if parsed.scheme == "ws":
         port = 80
      else:
         port = 443
   else:
      port = int(parsed.port)
   if parsed.fragment is not None and parsed.fragment != "":
      raise Exception("invalid WebSocket URL: non-empty fragment '%s" % parsed.fragment)
   if parsed.path is not None and parsed.path != "":
      ppath = parsed.path
      path = urllib.parse.unquote(ppath)
   else:
      ppath = "/"
      path = ppath
   if parsed.query is not None and parsed.query != "":
      resource = ppath + "?" + parsed.query
      params = urlparse.parse_qs(parsed.query)
   else:
      resource = ppath
      params = {}
   return (parsed.scheme == "wss", parsed.hostname, port, resource, path, params)



class TrafficStats:

   def __init__(self):
      self.reset()


   def reset(self):
      ## all of the following only tracks data messages, not control frames, not handshaking
      ##
      self.outgoingOctetsWireLevel = 0
      self.outgoingOctetsWebSocketLevel = 0
      self.outgoingOctetsAppLevel = 0
      self.outgoingWebSocketFrames = 0
      self.outgoingWebSocketMessages = 0

      self.incomingOctetsWireLevel = 0
      self.incomingOctetsWebSocketLevel = 0
      self.incomingOctetsAppLevel = 0
      self.incomingWebSocketFrames = 0
      self.incomingWebSocketMessages = 0

      ## the following track any traffic before the WebSocket connection
      ## reaches STATE_OPEN (this includes WebSocket opening handshake
      ## proxy handling and such)
      ##
      self.preopenOutgoingOctetsWireLevel = 0
      self.preopenIncomingOctetsWireLevel = 0


   def __json__(self):

      ## compression ratio = compressed size / uncompressed size
      ##
      if self.outgoingOctetsAppLevel > 0:
         outgoingCompressionRatio = float(self.outgoingOctetsWebSocketLevel) / float(self.outgoingOctetsAppLevel)
      else:
         outgoingCompressionRatio = None
      if self.incomingOctetsAppLevel > 0:
         incomingCompressionRatio = float(self.incomingOctetsWebSocketLevel) / float(self.incomingOctetsAppLevel)
      else:
         incomingCompressionRatio = None

      ## protocol overhead = non-payload size / payload size
      ##
      if self.outgoingOctetsWebSocketLevel > 0:
         outgoingWebSocketOverhead = float(self.outgoingOctetsWireLevel - self.outgoingOctetsWebSocketLevel) / float(self.outgoingOctetsWebSocketLevel)
      else:
         outgoingWebSocketOverhead = None
      if self.incomingOctetsWebSocketLevel > 0:
         incomingWebSocketOverhead = float(self.incomingOctetsWireLevel - self.incomingOctetsWebSocketLevel) / float(self.incomingOctetsWebSocketLevel)
      else:
         incomingWebSocketOverhead = None

      return {'outgoingOctetsWireLevel': self.outgoingOctetsWireLevel,
              'outgoingOctetsWebSocketLevel': self.outgoingOctetsWebSocketLevel,
              'outgoingOctetsAppLevel': self.outgoingOctetsAppLevel,
              'outgoingCompressionRatio': outgoingCompressionRatio,
              'outgoingWebSocketOverhead': outgoingWebSocketOverhead,
              'outgoingWebSocketFrames': self.outgoingWebSocketFrames,
              'outgoingWebSocketMessages': self.outgoingWebSocketMessages,
              'preopenOutgoingOctetsWireLevel': self.preopenOutgoingOctetsWireLevel,

              'incomingOctetsWireLevel': self.incomingOctetsWireLevel,
              'incomingOctetsWebSocketLevel': self.incomingOctetsWebSocketLevel,
              'incomingOctetsAppLevel': self.incomingOctetsAppLevel,
              'incomingCompressionRatio': incomingCompressionRatio,
              'incomingWebSocketOverhead': incomingWebSocketOverhead,
              'incomingWebSocketFrames': self.incomingWebSocketFrames,
              'incomingWebSocketMessages': self.incomingWebSocketMessages,
              'preopenIncomingOctetsWireLevel': self.preopenIncomingOctetsWireLevel}


   def __str__(self):
      return json.dumps(self.__json__())



class FrameHeader:
   """
   Thin-wrapper for storing WebSocket frame metadata.

   FOR INTERNAL USE ONLY!
   """

   def __init__(self, opcode, fin, rsv, length, mask):
      """
      Constructor.

      :param opcode: Frame opcode (0-15).
      :type opcode: int
      :param fin: Frame FIN flag.
      :type fin: bool
      :param rsv: Frame reserved flags (0-7).
      :type rsv: int
      :param length: Frame payload length.
      :type length: int
      :param mask: Frame mask (binary string) or None.
      :type mask: str
      """
      self.opcode = opcode
      self.fin = fin
      self.rsv = rsv
      self.length = length
      self.mask = mask



class ConnectionRequest:
   """
   Thin-wrapper for WebSocket connection request information provided in
   :meth:`autobahn.websocket.protocol.WebSocketServerProtocol.onConnect` when
   a WebSocket client want to establish a connection to a WebSocket server.
   """
   def __init__(self, peer, headers, host, path, params, version, origin, protocols, extensions):
      """
      Constructor.

      :param peer: Descriptor of the connecting client (eg IP address/port in case of TCP transports).
      :type peer: str
      :param headers: HTTP headers from opening handshake request.
      :type headers: dict
      :param host: Host from opening handshake HTTP header.
      :type host: str
      :param path: Path from requested HTTP resource URI. For example, a resource URI of `/myservice?foo=23&foo=66&bar=2` will be parsed to `/myservice`.
      :type path: str
      :param params: Query parameters (if any) from requested HTTP resource URI. For example, a resource URI of `/myservice?foo=23&foo=66&bar=2` will be parsed to `{'foo': ['23', '66'], 'bar': ['2']}`.
      :type params: dict of arrays of strings
      :param version: The WebSocket protocol version the client announced (and will be spoken, when connection is accepted).
      :type version: int
      :param origin: The WebSocket origin header or None. Note that this only a reliable source of information for browser clients!
      :type origin: str
      :param protocols: The WebSocket (sub)protocols the client announced. You must select and return one of those (or None) in :meth:`autobahn.websocket.WebSocketServerProtocol.onConnect`.
      :type protocols: array of strings
      :param extensions: The WebSocket extensions the client requested and the server accepted (and thus will be spoken, when WS connection is established).
      :type extensions: array of strings
      """
      self.peer = peer
      self.headers = headers
      self.host = host
      self.path = path
      self.params = params
      self.version = version
      self.origin = origin
      self.protocols = protocols
      self.extensions = extensions


   def __json__(self):
      return {'peer': self.peer,
              'headers': self.headers,
              'host': self.host,
              'path': self.path,
              'params': self.params,
              'version': self.version,
              'origin': self.origin,
              'protocols': self.protocols,
              'extensions': self.extensions}


   def __str__(self):
      return json.dumps(self.__json__())



class ConnectionResponse:
   """
   Thin-wrapper for WebSocket connection response information provided in
   :meth:`autobahn.websocket.protocol.WebSocketClientProtocol.onConnect` when
   a WebSocket server has accepted a connection request by a client.
   """
   def __init__(self, peer, headers, version, protocol, extensions):
      """
      Constructor.

      :param peer: Descriptor of the connected server (e.g. IP address/port in case of TCP transport).
      :type peer: str
      :param headers: HTTP headers from opening handshake response.
      :type headers: dict
      :param version: The WebSocket protocol version that is spoken.
      :type version: int
      :param protocol: The WebSocket (sub)protocol in use.
      :type protocol: str
      :param extensions: The WebSocket extensions in use.
      :type extensions: array of strings
      """
      self.peer = peer
      self.headers = headers
      self.version = version
      self.protocol = protocol
      self.extensions = extensions


   def __json__(self):
      return {'peer': self.peer,
              'headers': self.headers,
              'version': self.version,
              'protocol': self.protocol,
              'extensions': self.extensions}


   def __str__(self):
      return json.dumps(self.__json__())



def parseHttpHeader(data):
   """
   Parses the beginning of a HTTP request header (the data up to the \n\n line) into a pair
   of status line and HTTP headers dictionary.
   Header keys are normalized to all-lower-case.

   FOR INTERNAL USE ONLY!

   :param data: The HTTP header data up to the \n\n line.
   :type data: str

   :returns: tuple -- Tuple of HTTP status line, headers and headers count.
   """
   raw = data.decode('utf8').splitlines()
   http_status_line = raw[0].strip()
   http_headers = {}
   http_headers_cnt = {}
   for h in raw[1:]:
      i = h.find(":")
      if i > 0:
         ## HTTP header keys are case-insensitive
         key = h[:i].strip().lower()

         ## not sure if UTF-8 is allowed for HTTP header values..
         value = h[i+1:].strip()

         ## handle HTTP headers split across multiple lines
         if key in http_headers:
            http_headers[key] += ", %s" % value
            http_headers_cnt[key] += 1
         else:
            http_headers[key] = value
            http_headers_cnt[key] = 1
      else:
         # skip bad HTTP header
         pass
   return (http_status_line, http_headers, http_headers_cnt)



class Timings:
   """
   Helper class to track timings by key. This class also supports item access,
   iteration and conversion to string.
   """

   def __init__(self):
      self._stopwatch = Stopwatch()
      self._timings = {}

   def track(self, key):
      """
      Track elapsed for key.

      :param key: Key under which to track the timing.
      :type key: str
      """
      self._timings[key] = self._stopwatch.elapsed()

   def diff(self, startKey, endKey, format = True):
      """
      Get elapsed difference between two previously tracked keys.

      :param startKey: First key for interval (older timestamp).
      :type startKey: str
      :param endKey: Second key for interval (younger timestamp).
      :type endKey: str
      :param format: If `True`, format computed time period and return string.
      :type format: bool

      :returns: float or str -- Computed time period in seconds (or formatted string).
      """
      if endKey in self._timings and startKey in self._timings:
         d = self._timings[endKey] - self._timings[startKey]
         if format:
            if d < 0.00001: # 10us
               s = "%d ns" % round(d * 1000000000.)
            elif d < 0.01: # 10ms
               s = "%d us" % round(d * 1000000.)
            elif d < 10: # 10s
               s = "%d ms" % round(d * 1000.)
            else:
               s = "%d s" % round(d)
            return s.rjust(8)
         else:
            return d
      else:
         if format:
            return "n.a.".rjust(8)
         else:
            return None

   def __getitem__(self, key):
      return self._timings.get(key, None)

   def __iter__(self):
      return self._timings.__iter__(self)

   def __str__(self):
      return pformat(self._timings)



class WebSocketProtocol:
   """
   Protocol base class for WebSocket.

   This class implements:

     * :class:`autobahn.websocket.interfaces.IWebSocketChannel`
     * :class:`autobahn.websocket.interfaces.IWebSocketChannelFrameApi`
     * :class:`autobahn.websocket.interfaces.IWebSocketChannelStreamingApi`
   """

   SUPPORTED_SPEC_VERSIONS = [0, 10, 11, 12, 13, 14, 15, 16, 17, 18]
   """
   WebSocket protocol spec (draft) versions supported by this implementation.
   Use of version 18 indicates RFC6455. Use of versions < 18 indicate actual
   draft spec versions (Hybi-Drafts). Use of version 0 indicates Hixie-76.
   """

   SUPPORTED_PROTOCOL_VERSIONS = [0, 8, 13]
   """
   WebSocket protocol versions supported by this implementation. For Hixie-76,
   there is no protocol version announced in HTTP header, and we just use the
   draft version (0) in this case.
   """

   SPEC_TO_PROTOCOL_VERSION = {0: 0, 10: 8, 11: 8, 12: 8, 13: 13, 14: 13, 15: 13, 16: 13, 17: 13, 18: 13}
   """
   Mapping from protocol spec (draft) version to protocol version.  For Hixie-76,
   there is no protocol version announced in HTTP header, and we just use the
   pseudo protocol version 0 in this case.
   """

   PROTOCOL_TO_SPEC_VERSION = {0: 0, 8: 12, 13: 18}
   """
   Mapping from protocol version to the latest protocol spec (draft) version
   using that protocol version.  For Hixie-76, there is no protocol version
   announced in HTTP header, and we just use the draft version (0) in this case.
   """

   DEFAULT_SPEC_VERSION = 18
   """
   Default WebSocket protocol spec version this implementation speaks: final RFC6455.
   """

   DEFAULT_ALLOW_HIXIE76 = False
   """
   By default, this implementation will not allow to speak the obsoleted
   Hixie-76 protocol version. That protocol version has security issues, but
   is still spoken by some clients. Enable at your own risk! Enabling can be
   done by using setProtocolOptions() on the factories for clients and servers.
   """

   _WS_MAGIC = b"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
   """
   Protocol defined magic used during WebSocket handshake (used in Hybi-drafts
   and final RFC6455.
   """

   _QUEUED_WRITE_DELAY = 0.00001
   """
   For synched/chopped writes, this is the reactor reentry delay in seconds.
   """

   MESSAGE_TYPE_TEXT = 1
   """
   WebSocket text message type (UTF-8 payload).
   """

   MESSAGE_TYPE_BINARY = 2
   """
   WebSocket binary message type (arbitrary binary payload).
   """

   ## WebSocket protocol state:
   ## (STATE_PROXY_CONNECTING) => STATE_CONNECTING => STATE_OPEN => STATE_CLOSING => STATE_CLOSED
   ##
   STATE_CLOSED = 0
   STATE_CONNECTING = 1
   STATE_CLOSING = 2
   STATE_OPEN = 3
   STATE_PROXY_CONNECTING = 4

   ## Streaming Send State
   SEND_STATE_GROUND = 0
   SEND_STATE_MESSAGE_BEGIN = 1
   SEND_STATE_INSIDE_MESSAGE = 2
   SEND_STATE_INSIDE_MESSAGE_FRAME = 3

   ## WebSocket protocol close codes
   ##
   CLOSE_STATUS_CODE_NORMAL = 1000
   """Normal close of connection."""

   CLOSE_STATUS_CODE_GOING_AWAY = 1001
   """Going away."""

   CLOSE_STATUS_CODE_PROTOCOL_ERROR = 1002
   """Protocol error."""

   CLOSE_STATUS_CODE_UNSUPPORTED_DATA = 1003
   """Unsupported data."""

   CLOSE_STATUS_CODE_RESERVED1 = 1004
   """RESERVED"""

   CLOSE_STATUS_CODE_NULL = 1005 # MUST NOT be set in close frame!
   """No status received. (MUST NOT be used as status code when sending a close)."""

   CLOSE_STATUS_CODE_ABNORMAL_CLOSE = 1006 # MUST NOT be set in close frame!
   """Abnormal close of connection. (MUST NOT be used as status code when sending a close)."""

   CLOSE_STATUS_CODE_INVALID_PAYLOAD = 1007
   """Invalid frame payload data."""

   CLOSE_STATUS_CODE_POLICY_VIOLATION = 1008
   """Policy violation."""

   CLOSE_STATUS_CODE_MESSAGE_TOO_BIG = 1009
   """Message too big."""

   CLOSE_STATUS_CODE_MANDATORY_EXTENSION = 1010
   """Mandatory extension."""

   CLOSE_STATUS_CODE_INTERNAL_ERROR = 1011
   """The peer encountered an unexpected condition or internal error."""

   CLOSE_STATUS_CODE_TLS_HANDSHAKE_FAILED = 1015 # MUST NOT be set in close frame!
   """TLS handshake failed, i.e. server certificate could not be verified. (MUST NOT be used as status code when sending a close)."""

   CLOSE_STATUS_CODES_ALLOWED = [CLOSE_STATUS_CODE_NORMAL,
                                 CLOSE_STATUS_CODE_GOING_AWAY,
                                 CLOSE_STATUS_CODE_PROTOCOL_ERROR,
                                 CLOSE_STATUS_CODE_UNSUPPORTED_DATA,
                                 CLOSE_STATUS_CODE_INVALID_PAYLOAD,
                                 CLOSE_STATUS_CODE_POLICY_VIOLATION,
                                 CLOSE_STATUS_CODE_MESSAGE_TOO_BIG,
                                 CLOSE_STATUS_CODE_MANDATORY_EXTENSION,
                                 CLOSE_STATUS_CODE_INTERNAL_ERROR]
   """Status codes allowed to send in close."""


   CONFIG_ATTRS_COMMON = ['debug',
                          'debugCodePaths',
                          'logOctets',
                          'logFrames',
                          'trackTimings',
                          'allowHixie76',
                          'utf8validateIncoming',
                          'applyMask',
                          'maxFramePayloadSize',
                          'maxMessagePayloadSize',
                          'autoFragmentSize',
                          'failByDrop',
                          'echoCloseCodeReason',
                          'openHandshakeTimeout',
                          'closeHandshakeTimeout',
                          'tcpNoDelay']
   """
   Configuration attributes common to servers and clients.
   """

   CONFIG_ATTRS_SERVER = ['versions',
                          'webStatus',
                          'requireMaskedClientFrames',
                          'maskServerFrames',
                          'perMessageCompressionAccept']
   """
   Configuration attributes specific to servers.
   """

   CONFIG_ATTRS_CLIENT = ['version',
                          'acceptMaskedServerFrames',
                          'maskClientFrames',
                          'serverConnectionDropTimeout',
                          'perMessageCompressionOffers',
                          'perMessageCompressionAccept']
   """
   Configuration attributes specific to clients.
   """


   def onOpen(self):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.onOpen`
      """
      if self.debugCodePaths:
         self.factory._log("WebSocketProtocol.onOpen")


   def onMessageBegin(self, isBinary):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.onMessageBegin`
      """
      self.message_is_binary = isBinary
      self.message_data = []
      self.message_data_total_length = 0


   def onMessageFrameBegin(self, length):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.onMessageFrameBegin`
      """
      self.frame_length = length
      self.frame_data = []
      self.message_data_total_length += length
      if not self.failedByMe:
         if self.maxMessagePayloadSize > 0 and self.message_data_total_length > self.maxMessagePayloadSize:
            self.wasMaxMessagePayloadSizeExceeded = True
            self.failConnection(WebSocketProtocol.CLOSE_STATUS_CODE_MESSAGE_TOO_BIG, "message exceeds payload limit of %d octets" % self.maxMessagePayloadSize)
         elif self.maxFramePayloadSize > 0 and length > self.maxFramePayloadSize:
            self.wasMaxFramePayloadSizeExceeded = True
            self.failConnection(WebSocketProtocol.CLOSE_STATUS_CODE_POLICY_VIOLATION, "frame exceeds payload limit of %d octets" % self.maxFramePayloadSize)


   def onMessageFrameData(self, payload):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.onMessageFrameData`
      """
      if not self.failedByMe:
         if self.websocket_version == 0:
            self.message_data_total_length += len(payload)
            if self.maxMessagePayloadSize > 0 and self.message_data_total_length > self.maxMessagePayloadSize:
               self.wasMaxMessagePayloadSizeExceeded = True
               self.failConnection(WebSocketProtocol.CLOSE_STATUS_CODE_MESSAGE_TOO_BIG, "message exceeds payload limit of %d octets" % self.maxMessagePayloadSize)
            self.message_data.append(payload)
         else:
            self.frame_data.append(payload)


   def onMessageFrameEnd(self):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.onMessageFrameEnd`
      """
      if not self.failedByMe:
         self._onMessageFrame(self.frame_data)

      self.frame_data = None


   def onMessageFrame(self, payload):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.onMessageFrame`
      """
      if not self.failedByMe:
         self.message_data.extend(payload)


   def onMessageEnd(self):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.onMessageEnd`
      """
      if not self.failedByMe:
         payload = b''.join(self.message_data)
         if self.trackedTimings:
            self.trackedTimings.track("onMessage")
         self._onMessage(payload, self.message_is_binary)

      self.message_data = None


   def onMessage(self, payload, isBinary):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.onMessage`
      """
      if self.debug:
         self.factory._log("WebSocketProtocol.onMessage")


   def onPing(self, payload):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.onPing`
      """
      if self.debug:
         self.factory._log("WebSocketProtocol.onPing")
      if self.state == WebSocketProtocol.STATE_OPEN:
         self.sendPong(payload)


   def onPong(self, payload):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.onPong`
      """
      if self.debug:
         self.factory._log("WebSocketProtocol.onPong")


   def onClose(self, wasClean, code, reason):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.onClose`
      """
      if self.debugCodePaths:
         s = "WebSocketProtocol.onClose:\n"
         s += "wasClean=%s\n" % wasClean
         s += "code=%s\n" % code
         s += "reason=%s\n" % reason
         s += "self.closedByMe=%s\n" % self.closedByMe
         s += "self.failedByMe=%s\n" % self.failedByMe
         s += "self.droppedByMe=%s\n" % self.droppedByMe
         s += "self.wasClean=%s\n" % self.wasClean
         s += "self.wasNotCleanReason=%s\n" % self.wasNotCleanReason
         s += "self.localCloseCode=%s\n" % self.localCloseCode
         s += "self.localCloseReason=%s\n" % self.localCloseReason
         s += "self.remoteCloseCode=%s\n" % self.remoteCloseCode
         s += "self.remoteCloseReason=%s\n" % self.remoteCloseReason
         self.factory._log(s)


   def onCloseFrame(self, code, reasonRaw):
      """
      Callback when a Close frame was received. The default implementation answers by
      sending a Close when no Close was sent before. Otherwise it drops
      the TCP connection either immediately (when we are a server) or after a timeout
      (when we are a client and expect the server to drop the TCP).

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, this method is slightly misnamed for historic reasons.
        - For Hixie mode, code and reasonRaw are silently ignored.

      :param code: None or close status code, if there was one (:class:`WebSocketProtocol`.CLOSE_STATUS_CODE_*).
      :type code: int
      :param reason: None or close reason (when present, a status code MUST have been also be present).
      :type reason: str
      """
      if self.debugCodePaths:
         self.factory._log("WebSocketProtocol.onCloseFrame")

      self.remoteCloseCode = code

      ## reserved close codes: 0-999, 1004, 1005, 1006, 1011-2999, >= 5000
      ##
      if code is not None and (code < 1000 or (code >= 1000 and code <= 2999 and code not in WebSocketProtocol.CLOSE_STATUS_CODES_ALLOWED) or code >= 5000):
         if self.protocolViolation("invalid close code %d" % code):
            return True

      ## closing reason
      ##
      if reasonRaw is not None:
         ## we use our own UTF-8 validator to get consistent and fully conformant
         ## UTF-8 validation behavior
         u = Utf8Validator()
         val = u.validate(reasonRaw)
         if not val[0]:
            if self.invalidPayload("invalid close reason (non-UTF-8 payload)"):
               return True
         self.remoteCloseReason = reasonRaw.decode('utf8')

      if self.state == WebSocketProtocol.STATE_CLOSING:
         ## We already initiated the closing handshake, so this
         ## is the peer's reply to our close frame.

         ## cancel any closing HS timer if present
         ##
         if self.closeHandshakeTimeoutCall is not None:
            if self.debugCodePaths:
               self.factory._log("closeHandshakeTimeoutCall.cancel")
            self.closeHandshakeTimeoutCall.cancel()
            self.closeHandshakeTimeoutCall = None

         self.wasClean = True

         if self.factory.isServer:
            ## When we are a server, we immediately drop the TCP.
            self.dropConnection(abort = True)
         else:
            ## When we are a client, the server should drop the TCP
            ## If that doesn't happen, we do. And that will set wasClean = False.
            if self.serverConnectionDropTimeout > 0:
               self.serverConnectionDropTimeoutCall = self.factory._callLater(self.serverConnectionDropTimeout, self.onServerConnectionDropTimeout)

      elif self.state == WebSocketProtocol.STATE_OPEN:
         ## The peer initiates a closing handshake, so we reply
         ## by sending close frame.

         self.wasClean = True

         if self.websocket_version == 0:
            self.sendCloseFrame(isReply = True)
         else:
            ## Either reply with same code/reason, or code == NORMAL/reason=None
            if self.echoCloseCodeReason:
               self.sendCloseFrame(code = code, reasonUtf8 = reason.encode("UTF-8"), isReply = True)
            else:
               self.sendCloseFrame(code = WebSocketProtocol.CLOSE_STATUS_CODE_NORMAL, isReply = True)

         if self.factory.isServer:
            ## When we are a server, we immediately drop the TCP.
            self.dropConnection(abort = False)
         else:
            ## When we are a client, we expect the server to drop the TCP,
            ## and when the server fails to do so, a timeout in sendCloseFrame()
            ## will set wasClean = False back again.
            pass

      else:
         ## STATE_PROXY_CONNECTING, STATE_CONNECTING, STATE_CLOSED
         raise Exception("logic error")


   def onServerConnectionDropTimeout(self):
      """
      We (a client) expected the peer (a server) to drop the connection,
      but it didn't (in time self.serverConnectionDropTimeout).
      So we drop the connection, but set self.wasClean = False.

      Modes: Hybi, Hixie
      """
      self.serverConnectionDropTimeoutCall = None
      if self.state != WebSocketProtocol.STATE_CLOSED:
         if self.debugCodePaths:
            self.factory._log("onServerConnectionDropTimeout")
         self.wasClean = False
         self.wasNotCleanReason = "server did not drop TCP connection (in time)"
         self.wasServerConnectionDropTimeout = True
         self.dropConnection(abort = True)
      else:
         if self.debugCodePaths:
            self.factory._log("skipping onServerConnectionDropTimeout since connection is already closed")


   def onOpenHandshakeTimeout(self):
      """
      We expected the peer to complete the opening handshake with to us.
      It didn't do so (in time self.openHandshakeTimeout).
      So we drop the connection, but set self.wasClean = False.

      Modes: Hybi, Hixie
      """
      self.openHandshakeTimeoutCall = None
      if self.state in [WebSocketProtocol.STATE_CONNECTING, WebSocketProtocol.STATE_PROXY_CONNECTING]:
         if self.debugCodePaths:
            self.factory._log("onOpenHandshakeTimeout fired")
         self.wasClean = False
         self.wasNotCleanReason = "peer did not finish (in time) the opening handshake"
         self.wasOpenHandshakeTimeout = True
         self.dropConnection(abort = True)
      elif self.state == WebSocketProtocol.STATE_OPEN:
         if self.debugCodePaths:
            self.factory._log("skipping onOpenHandshakeTimeout since WebSocket connection is open (opening handshake already finished)")
      elif self.state == WebSocketProtocol.STATE_CLOSING:
         if self.debugCodePaths:
            self.factory._log("skipping onOpenHandshakeTimeout since WebSocket connection is closing")
      elif self.state == WebSocketProtocol.STATE_CLOSED:
         if self.debugCodePaths:
            self.factory._log("skipping onOpenHandshakeTimeout since WebSocket connection already closed")
      else:
         # should not arrive here
         raise Exception("logic error")


   def onCloseHandshakeTimeout(self):
      """
      We expected the peer to respond to us initiating a close handshake. It didn't
      respond (in time self.closeHandshakeTimeout) with a close response frame though.
      So we drop the connection, but set self.wasClean = False.

      Modes: Hybi, Hixie
      """
      self.closeHandshakeTimeoutCall = None
      if self.state != WebSocketProtocol.STATE_CLOSED:
         if self.debugCodePaths:
            self.factory._log("onCloseHandshakeTimeout fired")
         self.wasClean = False
         self.wasNotCleanReason = "peer did not respond (in time) in closing handshake"
         self.wasCloseHandshakeTimeout = True
         self.dropConnection(abort = True)
      else:
         if self.debugCodePaths:
            self.factory._log("skipping onCloseHandshakeTimeout since connection is already closed")


   def dropConnection(self, abort = False):
      """
      Drop the underlying TCP connection.

      Modes: Hybi, Hixie
      """
      if self.state != WebSocketProtocol.STATE_CLOSED:
         if self.debugCodePaths:
            self.factory._log("dropping connection")
         self.droppedByMe = True
         self.state = WebSocketProtocol.STATE_CLOSED

         self._closeConnection(abort)
      else:
         if self.debugCodePaths:
            self.factory._log("skipping dropConnection since connection is already closed")


   def failConnection(self, code = CLOSE_STATUS_CODE_GOING_AWAY, reason = "Going Away"):
      """
      Fails the WebSocket connection.

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, the code and reason are silently ignored.
      """
      if self.state != WebSocketProtocol.STATE_CLOSED:
         if self.debugCodePaths:
            self.factory._log("Failing connection : %s - %s" % (code, reason))

         self.failedByMe = True

         if self.failByDrop:
            ## brutally drop the TCP connection
            self.wasClean = False
            self.wasNotCleanReason = "I failed the WebSocket connection by dropping the TCP connection"
            self.dropConnection(abort = True)

         else:
            if self.state != WebSocketProtocol.STATE_CLOSING:
               ## perform WebSocket closing handshake
               self.sendCloseFrame(code = code, reasonUtf8 = reason.encode("UTF-8")[:125-2], isReply = False)
            else:
               ## already performing closing handshake .. we now drop the TCP
               ## (this can happen e.g. if we encounter a 2nd protocol violation during closing HS)
               self.dropConnection(abort = False)

      else:
         if self.debugCodePaths:
            self.factory._log("skipping failConnection since connection is already closed")


   def protocolViolation(self, reason):
      """
      Fired when a WebSocket protocol violation/error occurs.

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, reason is silently ignored.

      :param reason: Protocol violation that was encountered (human readable).
      :type reason: str

      :returns: bool -- True, when any further processing should be discontinued.
      """
      if self.debugCodePaths:
         self.factory._log("Protocol violation : %s" % reason)
      self.failConnection(WebSocketProtocol.CLOSE_STATUS_CODE_PROTOCOL_ERROR, reason)
      if self.failByDrop:
         return True
      else:
         ## if we don't immediately drop the TCP, we need to skip the invalid frame
         ## to continue to later receive the closing handshake reply
         return False


   def invalidPayload(self, reason):
      """
      Fired when invalid payload is encountered. Currently, this only happens
      for text message when payload is invalid UTF-8 or close frames with
      close reason that is invalid UTF-8.

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, reason is silently ignored.

      :param reason: What was invalid for the payload (human readable).
      :type reason: str

      :returns: bool -- True, when any further processing should be discontinued.
      """
      if self.debugCodePaths:
         self.factory._log("Invalid payload : %s" % reason)
      self.failConnection(WebSocketProtocol.CLOSE_STATUS_CODE_INVALID_PAYLOAD, reason)
      if self.failByDrop:
         return True
      else:
         ## if we don't immediately drop the TCP, we need to skip the invalid frame
         ## to continue to later receive the closing handshake reply
         return False


   def setTrackTimings(self, enable):
      """
      Enable/disable tracking of detailed timings.

      :param enable: Turn time tracking on/off.
      :type enable: bool
      """
      if not hasattr(self, 'trackTimings') or self.trackTimings != enable:
         self.trackTimings = enable
         if self.trackTimings:
            self.trackedTimings = Timings()
         else:
            self.trackedTimings = None


   def _connectionMade(self):
      """
      This is called by network framework when a new TCP connection has been established
      and handed over to a Protocol instance (an instance of this class).

      Modes: Hybi, Hixie
      """

      ## copy default options from factory (so we are not affected by changed on
      ## those), but only copy if not already set on protocol instance (allow
      ## to set configuration individually)
      ##
      configAttrLog = []
      for configAttr in self.CONFIG_ATTRS:
         if not hasattr(self, configAttr):
            setattr(self, configAttr, getattr(self.factory, configAttr))
            configAttrSource = self.factory.__class__.__name__
         else:
            configAttrSource = self.__class__.__name__
         configAttrLog.append((configAttr, getattr(self, configAttr), configAttrSource))

      if self.debug:
         #self.factory._log(configAttrLog)
         self.factory._log("\n" + pformat(configAttrLog))

      ## permessage-compress extension
      self._perMessageCompress = None

      ## Time tracking
      self.trackedTimings = None
      self.setTrackTimings(self.trackTimings)

      ## Traffic stats
      self.trafficStats = TrafficStats()

      ## initial state
      if not self.factory.isServer and self.factory.proxy is not None:
         self.state = WebSocketProtocol.STATE_PROXY_CONNECTING
      else:
         self.state = WebSocketProtocol.STATE_CONNECTING
      self.send_state = WebSocketProtocol.SEND_STATE_GROUND
      self.data = b""

      ## for chopped/synched sends, we need to queue to maintain
      ## ordering when recalling the reactor to actually "force"
      ## the octets to wire (see test/trickling in the repo)
      self.send_queue = deque()
      self.triggered = False

      ## incremental UTF8 validator
      self.utf8validator = Utf8Validator()

      ## track when frame/message payload sizes (incoming) were exceeded
      self.wasMaxFramePayloadSizeExceeded = False
      self.wasMaxMessagePayloadSizeExceeded = False

      ## the following vars are related to connection close handling/tracking

      # True, iff I have initiated closing HS (that is, did send close first)
      self.closedByMe = False

      # True, iff I have failed the WS connection (i.e. due to protocol error)
      # Failing can be either by initiating close HS or brutal drop (this is
      # controlled by failByDrop option)
      self.failedByMe = False

      # True, iff I dropped the TCP connection (called transport.loseConnection())
      self.droppedByMe = False

      # True, iff full WebSocket closing handshake was performed (close frame sent
      # and received) _and_ the server dropped the TCP (which is its responsibility)
      self.wasClean = False

      # When self.wasClean = False, the reason (what happened)
      self.wasNotCleanReason = None

      # When we are a client, and we expected the server to drop the TCP, but that
      # didn't happen in time, this gets True
      self.wasServerConnectionDropTimeout = False

      # When the initial WebSocket opening handshake times out, this gets True
      self.wasOpenHandshakeTimeout = False

      # When we initiated a closing handshake, but the peer did not respond in
      # time, this gets True
      self.wasCloseHandshakeTimeout = False

      # The close code I sent in close frame (if any)
      self.localCloseCode = None

      # The close reason I sent in close frame (if any)
      self.localCloseReason = None

      # The close code the peer sent me in close frame (if any)
      self.remoteCloseCode = None

      # The close reason the peer sent me in close frame (if any)
      self.remoteCloseReason = None

      # timers, which might get set up later, and remembered here to get canceled
      # when appropriate
      if not self.factory.isServer:
         self.serverConnectionDropTimeoutCall = None
      self.openHandshakeTimeoutCall = None
      self.closeHandshakeTimeoutCall = None

      # set opening handshake timeout handler
      if self.openHandshakeTimeout > 0:
         self.openHandshakeTimeoutCall = self.factory._callLater(self.openHandshakeTimeout, self.onOpenHandshakeTimeout)


   def _connectionLost(self, reason):
      """
      This is called by network framework when a transport connection was lost.

      Modes: Hybi, Hixie
      """
      ## cancel any server connection drop timer if present
      ##
      if not self.factory.isServer and self.serverConnectionDropTimeoutCall is not None:
         if self.debugCodePaths:
            self.factory._log("serverConnectionDropTimeoutCall.cancel")
         self.serverConnectionDropTimeoutCall.cancel()
         self.serverConnectionDropTimeoutCall = None

      self.state = WebSocketProtocol.STATE_CLOSED
      if not self.wasClean:
         if not self.droppedByMe and self.wasNotCleanReason is None:
            self.wasNotCleanReason = "peer dropped the TCP connection without previous WebSocket closing handshake"
         self._onClose(self.wasClean, WebSocketProtocol.CLOSE_STATUS_CODE_ABNORMAL_CLOSE, "connection was closed uncleanly (%s)" % self.wasNotCleanReason)
      else:
         self._onClose(self.wasClean, self.remoteCloseCode, self.remoteCloseReason)


   def logRxOctets(self, data):
      """
      Hook fired right after raw octets have been received, but only when self.logOctets == True.

      Modes: Hybi, Hixie
      """
      self.factory._log("RX Octets from %s : octets = %s" % (self.peer, binascii.b2a_hex(data)))


   def logTxOctets(self, data, sync):
      """
      Hook fired right after raw octets have been sent, but only when self.logOctets == True.

      Modes: Hybi, Hixie
      """
      self.factory._log("TX Octets to %s : sync = %s, octets = %s" % (self.peer, sync, binascii.b2a_hex(data)))


   def logRxFrame(self, frameHeader, payload):
      """
      Hook fired right after WebSocket frame has been received and decoded, but only when self.logFrames == True.

      Modes: Hybi
      """
      data = b''.join(payload)
      info = (self.peer,
              frameHeader.fin,
              frameHeader.rsv,
              frameHeader.opcode,
              binascii.b2a_hex(frameHeader.mask) if frameHeader.mask else "-",
              frameHeader.length,
              data if frameHeader.opcode == 1 else binascii.b2a_hex(data))

      self.factory._log("RX Frame from %s : fin = %s, rsv = %s, opcode = %s, mask = %s, length = %s, payload = %s" % info)


   def logTxFrame(self, frameHeader, payload, repeatLength, chopsize, sync):
      """
      Hook fired right after WebSocket frame has been encoded and sent, but only when self.logFrames == True.

      Modes: Hybi
      """
      info = (self.peer,
              frameHeader.fin,
              frameHeader.rsv,
              frameHeader.opcode,
              binascii.b2a_hex(frameHeader.mask) if frameHeader.mask else "-",
              frameHeader.length,
              repeatLength,
              chopsize,
              sync,
              payload if frameHeader.opcode == 1 else binascii.b2a_hex(payload))

      self.factory._log("TX Frame to %s : fin = %s, rsv = %s, opcode = %s, mask = %s, length = %s, repeat_length = %s, chopsize = %s, sync = %s, payload = %s" % info)


   def _dataReceived(self, data):
      """
      This is called by network framework upon receiving data on transport connection.

      Modes: Hybi, Hixie
      """
      if self.state == WebSocketProtocol.STATE_OPEN:
         self.trafficStats.incomingOctetsWireLevel += len(data)
      elif self.state == WebSocketProtocol.STATE_CONNECTING or self.state == WebSocketProtocol.STATE_PROXY_CONNECTING:
         self.trafficStats.preopenIncomingOctetsWireLevel += len(data)

      if self.logOctets:
         self.logRxOctets(data)
      self.data += data
      self.consumeData()


   def consumeData(self):
      """
      Consume buffered (incoming) data.

      Modes: Hybi, Hixie
      """

      ## WebSocket is open (handshake was completed) or close was sent
      ##
      if self.state == WebSocketProtocol.STATE_OPEN or self.state == WebSocketProtocol.STATE_CLOSING:

         ## process until no more buffered data left or WS was closed
         ##
         while self.processData() and self.state != WebSocketProtocol.STATE_CLOSED:
            pass

      ## need to establish proxy connection
      ##
      elif self.state == WebSocketProtocol.STATE_PROXY_CONNECTING:

         self.processProxyConnect()

      ## WebSocket needs handshake
      ##
      elif self.state == WebSocketProtocol.STATE_CONNECTING:

         ## the implementation of processHandshake() in derived
         ## class needs to perform client or server handshake
         ## from other party here ..
         ##
         self.processHandshake()

      ## we failed the connection .. don't process any more data!
      ##
      elif self.state == WebSocketProtocol.STATE_CLOSED:

         ## ignore any data received after WS was closed
         ##
         if self.debugCodePaths:
            self.factory._log("received data in STATE_CLOSED")

      ## should not arrive here (invalid state)
      ##
      else:
         raise Exception("invalid state")


   def processProxyConnect(self):
      """
      Process proxy connect.

      Modes: Hybi, Hixie
      """
      raise Exception("must implement proxy connect (client or server) in derived class")


   def processHandshake(self):
      """
      Process WebSocket handshake.

      Modes: Hybi, Hixie
      """
      raise Exception("must implement handshake (client or server) in derived class")


   def _trigger(self):
      """
      Trigger sending stuff from send queue (which is only used for chopped/synched writes).

      Modes: Hybi, Hixie
      """
      if not self.triggered:
         self.triggered = True
         self._send()


   def _send(self):
      """
      Send out stuff from send queue. For details how this works, see test/trickling
      in the repo.

      Modes: Hybi, Hixie
      """
      if len(self.send_queue) > 0:
         e = self.send_queue.popleft()

         if self.state != WebSocketProtocol.STATE_CLOSED:

            self.transport.write(e[0])

            if self.state == WebSocketProtocol.STATE_OPEN:
               self.trafficStats.outgoingOctetsWireLevel += len(e[0])
            elif self.state == WebSocketProtocol.STATE_CONNECTING or self.state == WebSocketProtocol.STATE_PROXY_CONNECTING:
               self.trafficStats.preopenOutgoingOctetsWireLevel += len(e[0])

            if self.logOctets:
               self.logTxOctets(e[0], e[1])
         else:
            if self.debugCodePaths:
               self.factory._log("skipped delayed write, since connection is closed")
         # we need to reenter the reactor to make the latter
         # reenter the OS network stack, so that octets
         # can get on the wire. Note: this is a "heuristic",
         # since there is no (easy) way to really force out
         # octets from the OS network stack to wire.
         self.factory._callLater(WebSocketProtocol._QUEUED_WRITE_DELAY, self._send)
      else:
         self.triggered = False


   def sendData(self, data, sync = False, chopsize = None):
      """
      Wrapper for self.transport.write which allows to give a chopsize.
      When asked to chop up writing to TCP stream, we write only chopsize octets
      and then give up control to select() in underlying reactor so that bytes
      get onto wire immediately. Note that this is different from and unrelated
      to WebSocket data message fragmentation. Note that this is also different
      from the TcpNoDelay option which can be set on the socket.

      Modes: Hybi, Hixie
      """
      if chopsize and chopsize > 0:
         i = 0
         n = len(data)
         done = False
         while not done:
            j = i + chopsize
            if j >= n:
               done = True
               j = n
            self.send_queue.append((data[i:j], True))
            i += chopsize
         self._trigger()
      else:
         if sync or len(self.send_queue) > 0:
            self.send_queue.append((data, sync))
            self._trigger()
         else:
            self.transport.write(data)

            if self.state == WebSocketProtocol.STATE_OPEN:
               self.trafficStats.outgoingOctetsWireLevel += len(data)
            elif self.state == WebSocketProtocol.STATE_CONNECTING or self.state == WebSocketProtocol.STATE_PROXY_CONNECTING:
               self.trafficStats.preopenOutgoingOctetsWireLevel += len(data)

            if self.logOctets:
               self.logTxOctets(data, False)


   def sendPreparedMessage(self, preparedMsg):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.sendPreparedMessage`
      """
      if self.websocket_version != 0:
         if self._perMessageCompress is None or preparedMsg.doNotCompress:
            self.sendData(preparedMsg.payloadHybi)
         else:
            self.sendMessage(preparedMsg.payload, preparedMsg.binary)
      else:
         self.sendData(preparedMsg.payloadHixie)


   def processData(self):
      """
      After WebSocket handshake has been completed, this procedure will do all
      subsequent processing of incoming bytes.

      Modes: Hybi, Hixie
      """
      if self.websocket_version == 0:
         return self.processDataHixie76()
      else:
         return self.processDataHybi()


   def processDataHixie76(self):
      """
      Hixie-76 incoming data processing.

      Modes: Hixie
      """
      buffered_len = len(self.data)

      ## outside a message, that is we are awaiting data which starts a new message
      ##
      if not self.inside_message:
         if buffered_len >= 2:

            ## new message
            ##
            if self.data[0] == b'\x00':

               self.inside_message = True

               if self.utf8validateIncoming:
                  self.utf8validator.reset()
                  self.utf8validateIncomingCurrentMessage = True
                  self.utf8validateLast = (True, True, 0, 0)
               else:
                  self.utf8validateIncomingCurrentMessage = False

               self.data = self.data[1:]
               if self.trackedTimings:
                  self.trackedTimings.track("onMessageBegin")
               self._onMessageBegin(False)

            ## Hixie close from peer received
            ##
            elif self.data[0] == b'\xff' and self.data[1] == b'\x00':
               self.onCloseFrame(None, None)
               self.data = self.data[2:]
               # stop receiving/processing after having received close!
               return False

            ## malformed data
            ##
            else:
               if self.protocolViolation("malformed data received"):
                  return False
         else:
            ## need more data
            return False

      end_index = self.data.find(b'\xff')
      if end_index > 0:
         payload = self.data[:end_index]
         self.data = self.data[end_index + 1:]
      else:
         payload = self.data
         self.data = b''

      ## incrementally validate UTF-8 payload
      ##
      if self.utf8validateIncomingCurrentMessage:
         self.utf8validateLast = self.utf8validator.validate(payload)
         if not self.utf8validateLast[0]:
            if self.invalidPayload("encountered invalid UTF-8 while processing text message at payload octet index %d" % self.utf8validateLast[3]):
               return False

      self._onMessageFrameData(payload)

      if end_index > 0:
         self.inside_message = False
         self._onMessageEnd()

      return len(self.data) > 0


   def processDataHybi(self):
      """
      RFC6455/Hybi-Drafts incoming data processing.

      Modes: Hybi
      """
      buffered_len = len(self.data)

      ## outside a frame, that is we are awaiting data which starts a new frame
      ##
      if self.current_frame is None:

         ## need minimum of 2 octets to for new frame
         ##
         if buffered_len >= 2:

            ## FIN, RSV, OPCODE
            ##
            if six.PY3:
               b = self.data[0]
            else:
               b = ord(self.data[0])
            frame_fin = (b & 0x80) != 0
            frame_rsv = (b & 0x70) >> 4
            frame_opcode = b & 0x0f

            ## MASK, PAYLOAD LEN 1
            ##
            if six.PY3:
               b = self.data[1]
            else:
               b = ord(self.data[1])
            frame_masked = (b & 0x80) != 0
            frame_payload_len1 = b & 0x7f

            ## MUST be 0 when no extension defining
            ## the semantics of RSV has been negotiated
            ##
            if frame_rsv != 0:
               if self._perMessageCompress is not None and frame_rsv == 4:
                  pass
               else:
                  if self.protocolViolation("RSV = %d and no extension negotiated" % frame_rsv):
                     return False

            ## all client-to-server frames MUST be masked
            ##
            if self.factory.isServer and self.requireMaskedClientFrames and not frame_masked:
               if self.protocolViolation("unmasked client-to-server frame"):
                  return False

            ## all server-to-client frames MUST NOT be masked
            ##
            if not self.factory.isServer and not self.acceptMaskedServerFrames and frame_masked:
               if self.protocolViolation("masked server-to-client frame"):
                  return False

            ## check frame
            ##
            if frame_opcode > 7: # control frame (have MSB in opcode set)

               ## control frames MUST NOT be fragmented
               ##
               if not frame_fin:
                  if self.protocolViolation("fragmented control frame"):
                     return False

               ## control frames MUST have payload 125 octets or less
               ##
               if frame_payload_len1 > 125:
                  if self.protocolViolation("control frame with payload length > 125 octets"):
                     return False

               ## check for reserved control frame opcodes
               ##
               if frame_opcode not in [8, 9, 10]:
                  if self.protocolViolation("control frame using reserved opcode %d" % frame_opcode):
                     return False

               ## close frame : if there is a body, the first two bytes of the body MUST be a 2-byte
               ## unsigned integer (in network byte order) representing a status code
               ##
               if frame_opcode == 8 and frame_payload_len1 == 1:
                  if self.protocolViolation("received close control frame with payload len 1"):
                     return False

               ## control frames MUST NOT be compressed
               ##
               if self._perMessageCompress is not None and frame_rsv == 4:
                  if self.protocolViolation("received compressed control frame [%s]" % self._perMessageCompress.EXTENSION_NAME):
                     return False

            else: # data frame

               ## check for reserved data frame opcodes
               ##
               if frame_opcode not in [0, 1, 2]:
                  if self.protocolViolation("data frame using reserved opcode %d" % frame_opcode):
                     return False

               ## check opcode vs message fragmentation state 1/2
               ##
               if not self.inside_message and frame_opcode == 0:
                  if self.protocolViolation("received continuation data frame outside fragmented message"):
                     return False

               ## check opcode vs message fragmentation state 2/2
               ##
               if self.inside_message and frame_opcode != 0:
                  if self.protocolViolation("received non-continuation data frame while inside fragmented message"):
                     return False

               ## continuation data frames MUST NOT have the compressed bit set
               ##
               if self._perMessageCompress is not None and frame_rsv == 4 and self.inside_message:
                  if self.protocolViolation("received continution data frame with compress bit set [%s]" % self._perMessageCompress.EXTENSION_NAME):
                     return False

            ## compute complete header length
            ##
            if frame_masked:
               mask_len = 4
            else:
               mask_len = 0

            if frame_payload_len1 <  126:
               frame_header_len = 2 + mask_len
            elif frame_payload_len1 == 126:
               frame_header_len = 2 + 2 + mask_len
            elif frame_payload_len1 == 127:
               frame_header_len = 2 + 8 + mask_len
            else:
               raise Exception("logic error")

            ## only proceed when we have enough data buffered for complete
            ## frame header (which includes extended payload len + mask)
            ##
            if buffered_len >= frame_header_len:

               ## minimum frame header length (already consumed)
               ##
               i = 2

               ## extract extended payload length
               ##
               if frame_payload_len1 == 126:
                  frame_payload_len = struct.unpack("!H", self.data[i:i+2])[0]
                  if frame_payload_len < 126:
                     if self.protocolViolation("invalid data frame length (not using minimal length encoding)"):
                        return False
                  i += 2
               elif frame_payload_len1 == 127:
                  frame_payload_len = struct.unpack("!Q", self.data[i:i+8])[0]
                  if frame_payload_len > 0x7FFFFFFFFFFFFFFF: # 2**63
                     if self.protocolViolation("invalid data frame length (>2^63)"):
                        return False
                  if frame_payload_len < 65536:
                     if self.protocolViolation("invalid data frame length (not using minimal length encoding)"):
                        return False
                  i += 8
               else:
                  frame_payload_len = frame_payload_len1

               ## when payload is masked, extract frame mask
               ##
               frame_mask = None
               if frame_masked:
                  frame_mask = self.data[i:i+4]
                  i += 4

               if frame_masked and frame_payload_len > 0 and self.applyMask:
                  self.current_frame_masker = createXorMasker(frame_mask, frame_payload_len)
               else:
                  self.current_frame_masker = XorMaskerNull()


               ## remember rest (payload of current frame after header and everything thereafter)
               ##
               self.data = self.data[i:]

               ## ok, got complete frame header
               ##
               self.current_frame = FrameHeader(frame_opcode,
                                                frame_fin,
                                                frame_rsv,
                                                frame_payload_len,
                                                frame_mask)

               ## process begin on new frame
               ##
               self.onFrameBegin()

               ## reprocess when frame has no payload or and buffered data left
               ##
               return frame_payload_len == 0 or len(self.data) > 0

            else:
               return False # need more data
         else:
            return False # need more data

      ## inside a started frame
      ##
      else:

         ## cut out rest of frame payload
         ##
         rest = self.current_frame.length - self.current_frame_masker.pointer()
         if buffered_len >= rest:
            data = self.data[:rest]
            length = rest
            self.data = self.data[rest:]
         else:
            data = self.data
            length = buffered_len
            self.data = b''

         if length > 0:
            ## unmask payload
            ##
            payload = self.current_frame_masker.process(data)
         else:
            ## we also process empty payloads, since we need to fire
            ## our hooks (at least for streaming processing, this is
            ## necessary for correct protocol state transitioning)
            ##
            payload = b''

         ## process frame data
         ##
         fr = self.onFrameData(payload)
         if fr == False:
            return False

         ## fire frame end handler when frame payload is complete
         ##
         if self.current_frame_masker.pointer() == self.current_frame.length:
            fr = self.onFrameEnd()
            if fr == False:
               return False

         ## reprocess when no error occurred and buffered data left
         ##
         return len(self.data) > 0


   def onFrameBegin(self):
      """
      Begin of receive new frame.

      Modes: Hybi
      """
      if self.current_frame.opcode > 7:
         self.control_frame_data = []
      else:
         ## new message started
         ##
         if not self.inside_message:

            self.inside_message = True

            ## setup decompressor
            ##
            if self._perMessageCompress is not None and self.current_frame.rsv == 4:
               self._isMessageCompressed = True
               self._perMessageCompress.startDecompressMessage()
            else:
               self._isMessageCompressed = False

            ## setup UTF8 validator
            ##
            if self.current_frame.opcode == WebSocketProtocol.MESSAGE_TYPE_TEXT and self.utf8validateIncoming:
               self.utf8validator.reset()
               self.utf8validateIncomingCurrentMessage = True
               self.utf8validateLast = (True, True, 0, 0)
            else:
               self.utf8validateIncomingCurrentMessage = False

            ## track timings
            ##
            if self.trackedTimings:
               self.trackedTimings.track("onMessageBegin")

            ## fire onMessageBegin
            ##
            self._onMessageBegin(self.current_frame.opcode == WebSocketProtocol.MESSAGE_TYPE_BINARY)

         self._onMessageFrameBegin(self.current_frame.length)


   def onFrameData(self, payload):
      """
      New data received within frame.

      Modes: Hybi
      """
      if self.current_frame.opcode > 7:
         self.control_frame_data.append(payload)
      else:
         ## decompress frame payload
         ##
         if self._isMessageCompressed:
            compressedLen = len(payload)
            if self.debug:
               self.factory._log("RX compressed [%d]: %s" % (compressedLen, binascii.b2a_hex(payload)))

            payload = self._perMessageCompress.decompressMessageData(payload)
            uncompressedLen = len(payload)
         else:
            l = len(payload)
            compressedLen = l
            uncompressedLen = l

         if self.state == WebSocketProtocol.STATE_OPEN:
            self.trafficStats.incomingOctetsWebSocketLevel += compressedLen
            self.trafficStats.incomingOctetsAppLevel += uncompressedLen

         ## incrementally validate UTF-8 payload
         ##
         if self.utf8validateIncomingCurrentMessage:
            self.utf8validateLast = self.utf8validator.validate(payload)
            if not self.utf8validateLast[0]:
               if self.invalidPayload("encountered invalid UTF-8 while processing text message at payload octet index %d" % self.utf8validateLast[3]):
                  return False

         self._onMessageFrameData(payload)


   def onFrameEnd(self):
      """
      End of frame received.

      Modes: Hybi
      """
      if self.current_frame.opcode > 7:
         if self.logFrames:
            self.logRxFrame(self.current_frame, self.control_frame_data)
         self.processControlFrame()
      else:
         if self.state == WebSocketProtocol.STATE_OPEN:
            self.trafficStats.incomingWebSocketFrames += 1
         if self.logFrames:
            self.logRxFrame(self.current_frame, self.frame_data)

         self._onMessageFrameEnd()

         if self.current_frame.fin:

            ## handle end of compressed message
            ##
            if self._isMessageCompressed:
               self._perMessageCompress.endDecompressMessage()

            ## verify UTF8 has actually ended
            ##
            if self.utf8validateIncomingCurrentMessage:
               if not self.utf8validateLast[1]:
                  if self.invalidPayload("UTF-8 text message payload ended within Unicode code point at payload octet index %d" % self.utf8validateLast[3]):
                     return False

            #if self.debug:
            #   self.factory._log("Traffic statistics:\n" + str(self.trafficStats))

            if self.state == WebSocketProtocol.STATE_OPEN:
               self.trafficStats.incomingWebSocketMessages += 1

            self._onMessageEnd()
            self.inside_message = False

      self.current_frame = None


   def processControlFrame(self):
      """
      Process a completely received control frame.

      Modes: Hybi
      """

      payload = b''.join(self.control_frame_data)
      self.control_frame_data = None

      ## CLOSE frame
      ##
      if self.current_frame.opcode == 8:

         code = None
         reasonRaw = None
         ll = len(payload)
         if ll > 1:
            code = struct.unpack("!H", payload[0:2])[0]
            if ll > 2:
               reasonRaw = payload[2:]

         if self.onCloseFrame(code, reasonRaw):
            return False

      ## PING frame
      ##
      elif self.current_frame.opcode == 9:
         self._onPing(payload)

      ## PONG frame
      ##
      elif self.current_frame.opcode == 10:
         self._onPong(payload)

      else:
         ## we might arrive here, when protocolViolation
         ## wants us to continue anyway
         pass

      return True


   def sendFrame(self,
                 opcode,
                 payload = b'',
                 fin = True,
                 rsv = 0,
                 mask = None,
                 payload_len = None,
                 chopsize = None,
                 sync = False):
      """
      Send out frame. Normally only used internally via sendMessage(), sendPing(), sendPong() and sendClose().

      This method deliberately allows to send invalid frames (that is frames invalid
      per-se, or frames invalid because of protocol state). Other than in fuzzing servers,
      calling methods will ensure that no invalid frames are sent.

      In addition, this method supports explicit specification of payload length.
      When payload_len is given, it will always write that many octets to the stream.
      It'll wrap within payload, resending parts of that when more octets were requested
      The use case is again for fuzzing server which want to sent increasing amounts
      of payload data to peers without having to construct potentially large messges
      themselfes.

      Modes: Hybi
      """
      if self.websocket_version == 0:
         raise Exception("function not supported in Hixie-76 mode")

      if payload_len is not None:
         if len(payload) < 1:
            raise Exception("cannot construct repeated payload with length %d from payload of length %d" % (payload_len, len(payload)))
         l = payload_len
         pl = b''.join([payload for k in range(payload_len / len(payload))]) + payload[:payload_len % len(payload)]
      else:
         l = len(payload)
         pl = payload

      ## first byte
      ##
      b0 = 0
      if fin:
         b0 |= (1 << 7)
      b0 |= (rsv % 8) << 4
      b0 |= opcode % 128

      ## second byte, payload len bytes and mask
      ##
      b1 = 0
      if mask or (not self.factory.isServer and self.maskClientFrames) or (self.factory.isServer and self.maskServerFrames):
         b1 |= 1 << 7
         if not mask:
            mask = struct.pack("!I", random.getrandbits(32))
            mv = mask
         else:
            mv = b''

         ## mask frame payload
         ##
         if l > 0 and self.applyMask:
            masker = createXorMasker(mask, l)
            plm = masker.process(pl)
         else:
            plm = pl

      else:
         mv = b''
         plm = pl

      el = b''
      if l <= 125:
         b1 |= l
      elif l <= 0xFFFF:
         b1 |= 126
         el = struct.pack("!H", l)
      elif l <= 0x7FFFFFFFFFFFFFFF:
         b1 |= 127
         el = struct.pack("!Q", l)
      else:
         raise Exception("invalid payload length")

      if six.PY3:
         raw = b''.join([b0.to_bytes(1, 'big'), b1.to_bytes(1, 'big'), el, mv, plm])
      else:
         raw = b''.join([chr(b0), chr(b1), el, mv, plm])

      if opcode in [0, 1, 2]:
         self.trafficStats.outgoingWebSocketFrames += 1

      if self.logFrames:
         frameHeader = FrameHeader(opcode, fin, rsv, l, mask)
         self.logTxFrame(frameHeader, payload, payload_len, chopsize, sync)

      ## send frame octets
      ##
      self.sendData(raw, sync, chopsize)


   def sendPing(self, payload = None):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.sendPing`
      """
      if self.websocket_version == 0:
         raise Exception("function not supported in Hixie-76 mode")
      if self.state != WebSocketProtocol.STATE_OPEN:
         return
      if payload:
         l = len(payload)
         if l > 125:
            raise Exception("invalid payload for PING (payload length must be <= 125, was %d)" % l)
         self.sendFrame(opcode = 9, payload = payload)
      else:
         self.sendFrame(opcode = 9)


   def sendPong(self, payload = None):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.sendPong`
      """
      if self.websocket_version == 0:
         raise Exception("function not supported in Hixie-76 mode")
      if self.state != WebSocketProtocol.STATE_OPEN:
         return
      if payload:
         l = len(payload)
         if l > 125:
            raise Exception("invalid payload for PONG (payload length must be <= 125, was %d)" % l)
         self.sendFrame(opcode = 10, payload = payload)
      else:
         self.sendFrame(opcode = 10)


   def sendCloseFrame(self, code = None, reasonUtf8 = None, isReply = False):
      """
      Send a close frame and update protocol state. Note, that this is
      an internal method which deliberately allows not send close
      frame with invalid payload.

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, this method is slightly misnamed for historic reasons.
        - For Hixie mode, code and reasonUtf8 will be silently ignored.
      """
      if self.state == WebSocketProtocol.STATE_CLOSING:
         if self.debugCodePaths:
            self.factory._log("ignoring sendCloseFrame since connection is closing")

      elif self.state == WebSocketProtocol.STATE_CLOSED:
         if self.debugCodePaths:
            self.factory._log("ignoring sendCloseFrame since connection already closed")

      elif self.state in [WebSocketProtocol.STATE_PROXY_CONNECTING, WebSocketProtocol.STATE_CONNECTING]:
         raise Exception("cannot close a connection not yet connected")

      elif self.state == WebSocketProtocol.STATE_OPEN:

         if self.websocket_version == 0:
            self.sendData("\xff\x00")
         else:
            ## construct Hybi close frame payload and send frame
            payload = b''
            if code is not None:
               payload += struct.pack("!H", code)
            if reasonUtf8 is not None:
               payload += reasonUtf8
            self.sendFrame(opcode = 8, payload = payload)

         ## update state
         self.state = WebSocketProtocol.STATE_CLOSING
         self.closedByMe = not isReply

         ## remember payload of close frame we sent
         self.localCloseCode = code
         self.localCloseReason = reasonUtf8

         ## drop connection when timeout on receiving close handshake reply
         if self.closedByMe and self.closeHandshakeTimeout > 0:
            self.closeHandshakeTimeoutCall = self.factory._callLater(self.closeHandshakeTimeout, self.onCloseHandshakeTimeout)

      else:
         raise Exception("logic error")


   def sendClose(self, code = None, reason = None):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.sendClose`
      """
      if code is not None:
         if type(code) != int:
            raise Exception("invalid type %s for close code" % type(code))
         if code != 1000 and not (code >= 3000 and code <= 4999):
            raise Exception("invalid close code %d" % code)
      if reason is not None:
         if code is None:
            raise Exception("close reason without close code")
         if type(reason) != six.text_type:
            raise Exception("invalid type %s for close reason" % type(reason))
         reasonUtf8 = reason.encode("utf8")
         if len(reasonUtf8) + 2 > 125:
            raise Exception("close reason too long (%d)" % len(reasonUtf8))
      else:
         reasonUtf8 = None
      self.sendCloseFrame(code = code, reasonUtf8 = reasonUtf8, isReply = False)


   def beginMessage(self, isBinary = False, doNotCompress = False):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.beginMessage`
      """
      if self.state != WebSocketProtocol.STATE_OPEN:
         return

      ## check if sending state is valid for this method
      ##
      if self.send_state != WebSocketProtocol.SEND_STATE_GROUND:
         raise Exception("WebSocketProtocol.beginMessage invalid in current sending state")

      if self.websocket_version == 0:
         if isBinary:
            raise Exception("cannot send binary message in Hixie76 mode")

         self.sendData('\x00')
         self.send_state = WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE
      else:
         self.send_message_opcode = WebSocketProtocol.MESSAGE_TYPE_BINARY if isBinary else WebSocketProtocol.MESSAGE_TYPE_TEXT
         self.send_state = WebSocketProtocol.SEND_STATE_MESSAGE_BEGIN

         ## setup compressor
         ##
         if self._perMessageCompress is not None and not doNotCompress:
            self.send_compressed = True
            self._perMessageCompress.startCompressMessage()
         else:
            self.send_compressed = False

      self.trafficStats.outgoingWebSocketMessages += 1


   def beginMessageFrame(self, length):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.beginMessageFrame`
      """
      if self.websocket_version == 0:
         raise Exception("function not supported in Hixie-76 mode")

      if self.state != WebSocketProtocol.STATE_OPEN:
         return

      ## check if sending state is valid for this method
      ##
      if self.send_state not in [WebSocketProtocol.SEND_STATE_MESSAGE_BEGIN, WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE]:
         raise Exception("WebSocketProtocol.beginMessageFrame invalid in current sending state [%d]" % self.send_state)

      if type(length) != int or length < 0 or length > 0x7FFFFFFFFFFFFFFF: # 2**63
         raise Exception("invalid value for message frame length")

      self.send_message_frame_length = length

      self.trafficStats.outgoingWebSocketFrames += 1

      if (not self.factory.isServer and self.maskClientFrames) or (self.factory.isServer and self.maskServerFrames):
         ## automatic mask:
         ##  - client-to-server masking (if not deactivated)
         ##  - server-to-client masking (if activated)
         ##
         self.send_message_frame_mask = struct.pack("!I", random.getrandbits(32))

      else:
         ## no mask
         ##
         self.send_message_frame_mask = None

      ## payload masker
      ##
      if self.send_message_frame_mask and length > 0 and self.applyMask:
         self.send_message_frame_masker = createXorMasker(self.send_message_frame_mask, length)
      else:
         self.send_message_frame_masker = XorMaskerNull()

      ## first byte
      ##
      # FIN = false .. since with streaming, we don't know when message ends
      b0 = 0
      if self.send_state == WebSocketProtocol.SEND_STATE_MESSAGE_BEGIN:

         b0 |= self.send_message_opcode % 128

         if self.send_compressed:
            b0 |= (4 % 8) << 4

         self.send_state = WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE
      else:
         pass # message continuation frame

      ## second byte, payload len bytes and mask
      ##
      b1 = 0
      if self.send_message_frame_mask:
         b1 |= 1 << 7
         mv = self.send_message_frame_mask
      else:
         mv = b''

      el = b''
      if length <= 125:
         b1 |= length
      elif length <= 0xFFFF:
         b1 |= 126
         el = struct.pack("!H", length)
      elif length <= 0x7FFFFFFFFFFFFFFF:
         b1 |= 127
         el = struct.pack("!Q", length)
      else:
         raise Exception("invalid payload length")

      ## write message frame header
      ##
      if six.PY3:
         header = b''.join([b0.to_bytes(1, 'big'), b1.to_bytes(1, 'big'), el, mv])
      else:
         header = b''.join([chr(b0), chr(b1), el, mv])

      self.sendData(header)

      ## now we are inside message frame ..
      ##
      self.send_state = WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE_FRAME


   def sendMessageFrameData(self, payload, sync = False):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.sendMessageFrameData`
      """
      if self.state != WebSocketProtocol.STATE_OPEN:
         return

      if not self.send_compressed:
         self.trafficStats.outgoingOctetsAppLevel += len(payload)
      self.trafficStats.outgoingOctetsWebSocketLevel += len(payload)

      if self.websocket_version == 0:
         ## Hixie Mode
         ##
         if self.send_state != WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE:
            raise Exception("WebSocketProtocol.sendMessageFrameData invalid in current sending state")
         self.sendData(payload, sync = sync)
         return None

      else:
         ## Hybi Mode
         ##
         if self.send_state != WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE_FRAME:
            raise Exception("WebSocketProtocol.sendMessageFrameData invalid in current sending state")

         rl = len(payload)
         if self.send_message_frame_masker.pointer() + rl > self.send_message_frame_length:
            l = self.send_message_frame_length - self.send_message_frame_masker.pointer()
            rest = -(rl - l)
            pl = payload[:l]
         else:
            l = rl
            rest = self.send_message_frame_length - self.send_message_frame_masker.pointer() - l
            pl = payload

         ## mask frame payload
         ##
         plm = self.send_message_frame_masker.process(pl)

         ## send frame payload
         ##
         self.sendData(plm, sync = sync)

         ## if we are done with frame, move back into "inside message" state
         ##
         if self.send_message_frame_masker.pointer() >= self.send_message_frame_length:
            self.send_state = WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE

         ## when =0 : frame was completed exactly
         ## when >0 : frame is still uncomplete and that much amount is still left to complete the frame
         ## when <0 : frame was completed and there was this much unconsumed data in payload argument
         ##
         return rest


   def endMessage(self):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.endMessage`
      """
      if self.state != WebSocketProtocol.STATE_OPEN:
         return

      ## check if sending state is valid for this method
      ##
      #if self.send_state != WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE:
      #   raise Exception("WebSocketProtocol.endMessage invalid in current sending state [%d]" % self.send_state)

      if self.websocket_version == 0:
         self.sendData('\x00')
      else:
         if self.send_compressed:
            payload = self._perMessageCompress.endCompressMessage()
            self.trafficStats.outgoingOctetsWebSocketLevel += len(payload)
         else:
            ## send continuation frame with empty payload and FIN set to end message
            payload = b''
         self.sendFrame(opcode = 0, payload = payload, fin = True)

      self.send_state = WebSocketProtocol.SEND_STATE_GROUND


   def sendMessageFrame(self, payload, sync = False):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.sendMessageFrame`
      """
      if self.websocket_version == 0:
         raise Exception("function not supported in Hixie-76 mode")

      if self.state != WebSocketProtocol.STATE_OPEN:
         return

      if self.send_compressed:
         self.trafficStats.outgoingOctetsAppLevel += len(payload)
         payload = self._perMessageCompress.compressMessageData(payload)

      self.beginMessageFrame(len(payload))
      self.sendMessageFrameData(payload, sync)


   def sendMessage(self,
                   payload,
                   isBinary = False,
                   fragmentSize = None,
                   sync = False,
                   doNotCompress = False):
      """
      Implements :func:`autobahn.websocket.interfaces.IWebSocketChannel.sendMessage`
      """
      assert(type(payload) == bytes)

      if self.state != WebSocketProtocol.STATE_OPEN:
         return

      if self.trackedTimings:
         self.trackedTimings.track("sendMessage")

      if self.websocket_version == 0:
         if isBinary:
            raise Exception("cannot send binary message in Hixie76 mode")
         if fragmentSize:
            raise Exception("cannot fragment messages in Hixie76 mode")
         self.sendMessageHixie76(payload, sync)
      else:
         self.sendMessageHybi(payload, isBinary, fragmentSize, sync, doNotCompress)


   def sendMessageHixie76(self, payload, sync = False):
      """
      Hixie76-Variant of sendMessage().

      Modes: Hixie
      """
      self.sendData(b'\x00' + payload + b'\xff', sync = sync)


   def sendMessageHybi(self,
                       payload,
                       isBinary = False,
                       fragmentSize = None,
                       sync = False,
                       doNotCompress = False):
      """
      Hybi-Variant of sendMessage().

      Modes: Hybi
      """
      ## (initial) frame opcode
      ##
      if isBinary:
         opcode = 2
      else:
         opcode = 1

      self.trafficStats.outgoingWebSocketMessages += 1

      ## setup compressor
      ##
      if self._perMessageCompress is not None and not doNotCompress:
         sendCompressed = True

         self._perMessageCompress.startCompressMessage()

         self.trafficStats.outgoingOctetsAppLevel += len(payload)

         payload1 = self._perMessageCompress.compressMessageData(payload)
         payload2 = self._perMessageCompress.endCompressMessage()
         payload = b''.join([payload1, payload2])

         self.trafficStats.outgoingOctetsWebSocketLevel += len(payload)

      else:
         sendCompressed = False
         l = len(payload)
         self.trafficStats.outgoingOctetsAppLevel += l
         self.trafficStats.outgoingOctetsWebSocketLevel += l

      ## explicit fragmentSize arguments overrides autoFragmentSize setting
      ##
      if fragmentSize is not None:
         pfs = fragmentSize
      else:
         if self.autoFragmentSize > 0:
            pfs = self.autoFragmentSize
         else:
            pfs = None

      ## send unfragmented
      ##
      if pfs is None or len(payload) <= pfs:
         self.sendFrame(opcode = opcode, payload = payload, sync = sync, rsv = 4 if sendCompressed else 0)

      ## send data message in fragments
      ##
      else:
         if pfs < 1:
            raise Exception("payload fragment size must be at least 1 (was %d)" % pfs)
         n = len(payload)
         i = 0
         done = False
         first = True
         while not done:
            j = i + pfs
            if j > n:
               done = True
               j = n
            if first:
               self.sendFrame(opcode = opcode, payload = payload[i:j], fin = done, sync = sync, rsv = 4 if sendCompressed else 0)
               first = False
            else:
               self.sendFrame(opcode = 0, payload = payload[i:j], fin = done, sync = sync)
            i += pfs

      #if self.debug:
      #   self.factory._log("Traffic statistics:\n" + str(self.trafficStats))


   def _parseExtensionsHeader(self, header, removeQuotes = True):
      """
      Parse the Sec-WebSocket-Extensions header.
      """
      extensions = []
      exts = [str(x.strip()) for x in header.split(',')]
      for e in exts:
         if e != "":
            ext = [x.strip() for x in e.split(";")]
            if len(ext) > 0:
               extension = ext[0].lower()
               params = {}
               for p in ext[1:]:
                  p = [x.strip() for x in p.split("=")]
                  key = p[0].lower()
                  if len(p) > 1:
                     value = "=".join(p[1:])
                     if removeQuotes:
                        if len(value) > 0 and value[0] == '"':
                           value = value[1:]
                        if len(value) > 0 and value[-1] == '"':
                           value = value[:-1]
                  else:
                     value = True
                  if not key in params:
                     params[key] = []
                  params[key].append(value)
               extensions.append((extension, params))
            else:
               pass # should not arrive here
      return extensions



IWebSocketChannel.register(WebSocketProtocol)
IWebSocketChannelFrameApi.register(WebSocketProtocol)
IWebSocketChannelStreamingApi.register(WebSocketProtocol)



class PreparedMessage:
   """
   Encapsulates a prepared message to be sent later once or multiple
   times on one or more WebSocket connections.
   This can be used for optimizing Broadcast/PubSub.
   """

   def __init__(self, payload, isBinary, applyMask, doNotCompress):
      """
      Ctor for a prepared message.

      :param payload: The message payload.
      :type payload: str
      :param isBinary: Provide `True` for binary payload.
      :type isBinary: bool
      :param applyMask: Provide `True` if WebSocket message is to be masked (required for client to server WebSocket messages).
      :type applyMask: bool
      :param doNotCompress: Iff `True`, never compress this message. This only applies to
                            Hybi-Mode and only when WebSocket compression has been negotiated on
                            the WebSocket connection. Use when you know the payload
                            uncompressible (e.g. encrypted or already compressed).
      :type doNotCompress: bool
      """
      if not doNotCompress:
         ## we need to store original payload for compressed WS
         ## connections (cannot compress/frame in advanced when
         ## compression is on, and context takeover is off)
         self.payload = payload
         self.binary = isBinary
      self.doNotCompress = doNotCompress

      ## store pre-framed octets to be sent to Hixie-76 peers
      self._initHixie(payload, isBinary)

      ## store pre-framed octets to be sent to Hybi peers
      self._initHybi(payload, isBinary, applyMask)


   def _initHixie(self, payload, binary):
      if binary:
         # silently filter out .. probably do something else:
         # base64?
         # dunno
         self.payloadHixie = ''
      else:
         self.payloadHixie = '\x00' + payload + '\xff'


   def _initHybi(self, payload, binary, masked):
      l = len(payload)

      ## first byte
      ##
      b0 = ((1 << 7) | 2) if binary else ((1 << 7) | 1)

      ## second byte, payload len bytes and mask
      ##
      if masked:
         b1 = 1 << 7
         mask = struct.pack("!I", random.getrandbits(32))
         if l == 0:
            plm = payload
         else:
            plm = createXorMasker(mask, l).process(payload)
      else:
         b1 = 0
         mask = b''
         plm = payload

      ## payload extended length
      ##
      el = b''
      if l <= 125:
         b1 |= l
      elif l <= 0xFFFF:
         b1 |= 126
         el = struct.pack("!H", l)
      elif l <= 0x7FFFFFFFFFFFFFFF:
         b1 |= 127
         el = struct.pack("!Q", l)
      else:
         raise Exception("invalid payload length")

      ## raw WS message (single frame)
      ##
      if six.PY3:
         self.payloadHybi = b''.join([b0.to_bytes(1, 'big'), b1.to_bytes(1, 'big'), el, mask, plm])
      else:
         self.payloadHybi = b''.join([chr(b0), chr(b1), el, mask, plm])



class WebSocketFactory:
   """
   Mixin for
   :class:`autobahn.websocket.protocol.WebSocketClientFactory` and
   :class:`autobahn.websocket.protocol.WebSocketServerFactory`.
   """

   def prepareMessage(self, payload, isBinary = False, doNotCompress = False):
      """
      Prepare a WebSocket message. This can be later sent on multiple
      instances of :class:`autobahn.websocket.WebSocketProtocol` using
      :meth:`autobahn.websocket.WebSocketProtocol.sendPreparedMessage`.

      By doing so, you can avoid the (small) overhead of framing the
      *same* payload into WebSocket messages multiple times when that
      same payload is to be sent out on multiple connections.

      :param payload: The message payload.
      :type payload: bytes
      :param isBinary: `True` iff payload is binary, else the payload must be UTF-8 encoded text.
      :type isBinary: bool
      :param doNotCompress: Iff `True`, never compress this message. This only applies to
                            Hybi-Mode and only when WebSocket compression has been negotiated on
                            the WebSocket connection. Use when you know the payload
                            uncompressible (e.g. encrypted or already compressed).
      :type doNotCompress: bool

      :returns: obj -- An instance of :class:`autobahn.websocket.protocol.PreparedMessage`.
      """
      applyMask = not self.isServer
      return PreparedMessage(payload, isBinary, applyMask, doNotCompress)



class WebSocketServerProtocol(WebSocketProtocol):
   """
   Protocol base class for WebSocket servers.
   """

   CONFIG_ATTRS = WebSocketProtocol.CONFIG_ATTRS_COMMON + WebSocketProtocol.CONFIG_ATTRS_SERVER


   def onConnect(self, request):
      """
      Callback fired during WebSocket opening handshake when new WebSocket client
      connection is about to be established.

      When you want to accept the connection, return the accepted protocol
      from list of WebSocket (sub)protocols provided by client or `None` to
      speak no specific one or when the client protocol list was empty.

      You may also return a pair of `(protocol, headers)` to send additional
      HTTP headers, with `headers` being a dictionary of key-values.

      Throw :class:`autobahn.websocket.http.HttpException` when you don't want
      to accept the WebSocket connection request.

      :param request: WebSocket connection request information.
      :type request: instance of :class:`autobahn.websocket.protocol.ConnectionRequest`
      """
      return None


   def _connectionMade(self):
      """
      Called by network framework when new transport connection from client was
      accepted. Default implementation will prepare for initial WebSocket opening
      handshake. When overriding in derived class, make sure to call this base class
      implementation *before* your code.
      """
      WebSocketProtocol._connectionMade(self)
      self.factory.countConnections += 1
      if self.debug:
         self.factory._log("connection accepted from peer %s" % self.peer)


   def _connectionLost(self, reason):
      """
      Called by network framework when established transport connection from client
      was lost. Default implementation will tear down all state properly.
      When overriding in derived class, make sure to call this base class
      implementation *after* your code.
      """
      WebSocketProtocol._connectionLost(self, reason)
      self.factory.countConnections -= 1
      if self.debug:
         self.factory._log("connection from %s lost" % self.peer)


   def processProxyConnect(self):
      raise Exception("Autobahn isn't a proxy server")


   def parseHixie76Key(self, key):
      """
      Parse Hixie76 opening handshake key provided by client.
      """
      return int(filter(lambda x: x.isdigit(), key)) / key.count(" ")


   def processHandshake(self):
      """
      Process WebSocket opening handshake request from client.
      """
      ## only proceed when we have fully received the HTTP request line and all headers
      ##
      end_of_header = self.data.find(b"\x0d\x0a\x0d\x0a")
      if end_of_header >= 0:

         self.http_request_data = self.data[:end_of_header + 4]
         if self.debug:
            self.factory._log("received HTTP request:\n\n%s\n\n" % self.http_request_data)

         ## extract HTTP status line and headers
         ##
         (self.http_status_line, self.http_headers, http_headers_cnt) = parseHttpHeader(self.http_request_data)

         ## validate WebSocket opening handshake client request
         ##
         if self.debug:
            self.factory._log("received HTTP status line in opening handshake : %s" % str(self.http_status_line))
            self.factory._log("received HTTP headers in opening handshake : %s" % str(self.http_headers))

         ## HTTP Request line : METHOD, VERSION
         ##
         rl = self.http_status_line.split()
         if len(rl) != 3:
            return self.failHandshake("Bad HTTP request status line '%s'" % self.http_status_line)
         if rl[0].strip() != "GET":
            return self.failHandshake("HTTP method '%s' not allowed" % rl[0], http.METHOD_NOT_ALLOWED[0])
         vs = rl[2].strip().split("/")
         if len(vs) != 2 or vs[0] != "HTTP" or vs[1] not in ["1.1"]:
            return self.failHandshake("Unsupported HTTP version '%s'" % rl[2], http.UNSUPPORTED_HTTP_VERSION[0])

         ## HTTP Request line : REQUEST-URI
         ##
         self.http_request_uri = rl[1].strip()
         try:
            (scheme, netloc, path, params, query, fragment) = urllib.parse.urlparse(self.http_request_uri)

            ## FIXME: check that if absolute resource URI is given,
            ## the scheme/netloc matches the server
            if scheme != "" or netloc != "":
               pass

            ## Fragment identifiers are meaningless in the context of WebSocket
            ## URIs, and MUST NOT be used on these URIs.
            if fragment != "":
               return self.failHandshake("HTTP requested resource contains a fragment identifier '%s'" % fragment)

            ## resource path and query parameters .. this will get forwarded
            ## to onConnect()
            self.http_request_path = path
            self.http_request_params = urllib.parse.parse_qs(query)
         except:
            return self.failHandshake("Bad HTTP request resource - could not parse '%s'" % rl[1].strip())

         ## Host
         ##
         if not 'host' in self.http_headers:
            return self.failHandshake("HTTP Host header missing in opening handshake request")

         if http_headers_cnt["host"] > 1:
            return self.failHandshake("HTTP Host header appears more than once in opening handshake request")

         self.http_request_host = self.http_headers["host"].strip()

         if self.http_request_host.find(":") >= 0:
            (h, p) = self.http_request_host.split(":")
            try:
               port = int(str(p.strip()))
            except:
               return self.failHandshake("invalid port '%s' in HTTP Host header '%s'" % (str(p.strip()), str(self.http_request_host)))

            ## do port checking only if externalPort or URL was set
            if self.factory.externalPort:
               if port != self.factory.externalPort:
                  return self.failHandshake("port %d in HTTP Host header '%s' does not match server listening port %s" % (port, str(self.http_request_host), self.factory.externalPort))
            else:
               if self.debugCodePaths:
                  self.factory._log("skipping openening handshake port checking - neither WS URL nor external port set")

            self.http_request_host = h

         else:
            ## do port checking only if externalPort or URL was set
            if self.factory.externalPort:
               if not ((self.factory.isSecure and self.factory.externalPort == 443) or (not self.factory.isSecure and self.factory.externalPort == 80)):
                  return self.failHandshake("missing port in HTTP Host header '%s' and server runs on non-standard port %d (wss = %s)" % (str(self.http_request_host), self.factory.externalPort, self.factory.isSecure))
            else:
               if self.debugCodePaths:
                  self.factory._log("skipping openening handshake port checking - neither WS URL nor external port set")

         ## Upgrade
         ##
         if not 'upgrade' in self.http_headers:
            ## When no WS upgrade, render HTML server status page
            ##
            if self.webStatus:
               if 'redirect' in self.http_request_params and len(self.http_request_params['redirect']) > 0:
                  ## To specifiy an URL for redirection, encode the URL, i.e. from JavaScript:
                  ##
                  ##    var url = encodeURIComponent("http://autobahn.ws/python");
                  ##
                  ## and append the encoded string as a query parameter 'redirect'
                  ##
                  ##    http://localhost:9000?redirect=http%3A%2F%2Fautobahn.ws%2Fpython
                  ##    https://localhost:9000?redirect=https%3A%2F%2Ftwitter.com%2F
                  ##
                  ## This will perform an immediate HTTP-303 redirection. If you provide
                  ## an additional parameter 'after' (int >= 0), the redirection happens
                  ## via Meta-Refresh in the rendered HTML status page, i.e.
                  ##
                  ##    https://localhost:9000/?redirect=https%3A%2F%2Ftwitter.com%2F&after=3
                  ##
                  url = self.http_request_params['redirect'][0]
                  if 'after' in self.http_request_params and len(self.http_request_params['after']) > 0:
                     after = int(self.http_request_params['after'][0])
                     if self.debugCodePaths:
                        self.factory._log("HTTP Upgrade header missing : render server status page and meta-refresh-redirecting to %s after %d seconds" % (url, after))
                     self.sendServerStatus(url, after)
                  else:
                     if self.debugCodePaths:
                        self.factory._log("HTTP Upgrade header missing : 303-redirecting to %s" % url)
                     self.sendRedirect(url)
               else:
                  if self.debugCodePaths:
                     self.factory._log("HTTP Upgrade header missing : render server status page")
                  self.sendServerStatus()
               self.dropConnection(abort = False)
               return
            else:
               return self.failHandshake("HTTP Upgrade header missing", http.UPGRADE_REQUIRED[0])
         upgradeWebSocket = False
         for u in self.http_headers["upgrade"].split(","):
            if u.strip().lower() == "websocket":
               upgradeWebSocket = True
               break
         if not upgradeWebSocket:
            return self.failHandshake("HTTP Upgrade headers do not include 'websocket' value (case-insensitive) : %s" % self.http_headers["upgrade"])

         ## Connection
         ##
         if not 'connection' in self.http_headers:
            return self.failHandshake("HTTP Connection header missing")
         connectionUpgrade = False
         for c in self.http_headers["connection"].split(","):
            if c.strip().lower() == "upgrade":
               connectionUpgrade = True
               break
         if not connectionUpgrade:
            return self.failHandshake("HTTP Connection headers do not include 'upgrade' value (case-insensitive) : %s" % self.http_headers["connection"])

         ## Sec-WebSocket-Version PLUS determine mode: Hybi or Hixie
         ##
         if not 'sec-websocket-version' in self.http_headers:
            if self.debugCodePaths:
               self.factory._log("Hixie76 protocol detected")
            if self.allowHixie76:
               version = 0
            else:
               return self.failHandshake("WebSocket connection denied - Hixie76 protocol mode disabled.")
         else:
            if self.debugCodePaths:
               self.factory._log("Hybi protocol detected")
            if http_headers_cnt["sec-websocket-version"] > 1:
               return self.failHandshake("HTTP Sec-WebSocket-Version header appears more than once in opening handshake request")
            try:
               version = int(self.http_headers["sec-websocket-version"])
            except:
               return self.failHandshake("could not parse HTTP Sec-WebSocket-Version header '%s' in opening handshake request" % self.http_headers["sec-websocket-version"])

         if version not in self.versions:

            ## respond with list of supported versions (descending order)
            ##
            sv = sorted(self.versions)
            sv.reverse()
            svs = ','.join([str(x) for x in sv])
            return self.failHandshake("WebSocket version %d not supported (supported versions: %s)" % (version, svs),
                                      http.BAD_REQUEST[0],
                                      [("Sec-WebSocket-Version", svs)])
         else:
            ## store the protocol version we are supposed to talk
            self.websocket_version = version

         ## Sec-WebSocket-Protocol
         ##
         if 'sec-websocket-protocol' in self.http_headers:
            protocols = [str(x.strip()) for x in self.http_headers["sec-websocket-protocol"].split(",")]
            # check for duplicates in protocol header
            pp = {}
            for p in protocols:
               if p in pp:
                  return self.failHandshake("duplicate protocol '%s' specified in HTTP Sec-WebSocket-Protocol header" % p)
               else:
                  pp[p] = 1
            # ok, no duplicates, save list in order the client sent it
            self.websocket_protocols = protocols
         else:
            self.websocket_protocols = []

         ## Origin / Sec-WebSocket-Origin
         ## http://tools.ietf.org/html/draft-ietf-websec-origin-02
         ##
         if self.websocket_version < 13 and self.websocket_version != 0:
            # Hybi, but only < Hybi-13
            websocket_origin_header_key = 'sec-websocket-origin'
         else:
            # RFC6455, >= Hybi-13 and Hixie
            websocket_origin_header_key = "origin"

         self.websocket_origin = None
         if websocket_origin_header_key in self.http_headers:
            if http_headers_cnt[websocket_origin_header_key] > 1:
               return self.failHandshake("HTTP Origin header appears more than once in opening handshake request")
            self.websocket_origin = self.http_headers[websocket_origin_header_key].strip()
         else:
            # non-browser clients are allowed to omit this header
            pass

         ## Sec-WebSocket-Key (Hybi) or Sec-WebSocket-Key1/Sec-WebSocket-Key2 (Hixie-76)
         ##
         if self.websocket_version == 0:
            for kk in ['Sec-WebSocket-Key1', 'Sec-WebSocket-Key2']:
               k = kk.lower()
               if not k in self.http_headers:
                  return self.failHandshake("HTTP %s header missing" % kk)
               if http_headers_cnt[k] > 1:
                  return self.failHandshake("HTTP %s header appears more than once in opening handshake request" % kk)
               try:
                  key1 = self.parseHixie76Key(self.http_headers["sec-websocket-key1"].strip())
                  key2 = self.parseHixie76Key(self.http_headers["sec-websocket-key2"].strip())
               except:
                  return self.failHandshake("could not parse Sec-WebSocket-Key1/2")
         else:
            if not 'sec-websocket-key' in self.http_headers:
               return self.failHandshake("HTTP Sec-WebSocket-Key header missing")
            if http_headers_cnt["sec-websocket-key"] > 1:
               return self.failHandshake("HTTP Sec-WebSocket-Key header appears more than once in opening handshake request")
            key = self.http_headers["sec-websocket-key"].strip()
            if len(key) != 24: # 16 bytes => (ceil(128/24)*24)/6 == 24
               return self.failHandshake("bad Sec-WebSocket-Key (length must be 24 ASCII chars) '%s'" % key)
            if key[-2:] != "==": # 24 - ceil(128/6) == 2
               return self.failHandshake("bad Sec-WebSocket-Key (invalid base64 encoding) '%s'" % key)
            for c in key[:-2]:
               if c not in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/":
                  return self.failHandshake("bad character '%s' in Sec-WebSocket-Key (invalid base64 encoding) '%s'" (c, key))

         ## Sec-WebSocket-Extensions
         ##
         self.websocket_extensions = []
         if 'sec-websocket-extensions' in self.http_headers:

            if self.websocket_version == 0:
               return self.failHandshake("HTTP Sec-WebSocket-Extensions header encountered for Hixie-76")
            else:
               if http_headers_cnt["sec-websocket-extensions"] > 1:
                  return self.failHandshake("HTTP Sec-WebSocket-Extensions header appears more than once in opening handshake request")
               else:
                  ## extensions requested/offered by client
                  ##
                  self.websocket_extensions = self._parseExtensionsHeader(self.http_headers["sec-websocket-extensions"])

         ## For Hixie-76, we need 8 octets of HTTP request body to complete HS!
         ##
         if self.websocket_version == 0:
            if len(self.data) < end_of_header + 4 + 8:
               return
            else:
               key3 =  self.data[end_of_header + 4:end_of_header + 4 + 8]
               if self.debug:
                  self.factory._log("received HTTP request body containing key3 for Hixie-76: %s" % key3)

         ## Ok, got complete HS input, remember rest (if any)
         ##
         if self.websocket_version == 0:
            self.data = self.data[end_of_header + 4 + 8:]
         else:
            self.data = self.data[end_of_header + 4:]

         ## store WS key
         ##
         if self.websocket_version == 0:
            self._wskey = (key1, key2, key3)
         else:
            self._wskey = key

         ## WebSocket handshake validated => produce opening handshake response

         ## Now fire onConnect() on derived class, to give that class a chance to accept or deny
         ## the connection. onConnect() may throw, in which case the connection is denied, or it
         ## may return a protocol from the protocols provided by client or None.
         ##
         request = ConnectionRequest(self.peer,
                                     self.http_headers,
                                     self.http_request_host,
                                     self.http_request_path,
                                     self.http_request_params,
                                     self.websocket_version,
                                     self.websocket_origin,
                                     self.websocket_protocols,
                                     self.websocket_extensions)
         self._onConnect(request)


   def succeedHandshake(self, res):
      """
      Callback after onConnect() returns successfully. Generates the response for the handshake.
      """
      protocol = None
      headers = {}
      if type(res) == tuple:
         if len(res) > 0:
            protocol = res[0]
         if len(res) > 1:
            headers = res[1]
      else:
         protocol = res

      if protocol is not None and not (protocol in self.websocket_protocols):
         raise Exception("protocol accepted must be from the list client sent or None")

      self.websocket_protocol_in_use = protocol

      if self.websocket_version == 0:
         key1, key2, key3 = self._wskey
      else:
         key = self._wskey


      ## extensions effectively in use for this connection
      ##
      self.websocket_extensions_in_use = []

      extensionResponse = []

      ## gets filled with permessage-compress offers from the client
      ##
      pmceOffers = []

      ## handle WebSocket extensions
      ##
      for (extension, params) in self.websocket_extensions:

         if self.debug:
            self.factory._log("parsed WebSocket extension '%s' with params '%s'" % (extension, params))

         ## process permessage-compress extension
         ##
         if extension in PERMESSAGE_COMPRESSION_EXTENSION:

            PMCE = PERMESSAGE_COMPRESSION_EXTENSION[extension]

            try:
               offer = PMCE['Offer'].parse(params)
               pmceOffers.append(offer)
            except Exception as e:
               return self.failHandshake(str(e))

         else:
            if self.debug:
               self.factory._log("client requested '%s' extension we don't support or which is not activated" % extension)

      ## handle permessage-compress offers by the client
      ##
      if len(pmceOffers) > 0:
         accept = self.perMessageCompressionAccept(pmceOffers)
         if accept is not None:
            PMCE = PERMESSAGE_COMPRESSION_EXTENSION[accept.EXTENSION_NAME]
            self._perMessageCompress = PMCE['PMCE'].createFromOfferAccept(self.factory.isServer, accept)
            self.websocket_extensions_in_use.append(self._perMessageCompress)
            extensionResponse.append(accept.getExtensionString())
         else:
            if self.debug:
               self.factory._log("client request permessage-compress extension, but we did not accept any offer [%s]" % pmceOffers)


      ## build response to complete WebSocket handshake
      ##
      response = "HTTP/1.1 %d Switching Protocols\x0d\x0a" % http.SWITCHING_PROTOCOLS[0]

      if self.factory.server is not None and self.factory.server != "":
         response += "Server: %s\x0d\x0a" % self.factory.server

      response += "Upgrade: WebSocket\x0d\x0a"
      response += "Connection: Upgrade\x0d\x0a"

      ## optional, user supplied additional HTTP headers
      ##
      ## headers from factory
      for uh in self.factory.headers.items():
         response += "%s: %s\x0d\x0a" % (uh[0], uh[1])
      ## headers from onConnect
      for uh in headers.items():
         response += "%s: %s\x0d\x0a" % (uh[0], uh[1])

      if self.websocket_protocol_in_use is not None:
         response += "Sec-WebSocket-Protocol: %s\x0d\x0a" % str(self.websocket_protocol_in_use)

      if self.websocket_version == 0:

         if self.websocket_origin:
            ## browser client provide the header, and expect it to be echo'ed
            response += "Sec-WebSocket-Origin: %s\x0d\x0a" % str(self.websocket_origin)

         if self.debugCodePaths:
            self.factory._log('factory isSecure = %s port = %s' % (self.factory.isSecure, self.factory.externalPort))

         if self.factory.externalPort and ((self.factory.isSecure and self.factory.externalPort != 443) or ((not self.factory.isSecure) and self.factory.externalPort != 80)):
            if self.debugCodePaths:
               self.factory._log('factory running on non-default port')
            response_port = ':' + str(self.factory.externalPort)
         else:
            if self.debugCodePaths:
               self.factory._log('factory running on default port')
            response_port = ''

         ## FIXME: check this! But see below ..
         if False:
            response_host = str(self.factory.host)
            response_path = str(self.factory.path)
         else:
            response_host = str(self.http_request_host)
            response_path = str(self.http_request_uri)

         location = "%s://%s%s%s" % ('wss' if self.factory.isSecure else 'ws', response_host, response_port, response_path)

         # Safari is very picky about this one
         response += "Sec-WebSocket-Location: %s\x0d\x0a" % location

         ## end of HTTP response headers
         response += "\x0d\x0a"

         ## compute accept body
         ##
         accept_val = struct.pack(">II", key1, key2) + key3
         response_body = hashlib.md5(accept_val).digest()

      else:
         ## compute Sec-WebSocket-Accept
         ##
         sha1 = hashlib.sha1()
         sha1.update(key.encode('utf8') + WebSocketProtocol._WS_MAGIC)
         sec_websocket_accept = base64.b64encode(sha1.digest())

         response += "Sec-WebSocket-Accept: %s\x0d\x0a" % sec_websocket_accept.decode()

         ## agreed extensions
         ##
         if len(extensionResponse) > 0:
            response += "Sec-WebSocket-Extensions: %s\x0d\x0a" % ', '.join(extensionResponse)

         ## end of HTTP response headers
         response += "\x0d\x0a"
         response_body = None

      ## send out opening handshake response
      ##
      if self.debug:
         self.factory._log("sending HTTP response:\n\n%s" % response)
      self.sendData(response.encode('utf8'))

      if response_body:
         if self.debug:
            self.factory._log("sending HTTP response body:\n\n%s" % binascii.b2a_hex(response_body))
         self.sendData(response_body)

      ## save response for testsuite
      ##
      self.http_response_data = response

      ## opening handshake completed, move WebSocket connection into OPEN state
      ##
      self.state = WebSocketProtocol.STATE_OPEN

      ## cancel any opening HS timer if present
      ##
      if self.openHandshakeTimeoutCall is not None:
         if self.debugCodePaths:
            self.factory._log("openHandshakeTimeoutCall.cancel")
         self.openHandshakeTimeoutCall.cancel()
         self.openHandshakeTimeoutCall = None

      ## init state
      ##
      self.inside_message = False
      if self.websocket_version != 0:
         self.current_frame = None

      ## fire handler on derived class
      ##
      if self.trackedTimings:
         self.trackedTimings.track("onOpen")
      self._onOpen()

      ## process rest, if any
      ##
      if len(self.data) > 0:
         self.consumeData()


   def failHandshake(self, reason, code = http.BAD_REQUEST[0], responseHeaders = []):
      """
      During opening handshake the client request was invalid, we send a HTTP
      error response and then drop the connection.
      """
      if self.debug:
         self.factory._log("failing WebSocket opening handshake ('%s')" % reason)
      self.sendHttpErrorResponse(code, reason, responseHeaders)
      self.dropConnection(abort = False)


   def sendHttpErrorResponse(self, code, reason, responseHeaders = []):
      """
      Send out HTTP error response.
      """
      response  = "HTTP/1.1 {0} {1}\x0d\x0a".format(code, reason)
      for h in responseHeaders:
         response += "{0}: {1}\x0d\x0a".format(h[0], h[1])
      response += "\x0d\x0a"
      self.sendData(response.encode('utf8'))


   def sendHtml(self, html):
      """
      Send HTML page HTTP response.
      """
      responseBody = html.encode('utf8')
      response  = "HTTP/1.1 %d %s\x0d\x0a" % (http.OK[0], http.OK[1])
      if self.factory.server is not None and self.factory.server != "":
         response += "Server: %s\x0d\x0a" % self.factory.server
      response += "Content-Type: text/html; charset=UTF-8\x0d\x0a"
      response += "Content-Length: %d\x0d\x0a" % len(responseBody)
      response += "\x0d\x0a"
      self.sendData(response.encode('utf8'))
      self.sendData(responseBody)


   def sendRedirect(self, url):
      """
      Send HTTP Redirect (303) response.
      """
      response  = "HTTP/1.1 %d\x0d\x0a" % http.SEE_OTHER[0]
      if self.factory.server is not None and self.factory.server != "":
         response += "Server: %s\x0d\x0a" % self.factory.server
      response += "Location: %s\x0d\x0a" % url
      response += "\x0d\x0a"
      self.sendData(response.encode('utf8'))


   def sendServerStatus(self, redirectUrl = None, redirectAfter = 0):
      """
      Used to send out server status/version upon receiving a HTTP/GET without
      upgrade to WebSocket header (and option serverStatus is True).
      """
      if redirectUrl:
         redirect = """<meta http-equiv="refresh" content="%d;URL='%s'">""" % (redirectAfter, redirectUrl)
      else:
         redirect = ""
      html = """
<!DOCTYPE html>
<html>
   <head>
      %s
      <style>
         body {
            color: #fff;
            background-color: #027eae;
            font-family: "Segoe UI", "Lucida Grande", "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-size: 16px;
         }

         a, a:visited, a:hover {
            color: #fff;
         }
      </style>
   </head>
   <body>
      <h1>AutobahnPython %s</h1>
      <p>
         I am not Web server, but a WebSocket endpoint.
         You can talk to me using the WebSocket <a href="http://tools.ietf.org/html/rfc6455">protocol</a>.
      </p>
      <p>
         For more information, please visit <a href="http://autobahn.ws/python">my homepage</a>.
      </p>
   </body>
</html>
""" % (redirect, __version__)
      self.sendHtml(html)



class WebSocketServerFactory(WebSocketFactory):
   """
   A protocol factory for WebSocket servers.
   """

   protocol = WebSocketServerProtocol
   """
   The protocol to be spoken. Must be derived from :class:`autobahn.websocket.protocol.WebSocketServerProtocol`.
   """

   isServer = True
   """
   Flag indicating if this factory is client- or server-side.
   """


   def __init__(self,
                url = None,
                protocols = [],
                server = "AutobahnPython/%s" % __version__,
                headers = {},
                externalPort = None,
                debug = False,
                debugCodePaths = False):
      """
      Create instance of WebSocket server factory.

      :param url: The WebSocket URL this factory is working for, e.g. `ws://myhost.com/somepath`.
                  For non-TCP transports like pipes or Unix domain sockets, provide `None`.
                  This will use an implicit URL of `ws://localhost`.
      :type url: str
      :param protocols: List of subprotocols the server supports. The subprotocol used is the first from the list of subprotocols announced by the client that is contained in this list.
      :type protocols: list of strings
      :param server: Server as announced in HTTP response header during opening handshake or None (default: `AutobahnWebSocket/?.?.?`).
      :type server: str
      :param headers: An optional mapping of additional HTTP headers to send during the WebSocket opening handshake.
      :type headers: dict
      :param externalPort: Optionally, the external visible port this factory will be reachable under (i.e. when running behind a L2/L3 forwarding device).
      :type externalPort: int
      :param debug: Debug mode (default: `False`).
      :type debug: bool
      :param debugCodePaths: Debug code paths mode (default: `False`).
      :type debugCodePaths: bool
      """
      self.debug = debug
      self.debugCodePaths = debugCodePaths

      self.logOctets = debug
      self.logFrames = debug

      self.trackTimings = False

      ## seed RNG which is used for WS frame masks generation
      random.seed()

      ## default WS session parameters
      ##
      self.setSessionParameters(url, protocols, server, headers, externalPort)

      ## default WebSocket protocol options
      ##
      self.resetProtocolOptions()

      ## number of currently connected clients
      ##
      self.countConnections = 0


   def setSessionParameters(self,
                            url = None,
                            protocols = [],
                            server = None,
                            headers = {},
                            externalPort = None):
      """
      Set WebSocket session parameters.

      :param url: The WebSocket URL this factory is working for, e.g. `ws://myhost.com/somepath`.
                  For non-TCP transports like pipes or Unix domain sockets, provide `None`.
                  This will use an implicit URL of `ws://localhost`.
      :type url: str
      :param protocols: List of subprotocols the server supports. The subprotocol used is the first from the list of subprotocols announced by the client that is contained in this list.
      :type protocols: list of strings
      :param server: Server as announced in HTTP response header during opening handshake.
      :type server: str
      :param headers: An optional mapping of additional HTTP headers to send during the WebSocket opening handshake.
      :type headers: dict
      :param externalPort: Optionally, the external visible port this server will be reachable under (i.e. when running behind a L2/L3 forwarding device).
      :type externalPort: int
      """
      ## parse WebSocket URI into components
      (isSecure, host, port, resource, path, params) = parseWsUrl(url or "ws://localhost")
      if len(params) > 0:
         raise Exception("query parameters specified for server WebSocket URL")
      self.url = url
      self.isSecure = isSecure
      self.host = host
      self.port = port
      self.resource = resource
      self.path = path
      self.params = params

      self.protocols = protocols
      self.server = server
      self.headers = headers

      if externalPort:
         self.externalPort = externalPort
      elif url:
         self.externalPort = self.port
      else:
         self.externalPort = None


   def resetProtocolOptions(self):
      """
      Reset all WebSocket protocol options to defaults.
      """
      self.versions = WebSocketProtocol.SUPPORTED_PROTOCOL_VERSIONS
      self.allowHixie76 = WebSocketProtocol.DEFAULT_ALLOW_HIXIE76
      self.webStatus = True
      self.utf8validateIncoming = True
      self.requireMaskedClientFrames = True
      self.maskServerFrames = False
      self.applyMask = True
      self.maxFramePayloadSize = 0
      self.maxMessagePayloadSize = 0
      self.autoFragmentSize = 0
      self.failByDrop = True
      self.echoCloseCodeReason = False
      self.openHandshakeTimeout = 5
      self.closeHandshakeTimeout = 1
      self.tcpNoDelay = True

      ## permessage-XXX extension
      ##
      self.perMessageCompressionAccept = lambda _: None


   def setProtocolOptions(self,
                          versions = None,
                          allowHixie76 = None,
                          webStatus = None,
                          utf8validateIncoming = None,
                          maskServerFrames = None,
                          requireMaskedClientFrames = None,
                          applyMask = None,
                          maxFramePayloadSize = None,
                          maxMessagePayloadSize = None,
                          autoFragmentSize = None,
                          failByDrop = None,
                          echoCloseCodeReason = None,
                          openHandshakeTimeout = None,
                          closeHandshakeTimeout = None,
                          tcpNoDelay = None,
                          perMessageCompressionAccept = None):
      """
      Set WebSocket protocol options used as defaults for new protocol instances.

      :param versions: The WebSocket protocol versions accepted by the server (default: :func:`autobahn.websocket.protocol.WebSocketProtocol.SUPPORTED_PROTOCOL_VERSIONS`).
      :type versions: list of ints
      :param allowHixie76: Allow to speak Hixie76 protocol version.
      :type allowHixie76: bool
      :param webStatus: Return server status/version on HTTP/GET without WebSocket upgrade header (default: `True`).
      :type webStatus: bool
      :param utf8validateIncoming: Validate incoming UTF-8 in text message payloads (default: `True`).
      :type utf8validateIncoming: bool
      :param maskServerFrames: Mask server-to-client frames (default: `False`).
      :type maskServerFrames: bool
      :param requireMaskedClientFrames: Require client-to-server frames to be masked (default: `True`).
      :type requireMaskedClientFrames: bool
      :param applyMask: Actually apply mask to payload when mask it present. Applies for outgoing and incoming frames (default: `True`).
      :type applyMask: bool
      :param maxFramePayloadSize: Maximum frame payload size that will be accepted when receiving or `0` for unlimited (default: `0`).
      :type maxFramePayloadSize: int
      :param maxMessagePayloadSize: Maximum message payload size (after reassembly of fragmented messages) that will be accepted when receiving or `0` for unlimited (default: `0`).
      :type maxMessagePayloadSize: int
      :param autoFragmentSize: Automatic fragmentation of outgoing data messages (when using the message-based API) into frames with payload length `<=` this size or `0` for no auto-fragmentation (default: `0`).
      :type autoFragmentSize: int
      :param failByDrop: Fail connections by dropping the TCP connection without performaing closing handshake (default: `True`).
      :type failbyDrop: bool
      :param echoCloseCodeReason: Iff true, when receiving a close, echo back close code/reason. Otherwise reply with `code == 1000, reason = ""` (default: `False`).
      :type echoCloseCodeReason: bool
      :param openHandshakeTimeout: Opening WebSocket handshake timeout, timeout in seconds or `0` to deactivate (default: `0`).
      :type openHandshakeTimeout: float
      :param closeHandshakeTimeout: When we expect to receive a closing handshake reply, timeout in seconds (default: `1`).
      :type closeHandshakeTimeout: float
      :param tcpNoDelay: TCP NODELAY ("Nagle") socket option (default: `True`).
      :type tcpNoDelay: bool
      :param perMessageCompressionAccept: Acceptor function for offers.
      :type perMessageCompressionAccept: callable
      """
      if allowHixie76 is not None and allowHixie76 != self.allowHixie76:
         self.allowHixie76 = allowHixie76

      if versions is not None:
         for v in versions:
            if v not in WebSocketProtocol.SUPPORTED_PROTOCOL_VERSIONS:
               raise Exception("invalid WebSocket protocol version %s (allowed values: %s)" % (v, str(WebSocketProtocol.SUPPORTED_PROTOCOL_VERSIONS)))
            if v == 0 and not self.allowHixie76:
               raise Exception("use of Hixie-76 requires allowHixie76 == True")
         if set(versions) != set(self.versions):
            self.versions = versions

      if webStatus is not None and webStatus != self.webStatus:
         self.webStatus = webStatus

      if utf8validateIncoming is not None and utf8validateIncoming != self.utf8validateIncoming:
         self.utf8validateIncoming = utf8validateIncoming

      if requireMaskedClientFrames is not None and requireMaskedClientFrames != self.requireMaskedClientFrames:
         self.requireMaskedClientFrames = requireMaskedClientFrames

      if maskServerFrames is not None and maskServerFrames != self.maskServerFrames:
         self.maskServerFrames = maskServerFrames

      if applyMask is not None and applyMask != self.applyMask:
         self.applyMask = applyMask

      if maxFramePayloadSize is not None and maxFramePayloadSize != self.maxFramePayloadSize:
         self.maxFramePayloadSize = maxFramePayloadSize

      if maxMessagePayloadSize is not None and maxMessagePayloadSize != self.maxMessagePayloadSize:
         self.maxMessagePayloadSize = maxMessagePayloadSize

      if autoFragmentSize is not None and autoFragmentSize != self.autoFragmentSize:
         self.autoFragmentSize = autoFragmentSize

      if failByDrop is not None and failByDrop != self.failByDrop:
         self.failByDrop = failByDrop

      if echoCloseCodeReason is not None and echoCloseCodeReason != self.echoCloseCodeReason:
         self.echoCloseCodeReason = echoCloseCodeReason

      if openHandshakeTimeout is not None and openHandshakeTimeout != self.openHandshakeTimeout:
         self.openHandshakeTimeout = openHandshakeTimeout

      if closeHandshakeTimeout is not None and closeHandshakeTimeout != self.closeHandshakeTimeout:
         self.closeHandshakeTimeout = closeHandshakeTimeout

      if tcpNoDelay is not None and tcpNoDelay != self.tcpNoDelay:
         self.tcpNoDelay = tcpNoDelay

      if perMessageCompressionAccept is not None and perMessageCompressionAccept != self.perMessageCompressionAccept:
         self.perMessageCompressionAccept = perMessageCompressionAccept


   def getConnectionCount(self):
      """
      Get number of currently connected clients.

      :returns: int -- Number of currently connected clients.
      """
      return self.countConnections



class WebSocketClientProtocol(WebSocketProtocol):
   """
   Protocol base class for WebSocket clients.
   """

   CONFIG_ATTRS = WebSocketProtocol.CONFIG_ATTRS_COMMON + WebSocketProtocol.CONFIG_ATTRS_CLIENT


   def onConnect(self, response):
      """
      Callback fired directly after WebSocket opening handshake when new WebSocket server
      connection was established.

      :param response: WebSocket connection response information.
      :type response: instance of :class:`autobahn.websocket.protocol.ConnectionResponse`
      """
      pass


   def _connectionMade(self):
      """
      Called by network framework when new transport connection to server was established. Default
      implementation will start the initial WebSocket opening handshake (or proxy connect).
      When overriding in derived class, make sure to call this base class
      implementation _before_ your code.
      """
      WebSocketProtocol._connectionMade(self)
      if self.debug:
         self.factory._log("connection to %s established" % self.peer)

      if not self.factory.isServer and self.factory.proxy is not None:
         ## start by doing a HTTP/CONNECT for explicit proxies
         self.startProxyConnect()
      else:
         ## immediately start with the WebSocket opening handshake
         self.startHandshake()


   def _connectionLost(self, reason):
      """
      Called by network framework when established transport connection to server was lost. Default
      implementation will tear down all state properly.
      When overriding in derived class, make sure to call this base class
      implementation _after_ your code.
      """
      WebSocketProtocol._connectionLost(self, reason)
      if self.debug:
         self.factory._log("connection to %s lost" % self.peer)


   def startProxyConnect(self):
      """
      Connect to explicit proxy.
      """

      ## construct proxy connect HTTP request
      ##
      request  = "CONNECT %s:%d HTTP/1.1\x0d\x0a" % (self.factory.host.encode("utf-8"), self.factory.port)
      request += "Host: %s:%d\x0d\x0a" % (self.factory.host.encode("utf-8"), self.factory.port)
      request += "\x0d\x0a"

      if self.debug:
         self.factory._log(request)

      self.sendData(request)


   def processProxyConnect(self):
      """
      Process HTTP/CONNECT response from server.
      """
      ## only proceed when we have fully received the HTTP request line and all headers
      ##
      end_of_header = self.data.find(b"\x0d\x0a\x0d\x0a")
      if end_of_header >= 0:

         http_response_data = self.data[:end_of_header + 4]
         if self.debug:
            self.factory._log("received HTTP response:\n\n%s\n\n" % http_response_data)

         ## extract HTTP status line and headers
         ##
         (http_status_line, http_headers, http_headers_cnt) = parseHttpHeader(http_response_data)

         ## validate proxy connect response
         ##
         if self.debug:
            self.factory._log("received HTTP status line for proxy connect request : %s" % str(http_status_line))
            self.factory._log("received HTTP headers for proxy connect request : %s" % str(http_headers))

         ## Response Line
         ##
         sl = http_status_line.split()
         if len(sl) < 2:
            return self.failProxyConnect("Bad HTTP response status line '%s'" % http_status_line)

         ## HTTP version
         ##
         http_version = sl[0].strip()
         if http_version != "HTTP/1.1":
            return self.failProxyConnect("Unsupported HTTP version ('%s')" % http_version)

         ## HTTP status code
         ##
         try:
            status_code = int(sl[1].strip())
         except:
            return self.failProxyConnect("Bad HTTP status code ('%s')" % sl[1].strip())

         if not (status_code >= 200 and status_code < 300):

            ## FIXME: handle redirects
            ## FIXME: handle authentication required

            if len(sl) > 2:
               reason = " - %s" % ''.join(sl[2:])
            else:
               reason = ""
            return self.failProxyConnect("HTTP proxy connect failed (%d%s)" % (status_code, reason))


         ## Ok, got complete response for HTTP/CONNECT, remember rest (if any)
         ##
         self.data = self.data[end_of_header + 4:]

         ## opening handshake completed, move WebSocket connection into OPEN state
         ##
         self.state = WebSocketProtocol.STATE_CONNECTING

         ## process rest of buffered data, if any
         ##
         if len(self.data) > 0:
            self.consumeData()

         ## now start WebSocket opening handshake
         ##
         self.startHandshake()


   def failProxyConnect(self, reason):
      """
      During initial explicit proxy connect, the server response indicates some failure and we drop the
      connection.
      """
      if self.debug:
         self.factory._log("failing proxy connect ('%s')" % reason)
      self.dropConnection(abort = True)


   def createHixieKey(self):
      """
      Supposed to implement the crack smoker algorithm below. Well, crack
      probably wasn't the stuff they smoked - dog poo?

      http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76#page-21
      Items 16 - 22
      """
      spaces1 = random.randint(1, 12)
      max1 = int(4294967295 / spaces1)
      number1 = random.randint(0, max1)
      product1 = number1 * spaces1
      key1 = str(product1)
      rchars = filter(lambda x: (x >= 0x21 and x <= 0x2f) or (x >= 0x3a and x <= 0x7e), range(0,127))
      for i in xrange(random.randint(1, 12)):
         p = random.randint(0, len(key1) - 1)
         key1 = key1[:p] + chr(random.choice(rchars)) + key1[p:]
      for i in xrange(spaces1):
         p = random.randint(1, len(key1) - 2)
         key1 = key1[:p] + ' ' + key1[p:]
      return (key1, number1)


   def startHandshake(self):
      """
      Start WebSocket opening handshake.
      """

      ## construct WS opening handshake HTTP header
      ##
      request  = "GET %s HTTP/1.1\x0d\x0a" % self.factory.resource

      if self.factory.useragent is not None and self.factory.useragent != "":
         request += "User-Agent: %s\x0d\x0a" % self.factory.useragent

      request += "Host: %s:%d\x0d\x0a" % (self.factory.host, self.factory.port)
      request += "Upgrade: WebSocket\x0d\x0a"
      request += "Connection: Upgrade\x0d\x0a"

      ## this seems to prohibit some non-compliant proxies from removing the
      ## connection "Upgrade" header
      ## See also:
      ##   http://www.ietf.org/mail-archive/web/hybi/current/msg09841.html
      ##   http://code.google.com/p/chromium/issues/detail?id=148908
      ##
      request += "Pragma: no-cache\x0d\x0a"
      request += "Cache-Control: no-cache\x0d\x0a"

      ## optional, user supplied additional HTTP headers
      ##
      for uh in self.factory.headers.items():
         request += "%s: %s\x0d\x0a" % (uh[0], uh[1])

      ## handshake random key
      ##
      if self.version == 0:
         (self.websocket_key1, number1) = self.createHixieKey()
         (self.websocket_key2, number2) = self.createHixieKey()
         self.websocket_key3 = os.urandom(8)
         accept_val = struct.pack(">II", number1, number2) + self.websocket_key3
         self.websocket_expected_challenge_response = hashlib.md5(accept_val).digest()

         ## Safari does NOT set Content-Length, even though the body is
         ## non-empty, and the request unchunked. We do it.
         ## See also: http://www.ietf.org/mail-archive/web/hybi/current/msg02149.html
         request += "Content-Length: %s\x0d\x0a" % len(self.websocket_key3)

         ## First two keys.
         request += "Sec-WebSocket-Key1: %s\x0d\x0a" % self.websocket_key1
         request += "Sec-WebSocket-Key2: %s\x0d\x0a" % self.websocket_key2
         request_body = self.websocket_key3
      else:
         self.websocket_key = base64.b64encode(os.urandom(16))
         request += "Sec-WebSocket-Key: %s\x0d\x0a" % self.websocket_key.decode()
         request_body = None

      ## optional origin announced
      ##
      if self.factory.origin:
         if self.version > 10 or self.version == 0:
            request += "Origin: %s\x0d\x0a" % self.factory.origin
         else:
            request += "Sec-WebSocket-Origin: %s\x0d\x0a" % self.factory.origin

      ## optional list of WS subprotocols announced
      ##
      if len(self.factory.protocols) > 0:
         request += "Sec-WebSocket-Protocol: %s\x0d\x0a" % ','.join(self.factory.protocols)

      ## extensions
      ##
      if self.version != 0:
         extensions = []

         ## permessage-compress offers
         ##
         for offer in self.perMessageCompressionOffers:
            extensions.append(offer.getExtensionString())

         if len(extensions) > 0:
            request += "Sec-WebSocket-Extensions: %s\x0d\x0a" % ', '.join(extensions)

      ## set WS protocol version depending on WS spec version
      ##
      if self.version != 0:
         request += "Sec-WebSocket-Version: %d\x0d\x0a" % WebSocketProtocol.SPEC_TO_PROTOCOL_VERSION[self.version]

      request += "\x0d\x0a"

      self.http_request_data = request.encode('utf8')
      self.sendData(self.http_request_data)

      if request_body:
         ## Write HTTP request body for Hixie-76
         self.sendData(request_body)

      if self.debug:
         self.factory._log(request)


   def processHandshake(self):
      """
      Process WebSocket opening handshake response from server.
      """
      ## only proceed when we have fully received the HTTP request line and all headers
      ##
      end_of_header = self.data.find(b"\x0d\x0a\x0d\x0a")
      if end_of_header >= 0:

         self.http_response_data = self.data[:end_of_header + 4]
         if self.debug:
            self.factory._log("received HTTP response:\n\n%s\n\n" % self.http_response_data)

         ## extract HTTP status line and headers
         ##
         (self.http_status_line, self.http_headers, http_headers_cnt) = parseHttpHeader(self.http_response_data)

         ## validate WebSocket opening handshake server response
         ##
         if self.debug:
            self.factory._log("received HTTP status line in opening handshake : %s" % str(self.http_status_line))
            self.factory._log("received HTTP headers in opening handshake : %s" % str(self.http_headers))

         ## Response Line
         ##
         sl = self.http_status_line.split()
         if len(sl) < 2:
            return self.failHandshake("Bad HTTP response status line '%s'" % self.http_status_line)

         ## HTTP version
         ##
         http_version = sl[0].strip()
         if http_version != "HTTP/1.1":
            return self.failHandshake("Unsupported HTTP version ('%s')" % http_version)

         ## HTTP status code
         ##
         try:
            status_code = int(sl[1].strip())
         except:
            return self.failHandshake("Bad HTTP status code ('%s')" % sl[1].strip())
         if status_code != http.SWITCHING_PROTOCOLS[0]:

            ## FIXME: handle redirects
            ## FIXME: handle authentication required

            if len(sl) > 2:
               reason = " - %s" % ''.join(sl[2:])
            else:
               reason = ""
            return self.failHandshake("WebSocket connection upgrade failed (%d%s)" % (status_code, reason))

         ## Upgrade
         ##
         if not 'upgrade' in self.http_headers:
            return self.failHandshake("HTTP Upgrade header missing")
         if self.http_headers["upgrade"].strip().lower() != "websocket":
            return self.failHandshake("HTTP Upgrade header different from 'websocket' (case-insensitive) : %s" % self.http_headers["upgrade"])

         ## Connection
         ##
         if not 'connection' in self.http_headers:
            return self.failHandshake("HTTP Connection header missing")
         connectionUpgrade = False
         for c in self.http_headers["connection"].split(","):
            if c.strip().lower() == "upgrade":
               connectionUpgrade = True
               break
         if not connectionUpgrade:
            return self.failHandshake("HTTP Connection header does not include 'upgrade' value (case-insensitive) : %s" % self.http_headers["connection"])

         ## compute Sec-WebSocket-Accept
         ##
         if self.version != 0:
            if not 'sec-websocket-accept' in self.http_headers:
               return self.failHandshake("HTTP Sec-WebSocket-Accept header missing in opening handshake reply")
            else:
               if http_headers_cnt["sec-websocket-accept"] > 1:
                  return self.failHandshake("HTTP Sec-WebSocket-Accept header appears more than once in opening handshake reply")
               sec_websocket_accept_got = self.http_headers["sec-websocket-accept"].strip()

               sha1 = hashlib.sha1()
               sha1.update(self.websocket_key + WebSocketProtocol._WS_MAGIC)
               sec_websocket_accept = base64.b64encode(sha1.digest()).decode()

               if sec_websocket_accept_got != sec_websocket_accept:
                  return self.failHandshake("HTTP Sec-WebSocket-Accept bogus value : expected %s / got %s" % (sec_websocket_accept, sec_websocket_accept_got))

         ## Sec-WebSocket-Extensions
         ##

         ## extensions effectively in use for this connection
         ##
         self.websocket_extensions_in_use = []

         if 'sec-websocket-extensions' in self.http_headers:

            if self.version == 0:
               return self.failHandshake("HTTP Sec-WebSocket-Extensions header encountered for Hixie-76")
            else:
               if http_headers_cnt["sec-websocket-extensions"] > 1:
                  return self.failHandshake("HTTP Sec-WebSocket-Extensions header appears more than once in opening handshake reply")
               else:
                  ## extensions select by server
                  ##
                  websocket_extensions = self._parseExtensionsHeader(self.http_headers["sec-websocket-extensions"])

            ## process extensions selected by server
            ##
            for (extension, params) in websocket_extensions:

               if self.debug:
                  self.factory._log("parsed WebSocket extension '%s' with params '%s'" % (extension, params))

               ## process permessage-compress extension
               ##
               if extension in PERMESSAGE_COMPRESSION_EXTENSION:

                  ## check that server only responded with 1 configuration ("PMCE")
                  ##
                  if self._perMessageCompress is not None:
                     return self.failHandshake("multiple occurence of a permessage-compress extension")

                  PMCE = PERMESSAGE_COMPRESSION_EXTENSION[extension]

                  try:
                     pmceResponse = PMCE['Response'].parse(params)
                  except Exception as e:
                     return self.failHandshake(str(e))

                  accept = self.perMessageCompressionAccept(pmceResponse)

                  if accept is None:
                     return self.failHandshake("WebSocket permessage-compress extension response from server denied by client")

                  self._perMessageCompress = PMCE['PMCE'].createFromResponseAccept(self.factory.isServer, accept)

                  self.websocket_extensions_in_use.append(self._perMessageCompress)

               else:
                  return self.failHandshake("server wants to use extension '%s' we did not request, haven't implemented or did not enable" % extension)

         ## handle "subprotocol in use" - if any
         ##
         self.websocket_protocol_in_use = None
         if 'sec-websocket-protocol' in self.http_headers:
            if http_headers_cnt["sec-websocket-protocol"] > 1:
               return self.failHandshake("HTTP Sec-WebSocket-Protocol header appears more than once in opening handshake reply")
            sp = str(self.http_headers["sec-websocket-protocol"].strip())
            if sp != "":
               if sp not in self.factory.protocols:
                  return self.failHandshake("subprotocol selected by server (%s) not in subprotocol list requested by client (%s)" % (sp, str(self.factory.protocols)))
               else:
                  ## ok, subprotocol in use
                  ##
                  self.websocket_protocol_in_use = sp

         ## For Hixie-76, we need 16 octets of HTTP request body to complete HS!
         ##
         if self.version == 0:
            if len(self.data) < end_of_header + 4 + 16:
               return
            else:
               challenge_response =  self.data[end_of_header + 4:end_of_header + 4 + 16]
               if challenge_response != self.websocket_expected_challenge_response:
                  return self.failHandshake("invalid challenge response received from server (Hixie-76)")

         ## Ok, got complete HS input, remember rest (if any)
         ##
         if self.version == 0:
            self.data = self.data[end_of_header + 4 + 16:]
         else:
            self.data = self.data[end_of_header + 4:]

         ## opening handshake completed, move WebSocket connection into OPEN state
         ##
         self.state = WebSocketProtocol.STATE_OPEN
         self.inside_message = False
         if self.version != 0:
            self.current_frame = None
         self.websocket_version = self.version

         ## we handle this symmetrical to server-side .. that is, give the
         ## client a chance to bail out .. i.e. on no subprotocol selected
         ## by server
         try:
            response = ConnectionResponse(self.peer,
                                          self.http_headers,
                                          None, # FIXME
                                          self.websocket_protocol_in_use,
                                          self.websocket_extensions_in_use)

            self._onConnect(response)

         except Exception as e:
            ## immediately close the WS connection
            ##
            self.failConnection(1000, str(e))
         else:
            ## fire handler on derived class
            ##
            if self.trackedTimings:
               self.trackedTimings.track("onOpen")
            self._onOpen()

         ## process rest, if any
         ##
         if len(self.data) > 0:
            self.consumeData()


   def failHandshake(self, reason):
      """
      During opening handshake the server response is invalid and we drop the
      connection.
      """
      if self.debug:
         self.factory._log("failing WebSocket opening handshake ('%s')" % reason)
      self.dropConnection(abort = True)



class WebSocketClientFactory(WebSocketFactory):
   """
   A protocol factory for WebSocket clients.
   """

   protocol = WebSocketClientProtocol
   """
   The protocol to be spoken. Must be derived from :class:`autobahn.websocket.protocol.WebSocketClientProtocol`.
   """

   isServer = False
   """
   Flag indicating if this factory is client- or server-side.
   """


   def __init__(self,
                url = None,
                origin = None,
                protocols = [],
                useragent = "AutobahnPython/%s" % __version__,
                headers = {},
                proxy = None,
                debug = False,
                debugCodePaths = False):
      """
      Create instance of WebSocket client factory.

      Note that you MUST provide URL either here or set using
      :meth:`autobahn.websocket.WebSocketClientFactory.setSessionParameters`
      *before* the factory is started.

      :param url: WebSocket URL this factory will connect to, e.g. `ws://myhost.com/somepath?param1=23`.
                  For non-TCP transports like pipes or Unix domain sockets, provide `None`.
                  This will use an implicit URL of `ws://localhost`.
      :type url: str
      :param origin: The origin to be sent in WebSocket opening handshake or None (default: `None`).
      :type origin: str
      :param protocols: List of subprotocols the client should announce in WebSocket opening handshake (default: `[]`).
      :type protocols: list of strings
      :param useragent: User agent as announced in HTTP request header or None (default: `AutobahnWebSocket/?.?.?`).
      :type useragent: str
      :param headers: An optional mapping of additional HTTP headers to send during the WebSocket opening handshake.
      :type headers: dict
      :param proxy: Explicit proxy server to use (`hostname:port` or `IP:port`), e.g. `192.168.1.100:8080`.
      :type proxy: str
      :param debug: Debug mode (default: `False`).
      :type debug: bool
      :param debugCodePaths: Debug code paths mode (default: `False`).
      :type debugCodePaths: bool
      """
      self.debug = debug
      self.debugCodePaths = debugCodePaths

      self.logOctets = debug
      self.logFrames = debug

      self.trackTimings = False

      ## seed RNG which is used for WS opening handshake key and WS frame masks generation
      random.seed()

      ## default WS session parameters
      ##
      self.setSessionParameters(url, origin, protocols, useragent, headers, proxy)

      ## default WebSocket protocol options
      ##
      self.resetProtocolOptions()


   def setSessionParameters(self,
                            url = None,
                            origin = None,
                            protocols = [],
                            useragent = None,
                            headers = {},
                            proxy = None):
      """
      Set WebSocket session parameters.

      :param url: WebSocket URL this factory will connect to, e.g. `ws://myhost.com/somepath?param1=23`.
                  For non-TCP transports like pipes or Unix domain sockets, provide `None`.
                  This will use an implicit URL of `ws://localhost`.
      :type url: str
      :param origin: The origin to be sent in opening handshake.
      :type origin: str
      :param protocols: List of WebSocket subprotocols the client should announce in opening handshake.
      :type protocols: list of strings
      :param useragent: User agent as announced in HTTP request header during opening handshake.
      :type useragent: str
      :param headers: An optional mapping of additional HTTP headers to send during the WebSocket opening handshake.
      :type headers: dict
      """
      ## parse WebSocket URI into components
      (isSecure, host, port, resource, path, params) = parseWsUrl(url or "ws://localhost")
      self.url = url
      self.isSecure = isSecure
      self.host = host
      self.port = port
      self.resource = resource
      self.path = path
      self.params = params

      self.origin = origin
      self.protocols = protocols
      self.useragent = useragent
      self.headers = headers

      self.proxy = proxy


   def resetProtocolOptions(self):
      """
      Reset all WebSocket protocol options to defaults.
      """
      self.version = WebSocketProtocol.DEFAULT_SPEC_VERSION
      self.allowHixie76 = WebSocketProtocol.DEFAULT_ALLOW_HIXIE76
      self.utf8validateIncoming = True
      self.acceptMaskedServerFrames = False
      self.maskClientFrames = True
      self.applyMask = True
      self.maxFramePayloadSize = 0
      self.maxMessagePayloadSize = 0
      self.autoFragmentSize = 0
      self.failByDrop = True
      self.echoCloseCodeReason = False
      self.serverConnectionDropTimeout = 1
      self.openHandshakeTimeout = 5
      self.closeHandshakeTimeout = 1
      self.tcpNoDelay = True

      ## permessage-XXX extensions
      ##
      self.perMessageCompressionOffers = []
      self.perMessageCompressionAccept = lambda _: None


   def setProtocolOptions(self,
                          version = None,
                          allowHixie76 = None,
                          utf8validateIncoming = None,
                          acceptMaskedServerFrames = None,
                          maskClientFrames = None,
                          applyMask = None,
                          maxFramePayloadSize = None,
                          maxMessagePayloadSize = None,
                          autoFragmentSize = None,
                          failByDrop = None,
                          echoCloseCodeReason = None,
                          serverConnectionDropTimeout = None,
                          openHandshakeTimeout = None,
                          closeHandshakeTimeout = None,
                          tcpNoDelay = None,
                          perMessageCompressionOffers = None,
                          perMessageCompressionAccept = None):
      """
      Set WebSocket protocol options used as defaults for _new_ protocol instances.

      :param version: The WebSocket protocol spec (draft) version to be used (default: :func:`autobahn.websocket.protocol.WebSocketProtocol.SUPPORTED_PROTOCOL_VERSIONS`).
      :param utf8validateIncoming: Validate incoming UTF-8 in text message payloads (default: `True`).
      :type utf8validateIncoming: bool
      :param acceptMaskedServerFrames: Accept masked server-to-client frames (default: `False`).
      :type acceptMaskedServerFrames: bool
      :param maskClientFrames: Mask client-to-server frames (default: `True`).
      :type maskClientFrames: bool
      :param applyMask: Actually apply mask to payload when mask it present. Applies for outgoing and incoming frames (default: `True`).
      :type applyMask: bool
      :param maxFramePayloadSize: Maximum frame payload size that will be accepted when receiving or `0` for unlimited (default: `0`).
      :type maxFramePayloadSize: int
      :param maxMessagePayloadSize: Maximum message payload size (after reassembly of fragmented messages) that will be accepted when receiving or `0` for unlimited (default: `0`).
      :type maxMessagePayloadSize: int
      :param autoFragmentSize: Automatic fragmentation of outgoing data messages (when using the message-based API) into frames with payload length `<=` this size or `0` for no auto-fragmentation (default: `0`).
      :type autoFragmentSize: int
      :param failByDrop: Fail connections by dropping the TCP connection without performing closing handshake (default: `True`).
      :type failbyDrop: bool
      :param echoCloseCodeReason: Iff true, when receiving a close, echo back close code/reason. Otherwise reply with `code == 1000, reason = ""` (default: `False`).
      :type echoCloseCodeReason: bool
      :param serverConnectionDropTimeout: When the client expects the server to drop the TCP, timeout in seconds (default: `1`).
      :type serverConnectionDropTimeout: float
      :param openHandshakeTimeout: Opening WebSocket handshake timeout, timeout in seconds or `0` to deactivate (default: `0`).
      :type openHandshakeTimeout: float
      :param closeHandshakeTimeout: When we expect to receive a closing handshake reply, timeout in seconds (default: `1`).
      :type closeHandshakeTimeout: float
      :param tcpNoDelay: TCP NODELAY ("Nagle"): bool socket option (default: `True`).
      :type tcpNoDelay: bool
      :param perMessageCompressionOffers: A list of offers to provide to the server for the permessage-compress WebSocket extension. Must be a list of instances of subclass of PerMessageCompressOffer.
      :type perMessageCompressionOffers: list of instance of subclass of PerMessageCompressOffer
      :param perMessageCompressionAccept: Acceptor function for responses.
      :type perMessageCompressionAccept: callable
      """
      if allowHixie76 is not None and allowHixie76 != self.allowHixie76:
         self.allowHixie76 = allowHixie76

      if version is not None:
         if version not in WebSocketProtocol.SUPPORTED_SPEC_VERSIONS:
            raise Exception("invalid WebSocket draft version %s (allowed values: %s)" % (version, str(WebSocketProtocol.SUPPORTED_SPEC_VERSIONS)))
         if version == 0 and not self.allowHixie76:
            raise Exception("use of Hixie-76 requires allowHixie76 == True")
         if version != self.version:
            self.version = version

      if utf8validateIncoming is not None and utf8validateIncoming != self.utf8validateIncoming:
         self.utf8validateIncoming = utf8validateIncoming

      if acceptMaskedServerFrames is not None and acceptMaskedServerFrames != self.acceptMaskedServerFrames:
         self.acceptMaskedServerFrames = acceptMaskedServerFrames

      if maskClientFrames is not None and maskClientFrames != self.maskClientFrames:
         self.maskClientFrames = maskClientFrames

      if applyMask is not None and applyMask != self.applyMask:
         self.applyMask = applyMask

      if maxFramePayloadSize is not None and maxFramePayloadSize != self.maxFramePayloadSize:
         self.maxFramePayloadSize = maxFramePayloadSize

      if maxMessagePayloadSize is not None and maxMessagePayloadSize != self.maxMessagePayloadSize:
         self.maxMessagePayloadSize = maxMessagePayloadSize

      if autoFragmentSize is not None and autoFragmentSize != self.autoFragmentSize:
         self.autoFragmentSize = autoFragmentSize

      if failByDrop is not None and failByDrop != self.failByDrop:
         self.failByDrop = failByDrop

      if echoCloseCodeReason is not None and echoCloseCodeReason != self.echoCloseCodeReason:
         self.echoCloseCodeReason = echoCloseCodeReason

      if serverConnectionDropTimeout is not None and serverConnectionDropTimeout != self.serverConnectionDropTimeout:
         self.serverConnectionDropTimeout = serverConnectionDropTimeout

      if openHandshakeTimeout is not None and openHandshakeTimeout != self.openHandshakeTimeout:
         self.openHandshakeTimeout = openHandshakeTimeout

      if closeHandshakeTimeout is not None and closeHandshakeTimeout != self.closeHandshakeTimeout:
         self.closeHandshakeTimeout = closeHandshakeTimeout

      if tcpNoDelay is not None and tcpNoDelay != self.tcpNoDelay:
         self.tcpNoDelay = tcpNoDelay

      if perMessageCompressionOffers is not None and pickle.dumps(perMessageCompressionOffers) != pickle.dumps(self.perMessageCompressionOffers):
         if type(perMessageCompressionOffers) == list:
            ##
            ## FIXME: more rigorous verification of passed argument
            ##
            self.perMessageCompressionOffers = copy.deepcopy(perMessageCompressionOffers)
         else:
            raise Exception("invalid type %s for perMessageCompressionOffers - expected list" % type(perMessageCompressionOffers))

      if perMessageCompressionAccept is not None and perMessageCompressionAccept != self.perMessageCompressionAccept:
         self.perMessageCompressionAccept = perMessageCompressionAccept

########NEW FILE########
__FILENAME__ = test_websocket_url
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

try:
   from twisted.trial import unittest
except:
   import unittest

from autobahn.websocket.protocol import createWsUrl, parseWsUrl



class TestCreateWsUrl(unittest.TestCase):

   def test_create_url01(self):
      self.assertEqual(createWsUrl("localhost"), "ws://localhost:80/")

   def test_create_url02(self):
      self.assertEqual(createWsUrl("localhost", port = 8090), "ws://localhost:8090/")

   def test_create_url03(self):
      self.assertEqual(createWsUrl("localhost", path = "ws"), "ws://localhost:80/ws")

   def test_create_url04(self):
      self.assertEqual(createWsUrl("localhost", path = "/ws"), "ws://localhost:80/ws")

   def test_create_url05(self):
      self.assertEqual(createWsUrl("localhost", path = "/ws/foobar"), "ws://localhost:80/ws/foobar")

   def test_create_url06(self):
      self.assertEqual(createWsUrl("localhost", isSecure = True), "wss://localhost:443/")

   def test_create_url07(self):
      self.assertEqual(createWsUrl("localhost", isSecure = True, port = 443), "wss://localhost:443/")

   def test_create_url08(self):
      self.assertEqual(createWsUrl("localhost", isSecure = True, port = 80), "wss://localhost:80/")

   def test_create_url09(self):
      self.assertEqual(createWsUrl("localhost", isSecure = True, port = 9090, path = "ws", params = {'foo': 'bar'}), "wss://localhost:9090/ws?foo=bar")

   def test_create_url10(self):
      self.assertEqual(createWsUrl("localhost", isSecure = True, port = 9090, path = "ws", params = {'foo': 'bar', 'moo': 23}), "wss://localhost:9090/ws?foo=bar&moo=23")

   def test_create_url11(self):
      self.assertEqual(createWsUrl("127.0.0.1", path = "ws"), "ws://127.0.0.1:80/ws")

   def test_create_url12(self):
      self.assertEqual(createWsUrl("62.146.25.34", path = "ws"), "ws://62.146.25.34:80/ws")

   def test_create_url13(self):
      self.assertEqual(createWsUrl("subsub1.sub1.something.com", path = "ws"), "ws://subsub1.sub1.something.com:80/ws")

   def test_create_url14(self):
      self.assertEqual(createWsUrl("::1", path = "ws"), "ws://::1:80/ws")

   def test_create_url15(self):
      self.assertEqual(createWsUrl("0:0:0:0:0:0:0:1", path = "ws"), "ws://0:0:0:0:0:0:0:1:80/ws")




class TestParseWsUrl(unittest.TestCase):

   # parseWsUrl -> (isSecure, host, port, resource, path, params)

   def test_parse_url01(self):
      self.assertEqual(parseWsUrl("ws://localhost"), (False, 'localhost', 80, '/', '/', {}))

   def test_parse_url02(self):
      self.assertEqual(parseWsUrl("ws://localhost:80"), (False, 'localhost', 80, '/', '/', {}))

   def test_parse_url03(self):
      self.assertEqual(parseWsUrl("wss://localhost"), (True, 'localhost', 443, '/', '/', {}))

   def test_parse_url04(self):
      self.assertEqual(parseWsUrl("wss://localhost:443"), (True, 'localhost', 443, '/', '/', {}))

   def test_parse_url05(self):
      self.assertEqual(parseWsUrl("wss://localhost/ws"), (True, 'localhost', 443, '/ws', '/ws', {}))

   def test_parse_url06(self):
      self.assertEqual(parseWsUrl("wss://localhost/ws?foo=bar"), (True, 'localhost', 443, '/ws?foo=bar', '/ws', {'foo': ['bar']}))

   def test_parse_url07(self):
      self.assertEqual(parseWsUrl("wss://localhost/ws?foo=bar&moo=23"), (True, 'localhost', 443, '/ws?foo=bar&moo=23', '/ws', {'moo': ['23'], 'foo': ['bar']}))

   def test_parse_url08(self):
      self.assertEqual(parseWsUrl("wss://localhost/ws?foo=bar&moo=23&moo=44"), (True, 'localhost', 443, '/ws?foo=bar&moo=23&moo=44', '/ws', {'moo': ['23', '44'], 'foo': ['bar']}))


   def test_parse_url09(self):
      self.assertRaises(Exception, parseWsUrl, "http://localhost")

   def test_parse_url10(self):
      self.assertRaises(Exception, parseWsUrl, "https://localhost")

   def test_parse_url11(self):
      self.assertRaises(Exception, parseWsUrl, "http://localhost:80")

   def test_parse_url12(self):
      self.assertRaises(Exception, parseWsUrl, "http://localhost#frag1")

   def test_parse_url13(self):
      self.assertRaises(Exception, parseWsUrl, "wss://")

   def test_parse_url14(self):
      self.assertRaises(Exception, parseWsUrl, "ws://")



if __name__ == '__main__':
   unittest.main()

########NEW FILE########
__FILENAME__ = useragent
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ("lookupWsSupport",)


import re

UA_FIREFOX = re.compile(".*Firefox/(\d*).*")
UA_CHROME = re.compile(".*Chrome/(\d*).*")
UA_CHROMEFRAME = re.compile(".*chromeframe/(\d*).*")
UA_WEBKIT = re.compile(".*AppleWebKit/([0-9+\.]*)\w*.*")
UA_WEBOS = re.compile(".*webos/([0-9+\.]*)\w*.*")
UA_HPWEBOS = re.compile(".*hpwOS/([0-9+\.]*)\w*.*")



# Chrome =============================================================

# Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11


# Chrome Frame =======================================================

# IE6 on Windows with Chrome Frame
# Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; chromeframe/11.0.660.0)


# Firefox ============================================================

# Windows 7 64 Bit
# Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0a2) Gecko/20120227 Firefox/12.0a2


# Android ============================================================

# Firefox Mobile
# Mozilla/5.0 (Android; Linux armv7l; rv:10.0.2) Gecko/20120215 Firefox/10.0.2 Fennec/10.0.2

# Chrome for Android (on ICS)
# Mozilla/5.0 (Linux; U; Android-4.0.3; en-us; Galaxy Nexus Build/IML74K) AppleWebKit/535.7 (KHTML, like Gecko) CrMo/16.0.912.75 Mobile Safari/535.7

# Android builtin browser

# Samsung Galaxy Tab 1
# Mozilla/5.0 (Linux; U; Android 2.2; de-de; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1

# Samsung Galaxy S
# Mozilla/5.0 (Linux; U; Android 2.3.3; de-de; GT-I9000 Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1

# Samsung Galaxy Note
# Mozilla/5.0 (Linux; U; Android 2.3.6; de-de; GT-N7000 Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1

# Samsung Galaxy ACE (no Flash since ARM)
# Mozilla/5.0 (Linux; U; Android 2.2.1; de-de; GT-S5830 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1


# WebOS ==============================================================

# HP Touchpad
# Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.5; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) wOSBrowser/234.83 Safari/534.6 TouchPad/1.0
# => Qt-WebKit, Hixie-76, Flash


# Safari =============================================================

# iPod Touch, iOS 4.2.1
# Mozilla/5.0 (iPod; U; CPU iPhone OS 4_2_1 like Mac OS X; de-de) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5
# => Hixie-76

# MacBook Pro, OSX 10.5.8, Safari 5.0.6
# Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/534.50.2 (KHTML, like Gecko) Version/5.0.6 Safari/533.22.3
# => Hixie-76

# RFC6455
# Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534+ (KHTML, like Gecko) Version/5.1.2 Safari/534.52.7
# Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.24+ (KHTML, like Gecko) Version/5.1.3 Safari/534.53.10

# Hixie-76
# Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/534.53.11 (KHTML, like Gecko) Version/5.1.3 Safari/534.53.10

# Hixie-76
# Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/534.50.2 (KHTML, like Gecko) Version/5.0.6 Safari/533.22.3


# Opera ==============================================================

# Windows 7 32-Bit
# Opera/9.80 (Windows NT 6.1; U; de) Presto/2.10.229 Version/11.61

# Windows 7 64-Bit
# Opera/9.80 (Windows NT 6.1; WOW64; U; de) Presto/2.10.229 Version/11.62

# Samsung Galaxy S
# Opera/9.80 (Android 2.3.3; Linux; Opera Mobi/ADR-1202231246; U; de) Presto/2.10.254 Version/12.00

# Samsung Galaxy Tab 1
# Opera/9.80 (Android 2.2; Linux; Opera Tablet/ADR-1203051631; U; de) Presto/2.10.254 Version/12.00

# Samsung Galaxy ACE:
# Opera/9.80 (Android 2.2.1; Linux; Opera Mobi/ADR-1203051631; U; de) Presto/2.10.254 Version/12.00

# Nokia N8, Symbian S60 5th Ed., S60 Bell
# Opera/9.80 (S60; SymbOS; Opera Mobi/SYB-1111151949; U; de) Presto/2.9.201 Version/11.50


def _lookupWsSupport(ua):
   ## Internet Explorer
   ##
   ## FIXME: handle Windows Phone
   ##
   if ua.find("MSIE") >= 0:
      # IE10 has native support
      if ua.find("MSIE 10") >= 0:
         # native Hybi-10+
         return (True, False, True)

      # first, check for Google Chrome Frame
      # http://www.chromium.org/developers/how-tos/chrome-frame-getting-started/understanding-chrome-frame-user-agent
      if ua.find("chromeframe") >= 0:

         r = UA_CHROMEFRAME.match(ua)
         try:
            v = int(r.groups()[0])
            if v >= 14:
               # native Hybi-10+
               return (True, False, True)
         except:
            # detection problem
            return (False, False, False)

      # Flash fallback
      if ua.find("MSIE 8") >= 0 or ua.find("MSIE 9") >= 0:
         return (True, True, True)

      # unsupported
      return (False, False, True)


   ## iOS
   ##
   if ua.find("iPhone") >= 0 or ua.find("iPad") >= 0 or ua.find("iPod") >= 0:
      ## native Hixie76 (as of March 2012), no Flash, no alternative browsers
      return (True, False, True)


   ## Android
   ##
   if ua.find("Android") >= 0:

      ## Firefox Mobile
      ##
      if ua.find("Firefox") >= 0:
         # Hybi-10+ for FF Mobile 8+
         return (True, False, True)

      ## Opera Mobile
      ##
      if ua.find("Opera") >= 0:
         # Hixie76 for Opera 11+
         return (True, False, True)

      ## Chrome for Android
      ##
      if ua.find("CrMo") >= 0:
         # http://code.google.com/chrome/mobile/docs/faq.html
         return (True, False, True)

      ## Android builtin Browser (ooold WebKit)
      ##
      if ua.find("AppleWebKit") >= 0:

         # Though we return WS = True, and Flash = True here, when the device has no actual Flash support, that
         # will get later detected in JS. This applies to i.e. ARMv6 devices like Samsung Galaxy ACE

         # builtin browser, only works via Flash
         return (True, True, True)

      # detection problem
      return (False, False, False)


   ## webOS
   ##
   if ua.find("hpwOS") >= 0 or ua.find("webos") >= 0:
      try:
         if ua.find("hpwOS") >= 0:
            vv = [int(x) for x in UA_HPWEBOS.match(ua).groups()[0].split('.')]
            if vv[0] >= 3:
               return (True, False, True)
         elif ua.find("webos") >= 0:
            vv = [int(x) for x in UA_WEBOS.match(ua).groups()[0].split('.')]
            if vv[0] >= 2:
               return (True, False, True)
      except:
         # detection problem
         return (False, False, False)
      else:
         # unsupported
         return (False, False, True)


   ## Opera
   ##
   if ua.find("Opera") >= 0:
      # Opera 11+ has Hixie76 (needs to be manually activated though)
      return (True, False, True)


   ## Firefox
   ##
   if ua.find("Firefox") >= 0:
      r = UA_FIREFOX.match(ua)
      try:
         v = int(r.groups()[0])
         if v >= 7:
            # native Hybi-10+
            return (True, False, True)
         elif v >= 3:
            # works with Flash bridge
            return (True, True, True)
         else:
            # unsupported
            return (False, False, True)
      except:
         # detection problem
         return (False, False, False)


   ## Safari
   ##
   if ua.find("Safari") >= 0 and not ua.find("Chrome") >= 0:

      # rely on at least Hixie76
      return (True, False, True)


   ## Chrome
   ##
   if ua.find("Chrome") >= 0:
      r = UA_CHROME.match(ua)
      try:
         v = int(r.groups()[0])
         if v >= 14:
            # native Hybi-10+
            return (True, False, True)
         elif v >= 4:
            # works with Flash bridge
            return (True, True, True)
         else:
            # unsupported
            return (False, False, True)
      except:
         # detection problem
         return (False, False, False)


   # detection problem
   return (False, False, False)


UA_DETECT_WS_SUPPORT_DB = {}

def lookupWsSupport(ua, debug = True):
   """
   Lookup if browser supports WebSocket (Hixie76, Hybi10+, RFC6455) natively,
   and if not, whether the `web-socket-js <https://github.com/gimite/web-socket-js>`_
   Flash bridge works to polyfill that.

   Returns a tuple of booleans `(ws_supported, needs_flash, detected)` where

      * `ws_supported`: WebSocket is supported
      * `needs_flash`: Flash Bridge is needed for support
      * `detected` the code has explicitly mapped the support/nosupport

   :param ua: The browser user agent string as sent in the HTTP header, e.g. provided as `flask.request.user_agent.string` in Flask.
   :type ua: str

   :returns: tuple -- A tuple `(ws_supported, needs_flash, detected)`.
   """
   ws = _lookupWsSupport(ua)
   if debug:
      if not UA_DETECT_WS_SUPPORT_DB.has_key(ua):
         UA_DETECT_WS_SUPPORT_DB[ua] = ws

      if not ws[2]:
         msg = "UNDETECTED"
      elif ws[0]:
         msg = "SUPPORTED"
      elif not ws[0]:
         msg = "UNSUPPORTED"
      else:
         msg = "ERROR"

      print("DETECT_WS_SUPPORT: %s %s %s %s %s" % (ua, ws[0], ws[1], ws[2], msg))

   return ws

########NEW FILE########
__FILENAME__ = utf8validator
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Note:
##
##  This code is a Python implementation of the algorithm
##
##            "Flexible and Economical UTF-8 Decoder"
##
##  by Bjoern Hoehrmann
##
##       bjoern@hoehrmann.de
##       http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ("Utf8Validator",)


## DFA transitions
UTF8VALIDATOR_DFA = (
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 00..1f
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 20..3f
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 40..5f
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 60..7f
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, # 80..9f
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, # a0..bf
  8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, # c0..df
  0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, # e0..ef
  0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, # f0..ff
  0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, # s0..s0
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, # s1..s2
  1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, # s3..s4
  1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, # s5..s6
  1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, # s7..s8
)

UTF8_ACCEPT = 0
UTF8_REJECT = 1


## use Cython implementation of UTF8 validator if available
##
try:
   from wsaccel.utf8validator import Utf8Validator

except:
   ##
   ## Fallback to pure Python implementation - also for PyPy.
   ##
   ## Do NOT touch this code unless you know what you are doing!
   ## https://github.com/oberstet/scratchbox/tree/master/python/utf8
   ##

   import six

   if six.PY3:

      ## Python 3 and above

      ## convert DFA table to bytes (performance)
      UTF8VALIDATOR_DFA_S = bytes(UTF8VALIDATOR_DFA)

      class Utf8Validator:
         """
         Incremental UTF-8 validator with constant memory consumption (minimal state).

         Implements the algorithm "Flexible and Economical UTF-8 Decoder" by
         Bjoern Hoehrmann (http://bjoern.hoehrmann.de/utf-8/decoder/dfa/).
         """

         def __init__(self):
            self.reset()

         def decode(self, b):
            """
            Eat one UTF-8 octet, and validate on the fly.

            Returns UTF8_ACCEPT when enough octets have been consumed, in which case
            self.codepoint contains the decoded Unicode code point.

            Returns UTF8_REJECT when invalid UTF-8 was encountered.

            Returns some other positive integer when more octets need to be eaten.
            """
            tt = UTF8VALIDATOR_DFA_S[b]
            if self.state != UTF8_ACCEPT:
               self.codepoint = (b & 0x3f) | (self.codepoint << 6)
            else:
               self.codepoint = (0xff >> tt) & b
            self.state = UTF8VALIDATOR_DFA_S[256 + self.state * 16 + tt]
            return self.state

         def reset(self):
            """
            Reset validator to start new incremental UTF-8 decode/validation.
            """
            self.state = UTF8_ACCEPT # the empty string is valid UTF8
            self.codepoint = 0
            self.i = 0

         def validate(self, ba):
            """
            Incrementally validate a chunk of bytes provided as string.

            Will return a quad (valid?, endsOnCodePoint?, currentIndex, totalIndex).

            As soon as an octet is encountered which renders the octet sequence
            invalid, a quad with valid? == False is returned. currentIndex returns
            the index within the currently consumed chunk, and totalIndex the
            index within the total consumed sequence that was the point of bail out.
            When valid? == True, currentIndex will be len(ba) and totalIndex the
            total amount of consumed bytes.
            """
            ##
            ## The code here is written for optimal JITting in PyPy, not for best
            ## readability by your grandma or particular elegance. Do NOT touch!
            ##
            l = len(ba)
            i = 0
            state = self.state
            while i < l:
               ## optimized version of decode(), since we are not interested in actual code points
               state = UTF8VALIDATOR_DFA_S[256 + (state << 4) + UTF8VALIDATOR_DFA_S[ba[i]]]
               if state == UTF8_REJECT:
                  self.state = state
                  self.i += i
                  return False, False, i, self.i
               i += 1
            self.state = state
            self.i += l
            return True, state == UTF8_ACCEPT, l, self.i

   else:

      ## convert DFA table to string (performance)
      UTF8VALIDATOR_DFA_S = ''.join([chr(c) for c in UTF8VALIDATOR_DFA])

      class Utf8Validator:
         """
         Incremental UTF-8 validator with constant memory consumption (minimal state).

         Implements the algorithm "Flexible and Economical UTF-8 Decoder" by
         Bjoern Hoehrmann (http://bjoern.hoehrmann.de/utf-8/decoder/dfa/).
         """

         def __init__(self):
            self.reset()

         def decode(self, b):
            """
            Eat one UTF-8 octet, and validate on the fly.

            Returns UTF8_ACCEPT when enough octets have been consumed, in which case
            self.codepoint contains the decoded Unicode code point.

            Returns UTF8_REJECT when invalid UTF-8 was encountered.

            Returns some other positive integer when more octets need to be eaten.
            """
            tt = ord(UTF8VALIDATOR_DFA_S[b])
            if self.state != UTF8_ACCEPT:
               self.codepoint = (b & 0x3f) | (self.codepoint << 6)
            else:
               self.codepoint = (0xff >> tt) & b
            self.state = ord(UTF8VALIDATOR_DFA_S[256 + self.state * 16 + tt])
            return self.state

         def reset(self):
            """
            Reset validator to start new incremental UTF-8 decode/validation.
            """
            self.state = UTF8_ACCEPT # the empty string is valid UTF8
            self.codepoint = 0
            self.i = 0

         def validate(self, ba):
            """
            Incrementally validate a chunk of bytes provided as string.

            Will return a quad (valid?, endsOnCodePoint?, currentIndex, totalIndex).

            As soon as an octet is encountered which renders the octet sequence
            invalid, a quad with valid? == False is returned. currentIndex returns
            the index within the currently consumed chunk, and totalIndex the
            index within the total consumed sequence that was the point of bail out.
            When valid? == True, currentIndex will be len(ba) and totalIndex the
            total amount of consumed bytes.
            """
            ##
            ## The code here is written for optimal JITting in PyPy, not for best
            ## readability by your grandma or particular elegance. Do NOT touch!
            ##
            l = len(ba)
            i = 0
            state = self.state
            while i < l:
               ## optimized version of decode(), since we are not interested in actual code points
               state = ord(UTF8VALIDATOR_DFA_S[256 + (state << 4) + ord(UTF8VALIDATOR_DFA_S[ord(ba[i])])])
               if state == UTF8_REJECT:
                  self.state = state
                  self.i += i
                  return False, False, i, self.i
               i += 1
            self.state = state
            self.i += l
            return True, state == UTF8_ACCEPT, l, self.i

########NEW FILE########
__FILENAME__ = xormasker
###############################################################################
##
##  Copyright (C) 2012-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import six


## use Cython implementation of XorMasker validator if available
##
try:
   from wsaccel.xormask import XorMaskerNull, createXorMasker

except:
   ## fallback to pure Python implementation

   ## http://stackoverflow.com/questions/15014310/python3-xrange-lack-hurts
   try:
      xrange
   except NameError:
      ## Python 3
      xrange = range

   from array import array

   class XorMaskerNull:

      def __init__(self, mask = None):
         self.ptr = 0

      def pointer(self):
         return self.ptr

      def reset(self):
         self.ptr = 0

      def process(self, data):
         self.ptr += len(data)
         return data


   class XorMaskerSimple:

      def __init__(self, mask):
         assert len(mask) == 4
         self.ptr = 0
         self.msk = array('B', mask)

      def pointer(self):
         return self.ptr

      def reset(self):
         self.ptr = 0

      def process(self, data):
         dlen = len(data)
         payload = array('B', data)
         for k in xrange(dlen):
            payload[k] ^= self.msk[self.ptr & 3]
            self.ptr += 1
         return payload.tostring()


   class XorMaskerShifted1:

      def __init__(self, mask):
         assert len(mask) == 4
         self.ptr = 0
         self.mskarray = [array('B'), array('B'), array('B'), array('B')]
         if six.PY3:
            for j in xrange(4):
               self.mskarray[0].append(mask[ j & 3])
               self.mskarray[1].append(mask[(j + 1) & 3])
               self.mskarray[2].append(mask[(j + 2) & 3])
               self.mskarray[3].append(mask[(j + 3) & 3])
         else:
            for j in xrange(4):
               self.mskarray[0].append(ord(mask[ j & 3]))
               self.mskarray[1].append(ord(mask[(j + 1) & 3]))
               self.mskarray[2].append(ord(mask[(j + 2) & 3]))
               self.mskarray[3].append(ord(mask[(j + 3) & 3]))

      def pointer(self):
         return self.ptr

      def reset(self):
         self.ptr = 0

      def process(self, data):
         dlen = len(data)
         payload = array('B', data)
         msk = self.mskarray[self.ptr & 3]
         for k in xrange(dlen):
            payload[k] ^= msk[k & 3]
         self.ptr += dlen
         return payload.tostring()


   def createXorMasker(mask, len = None):
      if len is None or len < 128:
         return XorMaskerSimple(mask)
      else:
         return XorMaskerShifted1(mask)

########NEW FILE########
__FILENAME__ = autobahn_endpoints
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from zope.interface import implementer

from twisted.plugin import IPlugin
from twisted.internet.interfaces import IStreamServerEndpointStringParser, \
                                        IStreamServerEndpoint, \
                                        IStreamClientEndpointStringParser, \
                                        IStreamClientEndpoint

from twisted.internet.endpoints import serverFromString, clientFromString

from autobahn.twisted.websocket import WrappingWebSocketServerFactory, \
                                       WrappingWebSocketClientFactory


def _parseOptions(options):
   opts = {}

   if not 'url' in options:
      raise Exception("URL needed")
   else:
      opts['url'] = options['url']

   if 'compression' in options:
      value = options['compression'].lower().strip()
      if value == 'true':
         opts['enableCompression'] = True
      elif value == 'false':
         opts['enableCompression'] = False
      else:
         raise Exception("invalid value '{}' for compression".format(value))

   if 'autofrag' in options:
      try:
         value = int(options['autofrag'])
      except:
         raise Exception("invalid value '{}' for autofrag".format(options['autofrag']))

      if value < 0:
         raise Exception("negative value '{}' for autofrag".format(value))

      opts['autoFragmentSize'] = value

   if 'subprotocol' in options:
      value = options['subprotocol'].lower().strip()
      opts['subprotocol'] = value

   if 'debug' in options:
      value = options['debug'].lower().strip()
      if value == 'true':
         opts['debug'] = True
      elif value == 'false':
         opts['debug'] = False
      else:
         raise Exception("invalid value '{}' for debug".format(value))

   return opts


@implementer(IPlugin)
@implementer(IStreamServerEndpointStringParser)
class AutobahnServerParser(object):

   prefix = "autobahn"

   def parseStreamServer(self, reactor, description, **options):

      ## The present endpoint plugin is intended to be used as in the
      ## following for running a streaming protocol over WebSocket over
      ## an underlying stream transport.
      ##
      ##  endpoint = serverFromString(reactor,
      ##    "autobahn:tcp\:9000\:interface\=0.0.0.0:url=ws\://localhost\:9000:compress=false"
      ##
      ## This will result in `parseStreamServer` to be called will
      ##
      ##   description == tcp:9000:interface=0.0.0.0
      ##
      ## and
      ##
      ##   options == {'url': 'ws://localhost:9000', 'compress': 'false'}
      ##
      ## Essentially, we are using the `\:` escape to coerce the endpoint descriptor
      ## of the underyling stream transport into one (first) positional argument.
      ##
      ## Note that the `\:` within "url" is another form of escaping!
      ##
      opts = _parseOptions(options)
      endpoint = serverFromString(reactor, description)
      return AutobahnServerEndpoint(reactor, endpoint, opts)


@implementer(IPlugin)
@implementer(IStreamServerEndpoint)
class AutobahnServerEndpoint(object):

   def __init__(self, reactor, endpoint, options):
      self._reactor = reactor
      self._endpoint = endpoint
      self._options = options

   def listen(self, protocolFactory):
      return self._endpoint.listen(WrappingWebSocketServerFactory(protocolFactory, reactor = self._reactor, **self._options))


@implementer(IPlugin)
@implementer(IStreamClientEndpointStringParser)
class AutobahnClientParser(object):

   prefix = "autobahn"

## <oberstet> Is there are particular reason why "plugin.parseStreamServer" provides a "reactor" argument while "plugin.parseStreamClient" does not?
## <oberstet> http://twistedmatrix.com/trac/browser/tags/releases/twisted-13.2.0/twisted/internet/endpoints.py#L1396
## <oberstet> http://twistedmatrix.com/trac/browser/tags/releases/twisted-13.2.0/twisted/internet/endpoints.py#L1735

## => http://twistedmatrix.com/trac/ticket/4956
## => https://twistedmatrix.com/trac/ticket/5069

#   def parseStreamClient(self, reactor, description, **options):
   def parseStreamClient(self, description, **options):
      from twisted.internet import reactor
      opts = _parseOptions(options)
      endpoint = clientFromString(reactor, description)
      return AutobahnClientEndpoint(reactor, endpoint, opts)


@implementer(IPlugin)
@implementer(IStreamClientEndpoint)
class AutobahnClientEndpoint(object):

   def __init__(self, reactor, endpoint, options):
      self._reactor = reactor
      self._endpoint = endpoint
      self._options = options

   def connect(self, protocolFactory):
      return self._endpoint.connect(WrappingWebSocketClientFactory(protocolFactory, reactor = self._reactor, **self._options))


autobahnServerParser = AutobahnServerParser()
autobahnClientParser = AutobahnClientParser()

########NEW FILE########
__FILENAME__ = autobahn_twistd
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


from twisted.application.service import ServiceMaker

serviceMaker = ServiceMaker('endpointforward',
                            'autobahn.twisted.forwarder',
                            'A simple stream endpoint forwarder',
                            'endpointforward')

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Autobahn WebSockets documentation build configuration file, created by
# sphinx-quickstart on Sat Aug 13 14:17:44 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

from __future__ import absolute_import

import sys, os

try:
   import sphinx_rtd_theme
except ImportError:
   sphinx_rtd_theme = None

try:
   from sphinxcontrib import spelling
except ImportError:
   spelling = None


# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
#extensions = ['sphinx.ext.autodoc']

extensions = ['sphinx.ext.autodoc',
              'sphinx.ext.doctest',
              'sphinx.ext.intersphinx',
              'sphinx.ext.viewcode']

if spelling is not None:
   extensions.append('sphinxcontrib.spelling')

# Add any paths that contain templates here, relative to this directory.
#templates_path = ['_templates']
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'AutobahnPython'
copyright = u'2011-2014 <a href="http://tavendo.com">Tavendo GmbH</a>, <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons CC-BY-SA</a><br>Tavendo, WAMP and "Autobahn WebSocket" are trademarks of <a href="http://tavendo.com">Tavendo GmbH</a>'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#

base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir, 'autobahn'))
init = {}
with open(os.path.join(base_dir, "autobahn", "__init__.py")) as f:
   exec(f.read(), init)

version = release = init["__version__"]


# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
#pygments_style = 'sphinx'
pygments_style = 'flask_theme_support.FlaskyStyle'
# pygments_style = 'pastie'
# pygments_style = 'monokai'
# pygments_style = 'colorful'
# pygments_style = 'trac'



# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.

if False:
   if sphinx_rtd_theme:
      html_theme = "sphinx_rtd_theme"
      html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
   else:
      #html_theme = "default"
      html_theme = 'sphinxdoc'
else:
   sys.path.append(os.path.abspath('_themes'))
   html_theme_path = ['_themes']
   html_theme = 'kr'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

html_theme_options = {
#  'footertextcolor': '#ccc',
#  'sidebarbgcolor': '#111',
#  'sidebartextcolor': '#ccc',
#  'sidebarlinkcolor': '#480',
#  'relbarbgcolor': '#111',
#  'relbartextcolor': '#ccc',
#  'relbarlinkcolor': '#480',
#  'bgcolor': '#111',
#  'textcolor': '#ccc',
#  'linkcolor': '#480',
#  'headtextcolor': '#ccc',
#  'headlinkcolor': '#480',
#  'codebgcolor': '#111',
#  'codetextcolor': '#ccc',
#  'bodyfont': 'serif',
#  'headfont': 'serif',
}


# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# additional variables which become accessible in the template engine's context for
# all pages
# html_context = {'widgeturl': 'http://192.168.1.147:8090/widget'}
html_context = {'widgeturl': 'https://demo.crossbar.io/clandeckwidget'}

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    # 'index':    ['side-primary.html', 'searchbox.html'],
    '**':       ['side-secondary.html', 'stay_informed.html', 'sidetoc.html',
                 'previous_next.html', 'searchbox.html' ]
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'AutobahnPython'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'AutobahnPython.tex', u'Autobahn Python Documentation',
   u'Tavendo GmbH', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'autobahnpython', u'Autobahn Python Documentation',
     [u'Tavendo GmbH'], 1)
]

autodoc_member_order = 'bysource'

# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

rst_epilog = """
.. |ab| replace:: **Autobahn**\|Python
"""

rst_prolog = """
.. container:: topnav

   :doc:`Overview <index>` :doc:`installation` :doc:`Examples <examples>`  :doc:`WebSocket <websocketprogramming>`  :doc:`WAMP <wampprogramming>` :doc:`Reference <reference>` :doc:`TOC <table_of_contents>`

"""

# changed

########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        #Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929", # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902", # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902", # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000", # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


if __name__ == '__main__':

   import sys, argparse, asyncio


   ## parse command line arguments
   ##
   parser = argparse.ArgumentParser()

   parser.add_argument("-d", "--debug", action = "store_true",
                       help = "Enable debug output.")

   parser.add_argument("-c", "--component", type = str,
                       help = "Start WAMP client with this application component, e.g. 'timeservice.TimeServiceFrontend'")

   parser.add_argument("-r", "--realm", type = str, default = "realm1",
                       help = "The WAMP realm to start the component in (if any).")

   parser.add_argument("--host", type = str, default = "127.0.0.1",
                       help = 'IP or hostname to connect to.')

   parser.add_argument("--port", type = int, default = 8080,
                       help = 'TCP port to connect to.')

   parser.add_argument("--transport", choices = ['websocket', 'rawsocket-json', 'rawsocket-msgpack'], default = "websocket",
                       help = 'WAMP transport type')

   parser.add_argument("--url", type = str, default = None,
                       help = 'The WebSocket URL to connect to, e.g. ws://127.0.0.1:8080/ws.')

   args = parser.parse_args()


   ## create a WAMP application session factory
   ##
   from autobahn.asyncio.wamp import ApplicationSessionFactory
   from autobahn.wamp import types
   session_factory = ApplicationSessionFactory(types.ComponentConfig(realm = args.realm))


   ## dynamically load the application component ..
   ##
   import importlib
   c = args.component.split('.')
   mod, klass = '.'.join(c[:-1]), c[-1]
   app = importlib.import_module(mod)

   ## .. and set the session class on the factory
   ##
   session_factory.session = getattr(app, klass)


   if args.transport == "websocket":

      ## create a WAMP-over-WebSocket transport client factory
      ##
      from autobahn.asyncio.websocket import WampWebSocketClientFactory
      transport_factory = WampWebSocketClientFactory(session_factory, url = args.url, debug_wamp = args.debug)
      transport_factory.setProtocolOptions(failByDrop = False)

   elif args.transport in ['rawsocket-json', 'rawsocket-msgpack']:

      ## create a WAMP-over-RawSocket transport client factory
      ##
      if args.transport == 'rawsocket-msgpack':
         from autobahn.wamp.serializer import MsgPackSerializer
         serializer = MsgPackSerializer()
      elif args.transport == 'rawsocket-json':
         from autobahn.wamp.serializer import JsonSerializer
         serializer = JsonSerializer()
      else:
         raise Exception("should not arrive here")

      from autobahn.asyncio.rawsocket import WampRawSocketClientFactory
      transport_factory = WampRawSocketClientFactory(session_factory, serializer, debug = args.debug)


   ## start the client
   loop = asyncio.get_event_loop()
   coro = loop.create_connection(transport_factory, args.host, args.port)
   loop.run_until_complete(coro)

   ## now enter the asyncio event loop
   loop.run_forever()
   loop.close()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that publishes an event every second.
   """

   @asyncio.coroutine
   def onJoin(self, details):
      counter = 0
      while True:
         self.publish('com.myapp.topic1', counter)
         counter += 1
         yield from asyncio.sleep(1)

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that subscribes and receives events,
   and stop after having received 5 events.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      self.received = 0

      def on_event(i):
         print("Got event: {}".format(i))
         self.received += 1
         if self.received > 5:
            self.leave()

      yield from self.subscribe(on_event, 'com.myapp.topic1')


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import random

import asyncio

from autobahn.wamp.types import SubscribeOptions
from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that publishes events with no payload
   and with complex payloads every second.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      counter = 0
      while True:
         self.publish('com.myapp.heartbeat')

         obj = {'counter': counter, 'foo': [1, 2, 3]}
         self.publish('com.myapp.topic2', random.randint(0, 100), 23, c = "Hello", d = obj)

         counter += 1
         yield from asyncio.sleep(1)

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import random

import asyncio

from autobahn.wamp.types import SubscribeOptions
from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that subscribes and receives events
   of no payload and of complex payload, and stops after 5 seconds.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      self.received = 0

      def on_heartbeat(details = None):
         print("Got heartbeat (publication ID {})".format(details.publication))

      yield from self.subscribe(on_heartbeat, 'com.myapp.heartbeat', options = SubscribeOptions(details_arg = 'details'))


      def on_topic2(a, b, c = None, d = None):
         print("Got event: {} {} {} {}".format(a, b, c, d))

      yield from self.subscribe(on_topic2, 'com.myapp.topic2')


      asyncio.get_event_loop().call_later(5, self.leave)


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that publishes an event every second.
   """

   @asyncio.coroutine
   def onJoin(self, details):
      counter = 0
      while True:
         self.publish('com.myapp.topic1', counter)
         self.publish('com.myapp.topic2', "Hello world.")
         counter += 1
         yield from asyncio.sleep(1)

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn import wamp
from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that subscribes and receives events,
   and stop after having received 5 events.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      self.received = 0

      ## subscribe all methods on this object decorated with "@wamp.topic"
      ## as PubSub event handlers
      ##
      results = yield from self.subscribe(self)
      for res in results:
         if isinstance(res, wamp.protocol.Subscription):
            ## res is an Subscription instance
            print("Ok, subscribed handler with subscription ID {}".format(res.id))
         else:
            ## res is an Failure instance
            print("Failed to subscribe handler: {}".format(res))


   @wamp.topic('com.myapp.topic1')
   def onEvent1(self, i):
      print("Got event on topic1: {}".format(i))
      self.received += 1
      if self.received > 5:
         self.leave()


   @wamp.topic('com.myapp.topic2')
   def onEvent2(self, msg):
      print("Got event on topic2: {}".format(msg))


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.wamp.types import PublishOptions, EventDetails, SubscribeOptions
from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that publishes an event every second.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      def on_event(i):
         print("Got event: {}".format(i))

      yield from self.subscribe(on_event, 'com.myapp.topic1')


      counter = 0
      while True:
         publication = yield from self.publish('com.myapp.topic1', counter,
               options = PublishOptions(acknowledge = True, discloseMe = True, excludeMe = False))
         print("Event published with publication ID {}".format(publication.id))
         counter += 1
         yield from asyncio.sleep(1)

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.wamp.types import PublishOptions, EventDetails, SubscribeOptions
from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that subscribes and receives events,
   and stop after having received 5 events.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      self.received = 0

      def on_event(i, details = None):
         print("Got event, publication ID {}, publisher {}: {}".format(details.publication, details.publisher, i))
         self.received += 1
         if self.received > 5:
            self.leave()

      yield from self.subscribe(on_event, 'com.myapp.topic1',
         options = SubscribeOptions(details_arg = 'details'))


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that publishes an event every second.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      counter = 0
      while True:
         self.publish('com.myapp.topic1', counter)
         counter += 1
         yield from asyncio.sleep(1)

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that subscribes and receives events.
   After receiving 5 events, it unsubscribes, sleeps and then
   resubscribes for another run. Then it stops.
   """

   @asyncio.coroutine
   def test(self):

      self.received = 0

      #@asyncio.coroutine
      def on_event(i):
         print("Got event: {}".format(i))
         self.received += 1
         if self.received > 5:
            self.runs += 1
            if self.runs > 1:
               self.leave()
            else:
               self.subscription.unsubscribe()
               #yield from self.subscription.unsubscribe()
               print("Unsubscribed .. continue in 2s ..")

               ## FIXME
               asyncio.get_event_loop().call_later(2, self.test)

      self.subscription = yield from self.subscribe(on_event, 'com.myapp.topic1')
      print("Subscribed with subscription ID {}".format(self.subscription.id))


   @asyncio.coroutine
   def onJoin(self, details):

      self.runs = 0
      yield from self.test()


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component providing procedures with different kinds of arguments.
   """

   def onJoin(self, details):

      def ping():
         return

      def add2(a, b):
         return a + b

      def stars(nick = "somebody", stars = 0):
         return u"{} starred {}x".format(nick, stars)

      def orders(product, limit = 5):
         return [u"Product {}".format(i) for i in range(50)][:limit]

      def arglen(*args, **kwargs):
         return [len(args), len(kwargs)]

      self.register(ping, u'com.arguments.ping')
      self.register(add2, u'com.arguments.add2')
      self.register(stars, u'com.arguments.stars')
      self.register(orders, u'com.arguments.orders')
      self.register(arglen, u'com.arguments.arglen')

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component calling the different backend procedures.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      yield from self.call('com.arguments.ping')
      print("Pinged!")

      res = yield from self.call('com.arguments.add2', 2, 3)
      print("Add2: {}".format(res))

      starred = yield from self.call('com.arguments.stars')
      print("Starred 1: {}".format(starred))

      starred = yield from self.call('com.arguments.stars', nick = u'Homer')
      print("Starred 2: {}".format(starred))

      starred = yield from self.call('com.arguments.stars', stars = 5)
      print("Starred 3: {}".format(starred))

      starred = yield from self.call('com.arguments.stars', nick = u'Homer', stars = 5)
      print("Starred 4: {}".format(starred))

      orders = yield from self.call('com.arguments.orders', u'coffee')
      print("Orders 1: {}".format(orders))

      orders = yield from self.call('com.arguments.orders', u'coffee', limit = 10)
      print("Orders 2: {}".format(orders))

      arglengths = yield from self.call('com.arguments.arglen')
      print("Arglen 1: {}".format(arglengths))

      arglengths = yield from self.call('com.arguments.arglen', 1, 2, 3)
      print("Arglen 1: {}".format(arglengths))

      arglengths = yield from self.call('com.arguments.arglen', a = 1, b = 2, c = 3)
      print("Arglen 2: {}".format(arglengths))

      arglengths = yield from self.call('com.arguments.arglen', 1, 2, 3, a = 1, b = 2, c = 3)
      print("Arglen 3: {}".format(arglengths))

      self.leave()


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.wamp.types import CallResult
from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   Application component that provides procedures which
   return complex results.
   """

   def onJoin(self, details):

      def add_complex(a, ai, b, bi):
         return CallResult(c = a + b, ci = ai + bi)

      self.register(add_complex, 'com.myapp.add_complex')

      def split_name(fullname):
         forename, surname = fullname.split()
         return CallResult(forename, surname)

      self.register(split_name, 'com.myapp.split_name')

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.wamp.types import CallResult
from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   Application component that calls procedures which
   produce complex results and showing how to access those.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      res = yield from self.call('com.myapp.add_complex', 2, 3, 4, 5)
      print("Result: {} + {}i".format(res.kwresults['c'], res.kwresults['ci']))

      res = yield from self.call('com.myapp.split_name', 'Homer Simpson')
      print("Forname: {}, Surname: {}".format(res.results[0], res.results[1]))

      self.leave()


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime

import asyncio

from autobahn import wamp
from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component registering RPC endpoints using decorators.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      ## register all methods on this object decorated with "@wamp.procedure"
      ## as a RPC endpoint
      ##
      results = yield from self.register(self)
      for res in results:
         if isinstance(res, wamp.protocol.Registration):
            ## res is an Registration instance
            print("Ok, registered procedure with registration ID {}".format(res.id))
         else:
            ## res is an Failure instance
            print("Failed to register procedure: {}".format(res))


   @wamp.procedure('com.mathservice.add2')
   def add2(self, x, y):
      return x + y


   @wamp.procedure('com.mathservice.mul2')
   def mul2(self, x, y):
      return x * y


   @wamp.procedure('com.mathservice.div2')
   def square(self, x, y):
      if y:
         return float(x) / float(y)
      else:
         return 0

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component calling the different backend procedures.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      procs = [u'com.mathservice.add2',
               u'com.mathservice.mul2',
               u'com.mathservice.div2']

      try:
         for proc in procs:
            res = yield from self.call(proc, 2, 3)
            print("{}: {}".format(proc, res))
      except Exception as e:
         print("Something went wrong: {}".format(e))

      self.leave()


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import math

import asyncio

from autobahn import wamp
from autobahn.wamp.exception import ApplicationError
from autobahn.asyncio.wamp import ApplicationSession



@wamp.error("com.myapp.error1")
class AppError1(Exception):
   """
   An application specific exception that is decorated with a WAMP URI,
   and hence can be automapped by Autobahn.
   """



class Component(ApplicationSession):
   """
   Example WAMP application backend that raised exceptions.
   """

   def onJoin(self, details):

      ## raising standard exceptions
      ##
      def sqrt(x):
         if x == 0:
            raise Exception("don't ask folly questions;)")
         else:
            ## this also will raise, if x < 0
            return math.sqrt(x)

      self.register(sqrt, 'com.myapp.sqrt')


      ## raising WAMP application exceptions
      ##
      def checkname(name):
         if name in ['foo', 'bar']:
            raise ApplicationError("com.myapp.error.reserved")

         if name.lower() != name.upper():
            ## forward positional arguments in exceptions
            raise ApplicationError("com.myapp.error.mixed_case", name.lower(), name.upper())

         if len(name) < 3 or len(name) > 10:
            ## forward keyword arguments in exceptions
            raise ApplicationError("com.myapp.error.invalid_length", min = 3, max = 10)

      self.register(checkname, 'com.myapp.checkname')


      ## defining and automapping WAMP application exceptions
      ##
      self.define(AppError1)

      def compare(a, b):
         if a < b:
            raise AppError1(b - a)

      self.register(compare, 'com.myapp.compare')

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import math

import asyncio

from autobahn import wamp
from autobahn.wamp.exception import ApplicationError
from autobahn.asyncio.wamp import ApplicationSession



@wamp.error("com.myapp.error1")
class AppError1(Exception):
   """
   An application specific exception that is decorated with a WAMP URI,
   and hence can be automapped by Autobahn.
   """



class Component(ApplicationSession):
   """
   Example WAMP application frontend that catches exceptions.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      ## catching standard exceptions
      ##
      for x in [2, 0, -2]:
         try:
            res = yield from self.call('com.myapp.sqrt', x)
         except Exception as e:
            print("Error: {} {}".format(e, e.args))
         else:
            print("Result: {}".format(res))


      ## catching WAMP application exceptions
      ##
      for name in ['foo', 'a', '*'*11, 'Hello']:
         try:
            res = yield from self.call('com.myapp.checkname', name)
         except ApplicationError as e:
            print("Error: {} {} {} {}".format(e, e.error, e.args, e.kwargs))
         else:
            print("Result: {}".format(res))


      ## defining and automapping WAMP application exceptions
      ##
      self.define(AppError1)

      try:
         yield from self.call('com.myapp.compare', 3, 17)
      except AppError1 as e:
         print("Compare Error: {}".format(e))


      self.leave()


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.wamp.types import CallOptions, RegisterOptions, PublishOptions
from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component providing procedures with
   different kinds of arguments.
   """

   def onJoin(self, details):

      def square(val, details = None):
         print("square called from: {}".format(details.caller))

         if val < 0:
            self.publish('com.myapp.square_on_nonpositive', val)
         elif val == 0:
            if details.caller:
               options = PublishOptions(exclude = [details.caller])
            else:
               options = None
            self.publish('com.myapp.square_on_nonpositive', val, options = options)
         return val * val

      self.register(square, 'com.myapp.square', RegisterOptions(details_arg = 'details'))

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.wamp.types import CallOptions, RegisterOptions, PublishOptions
from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component calling the different backend procedures.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      def on_event(val):
         print("Someone requested to square non-positive: {}".format(val))

      yield from self.subscribe(on_event, 'com.myapp.square_on_nonpositive')

      for val in [2, 0, -2]:
         res = yield from self.call('com.myapp.square', val, options = CallOptions(discloseMe = True))
         print("Squared {} = {}".format(val, res))

      self.leave()


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.wamp.types import CallOptions, RegisterOptions
from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   Application component that produces progressive results.
   """

   def onJoin(self, details):

      @asyncio.coroutine
      def longop(n, details = None):
         if details.progress:
            for i in range(n):
               details.progress(i)
               yield from asyncio.sleep(1)
         else:
            yield from asyncio.sleep(1 * n)
         return n

      self.register(longop, 'com.myapp.longop', RegisterOptions(details_arg = 'details'))

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.wamp.types import CallOptions, RegisterOptions
from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   Application component that consumes progressive results.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      def on_progress(i):
         print("Progress: {}".format(i))

      res = yield from self.call('com.myapp.longop', 3, options = CallOptions(onProgress = on_progress))

      print("Final: {}".format(res))

      self.leave()


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import asyncio

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   A math service application component.
   """

   def onJoin(self, details):

      def square(x):
         return x * x

      self.register(square, 'com.math.square')


      @asyncio.coroutine
      def slowsquare(x, delay = 1):
         yield from asyncio.sleep(delay)
         return x * x

      self.register(slowsquare, 'com.math.slowsquare')

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import time
import asyncio
from functools import partial

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component using the time service.
   """

   @asyncio.coroutine
   def onJoin(self, details):

      def got(started, msg, f):
         res = f.result()
         duration = 1000. * (time.clock() - started)
         print("{}: {} in {}".format(msg, res, duration))

      t1 = time.clock()
      d1 = self.call('com.math.slowsquare', 3, 2)
      d1.add_done_callback(partial(got, t1, "Slow Square"))

      t2 = time.clock()
      d2 = self.call('com.math.square', 3)
      d2.add_done_callback(partial(got, t2, "Quick Square"))

      yield from asyncio.gather(d1, d2)
      print("All finished.")
      self.leave()


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   A simple time service application component.
   """

   def onJoin(self, details):

      def utcnow():
         now = datetime.datetime.utcnow()
         return now.strftime("%Y-%m-%dT%H:%M:%SZ")

      self.register(utcnow, 'com.timeservice.now')

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime
import asyncio

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component using the time service.
   """

   @asyncio.coroutine
   def onJoin(self, details):
      try:
         now = yield from self.call('com.timeservice.now')
      except Exception as e:
         print("Error: {}".format(e))
      else:
         print("Current time from time service: {}".format(now))

      self.leave()


   def onDisconnect(self):
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


if __name__ == '__main__':

   import sys, argparse, asyncio


   ## parse command line arguments
   ##
   parser = argparse.ArgumentParser()

   parser.add_argument("-d", "--debug", action = "store_true",
                       help = "Enable debug output.")

   parser.add_argument("-c", "--component", type = str, default = None,
                       help = "Start WAMP server with this application component, e.g. 'timeservice.TimeServiceBackend', or None.")

   parser.add_argument("-r", "--realm", type = str, default = "realm1",
                       help = "The WAMP realm to start the component in (if any).")

   parser.add_argument("--interface", type = str, default = "127.0.0.1",
                       help = 'IP of interface to listen on.')

   parser.add_argument("--port", type = int, default = 8080,
                       help = 'TCP port to listen on.')

   parser.add_argument("--transport", choices = ['websocket', 'rawsocket-json', 'rawsocket-msgpack'], default = "websocket",
                       help = 'WAMP transport type')

   args = parser.parse_args()


   ## create a WAMP router factory
   ##
   from autobahn.wamp.router import RouterFactory
   router_factory = RouterFactory()


   ## create a WAMP router session factory
   ##
   from autobahn.asyncio.wamp import RouterSessionFactory
   session_factory = RouterSessionFactory(router_factory)


   ## if asked to start an embedded application component ..
   ##
   if args.component:
      ## dynamically load the application component ..
      ##
      import importlib
      c = args.component.split('.')
      mod, klass = '.'.join(c[:-1]), c[-1]
      app = importlib.import_module(mod)
      SessionKlass = getattr(app, klass)

      ## .. and create and add an WAMP application session to
      ## run next to the router
      ##
      from autobahn.wamp import types
      session_factory.add(SessionKlass(types.ComponentConfig(realm = args.realm)))


   if args.transport == "websocket":

      ## create a WAMP-over-WebSocket transport server factory
      ##
      from autobahn.asyncio.websocket import WampWebSocketServerFactory
      transport_factory = WampWebSocketServerFactory(session_factory, debug_wamp = args.debug)
      transport_factory.setProtocolOptions(failByDrop = False)

   elif args.transport in ['rawsocket-json', 'rawsocket-msgpack']:

      ## create a WAMP-over-RawSocket transport server factory
      ##
      if args.transport == 'rawsocket-msgpack':
         from autobahn.wamp.serializer import MsgPackSerializer
         serializer = MsgPackSerializer()
      elif args.transport == 'rawsocket-json':
         from autobahn.wamp.serializer import JsonSerializer
         serializer = JsonSerializer()
      else:
         raise Exception("should not arrive here")

      from autobahn.asyncio.rawsocket import WampRawSocketServerFactory
      transport_factory = WampRawSocketServerFactory(session_factory, serializer, debug = args.debug)

   else:
      raise Exception("should not arrive here")


   ## start the server from an endpoint
   ##
   loop = asyncio.get_event_loop()
   coro = loop.create_server(transport_factory, args.interface, args.port)
   server = loop.run_until_complete(coro)

   try:
      ## now enter the asyncio event loop
      loop.run_forever()
   except KeyboardInterrupt:
      pass
   finally:
      server.close()
      loop.close()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   A simple time service application component.
   """

   def onJoin(self, details):

      def utcnow():
         now = datetime.datetime.utcnow()
         return now.strftime("%Y-%m-%dT%H:%M:%SZ")

      self.register(utcnow, 'com.timeservice.now')

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime

import asyncio

from autobahn.asyncio.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component using the time service
   during 3 subsequent WAMP sessions, while the
   underlying transport continues to exist.
   """

   def __init__(self, config):
      ApplicationSession.__init__(self, config)
      self.count = 0


   @asyncio.coroutine
   def onJoin(self, details):
      print("Realm joined (WAMP session started).")

      try:
         now = yield from self.call('com.timeservice.now')
      except Exception as e:
         print("Error: {}".format(e))
      else:
         print("Current time from time service: {}".format(now))

      self.leave()


   def onLeave(self, details):
      print("Realm left (WAMP session ended).")
      self.count += 1
      if self.count < 3:
         self.join("realm1")
      else:
         self.disconnect()


   def onDisconnect(self):
      print("Transport disconnected.")
      asyncio.get_event_loop().stop()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys
import asyncio

from autobahn.asyncio import wamp, websocket


class MyFrontendComponent(wamp.ApplicationSession):
   """
   Application code goes here. This is an example component that calls
   a remote procedure on a WAMP peer, subscribes to a topic to receive
   events, and then stops the world after some events.
   """
   def onConnect(self):
      self.join(u"realm1")

   @asyncio.coroutine
   def onJoin(self, details):

      ## call a remote procedure
      ##
      try:
         now = yield from self.call(u'com.timeservice.now')
      except Exception as e:
         print("Error: {}".format(e))
      else:
         print("Current time from time service: {}".format(now))

      ## subscribe to a topic
      ##
      self.received = 0

      def on_event(i):
         print("Got event: {}".format(i))
         self.received += 1
         if self.received > 5:
            self.leave()

      sub = yield from self.subscribe(on_event, u'com.myapp.topic1')
      print("Subscribed with subscription ID {}".format(sub.id))

   def onLeave(self, details):
      self.disconnect()

   def onDisconnect(self):
      asyncio.get_event_loop().stop()


if __name__ == '__main__':

   ## 1) create a WAMP application session factory
   session_factory = wamp.ApplicationSessionFactory()
   session_factory.session = MyFrontendComponent

   ## 2) create a WAMP-over-WebSocket transport client factory
   transport_factory = websocket.WampWebSocketClientFactory(session_factory, \
                                                            debug = False, \
                                                            debug_wamp = False)

   ## 3) start the client
   loop = asyncio.get_event_loop()
   coro = loop.create_connection(transport_factory, '127.0.0.1', 8080)
   loop.run_until_complete(coro)

   ## 4) now enter the asyncio event loop
   loop.run_forever()
   loop.close()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys
import six
import datetime
import asyncio

from autobahn.wamp import router
from autobahn.asyncio import wamp, websocket



class MyBackendComponent(wamp.ApplicationSession):
   """
   Application code goes here. This is an example component that provides
   a simple procedure which can be called remotely from any WAMP peer.
   It also publishes an event every second to some topic.
   """
   def onConnect(self):
      self.join(u"realm1")

   @asyncio.coroutine
   def onJoin(self, details):
      ## register a procedure for remote calling
      ##
      def utcnow():
         print("Someone is calling me;)")
         now = datetime.datetime.utcnow()
         return six.u(now.strftime("%Y-%m-%dT%H:%M:%SZ"))

      reg = yield from self.register(utcnow, u'com.timeservice.now')
      print("Registered procedure with ID {}".format(reg.id))

      ## publish events to a topic
      ##
      counter = 0
      while True:
         self.publish(u'com.myapp.topic1', counter)
         print("Published event.")
         counter += 1
         yield from asyncio.sleep(1)


if __name__ == '__main__':

   ## 1) create a WAMP router factory
   router_factory = router.RouterFactory()

   ## 2) create a WAMP router session factory
   session_factory = wamp.RouterSessionFactory(router_factory)

   ## 3) Optionally, add embedded WAMP application sessions to the router
   session_factory.add(MyBackendComponent())

   ## 4) create a WAMP-over-WebSocket transport server factory
   transport_factory = websocket.WampWebSocketServerFactory(session_factory,
                                                            debug = False,
                                                            debug_wamp = False)

   ## 5) start the server
   loop = asyncio.get_event_loop()
   coro = loop.create_server(transport_factory, '127.0.0.1', 8080)
   server = loop.run_until_complete(coro)

   try:
      ## 6) now enter the asyncio event loop
      loop.run_forever()
   except KeyboardInterrupt:
      pass
   finally:
      server.close()
      loop.close()

########NEW FILE########
__FILENAME__ = calculator
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn import wamp


class Calculator(object):
   """
   An application component registering RPC endpoints using decorators.
   """

   @wamp.procedure('com.mathservice.add2')
   def add2(self, x, y):
      return x + y


   @wamp.procedure('com.mathservice.mul2')
   def mul2(self, x, y):
      return x * y


   @wamp.procedure('com.mathservice.div2')
   def square(self, x, y):
      if y:
         return float(x) / float(y)
      else:
         return 0

########NEW FILE########
__FILENAME__ = component1
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime
import asyncio

from autobahn import wamp
from autobahn.asyncio.wamp import ApplicationSession

from calculator import Calculator



## WAMP application component with our app code.
##
class Component1(ApplicationSession):

   @asyncio.coroutine
   def onJoin(self, details):

      ## register a function that can be called remotely
      ##
      def utcnow():
         now = datetime.datetime.utcnow()
         return now.strftime("%Y-%m-%dT%H:%M:%SZ")

      reg = yield from self.register(utcnow, 'com.timeservice.now')
      print("Procedure registered with ID {}".format(reg.id))

      ## create an application object that exposes methods for remoting
      ##
      self.calculator = Calculator()

      ## register all methods on the "calculator" decorated with "@wamp.procedure"
      ##
      results = yield from self.register(self.calculator)
      for res in results:
         if isinstance(res, wamp.protocol.Registration):
            print("Ok, registered procedure with registration ID {}".format(res.id))
         else:
            print("Failed to register procedure: {}".format(res))


   def onDisconnect(self):
      asyncio.get_event_loop().stop()



def make(config):
   ##
   ## This component factory creates instances of the
   ## application component to run.
   ##
   ## The function will get called either during development
   ## using the ApplicationRunner below, or as  a plugin running
   ## hosted in a WAMPlet container such as a Crossbar.io worker.
   ##
   if config:
      return Component1(config)
   else:
      ## if no config given, return a description of this WAMPlet ..
      return {'label': 'Awesome WAMPlet 1',
              'description': 'This is just a test WAMPlet that provides some procedures to call.'}



if __name__ == '__main__':
   from autobahn.asyncio.wamp import ApplicationRunner

   ## test drive the component during development ..
   runner = ApplicationRunner(
      url = "ws://127.0.0.1:8080/ws",
      realm = "realm1",
      debug = False, ## low-level WebSocket debugging
      debug_wamp = False, ## WAMP protocol-level debugging
      debug_app = True) ## app-level debugging

   runner.run(make)

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.asyncio.websocket import WebSocketClientProtocol, \
                                       WebSocketClientFactory



class MyClientProtocol(WebSocketClientProtocol):

   def onConnect(self, response):
      print("Server connected: {0}".format(response.peer))

   def onOpen(self):
      print("WebSocket connection open.")

      def hello():
         self.sendMessage(u"Hello, world!".encode('utf8'))
         self.sendMessage(b"\x00\x01\x03\x04", isBinary = True)
         self.factory.loop.call_later(1, hello)

      ## start sending messages every second ..
      hello()

   def onMessage(self, payload, isBinary):
      if isBinary:
         print("Binary message received: {0} bytes".format(len(payload)))
      else:
         print("Text message received: {0}".format(payload.decode('utf8')))

   def onClose(self, wasClean, code, reason):
      print("WebSocket connection closed: {0}".format(reason))



if __name__ == '__main__':

   import asyncio

   factory = WebSocketClientFactory("ws://localhost:9000", debug = False)
   factory.protocol = MyClientProtocol

   loop = asyncio.get_event_loop()
   coro = loop.create_connection(factory, '127.0.0.1', 9000)
   loop.run_until_complete(coro)
   loop.run_forever()
   loop.close()

########NEW FILE########
__FILENAME__ = client_coroutines
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.asyncio.websocket import WebSocketClientProtocol, \
                                       WebSocketClientFactory

import asyncio



class MyClientProtocol(WebSocketClientProtocol):

   def onConnect(self, response):
      print("Server connected: {0}".format(response.peer))

   @asyncio.coroutine
   def onOpen(self):
      print("WebSocket connection open.")

      ## start sending messages every second ..
      while True:
         self.sendMessage(u"Hello, world!".encode('utf8'))
         self.sendMessage(b"\x00\x01\x03\x04", isBinary = True)
         yield from asyncio.sleep(1)

   def onMessage(self, payload, isBinary):
      if isBinary:
         print("Binary message received: {0} bytes".format(len(payload)))
      else:
         print("Text message received: {0}".format(payload.decode('utf8')))

   def onClose(self, wasClean, code, reason):
      print("WebSocket connection closed: {0}".format(reason))



if __name__ == '__main__':

   import asyncio

   factory = WebSocketClientFactory("ws://localhost:9000", debug = False)
   factory.protocol = MyClientProtocol

   loop = asyncio.get_event_loop()
   coro = loop.create_connection(factory, '127.0.0.1', 9000)
   loop.run_until_complete(coro)
   loop.run_forever()
   loop.close()

########NEW FILE########
__FILENAME__ = client_coroutines_py2
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.asyncio.websocket import WebSocketClientProtocol, \
                                       WebSocketClientFactory

import asyncio



class MyClientProtocol(WebSocketClientProtocol):

   def onConnect(self, response):
      print("Server connected: {0}".format(response.peer))

   @asyncio.coroutine
   def onOpen(self):
      print("WebSocket connection open.")

      ## start sending messages every second ..
      while True:
         self.sendMessage(u"Hello, world!".encode('utf8'))
         self.sendMessage(b"\x00\x01\x03\x04", isBinary = True)
         yield asyncio.sleep(1)

   def onMessage(self, payload, isBinary):
      if isBinary:
         print("Binary message received: {0} bytes".format(len(payload)))
      else:
         print("Text message received: {0}".format(payload.decode('utf8')))

   def onClose(self, wasClean, code, reason):
      print("WebSocket connection closed: {0}".format(reason))



if __name__ == '__main__':

   import asyncio

   factory = WebSocketClientFactory("ws://localhost:9000", debug = False)
   factory.protocol = MyClientProtocol

   loop = asyncio.get_event_loop()
   coro = loop.create_connection(factory, '127.0.0.1', 9000)
   loop.run_until_complete(coro)
   loop.run_forever()
   loop.close()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.asyncio.websocket import WebSocketServerProtocol, \
                                       WebSocketServerFactory


class MyServerProtocol(WebSocketServerProtocol):

   def onConnect(self, request):
      print("Client connecting: {0}".format(request.peer))

   def onOpen(self):
      print("WebSocket connection open.")

   def onMessage(self, payload, isBinary):
      if isBinary:
         print("Binary message received: {0} bytes".format(len(payload)))
      else:
         print("Text message received: {0}".format(payload.decode('utf8')))

      ## echo back message verbatim
      self.sendMessage(payload, isBinary)

   def onClose(self, wasClean, code, reason):
      print("WebSocket connection closed: {0}".format(reason))



if __name__ == '__main__':

   import asyncio

   factory = WebSocketServerFactory("ws://localhost:9000", debug = False)
   factory.protocol = MyServerProtocol

   loop = asyncio.get_event_loop()
   coro = loop.create_server(factory, '127.0.0.1', 9000)
   server = loop.run_until_complete(coro)

   try:
      loop.run_forever()
   except KeyboardInterrupt:
      pass
   finally:
      server.close()
      loop.close()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.asyncio.websocket import WebSocketClientProtocol, \
                                       WebSocketClientFactory

import json, random


class SlowSquareClientProtocol(WebSocketClientProtocol):

   def onOpen(self):
      x = 10. * random.random()
      self.sendMessage(json.dumps(x).encode('utf8'))
      print("Request to square {} sent.".format(x))

   def onMessage(self, payload, isBinary):
      if not isBinary:
         res = json.loads(payload.decode('utf8'))
         print("Result received: {}".format(res))
         self.sendClose()

   def onClose(self, wasClean, code, reason):
      if reason:
         print(reason)
      loop.stop()



if __name__ == '__main__':

   import asyncio

   factory = WebSocketClientFactory("ws://localhost:9000", debug = False)
   factory.protocol = SlowSquareClientProtocol

   loop = asyncio.get_event_loop()
   coro = loop.create_connection(factory, '127.0.0.1', 9000)
   loop.run_until_complete(coro)
   loop.run_forever()
   loop.close()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.asyncio.websocket import WebSocketServerProtocol, \
                                       WebSocketServerFactory

import asyncio
import json


class SlowSquareServerProtocol(WebSocketServerProtocol):

   @asyncio.coroutine
   def slowsquare(self, x):
      if x > 5:
         raise Exception("number too large")
      else:
         yield from asyncio.sleep(1)
         return x * x

   @asyncio.coroutine
   def onMessage(self, payload, isBinary):
      if not isBinary:
         x = json.loads(payload.decode('utf8'))
         try:
            res = yield from self.slowsquare(x)
         except Exception as e:
            self.sendClose(1000, str(e))
         else:
            self.sendMessage(json.dumps(res).encode('utf8'))



if __name__ == '__main__':

   import asyncio

   factory = WebSocketServerFactory("ws://localhost:9000", debug = False)
   factory.protocol = SlowSquareServerProtocol

   loop = asyncio.get_event_loop()
   coro = loop.create_server(factory, '127.0.0.1', 9000)
   server = loop.run_until_complete(coro)

   try:
      loop.run_forever()
   except KeyboardInterrupt:
      pass
   finally:
      server.close()
      loop.close()

########NEW FILE########
__FILENAME__ = server_py2
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.asyncio.websocket import WebSocketServerProtocol, \
                                       WebSocketServerFactory

import asyncio
import json


class SlowSquareServerProtocol(WebSocketServerProtocol):

   @asyncio.coroutine
   def slowsquare(self, x):
      if x > 5:
         raise Exception("number too large")
      else:
         yield asyncio.sleep(1)
         raise asyncio.Return(x * x)

   @asyncio.coroutine
   def onMessage(self, payload, isBinary):
      if not isBinary:
         x = json.loads(payload.decode('utf8'))
         try:
            res = yield self.slowsquare(x)
         except Exception as e:
            self.sendClose(1000, str(e))
         else:
            self.sendMessage(json.dumps(res).encode('utf8'))



if __name__ == '__main__':

   import asyncio

   factory = WebSocketServerFactory("ws://localhost:9000", debug = False)
   factory.protocol = SlowSquareServerProtocol

   loop = asyncio.get_event_loop()
   coro = loop.create_server(factory, '127.0.0.1', 9000)
   server = loop.run_until_complete(coro)

   try:
      loop.run_forever()
   except KeyboardInterrupt:
      pass
   finally:
      server.close()
      loop.close()

########NEW FILE########
__FILENAME__ = testee_server
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import autobahn

from autobahn.asyncio.websocket import WebSocketServerProtocol, \
                                       WebSocketServerFactory

from autobahn.websocket.compress import *



class TesteeServerProtocol(WebSocketServerProtocol):

   def onMessage(self, payload, isBinary):
      self.sendMessage(payload, isBinary)



class StreamingTesteeServerProtocol(WebSocketServerProtocol):

   def onMessageBegin(self, isBinary):
      WebSocketServerProtocol.onMessageBegin(self, isBinary)
      self.beginMessage(isBinary)

   def onMessageFrameBegin(self, length):
      WebSocketServerProtocol.onMessageFrameBegin(self, length)
      self.beginMessageFrame(length)

   def onMessageFrameData(self, payload):
      self.sendMessageFrameData(payload)

   def onMessageFrameEnd(self):
      pass

   def onMessageEnd(self):
      self.endMessage()



class TesteeServerFactory(WebSocketServerFactory):

   #protocol = TesteeServerProtocol
   protocol = StreamingTesteeServerProtocol

   def __init__(self, url, debug = False, ident = None):
      if ident is not None:
         server = ident
      else:
         server = "AutobahnPython-Asyncio/%s" % autobahn.version
      WebSocketServerFactory.__init__(self, url, debug = debug, debugCodePaths = debug, server = server)
      self.setProtocolOptions(failByDrop = False) # spec conformance
      self.setProtocolOptions(failByDrop = True) # needed for streaming mode
      #self.setProtocolOptions(utf8validateIncoming = False)

      ## enable permessage-deflate
      ##
      def accept(offers):
         for offer in offers:
            if isinstance(offer, PerMessageDeflateOffer):
               return PerMessageDeflateOfferAccept(offer)

      self.setProtocolOptions(perMessageCompressionAccept = accept)



if __name__ == '__main__':

   import asyncio

   factory = TesteeServerFactory("ws://localhost:9002", debug = False)

   loop = asyncio.get_event_loop()
   coro = loop.create_server(factory, port = 9002)
   server = loop.run_until_complete(coro)

   try:
      loop.run_forever()
   except KeyboardInterrupt:
      pass
   finally:
      server.close()
      loop.close()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime

from autobahn.twisted.wamp import ApplicationSession


class TimeService(ApplicationSession):
   """
   A simple time service application component.
   """

   def __init__(self, realm = "realm1"):
      ApplicationSession.__init__(self)
      self._realm = realm


   def onConnect(self):
      self.join(self._realm)


   def onJoin(self, details):

      def utcnow():
         now = datetime.datetime.utcnow()
         return now.strftime("%Y-%m-%dT%H:%M:%SZ")

      self.register(utcnow, 'com.timeservice.now')



from twisted.python import log
from autobahn.twisted.websocket import WampWebSocketServerProtocol, WampWebSocketServerFactory
from twisted.internet.defer import Deferred

import json
import urllib
import Cookie

from autobahn.util import newid, utcnow
from autobahn.websocket import http


class ServerProtocol(WampWebSocketServerProtocol):

   ## authid -> cookie -> set(connection)

   def onConnect(self, request):
      protocol, headers = WampWebSocketServerProtocol.onConnect(self, request)

      ## our cookie tracking ID
      self._cbtid = None

      ## see if there already is a cookie set ..
      if request.headers.has_key('cookie'):
         try:
            cookie = Cookie.SimpleCookie()
            cookie.load(str(request.headers['cookie']))
         except Cookie.CookieError:
            pass
         else:
            if cookie.has_key('cbtid'):
               cbtid = cookie['cbtid'].value
               if self.factory._cookies.has_key(cbtid):
                  self._cbtid = cbtid
                  log.msg("Cookie already set: %s" % self._cbtid)

      ## if no cookie is set, create a new one ..
      if self._cbtid is None:

         self._cbtid = newid()
         maxAge = 86400

         cbtData = {'created': utcnow(),
                    'authenticated': None,
                    'maxAge': maxAge,
                    'connections': set()}

         self.factory._cookies[self._cbtid] = cbtData

         ## do NOT add the "secure" cookie attribute! "secure" refers to the
         ## scheme of the Web page that triggered the WS, not WS itself!!
         ##
         headers['Set-Cookie'] = 'cbtid=%s;max-age=%d' % (self._cbtid, maxAge)
         log.msg("Setting new cookie: %s" % self._cbtid)

      ## add this WebSocket connection to the set of connections
      ## associated with the same cookie
      self.factory._cookies[self._cbtid]['connections'].add(self)

      self._authenticated = self.factory._cookies[self._cbtid]['authenticated']

      ## accept the WebSocket connection, speaking subprotocol `protocol`
      ## and setting HTTP headers `headers`
      return (protocol, headers)



from autobahn.twisted.wamp import RouterSession
from autobahn.wamp import types


class MyRouterSession(RouterSession):

   def onOpen(self, transport):
      RouterSession.onOpen(self, transport)
      print "transport authenticated: {}".format(self._transport._authenticated)


   def onHello(self, realm, details):
      print "onHello: {} {}".format(realm, details)
      if self._transport._authenticated is not None:
         return types.Accept(authid = self._transport._authenticated)
      else:
         return types.Challenge("mozilla-persona")
      return accept


   def onLeave(self, details):
      if details.reason == "wamp.close.logout":
         cookie = self._transport.factory._cookies[self._transport._cbtid]
         cookie['authenticated'] = None
         for proto in cookie['connections']:
            proto.sendClose()


   def onAuthenticate(self, signature, extra):
      print "onAuthenticate: {} {}".format(signature, extra)

      dres = Deferred()

      ## The client did it's Mozilla Persona authentication thing
      ## and now wants to verify the authentication and login.
      assertion = signature
      audience = 'http://127.0.0.1:8080/'

      ## To verify the authentication, we need to send a HTTP/POST
      ## to Mozilla Persona. When successful, Persona will send us
      ## back something like:

      # {
      #    "audience": "http://192.168.1.130:8080/",
      #    "expires": 1393681951257,
      #    "issuer": "gmail.login.persona.org",
      #    "email": "tobias.oberstein@gmail.com",
      #    "status": "okay"
      # }

      headers = {'Content-Type': 'application/x-www-form-urlencoded'}
      body = urllib.urlencode({'audience': audience, 'assertion': assertion})

      from twisted.web.client import getPage
      d = getPage(url = "https://verifier.login.persona.org/verify",
                  method = 'POST',
                  postdata = body,
                  headers = headers)

      log.msg("Authentication request sent.")

      def done(res):
         res = json.loads(res)
         try:
            if res['status'] == 'okay':
               ## Mozilla Persona successfully authenticated the user

               ## remember the user's email address. this marks the cookie as
               ## authenticated
               self._transport.factory._cookies[self._transport._cbtid]['authenticated'] = res['email']

               log.msg("Authenticated user {}".format(res['email']))
               dres.callback(types.Accept(authid = res['email']))
            else:
               log.msg("Authentication failed!")
               dres.callback(types.Deny())
         except Exception as e:
            print "ERRR", e

      def error(err):
         log.msg("Authentication request failed: {}".format(err.value))
         dres.callback(types.Deny())

      d.addCallbacks(done, error)

      return dres


if __name__ == '__main__':

   import sys, argparse

   from twisted.python import log
   from twisted.internet.endpoints import serverFromString


   ## parse command line arguments
   ##
   parser = argparse.ArgumentParser()

   parser.add_argument("-d", "--debug", action = "store_true",
                       help = "Enable debug output.")

   parser.add_argument("-c", "--component", type = str, default = None,
                       help = "Start WAMP-WebSocket server with this application component, e.g. 'timeservice.TimeServiceBackend', or None.")

   parser.add_argument("--websocket", type = str, default = "tcp:8080",
                       help = 'WebSocket server Twisted endpoint descriptor, e.g. "tcp:9000" or "unix:/tmp/mywebsocket".')

   parser.add_argument("--wsurl", type = str, default = "ws://localhost:8080",
                       help = 'WebSocket URL (must suit the endpoint), e.g. "ws://localhost:9000".')

   args = parser.parse_args()


   ## start Twisted logging to stdout
   ##
   if True or args.debug:
      log.startLogging(sys.stdout)


   ## we use an Autobahn utility to install the "best" available Twisted reactor
   ##
   from autobahn.twisted.choosereactor import install_reactor
   reactor = install_reactor()
   if args.debug:
      print("Running on reactor {}".format(reactor))


   ## create a WAMP router factory
   ##
   from autobahn.wamp.router import RouterFactory
   router_factory = RouterFactory()


   ## create a WAMP router session factory
   ##
   from autobahn.twisted.wamp import RouterSessionFactory
   session_factory = RouterSessionFactory(router_factory)
   session_factory.session = MyRouterSession


   ## start an embedded application component ..
   ##
   session_factory.add(TimeService())


   ## create a WAMP-over-WebSocket transport server factory
   ##
   from autobahn.twisted.websocket import WampWebSocketServerFactory
   transport_factory = WampWebSocketServerFactory(session_factory, args.wsurl, debug_wamp = args.debug)
   transport_factory.protocol = ServerProtocol
   transport_factory._cookies = {}

   transport_factory.setProtocolOptions(failByDrop = False)


   from twisted.web.server import Site
   from twisted.web.static import File
   from autobahn.twisted.resource import WebSocketResource

   ## we serve static files under "/" ..
   root = File(".")

   ## .. and our WebSocket server under "/ws"
   resource = WebSocketResource(transport_factory)
   root.putChild("ws", resource)

   ## run both under one Twisted Web Site
   site = Site(root)

   ## start the WebSocket server from an endpoint
   ##
   server = serverFromString(reactor, args.websocket)
   server.listen(site)


   ## now enter the Twisted reactor loop
   ##
   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


if __name__ == '__main__':

   import sys, argparse

   from twisted.python import log
   from twisted.internet.endpoints import clientFromString


   ## parse command line arguments
   ##
   parser = argparse.ArgumentParser()

   parser.add_argument("-d", "--debug", action = "store_true",
                       help = "Enable debug output.")

   parser.add_argument("-c", "--component", type = str,
                       help = "Start WAMP client with this application component, e.g. 'timeservice.TimeServiceFrontend'")

   parser.add_argument("-r", "--realm", type = str, default = "realm1",
                       help = "The WAMP realm to start the component in (if any).")

   parser.add_argument("--endpoint", type = str, default = "tcp:127.0.0.1:8080",
                       help = 'Twisted client endpoint descriptor, e.g. "tcp:127.0.0.1:8080" or "unix:/tmp/mywebsocket".')

   parser.add_argument("--transport", choices = ['websocket', 'rawsocket-json', 'rawsocket-msgpack'], default = "websocket",
                       help = 'WAMP transport type')

   parser.add_argument("--url", type = str, default = None,
                       help = 'The WebSocket URL to connect to, e.g. ws://127.0.0.1:8080/ws.')

   args = parser.parse_args()


   ## start Twisted logging to stdout
   ##
   if args.debug:
      log.startLogging(sys.stdout)


   ## we use an Autobahn utility to import the "best" available Twisted reactor
   ##
   from autobahn.twisted.choosereactor import install_reactor
   reactor = install_reactor()
   if args.debug:
      print("Running on reactor {}".format(reactor))


   ## create a WAMP application session factory
   ##
   from autobahn.twisted.wamp import ApplicationSessionFactory
   from autobahn.wamp import types
   session_factory = ApplicationSessionFactory(types.ComponentConfig(realm = args.realm))


   ## dynamically load the application component ..
   ##
   import importlib
   c = args.component.split('.')
   mod, klass = '.'.join(c[:-1]), c[-1]
   app = importlib.import_module(mod)

   ## .. and set the session class on the factory
   ##
   session_factory.session = getattr(app, klass)


   if args.transport == "websocket":

      ## create a WAMP-over-WebSocket transport client factory
      ##
      from autobahn.twisted.websocket import WampWebSocketClientFactory
      transport_factory = WampWebSocketClientFactory(session_factory, url = args.url, debug_wamp = args.debug)
      transport_factory.setProtocolOptions(failByDrop = False)

   elif args.transport in ['rawsocket-json', 'rawsocket-msgpack']:

      ## create a WAMP-over-RawSocket transport client factory
      ##
      if args.transport == 'rawsocket-msgpack':
         from autobahn.wamp.serializer import MsgPackSerializer
         serializer = MsgPackSerializer()
      elif args.transport == 'rawsocket-json':
         from autobahn.wamp.serializer import JsonSerializer
         serializer = JsonSerializer()
      else:
         raise Exception("should not arrive here")

      from autobahn.twisted.rawsocket import WampRawSocketClientFactory
      transport_factory = WampRawSocketClientFactory(session_factory, serializer, debug = args.debug)


   ## start the client from an endpoint
   ##
   client = clientFromString(reactor, args.endpoint)
   client.connect(transport_factory)


   ## now enter the Twisted reactor loop
   ##
   reactor.run()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.util import sleep
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that publishes an event every second.
   """

   @inlineCallbacks
   def onJoin(self, details):
      counter = 0
      while True:
         self.publish('com.myapp.topic1', counter)
         counter += 1
         yield sleep(1)

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that subscribes and receives events,
   and stop after having received 5 events.
   """

   @inlineCallbacks
   def onJoin(self, details):

      self.received = 0

      def on_event(i):
         print("Got event: {}".format(i))
         self.received += 1
         if self.received > 5:
            self.leave()

      yield self.subscribe(on_event, 'com.myapp.topic1')


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import random

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.wamp.types import SubscribeOptions
from autobahn.twisted.util import sleep
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that publishes events with no payload
   and with complex payloads every second.
   """

   @inlineCallbacks
   def onJoin(self, details):

      counter = 0
      while True:
         self.publish('com.myapp.heartbeat')

         obj = {'counter': counter, 'foo': [1, 2, 3]}
         self.publish('com.myapp.topic2', random.randint(0, 100), 23, c = "Hello", d = obj)

         counter += 1
         yield sleep(1)

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import random

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.wamp.types import SubscribeOptions
from autobahn.twisted.util import sleep
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that subscribes and receives events
   of no payload and of complex payload, and stops after 5 seconds.
   """

   @inlineCallbacks
   def onJoin(self, details):

      self.received = 0

      def on_heartbeat(details = None):
         print("Got heartbeat (publication ID {})".format(details.publication))

      yield self.subscribe(on_heartbeat, 'com.myapp.heartbeat', options = SubscribeOptions(details_arg = 'details'))


      def on_topic2(a, b, c = None, d = None):
         print("Got event: {} {} {} {}".format(a, b, c, d))

      yield self.subscribe(on_topic2, 'com.myapp.topic2')


      reactor.callLater(5, self.leave)


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.util import sleep
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that publishes an event every second.
   """

   @inlineCallbacks
   def onJoin(self, details):
      counter = 0
      while True:
         self.publish('com.myapp.topic1', counter)
         self.publish('com.myapp.topic2', "Hello world.")
         counter += 1
         yield sleep(1)

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn import wamp
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that subscribes and receives events,
   and stop after having received 5 events.
   """

   @inlineCallbacks
   def onJoin(self, details):

      ## subscribe all methods on this object decorated with "@wamp.topic"
      ## as PubSub event handlers
      ##
      results = yield self.subscribe(self)
      for success, res in results:
         if success:
            ## res is an Subscription instance
            print("Ok, subscribed handler with subscription ID {}".format(res.id))
         else:
            ## res is an Failure instance
            print("Failed to subscribe handler: {}".format(res.value))


   @wamp.topic('com.myapp.topic1')
   def onEvent1(self, i):
      print("Got event on topic1: {}".format(i))
      self.received += 1
      if self.received > 5:
         self.leave()


   @wamp.topic('com.myapp.topic2')
   def onEvent2(self, msg):
      print("Got event on topic2: {}".format(msg))


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.wamp.types import PublishOptions, EventDetails, SubscribeOptions
from autobahn.twisted.util import sleep
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that publishes an event every second.
   """

   @inlineCallbacks
   def onJoin(self, details):

      def on_event(i):
         print("Got event: {}".format(i))

      yield self.subscribe(on_event, 'com.myapp.topic1')


      counter = 0
      while True:
         publication = yield self.publish('com.myapp.topic1', counter,
               options = PublishOptions(acknowledge = True, discloseMe = True, excludeMe = False))
         print("Event published with publication ID {}".format(publication.id))
         counter += 1
         yield sleep(1)

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.wamp.types import PublishOptions, EventDetails, SubscribeOptions
from autobahn.twisted.util import sleep
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that subscribes and receives events,
   and stop after having received 5 events.
   """

   @inlineCallbacks
   def onJoin(self, details):

      self.received = 0

      def on_event(i, details = None):
         print("Got event, publication ID {}, publisher {}: {}".format(details.publication, details.publisher, i))
         self.received += 1
         if self.received > 5:
            self.leave()

      yield self.subscribe(on_event, 'com.myapp.topic1',
                              options = SubscribeOptions(details_arg = 'details'))


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.util import sleep
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that publishes an event every second.
   """

   @inlineCallbacks
   def onJoin(self, details):

      counter = 0
      while True:
         self.publish('com.myapp.topic1', counter)
         counter += 1
         yield sleep(1)

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.util import sleep
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component that subscribes and receives events.
   After receiving 5 events, it unsubscribes, sleeps and then
   resubscribes for another run. Then it stops.
   """

   @inlineCallbacks
   def test(self):

      self.received = 0

      @inlineCallbacks
      def on_event(i):
         print("Got event: {}".format(i))
         self.received += 1
         if self.received > 5:
            self.runs += 1
            if self.runs > 1:
               self.leave()
            else:
               yield self.subscription.unsubscribe()
               print("Unsubscribed .. continue in 2s ..")
               reactor.callLater(2, self.test)

      self.subscription = yield self.subscribe(on_event, 'com.myapp.topic1')
      print("Subscribed with subscription ID {}".format(self.subscription.id))


   @inlineCallbacks
   def onJoin(self, details):

      self.runs = 0
      yield self.test()


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component providing procedures with different kinds of arguments.
   """

   def onJoin(self, details):

      def ping():
         return

      def add2(a, b):
         return a + b

      def stars(nick = "somebody", stars = 0):
         return u"{} starred {}x".format(nick, stars)

      def orders(product, limit = 5):
         return [u"Product {}".format(i) for i in range(50)][:limit]

      def arglen(*args, **kwargs):
         return [len(args), len(kwargs)]

      self.register(ping, u'com.arguments.ping')
      self.register(add2, u'com.arguments.add2')
      self.register(stars, u'com.arguments.stars')
      self.register(orders, u'com.arguments.orders')
      self.register(arglen, u'com.arguments.arglen')

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component calling the different backend procedures.
   """

   @inlineCallbacks
   def onJoin(self, details):

      yield self.call(u'com.arguments.ping')
      print("Pinged!")

      res = yield self.call(u'com.arguments.add2', 2, 3)
      print("Add2: {}".format(res))

      starred = yield self.call(u'com.arguments.stars')
      print("Starred 1: {}".format(starred))

      starred = yield self.call(u'com.arguments.stars', nick = u'Homer')
      print("Starred 2: {}".format(starred))

      starred = yield self.call(u'com.arguments.stars', stars = 5)
      print("Starred 3: {}".format(starred))

      starred = yield self.call(u'com.arguments.stars', nick = u'Homer', stars = 5)
      print("Starred 4: {}".format(starred))

      orders = yield self.call(u'com.arguments.orders', u'coffee')
      print("Orders 1: {}".format(orders))

      orders = yield self.call(u'com.arguments.orders', u'coffee', limit = 10)
      print("Orders 2: {}".format(orders))

      arglengths = yield self.call(u'com.arguments.arglen')
      print("Arglen 1: {}".format(arglengths))

      arglengths = yield self.call(u'com.arguments.arglen', 1, 2, 3)
      print("Arglen 1: {}".format(arglengths))

      arglengths = yield self.call(u'com.arguments.arglen', a = 1, b = 2, c = 3)
      print("Arglen 2: {}".format(arglengths))

      arglengths = yield self.call(u'com.arguments.arglen', 1, 2, 3, a = 1, b = 2, c = 3)
      print("Arglen 3: {}".format(arglengths))

      self.leave()


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.wamp.types import CallResult
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   Application component that provides procedures which
   return complex results.
   """

   def onJoin(self, details):

      def add_complex(a, ai, b, bi):
         return CallResult(c = a + b, ci = ai + bi)

      self.register(add_complex, 'com.myapp.add_complex')

      def split_name(fullname):
         forename, surname = fullname.split()
         return CallResult(forename, surname)

      self.register(split_name, 'com.myapp.split_name')

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.wamp.types import CallResult
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   Application component that calls procedures which
   produce complex results and showing how to access those.
   """

   @inlineCallbacks
   def onJoin(self, details):

      res = yield self.call('com.myapp.add_complex', 2, 3, 4, 5)
      print("Result: {} + {}i".format(res.kwresults['c'], res.kwresults['ci']))

      res = yield self.call('com.myapp.split_name', 'Homer Simpson')
      print("Forname: {}, Surname: {}".format(res.results[0], res.results[1]))

      self.leave()


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime

from twisted.internet.defer import inlineCallbacks

from autobahn import wamp
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component registering RPC endpoints using decorators.
   """

   @inlineCallbacks
   def onJoin(self, details):
      ## register all methods on this object decorated with "@wamp.procedure"
      ## as a RPC endpoint
      ##
      results = yield self.register(self)
      for success, res in results:
         if success:
            ## res is an Registration instance
            print("Ok, registered procedure with registration ID {}".format(res.id))
         else:
            ## res is an Failure instance
            print("Failed to register procedure: {}".format(res.value))


   @wamp.procedure('com.mathservice.add2')
   def add2(self, x, y):
      return x + y


   @wamp.procedure('com.mathservice.mul2')
   def mul2(self, x, y):
      return x * y


   @wamp.procedure('com.mathservice.div2')
   def square(self, x, y):
      if y:
         return float(x) / float(y)
      else:
         return 0

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component calling the different backend procedures.
   """

   @inlineCallbacks
   def onJoin(self, details):
      procs = [u'com.mathservice.add2',
               u'com.mathservice.mul2',
               u'com.mathservice.div2']

      try:
         for proc in procs:
            res = yield self.call(proc, 2, 3)
            print("{}: {}".format(proc, res))
      except Exception as e:
         print("Something went wrong: {}".format(e))

      self.leave()


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import math

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn import wamp
from autobahn.wamp.exception import ApplicationError
from autobahn.twisted.wamp import ApplicationSession



@wamp.error("com.myapp.error1")
class AppError1(Exception):
   """
   An application specific exception that is decorated with a WAMP URI,
   and hence can be automapped by Autobahn.
   """



class Component(ApplicationSession):
   """
   Example WAMP application backend that raised exceptions.
   """

   def onJoin(self, details):

      ## raising standard exceptions
      ##
      def sqrt(x):
         if x == 0:
            raise Exception("don't ask folly questions;)")
         else:
            ## this also will raise, if x < 0
            return math.sqrt(x)

      self.register(sqrt, 'com.myapp.sqrt')


      ## raising WAMP application exceptions
      ##
      def checkname(name):
         if name in ['foo', 'bar']:
            raise ApplicationError("com.myapp.error.reserved")

         if name.lower() != name.upper():
            ## forward positional arguments in exceptions
            raise ApplicationError("com.myapp.error.mixed_case", name.lower(), name.upper())

         if len(name) < 3 or len(name) > 10:
            ## forward keyword arguments in exceptions
            raise ApplicationError("com.myapp.error.invalid_length", min = 3, max = 10)

      self.register(checkname, 'com.myapp.checkname')


      ## defining and automapping WAMP application exceptions
      ##
      self.define(AppError1)

      def compare(a, b):
         if a < b:
            raise AppError1(b - a)

      self.register(compare, 'com.myapp.compare')

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import math

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn import wamp
from autobahn.wamp.exception import ApplicationError
from autobahn.twisted.wamp import ApplicationSession



@wamp.error("com.myapp.error1")
class AppError1(Exception):
   """
   An application specific exception that is decorated with a WAMP URI,
   and hence can be automapped by Autobahn.
   """



class Component(ApplicationSession):
   """
   Example WAMP application frontend that catches exceptions.
   """

   @inlineCallbacks
   def onJoin(self, details):

      ## catching standard exceptions
      ##
      for x in [2, 0, -2]:
         try:
            res = yield self.call('com.myapp.sqrt', x)
         except Exception as e:
            print("Error: {} {}".format(e, e.args))
         else:
            print("Result: {}".format(res))


      ## catching WAMP application exceptions
      ##
      for name in ['foo', 'a', '*'*11, 'Hello']:
         try:
            res = yield self.call('com.myapp.checkname', name)
         except ApplicationError as e:
            print("Error: {} {} {} {}".format(e, e.error, e.args, e.kwargs))
         else:
            print("Result: {}".format(res))


      ## defining and automapping WAMP application exceptions
      ##
      self.define(AppError1)

      try:
         yield self.call('com.myapp.compare', 3, 17)
      except AppError1 as e:
         print("Compare Error: {}".format(e))


      self.leave()


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.wamp.types import CallOptions, RegisterOptions, PublishOptions
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component providing procedures with
   different kinds of arguments.
   """

   def onJoin(self, details):

      def square(val, details = None):
         print("square called from: {}".format(details.caller))

         if val < 0:
            self.publish('com.myapp.square_on_nonpositive', val)
         elif val == 0:
            if details.caller:
               options = PublishOptions(exclude = [details.caller])
            else:
               options = None
            self.publish('com.myapp.square_on_nonpositive', val, options = options)
         return val * val

      self.register(square, 'com.myapp.square', RegisterOptions(details_arg = 'details'))

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.wamp.types import CallOptions, RegisterOptions, PublishOptions
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component calling the different backend procedures.
   """

   @inlineCallbacks
   def onJoin(self, details):

      def on_event(val):
         print("Someone requested to square non-positive: {}".format(val))

      yield self.subscribe(on_event, 'com.myapp.square_on_nonpositive')

      for val in [2, 0, -2]:
         res = yield self.call('com.myapp.square', val, options = CallOptions(discloseMe = True))
         print("Squared {} = {}".format(val, res))

      self.leave()


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks, returnValue

from autobahn.wamp.types import CallOptions, RegisterOptions
from autobahn.twisted.util import sleep
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   Application component that produces progressive results.
   """


   def onJoin(self, details):

      @inlineCallbacks
      def longop(n, details = None):
         if details.progress:
            for i in range(n):
               details.progress(i)
               yield sleep(1)
         else:
            yield sleep(1 * n)
         returnValue(n)

      self.register(longop, 'com.myapp.longop', RegisterOptions(details_arg = 'details'))

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks, returnValue

from autobahn.wamp.types import CallOptions, RegisterOptions
from autobahn.twisted.util import sleep
from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   Application component that consumes progressive results.
   """

   @inlineCallbacks
   def onJoin(self, details):

      def on_progress(i):
         print("Progress: {}".format(i))

      res = yield self.call('com.myapp.longop', 3, options = CallOptions(onProgress = on_progress))

      print("Final: {}".format(res))

      self.leave()


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet.defer import Deferred, \
                                   inlineCallbacks, \
                                   returnValue

from autobahn.twisted.wamp import ApplicationSession
from autobahn.twisted.util import sleep



class Component(ApplicationSession):
   """
   A math service application component.
   """

   def onJoin(self, details):

      def square(x):
         return x * x

      self.register(square, 'com.math.square')


      @inlineCallbacks
      def slowsquare(x, delay = 1):
         yield sleep(delay)
         returnValue(x * x)

      self.register(slowsquare, 'com.math.slowsquare')

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import time

from twisted.internet import reactor
from twisted.internet.defer import DeferredList

from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component using the time service.
   """

   def onJoin(self, details):

      def got(res, started, msg):
         duration = 1000. * (time.clock() - started)
         print("{}: {} in {}".format(msg, res, duration))

      t1 = time.clock()
      d1 = self.call('com.math.slowsquare', 3)
      d1.addCallback(got, t1, "Slow Square")

      t2 = time.clock()
      d2 = self.call('com.math.square', 3)
      d2.addCallback(got, t2, "Quick Square")

      def done(_):
         print("All finished.")
         self.leave()

      DeferredList ([d1, d2]).addBoth(done)


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime

from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   A simple time service application component.
   """

   def onJoin(self, details):

      def utcnow():
         now = datetime.datetime.utcnow()
         return now.strftime("%Y-%m-%dT%H:%M:%SZ")

      self.register(utcnow, 'com.timeservice.now')

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component using the time service.
   """

   @inlineCallbacks
   def onJoin(self, details):
      try:
         now = yield self.call('com.timeservice.now')
      except Exception as e:
         print("Error: {}".format(e))
      else:
         print("Current time from time service: {}".format(now))

      self.leave()


   def onDisconnect(self):
      reactor.stop()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


if __name__ == '__main__':

   import sys, argparse

   from twisted.python import log
   from twisted.internet.endpoints import serverFromString


   ## parse command line arguments
   ##
   parser = argparse.ArgumentParser()

   parser.add_argument("-d", "--debug", action = "store_true",
                       help = "Enable debug output.")

   parser.add_argument("-c", "--component", type = str, default = None,
                       help = "Start WAMP server with this application component, e.g. 'timeservice.TimeServiceBackend', or None.")

   parser.add_argument("-r", "--realm", type = str, default = "realm1",
                       help = "The WAMP realm to start the component in (if any).")

   parser.add_argument("--endpoint", type = str, default = "tcp:8080",
                       help = 'Twisted server endpoint descriptor, e.g. "tcp:8080" or "unix:/tmp/mywebsocket".')

   parser.add_argument("--transport", choices = ['websocket', 'rawsocket-json', 'rawsocket-msgpack'], default = "websocket",
                       help = 'WAMP transport type')

   args = parser.parse_args()


   ## start Twisted logging to stdout
   ##
   if args.debug:
      log.startLogging(sys.stdout)


   ## we use an Autobahn utility to install the "best" available Twisted reactor
   ##
   from autobahn.twisted.choosereactor import install_reactor
   reactor = install_reactor()
   if args.debug:
      print("Running on reactor {}".format(reactor))


   ## create a WAMP router factory
   ##
   from autobahn.wamp.router import RouterFactory
   router_factory = RouterFactory()


   ## create a WAMP router session factory
   ##
   from autobahn.twisted.wamp import RouterSessionFactory
   session_factory = RouterSessionFactory(router_factory)


   ## if asked to start an embedded application component ..
   ##
   if args.component:
      ## dynamically load the application component ..
      ##
      import importlib
      c = args.component.split('.')
      mod, klass = '.'.join(c[:-1]), c[-1]
      app = importlib.import_module(mod)
      SessionKlass = getattr(app, klass)

      ## .. and create and add an WAMP application session to
      ## run next to the router
      ##
      from autobahn.wamp import types
      session_factory.add(SessionKlass(types.ComponentConfig(realm = args.realm)))


   if args.transport == "websocket":

      ## create a WAMP-over-WebSocket transport server factory
      ##
      from autobahn.twisted.websocket import WampWebSocketServerFactory
      transport_factory = WampWebSocketServerFactory(session_factory, debug_wamp = args.debug)
      transport_factory.setProtocolOptions(failByDrop = False)

   elif args.transport in ['rawsocket-json', 'rawsocket-msgpack']:

      ## create a WAMP-over-RawSocket transport server factory
      ##
      if args.transport == 'rawsocket-msgpack':
         from autobahn.wamp.serializer import MsgPackSerializer
         serializer = MsgPackSerializer()
      elif args.transport == 'rawsocket-json':
         from autobahn.wamp.serializer import JsonSerializer
         serializer = JsonSerializer()
      else:
         raise Exception("should not arrive here")

      from autobahn.twisted.rawsocket import WampRawSocketServerFactory
      transport_factory = WampRawSocketServerFactory(session_factory, serializer, debug = args.debug)

   else:
      raise Exception("should not arrive here")


   ## start the server from an endpoint
   ##
   server = serverFromString(reactor, args.endpoint)
   server.listen(transport_factory)


   ## now enter the Twisted reactor loop
   ##
   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.util import sleep
from autobahn.twisted.wamp import ApplicationSession



class MyAppComponent(ApplicationSession):

   def onJoin(self, details):
      if not self.factory._myAppSession:
         self.factory._myAppSession = self

   def onLeave(self, details):
      if self.factory._myAppSession == self:
         self.factory._myAppSession = None




if __name__ == '__main__':

   import sys

   from twisted.python import log
   from twisted.internet.endpoints import clientFromString
   log.startLogging(sys.stdout)


   ## we use an Autobahn utility to import the "best" available Twisted reactor
   ##
   from autobahn.twisted.choosereactor import install_reactor
   reactor = install_reactor()
   print("Running on reactor {}".format(reactor))


   ## create a WAMP application session factory
   ##
   from autobahn.twisted.wamp import ApplicationSessionFactory
   session_factory = ApplicationSessionFactory()


   ## .. and set the session class on the factory
   ##
   session_factory.session = MyAppComponent


   ## since we are running this component as a client, there
   ## will be only 1 app session instance anyway. We'll store a
   ## reference on the session factory, so we can access it
   ## from "outside" the session instance later (see below)
   ##
   session_factory._myAppSession = None


   ## create a WAMP-over-WebSocket transport client factory
   ##
   from autobahn.twisted.websocket import WampWebSocketClientFactory
   transport_factory = WampWebSocketClientFactory(session_factory, "ws://127.0.0.1:8080/ws")


   ## start a WebSocket client from an endpoint
   ##
   client = clientFromString(reactor, "tcp:127.0.0.1:8080")
   client.connect(transport_factory)


   ## publish an event every second from the (single) application session
   ## that get created by the session factory
   ##
   @inlineCallbacks
   def pub():
      counter = 0
      while True:
         ## here we can access the app session that was created ..
         ##
         if session_factory._myAppSession:
            session_factory._myAppSession.publish('com.myapp.topic123', counter)
            print("published event", counter)
         else:
            print("no session")
         counter += 1
         yield sleep(1)

   pub()


   ## now enter the Twisted reactor loop
   ##
   reactor.run()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   A simple time service application component.
   """

   def onJoin(self, details):

      def utcnow():
         now = datetime.datetime.utcnow()
         return now.strftime("%Y-%m-%dT%H:%M:%SZ")

      self.register(utcnow, 'com.timeservice.now')

########NEW FILE########
__FILENAME__ = frontend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.wamp import ApplicationSession



class Component(ApplicationSession):
   """
   An application component using the time service
   during 3 subsequent WAMP sessions, while the
   underlying transport continues to exist.
   """
   def __init__(self, config):
      ApplicationSession.__init__(self, config)
      self.count = 0


   @inlineCallbacks
   def onJoin(self, details):
      print("Realm joined (WAMP session started).")

      try:
         now = yield self.call('com.timeservice.now')
      except Exception as e:
         print("Error: {}".format(e))
      else:
         print("Current time from time service: {}".format(now))

      self.leave()


   def onLeave(self, details):
      print("Realm left (WAMP session ended).")
      self.count += 1
      if self.count < 3:
         self.join("realm1")
      else:
         self.disconnect()


   def onDisconnect(self):
      print("Transport disconnected.")
      reactor.stop()

########NEW FILE########
__FILENAME__ = test
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys
import io
import six
import datetime

from twisted.python import log
from twisted.internet.defer import inlineCallbacks, Deferred, DeferredList
from twisted.internet.endpoints import serverFromString

from autobahn.wamp import router
from autobahn.twisted.util import sleep
from autobahn.twisted import wamp, websocket


class CaseComponent(wamp.ApplicationSession):
   """
   Application code goes here. This is an example component that calls
   a remote procedure on a WAMP peer, subscribes to a topic to receive
   events, and then stops the world after some events.
   """

   def __init__(self, config, done):
      wamp.ApplicationSession.__init__(self, config)
      self._done = done
      self.stop = False
      self._logline = 1
      self.finished = False

   def log(self, *args):
      if len(args) > 1:
         sargs = ", ".join(str(s) for s in args)
      elif len(args) == 1:
         sargs = args[0]
      else:
         sargs = "-"

      msg = u'= : {:>3} : {:<20} : {}'.format(self._logline, self.__class__.__name__, sargs)
      self._logline += 1
      print(msg)
      if self.config.log and not self.config.log.closed:
         self.config.log.write(msg + "\n")
         self.config.log.flush()
      else:
         print("log already closed")

   def finish(self):
      if not self.finished:
         self._done.callback(None)
         #self.disconnect()
         self.finished = True
      else:
         print("already finished")



class Case1_Backend(CaseComponent):

   @inlineCallbacks
   def onJoin(self, details):

      self.log("joined")

      def add2(x, y):
         self.log("add2 invoked: {}, {}".format(x, y))
         return x + y

      yield self.register(add2, 'com.mathservice.add2')
      self.log("add2 registered")

      self.finish()



class Case1_Frontend(CaseComponent):

   @inlineCallbacks
   def onJoin(self, details):

      self.log("joined")

      try:
         res = yield self.call('com.mathservice.add2', 2, 3)
      except Exception as e:
         self.log("call error: {}".format(e))
      else:
         self.log("call result: {}".format(res))

      self.finish()



class Case2_Backend(CaseComponent):

   @inlineCallbacks
   def onJoin(self, details):

      self.log("joined")

      def ping():
         self.log("ping() is invoked")
         return

      def add2(a, b):
         self.log("add2() is invoked", a, b)
         return a + b

      def stars(nick = "somebody", stars = 0):
         self.log("stars() is invoked", nick, stars)
         return u"{} starred {}x".format(nick, stars)

      def orders(product, limit = 5):
         self.log("orders() is invoked", product, limit)
         return [u"Product {}".format(i) for i in range(50)][:limit]

      def arglen(*args, **kwargs):
         self.log("arglen() is invoked", args, kwargs)
         return [len(args), len(kwargs)]

      yield self.register(ping, u'com.arguments.ping')
      yield self.register(add2, u'com.arguments.add2')
      yield self.register(stars, u'com.arguments.stars')
      yield self.register(orders, u'com.arguments.orders')
      yield self.register(arglen, u'com.arguments.arglen')

      self.log("procedures registered")

      self.finish()


from autobahn.twisted.util import sleep

class Case2_Frontend(CaseComponent):

   @inlineCallbacks
   def onJoin(self, details):

      self.log("joined")

      #yield sleep(3)

      yield self.call(u'com.arguments.ping')
      self.log("Pinged!")

      res = yield self.call(u'com.arguments.add2', 2, 3)
      self.log("Add2: {}".format(res))

      starred = yield self.call(u'com.arguments.stars')
      self.log("Starred 1: {}".format(starred))

      starred = yield self.call(u'com.arguments.stars', nick = u'Homer')
      self.log("Starred 2: {}".format(starred))

      starred = yield self.call(u'com.arguments.stars', stars = 5)
      self.log("Starred 3: {}".format(starred))

      starred = yield self.call(u'com.arguments.stars', nick = u'Homer', stars = 5)
      self.log("Starred 4: {}".format(starred))

      orders = yield self.call(u'com.arguments.orders', u'coffee')
      self.log("Orders 1: {}".format(orders))

      orders = yield self.call(u'com.arguments.orders', u'coffee', limit = 10)
      self.log("Orders 2: {}".format(orders))

      arglengths = yield self.call(u'com.arguments.arglen')
      self.log("Arglen 1: {}".format(arglengths))

      arglengths = yield self.call(u'com.arguments.arglen', 1, 2, 3)
      self.log("Arglen 1: {}".format(arglengths))

      arglengths = yield self.call(u'com.arguments.arglen', a = 1, b = 2, c = 3)
      self.log("Arglen 2: {}".format(arglengths))

      arglengths = yield self.call(u'com.arguments.arglen', 1, 2, 3, a = 1, b = 2, c = 3)
      self.log("Arglen 3: {}".format(arglengths))

      #self.leave()

      self.finish()


## test different deployment topologies
##

if __name__ == '__main__':

   import sys, argparse

   from twisted.python import log
   from twisted.internet.endpoints import serverFromString
   from twisted.internet.endpoints import clientFromString


   ## parse command line arguments
   ##
   parser = argparse.ArgumentParser()

   parser.add_argument("-d", "--debug", action = "store_true",
                       help = "Enable debug output.")

   parser.add_argument("-c", "--component", type = str, default = None,
                       help = "Start WAMP server with this application component, e.g. 'timeservice.TimeServiceBackend', or None.")

   parser.add_argument("-r", "--realm", type = str, default = "realm1",
                       help = "The WAMP realm to start the component in (if any).")

   parser.add_argument("-u", "--url", type = str, default = "ws://127.0.0.1:8080",
                       help = "WebSocket URL.")

   parser.add_argument("--server", type = str, default = "tcp:8080",
                       help = 'Twisted server endpoint descriptor, e.g. "tcp:8080" or "unix:/tmp/mywebsocket".')

   parser.add_argument("--client", type = str, default = "tcp:127.0.0.1:8080",
                       help = 'Twisted client endpoint descriptor, e.g. "tcp:127.0.0.1:8080" or "unix:/tmp/mywebsocket".')

   parser.add_argument("--transport", choices = ['websocket', 'rawsocket-json', 'rawsocket-msgpack'], default = "websocket",
                       help = 'WAMP transport type')

   args = parser.parse_args()


   ## start Twisted logging to stdout
   ##
   if args.debug:
      log.startLogging(sys.stdout)


   ## we use an Autobahn utility to install the "best" available Twisted reactor
   ##
   from autobahn.twisted.choosereactor import install_reactor
   reactor = install_reactor()
   if args.debug:
      print("Running on reactor {}".format(reactor))


   ## create a WAMP router factory
   ##
   from autobahn.wamp.router import RouterFactory
   router_factory = RouterFactory()


   ## create a WAMP router session factory
   ##
   from autobahn.twisted.wamp import RouterSessionFactory
   session_factory = RouterSessionFactory(router_factory)



   ## .. and create and add an WAMP application session to
   ## run next to the router
   ##
   from autobahn.wamp import types

   config = types.ComponentConfig(realm = args.realm,
      extra = {
         'caselog': 'case1.log'
      }
   )

   if False:
      embedded_components = [Case1_Backend]
      client_components = [Case1_Frontend]
   else:
      embedded_components = []
      #client_components = [Case2_Backend]
      #client_components = [Case1_Backend, Case1_Frontend]
      client_components = [Case2_Backend, Case2_Frontend]

   log = io.open(config.extra['caselog'], 'w')
   config.log = log
   config.components = []

   config.all_done = []

   for C in embedded_components:
      one_done = Deferred()
      config.all_done.append(one_done)
      c = C(config, one_done)
      config.components.append(c)
      session_factory.add(c)


   if args.transport == "websocket":

      ## create a WAMP-over-WebSocket transport server factory
      ##
      from autobahn.twisted.websocket import WampWebSocketServerFactory
      transport_factory = WampWebSocketServerFactory(session_factory, debug_wamp = args.debug)
      transport_factory.setProtocolOptions(failByDrop = False)

   elif args.transport in ['rawsocket-json', 'rawsocket-msgpack']:

      ## create a WAMP-over-RawSocket transport server factory
      ##
      if args.transport == 'rawsocket-msgpack':
         from autobahn.wamp.serializer import MsgPackSerializer
         serializer = MsgPackSerializer()
      elif args.transport == 'rawsocket-json':
         from autobahn.wamp.serializer import JsonSerializer
         serializer = JsonSerializer()
      else:
         raise Exception("should not arrive here")

      from autobahn.twisted.rawsocket import WampRawSocketServerFactory
      transport_factory = WampRawSocketServerFactory(session_factory, serializer, debug = args.debug)

   else:
      raise Exception("should not arrive here")


   from autobahn.twisted.websocket import WampWebSocketClientFactory, WampWebSocketClientProtocol

   ## start the server from an endpoint
   ##
   server = serverFromString(reactor, args.server)
   server.listen(transport_factory)

   clients = []
   clients_d = []
   for C in client_components:
      ## create a WAMP application session factory
      ##
      from autobahn.twisted.wamp import ApplicationSessionFactory
      session_factory = ApplicationSessionFactory(config)

      one_done = Deferred()
      config.all_done.append(one_done)

      def make_make(Klass, done):
         def make(config):
            c = Klass(config, done)
            config.components.append(c)
            return c
         return make

      ## .. and set the session class on the factory
      ##
      session_factory.session = make_make(C, one_done)

      if args.transport == "websocket":

         from autobahn.wamp.serializer import JsonSerializer

         serializers = [JsonSerializer()]

         ## create a WAMP-over-WebSocket transport client factory
         ##
         transport_factory = WampWebSocketClientFactory(session_factory, serializers = serializers, url = args.url, debug_wamp = args.debug)


         if False:
            def maker(Klass):
               class TestClientProtocol(WampWebSocketClientProtocol):
                  def onOpen(self):
                     self.txcnt = 0
                     self.rxcnt = 0
                     WampWebSocketClientProtocol.onOpen(self)

                  def sendMessage(self, bytes, isBinary):
                     self.txcnt += 1
                     print("> : {:>3} : {:<20} : {}".format(self.txcnt, Klass.__name__, bytes))
                     WampWebSocketClientProtocol.sendMessage(self, bytes, isBinary)

                  def onMessage(self, bytes, isBinary):
                     self.rxcnt += 1
                     print("< : {:>3} : {:<20} : {}".format(self.rxcnt, Klass.__name__, bytes))
                     WampWebSocketClientProtocol.onMessage(self, bytes, isBinary)
               return TestClientProtocol

            transport_factory.protocol = maker(C)
         else:
            transport_factory.protocol = WampWebSocketClientProtocol

         transport_factory.setProtocolOptions(failByDrop = False)

      elif args.transport in ['rawsocket-json', 'rawsocket-msgpack']:

         ## create a WAMP-over-RawSocket transport client factory
         ##
         if args.transport == 'rawsocket-msgpack':
            from autobahn.wamp.serializer import MsgPackSerializer
            serializer = MsgPackSerializer()
         elif args.transport == 'rawsocket-json':
            from autobahn.wamp.serializer import JsonSerializer
            serializer = JsonSerializer()
         else:
            raise Exception("should not arrive here")

         from autobahn.twisted.rawsocket import WampRawSocketClientFactory
         transport_factory = WampRawSocketClientFactory(session_factory, serializer, debug = args.debug)


      ## start the client from an endpoint
      ##
      cl = clientFromString(reactor, args.client)
      clients_d.append(cl.connect(transport_factory))

      clients.append(cl)


   d = DeferredList(config.all_done)
   #d = config.components[1]._done

   def done(res):
      log.flush()
      log.close()
      for c in config.components:
         c.leave()
      from twisted.internet import reactor
      reactor.callLater(1, reactor.stop)

   d.addCallback(done)

   ## now enter the Twisted reactor loop
   ##
   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks
from twisted.internet.endpoints import clientFromString

from autobahn.twisted import wamp, websocket



class MyFrontendComponent(wamp.ApplicationSession):
   """
   Application code goes here. This is an example component that calls
   a remote procedure on a WAMP peer, subscribes to a topic to receive
   events, and then stops the world after some events.
   """

   @inlineCallbacks
   def onJoin(self, details):

      ## call a remote procedure
      ##
      try:
         now = yield self.call(u'com.timeservice.now')
      except Exception as e:
         print("Error: {}".format(e))
      else:
         print("Current time from time service: {}".format(now))

      ## subscribe to a topic
      ##
      self.received = 0

      def on_event(i):
         print("Got event: {}".format(i))
         self.received += 1
         if self.received > 5:
            self.leave()

      sub = yield self.subscribe(on_event, u'com.myapp.topic1')
      print("Subscribed with subscription ID {}".format(sub.id))


   def onDisconnect(self):
      reactor.stop()



if __name__ == '__main__':

   ## 0) start logging to console
   log.startLogging(sys.stdout)

   ## 1) create a WAMP application session factory
   session_factory = wamp.ApplicationSessionFactory()
   session_factory.session = MyFrontendComponent

   ## 2) create a WAMP-over-WebSocket transport client factory
   transport_factory = websocket.WampWebSocketClientFactory(session_factory, \
                                                            debug = False, \
                                                            debug_wamp = False)

   ## 3) start the client from a Twisted endpoint
   client = clientFromString(reactor, "tcp:127.0.0.1:8080")
   client.connect(transport_factory)

   ## 4) now enter the Twisted reactor loop
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys
import six
import datetime

from twisted.python import log
from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks
from twisted.internet.endpoints import serverFromString

from autobahn.wamp import router
from autobahn.twisted.util import sleep
from autobahn.twisted import wamp, websocket



class MyBackendComponent(wamp.ApplicationSession):
   """
   Application code goes here. This is an example component that provides
   a simple procedure which can be called remotely from any WAMP peer.
   It also publishes an event every second to some topic.
   """

   @inlineCallbacks
   def onJoin(self, details):

      ## register a procedure for remote calling
      ##
      def utcnow():
         print("Someone is calling me;)")
         now = datetime.datetime.utcnow()
         return six.u(now.strftime("%Y-%m-%dT%H:%M:%SZ"))

      reg = yield self.register(utcnow, u'com.timeservice.now')
      print("Registered procedure with ID {}".format(reg.id))

      ## publish events to a topic
      ##
      counter = 0
      while True:
         self.publish(u'com.myapp.topic1', counter)
         print("Published event.")
         counter += 1
         yield sleep(1)



if __name__ == '__main__':

   ## 0) start logging to console
   log.startLogging(sys.stdout)

   ## 1) create a WAMP router factory
   router_factory = router.RouterFactory()

   ## 2) create a WAMP router session factory
   session_factory = wamp.RouterSessionFactory(router_factory)

   ## 3) Optionally, add embedded WAMP application sessions to the router
   session_factory.add(MyBackendComponent())

   ## 4) create a WAMP-over-WebSocket transport server factory
   transport_factory = websocket.WampWebSocketServerFactory(session_factory, \
                                                            debug = False, \
                                                            debug_wamp = False)

   ## 5) start the server from a Twisted endpoint
   server = serverFromString(reactor, "tcp:8080")
   server.listen(transport_factory)

   ## 6) now enter the Twisted reactor loop
   reactor.run()

########NEW FILE########
__FILENAME__ = backend
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import os
import datetime
import sqlite3

from twisted.python import log
from twisted.enterprise import adbapi
from twisted.internet.defer import inlineCallbacks

from autobahn import wamp
from autobahn.twisted.wamp import ApplicationSession
from autobahn.wamp.exception import ApplicationError
from autobahn.wamp.types import PublishOptions


## WAMP application component with our app code.
##
class VoteGameBackend(ApplicationSession):

   def __init__(self, config):
      ApplicationSession.__init__(self)
      self.config = config
      self.init_db()


   def init_db(self):
      if not os.path.isfile(self.config.extra['dbfile']):
         log.msg("Initializing database ..")

         db = sqlite3.connect(self.config.extra['dbfile'])
         cur = db.cursor()

         cur.execute("""
                     CREATE TABLE votes (
                        item              TEXT     NOT NULL,
                        count             NUMBER   NOT NULL,
                        PRIMARY KEY (item))
                     """)

         for item in self.config.extra['items']:
            cur.execute("INSERT INTO votes (item, count) VALUES (?, ?)", [item, 0])
         db.commit()

         db.close()
         log.msg("Database initialized.")

      else:
         log.msg("Database already exists.")

      self.db = adbapi.ConnectionPool('sqlite3', self.config.extra['dbfile'], check_same_thread = False)
      log.msg("Database opened.")


   @wamp.procedure("com.votegame.get_votes")
   def get_votes(self):
      def run(txn):
         txn.execute("SELECT item, count FROM votes")
         res = {}
         for row in txn.fetchall():
            res[row[0]] = row[1]
         return res
      return self.db.runInteraction(run)


   @wamp.procedure("com.votegame.vote")
   def vote(self, item):
      if not item in self.config.extra['items']:
         raise ApplicationError("com.votegame.error.no_such_item", "no item '{}' to vote on".format(item))

      def run(txn):
         ## FIXME: make the following into 1 (atomic) SQL statement
         ## => does SQLite feature "UPDATE .. RETURNING"?
         txn.execute("UPDATE votes SET count = count + 1 WHERE item = ?", [item])
         txn.execute("SELECT count FROM votes WHERE item = ?", [item])
         count = int(txn.fetchone()[0])

         self.publish("com.votegame.onvote", item, count,
            options = PublishOptions(excludeMe = False))

         return count

      return self.db.runInteraction(run)



   @inlineCallbacks
   def onJoin(self, details):

      def onvote(item, count):
         print("New vote on '{}': {}".format(item, count))

      yield self.subscribe(onvote, 'com.votegame.onvote')

      try:
         regs = yield self.register(self)
         print("Ok, registered {} procedures.".format(len(regs)))
      except Exception as e:
         print("Failed to register procedures: {}".format(e))

      print("VoteGame Backend ready!")



   def onDisconnect(self):
      reactor.stop()



def make(config):
   ##
   ## This component factory creates instances of the
   ## application component to run.
   ##
   ## The function will get called either during development
   ## using the ApplicationRunner below, or as  a plugin running
   ## hosted in a WAMPlet container such as a Crossbar.io worker.
   ##
   if config:
      return VoteGameBackend(config)
   else:
      ## if no config given, return a description of this WAMPlet ..
      return {'label': 'VoteGame Service WAMPlet',
              'description': 'This is the backend WAMP application component of VoteGame.'}



if __name__ == '__main__':
   from autobahn.twisted.wamp import ApplicationRunner

   extra = {
      "dbfile": "votegame.db",
      "items": ["banana", "lemon", "grapefruit"]
   }

   ## test drive the component during development ..
   runner = ApplicationRunner(
      url = "ws://127.0.0.1:8080/ws",
      realm = "realm1",
      extra = extra,
      debug = False,       ## low-level WebSocket debugging
      debug_wamp = False,  ## WAMP protocol-level debugging
      debug_app = True)    ## app-level debugging

   runner.run(make)

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.python import log
from twisted.internet import protocol
from twisted.words.protocols import irc



class IRCClientProtocol(irc.IRCClient):
    
   def connectionMade(self):
      irc.IRCClient.connectionMade(self)
      print "connected"

   def connectionLost(self, reason):
      irc.IRCClient.connectionLost(self, reason)
      print "lost", reason

   def signedOn(self):
      print "signedon"
      for channel in self.channels:
         print "joining", channel
         self.join(channel)

   def joined(self, channel):
      print "joined", channel

   def privmsg(self, user, channel, msg):
      # privmsg oberstet!~vanaland@89.204.139.245 #autobahn bot23: test
      print "privmsg", user, channel, msg
      self.factory.session.publish('com.myapp.on_privmsg', user, channel, msg)

   def action(self, user, channel, msg):
      print "action", user, channel, msg



class IRCClientFactory(protocol.ClientFactory):

   def __init__(self, session, nickname, channels):
      self.session = session
      self.proto = None
      self.nickname = str(nickname)
      self.channels = [str(c) for c in channels]

   def buildProtocol(self, addr):
      assert(not self.proto)
      self.proto = IRCClientProtocol()
      self.proto.factory = self
      self.proto.nickname = self.nickname
      self.proto.channels = self.channels
      return self.proto

   def clientConnectionLost(self, connector, reason):
      #connector.connect()
      self.proto = None

   def clientConnectionFailed(self, connector, reason):
      #from twisted.internet import reactor
      #reactor.stop()
      self.proto = None

########NEW FILE########
__FILENAME__ = service
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

from twisted.internet.defer import inlineCallbacks
from twisted.internet.endpoints import clientFromString
from twisted.words.protocols import irc

from autobahn import wamp
from autobahn.twisted.wamp import ApplicationSession
from autobahn.wamp.exception import ApplicationError

from wampirc.client import IRCClientFactory



class Bot:
   """
   Tracks currently running bot instances.
   """
   def __init__(self, id, factory, client):
      self.id = id
      self.factory = factory
      self.client = client



class IRCComponent(ApplicationSession):
   """
   IRC bot services component.
   """

   def __init__(self, config):
      ApplicationSession.__init__(self)
      self.config = config
      self._bots = {}
      self._bot_no = 0


   @wamp.procedure('com.myapp.start_bot')
   def start_bot(self, nick, channels):
      self._bot_no += 1
      id = self._bot_no
      factory = IRCClientFactory(self, nick, channels)

      from twisted.internet import reactor
      client = clientFromString(reactor, self.config.extra['server'])
      d = client.connect(factory)

      def onconnect(res):
         self._bots[id] = Bot(id, factory, client)
         return id
      d.addCallback(onconnect)

      return d


   @wamp.procedure('com.myapp.stop_bot')
   def stop_bot(self, id):
      if id in self._bots:
         f = self._bots[id].factory
         if f.proto:
            f.proto.transport.loseConnection()
         f.stopFactory()
         del self._bots[id]
      else:
         raise ApplicationError('com.myapp.error.no_such_bot')


   @inlineCallbacks
   def onJoin(self, details):
      try:
         regs = yield self.register(self)
         print("Ok, registered {} procedures.".format(len(regs)))
      except Exception as e:
         print("Failed to register procedures: {}".format(e))

      print("IRC Bot Backend ready!")


   def onDisconnect(self):
      reactor.stop()



def make(config):
   if config:
      return IRCComponent(config)
   else:
      ## if no config given, return a description of this WAMPlet ..
      return {'label': 'An IRC bot service component',
              'description': 'This component provides IRC bot services via WAMP.'}



if __name__ == '__main__':
   from autobahn.twisted.wamp import ApplicationRunner

   extra = {
      "server": "tcp:irc.freenode.net:6667"
   }

   ## test drive the component during development ..
   runner = ApplicationRunner(
      url = "ws://localhost:8080/ws",
      realm = "realm1",
      extra = extra,
      debug = False,       ## low-level WebSocket debugging
      debug_wamp = False,  ## WAMP protocol-level debugging
      debug_app = True)    ## app-level debugging

   runner.run(make)

########NEW FILE########
__FILENAME__ = calculator
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn import wamp


class Calculator(object):
   """
   An application component registering RPC endpoints using decorators.
   """

   @wamp.procedure('com.mathservice.add2')
   def add2(self, x, y):
      return x + y


   @wamp.procedure('com.mathservice.mul2')
   def mul2(self, x, y):
      return x * y


   @wamp.procedure('com.mathservice.div2')
   def square(self, x, y):
      if y:
         return float(x) / float(y)
      else:
         return 0

########NEW FILE########
__FILENAME__ = component1
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import datetime

from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.wamp import ApplicationSession

from calculator import Calculator



## WAMP application component with our app code.
##
class Component1(ApplicationSession):

   @inlineCallbacks
   def onJoin(self, details):

      ## register a function that can be called remotely
      ##
      def utcnow():
         now = datetime.datetime.utcnow()
         return now.strftime("%Y-%m-%dT%H:%M:%SZ")

      reg = yield self.register(utcnow, 'com.timeservice.now')
      print("Procedure registered with ID {}".format(reg.id))

      ## create an application object that exposes methods for remoting
      ##
      self.calculator = Calculator()

      ## register all methods on the "calculator" decorated with "@wamp.procedure"
      ##
      results = yield self.register(self.calculator)
      for success, res in results:
         if success:
            print("Ok, registered procedure with registration ID {}".format(res.id))
         else:
            print("Failed to register procedure: {}".format(res.value))


   def onDisconnect(self):
      reactor.stop()



def make(config):
   ##
   ## This component factory creates instances of the
   ## application component to run.
   ##
   ## The function will get called either during development
   ## using the ApplicationRunner below, or as  a plugin running
   ## hosted in a WAMPlet container such as a Crossbar.io worker.
   ##
   if config:
      return Component1(config)
   else:
      ## if no config given, return a description of this WAMPlet ..
      return {'label': 'Awesome WAMPlet 1',
              'description': 'This is just a test WAMPlet that provides some procedures to call.'}



if __name__ == '__main__':
   from autobahn.twisted.wamp import ApplicationRunner

   ## test drive the component during development ..
   runner = ApplicationRunner(
      url = "ws://127.0.0.1:8080/ws",
      realm = "realm1",
      debug = False, ## low-level WebSocket debugging
      debug_wamp = False, ## WAMP protocol-level debugging
      debug_app = True) ## app-level debugging

   runner.run(make)

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


from autobahn.wamp2.broker import Broker
from autobahn.wamp2.websocket import WampWebSocketServerProtocol, \
                                     WampWebSocketServerFactory

from autobahn.wamp2.serializer import WampJsonSerializer, WampMsgPackSerializer

from autobahn.wamp2.http import WampHttpResourceSession, \
                                WampHttpResource


from autobahn.wamp2.protocol import WampProtocol


class MyWampSession(WampProtocol):

   def __init__(self, broker):
      self._broker = broker

   def onSessionOpen(self):
      self.setBroker(self._broker)


class MyWampSessionFactory:

   def __init__(self):
      self._broker = Broker()

   def createSession(self):
      session = MyWampSession(self._broker)
      return session



class MyPubSubResourceSession(WampHttpResourceSession):

   def onSessionOpen(self):
      self.setBroker(self._parent._broker)

   def onSessionClose(self):
      print "SESSION CLOSED"


class MyPubSubResource(WampHttpResource):

   protocol = MyPubSubResourceSession

   def __init__(self, serializers, broker, debug = True):
      WampHttpResource.__init__(self, serializers = serializers, debug = debug)
      self._broker = broker



class PubSubServerProtocol(WampWebSocketServerProtocol):

   def onSessionOpen(self):
      self.setBroker(self.factory._broker)



class PubSubServerFactory(WampWebSocketServerFactory):

   protocol = PubSubServerProtocol

   def __init__(self, url, serializers, broker, debug = False):
      WampWebSocketServerFactory.__init__(self, url, serializers = serializers, debug = debug)
      self._broker = broker




if __name__ == '__main__':

   import sys

   from twisted.internet import reactor
   from twisted.python import log
   from twisted.web.server import Site
   from twisted.web.static import File

   from twisted.internet.endpoints import serverFromString

   log.startLogging(sys.stdout)

   broker = Broker()

   jsonSerializer = WampJsonSerializer()

   serializers = [WampMsgPackSerializer(), jsonSerializer]

   wampfactory = PubSubServerFactory("ws://localhost:9000", serializers, broker, debug = False)
   wampserver = serverFromString(reactor, "tcp:9000")
   wampserver.listen(wampfactory)


   wampResource = MyPubSubResource([jsonSerializer], broker)

   root = File("longpoll")
   root.putChild("wamp", wampResource)

   site = Site(root)
   site.log = lambda _: None # disable any logging
   reactor.listenTCP(8080, site)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


from autobahn.wamp2.websocket import WampWebSocketClientProtocol, \
                                     WampWebSocketClientFactory

from autobahn.wamp2.serializer import WampJsonSerializer, WampMsgPackSerializer


class PubSubClientProtocol(WampWebSocketClientProtocol):
   """
   """ 

   def onSessionOpen(self):
      print "WAMP session opened", self.websocket_protocol_in_use

      def onMyEvent1(topic, event):
         print "Received event:", event

      d = self.subscribe("http://example.com/myEvent1", onMyEvent1)

      def subscribeSuccess(subscriptionid):
         print "Subscribe Success", subscriptionid

      def subscribeError(error):
         print "Subscribe Error", error

      d.addCallbacks(subscribeSuccess, subscribeError)

      if self.factory.period:

         self.counter = 0

         def sendMyEvent1():
            self.counter += 1
            self.publish("http://example.com/myEvent1",
               {
                  "msg": "Hello from Python!",
                  "counter": self.counter
               }
            )
            reactor.callLater(self.factory.period, sendMyEvent1)

         sendMyEvent1()


   def onSessionClose(self):
      print "WAMP session closed"
      self.factory.reactor.stop()



class PubSubClientFactory(WampWebSocketClientFactory):
   """
   """

   protocol = PubSubClientProtocol

   def __init__(self, url, serializers = None, period = 0, debug = False):
      WampWebSocketClientFactory.__init__(self, url, serializers = serializers, debug = debug)
      self.period = period



if __name__ == '__main__':

   import sys, argparse

   from twisted.python import log
   from twisted.internet.endpoints import clientFromString


   ## parse command line arguments
   ##
   parser = argparse.ArgumentParser()

   parser.add_argument("-d", "--debug", action = "store_true",
                       help = "Enable debug output.")

   parser.add_argument("--websocket", default = "tcp:localhost:9000",
                       help = 'WebSocket client Twisted endpoint descriptor, e.g. "tcp:localhost:9000" or "unix:/tmp/mywebsocket".')

   parser.add_argument("--wsurl", default = "ws://localhost:9000",
                       help = 'WebSocket URL (must suit the endpoint), e.g. "ws://localhost:9000".')

   parser.add_argument("--period", type = float, default = 2,
                       help = 'Auto-publication period in seconds.')

   parser.add_argument("--serializers", type = str, default = None,
                       help = 'If set, use this (comma separated) list of WAMP serializers, e.g. "json" or "msgpack,json"')

   #parser.add_argument("--period", type = float, default = 2,
   #                    help = 'Auto-publication period in seconds.')

   args = parser.parse_args()


   ## start Twisted logging to stdout
   ##
   log.startLogging(sys.stdout)


   ## we use an Autobahn utility to import the "best" available Twisted reactor
   ##
   from autobahn.choosereactor import install_reactor
   reactor = install_reactor()
   print "Running on reactor", reactor


   ## start a WebSocket client
   ##
   if args.serializers:
      serializers = []
      for id in args.serializers.split(','):
         if id.strip() == WampJsonSerializer.SERIALIZER_ID:
            serializers.append(WampJsonSerializer())
         elif id.strip() == WampMsgPackSerializer.SERIALIZER_ID:
            serializers.append(WampMsgPackSerializer())
         else:
            raise Exception("unknown WAMP serializer %s" % id)
      if len(serializers) == 0:
         raise Exception("no WAMP serializers selected")
   else:
      serializers = [WampMsgPackSerializer(), WampJsonSerializer()]
   wsfactory = PubSubClientFactory(args.wsurl, serializers = serializers, period = args.period, debug = args.debug)
   wsclient = clientFromString(reactor, args.websocket)
   d = wsclient.connect(wsfactory)

   def connected(proto):
      print "Endpoint connected:", proto

   def disconnected(err):
      print "Endpoint disconnected:", err
      reactor.stop()

   d.addCallbacks(connected, disconnected)


   ## now enter the Twisted reactor loop
   ##
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


from autobahn.wamp2.broker import Broker
from autobahn.wamp2.websocket import WampWebSocketServerProtocol, \
                                     WampWebSocketServerFactory


class PubSubServerProtocol(WampWebSocketServerProtocol):
   """
   """

   def onSessionOpen(self):
      self.setBroker(self.factory.broker)



class PubSubServerFactory(WampWebSocketServerFactory):
   """
   """

   protocol = PubSubServerProtocol

   def __init__(self, url, debug = False):
      WampWebSocketServerFactory.__init__(self, url, debug)
      self.broker = Broker()




if __name__ == '__main__':

   import sys, argparse

   from twisted.python import log
   from twisted.internet.endpoints import serverFromString


   ## parse command line arguments
   ##
   parser = argparse.ArgumentParser()

   parser.add_argument("-d", "--debug", action = "store_true",
                       help = "Enable debug output.")

   parser.add_argument("--websocket", default = "tcp:9000",
                       help = 'WebSocket server Twisted endpoint descriptor, e.g. "tcp:9000" or "unix:/tmp/mywebsocket".')

   parser.add_argument("--wsurl", default = "ws://localhost:9000",
                       help = 'WebSocket URL (must suit the endpoint), e.g. "ws://localhost:9000".')

   parser.add_argument("--web", default = "tcp:8080",
                       help = 'Web server endpoint descriptor, e.g. "tcp:8080".')

   args = parser.parse_args()


   ## start Twisted logging to stdout
   ##
   log.startLogging(sys.stdout)


   ## we use an Autobahn utility to install the "best" available Twisted reactor
   ##
   from autobahn.choosereactor import install_reactor
   reactor = install_reactor()
   print "Running on reactor", reactor


   ## start a WebSocket server
   ##
   wampfactory = PubSubServerFactory(args.wsurl, debug = args.debug)
   wampserver = serverFromString(reactor, args.websocket)
   wampserver.listen(wampfactory)


   ## start a Web server
   ##
   if args.web != "":
      from twisted.web.server import Site
      from twisted.web.static import File

      webfactory = Site(File("."))
      webserver = serverFromString(reactor, args.web)
      webserver.listen(webfactory)


   ## now enter the Twisted reactor loop
   ##
   reactor.run()

########NEW FILE########
__FILENAME__ = test
###############################################################################
##
##  Copyright 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from autobahn.websocket import WebSocketProtocol, HttpException, Timings
from autobahn.websocket import WebSocketClientProtocol, WebSocketClientFactory
from autobahn.websocket import WebSocketServerFactory, WebSocketServerProtocol

from autobahn.httpstatus import HTTP_STATUS_CODE_BAD_REQUEST
from autobahn.util import utcnow, newid

import autobahn.wamp2

from autobahn.wamp2.dealer import Dealer, exportRpc
from autobahn.wamp2.broker import Broker
from autobahn.wamp2.protocol import WampServerProtocol, \
                                    WampServerFactory, \
                                    WampClientProtocol, \
                                    WampClientFactory

from autobahn.wamp2.serializer import JsonSerializer, MsgPackSerializer

from twisted.python import log
from twisted.internet import reactor

from autobahn.websocket import connectWS, listenWS



def test1():

   serializer = JsonDefaultSerializer()

   wampSerializer = WampSerializer(serializer)

   wampMsg = WampMessageSubscribe("http://myapp.com/topic1", match = WampMessageSubscribe.MATCH_PREFIX)
   wampMsg = WampMessageUnsubscribe("http://myapp.com/topic1", match = WampMessageSubscribe.MATCH_PREFIX)
   wampMsg = WampMessagePublish("http://myapp.com/topic1", "Hello, world!")

   bytes = wampSerializer.serialize(wampMsg)

   print bytes

   wampMsg2 = wampSerializer.unserialize(bytes)

   print wampMsg2.__class__
   print wampMsg2


class Calculator:

   def __init__(self):
      self._sum = 0

   @exportRpc
   def add(self, a, b):
      return a + b

   @exportRpc
   def accumulate(self, value):
      self._sum += value

   @exportRpc
   def getValue(self):
      return self._sum


## http://myapp.com/getRevenue

## When multiple endpoints are registered under the same URI
## with a dealer, it is under the dealer's policy what happens:
## 
## - ignore any but first
## - overwrite
## - accumulate
##
## make subscribe return a (ephemeral) subscription id (on success)
## make event contain that subscription id
## make unsubscribe contain that subscription id
##
## make provide return a (ephemeral) provisioning id (on success)
## make call contain that provisioning id
## make unprovide contain that provisioning id
##

## call _all_ implementing endpoints and get accumulated result
## call _all_ implementing endpoints, receive progressive results and final result empty
## call a random implementing endpoint and receive result
## call the implementing endpoint with given session ID
## call any implementing endpoint (let the dealer choose, e.g. nearest)


def test_server(wsuri, wsuri2 = None):

   dealer = Dealer()

   if wsuri2 is None:
      calculator = Calculator()
      dealer.register("http://myapp.com/", calculator)


   broker = Broker()

   class MyPubSubServerProtocol(WampServerProtocol):

      def onSessionOpen(self):
         self.setBroker(broker)
         self.setDealer(dealer)

   wampFactory = WampServerFactory(wsuri)
   wampFactory.protocol = MyPubSubServerProtocol
   listenWS(wampFactory)

   if wsuri2:
      class MyPubSubClientProtocol(WampClientProtocol):

         def onSessionOpen(self):
            self.setBroker(broker)
            self.setDealer(dealer)

      factory = WampClientFactory(wsuri2)
      factory.protocol = MyPubSubClientProtocol
      connectWS(factory)


def test_client(wsuri, dopub):

   dorpc = False

   class MyPubSubClientProtocol(WampClientProtocol):

      def onSessionOpen(self):

         print "Connected!"

         def onMyEvent1(topic, event):
            print "Received event", topic, event

         d = self.subscribe("http://example.com/myEvent1", onMyEvent1)

         def subscribeSuccess(subscriptionid):
            print "Subscribe Success", subscriptionid

         def subscribeError(error):
            print "Subscribe Error", error

         d.addCallbacks(subscribeSuccess, subscribeError)

         self.counter = 0

         def sendMyEvent1():
            self.counter += 1
            self.publish("http://example.com/myEvent1",
               {
                  "msg": "Hello from Python!",
                  "counter": self.counter
               }
            )
            reactor.callLater(2, sendMyEvent1)

         if dopub:
            sendMyEvent1()

         if dorpc:
            def writeln(res):
               print res

            d = self.call("http://myapp.com/add", 23, 7)
            d.addBoth(writeln)

            d = self.call("http://myapp2.com/add", 40, 2)
            d.addBoth(writeln)


      def onClose(self, wasClean, code, reason):
         print "Connection closed", reason
         reactor.stop()

   factory = WampClientFactory(wsuri)
   factory.protocol = MyPubSubClientProtocol
   connectWS(factory)


def test_client2(wsuri):

   class MyPubSubClientProtocol(WampClientProtocol):

      def onSessionOpen(self):

         print "Connected!"
         calculator = Calculator()

         dealer = Dealer()
         dealer.register("http://myapp2.com/", calculator)

         self.setDealer(dealer)

      def onClose(self, wasClean, code, reason):
         print "Connection closed", reason
         reactor.stop()

   factory = WampClientFactory(wsuri)
   factory.protocol = MyPubSubClientProtocol
   connectWS(factory)

## python test.py server ws://127.0.0.1:9000
## python test.py server ws://127.0.0.1:9001 ws://127.0.0.1:9000
## python test.py client ws://127.0.0.1:9000 pub


## python test.py server ws://127.0.0.1:9000
## python test.py server ws://127.0.0.1:9001 ws://127.0.0.1:9000
## python test.py client2 ws://127.0.0.1:9001
## python test.py client ws://127.0.0.1:9000


if __name__ == '__main__':

   log.startLogging(sys.stdout)

   mode = sys.argv[1]
   wsuri = sys.argv[2]

   if mode == 'server' and len(sys.argv) > 3:
      wsuri2 = sys.argv[3]
   else:
      wsuri2 = None

   if mode == 'client' and len(sys.argv) > 3:
      dopub = sys.argv[3] == "pub"
   else:
      dopub = False

   if mode == 'client':
      test_client(wsuri, dopub)
   elif mode == 'client2':
      test_client2(wsuri)
   elif mode == 'server':
      test_server(wsuri, wsuri2)
   else:
      raise Exception("illegal mode")

   #test1()

   reactor.run()


########NEW FILE########
__FILENAME__ = test2

# http://docs.python.org/2/library/inspect.html
# https://github.com/dotcloud/zerorpc-python/blob/master/zerorpc/decorators.py

import inspect

class Foo(object):
   pass

#from twisted.internet.defer import inlineCallbacks

#@asyncio.coroutine
import asyncio

#@inlineCallbacks
@asyncio.coroutine
def add2(a, b = 3, c = Foo, d = "klj", *args, **kwargs):
   """
   Adds 2 numbers.

   :param a: First number.
   :type a: int
   :param b: Second number.
   :type b: int
   :returns: int -- The sum of both numbers.
   """
   return a + b

def get_class_default_arg(fn, klass):
   argspec = inspect.getargspec(fn)
   if argspec and argspec.defaults:
      for i in range(len(argspec.defaults)):
         if argspec.defaults[-i] == klass:
            return argspec.args[-i]
   return None

print(inspect.signature(add2))
print(inspect.getargspec(add2))
print(get_class_default_arg(add2, Foo))
print(inspect.cleandoc(add2.__doc__))

########NEW FILE########
__FILENAME__ = test3
from __future__ import absolute_import

from zope.interface import implementer

from autobahn.wamp2.interfaces import *
from autobahn.wamp2.types import *

from autobahn.wamp2.error import ApplicationError, ProtocolError

from twisted.internet.defer import Deferred, inlineCallbacks


import random

def newid():
   return random.randint(0, 2**53)



@implementer(ISubscriber)
@implementer(IPublisher)
@implementer(ICallee)
@implementer(ICaller)
class MockSession:

   def __init__(self):
      self._subscriptions = {}
      self._registrations = {}


   def subscribe(self, topic, options = None):
      assert(type(topic) == str)
      assert(options is None or isinstance(options, SubscribeOptions))
      if not self._subscriptions.has_key(topic):
         self._subscriptions[topic] = Subscription(newid(), topic)
      d = Deferred()
      d.callback(self._subscriptions[topic])
      return d


   def unsubscribe(self, subscription):
      assert(isinstance(subscription, Subscription))
      assert(subscription._isActive)
      assert(subscription._topic in self._subscriptions)
      subscription._isActive = False
      del self._subscriptions[subscription._topic]
      d = Deferred()
      d.callback(None)
      return d


   def publish(self, topic, payload = None, options = None):
      assert(type(topic) == str)
      assert(options is None or isinstance(options, PublishOptions))

      d = Deferred()
      if topic not in ["com.myapp.mytopic1"]:
         d.errback(ApplicationError(ApplicationError.NOT_AUTHORIZED))
      else:
         id = newid()
         if self._subscriptions.has_key(topic):
            event = Event(topic, payload, id)
            self._subscriptions[topic].notify(event)
         d.callback(id)
      return d


   def register(self, procedure, endpoint, options = None):
      assert(type(procedure) == str)
      assert(options is None or isinstance(options, RegisterOptions))
      if not self._registrations.has_key(procedure):
         self._registrations[procedure] = Registration(newid(), procedure, endpoint)
      d = Deferred()
      d.callback(self._registrations[procedure])
      return d


   def unregister(self, registration):
      assert(isinstance(registration, Registration))
      assert(registration._isActive)
      assert(registration._procedure in self._registrations)
      registration._isActive = False
      del self._registrations[registration._procedure]
      d = Deferred()
      d.callback(None)
      return d


   def call(self, procedure, *args, **kwargs):
      assert(type(procedure) == str)

      invocation = Invocation()
      if 'options' in kwargs:
         options = kwargs['options']
         del kwargs['options']
         assert(isinstance(options, CallOptions))
         if options.discloseMe:
            invocation.caller = newid()
         if options.onProgress:
            invocation.progress = options.onProgress

      d = Deferred()
      if procedure == "com.myapp.echo":
         if len(args) != 1 or len(kwargs) != 0 or type(args[0]) != str:
            d.errback(ApplicationError(ApplicationError.INVALID_ARGUMENT, "procedure takes exactly 1 positional argument of type string"))
         else:
            d.callback(args[0])
      elif procedure == "com.myapp.complex":
         d.callback(CallResult(23, 7, foo = "bar"))

      elif self._registrations.has_key(procedure):
         try:
            kwargs['invocation'] = invocation
            res = self._registrations[procedure]._endpoint(*args, **kwargs)
         except TypeError as err:
            d.errback(ApplicationError(ApplicationError.INVALID_ARGUMENT, str(err)))
         else:
            d.callback(res)

      else:
         d.errback(ApplicationError(ApplicationError.NO_SUCH_PROCEDURE, "no procedure with URI {}".format(procedure)))
      return d


import inspect

@inlineCallbacks
def test_rpc(session):

   def hello(msg, invocation = Invocation):
      for i in range(5):
         invocation.progress(i)
      return "You said {}. I say hello!".format(msg)

   print inspect.getargspec(hello)

   try:
      reg1 = yield session.register("com.myapp.hello", hello)
      print(reg1)
   except ApplicationError as err:
      print(err)
   else:
      def onProgress(i):
         print("progress {}".format(i))

      res = yield session.call("com.myapp.hello", "foooo", options = CallOptions(discloseMe = True, onProgress = onProgress))
      print(res)
      yield session.unregister(reg1)
      res = yield session.call("com.myapp.hello", "baaar")
      print(res)

   try:
#      res = yield session.call("com.myapp.echo", "Hello, world!", 23)
#      res = yield session.call("com.myapp.complex", "Hello, world!", 23)
      res = yield session.call("com.myapp.complex", "Hello, world!", 23, options = CallOptions(timeout = 2))
      print(res.results)
      print(res.kwresults)
   except ApplicationError as err:
      print(err)


@inlineCallbacks
def test_pubsub(session):
   try:
      sub1 = yield session.subscribe("com.myapp.mytopic1", SubscribeOptions(match = 'prefix'))
      print(sub1)
   except ApplicationError as err:
      print(err)
   else:
      def watcher1(event):
         print("watcher1: publication {} on topic {} with payload {}".format(event.publication, event.topic, event.payload))

      def watcher2(event):
         print("watcher1: publication {} on topic {} with payload {}".format(event.publication, event.topic, event.payload))

      sub1.watch(watcher1)
      sub1.watch(watcher2)

      session.publish("com.myapp.mytopic1", "Hello, world!")

      sub1.unwatch(watcher1)

      publicationId = yield session.publish("com.myapp.mytopic1", "Hello, world!")
      print(publicationId)

      session.publish("com.myapp.mytopic2", "Hello, world!")



if __name__ == '__main__':

   session = MockSession()

   test_rpc(session)
   test_pubsub(session)

########NEW FILE########
__FILENAME__ = test_interfaces
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from __future__ import absolute_import

#from twisted.trial import unittest
import unittest

from zope.interface import implementer

from autobahn.wamp.interfaces import *
from autobahn.wamp.types import *

from autobahn.wamp.exception import ApplicationError, ProtocolError

from twisted.internet.defer import Deferred, inlineCallbacks


import random

def newid():
   return random.randint(0, 2**53)



@implementer(ISubscriber)
@implementer(IPublisher)
@implementer(ICallee)
@implementer(ICaller)
class MockSession:

   def __init__(self):
      self._subscriptions = {}
      self._registrations = {}


   def subscribe(self, topic, options = None):
      assert(type(topic) == str)
      assert(options is None or isinstance(options, SubscribeOptions))
      if not self._subscriptions.has_key(topic):
         self._subscriptions[topic] = Subscription(newid(), topic)
      d = Deferred()
      d.callback(self._subscriptions[topic])
      return d


   def unsubscribe(self, subscription):
      assert(isinstance(subscription, Subscription))
      assert(subscription._isActive)
      assert(subscription._topic in self._subscriptions)
      subscription._isActive = False
      del self._subscriptions[subscription._topic]
      d = Deferred()
      d.callback(None)
      return d


   def publish(self, topic, payload = None, options = None):
      assert(type(topic) == str)
      assert(options is None or isinstance(options, PublishOptions))

      d = Deferred()
      if topic not in ["com.myapp.mytopic1"]:
         d.errback(ApplicationError(ApplicationError.NOT_AUTHORIZED))
      else:
         id = newid()
         if self._subscriptions.has_key(topic):
            event = Event(topic, payload, id)
            self._subscriptions[topic].notify(event)
         d.callback(id)
      return d


   def register(self, procedure, endpoint, options = None):
      assert(type(procedure) == str)
      assert(options is None or isinstance(options, RegisterOptions))
      if not self._registrations.has_key(procedure):
         self._registrations[procedure] = Registration(newid(), procedure, endpoint)
      d = Deferred()
      d.callback(self._registrations[procedure])
      return d


   def unregister(self, registration):
      assert(isinstance(registration, Registration))
      assert(registration._isActive)
      assert(registration._procedure in self._registrations)
      registration._isActive = False
      del self._registrations[registration._procedure]
      d = Deferred()
      d.callback(None)
      return d


   def call(self, procedure, *args, **kwargs):
      assert(type(procedure) == str)
      if 'options' in kwargs:
         options = kwargs['options']
         del kwargs['options']
         assert(isinstance(options, CallOptions))

      d = Deferred()
      if procedure == "com.myapp.echo":
         if len(args) != 1 or len(kwargs) != 0 or type(args[0]) != str:
            d.errback(ApplicationError(ApplicationError.INVALID_ARGUMENT, "procedure takes exactly 1 positional argument of type string"))
         else:
            d.callback(args[0])
      elif procedure == "com.myapp.complex":
         d.callback(CallResult(23, 7, foo = "bar"))

      elif self._registrations.has_key(procedure):
         try:
            res = self._registrations[procedure]._endpoint(*args, **kwargs)
         except TypeError as err:
            d.errback(ApplicationError(ApplicationError.INVALID_ARGUMENT, str(err)))
         else:
            d.callback(res)

      else:
         d.errback(ApplicationError(ApplicationError.NO_SUCH_PROCEDURE, "no procedure with URI {}".format(procedure)))
      return d



@inlineCallbacks
def test_rpc(session):

   def hello(msg):
      return "You said {}. I say hello!".format(msg)

   try:
      reg1 = yield session.register("com.myapp.hello", hello)
      print(reg1)
   except ApplicationError as err:
      print(err)
   else:
      res = yield session.call("com.myapp.hello", "foooo")
      print (res)
      yield session.unregister(reg1)
      res = yield session.call("com.myapp.hello", "baaar")
      print (res)

   try:
#      res = yield session.call("com.myapp.echo", "Hello, world!", 23)
#      res = yield session.call("com.myapp.complex", "Hello, world!", 23)
      res = yield session.call("com.myapp.complex", "Hello, world!", 23, options = CallOptions(timeout = 2))
      print(res.results)
      print(res.kwresults)
   except ApplicationError as err:
      print(err)


@inlineCallbacks
def test_pubsub(session):
   try:
      sub1 = yield session.subscribe("com.myapp.mytopic1", SubscribeOptions(match = 'prefix'))
      print(sub1)
   except ApplicationError as err:
      print(err)
   else:
      def watcher1(event):
         print("watcher1: publication {} on topic {} with payload {}".format(event.publication, event.topic, event.payload))

      def watcher2(event):
         print("watcher1: publication {} on topic {} with payload {}".format(event.publication, event.topic, event.payload))

      sub1.watch(watcher1)
      sub1.watch(watcher2)

      session.publish("com.myapp.mytopic1", "Hello, world!")

      sub1.unwatch(watcher1)

      publicationId = yield session.publish("com.myapp.mytopic1", "Hello, world!")
      print(publicationId)

      session.publish("com.myapp.mytopic2", "Hello, world!")



class Publisher(unittest.TestCase):

   def setUp(self):
      self.session = MockSession()

   def tearDown(self):
      pass

   @inlineCallbacks
   def test_register(self):

      def hello(msg):
         return "You said {}. I say hello!".format(msg)

      try:
         reg1 = yield self.session.register("com.myapp.hello", hello)
      except ApplicationError as err:
         print(err)


if __name__ == '__main__':
   unittest.main()

########NEW FILE########
__FILENAME__ = test_serializer
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import binascii

from autobahn.util import newid
from autobahn.wamp2.serializer import JsonSerializer, MsgPackSerializer, WampSerializer
from autobahn.wamp2.message import *


if __name__ == '__main__':
   serializers = [WampSerializer(JsonSerializer()), WampSerializer(MsgPackSerializer())]
   totals = {}

   EVENT1 = ["Hello, world!", 0.123456789, {'foo': 23, 'bar': 'baz', 'moo': True}, [True, True, False]]
   msgs = [
      WampMessagePublish("http://myapp.com/topic1", EVENT1),
      WampMessagePublish("http://myapp.com/topic1", EVENT1, excludeMe = False),
      WampMessagePublish("http://myapp.com/topic1", EVENT1, eligible = [newid(), newid(), newid()]),
      WampMessagePublish("http://myapp.com/topic1", EVENT1, discloseMe = True, excludeMe = True, exclude = [newid()]),
   ]

   for msg_out in msgs:
      for ser in serializers:

         bytes, isbinary = ser.serialize(msg_out)

         if not totals.has_key(ser._serializer):
            totals[ser._serializer] = 0

         totals[ser._serializer] += len(bytes)

         if isbinary:
            print len(bytes), binascii.hexlify(bytes)
         else:
            print len(bytes), bytes

         msg_in = ser.unserialize(bytes, isbinary)
         print msg_in
         print
         assert(msg_in == msg_out)

   for k, v in totals.items():
      print k, v

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys, decimal

from twisted.python import log
from twisted.internet import reactor
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import listenWS

from autobahn.wamp1.protocol import exportRpc, \
                                    WampServerFactory, \
                                    WampServerProtocol


class CalculatorServerProtocol(WampServerProtocol):

   def onSessionOpen(self):
      self.registerForRpc(self, "http://example.com/simple/calculator#")
      self.clear()


   def clear(self, arg = None):
      self.op = None
      self.current = decimal.Decimal(0)


   @exportRpc
   def calc(self, arg):

      op = arg["op"]

      if op == "C":
         self.clear()
         return str(self.current)

      num = decimal.Decimal(arg["num"])
      if self.op:
         if self.op == "+":
            self.current += num
         elif self.op == "-":
            self.current -= num
         elif self.op == "*":
            self.current *= num
         elif self.op == "/":
            self.current /= num
         self.op = op
      else:
         self.op = op
         self.current = num

      res = str(self.current)
      if op == "=":
         self.clear()

      return res


if __name__ == '__main__':

   decimal.getcontext().prec = 20

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WampServerFactory("ws://localhost:9000", debugWamp = debug)
   factory.protocol = CalculatorServerProtocol
   factory.setProtocolOptions(allowHixie76 = True)
   listenWS(factory)

   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2012-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor, defer

from txdbus import error, client

from autobahn.twisted.websocket import connectWS

from autobahn.wamp1.protocol import WampClientFactory, \
                                    WampCraClientProtocol


def delay(t):
   d = defer.Deferred()
   reactor.callLater(t, lambda : d.callback(None) )
   return d


class DbusClientProtocol(WampCraClientProtocol):

   def onSessionOpen(self):
      self.authenticate(self.onAuthSuccess,
                        self.onAuthError,
                        authKey = self.factory.user,
                        authSecret = self.factory.password)


   def onClose(self, wasClean, code, reason):
      reactor.stop()


   def onAuthSuccess(self, permissions):
      print "Authentication Success!", permissions
      self.subscribe("http://example.com/topics/%s" % self.factory.user, self.onNotify)
      self.subscribe("http://example.com/topics/all", self.onNotify)


   def onAuthError(self, uri, desc, details):
      print "Authentication Error!", uri, desc, details
      self.sendClose()


   @defer.inlineCallbacks
   def onNotify(self, topic, event):
      print topic, event

      con = yield client.connect(reactor, 'session')

      notifier = yield con.getRemoteObject('org.freedesktop.Notifications',
                                           '/org/freedesktop/Notifications')

      nid = yield notifier.callRemote('Notify',
                                      str(event['app']), 0,
                                      '',
                                      str(event['title']),
                                      str(event['body']),
                                      [], dict(),
                                      1)

      yield delay(event['duration'])

      print "autoclosing notification"

      yield notifier.callRemote('CloseNotification', nid)


class DbusClientFactory(WampClientFactory):

   protocol = DbusClientProtocol

   def __init__(self, wsuri, user, password):
      self.user = user
      self.password = password
      WampClientFactory.__init__(self, wsuri)



if __name__ == '__main__':

   log.startLogging(sys.stdout)
   factory = DbusClientFactory(sys.argv[1], sys.argv[2], sys.argv[3])
   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2012-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor, defer
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import listenWS

from autobahn.wamp1.protocol import exportRpc, \
                                    WampServerFactory, \
                                    WampCraServerProtocol



class DbusServerProtocol(WampCraServerProtocol):

   ## our pseudo user/permissions database
   USERS = {'user1': 'secret',
            'user2': 'geheim'}

   def onSessionOpen(self):

      ## override global client auth options
      self.clientAuthTimeout = 0
      self.clientAuthAllowAnonymous = True

      ## call base class method
      WampCraServerProtocol.onSessionOpen(self)


   def getAuthPermissions(self, authKey, authExtra):
      if authKey is None:
         ## notification issuer is only allowed to publish to topics
         ## and retrieve list of users
         pms = {'pubsub': [{'uri': 'http://example.com/topics/',
                                    'prefix': True,
                                    'pub': True,
                                    'sub': False}],
                 'rpc': [{'uri': 'http://example.com/procedures/getusers',
                          'call': True}]}
         return {'permissions': pms}
      else:
         ## desktop notification client is only allowed to subscribe to topics
         ##  http://example.com/topics/all
         ##  http://example.com/topics/<user>
         ##
         pms = {'pubsub': [{'uri': 'http://example.com/topics/all',
                                    'prefix': False,
                                    'pub': False,
                                    'sub': True},
                            {'uri': 'http://example.com/topics/%s' % authKey,
                                    'prefix': False,
                                    'pub': False,
                                    'sub': True}],
                 'rpc': []}
         return {'permissions': pms}


   def getAuthSecret(self, authKey):
      ## return the auth secret for the given auth key or None when the auth key
      ## does not exist
      return self.USERS.get(authKey, None)


   def onAuthenticated(self, authKey, permissions):
      ## fired when authentication succeeds

      ## register PubSub topics from the auth permissions
      self.registerForPubSubFromPermissions(perms['permissions'])

      ## register RPC endpoints (for now do that manually, keep in sync with perms)
      if authKey is None:
         self.registerForRpc(self, 'http://example.com/procedures/',
                             [MyServerProtocol.getUsers])


   @exportRpc("getusers")
   def getUsers(self):
      return self.USERS.keys()



if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WampServerFactory("ws://localhost:9000", debugWamp = debug)
   factory.protocol = DbusServerProtocol
   listenWS(factory)

   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = dirwatch
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys
import threading


if sys.platform == 'win32':
   from win32.dirwatch import DirWatcher
else:
   raise ImportError("missing platform support for %s" % sys.platform)


from twisted.python import log
from twisted.internet import reactor

from autobahn.twisted.websocket import connectWS

from autobahn.wamp1.protocol import WampClientFactory, \
                                    WampClientProtocol



class DirWatchClientProtocol(WampClientProtocol):

   def onSessionOpen(self):
      print "Connected", threading.currentThread().name
      self.factory.wasConnected = True



class DirWatchClientFactory(WampClientFactory):

   def __init__(self, app):
      WampClientFactory.__init__(self, app.url, debugWamp = app.debug)
      self.app = app
      self.proto = None
      self.wasConnected = False


   def buildProtocol(self, addr):
      self.proto = DirWatchClientProtocol()
      self.proto.factory = self
      return self.proto


   def _reconnect(self, connector):
      if self.wasConnected:
         log.msg("reconnecting in 2 secs ..")
         reactor.callLater(2, connector.connect)
      else:
         if self.app.watcher:
            self.app.watcher.stop()
         reactor.stop()


   def clientConnectionLost(self, connector, reason):
      self.proto = None
      log.msg("connection lost: %s" % reason)
      self._reconnect(connector)


   def clientConnectionFailed(self, connector, reason):
      self.proto = None
      log.msg("connection failed: %s" % reason)
      self._reconnect(connector)



class DirWatcherApp:

   def __init__(self, url, directory = ".", debug = False):
      self.directory = directory
      self.url = url
      self.debug = debug
      self.client = None
      self.watcher = None
      self.seq = 0


   def onDirEvent(self, events):
      print threading.currentThread().name, events

      ## only publish when we are connected to WAMP server
      ##
      if self.client and self.client.proto:
         for e in events:
            self.seq += 1
            event = {'operation': e[0],
                     'path': e[1],
                     'sequence': self.seq}

            ## we MUST use callFromThread to publish our event, since
            ## the code here is running on a background thread, and
            ## event dispatching (and in general the Twisted reactor)
            ## runs on the main thread.
            ##
            reactor.callFromThread(self.client.proto.publish, u"http://dirwatch.autobahn.ws#filesystemEvent", event)
      else:
         log.msg("not connected - skipping event")


   def start(self):
      ## the directory watcher
      ##
      self.watcher = DirWatcher(dir = self.directory)

      ## start directory watcher on _background_ thread
      ##
      reactor.callInThread(self.watcher.loop, self.onDirEvent)

      ## start WAMP client (on main reactor thread)
      ##
      self.client = DirWatchClientFactory(self)
      connectWS(self.client)



if __name__ == '__main__':

   log.startLogging(sys.stdout)
   debug = len(sys.argv) > 1 and sys.argv[1] == 'debug'

   app = DirWatcherApp("ws://localhost:9000", ".", debug)
   app.start()

   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import listenWS

from autobahn.wamp1.protocol import WampServerFactory, \
                                    WampServerProtocol


class DirWatchServerProtocol(WampServerProtocol):

   def onSessionOpen(self):

      ## register a URI and all URIs having the string as prefix as PubSub topic
      self.registerForPubSub("http://dirwatch.autobahn.ws", True)


if __name__ == '__main__':

   log.startLogging(sys.stdout)
   debug = len(sys.argv) > 1 and sys.argv[1] == 'debug'

   factory = WampServerFactory("ws://localhost:9000", debugWamp = debug)
   factory.protocol = DirWatchServerProtocol
   factory.setProtocolOptions(allowHixie76 = True)
   listenWS(factory)

   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = dirwatch
###############################################################################
##
##  Copyright 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import os
import os.path

import pywintypes

import win32file
import win32con
import win32event

import ntsecuritycon



class DirWatcher:
   """
   Watches a directory (optional recursively) for file system changes.

   Infos:
     * http://msdn.microsoft.com/en-us/library/windows/desktop/aa365465%28v=vs.85%29.aspx
     * http://www.themacaque.com/?p=859
     * http://timgolden.me.uk/python/win32_how_do_i/watch_directory_for_changes.html
   """

   _ACTIONS = {1: 'CREATE',
               2: 'DELETE',
               3: 'MODIFY',
               4: 'MOVEFROM',
               5: 'MOVETO'}

   def __init__(self, dir = '.', recurse = True, asynch = True, timeout = 200):
      """
      Directory change watcher. After creation, you will call loop() providing
      a callback that fires when changes are detected. If running asynch == True,
      you can stop() the loop, even when no change events happen (which is generally,
      desirable!).

      To use this class with Twisted, you should deferToThread the loop().

      :param dir: Directory to watch.
      :type dir: str
      :param recurse: Watch all subdirectories also - recursively.
      :type recurse: bool
      :param asynch: Iff true, use IOCP looping, which can be interrupted by calling stop().
      :type asynch: bool
      :param timeout: Iff asynch, timeout for the event loop.
      :type timeout: int
      """

      self.dir = os.path.abspath(dir)
      self.recurse = recurse
      self.stopped = False
      self.asynch = asynch
      self.timeout = timeout

      ## listening filter
      self.filter = win32con.FILE_NOTIFY_CHANGE_FILE_NAME | \
                    win32con.FILE_NOTIFY_CHANGE_DIR_NAME | \
                    win32con.FILE_NOTIFY_CHANGE_ATTRIBUTES | \
                    win32con.FILE_NOTIFY_CHANGE_SIZE | \
                    win32con.FILE_NOTIFY_CHANGE_LAST_WRITE | \
                    win32con.FILE_NOTIFY_CHANGE_SECURITY | \
                    0

      fflags = win32con.FILE_FLAG_BACKUP_SEMANTICS
      if self.asynch:
         fflags |= win32con.FILE_FLAG_OVERLAPPED
         self.loop = self.loop_asynchronous
      else:
         self.loop = self.loop_synchronous

      ## base directory object watched
      self.hdir = win32file.CreateFile(self.dir,
                                       ntsecuritycon.FILE_LIST_DIRECTORY,
                                       win32con.FILE_SHARE_READ | win32con.FILE_SHARE_WRITE | win32con.FILE_SHARE_DELETE,
                                       None,
                                       win32con.OPEN_EXISTING,
                                       fflags,
                                       None)

   def stop(self):
      self.stopped = True


   def loop_synchronous(self, callback):

      print "loop_synchronous"
      while not self.stopped:
         ##
         ## This will block until notification.
         ##
         results = win32file.ReadDirectoryChangesW(self.hdir,
                                                   8192,
                                                   self.recurse,
                                                   self.filter,
                                                   None,
                                                   None)
         print results
         r = [(DirWatcher._ACTIONS.get(x[0], "UNKNOWN"), x[1]) for x in results]
         if len(r) > 0:
            callback(r)



   def loop_asynchronous(self, callback):
      print "loop_asynchronous"

      buf = win32file.AllocateReadBuffer(8192)
      overlapped = pywintypes.OVERLAPPED()
      overlapped.hEvent = win32event.CreateEvent(None, 0, 0, None)

      while not self.stopped:

         win32file.ReadDirectoryChangesW(self.hdir,
                                         buf,
                                         self.recurse,
                                         self.filter,
                                         overlapped)

         ##
         ## This will block until notification OR timeout.
         ##
         rc = win32event.WaitForSingleObject(overlapped.hEvent, self.timeout)
         if rc == win32event.WAIT_OBJECT_0:
            ## got event: determine data length ..
            n = win32file.GetOverlappedResult(self.hdir, overlapped, True)
            if n:
               ## retrieve data
               results = win32file.FILE_NOTIFY_INFORMATION(buf, n)
               print results
               r = [(DirWatcher._ACTIONS.get(x[0], "UNKNOWN"), x[1]) for x in results]
               if len(r) > 0:
                  callback(r)
            else:
               # directory handled was closed
               self.stopped = True
         else:
            #print "timeout"
            pass


if __name__ == '__main__':
   dw = DirWatcher(asynch = False)
   def log(r):
      print r
   dw.loop(log)

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor
from twisted.internet.defer import Deferred, DeferredList

from autobahn.twisted.websocket import connectWS

from autobahn.wamp1.protocol import WampClientFactory, \
                                    WampClientProtocol


class KeyValueClientProtocol(WampClientProtocol):

   def done(self, *args):
      self.sendClose()
      reactor.stop()

   def show(self, key, value):
      print key, value

   def get(self, keys):
      defs = []
      for key in keys:
         d = self.call("keyvalue:get", key).addCallback(lambda value, key = key: self.show(key, value))
         defs.append(d)
      return DeferredList(defs)

   def onSessionOpen(self):
      self.prefix("keyvalue", "http://example.com/simple/keyvalue#")
      self.call("keyvalue:keys").addCallbacks(self.get).addCallback(self.done)


if __name__ == '__main__':

   log.startLogging(sys.stdout)
   factory = WampClientFactory("ws://localhost:8080/ws")
   factory.protocol = KeyValueClientProtocol
   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys, shelve

from twisted.python import log
from twisted.internet import reactor
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import listenWS
from autobahn.twisted.resource import WebSocketResource, \
                                      HTTPChannelHixie76Aware

from autobahn.wamp1.protocol import exportRpc, \
                                    WampServerFactory, \
                                    WampServerProtocol


class KeyValue:
   """
   Simple, persistent key-value store.
   """

   def __init__(self, filename):
      self.store = shelve.open(filename, flag = 'c', writeback = False)

   @exportRpc
   def set(self, key = None, value = None):
      if key is not None:
         k = str(key)
         if value is not None:
            self.store[k] = value
         else:
            if self.store.has_key(k):
               del self.store[k]
      else:
         self.store.clear()
      self.store.sync()

   @exportRpc
   def get(self, key = None):
      if key is None:
         return self.store.items()
      else:
         return self.store.get(str(key), None)

   @exportRpc
   def keys(self):
      return self.store.keys()



class KeyValueServerProtocol(WampServerProtocol):
   """
   Demonstrates creating a server with Autobahn WebSockets that provides
   a persistent key-value store which can we access via RPCs.
   """

   def onSessionOpen(self):
      ## register the key-value store, which resides on the factory within
      ## this connection
      self.registerForRpc(self.factory.keyvalue, "http://example.com/simple/keyvalue#")



class KeyValueServerFactory(WampServerFactory):

   protocol = KeyValueServerProtocol

   def __init__(self, url, debug = False, debugWamp = False):
      WampServerFactory.__init__(self, url, debug = debug, debugWamp = debugWamp)

      ## the key-value store resides on the factory object, since it is to
      ## be shared among all client connections
      self.keyvalue = KeyValue("keyvalue.dat")



if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   port = 8080

   factory = KeyValueServerFactory("ws://localhost:%d" % port, debug = debug, debugWamp = debug)
   factory.setProtocolOptions(allowHixie76 = True)
   ## need to start manually, see https://github.com/tavendo/AutobahnPython/issues/133
   factory.startFactory()

   ## Twisted Web resource for our WAMP factory
   resource = WebSocketResource(factory)

   ## we server static files under "/" ..
   root = File(".")

   ## and our WebSocket server under "/ws"
   root.putChild("ws", resource)

   ## both under one Twisted Web Site
   site = Site(root)
   site.protocol = HTTPChannelHixie76Aware # needed if Hixie76 is to be supported
   reactor.listenTCP(port, site)

   reactor.run()

########NEW FILE########
__FILENAME__ = serial2ws
###############################################################################
##
##  Copyright (C) 2012-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


import sys, time

if sys.platform == 'win32':
   ## on windows, we need to use the following reactor for serial support
   ## http://twistedmatrix.com/trac/ticket/3802
   ##
   from twisted.internet import win32eventreactor
   win32eventreactor.install()

from twisted.internet import reactor
print "Using Twisted reactor", reactor.__class__
print

from twisted.python import usage, log
from twisted.protocols.basic import LineReceiver
from twisted.internet.serialport import SerialPort
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import listenWS

from autobahn.wamp1.protocol import WampServerFactory, \
                                    WampServerProtocol, \
                                    exportRpc



class Serial2WsOptions(usage.Options):
   
   optFlags = [
      ['debugserial', 'd', 'Turn on Serial data logging.'],
      ['debugwamp', 't', 'Turn on WAMP traffic logging.'],
      ['debugws', 'r', 'Turn on WebSocket traffic logging.']
   ]

   optParameters = [
      ['baudrate', 'b', 9600, 'Serial baudrate'],
      ['port', 'p', 3, 'Serial port to use (e.g. 3 for a COM port on Windows, /dev/ttyATH0 for Arduino Yun, /dev/ttyACM0 for Serial-over-USB on RaspberryPi'],
      ['webport', 'w', 8080, 'Web port to use for embedded Web server'],
      ['wsurl', 's', "ws://localhost:9000", 'WebSocket port to use for embedded WebSocket server']
   ]


## MCU protocol
##
class McuProtocol(LineReceiver):

   ## need a reference to our WS-MCU gateway factory to dispatch PubSub events
   ##
   def __init__(self, wsMcuFactory):
      self.wsMcuFactory = wsMcuFactory


   ## this method is exported as RPC and can be called by connected clients
   ##
   @exportRpc("control-led")
   def controlLed(self, status):
      if status:
         payload = '1'
      else:
         payload = '0'
      if self.wsMcuFactory.debugSerial:
         print "Serial TX:", payload
      self.transport.write(payload)


   def connectionMade(self):
      log.msg('Serial port connected.')


   def lineReceived(self, line):
      if self.wsMcuFactory.debugSerial:
         print "Serial RX:", line
      try:
         ## parse data received from MCU
         ##
         data = [int(x) for x in line.split()]

         ## construct PubSub event from raw data
         ##
         evt = {'id': data[0], 'value': data[1]}

         ## publish event to all clients subscribed to topic
         ##
         self.wsMcuFactory.dispatch("http://example.com/mcu#analog-value", evt)

      except ValueError:
         log.err('Unable to parse value %s' % line)


## WS-MCU protocol
##
class WsMcuProtocol(WampServerProtocol):

   def onSessionOpen(self):
      ## register topic prefix under which we will publish MCU measurements
      ##
      self.registerForPubSub("http://example.com/mcu#", True)

      ## register methods for RPC
      ##
      self.registerForRpc(self.factory.mcuProtocol, "http://example.com/mcu-control#")


## WS-MCU factory
##
class WsMcuFactory(WampServerFactory):

   protocol = WsMcuProtocol

   def __init__(self, url, debugSerial = False, debugWs = False, debugWamp = False):
      WampServerFactory.__init__(self, url, debug = debugWs, debugWamp = debugWamp)
      self.debugSerial = debugSerial
      self.mcuProtocol = McuProtocol(self)


if __name__ == '__main__':

   ## parse options
   ##
   o = Serial2WsOptions()
   try:
      o.parseOptions()
   except usage.UsageError, errortext:
      print '%s %s' % (sys.argv[0], errortext)
      print 'Try %s --help for usage details' % sys.argv[0]
      sys.exit(1)

   debugWs = bool(o.opts['debugws'])
   debugWamp = bool(o.opts['debugwamp'])
   debugSerial = bool(o.opts['debugserial'])
   baudrate = int(o.opts['baudrate'])
   port = o.opts['port']
   webport = int(o.opts['webport'])
   wsurl = o.opts['wsurl']

   ## start Twisted log system
   ##
   log.startLogging(sys.stdout)

   ## create Serial2Ws gateway factory
   ##
   wsMcuFactory = WsMcuFactory(wsurl, debugSerial = debugSerial, debugWs = debugWs, debugWamp = debugWamp)
   listenWS(wsMcuFactory)

   ## create serial port and serial port protocol
   ##
   log.msg('About to open serial port %s [%d baud] ..' % (port, baudrate))
   serialPort = SerialPort(wsMcuFactory.mcuProtocol, port, reactor, baudrate = baudrate)

   ## create embedded web server for static files
   ##
   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(webport, web)

   ## start Twisted reactor ..
   ##
   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2012-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys
from pprint import pprint

from twisted.python import log
from twisted.internet import reactor

from autobahn.twisted.websocket import connectWS

from autobahn.wamp1.protocol import WampClientFactory, \
                                    WampCraClientProtocol



class MyClientProtocol(WampCraClientProtocol):
   """
   Authenticated WAMP client using WAMP-Challenge-Response-Authentication ("WAMP-CRA").
   """

   def onSessionOpen(self):
      ## "authenticate" as anonymous
      ##
      #d = self.authenticate()

      ## authenticate as "foobar" with password "secret"
      ##
      d = self.authenticate(authKey = "foobar",
                            authExtra = None,
                            authSecret = "secret")

      d.addCallbacks(self.onAuthSuccess, self.onAuthError)


   def onClose(self, wasClean, code, reason):
      reactor.stop()


   def onAuthSuccess(self, permissions):
      print "Authentication Success!", permissions
      self.publish("http://example.com/topics/mytopic1", "Hello, world!")
      d = self.call("http://example.com/procedures/hello", "Foobar")
      d.addBoth(pprint)
      d.addBoth(self.sendClose)


   def onAuthError(self, e):
      uri, desc, details = e.value.args
      print "Authentication Error!", uri, desc, details



if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   log.startLogging(sys.stdout)
   factory = WampClientFactory("ws://localhost:9000", debugWamp = debug)
   factory.protocol = MyClientProtocol
   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2012-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor, defer
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import listenWS

from autobahn.wamp1.protocol import exportRpc, \
                                    WampCraProtocol, \
                                    WampCraServerProtocol, \
                                    WampServerFactory



class MyServerProtocol(WampCraServerProtocol):
   """
   Authenticating WAMP server using WAMP-Challenge-Response-Authentication ("WAMP-CRA").
   """
   ## our pseudo user/permissions database

   ## auth extra sent by server
   ##
   if True:
      ## when using salted WAMP-CRA, we send salt info ..
      AUTHEXTRA = {'salt': "RANDOM SALT", 'keylen': 32, 'iterations': 1000}
   else:
      AUTHEXTRA = None

   ## secrets by authkey
   ##
   SECRETS = {'foobar': WampCraProtocol.deriveKey('secret', AUTHEXTRA)}

   print "Auth Extra/Secrets"
   print AUTHEXTRA
   print SECRETS

   ## permissions by authkey
   ##
   PERMISSIONS = {'foobar': {'pubsub': [{'uri': 'http://example.com/topics/',
                                         'prefix': True,
                                         'pub': True,
                                         'sub': True}],
                             'rpc': [{'uri': 'http://example.com/procedures/hello',
                                      'call': True}]},
                  None: {'pubsub': [{'uri': 'http://example.com/topics/mytopic1',
                                     'prefix': False,
                                     'pub': False,
                                     'sub': True}],
                         'rpc': []}}

   def onSessionOpen(self):

      ## override global client auth options
      self.clientAuthTimeout = 0
      self.clientAuthAllowAnonymous = True

      ## call base class method
      WampCraServerProtocol.onSessionOpen(self)


   def getAuthPermissions(self, authKey, authExtra):
      ## return permissions which will be granted for the auth key
      ## when the authentication succeeds
      return {'permissions': self.PERMISSIONS.get(authKey, None),
              'authextra': self.AUTHEXTRA}


   def getAuthSecret(self, authKey):
      ## return the auth secret for the given auth key or None when the auth key
      ## does not exist
      secret = self.SECRETS.get(authKey, None)
      if False:
         # we may return the secret as a string ..
         return secret
      else:
         # .. or return a Deferred that when fires provides the secret as a string.
         # This can be used i.e. when you retrieve the secret from a (real) database.
         d = defer.Deferred()
         d.callback(secret)
         return d


   def onAuthenticated(self, authKey, perms):
      ## fired when authentication succeeds

      ## register PubSub topics from the auth permissions
      self.registerForPubSubFromPermissions(perms['permissions'])

      ## register RPC endpoints (for now do that manually, keep in sync with perms)
      if authKey is not None:
         self.registerForRpc(self,
                             'http://example.com/procedures/',
                             [MyServerProtocol.hello])


   @exportRpc("hello")
   def hello(self, name):
      return "Hello back %s!" % name



if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WampServerFactory("ws://localhost:9000", debugWamp = debug)
   factory.protocol = MyServerProtocol
   listenWS(factory)

   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor
from twisted.internet.defer import Deferred, DeferredList

from autobahn.twisted.websocket import connectWS

from autobahn.wamp1.protocol import WampClientFactory, \
                                    WampClientProtocol



class MyClientProtocol(WampClientProtocol):
   """
   Demonstrates simple Publish & Subscribe (PubSub) with Autobahn WebSockets.
   """

   def show(self, result):
      print "SUCCESS:", result

   def logerror(self, e):
      erroruri, errodesc = e.value.args
      print "ERROR: %s ('%s')" % (erroruri, errodesc)

   def done(self, *args):
      self.sendClose()

   def onFoobar(self, topicUri, event):
      print "FOOBAR", topicUri, event

   def onSessionOpen(self):

      self.prefix("event", "http://example.com/event/")

      self.subscribe("event:foobar1", self.onFoobar)
      self.subscribe("event:foobar2", self.onFoobar)

      self.publish("event:foobar1", {"count": 666})
      self.publish("event:foobar2", {"count": 67})
      self.publish("event:foobar-extended", {"name": "foo", "value": "bar", "num": 42})
      self.publish("event:foobar-limited", {"name": "foo", "value": "bar", "num": 23})

      #self.done()


if __name__ == '__main__':

   log.startLogging(sys.stdout)
   factory = WampClientFactory("ws://localhost:9000")
   factory.protocol = MyClientProtocol
   connectWS(factory)
   reactor.run()
########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys, math

from twisted.python import log
from twisted.internet import reactor, defer
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import listenWS

from autobahn.wamp1.protocol import exportSub, \
                                    exportPub, \
                                    WampServerFactory, \
                                    WampServerProtocol


class MyTopicService:

   def __init__(self, allowedTopicIds):
      self.allowedTopicIds = allowedTopicIds
      self.serial = 0


   @exportSub("foobar", True)
   def subscribe(self, topicUriPrefix, topicUriSuffix):
      """
      Custom topic subscription handler.
      """
      print "client wants to subscribe to %s%s" % (topicUriPrefix, topicUriSuffix)
      try:
         i = int(topicUriSuffix)
         if i in self.allowedTopicIds:
            print "Subscribing client to topic Foobar %d" % i
            return True
         else:
            print "Client not allowed to subscribe to topic Foobar %d" % i
            return False
      except:
         print "illegal topic - skipped subscription"
         return False


   @exportPub("foobar", True)
   def publish(self, topicUriPrefix, topicUriSuffix, event):
      """
      Custom topic publication handler.
      """
      print "client wants to publish to %s%s" % (topicUriPrefix, topicUriSuffix)
      try:
         i = int(topicUriSuffix)
         if type(event) == dict and event.has_key("count"):
            if event["count"] > 0:
               self.serial += 1
               event["serial"] = self.serial
               print "ok, published enriched event"
               return event
            else:
               print "event count attribute is negative"
               return None
         else:
            print "event is not dict or misses count attribute"
            return None
      except:
         print "illegal topic - skipped publication of event"
         return None


class MyServerProtocol(WampServerProtocol):

   def onSessionOpen(self):

      ## register a single, fixed URI as PubSub topic
      self.registerForPubSub("http://example.com/event/simple")

      ## register a URI and all URIs having the string as prefix as PubSub topic
      #self.registerForPubSub("http://example.com/event/simple", True)

      ## register any URI (string) as topic
      #self.registerForPubSub("", True)

      ## register a topic handler to control topic subscriptions/publications
      self.topicservice = MyTopicService([1, 3, 7])
      self.registerHandlerForPubSub(self.topicservice, "http://example.com/event/")


if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WampServerFactory("ws://localhost:9000", debugWamp = True)
   factory.protocol = MyServerProtocol
   factory.setProtocolOptions(allowHixie76 = True)
   listenWS(factory)

   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import time, sys, argparse

from autobahn.twisted.choosereactor import install_reactor
install_reactor()

from twisted.python import log
from twisted.internet import reactor
from twisted.internet.defer import Deferred, DeferredList

import autobahn

from autobahn.twisted.websocket import connectWS

from autobahn.wamp1.protocol import WampClientFactory, \
                                    WampClientProtocol, \
                                    WampCraClientProtocol



class LoadLatencySubscriberProtocol(WampCraClientProtocol):

   def onSessionOpen(self):

      if self.factory.config.debug:
         print "Load/Latency Subscriber Client connected to %s [skiputf8validate = %s, skipmasking = %s]" % (self.factory.config.wsuri, self.factory.config.skiputf8validate, self.factory.config.skipmasking)

      if self.factory.config.secure:
         ## do WAMP-CRA authentication as anonymous
         d = self.authenticate()
         d.addCallbacks(self.onAuthSuccess, self.onAuthError)
      else:
         self.onReady()


   def onAuthSuccess(self, permissions):
      #print "Authenticated.", permissions
      #print "Authenticated."
      self.onReady()


   def onAuthError(self, e):
      uri, desc, details = e.value.args
      print "Authentication Error!", uri, desc, details


   def onReady(self):
      def onEvent(topic, event):
         rtt = time.clock() - event['sent']
         self.factory.receivedRtts.append(rtt)
         self.factory.receivedCnt += 1

      self.subscribe(self.factory.config.topic, onEvent)

      self.factory._ready.callback(None)



class LoadLatencySubscriberFactory(WampClientFactory):

   protocol = LoadLatencySubscriberProtocol

   def __init__(self, config, d):

      WampClientFactory.__init__(self, config.wsuri, debugWamp = config.debug)

      self._ready = d

      self.config = config
      self.receivedCnt = 0
      self.receivedRtts = []

      self.setProtocolOptions(failByDrop = False)

      if config.skiputf8validate:
         self.setProtocolOptions(utf8validateIncoming = False)

      if config.skipmasking:
         self.setProtocolOptions(maskClientFrames = False)


   def clientConnectionFailed(self, connector, reason):
      pass
      #print reason


   def clientConnectionLost(self, connector, reason):
      pass
      #print reason



class LoadLatencyPublisherProtocol(WampCraClientProtocol):

   def onSessionOpen(self):

      if self.factory.config.debug:
         print "Load/Latency Publisher Client connected to %s [skiputf8validate = %s, skipmasking = %s]" % (self.factory.config.wsuri, self.factory.config.skiputf8validate, self.factory.config.skipmasking)

      if self.factory.config.secure:
         ## do WAMP-CRA authentication as anonymous
         d = self.authenticate()
         d.addCallbacks(self.onAuthSuccess, self.onAuthError)
      else:
         self.onReady()


   def onAuthSuccess(self, permissions):
      print "Authenticated."
      self.onReady()


   def onAuthError(self, e):
      uri, desc, details = e.value.args
      print "Authentication Error!", uri, desc, details


   def onReady(self):

      def sendEvent():

         self.factory.batchid += 1
         msg = {'msg': '*' * self.factory.config.payload}
         for i in xrange(self.factory.config.batch):
            self.factory.id += 1
            self.factory.publishedCnt += 1
            #msg['id'] = self.factory.id
            #msg['batchid'] = self.factory.batchid
            msg['sent'] = time.clock()
            self.publish(self.factory.config.topic, msg)

         reactor.callLater(1. / float(self.factory.config.rate), sendEvent)

      sendEvent()



class LoadLatencyPublisherFactory(WampClientFactory):

   protocol = LoadLatencyPublisherProtocol

   def __init__(self, config):

      WampClientFactory.__init__(self, config.wsuri, debugWamp = config.debug)

      self.config = config
      self.id = 0
      self.batchid = 0
      self.publishedCnt = 0

      self.setProtocolOptions(failByDrop = False)

      if config.skiputf8validate:
         self.setProtocolOptions(utf8validateIncoming = False)

      if config.skipmasking:
         self.setProtocolOptions(maskClientFrames = False)



class LoadLatencyTest:

   def __init__(self, config):
      self.config = config
      self.linesPrinted = 0
      self.publishedCntTotal = 0
      self.receivedCntTotal = 0

   def run(self):
      self._factories = []
      dl = []
      t0 = 0
      for i in xrange(self.config.clients):
         d = Deferred()
         dl.append(d)

         factory = LoadLatencySubscriberFactory(self.config, d)
         self._factories.append(factory)

         reactor.callLater(t0, connectWS, factory)
         t0 += 1. / float(self.config.uprate)

      d2 = DeferredList(dl)

      def start_publishing(res):

         print "ok, %d clients all connected, start publishing .." % len(res)
         #print res

         publisherFactory = LoadLatencyPublisherFactory(self.config)
         connectWS(publisherFactory)

         def printstats():
            if self.linesPrinted % 20 == 0:
               print
               print "Parameters: %d clients, %d uprate, %d payload, %d batchsize, %d rate" % (self.config.clients, self.config.uprate, self.config.payload, self.config.batch, self.config.rate)
               print "Messages: sent_last, recv_last, sent_total, recv_total, avg. rtt (ms)"
               print
            self.linesPrinted += 1

            publishedCnt = publisherFactory.publishedCnt
            receivedCnt = sum([x.receivedCnt for x in self._factories])
            receivedSumRtts = 1000. * sum([sum(x.receivedRtts) for x in self._factories])

            if receivedCnt:
               rttAvg = float(receivedSumRtts) / float(receivedCnt)
            else:
               rttAvg = 0

            publisherFactory.publishedCnt = 0
            for f in self._factories:
               f.receivedCnt = 0
               f.receivedRtts = []

            self.publishedCntTotal += publishedCnt
            self.receivedCntTotal += receivedCnt

            print "%d, %d, %d, %d, %f" % (publishedCnt, receivedCnt, self.publishedCntTotal, self.receivedCntTotal, rttAvg)

            reactor.callLater(1, printstats)

         printstats()

      d2.addCallback(start_publishing)



if __name__ == '__main__':

   parser = argparse.ArgumentParser(prog = "llclient",
                                    description = "Load/Latency Test Client")

   parser.add_argument("-d",
                       "--debug",
                       help = "Enable debug output.",
                       action = "store_true")

   parser.add_argument("--skiputf8validate",
                       help = "Skip UTF8 validation of incoming messages.",
                       action = "store_true")

   parser.add_argument("--skipmasking",
                       help = "Skip masking of sent frames.",
                       action = "store_true")

   parser.add_argument("-c",
                       "--clients",
                       type = int,
                       default = 10,
                       help = "Number of WAMP clients to connect.")

   parser.add_argument("-p",
                       "--payload",
                       type = int,
                       default = 32,
                       help = "Length of string field payload in bytes of each published message.")

   parser.add_argument("-b",
                       "--batch",
                       type = int,
                       default = 1,
                       help = "Number of messages published per batch.")

   parser.add_argument("-r",
                       "--rate",
                       type = float,
                       default = 25.,
                       help = "Number of batches per second.")

   parser.add_argument("-u",
                       "--uprate",
                       type = int,
                       default = 15,
                       help = "Connect rate in new connections per seconds.")

   parser.add_argument("-w",
                       "--wsuri",
                       type = str,
                       default = "ws://127.0.0.1:9000",
                       help = "URI of WAMP server, e.g. ws://127.0.0.1:9000.")

   parser.add_argument("-t",
                       "--topic",
                       type = str,
                       default = "http://example.com/simple",
                       help = "Topic URI to use, e.g. http://example.com/simple")

   parser.add_argument("-s",
                       "--secure",
                       help = "Enable WAMP-CRA authentication (as anonymous) - This is for testing with Crossbar.io",
                       action = "store_true")

   config = parser.parse_args()

   if config.debug:
      log.startLogging(sys.stdout)

   test = LoadLatencyTest(config)
   test.run()

   print reactor.__class__
   print autobahn.utf8validator.Utf8Validator
   print autobahn.xormasker.XorMaskerNull
   print autobahn.wamp1.protocol.json_lib
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys, argparse

from autobahn.twisted.choosereactor import install_reactor
install_reactor()

from twisted.python import log
from twisted.internet import reactor

import autobahn
from autobahn.twisted.websocket import listenWS

from autobahn.wamp1.protocol import WampServerFactory, \
                                    WampServerProtocol, \
                                    WampCraServerProtocol



class LoadLatencyBrokerProtocol(WampCraServerProtocol):

   def onSessionOpen(self):

      if self.factory.config.secure:
         ## require WAMP-CRA authentication

         self.clientAuthTimeout = 0
         self.clientAuthAllowAnonymous = True
         WampCraServerProtocol.onSessionOpen(self)

      else:
         WampServerProtocol.onSessionOpen(self)
         self.onReady()


   def getAuthPermissions(self, authKey, authExtra):
      if authKey is None:
         return {'permissions': {'pubsub': [{'uri': self.factory.config.topic,
                                             'prefix': True,
                                             'pub': True,
                                             'sub': True}],
                                 'rpc': []}}
      else:
         return {'permissions': None}


   def onAuthenticated(self, authKey, perms):
      self.onReady()


   def onReady(self):
      self.registerForPubSub(self.factory.config.topic, True)
      #print "Load/Latency Broker client connected and brokering topic %s registered" % self.factory.config.topic
      self.factory.connectedClients.add(self)


   def onClose(self, wasClean, code, reason):
      try:
         self.factory.connectedClients.remove(self)
      except:
         pass
      #print "Load/Latency Broker client lost"



class LoadLatencyBrokerFactory(WampServerFactory):

   protocol = LoadLatencyBrokerProtocol

   def __init__(self, config):
      self.config = config
      WampServerFactory.__init__(self, config.wsuri, debugWamp = config.debug)

      self.setProtocolOptions(failByDrop = False)

      if config.skiputf8validate:
         self.setProtocolOptions(utf8validateIncoming = False)

      if config.allowunmasked:
         self.setProtocolOptions(requireMaskedClientFrames = False)

      self.connectedClients = set()

      print "Load/Latency Broker listening on %s [skiputf8validate = %s, allowunmasked = %s]" % (config.wsuri, config.skiputf8validate, config.allowunmasked)

      def printstats():
         print "%d clients connected" % len(self.connectedClients)
         reactor.callLater(1, printstats)

      printstats()



if __name__ == '__main__':

   parser = argparse.ArgumentParser(prog = "llserver",
                                    description = "Load/Latency Test Broker")

   parser.add_argument("-d",
                       "--debug",
                       help = "Enable debug output.",
                       action = "store_true")

   parser.add_argument("--skiputf8validate",
                       help = "Skip UTF8 validation of incoming messages.",
                       action = "store_true")

   parser.add_argument("--allowunmasked",
                       help = "Allow unmasked client frames.",
                       action = "store_true")

   parser.add_argument("-w",
                       "--wsuri",
                       type = str,
                       default = "ws://localhost:9000",
                       help = "Listening URI of WAMP server, e.g. ws://localhost:9000.")

   parser.add_argument("-t",
                       "--topic",
                       type = str,
                       default = "http://example.com/simple",
                       help = "Topic URI to use, e.g. http://example.com/simple")

   parser.add_argument("-s",
                       "--secure",
                       help = "Enable WAMP-CRA authentication (as anonymous) - This is for testing with Crossbar.io",
                       action = "store_true")

   config = parser.parse_args()

   if config.debug:
      log.startLogging(sys.stdout)

   factory = LoadLatencyBrokerFactory(config)
   listenWS(factory, backlog = 4096)

   print reactor.__class__
   print autobahn.utf8validator.Utf8Validator
   print autobahn.xormasker.XorMaskerNull
   print autobahn.wamp1.protocol.json_lib
   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor

from autobahn.twisted.websocket import connectWS

from autobahn.wamp1.protocol import WampClientFactory, \
                                    WampClientProtocol



class MyPubSubClientProtocol(WampClientProtocol):
   """
   Protocol class for our simple demo WAMP client.
   """

   def onSessionOpen(self):

      print "Connected!"

      def onMyEvent1(topic, event):
         print "Received event", topic, event

      self.subscribe("http://example.com/myEvent1", onMyEvent1)

      self.counter = 0

      def sendMyEvent1():
         self.counter += 1
         self.publish("http://example.com/myEvent1",
            {
               "msg": "Hello from Python!",
               "counter": self.counter
            }
         )
         reactor.callLater(2, sendMyEvent1)

      sendMyEvent1()


   def onClose(self, wasClean, code, reason):
      print "Connection closed", reason
      reactor.stop()



if __name__ == '__main__':

   log.startLogging(sys.stdout)

   if len(sys.argv) > 1:
      wsuri = sys.argv[1]
   else:
      wsuri = "ws://localhost:9000"

   print "Connecting to", wsuri

   ## our WAMP/WebSocket client
   ##
   factory = WampClientFactory(wsuri, debugWamp = False)
   factory.protocol = MyPubSubClientProtocol
   connectWS(factory)

   ## run the Twisted network reactor
   ##
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import listenWS

from autobahn.wamp1.protocol import WampServerFactory, \
                                    WampServerProtocol



class MyPubSubServerProtocol(WampServerProtocol):
   """
   Protocol class for our simple demo WAMP server.
   """

   def onSessionOpen(self):

      ## When the WAMP session to a client has been established,
      ## register a single fixed URI as PubSub topic that our
      ## message broker will handle
      ##
      self.registerForPubSub("http://example.com/myEvent1")



if __name__ == '__main__':

   log.startLogging(sys.stdout)

   ## our WAMP/WebSocket server
   ##
   wampFactory = WampServerFactory("ws://localhost:9000", debugWamp = True)
   wampFactory.protocol = MyPubSubServerProtocol
   listenWS(wampFactory)

   ## our Web server (for static Web content)
   ##
   webFactory = Site(File("."))
   reactor.listenTCP(8080, webFactory)

   ## run the Twisted network reactor
   ##
   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor

from autobahn.twisted.websocket import connectWS

from autobahn.wamp1.protocol import WampClientFactory, \
                                    WampClientProtocol



class MyClientProtocol(WampClientProtocol):
   """
   Demonstrates simple Publish & Subscribe (PubSub) with Autobahn WebSockets.
   """

   def printEvent(self, topicUri, event):
      print "printEvent", topicUri, event

   def sendSimpleEvent(self):
      self.publish("http://example.com/simple", "Hello!")
#      self.publish("http://example.com/simple", "Hello!", excludeMe = False, eligible = [self.session_id])
      reactor.callLater(2, self.sendSimpleEvent)

   def onEvent1(self, topicUri, event):
      self.counter += 1
      self.publish("event:myevent2", {"trigger": event, "counter": self.counter})

   def onSessionOpen(self):

      self.counter = 0
      self.subscribe("http://example.com/simple", self.printEvent)
      self.sendSimpleEvent()

      self.prefix("event", "http://example.com/event#")
      self.subscribe("event:myevent1", self.onEvent1)
      self.subscribe("event:myevent2", self.printEvent)


if __name__ == '__main__':

   log.startLogging(sys.stdout)
   factory = WampClientFactory("ws://localhost:9000")
   factory.protocol = MyClientProtocol
   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import listenWS

from autobahn.wamp1.protocol import WampServerFactory, \
                                    WampServerProtocol


class MyServerProtocol(WampServerProtocol):

   def onSessionOpen(self):

      ## register a single, fixed URI as PubSub topic
      self.registerForPubSub("http://example.com/simple")

      ## register a URI and all URIs having the string as prefix as PubSub topic
      self.registerForPubSub("http://example.com/event#", True)

      ## register any URI (string) as topic
      #self.registerForPubSub("", True)


if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WampServerFactory("ws://localhost:9000", debugWamp = True)
   factory.protocol = MyServerProtocol
   factory.setProtocolOptions(allowHixie76 = True)
   listenWS(factory)

   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor
from twisted.internet.defer import Deferred, \
                                   DeferredList, \
                                   gatherResults, \
                                   returnValue, \
                                   inlineCallbacks

from autobahn.twisted.websocket import connectWS

from autobahn.wamp1.protocol import WampClientFactory, \
                                    WampClientProtocol


class MyClientProtocol(WampClientProtocol):

   def println(self, msg):
      print msg

   @inlineCallbacks
   def onSessionOpen(self):
      self.prefix("calc", "http://example.com/simple/calc#")

      yield self.test1()

      yield self.test2(1.123)
      yield self.test3(1.123)

      yield self.test2(0)
      yield self.test3(0)

      yield self.test4(0)

      self.sendClose()
      reactor.stop()

   @inlineCallbacks
   def test1(self):
      r = yield self.call("calc:println", "\nStarting test 1 ..\n")
      s = 0
      for i in xrange(10):
         s += yield self.call("calc:sum", range(10))
      print s

   @inlineCallbacks
   def test2(self, delay):
      r = yield self.call("calc:println", "\nStarting test 2 with delay = %s..\n" % delay)
      s = 0
      for i in xrange(10):
         s += yield self.call("calc:asum", range(10), delay)
      print s

   @inlineCallbacks
   def test3(self, delay, n = 10):
      r = yield self.call("calc:println", "\nStarting test 3 with delay = %s ..\n" % delay)
      d = []
      for i in xrange(n):
         d.append(self.call("calc:wsum", range(10), delay))
      r = yield gatherResults(d).addCallback(lambda l: self.println(sum(l)))

   @inlineCallbacks
   def test4(self, delay, n = 10):
      r = yield self.call("calc:println", "\nStarting test 4 with delay = %s ..\n" % delay)
      d = []
      for i in xrange(n):
         d.append(self.call("calc:sum", range(10)))
         d.append(self.call("calc:wsum", range(10), delay))
      r = yield gatherResults(d).addCallback(lambda l: self.println(sum(l)))

if __name__ == '__main__':
   log.startLogging(sys.stdout)
   factory = WampClientFactory("ws://localhost:9000")
   factory.protocol = MyClientProtocol
   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys, math, time

from twisted.python import log
from twisted.internet import reactor, defer, threads


from autobahn.twisted.websocket import listenWS

from autobahn.wamp1.protocol import exportRpc, \
                                    WampServerFactory, \
                                    WampServerProtocol


RPC_SUCCESS_TIMINGS = [('RECV', 'onMessageBegin', 'onBeforeCall'),
                       ('CALL', 'onBeforeCall', 'onAfterCallSuccess'),
                       ('SEND', 'onAfterCallSuccess', 'onAfterSendCallSuccess')]

RPC_ERROR_TIMINGS = [('RECV', 'onMessageBegin', 'onBeforeCall'),
                     ('CALL', 'onBeforeCall', 'onAfterCallError'),
                     ('SEND', 'onAfterCallError', 'onAfterSendCallError')]


class SimpleServerProtocol(WampServerProtocol):
   """

   onMessageBegin
   onMessage
   onBeforeCall
   onAfterCallSuccess / onAfterCallError
   sendMessage
   onAfterSendCallSuccess / onAfterSendCallError
   """

   def onSessionOpen(self):
      print "\nNew session:", self.session_id
      self.registerForRpc(self, "http://example.com/simple/calc#")

   def onClose(self, wasClean, code, reason):
      print "\nSession closed."

   def printTimings(self, callid, timings, tdef):
      sys.stdout.write(" %s | " % callid)
      for t in tdef:
         sys.stdout.write(t[0])
         sys.stdout.write(": ")
         sys.stdout.write(timings[2].diff(t[1], t[2]))
         sys.stdout.write(" | ")
      sys.stdout.write("%s" % timings[0])
      print

   def onAfterSendCallSuccess(self, _, callid):
      self.printTimings(callid, self.trackedRpcs[callid], RPC_SUCCESS_TIMINGS)

   def onAfterSendCallError(self, _, callid):
      self.printTimings(callid, self.trackedRpcs[callid], RPC_ERROR_TIMINGS)

   @exportRpc
   def println(self, msg):
      print msg

   @exportRpc
   def sum(self, list):
      return reduce(lambda x, y: x + y, list)

   @exportRpc("tsum")
   def threadSum(self, list):
      return threads.deferToThread(self.sum, list)

   @exportRpc("asum")
   def asyncSum(self, list, delay):
      ## Simulate a slow function.
      d = defer.Deferred()
      reactor.callLater(delay, d.callback, self.sum(list))
      return d

   @exportRpc("wsum")
   def workerSum(self, list, delay):
      ## Execute a slow function on thread from background thread pool.
      def wsum(list):
         if delay > 0:
            time.sleep(delay)
         return self.sum(list)
      return threads.deferToThread(wsum, list)


if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WampServerFactory("ws://localhost:9000", debugWamp = debug)
   factory.protocol = SimpleServerProtocol
   factory.setProtocolOptions(allowHixie76 = True)
   factory.trackTimings = True
   listenWS(factory)

   poolSize = 5
   print "Thread pool size:", poolSize

   reactor.suggestThreadPoolSize(poolSize)
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor, defer
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import listenWS
from autobahn.wamp1.protocol import exportRpc, \
                                    WampServerFactory, \
                                    WampServerProtocol


def multiply(x, y):
   """
   A free standing procedure that we remote.
   """
   return x * y


class RpcServer1Protocol(WampServerProtocol):
   """
   A minimalistic RPC server.
   """

   def onSessionOpen(self):
      ## When the WAMP session has been established, register callables
      ## to be remoted (made available for RPC)
      ##
      self.registerProcedureForRpc("http://example.com/simple/calc#mul", multiply)
      self.registerMethodForRpc("http://example.com/simple/calc#sub", self, RpcServer1Protocol.doSub)
      self.registerForRpc(self, "http://example.com/simple/calc#")

   @exportRpc("add")
   def doAdd(self, x, y):
      """
      A method that we remote by using the exportRpc decorator.
      """
      return x + y

   def doSub(self, x, y):
      """
      A method that we remote explicitly.
      """
      return x - y



if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WampServerFactory("ws://localhost:9000", debugWamp = debug)
   factory.protocol = RpcServer1Protocol
   factory.setProtocolOptions(allowHixie76 = True)
   listenWS(factory)

   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor
from twisted.internet.defer import Deferred, DeferredList

from autobahn.twisted.websocket import connectWS

from autobahn.wamp1.protocol import WampClientFactory, \
                                    WampClientProtocol



class SimpleClientProtocol(WampClientProtocol):
   """
   Demonstrates simple Remote Procedure Calls (RPC) with
   AutobahnPython and Twisted Deferreds.
   """

   def show(self, result):
      print "SUCCESS:", result

   def logerror(self, e):
      erroruri, errodesc, errordetails = e.value.args
      print "ERROR: %s ('%s') - %s" % (erroruri, errodesc, errordetails)

   def done(self, *args):
      self.sendClose()
      reactor.stop()

   def onSessionOpen(self):

      self.prefix("calc", "http://example.com/simple/calc#")

      d1 = self.call("calc:square", 23).addCallback(self.show)

      d2 = self.call("calc:add", 23, 7).addCallback(self.show)

      d3 = self.call("calc:sum", [1, 2, 3, 4, 5]).addCallback(self.show)

      d4 = self.call("calc:square", 23).addCallback(lambda res: \
                         self.call("calc:sqrt", res)).addCallback(self.show)

      d5 = self.call("calc:sqrt", -1).addCallbacks(self.show,
                                                   self.logerror)

      d6 = self.call("calc:square", 1001).addCallbacks(self.show,
                                                       self.logerror)

      d7 = self.call("calc:asum", [1, 2, 3]).addCallback(self.show)

      d8 = self.call("calc:sum", [4, 5, 6]).addCallback(self.show)

      d9 = self.call("calc:pickySum", range(0, 30)).addCallbacks(self.show,
                                                                 self.logerror)

      ## we want to shutdown the client exactly when all deferreds are finished
      DeferredList([d1, d2, d3, d4, d5, d6, d7, d8, d9]).addCallback(self.done)


if __name__ == '__main__':

   log.startLogging(sys.stdout)
   factory = WampClientFactory("ws://localhost:9000", debugWamp = True)
   factory.protocol = SimpleClientProtocol
   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = client_icb
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor
from twisted.internet.defer import Deferred, returnValue, inlineCallbacks

from autobahn.twisted.websocket import connectWS

from autobahn.wamp1.protocol import WampClientFactory, \
                                    WampClientProtocol



class SimpleClientProtocol(WampClientProtocol):
   """
   Demonstrates simple Remote Procedure Calls (RPC) with
   Autobahn WebSockets and Twisted Inline Callbacks.
   """

   def show(self, result):
      print "SUCCESS:", result


   def done(self, *args):
      self.sendClose()
      reactor.stop()


   def onSessionOpen(self):
      self.prefix("calc", "http://example.com/simple/calc#")
      self.myfun(42).addCallback(self.show).addCallback(self.done)


   @inlineCallbacks
   def myfun(self, val):

      print "myfun:1", val

      r = yield self.mysubfun(val)
      print "myfun:2", r

      returnValue(r * 10)


   @inlineCallbacks
   def mysubfun(self, val):

      print "mysubfun:1", val

      r1 = yield self.call("calc:asum", [1, 2, 3, val])
      print "mysubfun:2", r1

      r2 = yield self.call("calc:square", r1)
      print "mysubfun:3", r2

      returnValue(r2 + 1)


if __name__ == '__main__':

   log.startLogging(sys.stdout)
   factory = WampClientFactory("ws://localhost:9000")
   factory.protocol = SimpleClientProtocol
   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys, math

from twisted.python import log
from twisted.internet import reactor, defer
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import listenWS
from autobahn.wamp1.protocol import exportRpc, \
                                    WampServerFactory, \
                                    WampServerProtocol


class Calc:
   """
   A simple calc service we will export for Remote Procedure Calls (RPC).

   All you need to do is use the @exportRpc decorator on methods
   you want to provide for RPC and register a class instance in the
   server factory (see below).

   The method will be exported under the Python method name, or
   under the (optional) name you can provide as an argument to the
   decorator (see asyncSum()).
   """

   @exportRpc
   def add(self, x, y):
      return x + y

   @exportRpc
   def sub(self, x, y):
      return x - y

   @exportRpc
   def square(self, x):
      MAX = 1000
      if x > MAX:
         ## raise a custom exception
         raise Exception("http://example.com/error#number_too_big",
                         "%d too big for me, max is %d" % (x, MAX),
                         MAX)
      return x * x

   @exportRpc
   def sum(self, list):
      return reduce(lambda x, y: x + y, list)

   @exportRpc
   def pickySum(self, list):
      errs = []
      for i in list:
         if i % 3 == 0:
            errs.append(i)
      if len(errs) > 0:
         raise Exception("http://example.com/error#invalid_numbers",
                         "one or more numbers are multiples of 3",
                         errs)
      return reduce(lambda x, y: x + y, list)

   @exportRpc
   def sqrt(self, x):
      return math.sqrt(x)

   @exportRpc("asum")
   def asyncSum(self, list):
      ## Simulate a slow function.
      d = defer.Deferred()
      reactor.callLater(3, d.callback, self.sum(list))
      return d


class SimpleServerProtocol(WampServerProtocol):
   """
   Demonstrates creating a simple server with Autobahn WebSockets that
   responds to RPC calls.
   """

   def onSessionOpen(self):

      # when connection is established, we create our
      # service instances ...
      self.calc = Calc()

      # .. and register them for RPC. that's it.
      self.registerForRpc(self.calc, "http://example.com/simple/calc#")


if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WampServerFactory("ws://localhost:9000", debugWamp = debug)
   factory.protocol = SimpleServerProtocol
   factory.setProtocolOptions(allowHixie76 = True)
   listenWS(factory)

   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys, time

from twisted.python import log
from twisted.internet import reactor

from autobahn.twisted.websocket import connectWS

from autobahn.wamp1.protocol import exportRpc, \
                                    WampClientFactory, \
                                    WampClientProtocol


class MyClientProtocol(WampClientProtocol):

   @exportRpc("getTime")
   def getTime(self):
      return time.strftime("%H:%M:%S", time.localtime())

   def onSessionOpen(self):
      self.registerForRpc(self, "http://example.com/client#")



if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WampClientFactory("ws://localhost:9000", debugWamp = debug)
   factory.protocol = MyClientProtocol

   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.python import log
from twisted.internet import reactor

from autobahn.twisted.websocket import listenWS

from autobahn.wamp1.protocol import WampServerFactory, \
                                    WampServerProtocol


class MyServerProtocol(WampServerProtocol):

   def onSessionOpen(self):
      self.callClient()

   def callClient(self):
      self.call("http://example.com/client#getTime").addCallback(self.onClientResult)

   def onClientResult(self, result):
      print result
      reactor.callLater(1, self.callClient)


if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WampServerFactory("ws://localhost:9000", debugWamp = debug)
   factory.protocol = MyServerProtocol
   listenWS(factory)

   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys
import json
import urllib
import Cookie

from twisted.internet import reactor
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File

import autobahn
from autobahn.util import newid, utcnow
from autobahn.websocket import http

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol

from autobahn.twisted.resource import WebSocketResource



class PersonaServerProtocol(WebSocketServerProtocol):
   """
   WebSocket server protocol that tracks WebSocket connections using HTTP cookies,
   and authenticates WebSocket connections using Mozilla Persona.
   """

   def onConnect(self, request):

      ## This is called during the initial WebSocket opening handshake.

      protocol, headers = None, {}

      ## our cookie tracking ID
      self._cbtid = None

      ## see if there already is a cookie set ..
      if request.headers.has_key('cookie'):
         try:
            cookie = Cookie.SimpleCookie()
            cookie.load(str(request.headers['cookie']))
         except Cookie.CookieError:
            pass
         else:
            if cookie.has_key('cbtid'):
               cbtid = cookie['cbtid'].value
               if self.factory._cookies.has_key(cbtid):
                  self._cbtid = cbtid
                  log.msg("Cookie already set: %s" % self._cbtid)

      ## if no cookie is set, create a new one ..
      if self._cbtid is None:

         self._cbtid = newid()
         maxAge = 86400

         cbtData = {'created': utcnow(),
                    'authenticated': None,
                    'maxAge': maxAge,
                    'connections': set()}

         self.factory._cookies[self._cbtid] = cbtData

         ## do NOT add the "secure" cookie attribute! "secure" refers to the
         ## scheme of the Web page that triggered the WS, not WS itself!!
         ##
         headers['Set-Cookie'] = 'cbtid=%s;max-age=%d' % (self._cbtid, maxAge)
         log.msg("Setting new cookie: %s" % self._cbtid)

      ## add this WebSocket connection to the set of connections
      ## associated with the same cookie
      self.factory._cookies[self._cbtid]['connections'].add(self)

      ## accept the WebSocket connection, speaking subprotocol `protocol`
      ## and setting HTTP headers `headers`
      return (protocol, headers)


   def onOpen(self):

      ## This is called when initial WebSocket opening handshake has
      ## been completed.

      ## see if we are authenticated ..
      authenticated = self.factory._cookies[self._cbtid]['authenticated']

      if not authenticated:
         ## .. if not, send authentication request
         self.sendMessage(json.dumps({'cmd': 'AUTHENTICATION_REQUIRED'}))
      else:
         ## .. if yes, send info on authenticated user
         self.sendMessage(json.dumps({'cmd': 'AUTHENTICATED', 'email': authenticated}))


   def onClose(self, wasClean, code, reason):

      ## This is called when WebSocket connection is gone

      ## remove this connection from list of connections associated with
      ## same cookie
      self.factory._cookies[self._cbtid]['connections'].remove(self)

      ## if list gets empty, possibly do something ..
      if not self.factory._cookies[self._cbtid]['connections']:
         log.msg("All connections for {} gone".format(self._cbtid))


   def onMessage(self, payload, isBinary):

      ## This is called when we receive a WebSocket message

      if not isBinary:

         msg = json.loads(payload)

         if msg['cmd'] == 'AUTHENTICATE':

            ## The client did it's Mozilla Persona authentication thing
            ## and now wants to verify the authentication and login.
            assertion = msg.get('assertion')
            audience = msg.get('audience');

            ## To verify the authentication, we need to send a HTTP/POST
            ## to Mozilla Persona. When successful, Persona will send us
            ## back something like:

            # {
            #    "audience": "http://192.168.1.130:8080/",
            #    "expires": 1393681951257,
            #    "issuer": "gmail.login.persona.org",
            #    "email": "tobias.oberstein@gmail.com",
            #    "status": "okay"
            # }

            headers = {'Content-Type': 'application/x-www-form-urlencoded'}
            body = urllib.urlencode({'audience': audience, 'assertion': assertion})

            from twisted.web.client import getPage
            d = getPage(url = "https://verifier.login.persona.org/verify",
                        method = 'POST',
                        postdata = body,
                        headers = headers)

            log.msg("Authentication request sent.")

            def done(res):
               res = json.loads(res)
               if res['status'] == 'okay':
                  ## Mozilla Persona successfully authenticated the user

                  ## remember the user's email address. this marks the cookie as
                  ## authenticated
                  self.factory._cookies[self._cbtid]['authenticated'] = res['email']

                  ## inform _all_ WebSocket connections of the successful auth.
                  msg = json.dumps({'cmd': 'AUTHENTICATED', 'email': res['email']})
                  for proto in self.factory._cookies[self._cbtid]['connections']:
                     proto.sendMessage(msg)

                  log.msg("Authenticated user {}".format(res['email']))
               else:
                  log.msg("Authentication failed: {}".format(res.get('reason')))
                  self.sendMessage(json.dumps({'cmd': 'AUTHENTICATION_FAILED', 'reason': res.get('reason')}))
                  self.sendClose()

            def error(err):
               log.msg("Authentication request failed: {}".format(err.value))
               self.sendMessage(json.dumps({'cmd': 'AUTHENTICATION_FAILED', 'reason': str(err.value)}))
               self.sendClose()

            d.addCallbacks(done, error)

         elif msg['cmd'] == 'LOGOUT':

            ## user wants to logout ..
            if self.factory._cookies[self._cbtid]['authenticated']:
               self.factory._cookies[self._cbtid]['authenticated'] = False

               ## inform _all_ WebSocket connections of the logout
               msg = json.dumps({'cmd': 'LOGGED_OUT'})
               for proto in self.factory._cookies[self._cbtid]['connections']:
                  proto.sendMessage(msg)

         else:
            log.msg("unknown command {}".format(msg))



class PersonaServerFactory(WebSocketServerFactory):
   """
   WebSocket server factory with cookie/sessions map.
   """

   protocol = PersonaServerProtocol

   def __init__(self, url):
      WebSocketServerFactory.__init__(self, url, debug = False)

      ## map of cookies
      self._cookies = {}



if __name__ == '__main__':

   log.startLogging(sys.stdout)

   print("Running Autobahn|Python {}".format(autobahn.version))

   ## our WebSocket server factory
   factory = PersonaServerFactory("ws://localhost:8080")

   ## we serve static files under "/" ..
   root = File(".")

   ## .. and our WebSocket server under "/ws"
   resource = WebSocketResource(factory)
   root.putChild("ws", resource)

   ## run both under one Twisted Web Site
   site = Site(root)
   site.log = lambda _: None # disable any logging
   
   reactor.listenTCP(8080, site)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys
from twisted.internet import reactor
from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS


class BroadcastClientProtocol(WebSocketClientProtocol):
   """
   Simple client that connects to a WebSocket server, send a HELLO
   message every 2 seconds and print everything it receives.
   """

   def sendHello(self):
      self.sendMessage("Hello from Python!".encode('utf8'))
      reactor.callLater(2, self.sendHello)

   def onOpen(self):
      self.sendHello()

   def onMessage(self, payload, isBinary):
      if not isBinary:
         print("Text message received: {}".format(payload.decode('utf8')))


if __name__ == '__main__':

   if len(sys.argv) < 2:
      print("Need the WebSocket server address, i.e. ws://localhost:9000")
      sys.exit(1)

   factory = WebSocketClientFactory(sys.argv[1])
   factory.protocol = BroadcastClientProtocol
   connectWS(factory)

   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol, \
                                       listenWS


class BroadcastServerProtocol(WebSocketServerProtocol):

   def onOpen(self):
      self.factory.register(self)

   def onMessage(self, payload, isBinary):
      if not isBinary:
         msg = "{} from {}".format(payload.decode('utf8'), self.peer)
         self.factory.broadcast(msg)

   def connectionLost(self, reason):
      WebSocketServerProtocol.connectionLost(self, reason)
      self.factory.unregister(self)


class BroadcastServerFactory(WebSocketServerFactory):
   """
   Simple broadcast server broadcasting any message it receives to all
   currently connected clients.
   """

   def __init__(self, url, debug = False, debugCodePaths = False):
      WebSocketServerFactory.__init__(self, url, debug = debug, debugCodePaths = debugCodePaths)
      self.clients = []
      self.tickcount = 0
      self.tick()

   def tick(self):
      self.tickcount += 1
      self.broadcast("tick %d from server" % self.tickcount)
      reactor.callLater(1, self.tick)

   def register(self, client):
      if not client in self.clients:
         print("registered client {}".format(client.peer))
         self.clients.append(client)

   def unregister(self, client):
      if client in self.clients:
         print("unregistered client {}".format(client.peer))
         self.clients.remove(client)

   def broadcast(self, msg):
      print("broadcasting message '{}' ..".format(msg))
      for c in self.clients:
         c.sendMessage(msg.encode('utf8'))
         print("message sent to {}".format(c.peer))


class BroadcastPreparedServerFactory(BroadcastServerFactory):
   """
   Functionally same as above, but optimized broadcast using
   prepareMessage and sendPreparedMessage.
   """

   def broadcast(self, msg):
      print("broadcasting prepared message '{}' ..".format(msg))
      preparedMsg = self.prepareMessage(msg)
      for c in self.clients:
         c.sendPreparedMessage(preparedMsg)
         print("prepared message sent to {}".format(c.peer))


if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   ServerFactory = BroadcastServerFactory
   #ServerFactory = BroadcastPreparedServerFactory

   factory = ServerFactory("ws://localhost:9000",
                           debug = debug,
                           debugCodePaths = debug)

   factory.protocol = BroadcastServerProtocol
   factory.setProtocolOptions(allowHixie76 = True)
   listenWS(factory)

   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.twisted.websocket import WebSocketClientProtocol, \
                                       WebSocketClientFactory



class MyClientProtocol(WebSocketClientProtocol):

   def onConnect(self, response):
      print("Server connected: {0}".format(response.peer))

   def onOpen(self):
      print("WebSocket connection open.")

      def hello():
         self.sendMessage(u"Hello, world!".encode('utf8'))
         self.sendMessage(b"\x00\x01\x03\x04", isBinary = True)
         self.factory.reactor.callLater(1, hello)

      ## start sending messages every second ..
      hello()

   def onMessage(self, payload, isBinary):
      if isBinary:
         print("Binary message received: {0} bytes".format(len(payload)))
      else:
         print("Text message received: {0}".format(payload.decode('utf8')))

   def onClose(self, wasClean, code, reason):
      print("WebSocket connection closed: {0}".format(reason))



if __name__ == '__main__':

   import sys

   from twisted.python import log
   from twisted.internet import reactor

   log.startLogging(sys.stdout)

   factory = WebSocketClientFactory("ws://localhost:9000", debug = False)
   factory.protocol = MyClientProtocol

   reactor.connectTCP("127.0.0.1", 9000, factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = client_coroutines
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.twisted.websocket import WebSocketClientProtocol, \
                                       WebSocketClientFactory

from twisted.internet.defer import Deferred, inlineCallbacks


def sleep(delay):
   d = Deferred()
   reactor.callLater(delay, d.callback, None)
   return d


class MyClientProtocol(WebSocketClientProtocol):

   def onConnect(self, response):
      print("Server connected: {0}".format(response.peer))

   @inlineCallbacks
   def onOpen(self):
      print("WebSocket connection open.")

      ## start sending messages every second ..
      while True:
         self.sendMessage(u"Hello, world!".encode('utf8'))
         self.sendMessage(b"\x00\x01\x03\x04", isBinary = True)
         yield sleep(1)

   def onMessage(self, payload, isBinary):
      if isBinary:
         print("Binary message received: {0} bytes".format(len(payload)))
      else:
         print("Text message received: {0}".format(payload.decode('utf8')))

   def onClose(self, wasClean, code, reason):
      print("WebSocket connection closed: {0}".format(reason))



if __name__ == '__main__':

   import sys

   from twisted.python import log
   from twisted.internet import reactor

   log.startLogging(sys.stdout)

   factory = WebSocketClientFactory("ws://localhost:9000", debug = False)
   factory.protocol = MyClientProtocol

   reactor.connectTCP("127.0.0.1", 9000, factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.twisted.websocket import WebSocketServerProtocol, \
                                       WebSocketServerFactory


class MyServerProtocol(WebSocketServerProtocol):

   def onConnect(self, request):
      print("Client connecting: {0}".format(request.peer))

   def onOpen(self):
      print("WebSocket connection open.")

   def onMessage(self, payload, isBinary):
      if isBinary:
         print("Binary message received: {0} bytes".format(len(payload)))
      else:
         print("Text message received: {0}".format(payload.decode('utf8')))

      ## echo back message verbatim
      self.sendMessage(payload, isBinary)

   def onClose(self, wasClean, code, reason):
      print("WebSocket connection closed: {0}".format(reason))



if __name__ == '__main__':

   import sys

   from twisted.python import log
   from twisted.internet import reactor

   log.startLogging(sys.stdout)

   factory = WebSocketServerFactory("ws://localhost:9000", debug = False)
   factory.protocol = MyServerProtocol

   reactor.listenTCP(9000, factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log

from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS

from autobahn.websocket.compress import PerMessageDeflateOffer, \
                                        PerMessageDeflateResponse, \
                                        PerMessageDeflateResponseAccept



class EchoClientProtocol(WebSocketClientProtocol):

   def onConnect(self, response):
      print("WebSocket extensions in use: {}".format(response.extensions))

   def sendHello(self):
      msg = "Hello, world!" * 100
      self.sendMessage(msg.encode('utf8'))

   def onOpen(self):
      self.sendHello()

   def onMessage(self, payload, isBinary):
      if not isBinary:
         print("Text message received: {}".format(payload.decode('utf8')))
      reactor.callLater(1, self.sendHello)


if __name__ == '__main__':

   if len(sys.argv) < 2:
      print("Need the WebSocket server address, i.e. ws://localhost:9000")
      sys.exit(1)

   if len(sys.argv) > 2 and sys.argv[2] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WebSocketClientFactory(sys.argv[1],
                                    debug = debug,
                                    debugCodePaths = debug)

   factory.protocol = EchoClientProtocol


   ## Enable WebSocket extension "permessage-deflate".
   ##

   ## The extensions offered to the server ..
   offers = [PerMessageDeflateOffer()]
   factory.setProtocolOptions(perMessageCompressionOffers = offers)

   ## Function to accept responses from the server ..
   def accept(response):
      if isinstance(response, PerMessageDeflateResponse):
         return PerMessageDeflateResponseAccept(response)

   factory.setProtocolOptions(perMessageCompressionAccept = accept)


   ## run client
   ##
   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = client_advanced
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log

from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS

from autobahn.websocket.compress import *



class EchoClientProtocol(WebSocketClientProtocol):

   def onConnect(self, response):
      print "WebSocket extensions in use: %s" % response.extensions

   def sendHello(self):
      self.sendMessage("Hello, world!" * 100)

   def onOpen(self):
      self.sendHello()

   def onMessage(self, payload, isBinary):
      if not isBinary:
         print("Text message received: {}".format(payload.decode('utf8')))
      reactor.callLater(1, self.sendHello)


if __name__ == '__main__':

   if len(sys.argv) < 2:
      print "Need the WebSocket server address, i.e. ws://localhost:9000"
      sys.exit(1)

   if len(sys.argv) > 2 and sys.argv[2] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WebSocketClientFactory(sys.argv[1],
                                    debug = debug,
                                    debugCodePaths = debug)

   factory.protocol = EchoClientProtocol

   ## Advanced usage: specify exact list of offers ("PMCE") we announce to server.
   ##
   ## Examples:
   ##

   ## this is just what the default constructor for PerMessageDeflateOffer
   ## creates anyway
   offers1 = [PerMessageDeflateOffer(acceptNoContextTakeover = True,
                                     acceptMaxWindowBits = True,
                                     requestNoContextTakeover = False,
                                     requestMaxWindowBits = 0)]

   ## request the server to use a sliding window of 2^8 bytes
   offers2 = [PerMessageDeflateOffer(True, True, False, 8)]

   ## request the server to use a sliding window of 2^8 bytes, but let the
   ## server fall back to "standard" if server does not support the setting
   offers3 = [PerMessageDeflateOffer(True, True, False, 8),
              PerMessageDeflateOffer(True, True, False, 0)]

   ## request "no context takeover", accept the same, but deny setting
   ## a sliding window. no fallback!
   offers4 = [PerMessageDeflateOffer(True, False, True, 0)]

   ## offer "permessage-snappy", "permessage-bzip2" and "permessage-deflate"
   ## note that the first 2 are currently not even in an RFC draft
   ##
   offers5 = []
   if PERMESSAGE_COMPRESSION_EXTENSION.has_key('permessage-snappy'):
      ## this require snappy to be installed
      offers5.append(PerMessageSnappyOffer())
   offers5.append(PerMessageBzip2Offer(True, 1))
   offers5.append(PerMessageDeflateOffer(True, True, False, 12))

   #factory.setProtocolOptions(perMessageCompressionOffers = offers1)
   #factory.setProtocolOptions(perMessageCompressionOffers = offers2)
   #factory.setProtocolOptions(perMessageCompressionOffers = offers3)
   #factory.setProtocolOptions(perMessageCompressionOffers = offers4)
   factory.setProtocolOptions(perMessageCompressionOffers = offers5)

   #factory.setProtocolOptions(autoFragmentSize = 4)

   def accept(response):
      if isinstance(response, PerMessageDeflateResponse):
         return PerMessageDeflateResponseAccept(response)

      elif isinstance(response, PerMessageBzip2Response):
         return PerMessageBzip2ResponseAccept(response)

      elif isinstance(response, PerMessageSnappyResponse):
         return PerMessageSnappyResponseAccept(response)

   factory.setProtocolOptions(perMessageCompressionAccept = accept)

   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import WebSocketServerProtocol, \
                                       WebSocketServerFactory, \
                                       listenWS

from autobahn.websocket.compress import PerMessageDeflateOffer, \
                                        PerMessageDeflateOfferAccept


class EchoServerProtocol(WebSocketServerProtocol):

   def onConnect(self, request):
      print("WebSocket connection request by {}".format(request.peer))

   def onOpen(self):
      print("WebSocket extensions in use: {}".format(self.websocket_extensions_in_use))

   def onMessage(self, payload, isBinary):
      self.sendMessage(payload, isBinary)


if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WebSocketServerFactory("ws://localhost:9000",
                                    debug = debug,
                                    debugCodePaths = debug)

   factory.protocol = EchoServerProtocol


   ## Enable WebSocket extension "permessage-deflate".
   ##

   ## Function to accept offers from the client ..
   def accept(offers):
      for offer in offers:
         if isinstance(offer, PerMessageDeflateOffer):
            return PerMessageDeflateOfferAccept(offer)

   factory.setProtocolOptions(perMessageCompressionAccept = accept)


   ## run server
   ##
   listenWS(factory)

   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = server_advanced
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol, \
                                       listenWS

from autobahn.websocket.compress import *


class EchoServerProtocol(WebSocketServerProtocol):

   def onConnect(self, request):
      print("WebSocket connection request by {}".format(request.peer))

   def onOpen(self):
      print("WebSocket extensions in use: {}".format(self.websocket_extensions_in_use))

   def onMessage(self, payload, isBinary):
      self.sendMessage(payload, isBinary)


if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WebSocketServerFactory("ws://localhost:9000",
                                    debug = debug,
                                    debugCodePaths = debug)

   factory.protocol = EchoServerProtocol

#   factory.setProtocolOptions(autoFragmentSize = 4)

   ## Enable WebSocket extension "permessage-deflate". This is all you
   ## need to do (unless you know what you are doing .. see below)!
   ##
   def accept0(offers):
      for offer in offers:
         if isinstance(offer, PerMessageDeflateOffer):
            return PerMessageDeflateOfferAccept(offer)

   ## Enable experimental compression extensions "permessage-snappy"
   ## and "permessage-bzip2"
   ##
   def accept1(offers):
      for offer in offers:
         if isinstance(offer, PerMessageSnappyOffer):
            return PerMessageSnappyOfferAccept(offer)

         elif isinstance(offer, PerMessageBzip2Offer):
            return PerMessageBzip2OfferAccept(offer)

         elif isinstance(offer, PerMessageDeflateOffer):
            return PerMessageDeflateOfferAccept(offer)

   ## permessage-deflate, server requests the client to do no
   ## context takeover
   ##
   def accept2(offers):
      for offer in offers:
         if isinstance(offer, PerMessageDeflateOffer):
            if offer.acceptNoContextTakeover:
               return PerMessageDeflateOfferAccept(offer, requestNoContextTakeover = True)


   ## permessage-deflate, server requests the client to do no
   ## context takeover, and does not context takeover also
   ##
   def accept3(offers):
      for offer in offers:
         if isinstance(offer, PerMessageDeflateOffer):
            if offer.acceptNoContextTakeover:
               return PerMessageDeflateOfferAccept(offer, requestNoContextTakeover = True, noContextTakeover = True)

   ## permessage-deflate, server requests the client to do use
   ## max window bits specified
   ##
   def accept4(offers):
      for offer in offers:
         if isinstance(offer, PerMessageDeflateOffer):
            if offer.acceptMaxWindowBits:
               return PerMessageDeflateOfferAccept(offer, requestMaxWindowBits = 8)


#   factory.setProtocolOptions(perMessageCompressionAccept = accept0)
#   factory.setProtocolOptions(perMessageCompressionAccept = accept1)
#   factory.setProtocolOptions(perMessageCompressionAccept = accept2)
#   factory.setProtocolOptions(perMessageCompressionAccept = accept3)
   factory.setProtocolOptions(perMessageCompressionAccept = accept4)

   listenWS(factory)

   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol



class EchoClientProtocol(WebSocketClientProtocol):
   """
   Example WebSocket client protocol. This is where you define your application
   specific protocol and logic.
   """

   def sendHello(self):
      self.sendMessage("Hello, world!".encode('utf8'))

   def onOpen(self):
      self.sendHello()

   def onMessage(self, payload, isBinary):
      if not isBinary:
         print("Text message received: {}".format(payload.decode('utf8')))
      self.factory.reactor.callLater(1, self.sendHello)



class EchoClientFactory(WebSocketClientFactory):
   """
   Example WebSocket client factory. This creates a new instance of our protocol
   when the client connects to the server.
   """

   protocol = EchoClientProtocol



if __name__ == '__main__':

   import sys, argparse

   from twisted.python import log
   from twisted.internet.endpoints import clientFromString


   ## parse command line arguments
   ##
   parser = argparse.ArgumentParser()

   parser.add_argument("-d", "--debug", action = "store_true",
                       help = "Enable debug output.")

   parser.add_argument("--websocket", default = "tcp:localhost:9000",
                       help = 'WebSocket client Twisted endpoint descriptor, e.g. "tcp:localhost:9000" or "unix:/tmp/mywebsocket".')

   parser.add_argument("--wsurl", default = "ws://localhost:9000",
                       help = 'WebSocket URL (must suit the endpoint), e.g. "ws://localhost:9000".')

   args = parser.parse_args()


   ## start Twisted logging to stdout
   ##
   log.startLogging(sys.stdout)


   ## we use an Autobahn utility to import the "best" available Twisted reactor
   ##
   from autobahn.choosereactor import install_reactor
   reactor = install_reactor()
   print("Running on reactor {}".format(reactor))


   ## start a WebSocket client
   ##
   wsfactory = EchoClientFactory(args.wsurl, debug = args.debug)
   wsclient = clientFromString(reactor, args.websocket)
   wsclient.connect(wsfactory)


   ## now enter the Twisted reactor loop
   ##
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol



class EchoServerProtocol(WebSocketServerProtocol):
   """
   Example WebSocket server protocol. This is where you define your application
   specific protocol and logic.
   """

   def onMessage(self, payload, isBinary):

      ## just echo any WebSocket message received back to client
      ##
      self.sendMessage(payload, isBinary)



class EchoServerFactory(WebSocketServerFactory):
   """
   Example WebSocket server factory. This creates new instances of our protocol
   for each client connecting.
   """

   protocol = EchoServerProtocol



if __name__ == '__main__':

   import sys, argparse

   from twisted.python import log
   from twisted.internet.endpoints import serverFromString


   ## parse command line arguments
   ##
   parser = argparse.ArgumentParser()

   parser.add_argument("-d", "--debug", action = "store_true",
                       help = "Enable debug output.")

   parser.add_argument("--websocket", default = "tcp:9000",
                       help = 'WebSocket server Twisted endpoint descriptor, e.g. "tcp:9000" or "unix:/tmp/mywebsocket".')

   parser.add_argument("--wsurl", default = "ws://localhost:9000",
                       help = 'WebSocket URL (must suit the endpoint), e.g. "ws://localhost:9000".')

   parser.add_argument("--web", default = "tcp:8080",
                       help = 'Web server endpoint descriptor, e.g. "tcp:8080".')

   args = parser.parse_args()


   ## start Twisted logging to stdout
   ##
   log.startLogging(sys.stdout)


   ## we use an Autobahn utility to install the "best" available Twisted reactor
   ##
   from autobahn.choosereactor import install_reactor
   reactor = install_reactor()
   print("Running on reactor {}".format(reactor))


   ## start a WebSocket server
   ##
   wsfactory = EchoServerFactory(args.wsurl, debug = args.debug)
   wsserver = serverFromString(reactor, args.websocket)
   wsserver.listen(wsfactory)


   ## start a Web server
   ##
   if args.web != "":
      from twisted.web.server import Site
      from twisted.web.static import File

      webfactory = Site(File("."))
      webserver = serverFromString(reactor, args.web)
      webserver.listen(webfactory)


   ## now enter the Twisted reactor loop
   ##
   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log

from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS


class EchoClientProtocol(WebSocketClientProtocol):

   def onConnect(self, response):
      print(response)

   def sendHello(self):
      self.sendMessage("Hello, world!".encode('utf8'))

   def onOpen(self):
      self.sendHello()

   def onMessage(self, payload, isBinary):
      if not isBinary:
         print("Text message received: {}".format(payload.decode('utf8')))
      reactor.callLater(1, self.sendHello)



if __name__ == '__main__':

   if len(sys.argv) < 2:
      print("Need the WebSocket server address, i.e. ws://localhost:9000")
      sys.exit(1)

   if len(sys.argv) > 2 and sys.argv[2] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   headers = {'MyCustomClientHeader': 'Bazbar'}

   factory = WebSocketClientFactory(sys.argv[1],
                                    headers = headers,
                                    debug = debug,
                                    debugCodePaths = debug)

   factory.protocol = EchoClientProtocol
   connectWS(factory)

   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol, \
                                       listenWS


class EchoServerProtocol(WebSocketServerProtocol):

   def onConnect(self, request):
      headers = {'MyCustomDynamicServerHeader1': 'Hello'}

      ## Note: HTTP header field names are case-insensitive,
      ## hence AutobahnPython will normalize header field names to
      ## lower case.
      ##
      if request.headers.has_key('mycustomclientheader'):
         headers['MyCustomDynamicServerHeader2'] = request.headers['mycustomclientheader']

      ## return a pair with WS protocol spoken (or None for any) and
      ## custom headers to send in initial WS opening handshake HTTP response
      ##
      return (None, headers)

   def onMessage(self, payload, isBinary):
      self.sendMessage(payload, isBinary)



if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   headers = {'MyCustomServerHeader': 'Foobar'}

   factory = WebSocketServerFactory("ws://localhost:9000",
                                    headers = headers,
                                    debug = debug,
                                    debugCodePaths = debug)

   factory.protocol = EchoServerProtocol
   listenWS(factory)

   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

## make sure we run a capable OS/reactor
##
startupMsgs = []
if 'bsd' in sys.platform:
   from twisted.internet import kqreactor
   kqreactor.install()
   startupMsgs.append("Alrighty: you run a capable kqueue platform - good job!")
elif sys.platform.startswith('linux'):
   from twisted.internet import epollreactor
   epollreactor.install()
   startupMsgs.append("Alrighty: you run a capable epoll platform - good job!")
elif sys.platform.startswith('darwin'):
   from twisted.internet import kqreactor
   kqreactor.install()
   startupMsgs.append("Huh, you run OSX and have kqueue, but don't be disappointed when performance sucks;)")
elif sys.platform == 'win32':
   raise Exception("Sorry dude, Twisted/Windows select/iocp reactors lack the necessary bits.")
else:
   raise Exception("Hey man, what OS are you using?")

import pkg_resources
from twisted.internet import reactor
startupMsgs.append("Using Twisted reactor class %s on Twisted %s" % (str(reactor.__class__), pkg_resources.require("Twisted")[0].version))


hasStatprof = False
try:
   import statprof
   startupMsgs.append("statprof found! you may enable statistical profiling") 
   hasStatprof = True
except ImportError:
   startupMsgs.append("statprof not installed - no profiling available")


import sys, os
import StringIO
from sys import argv, executable
from socket import AF_INET

from twisted.python import log
from twisted.internet import reactor
from twisted.internet.protocol import Factory
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.websocket import parseWsUrl

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol

from autobahn.util import Stopwatch


class Stats:
   def __init__(self):
      ## stats period
      self.period = 0

      ## currently connected client
      self.clients = 0

      ## total (runnning) stats
      self.tMsgs = 0
      self.tOctets = 0
      self.tHandshakes = 0
      self.tOctetsWireIn = 0
      self.tOctetsWireOut = 0

      self.stopwatch = Stopwatch(start = False)

      ## period stats
      self._advance()

   def _advance(self):
      self.period += 1
      self.pMsgs = 0
      self.pOctets = 0
      self.pHandshakes = 0
      self.pOctetsWireIn = 0
      self.pOctetsWireOut = 0
      self.stopwatch.resume()

   def trackHandshake(self):
      self.tHandshakes += 1
      self.pHandshakes += 1

   def trackMsg(self, length):
      self.tMsgs += 1
      self.pMsgs += 1
      self.tOctets += length
      self.pOctets += length

   def trackOctetsWireIn(self, count):
      self.tOctetsWireIn += count
      self.pOctetsWireIn += count

   def trackOctetsWireOut(self, count):
      self.tOctetsWireOut += count
      self.pOctetsWireOut += count


   def stats(self, advance = True):
      elapsed = self.stopwatch.stop()

      s =    ("Period No.        : %d\n" + \
              "Period duration   : %.3f s\n" + \
              "Connected clients : %d\n" + \
              "\n" + \

              "Period\n" + \
              "  Handshakes      : %20d # %20d #/s\n" + \
              "  Echo'ed msgs    : %20d # %20d #/s\n" + \
              "  Echo'ed octets  : %20d B %20d B/s\n" + \
              "  Wire octets in  : %20d B %20d B/s\n" + \
              "  Wire octets out : %20d B %20d B/s\n" + \
              "\n" + \

              "Total\n" + \
              "  Handshakes      : %20d #\n" + \
              "  Echo'ed msgs    : %20d #\n" + \
              "  Echo'ed octets  : %20d B\n" + \
              "  Wire octets in  : %20d B\n" + \
              "  Wire octets out : %20d B\n" + \

              ""
              ) % (self.period,
                   round(elapsed, 3),
                   self.clients,

                   self.pHandshakes,
                   round(float(self.pHandshakes) / elapsed),

                   self.pMsgs,
                   round(float(self.pMsgs) / elapsed),

                   self.pOctets,
                   round(float(self.pOctets) / elapsed),

                   self.pOctetsWireIn,
                   round(float(self.pOctetsWireIn) / elapsed),

                   self.pOctetsWireOut,
                   round(float(self.pOctetsWireOut) / elapsed),

                   self.tHandshakes,
                   self.tMsgs,
                   self.tOctets,
                   self.tOctetsWireIn,
                   self.tOctetsWireOut,
                   )
      self._advance()
      return s



class EchoServerProtocol(WebSocketServerProtocol):

   def onOpen(self):
      self.factory.stats.clients += 1
      self.factory.stats.trackHandshake()

   def onMessage(self, msg, binary):
      self.sendMessage(msg, binary)
      self.factory.stats.trackMsg(len(msg))

   def onClose(self, wasClean, code, reason):
      self.factory.stats.clients -= 1

   def connectionLost(self, reason):
      WebSocketServerProtocol.connectionLost(self, reason)

      self.factory.stats.trackOctetsWireIn(self.trafficStats.preopenIncomingOctetsWireLevel + \
                                           self.trafficStats.incomingOctetsWireLevel)

      self.factory.stats.trackOctetsWireOut(self.trafficStats.preopenOutgoingOctetsWireLevel + \
                                            self.trafficStats.outgoingOctetsWireLevel)



class EchoServerFactory(WebSocketServerFactory):

   protocol = EchoServerProtocol

   def __init__(self, wsuri, debug = False):
      WebSocketServerFactory.__init__(self, wsuri, debug = debug, debugCodePaths = debug)
      self.stats = Stats()


## export PYPYLOG="jit-log-opt,jit-backend:pypy.log"

## Run under "perf" and enable PyPy JIT logging
##
## Notes:
##
##  - setting an env var (outside root) will NOT work (not propagated)
##  - setting in code also will NOT work
##
## sudo PYPYLOG="jit-log-opt,jit-backend:pypy.log" perf record ~/pypy-20131102/bin/pypy server.py --workers 4



def master(options):
   """
   Start of the master process.
   """
   if not options.silence:
      print "Master started on PID %s" % os.getpid()

   ## start embedded Web server if asked for (this only runs on master)
   ##
   if options.port:
      webdir = File(".")
      web = Site(webdir)
      web.log = lambda _: None # disable annoyingly verbose request logging
      reactor.listenTCP(options.port, web)

   ## we just need some factory like thing .. it won't be used on master anyway
   ## for actual socket accept
   ##
   factory = Factory()

   ## create socket, bind and listen ..
   port = reactor.listenTCP(options.wsport, factory, backlog = options.backlog)

   ## .. but immediately stop reading: we only want to accept on workers, not master
   port.stopReading()

   ## fire off background workers
   ##
   for i in range(options.workers):

      args = [executable, "-u", __file__, "--fd", str(port.fileno()), "--cpuid", str(i)]

      ## pass on cmd line args to worker ..
      args.extend(sys.argv[1:])

      reactor.spawnProcess(
         None, executable, args,
         childFDs = {0: 0, 1: 1, 2: 2, port.fileno(): port.fileno()},
         env = os.environ)

   reactor.run()


PROFILER_FREQ = 2000

def worker(options):
   """
   Start background worker process.
   """
   workerPid = os.getpid()

   if not options.noaffinity:
      p = psutil.Process(workerPid)
      print "affinity [before]", p.get_cpu_affinity()
      p.set_cpu_affinity([options.cpuid])
      print "affinity [after]", p.get_cpu_affinity()


   factory = EchoServerFactory(options.wsuri, debug = options.debug)

   ## The master already created the socket, just start listening and accepting
   ##
   port = reactor.adoptStreamPort(options.fd, AF_INET, factory)

   if not options.silence:
      print "Worker started on PID %s using factory %s and protocol %s" % (workerPid, factory, factory.protocol)
      #print "Worker %d PYPYLOG=%s" % (workerPid, os.environ.get('PYPYLOG', None))

   if options.profile:
      statprof.reset(PROFILER_FREQ)
      statprof.start()

   if not options.silence:
      def stat():
         if options.profile:
            statprof.stop()

         output = StringIO.StringIO()
         output.write("-" * 80 + "\n")
         output.write("Worker Statistics (PID %s)\n\n%s"  % (workerPid, factory.stats.stats()))

         if options.profile:
            output.write("\n")
            #format = statprof.DisplayFormats.ByLine
            #format = statprof.DisplayFormats.ByMethod
            #statprof.display(output, format = format)
            statprof.display(output)

         output.write("-" * 80 + "\n\n")

         sys.stdout.write(output.getvalue())

         if options.profile:
            statprof.reset(PROFILER_FREQ)
            statprof.start()

         reactor.callLater(options.interval, stat)

      reactor.callLater(options.interval, stat)

   if False:
      import cProfile
      print "RUNNING cProfile"
      cProfile.run('reactor.run()')
   else:
      reactor.run()

# /usr/include/valgrind/valgrind.h
# valgrind --tool=callgrind python server.py --wsuri ws://127.0.0.1:9000

# http://valgrind.org/docs/manual/cg-manual.html
# http://valgrind.org/docs/manual/cl-manual.html

# https://bitbucket.org/pypy/jitviewer
# http://morepypy.blogspot.de/2011/08/visualization-of-jitted-code.html
# http://people.cs.uct.ac.za/~tmullins/work/writeup.pdf

# list(range(psutil.NUM_CPUS))
# p.get_cpu_affinity()

# p.set_cpu_affinity([0])
# p.set_nice(psutil.HIGH_PRIORITY_CLASS)


if __name__ == '__main__':

   import argparse
   import psutil

   DEFAULT_WORKERS = psutil.NUM_CPUS

   parser = argparse.ArgumentParser(description = 'Autobahn WebSocket Echo Multicore Server')
   parser.add_argument('--wsuri', dest = 'wsuri', type = str, default = 'ws://localhost:9000', help = 'The WebSocket URI the server is listening on, e.g. ws://localhost:9000.')
   parser.add_argument('--port', dest = 'port', type = int, default = 8080, help = 'Port to listen on for embedded Web server. Set to 0 to disable.')
   parser.add_argument('--workers', dest = 'workers', type = int, default = DEFAULT_WORKERS, help = 'Number of workers to spawn - should fit the number of (phyisical) CPU cores.')
   parser.add_argument('--noaffinity', dest = 'noaffinity', action = "store_true", default = False, help = 'Do not set worker/CPU affinity.')
   parser.add_argument('--backlog', dest = 'backlog', type = int, default = 8192, help = 'TCP accept queue depth. You must tune your OS also as this is just advisory!')
   parser.add_argument('--silence', dest = 'silence', action = "store_true", default = False, help = 'Silence log output.')
   parser.add_argument('--debug', dest = 'debug', action = "store_true", default = False, help = 'Enable WebSocket debug output.')
   parser.add_argument('--interval', dest = 'interval', type = int, default = 5, help = 'Worker stats update interval.')
   parser.add_argument('--profile', dest = 'profile', action = "store_true", default = False, help = 'Enable profiling.')

   parser.add_argument('--fd', dest = 'fd', type = int, default = None, help = 'If given, this is a worker which will use provided FD and all other options are ignored.')
   parser.add_argument('--cpuid', dest = 'cpuid', type = int, default = None, help = 'If given, this is a worker which will use provided CPU core to set its affinity.')

   options = parser.parse_args()

   if options.profile and not hasStatprof:
      raise Exception("profiling requested, but statprof not installed")

   ## parse WS URI into components and forward via options
   ## FIXME: add TLS support
   isSecure, host, wsport, resource, path, params = parseWsUrl(options.wsuri)
   options.wsport = wsport

   #if not options.silence:
   #   log.startLogging(sys.stdout)

   if options.fd is not None:
      # run worker
      worker(options)
   else:
      if not options.silence:
         for m in startupMsgs:
            print m
      # run master
      master(options)



########NEW FILE########
__FILENAME__ = server_reuseport
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys
import os
import socket

from twisted.internet import tcp
from autobahn.twisted.websocket import WebSocketServerProtocol, \
                                       WebSocketServerFactory


class CustomPort(tcp.Port):

   def __init__(self, port, factory, backlog = 50, interface = '', reactor = None, reuse = False):
      tcp.Port.__init__(self, port, factory, backlog, interface, reactor)
      self._reuse = reuse


   def createInternetSocket(self):
      s = tcp.Port.createInternetSocket(self)

      if self._reuse:
         ##
         ## reuse IP Port
         ##
         if 'bsd' in sys.platform or \
             sys.platform.startswith('linux') or \
             sys.platform.startswith('darwin'):
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)

         elif sys.platform == 'win32':
            ## on Windows, REUSEADDR already implies REUSEPORT
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

         else:
            raise Exception("don't know how to set SO_RESUSEPORT on platform {}".format(sys.platform))

      return s


class MyServerProtocol(WebSocketServerProtocol):

   def onConnect(self, request):
      print("Client connecting: {0} on server PID {1}".format(request.peer, os.getpid()))

   def onOpen(self):
      print("WebSocket connection open.")

   def onMessage(self, payload, isBinary):
      if isBinary:
         print("Binary message received: {0} bytes".format(len(payload)))
      else:
         print("Text message received: {0}".format(payload.decode('utf8')))

      ## echo back message verbatim
      self.sendMessage(payload, isBinary)

   def onClose(self, wasClean, code, reason):
      print("WebSocket connection closed: {0}".format(reason))



if __name__ == '__main__':

   import sys

   from twisted.python import log
   from twisted.internet import reactor

   log.startLogging(sys.stdout)

   factory = WebSocketServerFactory("ws://127.0.0.1:9000", debug = False)
   factory.protocol = MyServerProtocol

   #reactor.listenTCP(9000, factory)

   p = CustomPort(9000, factory, reuse = True)
   p.startListening()
   print p

   reactor.run()

########NEW FILE########
__FILENAME__ = echoservice
###############################################################################
##
##  Copyright 2012 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import os, pkg_resources

from twisted.python import log
from twisted.internet import reactor
from twisted.application import service

from twisted.web.server import Site
from twisted.web.static import File

from autobahn.websocket import WebSocketServerFactory, \
                               WebSocketServerProtocol

from autobahn.resource import WebSocketResource, \
                              HTTPChannelHixie76Aware



class EchoServerProtocol(WebSocketServerProtocol):

   def onMessage(self, msg, binary):
      self.sendMessage(msg, binary)



class EchoService(service.Service):
   """
   WebSocket Echo service - this runs a Twisted Web site with a WebSocket
   echo server running under path "/ws".
   """

   def __init__(self, port = 8080, debug = False):
      self.port = port
      self.debug = debug


   def startService(self):

      factory = WebSocketServerFactory("ws://localhost:%d" % self.port, debug = self.debug)

      factory.protocol = EchoServerProtocol
      factory.setProtocolOptions(allowHixie76 = True) # needed if Hixie76 is to be supported

      ## FIXME: Site.start/stopFactory should start/stop factories wrapped as Resources
      factory.startFactory()

      resource = WebSocketResource(factory)

      ## we server static files under "/" ..
      webdir = os.path.abspath(pkg_resources.resource_filename("echows", "web"))
      root = File(webdir)

      ## and our WebSocket server under "/ws"
      root.putChild("ws", resource)

      ## both under one Twisted Web Site
      site = Site(root)
      site.protocol = HTTPChannelHixie76Aware # needed if Hixie76 is to be supported

      self.site = site
      self.factory = factory

      self.listener = reactor.listenTCP(self.port, site)


   def stopService(self):
      self.factory.stopFactory()
      self.site.stopFactory()
      self.listener.stopListening()

########NEW FILE########
__FILENAME__ = main
###############################################################################
##
##  Copyright 2012 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


import twisted
from twisted.python import log, usage
from twisted.application.service import MultiService

from echoservice import EchoService


class AppService(MultiService):
   """
   Our application service hierarchy.
   """

   def startService(self):

      ## create WebSocket echo service and make it a child of our app service
      svc = EchoService(self.port, self.debug)
      svc.setName("EchoService")
      svc.setServiceParent(self)

      MultiService.startService(self)



class Options(usage.Options):
   optFlags = [['debug', 'd', 'Emit debug messages']]
   optParameters = [["port", "p", 8080, "Listening port (for both Web and WebSocket) - default 8080."]]



def makeService(options):
   """
   This will be called from twistd plugin system and we are supposed to
   create and return our application service.
   """

   ## create application service and forward command line options ..
   service = AppService()
   service.port = int(options['port'])
   service.debug = options['debug']

   return service

########NEW FILE########
__FILENAME__ = echows_plugin
###############################################################################
##
##  Copyright 2012 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.application.service import ServiceMaker

serviceMaker = ServiceMaker('echows',
                            'echows.main',
                            'Autobahn WebSocket Echo Service',
                            'echows')

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol

from autobahn.twisted.resource import WebSocketResource, \
                                      HTTPChannelHixie76Aware


class EchoServerProtocol(WebSocketServerProtocol):

   def onMessage(self, payload, isBinary):
      self.sendMessage(payload, isBinary)


if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WebSocketServerFactory("ws://localhost:8080",
                                    debug = debug,
                                    debugCodePaths = debug)

   factory.protocol = EchoServerProtocol
   factory.setProtocolOptions(allowHixie76 = True) # needed if Hixie76 is to be supported

   resource = WebSocketResource(factory)

   ## we server static files under "/" ..
   root = File(".")

   ## and our WebSocket server under "/ws"
   root.putChild("ws", resource)

   ## both under one Twisted Web Site
   site = Site(root)
   site.protocol = HTTPChannelHixie76Aware # needed if Hixie76 is to be supported
   reactor.listenTCP(8080, site)

   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor, ssl
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol

from autobahn.twisted.resource import WebSocketResource, \
                                      HTTPChannelHixie76Aware


class EchoServerProtocol(WebSocketServerProtocol):

   def onMessage(self, payload, isBinary):
      self.sendMessage(payload, isBinary)


if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   contextFactory = ssl.DefaultOpenSSLContextFactory('keys/server.key',
                                                     'keys/server.crt')

   factory = WebSocketServerFactory("wss://localhost:8080",
                                    debug = debug,
                                    debugCodePaths = debug)

   factory.protocol = EchoServerProtocol
   factory.setProtocolOptions(allowHixie76 = True) # needed if Hixie76 is to be supported

   resource = WebSocketResource(factory)

   ## we server static files under "/" ..
   root = File(".")

   ## and our WebSocket server under "/ws"
   root.putChild("ws", resource)

   ## both under one Twisted Web Site
   site = Site(root)
   site.protocol = HTTPChannelHixie76Aware # needed if Hixie76 is to be supported

   reactor.listenSSL(8080, site, contextFactory)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys
from optparse import OptionParser

from twisted.python import log
from twisted.internet import reactor, ssl

from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS



class EchoClientProtocol(WebSocketClientProtocol):

   def sendHello(self):
      self.sendMessage("Hello, world!".encode('utf8'))

   def onOpen(self):
      self.sendHello()

   def onMessage(self, payload, isBinary):
      if not isBinary:
         print("Text message received: {}".format(payload.decode('utf8')))
      reactor.callLater(1, self.sendHello)



if __name__ == '__main__':

   log.startLogging(sys.stdout)

   parser = OptionParser()
   parser.add_option("-u", "--url", dest = "url", help = "The WebSocket URL", default = "wss://localhost:9000")
   (options, args) = parser.parse_args()

   ## create a WS server factory with our protocol
   ##
   factory = WebSocketClientFactory(options.url, debug = False)
   factory.protocol = EchoClientProtocol

   ## SSL client context: default
   ##
   if factory.isSecure:
      contextFactory = ssl.ClientContextFactory()
   else:
      contextFactory = None

   connectWS(factory, contextFactory)
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor, ssl
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol, \
                                       listenWS


class EchoServerProtocol(WebSocketServerProtocol):

   def onMessage(self, payload, isBinary):
      self.sendMessage(payload, isBinary)


if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   ## SSL server context: load server key and certificate
   ## We use this for both WS and Web!
   ##
   contextFactory = ssl.DefaultOpenSSLContextFactory('keys/server.key',
                                                     'keys/server.crt')

   factory = WebSocketServerFactory("wss://localhost:9000",
                                    debug = debug,
                                    debugCodePaths = debug)

   factory.protocol = EchoServerProtocol
   factory.setProtocolOptions(allowHixie76 = True)
   listenWS(factory, contextFactory)

   webdir = File(".")
   webdir.contentTypes['.crt'] = 'application/x-x509-ca-cert'
   web = Site(webdir)
   #reactor.listenSSL(8080, web, contextFactory)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log

from autobahn.twisted.websocket import WebSocketClientProtocol, \
                                       WebSocketClientFactory, \
                                       connectWS


class EchoClientProtocol(WebSocketClientProtocol):

   def sendHello(self):
      self.sendMessage("Hello, world!".encode('utf8'))

   def onOpen(self):
      self.sendHello()

   def onMessage(self, payload, isBinary):
      if not isBinary:
         print("Text message received: {}".format(payload.decode('utf8')))
      reactor.callLater(1, self.sendHello)


if __name__ == '__main__':

   if len(sys.argv) < 2:
      print("Need the WebSocket server address, i.e. ws://localhost:9000")
      sys.exit(1)

   if len(sys.argv) > 2 and sys.argv[2] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WebSocketClientFactory(sys.argv[1],
                                    debug = debug,
                                    debugCodePaths = debug)

   # uncomment to use Hixie-76 protocol
   #factory.setProtocolOptions(allowHixie76 = True, version = 0)
   factory.protocol = EchoClientProtocol
   connectWS(factory)

   reactor.run()

########NEW FILE########
__FILENAME__ = client_reconnecting
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.internet.protocol import ReconnectingClientFactory
from twisted.python import log

from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS


class EchoClientProtocol(WebSocketClientProtocol):

   def sendHello(self):
      self.sendMessage("Hello, world!".encode('utf8'))

   def onOpen(self):
      self.sendHello()

   def onMessage(self, payload, isBinary):
      if not isBinary:
         print("Text message received: {}".format(payload.decode('utf8')))
      reactor.callLater(1, self.sendHello)



class EchoClientFactory(ReconnectingClientFactory, WebSocketClientFactory):

   protocol = EchoClientProtocol

   ## http://twistedmatrix.com/documents/current/api/twisted.internet.protocol.ReconnectingClientFactory.html
   ##
   maxDelay = 10
   maxRetries = 5

   def startedConnecting(self, connector):
     print('Started to connect.')

   def clientConnectionLost(self, connector, reason):
      print('Lost connection. Reason: {}'.format(reason))
      ReconnectingClientFactory.clientConnectionLost(self, connector, reason)

   def clientConnectionFailed(self, connector, reason):
      print('Connection failed. Reason: {}'.format(reason))
      ReconnectingClientFactory.clientConnectionFailed(self, connector, reason)



if __name__ == '__main__':

   if len(sys.argv) < 2:
      print("Need the WebSocket server address, i.e. ws://localhost:9000")
      sys.exit(1)

   if len(sys.argv) > 2 and sys.argv[2] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = EchoClientFactory(sys.argv[1],
                               debug = debug,
                               debugCodePaths = debug)

   # uncomment to use Hixie-76 protocol
   #factory.setProtocolOptions(allowHixie76 = True, version = 0)
   connectWS(factory)

   reactor.run()

########NEW FILE########
__FILENAME__ = client_with_params
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys
from twisted.internet import reactor
from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS


class EchoClientProtocol(WebSocketClientProtocol):

   def __init__(self, message):
      self.message = message.encode('utf8')

   def sendHello(self):
      self.sendMessage(self.message)

   def onOpen(self):
      self.sendHello()

   def onMessage(self, payload, isBinary):
      if not isBinary:
         print("Text message received: {}".format(payload.decode('utf8')))
      reactor.callLater(1, self.sendHello)


class EchoClientFactory(WebSocketClientFactory):

   def buildProtocol(self, addr):
      proto = EchoClientProtocol(self.message)
      proto.factory = self
      return proto


if __name__ == '__main__':

   if len(sys.argv) < 2:
      print "Need the WebSocket server address, i.e. ws://localhost:9000"
      sys.exit(1)

   factory = EchoClientFactory(sys.argv[1])
   factory.message = sys.argv[2] if len(sys.argv) > 2 else "My configurable message"
   connectWS(factory)

   reactor.run()

########NEW FILE########
__FILENAME__ = client_with_proxy
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log

from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS


class EchoClientProtocol(WebSocketClientProtocol):

   def sendHello(self):
      self.sendMessage("Hello, world!".encode('utf8'))

   def onOpen(self):
      self.sendHello()

   def onMessage(self, payload, isBinary):
      if not isBinary:
         print("Text message received: {}".format(payload.decode('utf8')))
      reactor.callLater(1, self.sendHello)


if __name__ == '__main__':

   if len(sys.argv) < 2:
      print("Need the WebSocket server address, i.e. ws://localhost:9000")
      sys.exit(1)

   if len(sys.argv) < 3:
      print("Need the Proxy, i.e. 192.168.1.100:8050")
      sys.exit(1)

   proxyHost, proxyPort = sys.argv[2].split(":")
   proxy = {'host': proxyHost, 'port': int(proxyPort)}

   if len(sys.argv) > 3 and sys.argv[3] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WebSocketClientFactory(sys.argv[1],
                                    proxy = proxy,
                                    debug = debug,
                                    debugCodePaths = debug)

   # uncomment to use Hixie-76 protocol
   #factory.setProtocolOptions(allowHixie76 = True, version = 0)
   factory.protocol = EchoClientProtocol
   connectWS(factory)

   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol, \
                                       listenWS



class EchoServerProtocol(WebSocketServerProtocol):

   def onMessage(self, payload, isBinary):
      self.sendMessage(payload, isBinary)



if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   factory = WebSocketServerFactory("ws://localhost:9000",
                                    debug = debug,
                                    debugCodePaths = debug)

   factory.protocol = EchoServerProtocol
   factory.setProtocolOptions(allowHixie76 = True)
   listenWS(factory)

   webdir = File(".")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol, \
                                       listenWS

from autobahn.twisted.flashpolicy import FlashPolicyFactory



class EchoServerProtocol(WebSocketServerProtocol):

   def onMessage(self, payload, isBinary):
      self.sendMessage(payload, isBinary)



if __name__ == '__main__':

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   wsPort = 9000

   ## Our WebSocket server
   ##
   factory = WebSocketServerFactory("ws://localhost:%d" % wsPort,
                                    debug = debug,
                                    debugCodePaths = debug)

   factory.protocol = EchoServerProtocol
   factory.setProtocolOptions(allowHixie76 = True)
   listenWS(factory)

   ## We need to start a "Flash Policy Server" on TCP/843
   ## which Adobe Flash player will contact to check if
   ## it is allowed to connect to the WebSocket port.
   ##
   flashPolicyFactory = FlashPolicyFactory(wsPort)
   reactor.listenTCP(843, flashPolicyFactory)

   ## Static Web server
   ##
   webdir = File("./web")
   web = Site(webdir)
   reactor.listenTCP(8080, web)

   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2012-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import uuid, sys

from twisted.python import log
from twisted.internet import reactor
from twisted.web.server import Site
from twisted.web.wsgi import WSGIResource

from flask import Flask, render_template

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol

from autobahn.twisted.resource import WebSocketResource, \
                                      WSGIRootResource, \
                                      HTTPChannelHixie76Aware


##
## Our WebSocket Server protocol
##
class EchoServerProtocol(WebSocketServerProtocol):

   def onMessage(self, payload, isBinary):
      self.sendMessage(payload, isBinary)


##
## Our WSGI application .. in this case Flask based
##
app = Flask(__name__)
app.secret_key = str(uuid.uuid4())

@app.route('/')
def page_home():
   return render_template('index.html')


if __name__ == "__main__":

   if len(sys.argv) > 1 and sys.argv[1] == 'debug':
      log.startLogging(sys.stdout)
      debug = True
   else:
      debug = False

   app.debug = debug
   if debug:
      log.startLogging(sys.stdout)

   ##
   ## create a Twisted Web resource for our WebSocket server
   ##
   wsFactory = WebSocketServerFactory("ws://localhost:8080",
                                      debug = debug,
                                      debugCodePaths = debug)

   wsFactory.protocol = EchoServerProtocol
   wsFactory.setProtocolOptions(allowHixie76 = True) # needed if Hixie76 is to be supported

   wsResource = WebSocketResource(wsFactory)

   ##
   ## create a Twisted Web WSGI resource for our Flask server
   ##
   wsgiResource = WSGIResource(reactor, reactor.getThreadPool(), app)

   ##
   ## create a root resource serving everything via WSGI/Flask, but
   ## the path "/ws" served by our WebSocket stuff
   ##
   rootResource = WSGIRootResource(wsgiResource, {'ws': wsResource})

   ##
   ## create a Twisted Web Site and run everything
   ##
   site = Site(rootResource)
   site.protocol = HTTPChannelHixie76Aware # needed if Hixie76 is to be supported

   reactor.listenTCP(8080, site)
   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log

from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS


class EchoClientProtocol(WebSocketClientProtocol):

   def sendHello(self):
      self.sendMessage("Hello, world!".encode('utf8'))

   def onOpen(self):
      self.sendHello()

   def onClose(self, wasClean, code, reason):
      print(reason)

   def onMessage(self, payload, isBinary):
      if not isBinary:
         print("Text message received: {}".format(payload.decode('utf8')))
      reactor.callLater(1, self.sendHello)


class EchoClientFactory(WebSocketClientFactory):

   protocol = EchoClientProtocol

   def clientConnectionLost(self, connector, reason):
      print(reason)
      reactor.stop()

   def clientConnectionFailed(self, connector, reason):
      print(reason)
      reactor.stop()


if __name__ == '__main__':

   if len(sys.argv) < 2:
      print("Need the WebSocket server address, i.e. ws://localhost:9000/echo1")
      sys.exit(1)

   factory = EchoClientFactory(sys.argv[1])
   connectWS(factory)

   reactor.run()

########NEW FILE########
__FILENAME__ = server1
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol, \
                                       listenWS

from autobahn.websocket.http import HttpException



class BaseService:
   """
   Simple base for our services.
   """
   def __init__(self, proto):
      self.proto = proto

   def onOpen(self):
      pass

   def onClose(self, wasClean, code, reason):
      pass

   def onMessage(self, payload, isBinary):
      pass


class Echo1Service(BaseService):
   """
   Awesome Echo Service 1.
   """
   def onMessage(self, payload, isBinary):
      if not isBinary:
         msg = "Echo 1 - {}".format(payload.decode('utf8'))
         print(msg)
         self.proto.sendMessage(msg.encode('utf8'))



class Echo2Service(BaseService):
   """
   Awesome Echo Service 2.
   """
   def onMessage(self, payload, isBinary):
      if not isBinary:
         msg = "Echo 2 - {}".format(payload.decode('utf8'))
         print(msg)
         self.proto.sendMessage(msg.encode('utf8'))



class ServiceServerProtocol(WebSocketServerProtocol):

   SERVICEMAP = {'/echo1': Echo1Service,
                 '/echo2': Echo2Service}

   def __init__(self):
      self.service = None

   def onConnect(self, request):
      ## request has all the information from the initial
      ## WebSocket opening handshake ..
      print(request.peer)
      print(request.headers)
      print(request.host)
      print(request.path)
      print(request.params)
      print(request.version)
      print(request.origin)
      print(request.protocols)
      print(request.extensions)

      ## We map to services based on path component of the URL the
      ## WebSocket client requested. This is just an example. We could
      ## use other information from request, such has HTTP headers,
      ## WebSocket subprotocol, WebSocket origin etc etc
      ##
      if self.SERVICEMAP.has_key(request.path):
         self.service = self.SERVICEMAP[request.path](self)
      else:
         err = "No service under %s" % request.path
         print(err)
         raise HttpException(404, err)

   def onOpen(self):
      if self.service:
         self.service.onOpen()

   def onMessage(self, payload, isBinary):
      if self.service:
         self.service.onMessage(payload, isBinary)

   def onClose(self, wasClean, code, reason):
      if self.service:
         self.service.onClose(wasClean, code, reason)



if __name__ == '__main__':

   factory = WebSocketServerFactory("ws://localhost:9000")
   factory.protocol = ServiceServerProtocol
   listenWS(factory)

   reactor.run()

########NEW FILE########
__FILENAME__ = server2
###############################################################################
##
##  Copyright (C) 2013-2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import Data

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol

from autobahn.twisted.resource import WebSocketResource



class Echo1ServerProtocol(WebSocketServerProtocol):

   def onMessage(self, payload, isBinary):
      if not isBinary:
         msg = "Echo 1 - {}".format(payload.decode('utf8'))
         print(msg)
         self.sendMessage(msg.encode('utf8'))



class Echo2ServerProtocol(WebSocketServerProtocol):

   def onMessage(self, payload, isBinary):
      if not isBinary:
         msg = "Echo 2 - {}".format(payload.decode('utf8'))
         print(msg)
         self.sendMessage(msg.encode('utf8'))



if __name__ == '__main__':

   log.startLogging(sys.stdout)

   factory1 = WebSocketServerFactory()
   factory1.protocol = Echo1ServerProtocol
   resource1 = WebSocketResource(factory1)

   factory2 = WebSocketServerFactory()
   factory2.protocol = Echo2ServerProtocol
   resource2 = WebSocketResource(factory2)

   ## Establish a dummy root resource
   root = Data("", "text/plain")

   ## and our WebSocket servers under different paths ..
   root.putChild("echo1", resource1)
   root.putChild("echo2", resource2)

   ## both under one Twisted Web Site
   site = Site(root)
   reactor.listenTCP(9000, site)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor
from twisted.python import log

from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS


class PingClientProtocol(WebSocketClientProtocol):

   def onOpen(self):
      self.pingsReceived = 0
      self.pongsSent = 0

   def onClose(self, wasClean, code, reason):
      reactor.stop()

   def onPing(self, payload):
      self.pingsReceived += 1
      print("Ping received from {} - {}".format(self.peer, self.pingsReceived)
      self.sendPong(payload)
      self.pongsSent += 1
      print("Pong sent to {} - {}".format(self.peer, self.pongsSent)



if __name__ == '__main__':

   log.startLogging(sys.stdout)

   if len(sys.argv) < 2:
      print("Need the WebSocket server address, i.e. ws://localhost:9000")
      sys.exit(1)

   factory = WebSocketClientFactory(sys.argv[1], debug = 'debug' in sys.argv)
   factory.protocol = PingClientProtocol
   connectWS(factory)

   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import sys

from twisted.internet import reactor, ssl
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol, \
                                       listenWS

from autobahn.twisted.resource import WebSocketResource



class PingServerProtocol(WebSocketServerProtocol):

   def doPing(self):
      if self.run:
         self.sendPing()
         self.factory.pingsSent[self.peer] += 1
         print("Ping sent to {} - {}".format(self.peer, self.factory.pingsSent[self.peer])
         reactor.callLater(1, self.doPing)

   def onPong(self, payload):
      self.factory.pongsReceived[self.peer] += 1
      print("Pong received from {} - {}".format(self.peer, self.factory.pongsReceived[self.peer])

   def onOpen(self):
      self.factory.pingsSent[self.peer] = 0
      self.factory.pongsReceived[self.peer] = 0
      self.run = True
      self.doPing()

   def onClose(self, wasClean, code, reason):
      self.run = False



class PingServerFactory(WebSocketServerFactory):

   def __init__(self, uri, debug):
      WebSocketServerFactory.__init__(self, uri, debug = debug)
      self.pingsSent = {}
      self.pongsReceived = {}



if __name__ == '__main__':

   log.startLogging(sys.stdout)

   contextFactory = ssl.DefaultOpenSSLContextFactory('keys/server.key',
                                                     'keys/server.crt')

   factory = PingServerFactory("wss://localhost:9000",
                               debug = 'debug' in sys.argv)

   factory.protocol = PingServerProtocol
   listenWS(factory, contextFactory)

   resource = WebSocketResource(factory)

   root = File(".")
   root.putChild("ws", resource)
   site = Site(root)

   reactor.listenSSL(8080, site, contextFactory)
   #reactor.listenTCP(8080, site)

   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.twisted.websocket import WebSocketClientProtocol, \
                                       WebSocketClientFactory

import json, random


class SlowSquareClientProtocol(WebSocketClientProtocol):

   def onOpen(self):
      x = 10. * random.random()
      self.sendMessage(json.dumps(x).encode('utf8'))
      print("Request to square {} sent.".format(x))

   def onMessage(self, payload, isBinary):
      if not isBinary:
         res = json.loads(payload.decode('utf8'))
         print("Result received: {}".format(res))
         self.sendClose()

   def onClose(self, wasClean, code, reason):
      if reason:
         print(reason)
      reactor.stop()



if __name__ == '__main__':

   import sys

   from twisted.python import log
   from twisted.internet import reactor

   log.startLogging(sys.stdout)

   factory = WebSocketClientFactory("ws://localhost:9000", debug = False)
   factory.protocol = SlowSquareClientProtocol

   reactor.connectTCP("127.0.0.1", 9000, factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2014 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from autobahn.twisted.websocket import WebSocketServerProtocol, \
                                       WebSocketServerFactory

import json
from twisted.internet.defer import Deferred, \
                                   inlineCallbacks, \
                                   returnValue


def sleep(delay):
   d = Deferred()
   reactor.callLater(delay, d.callback, None)
   return d


class SlowSquareServerProtocol(WebSocketServerProtocol):

   @inlineCallbacks
   def slowsquare(self, x):
      if x > 5:
         raise Exception("number too large")
      else:
         yield sleep(1)
         returnValue(x * x)

   @inlineCallbacks
   def onMessage(self, payload, isBinary):
      if not isBinary:
         x = json.loads(payload.decode('utf8'))
         try:
            res = yield self.slowsquare(x)
         except Exception as e:
            self.sendClose(1000, str(e))
         else:
            self.sendMessage(json.dumps(res).encode('utf8'))



if __name__ == '__main__':

   import sys

   from twisted.python import log
   from twisted.internet import reactor

   log.startLogging(sys.stdout)

   factory = WebSocketServerFactory("ws://localhost:9000", debug = False)
   factory.protocol = SlowSquareServerProtocol

   reactor.listenTCP(9000, factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = frame_based_client
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import hashlib
from pprint import pprint
from ranstring import randomByteString

from twisted.internet import reactor

from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS


FRAME_SIZE = 1 * 2**20
FRAME_COUNT = 10


class FrameBasedHashClientProtocol(WebSocketClientProtocol):
   """
   Message-based WebSockets client that generates stream of random octets
   sent to WebSockets server as a sequence of frames all in one message.
   The server will respond to us with the SHA-256 computed over frames.
   When we receive response, we repeat by sending a new frame.
   """

   def sendOneFrame(self):
      data = randomByteString(FRAME_SIZE)

      self.sha256.update(data)
      digest = self.sha256.hexdigest()
      print("Digest for frame {} computed by client: {}".format(self.count, digest))

      self.sendMessageFrame(data)

   def onOpen(self):
      self.count = 0
      self.finished = False
      self.beginMessage(isBinary = True)
      self.sha256 = hashlib.sha256()
      self.sendOneFrame()

   def onMessage(self, payload, isBinary):
      print("Digest for frame {} computed by server: {}".format(self.count, payload.decode('utf8')))
      #pprint(self.trafficStats.__json__())
      self.count += 1

      if self.count < FRAME_COUNT:
         self.sendOneFrame()
      elif not self.finished:
         self.endMessage()
         self.finished = True

      if self.count >= FRAME_COUNT:
         self.sendClose()

   def onClose(self, wasClean, code, reason):
      reactor.stop()


if __name__ == '__main__':

   factory = WebSocketClientFactory("ws://localhost:9000")
   factory.protocol = FrameBasedHashClientProtocol

   enableCompression = False
   if enableCompression:
      from autobahn.websocket.compress import PerMessageDeflateOffer, \
                                              PerMessageDeflateResponse, \
                                              PerMessageDeflateResponseAccept

      ## The extensions offered to the server ..
      offers = [PerMessageDeflateOffer()]
      factory.setProtocolOptions(perMessageCompressionOffers = offers)

      ## Function to accept responses from the server ..
      def accept(response):
         if isinstance(response, PerMessageDeflateResponse):
            return PerMessageDeflateResponseAccept(response)

      factory.setProtocolOptions(perMessageCompressionAccept = accept)

   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = frame_based_server
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import hashlib
from twisted.internet import reactor

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol, \
                                       listenWS


class FrameBasedHashServerProtocol(WebSocketServerProtocol):
   """
   Frame-based WebSockets server that computes a running SHA-256 for message
   data received. It will respond after every frame received with the digest
   computed up to that point. It can receive messages of unlimited number
   of frames. Digest is reset upon new message.
   """

   def onMessageBegin(self, isBinary):
      WebSocketServerProtocol.onMessageBegin(self, isBinary)
      self.sha256 = hashlib.sha256()

   def onMessageFrame(self, payload):
      l = 0
      for data in payload:
         l += len(data)
         self.sha256.update(data)
      digest = self.sha256.hexdigest()
      print("Received frame with payload length {}, compute digest: {}".format(l, digest))
      self.sendMessage(digest.encode('utf8'))

   def onMessageEnd(self):
      self.sha256 = None


if __name__ == '__main__':

   factory = WebSocketServerFactory("ws://localhost:9000")
   factory.protocol = FrameBasedHashServerProtocol

   enableCompression = False
   if enableCompression:
      from autobahn.websocket.compress import PerMessageDeflateOffer, \
                                              PerMessageDeflateOfferAccept
      ## Function to accept offers from the client ..
      def accept(offers):
         for offer in offers:
            if isinstance(offer, PerMessageDeflateOffer):
               return PerMessageDeflateOfferAccept(offer)

      factory.setProtocolOptions(perMessageCompressionAccept = accept)

   listenWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = message_based_client
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from ranstring import randomByteString
from twisted.internet import reactor

from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS

MESSAGE_SIZE = 1 * 2**20


class MessageBasedHashClientProtocol(WebSocketClientProtocol):
   """
   Message-based WebSockets client that generates stream of random octets
   sent to WebSockets server as a sequence of messages. The server will
   respond to us with the SHA-256 computed over each message. When
   we receive response, we repeat by sending a new message.
   """

   def sendOneMessage(self):
      data = randomByteString(MESSAGE_SIZE)
      self.sendMessage(data, isBinary = True)

   def onOpen(self):
      self.count = 0
      self.sendOneMessage()

   def onMessage(self, payload, isBinary):
      print("Digest for message {} computed by server: {}".format(self.count, payload.decode('utf8')))
      self.count += 1
      self.sendOneMessage()


if __name__ == '__main__':

   factory = WebSocketClientFactory("ws://localhost:9000")
   factory.protocol = MessageBasedHashClientProtocol
   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = message_based_server
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import hashlib
from twisted.internet import reactor

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol, \
                                       listenWS


class MessageBasedHashServerProtocol(WebSocketServerProtocol):
   """
   Message-based WebSockets server that computes a SHA-256 for every
   message it receives and sends back the computed digest.
   """

   def onMessage(self, payload, isBinary):
      sha256 = hashlib.sha256()
      sha256.update(payload)
      digest = sha256.hexdigest()
      self.sendMessage(digest.encode('utf8'))
      print("Sent digest for message: {}".format(digest))


if __name__ == '__main__':
   factory = WebSocketServerFactory("ws://localhost:9000")
   factory.protocol = MessageBasedHashServerProtocol
   listenWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = ranstring
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import random, struct

## http://stackoverflow.com/questions/15014310/python3-xrange-lack-hurts
try:
   xrange
except NameError:
   ## Python 3
   xrange = range


def randomByteString(len):
   """
   Generate a string of random bytes.
   """
   ll = int(len / 8 + int(len % 8 > 0))
   return b''.join([struct.pack("!Q", random.getrandbits(64)) for x in xrange(0, ll)])[:len]

########NEW FILE########
__FILENAME__ = streaming_client
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from ranstring import randomByteString
from twisted.internet import reactor

from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS

BATCH_SIZE = 1 * 2**20


class StreamingHashClientProtocol(WebSocketClientProtocol):
   """
   Streaming WebSockets client that generates stream of random octets
   sent to WebSockets server as a sequence of batches in one frame, in
   one message. The server computes a running SHA-256, which it will send
   every BATCH_SIZE octets back to us. When we receive a response, we
   repeat by sending another batch of data.
   """

   def sendOneBatch(self):
      data = randomByteString(BATCH_SIZE)

      # Note, that this could complete the frame, when the frame length is
      # reached. Since the frame length here is 2^63, we don't bother, since
      # it'll take _very_ long to reach that.
      self.sendMessageFrameData(data)

   def onOpen(self):
      self.count = 0
      self.beginMessage(isBinary = True)
      # 2^63 - This is the maximum imposed by the WS protocol
      self.beginMessageFrame(0x7FFFFFFFFFFFFFFF)
      self.sendOneBatch()

   def onMessage(self, payload, isBinary):
      print("Digest for batch {} computed by server: {}".format(self.count, payload.decode('utf8')))
      self.count += 1
      self.sendOneBatch()


if __name__ == '__main__':

   factory = WebSocketClientFactory("ws://localhost:9000")
   factory.protocol = StreamingHashClientProtocol
   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = streaming_producer_client
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from ranstring import randomByteString
from zope.interface import implementer
from twisted.internet import reactor, interfaces

from autobahn.twisted.websocket import WebSocketClientFactory, \
                                       WebSocketClientProtocol, \
                                       connectWS


# 2^63 - This is the maximum imposed by the WS protocol
FRAME_SIZE = 0x7FFFFFFFFFFFFFFF


@implementer(interfaces.IPushProducer)
class RandomByteStreamProducer:
   """
   A Twisted Push Producer generating a stream of random octets sending out data
   in a WebSockets message frame.
   """

   def __init__(self, proto):
      self.proto = proto
      self.started = False
      self.paused = False

   def pauseProducing(self):
      self.paused = True

   def resumeProducing(self):
      self.paused = False

      if not self.started:
         self.proto.beginMessage(isBinary = True)
         self.proto.beginMessageFrame(FRAME_SIZE)
         self.started = True

      while not self.paused:
         data = randomByteString(1024)
         if self.proto.sendMessageFrameData(data) <= 0:
            self.proto.beginMessageFrame(FRAME_SIZE)
            print("new frame started!")

   def stopProducing(self):
      pass


class StreamingProducerHashClientProtocol(WebSocketClientProtocol):
   """
   Streaming WebSockets client that generates stream of random octets
   sent to streaming WebSockets server, which computes a running SHA-256,
   which it will send every BATCH_SIZE octets back to us. This example
   uses a Twisted producer to produce the byte stream as fast as the
   receiver can consume, but not faster. Therefor, we don't need the
   application-level flow control as with the other examples.
   """

   def onOpen(self):
      self.count = 0
      producer = RandomByteStreamProducer(self)
      self.registerProducer(producer, True)
      producer.resumeProducing()

   def onMessage(self, payload, isBinary):
      print("Digest for batch {} computed by server: {}".format(self.count, payload.decode('utf8')))
      self.count += 1


if __name__ == '__main__':

   factory = WebSocketClientFactory("ws://localhost:9000")
   factory.protocol = StreamingProducerHashClientProtocol
   connectWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = streaming_server
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import hashlib
from twisted.internet import reactor

from autobahn.twisted.websocket import WebSocketServerFactory, \
                                       WebSocketServerProtocol, \
                                       listenWS

from streaming_client import BATCH_SIZE


class StreamingHashServerProtocol(WebSocketServerProtocol):
   """
   Streaming WebSockets server that computes a running SHA-256 for data
   received. It will respond every BATCH_SIZE bytes with the digest
   up to that point. It can receive messages of unlimited number of frames
   and frames of unlimited length (actually, up to 2^63, which is the
   WebSockets protocol imposed limit on frame size). Digest is reset upon
   new message.
   """

   def onMessageBegin(self, isBinary):
      WebSocketServerProtocol.onMessageBegin(self, isBinary)
      self.sha256 = hashlib.sha256()
      self.count = 0
      self.received = 0
      self.next = BATCH_SIZE

   def onMessageFrameBegin(self, length):
      WebSocketServerProtocol.onMessageFrameBegin(self, length)

   def onMessageFrameData(self, payload):
      length = len(payload)
      self.received += length

      ## when the data received exceeds the next BATCH_SIZE ..
      if self.received >= self.next:

         ## update digest up to batch size
         rest = length - (self.received - self.next)
         self.sha256.update(payload[:rest])

         ## send digest
         digest = self.sha256.hexdigest()
         self.sendMessage(digest.encode('utf8'))
         print("Sent digest for batch {} : {}".format(self.count, digest))

         ## advance to next batch
         self.next += BATCH_SIZE
         self.count += 1

         ## .. and update the digest for the rest
         self.sha256.update(payload[rest:])
      else:
         ## otherwise we just update the digest for received data
         self.sha256.update(payload)

   def onMessageFrameEnd(self):
      pass

   def onMessageEnd(self):
      pass


if __name__ == '__main__':
   factory = WebSocketServerFactory("ws://localhost:9000")
   factory.protocol = StreamingHashServerProtocol
   listenWS(factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = testee_server
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

import autobahn

from autobahn.twisted.websocket import WebSocketServerProtocol, \
                                       WebSocketServerFactory

from autobahn.websocket.protocol import WebSocketProtocol
from autobahn.websocket.compress import *



class TesteeServerProtocol(WebSocketServerProtocol):

   def onMessage(self, payload, isBinary):
      self.sendMessage(payload, isBinary)



class StreamingTesteeServerProtocol(WebSocketServerProtocol):

   def onMessageBegin(self, isBinary):
      WebSocketServerProtocol.onMessageBegin(self, isBinary)
      self.beginMessage(isBinary)

   def onMessageFrameBegin(self, length):
      WebSocketServerProtocol.onMessageFrameBegin(self, length)
      self.beginMessageFrame(length)

   def onMessageFrameData(self, payload):
      self.sendMessageFrameData(payload)

   def onMessageFrameEnd(self):
      pass

   def onMessageEnd(self):
      self.endMessage()



class TesteeServerFactory(WebSocketServerFactory):

   #protocol = TesteeServerProtocol
   protocol = StreamingTesteeServerProtocol

   def __init__(self, url, debug = False, ident = None):
      if ident is not None:
         server = ident
      else:
         server = "AutobahnPython-Twisted/%s" % autobahn.version
      WebSocketServerFactory.__init__(self, url, debug = debug, debugCodePaths = debug, server = server)
      self.setProtocolOptions(failByDrop = False) # spec conformance
      self.setProtocolOptions(failByDrop = True) # needed for streaming mode
      #self.setProtocolOptions(utf8validateIncoming = False)

      ## enable permessage-deflate
      ##
      def accept(offers):
         for offer in offers:
            if isinstance(offer, PerMessageDeflateOffer):
               return PerMessageDeflateOfferAccept(offer)

      self.setProtocolOptions(perMessageCompressionAccept = accept)



if __name__ == '__main__':

   import sys

   from twisted.python import log
   from twisted.internet import reactor

   log.startLogging(sys.stdout)

   factory = TesteeServerFactory("ws://localhost:9001", debug = False)

   reactor.listenTCP(9001, factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = client
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet.protocol import Protocol


class HelloClientProtocol(Protocol):

   def connectionMade(self):
      print("connectionMade")
      self.transport.write('hello' * 100)

   def dataReceived(self, data):
      print("dataReceived: {}".format(data))


if __name__ == '__main__':

   import sys

   from twisted.python import log
   from twisted.internet import reactor
   from twisted.internet.protocol import Factory

   from autobahn.twisted.websocket import WrappingWebSocketClientFactory

   log.startLogging(sys.stdout)

   wrappedFactory = Factory.forProtocol(HelloClientProtocol)
   factory = WrappingWebSocketClientFactory(wrappedFactory,
      "ws://localhost:9000",
      enableCompression = False,
      autoFragmentSize = 1024)

   reactor.connectTCP("127.0.0.1", 9000, factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = client_endpoint
###############################################################################
##
##  Copyright (C) 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet.protocol import Protocol


class HelloClientProtocol(Protocol):

   def connectionMade(self):
      print("connectionMade")
      self.transport.write('hello')

   def dataReceived(self, data):
      print("dataReceived: {}".format(data))


if __name__ == '__main__':

   import sys

   from twisted.python import log
   from twisted.internet import reactor
   from twisted.internet.protocol import Factory
   from twisted.internet.endpoints import clientFromString

   log.startLogging(sys.stdout)

   wrappedFactory = Factory.forProtocol(HelloClientProtocol)

   endpoint = clientFromString(reactor, "autobahn:tcp\:localhost\:9000:url=ws\://localhost\:9000")
   endpoint.connect(wrappedFactory)

   reactor.run()

########NEW FILE########
__FILENAME__ = server
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet.protocol import Protocol


class HelloServerProtocol(Protocol):

   def connectionMade(self):
      print("connectionMade")
      self.transport.write('how are you?' * 100)

   def dataReceived(self, data):
      print("dataReceived: {}".format(data))


if __name__ == '__main__':

   import sys

   from twisted.python import log
   from twisted.internet import reactor
   from twisted.internet.protocol import Factory

   from autobahn.twisted.websocket import WrappingWebSocketServerFactory

   log.startLogging(sys.stdout)

   wrappedFactory = Factory.forProtocol(HelloServerProtocol)
   factory = WrappingWebSocketServerFactory(wrappedFactory,
      "ws://localhost:9000",
      enableCompression = False,
      autoFragmentSize = 1024)

   reactor.listenTCP(9000, factory)
   reactor.run()

########NEW FILE########
__FILENAME__ = server_endpoint
###############################################################################
##
##  Copyright (C) 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

from twisted.internet.protocol import Protocol


class HelloServerProtocol(Protocol):

   def connectionMade(self):
      print("connectionMade")
      self.transport.write('how are you?')

   def dataReceived(self, data):
      print("dataReceived: {}".format(data))


if __name__ == '__main__':

   import sys

   from twisted.python import log
   from twisted.internet import reactor
   from twisted.internet.protocol import Factory
   from twisted.internet.endpoints import serverFromString

   log.startLogging(sys.stdout)

   wrappedFactory = Factory.forProtocol(HelloServerProtocol)

   endpoint = serverFromString(reactor, "autobahn:tcp\:9000:url=ws\://localhost\:9000")
   endpoint.listen(wrappedFactory)

   reactor.run()

########NEW FILE########
