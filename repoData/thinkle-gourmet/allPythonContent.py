__FILENAME__ = DatabaseChooser
import gtk, os.path
from gourmet import gglobals
from gourmet import cb_extras as cb
from gourmet import dialog_extras as de
from gourmet.gdebug import debug
from gettext import gettext as _

class DatabaseChooser:
    """This is a simple interface for getting database information from the user."""
    def __init__ (self, okcb=lambda x: debug(x,0), modal=True):
        self._okcb = okcb
        self.modal = modal
        self.possible_dbs = ['sqlite','mysql']
        self.need_connection_info = ['mysql']
        self.need_file_info = ['sqlite']
        self.default_file_directory = gglobals.gourmetdir
        self.default_files = {'sqlite':'recipes.db'
                              }
        uifile = os.path.join(gglobals.uibase,'databaseChooser.ui')
        self.ui = gtk.Builder()
        self.ui.add_from_file(uifile)
        self.connection_widgets = ['hostEntry','userEntry','pwEntry','dbEntry',
                                   'hostLabel','userLabel','pwLabel','dbLabel',
                                   'pwCheckButton']
        self.file_widgets = ['fileEntry','fileButton','fileLabel']
        self.widgets = self.file_widgets + self.connection_widgets + ['dbComboBox',
                                                                      'connectionExpander',
                                                                      'window']
        for w in self.widgets:
            setattr(self,w,self.ui.get_object(w))
        self.ui.connect_signals(
            {'ok_clicked':self.ok_cb,
             'cancel_clicked':self.cancel_cb,
             'dbChanged':self.change_db_cb,
             'browse_clicked':self.browse_cb}
            )
        self.pwEntry.set_visibility(False)
        self.dbComboBox.set_active(0)
        self.connectionExpander.set_expanded(False)
        self.change_db_cb()
        self.window.show()
        if self.modal:
            self.window.set_modal(gtk.TRUE)

    def run (self):
        if self.modal:
            gtk.mainloop()
            return self.retdic
        
    def ok_cb (self, *args):
        if not self.current_db:
            de.show_message(label='No database selected.',
                            sublabel='You need to select a database system.')
        else:
            self.retdic = {'db_backend':self.current_db}
            if self.current_db in self.need_connection_info:
                for e in self.connection_widgets:
                    if e.find('Entry') >= 0:
                        self.retdic[e[0:e.find('Entry')]]=getattr(self,e).get_text()
                self.retdic['store_pw']=self.pwCheckButton.get_active()
            if self.current_db in self.need_file_info:
                fi = self.fileEntry.get_text()
                if fi and fi.find(os.path.sep) < 0:
                    fi = os.path.join(self.default_file_directory,fi)
                self.retdic['file']=fi
            self.window.hide()
            self.window.destroy()
            if self._okcb: self._okcb(self.retdic)
            if self.modal:
                gtk.mainquit()
            return self.retdic

    def cancel_cb (self, *args):
        self.window.hide()
        self.window.destroy()
        if self.modal: gtk.mainquit()
        
    
    def change_db_cb (self, *args):
        self.current_db = None
        text = cb.cb_get_active_text(self.dbComboBox)
        if not text:
            return
        for db in self.possible_dbs:
            if text.lower().find(db.lower()) >= 0:
                self.current_db = db
                break
        if self.current_db in self.need_connection_info:
            self.connectionExpander.set_expanded(True)
            for w in self.connection_widgets:
                getattr(self,w).show()
        else:
            for w in self.connection_widgets:
                getattr(self,w).hide()
        for w in self.file_widgets:
            if self.current_db in self.need_file_info:
                getattr(self,w).show()
            else:
                getattr(self,w).hide()
        if self.default_files.has_key(self.current_db):
            self.fileEntry.set_text(self.default_files[self.current_db])

    def browse_cb (self,*args):
        fi = de.select_file(_("Choose Database File"),
                            filename=self.default_file_directory,
                            action=gtk.FILE_CHOOSER_ACTION_OPEN)
        if fi:
            self.fileEntry.set_text(fi)
    
        
if __name__ == '__main__':
    d = DatabaseChooser(None,modal=True)
    print d.run()

########NEW FILE########
__FILENAME__ = db
import shutil
import types
from gourmet.gdebug import debug, TimeAction, debug_decorator
import re, string, os.path, time
from gettext import gettext as _
import gourmet.gglobals as gglobals
from gourmet import Undo, keymanager, convert
from gourmet.defaults import lang as defaults
import StringIO
from gourmet import ImageExtras
import gourmet.version
import gourmet.recipeIdentifier as recipeIdentifier
from gourmet.plugin_loader import Pluggable, pluggable_method
from gourmet.plugin import DatabasePlugin

import sqlalchemy, sqlalchemy.orm
from sqlalchemy import Integer, LargeBinary, String, Float, Boolean, Numeric, Table, Column, ForeignKey, Text
from sqlalchemy.sql import and_, or_, case 
from sqlalchemy import event, func

Session = sqlalchemy.orm.sessionmaker()

def map_type_to_sqlalchemy (typ):
    """A convenience method -- take a string type and map it into a
    sqlalchemy type.
    """
    if typ=='int': return Integer()
    if typ.find('char(')==0:
        return String(
            length=int(typ[typ.find('(')+1:typ.find(')')])
            )
    if typ=='text': return Text()
    if typ=='bool': return Boolean()
    if typ=='float': return Float()
    if typ=='binary': return LargeBinary()

def fix_colnames (dict, *tables):
    """Map column names to sqlalchemy columns.
    """
    # This is a convenience method -- throughout Gourmet, the column
    # names are handed around as strings. This converts them into the
    # object sqlalchemy prefers.
    newdict =  {}
    for k,v in dict.items():
        got_prop = False
        for t in tables:
            try:
                newdict[getattr(t.c,k)]=v
            except:
                1
            else:
                got_prop = True
        if not got_prop: raise ValueError("Could not find column %s in tables %s"%(k,tables))
    return newdict

def make_simple_select_arg (criteria,*tables):
    args = []
    for k,v in fix_colnames(criteria,*tables).items():
        if type(v)==str:
            v = unicode(v)
        if type(v)==tuple:
            operator,value = v
            if type(value)==str:
                value = unicode(value)
            if operator=='in':
                args.append(k.in_(value))
            elif hasattr(k,operator):
                args.append(getattr(k,operator)(value))
            elif hasattr(k,operator+'_'): # for keywords like 'in'
                args.append(getattr(k,operator+'_')(value))
            else:
                args.append(k.op(operator)(value))
        else:
            args.append(k==v)
    if len(args)>1:
        return [and_(*args)]
    elif args:
        return [args[0]]
    else:
        return []

def make_order_by (sort_by, table, count_by=None, join_tables=[]):
    ret = []
    for col,direction in sort_by:        
        if col=='count' and not hasattr(table.c,'count'):
            col = sqlalchemy.func.count(getattr(table.c,count_by))
        else:
            if hasattr(table.c,col):
                col = getattr(table.c,col)
            elif join_tables:
                broken = True
                for t in join_tables:
                    if hasattr(t.c,col):
                        broken = False
                        col = getattr(t.c,col)
                        break
                if broken:
                    raise ValueError("No such column for tables %s %s: %s"%(table, join_tables, col))
        if isinstance(col.type, Text):
            # Sort nulls last rather than first using case statement...
            col = case([(col == None, '"%s"'%'z'*20),
                        (col == '', '"%s"'%'z'*20),
                        ],else_=func.lower(col))
        if direction==1: # Ascending
            ret.append(sqlalchemy.asc(col))
        else:
            ret.append(sqlalchemy.desc(col))
    return ret
    
class DBObject:
    pass
# CHANGES SINCE PREVIOUS VERSIONS...
# categories_table: id -> recipe_id, category_entry_id -> id
# ingredients_table: ingredient_id -> id, id -> recipe_id

class RecData (Pluggable): 

    """RecData is our base class for handling database connections.

    Subclasses implement specific backends, such as sqlite, etc."""

    # constants for determining how to get amounts when there are ranges.
    AMT_MODE_LOW = 0
    AMT_MODE_AVERAGE = 1
    AMT_MODE_HIGH = 2

    _singleton = {}

    def __init__ (self, file=os.path.join(gglobals.gourmetdir,'recipes.db'),
                  custom_url=None):
        # hooks run after adding, modifying or deleting a recipe.
        # Each hook is handed the recipe, except for delete_hooks,
        # which is handed the ID (since the recipe has been deleted)
        if RecData._singleton.has_key(file):
            raise RecData._singleton[file]
        else:
            RecData._singleton[file] = self
        # We keep track of IDs we've handed out with new_id() in order
        # to prevent collisions
        self.new_ids = []
        self._created = False
        if custom_url:
            self.url = custom_url
            self.filename = None
        else:
            self.filename = file
            self.url = 'sqlite:///' + self.filename
        self.add_hooks = []
        self.modify_hooks = []
        self.delete_hooks = []
        self.add_ing_hooks = []
        timer = TimeAction('initialize_connection + setup_tables',2)
        self.initialize_connection()
        Pluggable.__init__(self,[DatabasePlugin])            
        self.setup_tables()
        self.metadata.create_all()
        self.update_version_info(gourmet.version.version)
        self._created = True
        timer.end()

    # Basic setup functions

    def initialize_connection (self):
        """Initialize our database connection.
        
        This should also set self.new_db accordingly"""
        debug('Initializing DB connection',1)
        def instr(s,subs): return s.lower().find(subs.lower())+1
            
        # End REGEXP workaround 

        # Continue setting up connection...
        if self.filename:
            self.new_db = not os.path.exists(self.filename)
            #print 'Connecting to file ',self.filename,'new=',self.new_db
        else:
            self.new_db = True # ??? How will we do this now?
        #self.db = sqlalchemy.create_engine(self.url,strategy='threadlocal')
        #self.base_connection = self.db

        if self.url.startswith('mysql'):
            self.db = sqlalchemy.create_engine(self.url,
                                               connect_args = {'charset':'utf8'})
        else:
            self.db = sqlalchemy.create_engine(self.url)

        if self.url.startswith('sqlite'):
            # Workaround to create REGEXP function in sqlite
            # New way of adding custom function ensures we create a custom
            # function for every connection created and fixes problems
            # using regexp. Based on code found here:
            # http://stackoverflow.com/questions/8076126/have-an-sqlalchemy-sqlite-create-function-issue-with-datetime-representation
            def regexp(expr, item):
                if item:
                    return re.search(expr,item,re.IGNORECASE) is not None
                else:
                    return False

            @event.listens_for(self.db, 'connect')
            def on_connect (dbapi_con, con_record):
                dbapi_con.create_function('REGEXP',2,regexp)

        self.base_connection = self.db.connect()
        self.base_connection.begin()
        self.metadata = sqlalchemy.MetaData(self.db)
        # Be noisy... (uncomment for debugging/fiddling)
        # self.metadata.bind.echo = True
        Session.configure(bind=self.db)
        debug('Done initializing DB connection',1)

    def save (self):
        """Save our database (if we have a separate 'save' concept)"""
        row = self.fetch_one(self.info_table)
        if row:
            self.do_modify(
                self.info_table,
                row,
                {'last_access':time.time()},
                id_col = None
                )
        else:
            self.do_add(
                self.info_table,
                {'last_access':time.time()}
                )
        try:
            #self.base_connection.commit()
            pass
        except IndexError:
            print 'Ignoring sqlalchemy problem'
            import traceback; traceback.print_exc()

    def _setup_object_for_table (self, table, klass):
        self.__table_to_object__[table] = klass
        #print 'Mapping ',repr(klass),'->',repr(table)
        if True in [col.primary_key for col in table.columns]:
            sqlalchemy.orm.mapper(klass,table)
        else:
            # if there's no primary key...
            raise Exception("All tables need a primary key -- specify 'rowid'/Integer/Primary Key in table spec for %s" % table)

    @pluggable_method
    def setup_tables (self):
        """
        Subclasses should do any necessary adjustments/tweaking before calling
        this function."""
        # Info table - for versioning info
        self.__table_to_object__ = {}
        self.setup_base_tables()
        self.setup_shopper_tables() # could one day be part of a plugin

    def setup_base_tables (self):
        self.setup_info_table()
        self.setup_recipe_table()
        self.setup_category_table()
        self.setup_ingredient_table()        
        
    def setup_info_table (self):
        self.info_table = Table('info',self.metadata,
                                Column('version_super',Integer(),**{}), # three part version numbers 2.1.10, etc. 1.0.0
                                Column('version_major',Integer(),**{}),
                                Column('version_minor',Integer(),**{}),
                                Column('last_access',Integer(),**{}),
                                Column('rowid',Integer(),**{'primary_key':True})
                                )
        class Info (object):
            pass
        self._setup_object_for_table(self.info_table, Info)
        self.plugin_info_table = Table('plugin_info',self.metadata,
                                       Column('plugin',Text(),**{}),
                                       # three part version numbers
                                       # 2.1.10, etc. 1.0.0 -- these
                                       # contain the Gourmet version
                                       # at the last time of
                                       # plugging-in
                                       Column('id',Integer(),**{'primary_key':True}),
                                       Column('version_super',Integer(),**{}), 
                                       Column('version_major',Integer(),**{}),
                                       Column('version_minor',Integer(),**{}),
                                       # Stores the last time the plugin was used...
                                       Column('plugin_version',String(length=32),**{}))
        class PluginInfo (object):
            pass
        self._setup_object_for_table(self.plugin_info_table, PluginInfo)

    def setup_recipe_table (self):
        self.recipe_table = Table('recipe',self.metadata,
                                  Column('id',Integer(),**{'primary_key':True}),
                                  Column('title',Text(),**{}),
                                  Column('instructions',Text(),**{}),
                                  Column('modifications',Text(),**{}),
                                  Column('cuisine',Text(),**{}),
                                  Column('rating',Integer(),**{}),
                                  Column('description',Text(),**{}),
                                  Column('source',Text(),**{}),
                                  Column('preptime',Integer(),**{}),
                                  Column('cooktime',Integer(),**{}),
                                  # Note: we're leaving servings
                                  # around as a legacy column... it is
                                  # replaced by yields/yield_unit, but
                                  # update is much easier if it's
                                  # here, and it doesn't do much harm
                                  # to have it around.
                                  Column('servings',Float(),**{}), 
                                  Column('yields',Float(),**{}),                                  
                                  Column('yield_unit',String(length=32),**{}),
                                  Column('image',LargeBinary(),**{}),
                                  Column('thumb',LargeBinary(),**{}),
                                  Column('deleted',Boolean(),**{}),
                                  # A hash for uniquely identifying a recipe (based on title etc)
                                  Column('recipe_hash',String(length=32),**{}),
                                  # A hash for uniquely identifying a recipe (based on ingredients)
                                  Column('ingredient_hash',String(length=32),**{}),
                                  Column('link',Text(),**{}), # A field for a URL -- we ought to know about URLs
                                  Column('last_modified',Integer(),**{}),
                                  ) # RECIPE_TABLE_DESC

        class Recipe (object): pass
        self._setup_object_for_table(self.recipe_table,Recipe)

    def setup_category_table (self):
        self.categories_table = Table('categories',self.metadata,
                                    Column('id',Integer(),primary_key=True),
                                    Column('recipe_id',Integer,ForeignKey('recipe.id'),**{}), #recipe ID
                                    Column('category',Text(),**{}) # Category ID
                                    ) # CATEGORY_TABLE_DESC
        class Category (object): pass
        self._setup_object_for_table(self.categories_table,Category)

    def setup_ingredient_table (self):
        self.ingredients_table = Table('ingredients',self.metadata,
                                       Column('id',Integer(),primary_key=True),
                                       Column('recipe_id',Integer,ForeignKey('recipe.id'),**{}),
                                       Column('refid',Integer,ForeignKey('recipe.id'),**{}),
                                       Column('unit',Text(),**{}),
                                       Column('amount',Float(),**{}),
                                       Column('rangeamount',Float(),**{}),
                                       Column('item',Text(),**{}),
                                       Column('ingkey',Text(),**{}),
                                       Column('optional',Boolean(),**{}),
                                       #Integer so we can distinguish unset from False
                                       Column('shopoptional',Integer(),**{}), 
                                       Column('inggroup',Text(),**{}),
                                       Column('position',Integer(),**{}),
                                       Column('deleted',Boolean(),**{}),
                                       )
        class Ingredient (object): pass
        self._setup_object_for_table(self.ingredients_table, Ingredient)

    def setup_keylookup_table (self):
        # Keylookup table - for speedy keylookup
        self.keylookup_table = Table('keylookup',self.metadata,
                                     Column('id',Integer(),primary_key=True),
                                     Column('word',Text(),**{}),
                                      Column('item',Text(),**{}),
                                      Column('ingkey',Text(),**{}),
                                      Column('count',Integer(),**{})
                                     ) # INGKEY_LOOKUP_TABLE_DESC
        class KeyLookup (object): pass
        self._setup_object_for_table(self.keylookup_table, KeyLookup)

    def setup_shopcats_table (self):
        # shopcats - Keep track of which shoppin category ingredients are in...
        self.shopcats_table = Table('shopcats',self.metadata,
                                    Column('id',Integer(),primary_key=True),
                                    Column('ingkey',Text(32)),
                                    Column('shopcategory',Text()),
                                    Column('position',Integer()),
                                    )
        class ShopCat (object): pass
        self._setup_object_for_table(self.shopcats_table, ShopCat)
        
    def setup_shopcatsorder_table (self):
        # shopcatsorder - Keep track of the order of shopping categories
        self.shopcatsorder_table = Table('shopcatsorder',self.metadata,
                                         Column('id',Integer(),primary_key=True),
                                         Column('shopcategory',Text(32)),
                                         Column('position',Integer()),
                                         )
        class ShopCatOrder (object): pass
        self._setup_object_for_table(self.shopcatsorder_table, ShopCatOrder)
        
    def setup_pantry_table (self):
        # pantry table -- which items are in the "pantry" (i.e. not to
        # be added to the shopping list)
        self.pantry_table = Table('pantry',self.metadata,
                                  Column('id',Integer(),primary_key=True),
                                  Column('ingkey',Text(32)),
                                  Column('pantry',Boolean()),
                                  )
        class Pantry (object): pass
        self._setup_object_for_table(self.pantry_table, Pantry)

    def setup_density_table (self):
        # Keep track of the density of items...
        self.density_table = Table('density',self.metadata,
                                   Column('id',Integer(),primary_key=True),
                                   Column('dkey',String(length=150)),
                                   Column('value',String(length=150))
                                   )
        class Density (object): pass
        self._setup_object_for_table(self.density_table, Density)

    def setup_crossunitdict_table (self):
        self.crossunitdict_table = Table('crossunitdict',self.metadata,
                                         Column('id',Integer(),primary_key=True),
                                         Column('cukey',String(length=150)),
                                         Column('value',String(length=150)),
                                         )
        class CrossUnit (object): pass
        self._setup_object_for_table(self.crossunitdict_table,CrossUnit)
        
    def setup_unitdict_table (self):
        self.unitdict_table = Table('unitdict',self.metadata,
                                    Column('id',Integer(),primary_key=True),
                                    Column('ukey',String(length=150)),
                                    Column('value',String(length=150)),
                                    )
        class Unitdict (object):
            pass
        self._setup_object_for_table(self.unitdict_table, Unitdict)

    def setup_convtable_table (self):
        self.convtable_table = Table('convtable',self.metadata,
                                     Column('id',Integer(),primary_key=True),
                                     Column('ckey',String(length=150)),
                                     Column('value',String(length=150))
                                     )
        class Convtable (object):
            pass
        self._setup_object_for_table(self.convtable_table, Convtable)

    def setup_shopper_tables (self):
        self.setup_keylookup_table()
        self.setup_shopcats_table()
        self.setup_shopcatsorder_table()
        self.setup_pantry_table()
        self.setup_density_table()
        self.setup_crossunitdict_table()
        self.setup_unitdict_table()
        self.setup_convtable_table()

    def backup_db (self):
        """Make a backup copy of the DB -- this ensures experimental
        code won't permanently screw our users."""
        import time, os.path
        backup_file_name = self.filename + '.backup-' + time.strftime('%d-%m-%y')
        while os.path.exists(backup_file_name):
            backup_file_name += 'I'
        print 'Making a backup copy of DB in ',backup_file_name
        print 'You can use it to restore if something ugly happens.'
        shutil.copy(self.filename,backup_file_name) # Make a backup...
        import gourmet.gtk_extras.dialog_extras as de
        import gtk
        de.show_message(
            title=_("Upgrading database"),
            label=_("Upgrading database"),            
            sublabel=_("Depending on the size of your database, this may be an intensive process and may take  some time. Your data has been automatically backed up in case something goes wrong."),
            expander=(_("Details"),_("A backup has been made in %s in case something goes wrong. If this upgrade fails, you can manually rename your backup file recipes.db to recover it for use with older Gourmet.")%backup_file_name),
            message_type=gtk.MESSAGE_INFO)

    def update_version_info (self, version_string):
        """Report our version to the database.

        If necessary, we'll do some version-dependent updates to the GUI
        """
        stored_info = self.fetch_one(self.info_table)
        version = [s for s in version_string.split('-')[0].split('.')]
        current_super = int(version[0])
        current_major = int(version[1])
        current_minor = int(version[2])
        if not stored_info or not stored_info.version_major:
            # Default info -- the last version before we added the
            # version tracker...
            default_info = {'version_super':0,
                             'version_major':11,
                             'version_minor':0}
            if not stored_info:
                if not self.new_db:
                    self.do_add(self.info_table,
                                default_info)
                else:
                    self.do_add(self.info_table,
                                {'version_super':current_super,
                                 'version_major':current_major,
                                 'version_minor':current_minor,}
                                )
            else:
                self.do_modify(
                    self.info_table,
                    stored_info,
                    default_info)
            stored_info = self.fetch_one(self.info_table)            
    
        ### Code for updates between versions...
        if not self.new_db:
            sv_text = "%s.%s.%s"%(stored_info.version_super,stored_info.version_major,stored_info.version_minor)
            #print 'STORED_INFO:',stored_info.version_super,stored_info.version_major,stored_info.version_minor
            # Change from servings to yields! ( we use the plural to avoid a headache with keywords)
            if stored_info.version_super == 0 and stored_info.version_major < 16:
                print 'Database older than 0.16.0 -- updating',sv_text
                self.backup_db()
                from sqlalchemy.sql.expression import func
                # We need to unpickle Booleans that have erroneously remained
                # pickled during previous Metakit -> SQLite -> SQLAlchemy
                # database migrations.
                self.pantry_table.update().where(self.pantry_table.c.pantry
                                                 =='I01\n.'
                                                 ).values(pantry=True).execute()
                self.pantry_table.update().where(self.pantry_table.c.pantry
                                                 =='I00\n.'
                                                 ).values(pantry=False).execute()
                # Unpickling strings with SQLAlchemy is clearly more complicated:
                self.shopcats_table.update().where(
                    and_(self.shopcats_table.c.shopcategory.startswith("S'"),
                         self.shopcats_table.c.shopcategory.endswith("'\np0\n."))
                    ).values({self.shopcats_table.c.shopcategory:
                              func.substr(self.shopcats_table.c.shopcategory,
                                          3,
                                          func.char_length(
                                            self.shopcats_table.c.shopcategory
                                          )-8)
                             }).execute()

                # The following tables had Text columns as primary keys,
                # which, when used with MySQL, requires an extra parameter
                # specifying the length of the substring that MySQL is
                # supposed to use for the key. Thus, we're adding columns
                # named id of type Integer and make them the new primary keys
                # instead.
                self.alter_table('shopcats',self.setup_shopcats_table,
                                 {},['ingkey','shopcategory','position'])
                self.alter_table('shopcatsorder',self.setup_shopcatsorder_table,
                                 {},['shopcategory','position'])
                self.alter_table('pantry',self.setup_pantry_table,
                                 {},['ingkey','pantry'])
                self.alter_table('density',self.setup_density_table,
                                 {},['dkey','value'])
                self.alter_table('crossunitdict',self.setup_crossunitdict_table,
                                 {},['cukey','value'])
                self.alter_table('unitdict',self.setup_unitdict_table,
                                 {},['ukey','value'])
                self.alter_table('convtable',self.setup_convtable_table,
                                 {},['ckey','value'])
            if (stored_info.version_super == 0 and ((stored_info.version_major <= 14 and stored_info.version_minor <= 7)
                                                    or
                                                    (stored_info.version_major < 14)
                                                    )):
                print 'Database older than 0.14.7 -- updating',sv_text
                # Don't change the table defs here without changing them
                # above as well (for new users) - sorry for the stupid
                # repetition of code.
                self.add_column_to_table(self.recipe_table,('yields',Float(),{}))
                self.add_column_to_table(self.recipe_table,('yield_unit',String(length=32),{}))
                #self.db.execute('''UPDATE recipes SET yield = servings, yield_unit = "servings" WHERE EXISTS servings''')
                self.recipe_table.update(whereclause=self.recipe_table.c.servings
                                       ).values({
                        self.recipe_table.c.yield_unit:'servings',
                        self.recipe_table.c.yields:self.recipe_table.c.servings
                        }
                                                ).execute()
            if stored_info.version_super == 0 and stored_info.version_major < 14:
                print 'Database older than 0.14.0 -- updating',sv_text
                self.backup_db()
                # Name changes to make working with IDs make more sense
                # (i.e. the column named 'id' should always be a unique
                # identifier for a given table -- it should not be used to
                # refer to the IDs from *other* tables
                print 'Upgrade from < 0.14',sv_text
                self.alter_table('categories',self.setup_category_table,
                                 {'id':'recipe_id'},['category'])
                # Testing whether somehow recipe_id already exists
                # (apparently the version info here may be off? Not
                # sure -- this is coming from an odd bug report by a
                # user reported at...
                # https://sourceforge.net/projects/grecipe-manager/forums/forum/371768/topic/3630545?message=8205906
                try:
                    self.db.connect().execute('select recipe_id from ingredients')
                except sqlalchemy.exc.OperationalError:
                    self.alter_table('ingredients',self.setup_ingredient_table,
                                     {'id':'recipe_id'},
                                     ['refid', 'unit', 'amount', 'rangeamount',
                                      'item', 'ingkey', 'optional', 'shopoptional',
                                      'inggroup', 'position', 'deleted'])
                else:
                    print 'Odd -- recipe_id seems to already exist'
                self.alter_table('keylookup',self.setup_keylookup_table,
                                 {},['word','item','ingkey','count'])
            # Add recipe_hash, ingredient_hash and link fields
            # (These all get added in 0.13.0)
            if stored_info.version_super == 0 and stored_info.version_major <= 12:
                self.backup_db()                
                print 'UPDATE FROM < 0.13.0...',sv_text
                # Don't change the table defs here without changing them
                # above as well (for new users) - sorry for the stupid
                # repetition of code.
                self.add_column_to_table(self.recipe_table,('last_modified',Integer(),{}))
                self.add_column_to_table(self.recipe_table,('recipe_hash',String(length=32),{}))
                self.add_column_to_table(self.recipe_table,('ingredient_hash',String(length=32),{}))
                # Add a link field...
                self.add_column_to_table(self.recipe_table,('link',Text(),{}))
                print 'Searching for links in old recipe fields...',sv_text
                URL_SOURCES = ['instructions','source','modifications']
                recs = self.search_recipes(
                    [
                    {'column':col,
                     'operator':'LIKE',
                     'search':'%://%',
                     'logic':'OR'
                     }
                    for col in URL_SOURCES
                    ])
                for r in recs:
                    rec_url = ''
                    for src in URL_SOURCES:
                        blob = getattr(r,src)
                        url = None
                        if blob:
                            m = re.search('\w+://[^ ]*',blob)
                            if m:
                                rec_url = blob[m.start():m.end()]
                                if rec_url[-1] in ['.',')',',',';',':']:
                                    # Strip off trailing punctuation on
                                    # the assumption this is part of a
                                    # sentence -- this will break some
                                    # URLs, but hopefully rarely enough it
                                    # won't harm (m)any users.
                                    rec_url = rec_url[:-1]
                                break
                    if rec_url:
                        if r.source==rec_url:
                            new_source = rec_url.split('://')[1]
                            new_source = new_source.split('/')[0]
                            self.do_modify_rec(
                                r,
                                {'link':rec_url,
                                 'source':new_source,
                                 }
                                )
                        else:
                            self.do_modify_rec(
                                r,
                                {'link':rec_url,}
                                )
                # Add hash values to identify all recipes...
                for r in self.fetch_all(self.recipe_table): self.update_hashes(r)

            if stored_info.version_super == 0 and stored_info.version_major <= 11 and stored_info.version_minor <= 3:
                print 'version older than 0.11.4 -- doing update',sv_text
                self.backup_db()
                print 'Fixing broken ingredient-key view from earlier versions.'
                # Drop keylookup_table table, which wasn't being properly kept up
                # to date...
                self.delete_by_criteria(self.keylookup_table,{}) 
                # And update it in accord with current ingredients (less
                # than an ideal decision, alas)
                for ingredient in self.fetch_all(self.ingredients_table,deleted=False):
                    self.add_ing_to_keydic(ingredient.item,ingredient.ingkey)

            for plugin in self.plugins:
                self.update_plugin_version(plugin,
                                           (current_super,current_major,current_minor)
                                           )
        ### End of code for updates between versions...
        if (current_super!=stored_info.version_super
            or
            current_major!=stored_info.version_major
            or
            current_minor!=stored_info.version_minor
            ):
            self.do_modify(
                self.info_table,
                stored_info,
                {'version_super':current_super,
                 'version_major':current_major,
                 'version_minor':current_minor,},
                id_col=None
                )

    def update_plugin_version (self, plugin, current_version=None):
        if current_version:
            current_super,current_major,current_minor = current_version
        else:
            i = self.fetch_one(self.info_table)
            current_super,current_major,current_minor = (i.version_super,
                                                         i.version_major,
                                                         i.version_minor)
        existing = self.fetch_one(self.plugin_info_table,
                                  plugin=plugin.name)
        if existing:
            sup,maj,minor,plugin_version = (existing.version_super,
                                            existing.version_major,
                                            existing.version_minor,
                                            existing.plugin_version)
        else:
            # Default to the version before our plugin system existed
            sup,maj,minor = 0,13,9
            plugin_version = 0
        try:
            plugin.update_version(
                gourmet_stored=(sup,maj,minor),
                plugin_stored = plugin_version,
                gourmet_current=(current_super,current_major,current_minor),
                plugin_current = plugin.version,
                )
        except:
            print 'Problem updating plugin',plugin,plugin.name
            raise
        # Now we store the information so we know we've done an update
        info = {
            'plugin':plugin.name,
            'version_super':current_super,
            'version_major':current_major,
            'version_minor':current_minor,
            'plugin_version':plugin.version}
        if existing and (
            current_minor != minor or
            current_major != maj or
            current_super != sup or
            plugin.version != plugin_version):
            self.do_modify(self.plugin_info_table,existing,info)
        else:
            self.do_add(self.plugin_info_table,info)

    def run_hooks (self, hooks, *args):
        """A basic hook-running function. We use hooks to allow parts of the application
        to tag onto data-modifying events and e.g. update the display"""
        for h in hooks:
            t = TimeAction('running hook %s with args %s'%(h,args),3)
            h(*args)
            t.end()

    # basic DB access functions
    def fetch_all (self, table, sort_by=[], **criteria):
        return table.select(*make_simple_select_arg(criteria,table),
                            **{'order_by':make_order_by(sort_by,table)}
                            ).execute().fetchall()

    def fetch_one (self, table, **criteria):
        """Fetch one item from table and arguments"""
        return table.select(*make_simple_select_arg(criteria,table)).execute().fetchone()

    def fetch_count (self, table, column, sort_by=[],**criteria):
        """Return a counted view of the table, with the count stored in the property 'count'"""
        result =  sqlalchemy.select(
            [sqlalchemy.func.count(getattr(table.c,column)).label('count'),
             getattr(table.c,column)],
            *make_simple_select_arg(criteria,table),
            **{'group_by':column,
               'order_by':make_order_by(sort_by,table,count_by=column),
               }
            ).execute().fetchall()
        return result

    def fetch_len (self, table, **criteria):
        """Return the number of rows in table that match criteria
        """
        if criteria:
            return table.count(*make_simple_select_arg(criteria,table)).execute().fetchone()[0]
        else:
            return table.count().execute().fetchone()[0]

    def fetch_join (self, table1, table2, col1, col2,
                    column_names=None, sort_by=[], **criteria):
        if column_names:
            raise Exception("column_names KWARG NO LONGER SUPPORTED BY fetch_join!")
        return  table1.join(table2,getattr(table1.c,col1)==getattr(table2.c,col2)).select(
            *make_simple_select_arg(criteria,table1,table2)
            ).execute().fetchall()

    def fetch_food_groups_for_search (self, words):
        """Return food groups that match a given set of words."""
        where_statement = or_(
            *[self.nutrition_table.c.desc.like('%%%s%%'%w.lower())
              for w in words]
            )
        return [r[0] for r in sqlalchemy.select(
            [self.nutrition_table.c.foodgroup],
            where_statement,
            distinct=True).execute().fetchall()]

    def search_nutrition (self, words, group=None):
        """Search nutritional information for ingredient keys."""
        where_statement = and_(
            *[self.nutrition_table.c.desc.like('%%%s%%'%w)
              for w in words])
        if group:
            where_statement = and_(self.nutrition_table.c.foodgroup==group,
                                   where_statement)
        return self.nutrition_table.select(where_statement).execute().fetchall()

    def __get_joins (self, searches):
        joins = []
        for s in searches:
            if type(s)==tuple:
                joins.append(self.__get_joins(s[0]))
            else:
                if s['column'] == 'category':
                    if self.categories_table not in joins:
                        joins.append(self.categories_table,self.categories_table.c.id,
                                     self.recipe_table.c.id)
                elif s['column'] == 'ingredient':
                    if self.ingredients_table not in joins:
                        joins.append(self.ingredients_table)
        return joins

    def get_criteria (self,crit):
        if type(crit)==tuple:
            criteria,logic = crit
            if logic=='and':
                return and_(*[self.get_criteria(c) for c in criteria])
            elif logic=='or':
                return or_(*[self.get_criteria(c) for c in criteria])
        elif type(crit)!=dict: raise TypeError
        else:
            #join_crit = None # if we need to add an extra arg for a join
            if crit['column']=='category':
                subtable = self.categories_table
                col = subtable.c.category
            elif crit['column'] in ['ingkey','item']:
                subtable = self.ingredients_table
                col = getattr(subtable.c,crit['column'])
            elif crit['column']=='ingredient':
                d1 = crit.copy(); d1.update({'column':'ingkey'})
                d2 = crit.copy(); d2.update({'column':'item'}),
                return self.get_criteria(([d1,d2],
                                          'or'))
            elif crit['column']=='anywhere':
                searches = []
                for column in ['ingkey','item','category','cuisine','title','instructions','modifications',
                               'source','link']:
                    d = crit.copy(); d.update({'column':column})
                    searches.append(d)
                return self.get_criteria((searches,'or'))
            else:
                subtable = None
                col = getattr(self.recipe_table.c,crit['column'])
            # Make sure we're using unicode!
            if (type(crit.get('search',u'')) != unicode
                and type(crit.get('search',u'')) in types.StringTypes):
                crit['search'] = unicode(crit['search'])
            if crit.get('operator','LIKE')=='LIKE':
                retval = (col.like(crit['search']))
            elif crit['operator']=='REGEXP':
                retval = (col.op('REGEXP')(crit['search']))
            else:
                retval = (col==crit['search'])
            if subtable is not None:
                retval = self.recipe_table.c.id.in_(
                    sqlalchemy.select([subtable.c.recipe_id],retval)
                    )
            
            return retval

    def search_recipes (self, searches, sort_by=[]):
        """Search recipes for columns of values.

        "category" and "ingredient" are handled magically

        sort_by is a list of tuples (column,1) [ASCENDING] or (column,-1) [DESCENDING]
        """
        if 'rating' in [t[0] for t in sort_by]:
            i = [t[0] for t in sort_by].index('rating')
            d = (sort_by[i][1]==1 and -1 or 1)
            sort_by[i] = ('rating',d)
        criteria = self.get_criteria((searches,'and'))
        debug('backends.db.search_recipes - search criteria are %s'%searches,2)
        if 'category' in [s[0] for s in sort_by]:
            return sqlalchemy.select([c for c in self.recipe_table.c],# + [self.categories_table.c.category],
                                     criteria,distinct=True,
                                     from_obj=[sqlalchemy.outerjoin(self.recipe_table,self.categories_table)],
                                     order_by=make_order_by(sort_by,self.recipe_table,
                                                            join_tables=[self.categories_table])
                                     ).execute().fetchall()
        else:
            return sqlalchemy.select([self.recipe_table],criteria,distinct=True,
                                     order_by=make_order_by(sort_by,self.recipe_table,),
                                     ).execute().fetchall()

    def get_unique_values (self, colname,table=None,**criteria):
        """Get list of unique values for column in table."""
        if table is None: table=self.recipe_table
        if criteria: criteria = make_simple_select_arg(criteria,table)[0]
        else: criteria=None
        if colname=='category' and table==self.recipe_table:
            print 'WARNING: you are using a hack to access category values.'
            table = self.categories_table
            table = table.alias('ingrtable')
        retval = [r[0] for
                  r in sqlalchemy.select([getattr(table.c,colname)],distinct=True,whereclause=criteria).execute().fetchall()
                  ]
        return filter(lambda x: x is not None, retval) # Don't return null values

    def get_ingkeys_with_count (self, search={}):
        """Get unique list of ingredient keys and counts for number of times they appear in the database.
        """
        if search:
            col = getattr(self.ingredients_table.c,search['column'])
            operator = search.get('operator','LIKE')
            if operator=='LIKE':
                criteria = col.like(search['search'])
            elif operator=='REGEXP':
                criteria = col.op('REGEXP')(search['search'])
            else:
                criteria = col==crit['search']
            result =  sqlalchemy.select(
                [sqlalchemy.func.count(self.ingredients_table.c.ingkey).label('count'),
                 self.ingredients_table.c.ingkey],
                criteria,
                **{'group_by':'ingkey',
                   'order_by':make_order_by([],self.ingredients_table,count_by='ingkey'),
                   }
                ).execute().fetchall()                
        else:
            result =  sqlalchemy.select(
                [sqlalchemy.func.count(self.ingredients_table.c.ingkey).label('count'),
                 self.ingredients_table.c.ingkey],
                **{'group_by':'ingkey',
                   'order_by':make_order_by([],self.ingredients_table,count_by='ingkey'),
                   }
                ).execute().fetchall()

        return result

    def delete_by_criteria (self, table, criteria):
        """Table is our table.
        Criteria is a dictionary of criteria to delete by.
        """
        criteria = fix_colnames(criteria,table)
        delete_args = []
        for k,v in criteria.items():
            delete_args.append(k==v)
        if len(delete_args) > 1:
            delete_args = [and_(*delete_args)]
        table.delete(*delete_args).execute()

    def update_by_criteria (self, table, update_criteria, new_values_dic):
        try:
            to_del = []
            for k in new_values_dic:
                if type(k) != str:
                    to_del.append(k)
            for k in to_del:
                v = new_values_dic[k]
                del new_values_dic[k]
                new_values_dic[str(k)] = v
            table.update(*make_simple_select_arg(update_criteria,table)).execute(**new_values_dic)
        except:
            print 'update_by_criteria error...'
            print 'table:',table
            print 'UPDATE_CRITERIA:'
            for k,v in update_criteria.items(): print '','KEY:',k,'VAL:',v
            print 'NEW_VALUES_DIC:'
            for k,v in new_values_dic.items(): print '','KEY:',k,type(k),'VAL:',v
            raise

    def add_column_to_table (self, table, column_spec):
        """table is a table, column_spec is a tuple defining the
        column, following the format for new tables.
        """
        name = table.name; new_col = column_spec[0]; coltyp = column_spec[1]
        coltyp = coltyp.compile(dialect=self.db.dialect)
        sql = 'ALTER TABLE %(name)s ADD %(new_col)s %(coltyp)s;'%locals()
        try:
            self.db.execute(sql)
        except:
            print 'FAILED TO EXECUTE',sql
            print 'Ignoring error in add_column_to_table'
            import traceback; traceback.print_exc()

    def alter_table (self, table_name, setup_function, cols_to_change={}, cols_to_keep=[]):
        """Change table, moving some columns.

        table is the table object. table_name is the table
        name. setup_function is a function that will setup our correct
        table. cols_to_change is a dictionary of columns that are changing
        names (key=orig, val=new). cols_to_keep is a list of columns
        that should be copied over as is.

        This works by renaming our table to a temporary name, then
        recreating our initial table. Finally, we copy over table
        data and then delete our temporary table (i.e. our old table)

        This is much less efficient than an alter table command, but
        will allow us to e.g. change/add primary key columns to sqlite
        tables
        """
        print 'Attempting to alter ',table_name,setup_function,cols_to_change,cols_to_keep
        try:
            self.db.execute('ALTER TABLE %(t)s RENAME TO %(t)s_temp'%{'t':table_name})
        except:
            do_raise = True
            import traceback; traceback.print_exc()
            try:
                self.db.execute('DROP TABLE %(t)s_temp'%{'t':table_name})
            except:
                1
            else:
                do_raise = False
                self.db.execute('ALTER TABLE %(t)s RENAME TO %(t)s_temp'%{'t':table_name})
            if do_raise:
                raise 
        # SQLAlchemy >= 0.7 doesn't allow: del self.metadata.tables[table_name]
        self.metadata._remove_table(table_name, self.metadata.schema)
        setup_function()
        getattr(self,'%s_table'%table_name).create()
        TO_COLS = cols_to_keep[:]
        FROM_COLS = cols_to_keep[:]
        for fro,to_ in cols_to_change.items():
            FROM_COLS.append(fro)
            TO_COLS.append(to_)
        stmt = '''INSERT INTO %(t)s (%(to_cols)s)
        SELECT %(from_cols)s FROM %(t)s_temp
        '''%{'t':table_name,
             'from_cols':', '.join(FROM_COLS),
             'to_cols':', '.join(TO_COLS),
             }
        self.db.execute(stmt)        
        self.db.execute('DROP TABLE %s_temp'%table_name)

    # Metakit has no AUTOINCREMENT, so it has to do special magic here
    def increment_field (self, table, field):
        """Increment field in table, or return None if the DB will do
        this automatically.
        """
        return None


    def row_equal (self, r1, r2):
        """Test whether two row references are the same.

        Return True if r1 and r2 reference the same row in the database.
        """
        return r1==r2

    def find_duplicates (self, by='recipe',recipes=None, include_deleted=True):
        """Find all duplicate recipes by recipe or ingredient.

        Returns a nested list of IDs, where each nested list is a list
        of duplicates.

        This uses the recipe_hash and ingredient_hash respectively.
        To find only those recipes that have both duplicate recipe and
        ingredient hashes, use find_all_duplicates
        """
        if by=='recipe':
            col = self.recipe_table.c.recipe_hash
        elif by=='ingredient':
            col = self.recipe_table.c.ingredient_hash
        args = []
        if not include_deleted: args.append(self.recipe_table.c.deleted==False)
        kwargs = dict(having=sqlalchemy.func.count(col)>1,
                      group_by=col)
        duped_hashes = sqlalchemy.select([col],
                                         *args,
                                         **kwargs)
        query = sqlalchemy.select([self.recipe_table.c.id,col],
                                  include_deleted and col.in_(duped_hashes) or and_(col.in_(duped_hashes),
                                                                                    self.recipe_table.c.deleted==False),
                                  order_by=col).execute()
        recs_by_hash = {}
        for result in query.fetchall():
            rec_id = result[0]; hsh = result[1]
            if not recs_by_hash.has_key(hsh):
                recs_by_hash[hsh] = []
            recs_by_hash[hsh].append(rec_id)
        results = recs_by_hash.values()
        if recipes:
            rec_ids = [r.id for r in recipes]
            results = filter(lambda reclist: True in [(rid in rec_ids) for rid in reclist], results)
        return results

    def find_complete_duplicates (self, recipes=None, include_deleted=True):
        """Find all duplicate recipes (by recipe_hash and ingredient_hash)."""
        args = []
        if not include_deleted: args.append(self.recipe_table.c.deleted==False)
        
        ing_hashes,rec_hashes = [sqlalchemy.select([col],
                                                   *args,
                                                   **dict(having=sqlalchemy.func.count(col)>1,
                                                   group_by=col)
                                                   ) for col in [self.recipe_table.c.ingredient_hash,
                                                                 self.recipe_table.c.recipe_hash]
                             ]
        if not include_deleted: select_statements = [self.recipe_table.c.deleted==False]
        else: select_statements = []
        select_statements.append(self.recipe_table.c.ingredient_hash.in_(ing_hashes))
        select_statements.append(self.recipe_table.c.recipe_hash.in_(rec_hashes))

        query = sqlalchemy.select([self.recipe_table.c.id,
                                   self.recipe_table.c.recipe_hash,
                                   self.recipe_table.c.ingredient_hash],
                                  and_(*select_statements),
                                  order_by=[self.recipe_table.c.recipe_hash,
                                            self.recipe_table.c.ingredient_hash]).execute()
        recs_by_hash = {}
        for result in query.fetchall():
            rec_id = result[0]; rhsh = result[1]; ihsh = result[2]
            if not recs_by_hash.has_key((rhsh,ihsh)):
                recs_by_hash[(rhsh,ihsh)] = []
            recs_by_hash[(rhsh,ihsh)].append(rec_id)
        results = recs_by_hash.values()
        if recipes:
            rec_ids = [r.id for r in recipes]
            results = filter(lambda reclist: True in [(rid in rec_ids) for rid in reclist], results)
        return results
    
    # convenience DB access functions for working with ingredients,
    # recipes, etc.

    def delete_ing (self, ing):
        """Delete ingredient permanently."""
        self.delete_by_criteria(self.ingredients_table,
                                {'id':ing.id})

    def modify_rec (self, rec, dic):
        """Modify recipe based on attributes/values in dictionary.

        Return modified recipe.
        """
        self.validate_recdic(dic)        
        debug('validating dictionary',3)
        if dic.has_key('category'):
            newcats = dic['category'].split(', ')
            newcats = filter(lambda x: x, newcats) # Make sure our categories are not blank
            curcats = self.get_cats(rec)
            for c in curcats:
                if c not in newcats:
                    self.delete_by_criteria(self.categories_table,{'recipe_id':rec.id,'category':c})
            for c in newcats:
                if c not in curcats:
                    self.do_add_cat({'recipe_id':rec.id,'category':c})
            del dic['category']
        debug('do modify rec',3)
        retval = self.do_modify_rec(rec,dic)
        self.update_hashes(rec)
        return retval
    
    def validate_recdic (self, recdic):
        if not recdic.has_key('last_modified'):
            recdic['last_modified']=time.time()
        if recdic.has_key('image') and not recdic.has_key('thumb'):
            # if we have an image but no thumbnail, we want to create the thumbnail.
            try:
                img = ImageExtras.get_image_from_string(recdic['image'])
                thumb = ImageExtras.resize_image(img,40,40)
                ofi = StringIO.StringIO()
                thumb.save(ofi,'JPEG')
                recdic['thumb']=ofi.getvalue()
                ofi.close()
            except:
                del recdic['image']
                print """Warning: gourmet couldn't recognize the image.

                Proceding anyway, but here's the traceback should you
                wish to investigate.
                """
                import traceback
                traceback.print_stack()
        for k,v in recdic.items():
            try:
                recdic[k]=unicode(v.strip())
            except:
                pass

    def modify_ings (self, ings, ingdict):
        # allow for the possibility of doing a smarter job changing
        # something for a whole bunch of ingredients...
        for i in ings: self.modify_ing(i,ingdict)

    def modify_ing_and_update_keydic (self, ing, ingdict):
        """Update our key dictionary and modify our dictionary.

        This is a separate method from modify_ing because we only do
        this for hand-entered data, not for mass imports.
        """
        # If our ingredient has changed, update our keydic...
        if ing.item!=ingdict.get('item',ing.item) or ing.ingkey!=ingdict.get('ingkey',ing.ingkey):
            if ing.item and ing.ingkey:
                self.remove_ing_from_keydic(ing.item,ing.ingkey)
                self.add_ing_to_keydic(
                    ingdict.get('item',ing.item),
                    ingdict.get('ingkey',ing.ingkey)
                    )
        return self.modify_ing(ing,ingdict)
        
    def update_hashes (self, rec):
        rhash,ihash = recipeIdentifier.hash_recipe(rec,self)
        self.do_modify_rec(rec,{'recipe_hash':rhash,'ingredient_hash':ihash})

    def find_duplicates_of_rec (self, rec, match_ingredient=True, match_recipe=True):
        """Return recipes that appear to be duplicates"""
        if match_ingredient and match_recipe:
            perfect_matches = self.fetch_all(ingredient_hash=rec.ingredient_hash,recipe_hash=rec.recipe_hash)
        elif match_ingredient:
            perfect_matches = self.fetch_all(ingredient_hash=rec.ingredient_hash)
        else:
            perfect_matches = self.fetch_all(recipe_hash=rec.recipe_hash)
        matches = []
        if len(perfect_matches) == 1:
            return []
        else:
            for r in perfect_matches:
                if r.id != rec.id:
                    matches.append(r)
            return matches

    def find_all_duplicates (self):
        """Return a list of sets of duplicate recipes."""
        raise NotImplementedError

    def merge_mergeable_duplicates (self):
        """Merge all duplicates for which a simple merge is possible.
        For those recipes which can't be merged, return:
        [recipe-id-list,to-merge-dic,diff-dic]
        """
        dups = self.find_all_duplicates()
        unmerged = []
        for recs in dups:
            rec_objs = [self.fetch_one(self.recipe_table,id=r) for r in recs]
            merge_dic,diffs = recipeIdentifier.merge_recipes(self,rec_objs)
            if not diffs:
                if merge_dic:
                    self.modify_rec(rec_objs[0],merge_dic)
                for r in rec_objs[1:]: self.delete_rec(r)
            else:
                unmerged.append([recs,merge_dic,diffs])
        return unmerged
    
    def modify_ing (self, ing, ingdict):
        self.validate_ingdic(ingdict)
        return self.do_modify_ing(ing,ingdict)

    def add_rec (self, dic, accept_ids=False):
        """Dictionary is a dictionary of column values for our recipe.
        Return the ID of the newly created recipe.

        If accept_ids is True, we accept recipes with IDs already
        set. These IDs need to have been reserved with the new_id()
        method.
        """
        cats = []
        if dic.has_key('category'):
            cats = dic['category'].split(', ')
            del dic['category']
        if dic.has_key('servings'):
            if dic.has_key('yields'):
                del dic['yields']
            else:
                try:
                    dic['servings'] = float(dic['servings'])
                    dic['yields'] = dic['servings']
                    dic['yield_unit'] = 'servings'
                    del dic['servings']
                except:
                    del dic['servings']
        if not dic.has_key('deleted'): dic['deleted']=False
        self.validate_recdic(dic)
        try:
            ret = self.do_add_rec(dic)
        except:
            print 'Problem adding recipe with dictionary...'
            for k,v in dic.items(): print 'KEY:',k,'of type',type(k),'VALUE:',v,'of type',type(v)
            raise
        else:
            if type(ret)==int:
                ID = ret
                ret = self.get_rec(ID) 
            else:
                ID = ret.id
            for c in cats:
                if c: self.do_add_cat({'recipe_id':ID,'category':c})
            self.update_hashes(ret)
            return ret

    def add_ing_and_update_keydic (self, dic):
        if dic.has_key('item') and dic.has_key('ingkey') and dic['item'] and dic['ingkey']:
            self.add_ing_to_keydic(dic['item'],dic['ingkey'])
        return self.add_ing(dic)
    
    def add_ing (self, dic):
        self.validate_ingdic(dic)
        try:          
            return self.do_add_ing(dic)
        except:
            print 'Problem adding',dic
            raise

    def add_ings (self, dics):
        """Add multiple ingredient dictionaries at a time."""
        for d in dics:
            self.validate_ingdic(d)
            for k in ['refid','unit','amount','rangeamount','item','ingkey','optional','shopoptional','inggroup','position']:
                if not k in d:
                    d[k] = None
        try:
            # Warning: this method relies on all the dictionaries
            # looking identical. validate_ingdic should be taking care
            # of this for us now, but if parameters change in the
            # future, this rather subtle bug could well rear its ugly
            # head again.
            rp = self.ingredients_table.insert().execute(*dics)
        except ValueError:
            for d in dics: self.coerce_types(self.ingredients_table,d)
            self.ingredients_table.insert().execute(*dics)

    # Lower level DB access functions -- hopefully subclasses can
    # stick to implementing these    

    def coerce_types (self, table, dic):
        """Modify dic to make sure types are correct for table.
        """
        type_to_pytype = {Float:float,
                          Integer:int,
                          String:str,
                          Boolean:bool,
                          Numeric:float,
                          }
        for k,v in dic.copy().items():
            column_obj = getattr(table.c,k)
            if column_obj.type.__class__ in type_to_pytype:
                try:
                    v = type_to_pytype[column_obj.type.__class__](v)
                except:
                    v = None
                if dic[k] != v:
                    dic[k] = v

    def commit_fast_adds (self):
        if hasattr(self,'extra_connection'):
            self.extra_connection.commit()

    def do_add_fast (self, table, dic):
        '''Add fast -- return None'''
        if not hasattr(self,'extra_connection'):
            self.extra_connection = self.db.connect().connection
        try:
            tname = table.name
            SQL = 'INSERT INTO ' + tname + '('+', '.join(dic.keys()) + ')'
            SQL += ' VALUES (' +  ", ".join(['?']*len(dic)) + ')'
            self.extra_connection.execute(SQL,dic.values())
        except:
            return self.do_add(table,dic)

    def do_add (self, table, dic):
        insert_statement = table.insert()
        self._force_unicode(dic)
        try:
            result_proxy = insert_statement.execute(**dic)
        except ValueError:
            print 'Had to coerce types',table,dic
            self.coerce_types(table,dic)
            result_proxy = insert_statement.execute(**dic)
        return result_proxy

    def do_add_and_return_item (self, table, dic, id_prop='id'):
        result_proxy = self.do_add(table,dic)
        select = table.select(getattr(table.c,id_prop)==result_proxy.inserted_primary_key[0])
        return select.execute().fetchone()

    def do_add_ing (self,dic):
        return self.do_add_and_return_item(self.ingredients_table,dic,id_prop='id')

    def do_add_cat (self, dic):
        return self.do_add_and_return_item(self.categories_table,dic)

    def do_add_rec (self, rdict):
        """Add a recipe based on a dictionary of properties and values."""
        self.changed=True
        if not rdict.has_key('deleted'):
            rdict['deleted']=0
        if rdict.has_key('id'):
            # If our dictionary has an id, then we assume we are a
            # reserved ID
            if rdict['id'] in self.new_ids:
                rid = rdict['id']; del rdict['id']
                self.new_ids.remove(rid)
                self.update_by_criteria(self.recipe_table,
                                        {'id':rid},
                                        rdict)
                return self.recipe_table.select(self.recipe_table.c.id==rid).execute().fetchone()
            else:
                raise ValueError('New recipe created with preset id %s, but ID is not in our list of new_ids'%rdict['id'])
        insert_statement = self.recipe_table.insert()
        select = self.recipe_table.select(self.recipe_table.c.id==insert_statement.execute(**rdict).inserted_primary_key[0])
        return select.execute().fetchone()

    def validate_ingdic (self,dic):
        """Do any necessary validation and modification of ingredient dictionaries."""
        if not dic.has_key('deleted'): dic['deleted']=False
        self._force_unicode(dic)

    def _force_unicode (self, dic):
       for k,v in dic.items():
            if type(v)==str and k not in ['image','thumb']:
                # force unicode...
                dic[k]=unicode(v) 
                
    def do_modify_rec (self, rec, dic):
        """This is what other DBs should subclass."""
        return self.do_modify(self.recipe_table,rec,dic)

    def do_modify_ing (self, ing, ingdict):
        """modify ing based on dictionary of properties and new values."""
        return self.do_modify(self.ingredients_table,ing,ingdict)

    def do_modify (self, table, row, d, id_col='id'):
        if id_col:
            try:
                self._force_unicode(d)
                qr = table.update(getattr(table.c,id_col)==getattr(row,id_col)).execute(**d)
            except:
                print 'do_modify failed with args'
                print 'table=',table,'row=',row
                print 'd=',d,'id_col=',id_col
                raise
            select = table.select(getattr(table.c,id_col)==getattr(row,id_col))
        else:
            qr = table.update().execute(**d)
            select = table.select()
        return select.execute().fetchone()

    def get_ings (self, rec):
        """Handed rec, return a list of ingredients.

        rec should be an ID or an object with an attribute ID)"""
        if hasattr(rec,'id'):
            id=rec.id
        else:
            id=rec
        return self.fetch_all(self.ingredients_table,recipe_id=id,deleted=False)

    def get_cats (self, rec):
        svw = self.fetch_all(self.categories_table,recipe_id=rec.id)
        cats =  [c.category or '' for c in svw]
        # hackery...
        while '' in cats:
            cats.remove('')
        return cats

    def get_referenced_rec (self, ing):
        """Get recipe referenced by ingredient object."""
        if hasattr(ing,'refid') and ing.refid:
            rec = self.get_rec(ing.refid)
            if rec: return rec
        # otherwise, our reference is no use! Something's been
        # foobared. Unfortunately, this does happen, so rather than
        # screwing our user, let's try to look based on title/item
        # name (the name of the ingredient *should* be the title of
        # the recipe, though the user could change this)
        if hasattr(ing,'item'):
            rec = self.fetch_one(self.recipe_table,**{'title':ing.item})
            if rec:
                self.modify_ing(ing,{'refid':rec.id})
                return rec
            else:
                print 'Very odd: no match for',ing,'refid:',ing.refid

    def include_linked_recipes (self, recs):
        '''Handed a list of recipes, append any recipes that are
        linked as ingredients in those recipes to the list.

        Modifies the list in place.
        '''
        import sqlalchemy
        ids = [r.id for r in recs]
        extra_ings = self.ingredients_table.select(and_(
                self.ingredients_table.c.refid,
                self.ingredients_table.c.recipe_id.in_(ids)
                )
                                                  ).execute().fetchall()
        for i in extra_ings:
            if i.refid not in ids:
                recs.append(self.get_referenced_rec(i))
                
    def get_rec (self, id, recipe_table=None):
        """Handed an ID, return a recipe object."""
        if recipe_table:
            print 'handing get_rec an recipe_table is deprecated'
            print 'Ignoring recipe_table handed to get_rec'
        recipe_table=self.recipe_table
        return self.fetch_one(self.recipe_table, id=id)

    def delete_rec (self, rec):
        """Delete recipe object rec from our database."""
        if type(rec)!=int: rec=rec.id
        debug('deleting recipe ID %s'%rec,0)
        self.delete_by_criteria(self.recipe_table,{'id':rec})
        self.delete_by_criteria(self.categories_table,{'recipe_id':rec})
        self.delete_by_criteria(self.ingredients_table,{'recipe_id':rec})
        debug('deleted recipe ID %s'%rec,0)

    def new_rec (self):
        """Create and return a new, empty recipe"""
        blankdict = {'title':_('New Recipe'),
                     #'servings':'4'}
                     }
        return self.add_rec(blankdict)

    def new_id (self):
        #raise NotImplementedError("WARNING: NEW_ID IS NO LONGER FUNCTIONAL, FIND A NEW WAY AROUND THE PROBLEM")
        #rec = self.new_rec()
        rec = self.do_add_rec({'deleted':1})
        self.new_ids.append(rec.id)
        return rec.id
    
    # Convenience functions for dealing with ingredients

    def order_ings (self, ings):
        """Handed a view of ingredients, we return an alist:
        [['group'|None ['ingredient1', 'ingredient2', ...]], ... ]
        """
        defaultn = 0
        groups = {}
        group_order = {}
        n = 0; group = 0
        for i in ings:
            # defaults
            if not hasattr(i,'inggroup'):
                group = None
            else:
                group=i.inggroup
            if group == None:
                group = n; n+=1
            if not hasattr(i,'position'):
                print 'Bad: ingredient without position',i
                i.position=defaultn
                defaultn += 1
            if groups.has_key(group): 
                groups[group].append(i)
                # the position of the group is the smallest position of its members
                # in other words, positions pay no attention to groups really.
                if i.position < group_order[group]: group_order[group]=i.position
            else:
                groups[group]=[i]
                group_order[group]=i.position
        # now we just have to sort an i-listify
        def sort_groups (x,y):
            if group_order[x[0]] > group_order[y[0]]: return 1
            elif group_order[x[0]] == group_order[y[0]]: return 0
            else: return -1
        alist=groups.items()
        alist.sort(sort_groups)
        def sort_ings (x,y):
            if x.position > y.position: return 1
            elif x.position == y.position: return 0
            else: return -1
        for g,lst in alist:
            lst.sort(sort_ings)
        final_alist = []
        last_g = -1
        for g,ii in alist:
            if type(g)==int:
                if last_g == None:
                    final_alist[-1][1].extend(ii)
                else:
                    final_alist.append([None,ii])
                last_g = None
            else:
                final_alist.append([g,ii])
                last_g = g
        return final_alist

    def replace_ings (self, ingdicts):
        """Add a new ingredients and remove old ingredient list."""
        ## we assume (hope!) all ingdicts are for the same ID
        id=ingdicts[0]['id']
        debug("Deleting ingredients for recipe with ID %s"%id,1)
        self.delete_by_criteria(self.ingredients_table,{'id':id})
        for ingd in ingdicts:
            self.add_ing(ingd)
    
    def ingview_to_lst (self, view):
        """Handed a view of ingredient data, we output a useful list.
        The data we hand out consists of a list of tuples. Each tuple contains
        amt, unit, key, alternative?"""
        ret = []
        for i in view:
            ret.append([self.get_amount(i), i.unit, i.ingkey,])
        return ret

    def get_amount (self, ing, mult=1):
        """Given an ingredient object, return the amount for it.

        Amount may be a tuple if the amount is a range, a float if
        there is a single amount, or None"""
        amt=getattr(ing,'amount')
        try:
            ramt = getattr(ing,'rangeamount')
        except:
            # this blanket exception is here for our lovely upgrade
            # which requires a working export with an out-of-date DB
            ramt = None
        if mult != 1:
            if amt: amt = amt * mult
            if ramt: ramt = ramt * mult
        if ramt:
            return (amt,ramt)
        else:
            return amt

    @pluggable_method
    def get_amount_and_unit (self, ing, mult=1, conv=None, fractions=None, adjust_units=False,
                             favor_current_unit=True,preferred_unit_groups=[]):
        """Return a tuple of strings representing our amount and unit.
        
        If we are handed a converter interface, we will adjust the
        units to make them readable.
        """
        amt = self.get_amount(ing,mult)
        unit = ing.unit
        ramount = None
        if type(amt)==tuple: amt,ramount = amt
        if adjust_units or preferred_unit_groups:
            if not conv:
                conv = convert.get_converter()
            amt,unit = conv.adjust_unit(amt,unit,
                                        favor_current_unit=favor_current_unit,
                                        preferred_unit_groups=preferred_unit_groups)
            if ramount and unit != ing.unit:
                # if we're changing units... convert the upper range too
                ramount = ramount * conv.converter(ing.unit, unit)
        if ramount: amt = (amt,ramount)
        return (self._format_amount_string_from_amount(amt,fractions=fractions,unit=unit),unit)
        
    def get_amount_as_string (self,
                              ing,
                              mult=1,
                              fractions=None,
                              ):
        """Return a string representing our amount.
        If we have a multiplier, multiply the amount before returning it.        
        """
        amt = self.get_amount(ing,mult)
        return self._format_amount_string_from_amount(amt, fractions=fractions)

    def _format_amount_string_from_amount (self, amt, fractions=None, unit=None):
        """Format our amount string given an amount tuple.

        If fractions is None, we use the default setting from
        convert.USE_FRACTIONS. Otherwise, we will override that
        setting.
        
        If you're thinking of using this function from outside, you
        should probably just use a convenience function like
        get_amount_as_string or get_amount_and_unit
        """
        if fractions is None:
            # None means use the default value
            fractions = convert.USE_FRACTIONS
        if unit:
            approx = defaults.unit_rounding_guide.get(unit,0.01)
        else:
            approx = 0.01
        if type(amt)==tuple:
            return "%s-%s"%(convert.float_to_frac(amt[0],fractions=fractions,approx=approx).strip(),
                            convert.float_to_frac(amt[1],fractions=fractions,approx=approx).strip())
        elif type(amt) in (float,int):
            return convert.float_to_frac(amt,fractions=fractions,approx=approx)
        else: return ""

    def get_amount_as_float (self, ing, mode=1): #1 == self.AMT_MODE_AVERAGE
        """Return a float representing our amount.

        If we have a range for amount, this function will ignore the range and simply
        return a number.  'mode' specifies how we deal with the mode:
        self.AMT_MODE_AVERAGE means we average the mode (our default behavior)
        self.AMT_MODE_LOW means we use the low number.
        self.AMT_MODE_HIGH means we take the high number.
        """
        amt = self.get_amount(ing)
        if type(amt) in [float, int, type(None)]:
            return amt
        else:
            # otherwise we do our magic
            amt=list(amt)
            amt.sort() # make sure these are in order
            low,high=amt
            if mode==self.AMT_MODE_AVERAGE: return (low+high)/2.0
            elif mode==self.AMT_MODE_LOW: return low
            elif mode==self.AMT_MODE_HIGH: return high # mode==self.AMT_MODE_HIGH
            else:
                raise ValueError("%s is an invalid value for mode"%mode)

    @pluggable_method
    def add_ing_to_keydic (self, item, key):
        #print 'add ',item,key,'to keydic'
        # Make sure we have unicode...
        if type(item)==str: item = unicode(item)
        if type(key)==str: key = unicode(key)
        if not item or not key: return
        else:
            if item: item = unicode(item)
            if key: key = unicode(key)
        row = self.fetch_one(self.keylookup_table, item=item, ingkey=key)
        if row:
            self.do_modify(self.keylookup_table,row,{'count':row.count+1})
        else:
            self.do_add(self.keylookup_table,{'item':item,'ingkey':key,'count':1})
        # The below code should move to a plugin for users who care about ingkeys...
        for w in item.split():
            w=str(w.decode('utf8').lower())
            row = self.fetch_one(self.keylookup_table,word=unicode(w),ingkey=unicode(key))
            if row:
                self.do_modify(self.keylookup_table,row,{'count':row.count+1})
            else:
                self.do_add(self.keylookup_table,{'word':unicode(w),'ingkey':unicode(key),'count':1})

    def remove_ing_from_keydic (self, item, key):
        #print 'remove ',item,key,'to keydic'        
        row = self.fetch_one(self.keylookup_table,item=item,ingkey=key)
        if row:
            new_count = row.count - 1
            if new_count:
                self.do_modify(self.keylookup_table,row,{'count':new_count})
            else:
                self.delete_by_criteria(self.keylookup_table,{'item':item,'ingkey':key})
        for w in item.split():
            w=str(w.decode('utf8').lower())
            row = self.fetch_one(self.keylookup_table,item=item,ingkey=key)
            if row:
                new_count = row.count - 1
                if new_count:
                    self.do_modify(self.keylookup_table,row,{'count':new_count})
                else:
                    self.delete_by_criteria(self.keylookup_table,{'word':w,'ingkey':key})

    def ing_shopper (self, view):
        return DatabaseShopper(self.ingview_to_lst(view))

    # functions to undoably modify tables 

    def get_dict_for_obj (self, obj, keys):
        orig_dic = {}
        for k in keys:
            if k=='category':
                v = ", ".join(self.get_cats(obj))
            else:
                v=getattr(obj,k)
            orig_dic[k]=v
        return orig_dic

    def undoable_modify_rec (self, rec, dic, history=[], get_current_rec_method=None,
                             select_change_method=None):
        """Modify our recipe and remember how to undo our modification using history."""
        orig_dic = self.get_dict_for_obj(rec,dic.keys())
        reundo_name = "Re_apply"
        reapply_name = "Re_apply "
        reundo_name += string.join(["%s <i>%s</i>"%(k,v) for k,v in orig_dic.items()])
        reapply_name += string.join(["%s <i>%s</i>"%(k,v) for k,v in dic.items()])
        redo,reundo=None,None
        if get_current_rec_method:
            def redo (*args):
                r=get_current_rec_method()
                odic = self.get_dict_for_obj(r,dic.keys())
                return ([r,dic],[r,odic])
            def reundo (*args):
                r = get_current_rec_method()
                odic = self.get_dict_for_obj(r,orig_dic.keys())
                return ([r,orig_dic],[r,odic])

        def action (*args,**kwargs):
            """Our actual action allows for selecting changes after modifying"""
            self.modify_rec(*args,**kwargs)
            if select_change_method:
                select_change_method(*args,**kwargs)
                
        obj = Undo.UndoableObject(action,action,history,
                                  action_args=[rec,dic],undo_action_args=[rec,orig_dic],
                                  get_reapply_action_args=redo,
                                  get_reundo_action_args=reundo,
                                  reapply_name=reapply_name,
                                  reundo_name=reundo_name,)
        obj.perform()

    def undoable_delete_recs (self, recs, history, make_visible=None):
        """Delete recipes by setting their 'deleted' flag to True and add to UNDO history."""
        def do_delete ():
            for rec in recs:
                debug('rec %s deleted=True'%rec.id,1)
                self.modify_rec(rec,{'deleted':True})
            if make_visible: make_visible(recs)
        def undo_delete ():
            for rec in recs:
                debug('rec %s deleted=False'%rec.id,1)
                self.modify_rec(rec,{'deleted':False})
            if make_visible: make_visible(recs)
        obj = Undo.UndoableObject(do_delete,undo_delete,history)
        obj.perform()

    def undoable_modify_ing (self, ing, dic, history, make_visible=None):
        """modify ingredient object ing based on a dictionary of properties and new values.

        history is our undo history to be handed to Undo.UndoableObject
        make_visible is a function that will make our change (or the undo or our change) visible.
        """
        orig_dic = self.get_dict_for_obj(ing,dic.keys())
        key = dic.get('ingkey',None)
        item = key and dic.get('item',ing.item)
        def do_action ():
            debug('undoable_modify_ing modifying %s'%dic,2)
            self.modify_ing(ing,dic)
            if key:
                self.add_ing_to_keydic(item,key)
            if make_visible: make_visible(ing,dic)
        def undo_action ():
            debug('undoable_modify_ing unmodifying %s'%orig_dic,2)
            self.modify_ing(ing,orig_dic)
            if key:
                self.remove_ing_from_keydic(item,key)
            if make_visible: make_visible(ing,orig_dic)
        obj = Undo.UndoableObject(do_action,undo_action,history)
        obj.perform()
        
    def undoable_delete_ings (self, ings, history, make_visible=None):
        """Delete ingredients in list ings and add to our undo history."""
        def do_delete():
            modded_ings = [self.modify_ing(i,{'deleted':True}) for i in ings]
            if make_visible:
                make_visible(modded_ings)
        def undo_delete ():
            modded_ings = [self.modify_ing(i,{'deleted':False}) for i in ings]
            if make_visible: make_visible(modded_ings)
        obj = Undo.UndoableObject(do_delete,undo_delete,history)
        obj.perform()
    
    def get_default_values (self, colname):
        try:
            return defaults.fields[colname]
        except:
            return []

    
class RecipeManager (RecData):
    
    def __init__ (self,*args,**kwargs):
        debug('recipeManager.__init__()',3)
        RecData.__init__(self,*args,**kwargs)
        #self.km = keymanager.KeyManager(rm=self)
        self.km = keymanager.get_keymanager(rm=self)
        
    def key_search (self, ing):
        """Handed a string, we search for keys that could match
        the ingredient."""
        result=self.km.look_for_key(ing)
        if type(result)==type(""):
            return [result]
        elif type(result)==type([]):
            # look_for contains an alist of sorts... we just want the first
            # item of every cell.
            if len(result)>0 and result[0][1]>0.8:
                return map(lambda a: a[0],result)
            else:
                ## otherwise, we make a mad attempt to guess!
                k=self.km.generate_key(ing)
                l = [k]
                l.extend(map(lambda a: a[0],result))
                return l
        else:
            return None

    def parse_ingredient (self, s, conv=None, get_key=True):
        """Handed a string, we hand back a dictionary representing a parsed ingredient (sans recipe ID)"""
        #if conv:
        #    print 'parse_ingredient: conv argument is now ignored'
        debug('ingredient_parser handed: %s'%s,0)
        # Strip whitespace and bullets...
        d={}
        s = s.decode('utf8').strip(
            u'\u2022\u2023\u2043\u204C\u204D\u2219\u25C9\u25D8\u25E6\u2619\u2765\u2767\u29BE\u29BF\n\t #*+-')
        s = unicode(s)
        option_m = re.match('\s*optional:?\s*',s,re.IGNORECASE)
        if option_m:
            s = s[option_m.end():]
            d['optional']=True
        debug('ingredient_parser handed: "%s"'%s,1)
        m=convert.ING_MATCHER.match(s)
        if m:
            debug('ingredient parser successfully parsed %s'%s,1)
            a,u,i=(m.group(convert.ING_MATCHER_AMT_GROUP),
                   m.group(convert.ING_MATCHER_UNIT_GROUP),
                   m.group(convert.ING_MATCHER_ITEM_GROUP))
            if a:
                asplit = convert.RANGE_MATCHER.split(a)
                if len(asplit)==2:
                    d['amount']=convert.frac_to_float(asplit[0].strip())
                    d['rangeamount']=convert.frac_to_float(asplit[1].strip())
                else:
                    d['amount']=convert.frac_to_float(a.strip())
            if u:
                conv = convert.get_converter()
                if conv and conv.unit_dict.has_key(u.strip()):
                    # Don't convert units to our units!
                    d['unit']=u.strip()
                else:
                    # has this unit been used
                    prev_uses = self.fetch_all(self.ingredients_table,unit=u.strip())
                    if prev_uses:
                        d['unit']=u
                    else:
                        # otherwise, unit is not a unit
                        i = u + ' ' + i
            if i:
                optmatch = re.search('\s+\(?[Oo]ptional\)?',i)
                if optmatch:
                    d['optional']=True
                    i = i[0:optmatch.start()] + i[optmatch.end():]
                d['item']=i.strip()
                if get_key: d['ingkey']=self.km.get_key(i.strip())
            debug('ingredient_parser returning: %s'%d,0)
            return d
        else:
            debug("Unable to parse %s"%s,0)
            d['item'] = s
            return d
        
    ingredient_parser = parse_ingredient

    def ing_search (self, ing, keyed=None, recipe_table=None, use_regexp=True, exact=False):
        """Search for an ingredient."""
        if not recipe_table: recipe_table = self.recipe_table
        vw = self.joined_search(recipe_table,self.ingredients_table,'ingkey',ing,use_regexp=use_regexp,exact=exact)
        if not keyed:
            vw2 = self.joined_search(recipe_table,self.ingredients_table,'item',ing,use_regexp=use_regexp,exact=exact)
            if vw2 and vw:
                vw = vw.union(vw2)
            else: vw = vw2
        return vw

    def joined_search (self, table1, table2, search_by, search_str, use_regexp=True, exact=False, join_on='id'):
        raise NotImplementedError
    
    def ings_search (self, ings, keyed=None, recipe_table=None, use_regexp=True, exact=False):
        """Search for multiple ingredients."""
        raise NotImplementedError

    def clear_remembered_optional_ings (self, recipe=None):
        """Clear our memories of optional ingredient defaults.

        If handed a recipe, we clear only for the recipe we've been
        given.

        Otherwise, we clear *all* recipes.
        """
        if recipe:
            vw = self.get_ings(recipe)
        else:
            vw = self.ingredients_table
        # this is ugly...
        vw1 = vw.select(shopoptional=1)
        vw2 = vw.select(shopoptional=2)
        for v in vw1,vw2:
            for i in v: self.modify_ing(i,{'shopoptional':0})

class DatabaseConverter(convert.Converter):
    def __init__ (self, db):
        self.db = db
        convert.converter.__init__(self)
    ## FIXME: still need to finish this class and then
    ## replace calls to convert.converter with
    ## calls to DatabaseConverter

    def create_conv_table (self):
        self.conv_table = dbDic('ckey','value',self.db.convtable_table, self.db)
        for k,v in defaults.CONVERTER_TABLE.items():
            if not self.conv_table.has_key(k):
                self.conv_table[k]=v

    def create_density_table (self):
        self.density_table = dbDic('dkey','value',
                                   self.db.density_table,self.db)
        for k,v in defaults.DENSITY_TABLE.items():
            if not self.density_table.has_key(k):
                self.density_table[k]=v

    def create_cross_unit_table (self):
        self.cross_unit_table=dbDic('cukey','value',self.db.crossunitdict_table,self.db)
        for k,v in defaults.CROSS_UNIT_TABLE:
            if not self.cross_unit_table.has_key(k):
                self.cross_unit_table[k]=v

    def create_unit_dict (self):
        self.units = defaults.UNITS
        self.unit_dict=dbDic('ukey','value',self.db.unitdict_table,self.db)
        for itm in self.units:
            key = itm[0]
            variations = itm[1]
            self.unit_dict[key] = key
            for v in variations:
                self.unit_dict[v] = key
                
class dbDic:
    def __init__ (self, keyprop, valprop, view, db):
        """Create a dictionary interface to a database table."""
        self.vw = view
        self.kp = keyprop
        self.vp = valprop
        self.db = db
        self.just_got = {}

    def has_key (self, k):
        try:
            self.just_got = {k:self.__getitem__(k)}
            return True
        except:
            try:
                self.__getitem__(k)
                return True
            except:
                return False
        
    def __setitem__ (self, k, v):
        store_v = v
        row = self.db.fetch_one(self.vw,**{self.kp:k})
        if row:
            self.db.do_modify(self.vw, row, {self.vp:store_v},id_col=self.kp)
        else:
            self.db.do_add(self.vw,{self.kp:k,self.vp:store_v})
        self.db.changed=True
        return v

    def __getitem__ (self, k):
        if self.just_got.has_key(k): return self.just_got[k]
        v = getattr(self.db.fetch_one(self.vw,**{self.kp:k}),self.vp)
        return v
    
    def __repr__ (self):
        retstr = "<dbDic> {"
        #for i in self.vw:
        #    retstr += getattr(i,self.kp)
        #    retstr += ":"
        #    retstr += "%s"%getattr(i,self.vp)
        #    retstr += ", "
        retstr += "}"
        return retstr

    def initialize (self, d):
        '''Initialize values based on dictionary d

        We assume the DB is known to be empty.

        '''
        dics = []
        for k in d:
            store_v = d[k]
            if type(store_v) in types.StringTypes:
                store_v = unicode(store_v)
            if type(k) in types.StringTypes:
                k = unicode(k)
            dics.append({self.kp:k,self.vp:store_v})
        self.vw.insert().execute(*dics)

    def keys (self):
        ret = []
        for i in self.db.fetch_all(self.vw):
            ret.append(getattr(i,self.kp))
        return ret

    def values (self):
        ret = []
        for i in self.db.fetch_all(self.vw):
            val = getattr(i,self.vp)
            ret.append(val)
        return ret

    def items (self):
        ret = []
        for i in self.db.fetch_all(self.vw):
            try:
                key = getattr(i,self.kp)
                val = getattr(i,self.vp)
            except:
                print 'TRYING TO GET',self.kp,self.vp,'from',self.vw
                print 'ERROR!!!'
                import traceback; traceback.print_exc()
                print 'IGNORING'
                continue
            ret.append((key,val))
        return ret

# To change
# fetch_one -> use whatever syntax sqlalchemy uses throughout
# fetch_all ->
#recipe_table -> recipe_table
# To eliminate

def test_db ():
    import tempfile
    db = RecData(file=tempfile.mktemp())
    print 'BEGIN TESTING'
    from db_tests import test_db
    test_db(db)
    print 'END TESTING'

def add_sample_recs ():
    for rec,ings in [[dict(title='Spaghetti',cuisine='Italian',category='Easy, Entree'),
                      [dict(amount=1,unit='jar',item='Marinara Sauce',ingkey='sauce, marinara'),
                       dict(amount=0.25,unit='c.',item='Parmesan Cheese',ingkey='cheese, parmesan'),
                       dict(amount=.5,unit='lb.',item='Spaghetti',ingkey='spaghetti, dried')]],
                     [dict(title='Spaghetti w/ Meatballs',cuisine='Italian',category='Easy, Entree'),
                      [dict(amount=1,unit='jar',item='Marinara Sauce',ingkey='sauce, marinara'),
                       dict(amount=0.25,unit='c.',item='Parmesan Cheese',ingkey='cheese, parmesan'),
                       dict(amount=.5,unit='lb.',item='Spaghetti',ingkey='spaghetti, dried'),
                       dict(amount=0.5,unit='lb.',item='Meatballs',ingkey='Meatballs, prepared'),
                       ]],
                     [dict(title='Toasted cheese',cuisine='American',category='Sandwich, Easy',
                           servings=2),
                      [dict(amount=2,unit='slices',item='bread'),
                       dict(amount=2,unit='slices',item='cheddar cheese'),
                       dict(amount=2,unit='slices',item='tomato')]]
                     ]:
        r = db.add_rec(rec)
        for i in ings:
            i['recipe_id']=r.id
            db.add_ing(i)

def get_database (*args,**kwargs):
    try:
        return RecData(*args,**kwargs)
    except RecData, rd:
        return rd

if __name__ == '__main__':
    db = RecData()

########NEW FILE########
__FILENAME__ = test_db
import tempfile, unittest
import db

class DBTest (unittest.TestCase):
    def setUp (self):
        tmpfile = tempfile.mktemp()
        self.db = db.get_database(file=tmpfile)

class testRecBasics (DBTest):
    def runTest (self):
        self.assertEqual(self.db.fetch_len(self.db.recipe_table),0)        
        rec = self.db.add_rec({'title':'Fooboo'})
        self.assertEqual(rec.title,'Fooboo')
        rec2 = self.db.new_rec()
        rec2 = self.db.modify_rec(rec2,{'title':'Foo','cuisine':'Bar'})
        self.assertEqual(rec2.title,'Foo')
        self.assertEqual(rec2.cuisine,'Bar')
        self.db.delete_rec(rec)
        self.db.delete_rec(rec2)
        self.assertEqual(self.db.fetch_len(self.db.recipe_table),0)

class testIngBasics (DBTest):

    def testAddIngs (self):
        rid = self.db.new_rec().id
        ing = self.db.add_ing({'amount':1,
                          'unit':'c.',
                          'item':'Carrot juice',
                          'ingkey':'juice, carrot',
                          'recipe_id':rid
                          })
        ing2 = self.db.add_ing({'amount':2,
                       'unit':'c.',
                      'item':'Tomato juice',
                      'ingkey':'juice, tomato',
                      'recipe_id':rid
                       })
        self.assertEqual(len(self.db.get_ings(rid)),2)
        ing = self.db.modify_ing(ing,{'amount':2})
        self.assertEqual(ing.amount,2)
        ing = self.db.modify_ing(ing,{'unit':'cup'})    
        self.assertEqual(ing.unit,'cup')
        self.db.delete_ing(ing)
        self.db.delete_ing(ing2)
        self.assertEqual(self.db.fetch_len(self.db.ingredients_table),0)
        self.db.add_ings([
                {'rangeamount': None, 'item': 'water', 'recipe_id': rid, 'position': 1, 'ingkey': u'water'},                
                {'rangeamount': None, 'item': 'linguine', 'amount': 0.5, 'recipe_id': rid, 'position': 1, 'ingkey': u'linguine', 'unit': 'pound'}
             ]
                         )
        ings = self.db.get_ings(rid)
        self.assertEqual(ings[1].unit,'pound')
        self.assertEqual(ings[1].amount,0.5)        

    def testUnique (self):
        self.db.delete_by_criteria(self.db.ingredients_table,{}) # Clear out ingredients
        for i in ['juice, tomato',
                  'broccoli',
                  'spinach',
                  'spinach',
                  'spinach',]:
            self.db.add_ing({'amount':1,'unit':'c.','item':i,'ingkey':i})
        vv=self.db.get_unique_values('ingkey',self.db.ingredients_table)
        assert(len(vv)==3)
        cvw = self.db.fetch_count(self.db.ingredients_table,'ingkey',ingkey='spinach',sort_by=[('count',-1)])
        assert(cvw[0].count==3)    
        assert(cvw[0].ingkey=='spinach')

class testSearch (DBTest):
    def runTest (self):
        self.db.delete_by_criteria(self.db.ingredients_table,{}) # Clear out ingredients
        self.db.delete_by_criteria(self.db.recipe_table,{}) # Clear out recipes
        self.db.delete_by_criteria(self.db.categories_table,{}) # Clear out categories        
        self.db.add_rec({'title':'Foo','cuisine':'Bar','source':'Z'})
        self.db.add_rec({'title':'Fooey','cuisine':'Bar','source':'Y'})
        self.db.add_rec({'title':'Fooey','cuisine':'Foo','source':'X'})
        self.db.add_rec({'title':'Foo','cuisine':'Foo','source':'A'})
        self.db.add_rec({'title':'Boe','cuisine':'Fa'})
        result = self.db.search_recipes([{'column':'deleted','search':False,'operator':'='},
                                    {'column':'cuisine','search':'Foo','operator':'='}])
        assert(len(result)==2)
        result = self.db.search_recipes([{'column':'deleted','search':False,'operator':'='},
                                    {'column':'cuisine','search':'F.*','operator':'REGEXP'}])

        assert(len(result)==3)
        result = self.db.search_recipes([{'column':'deleted','search':False,'operator':'='},
                                    {'column':'cuisine','search':'Foo'},
                                    {'column':'title','search':'Foo','operator':'='},])
        assert(len(result)==1)
        result = self.db.search_recipes([{'column':'title','search':'Fo.*','operator':'REGEXP'}],
                                   [('source',1)])
        assert(result[0].title=='Foo' and result[0].source=='A')
        # Advanced searching
        self.db.add_rec({'title':'Spaghetti','category':'Entree'})
        self.db.add_rec({'title':'Quiche','category':'Entree, Low-Fat, High-Carb'})
        assert(len(self.db.search_recipes([
            {'column':'deleted','search':False,'operator':'='},
            {'column':'category','search':'Entree','operator':'='}]))==2)
        # Test fancy multi-category searches...
        assert(len(self.db.search_recipes([{'column':'category','search':'Entree','operator':'='},
                                      {'column':'category','search':'Low-Fat','operator':'='}])
                   )==1)
        # Test ingredient search
        recs = self.db.fetch_all(self.db.recipe_table)
        r = recs[0]
        self.db.add_ing({'recipe_id':r.id,'ingkey':'apple'})
        self.db.add_ing({'recipe_id':r.id,'ingkey':'cinnamon'})
        self.db.add_ing({'recipe_id':r.id,'ingkey':'sugar, brown'})
        r2 = recs[1]
        self.db.add_ing({'recipe_id':r2.id,'ingkey':'sugar, brown'})
        self.db.add_ing({'recipe_id':r2.id,'ingkey':'flour, all-purpose'})
        self.db.add_ing({'recipe_id':r2.id,'ingkey':'sugar, white'})
        self.db.add_ing({'recipe_id':r2.id,'ingkey':'vanilla extract'})
        r3 = recs[2]
        self.db.add_ing({'recipe_id':r3.id,'ingkey':'sugar, brown'})
        self.db.add_ing({'recipe_id':r3.id,'ingkey':'sugar, brown','unit':3,'unit':'c.'} )
        assert(len(self.db.search_recipes([{'column':'ingredient',
                                       'search':'sugar%',
                                       'operator':'LIKE',
                                      }])
                   )==3)
        assert(len(self.db.search_recipes([{'column':'ingredient',
                                      'search':'sugar, brown'},
                                     {'column':'ingredient',
                                      'search':'apple'}])
                   )==1)

class testUnicode (DBTest):

    def runTest (self):
        rec = self.db.add_rec({'title':u'Comida de \xc1guila',
                          'source':u'C\xc6SAR',
                          'category':u'C\xc6sar',
                          })
        assert(rec.title == u'Comida de \xc1guila')
        assert(rec.source == u'C\xc6SAR')
        rec = self.db.modify_rec(rec,{'title':u'\xc1 Comida de \xc1guila'})
        assert(rec.title==u'\xc1 Comida de \xc1guila')
        ing = self.db.add_ing_and_update_keydic({
                'recipe_id':rec.id,
                'amount':1.0,
                'unit':u'\xc1guila',
                'item':u'\xc1guila',
                'ingkey':u'\xc1guila'
                })
        for attr in 'unit','item','ingkey':
            assert(getattr(ing,attr)==u'\xc1guila')


class testIDReservation (DBTest):                                  

    def runTest (self):
        rid = self.db.new_id()
        rid2 = self.db.new_id()
        r1 = self.db.add_rec({'title':'intermittent'})
        r1i = self.db.add_rec({'title':'intermittent2'})
        r12 = self.db.add_rec({'title':'intermittent3'})    
        r2 = self.db.add_rec({'title':'reserved','id':rid})
        r3 = self.db.add_rec({'title':'reserved2','id':rid2})
        try: assert(r2.id==rid)
        except:
            print 'reserved ID',rid
            print 'fetched ID',r2.id
            print 'intermittent ID',r1.id
            raise
        for r in [r1,r1i,r12,r2,r3]: self.db.delete_rec(r)

img='\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00\xff\xdb\x00C\x00\x08\x06\x06\x07\x06\x05\x08\x07\x07\x07\t\t\x08\n\x0c\x14\r\x0c\x0b\x0b\x0c\x19\x12\x13\x0f\x14\x1d\x1a\x1f\x1e\x1d\x1a\x1c\x1c $.\' ",#\x1c\x1c(7),01444\x1f\'9=82<.342\xff\xdb\x00C\x01\t\t\t\x0c\x0b\x0c\x18\r\r\x182!\x1c!22222222222222222222222222222222222222222222222222\xff\xc0\x00\x11\x08\x00(\x00#\x03\x01"\x00\x02\x11\x01\x03\x11\x01\xff\xc4\x00\x1f\x00\x00\x01\x05\x01\x01\x01\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\xff\xc4\x00\xb5\x10\x00\x02\x01\x03\x03\x02\x04\x03\x05\x05\x04\x04\x00\x00\x01}\x01\x02\x03\x00\x04\x11\x05\x12!1A\x06\x13Qa\x07"q\x142\x81\x91\xa1\x08#B\xb1\xc1\x15R\xd1\xf0$3br\x82\t\n\x16\x17\x18\x19\x1a%&\'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz\x83\x84\x85\x86\x87\x88\x89\x8a\x92\x93\x94\x95\x96\x97\x98\x99\x9a\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xff\xc4\x00\x1f\x01\x00\x03\x01\x01\x01\x01\x01\x01\x01\x01\x01\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\xff\xc4\x00\xb5\x11\x00\x02\x01\x02\x04\x04\x03\x04\x07\x05\x04\x04\x00\x01\x02w\x00\x01\x02\x03\x11\x04\x05!1\x06\x12AQ\x07aq\x13"2\x81\x08\x14B\x91\xa1\xb1\xc1\t#3R\xf0\x15br\xd1\n\x16$4\xe1%\xf1\x17\x18\x19\x1a&\'()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x92\x93\x94\x95\x96\x97\x98\x99\x9a\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xff\xda\x00\x0c\x03\x01\x00\x02\x11\x03\x11\x00?\x00\xf5\x01#r\xc0\x1c\x01\x92q\xd0S\x9a\xea+x\x1a{\xa9\x92(\x82\x16R\xc7n\xefl\x9e+\x07\xc6z\xf0\xd3$\x16p\xa4A\xf2\xb2d\xb1S\x8eq\xfc\'=\xff\x00:\xcf\x9a\xf7Q\xf1O\x85\x9eDB\xa9\x14\xdbJ\xc7\xceO\xe4\x0f\x7f\xd6\xaeUU\xb4*4\x9bj\xfb\x1d5\x9e\xadk}m\xba\x19\xe3\x92U8a\x1b\x02\x05`k\xfe\'m1\x84\x0bl\x1d\x87F.F>\xb8\xebShKi\xa0\xe9-4\xf8I\xe7E\r\xba,\x98\xd8\x03\x81\x8c\xe4\xf5\xcf^A\x14\x96\x97:>\xb5rl\xae\x00\xbd\x91\x8b"\xbbB\xcaz\xfd\xe1\xe9\xeb\xc1\x1c}1I\xc9\xc9+n5\x15\x17\xaa\xba,\xe9\xda\xb5\xd6\xa3a\r\xdb\xa2\xabH2F\x07c\x8f\xe9Etp\xd9\xc1o\x04p\xc5\x10\x11\xc6\xa1T{\n+U-52v\xbe\x86\x0f\x8c\xbc2\xfa\xcc\x90\xdc@3 \xc4dd\x0f\xa7\xf3\xadm\x13H\x87C\xd2\xa2\xb2\x1f31\xdc\xe4\x0e\x0b\x1cg\xf9\x01Z\x8e\xe7#\x18\x1e\xe6\xa2\xbb\xbb\x8a\xd9Y\x9d\x86\xc03\x9a\xc9E\'r\xdc\xdb\x8f)\xc6\xfcF\xd3e\xb9\xb3\x82\xea0\xc7h*v\xfey\xff\x00>\x95\x93\xf0\xfbIxo\x1e\xfex\xdbj\x02\xa8I\xfe#\xd7\xf4\xcf\xe7]\xcc\x97\xd1\xdd\xda\xc8\x8a\x98S\xf2\xe5\xfe\\\xfd;\xf1\x8c\xfe\x1d\xba\xd3\x86AX\xc4,\x15F7\xed\x00\x13\xdf\x8c\xf1\xcei{?{\x98~\xd3\xdc\xe5,1%\x89\x07\x03\xd0QF(\xadL\xc9\xd9\xc6*\xa5\xec"x\n\xed\xdcr\x1b\x1e\xb84QR\x80\xa0\xc8\xb3C\xf6i"|0\xc6\x0eG\x1f^\xb9\xabS\\}\x968`p\xca\xa3\x01X\xe4\x8f\xc4\xff\x00\x8d\x14U\x89\n\xf7r+m\x8ebT\x01\x8c-\x14QH\x0f\xff\xd9'

class TestMoreDataStuff (DBTest):
    def test_image_data (self):
        r = self.db.add_rec({'image':img})
        self.assertEqual(str(r.image), img)

    def test_update (self):
        r = self.db.add_rec({'title':'Foo','cuisine':'Bar','source':'Z'})
        self.db.update_by_criteria(self.db.recipe_table,{'title':'Foo'},{'title':'Boo'})
        self.assertEqual(self.db.get_rec(r.id).title, 'Boo')
    
    def test_modify_rec (self):
        orig_attrs = {'title':'Foo','cuisine':'Bar','yields':7,'yield_unit':'cups'}
        new_attrs =  {'title':'Foob','cuisine':'Baz','yields':4,'yield_unit':'servings'}
        r = self.db.add_rec(orig_attrs.copy())
        for attr,val in new_attrs.items():
            r = self.db.modify_rec(r,{attr:val})
            # Make sure our value changed...
            self.assertEqual(getattr(r,attr),val,'Incorrect modified value for %s'%attr)
            # Make sure no other values changed
            for a,v in orig_attrs.items():
                if a != attr:
                    self.assertEqual(getattr(r,a),v,'Incorrect original value for %s'%a)
            # Change back our recipe
            r = self.db.modify_rec(r,{attr:orig_attrs[attr]})

    def test_modify_ing (self):
        r = self.db.add_rec({'title':'itest'})
        orig_attrs = {'item':'Foo','ingkey':'Bar','amount':7,'unit':'cups','optional':True,'rangeamount':None,'recipe_id':r.id}
        new_attrs ={'item':'Fooz','ingkey':'Baz','amount':3,'unit':'ounces','optional':False,'rangeamount':2,}
        i = self.db.add_ing(orig_attrs.copy())
        for attr,val in new_attrs.items():
            r = self.db.modify_ing(i,{attr:val})
            # Make sure our value changed...
            self.assertEqual(getattr(r,attr),val,'Incorrect modified value for %s'%attr)
            # Make sure no other values changed
            for a,v in orig_attrs.items():
                if a != attr:
                    self.assertEqual(getattr(r,a),v,'Incorrect original vlaue for %s'%a)
            # Change back our ingredient...
            r = self.db.modify_ing(i,{attr:orig_attrs[attr]})
            
suite = unittest.TestSuite()
suite.addTests([
        testRecBasics(),
        testSearch(),
        testUnicode(),
        testIDReservation(),
        TestMoreDataStuff('test_image_data'),
        TestMoreDataStuff('test_update'),
        TestMoreDataStuff('test_modify_rec'),
        TestMoreDataStuff('test_modify_ing'),                
        ] + [
        testIngBasics(m) for m in ['testUnique','testAddIngs',]
        ]
               )
    
if __name__=='__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = batchEditor
import os
import gtk
import gglobals
from gtk_extras import cb_extras

class BatchEditor:
    
    def __init__ (self, rg):        
        self.rg = rg
        self.setup_ui()

    def setup_ui (self):
        self.ui = gtk.Builder()
        self.ui.add_from_file(os.path.join(gglobals.uibase,'batchEditor.ui'))
        self.dialog = self.ui.get_object('batchEditorDialog')
        self.setFieldWhereBlankButton = self.ui.get_object('setFieldWhereBlankButton')
        self.setup_boxes()
        self.dialog.connect('response',self.response_cb)
        
    def setup_boxes (self):
        self.attribute_widgets = {}
        self.get_data_methods = {}
        for a,l,w in gglobals.REC_ATTRS:
            checkbutton = self.ui.get_object('%sCheckButton'%a)
            if checkbutton:
                setattr(self,'%sCheckButton'%a,checkbutton)
                box = self.ui.get_object('%sBox'%a)
                self.attribute_widgets[a] = box
                setattr(self,'%sBox'%a,box)
                checkbutton.connect('toggled',self.toggle_cb,a)
                box.set_sensitive(False)
                if w=='Combo':
                    # If this is a combo box, we'll get info via the child's get_text method...
                    self.get_data_methods[a] = (checkbutton,
                                                getattr(self,'%sBox'%a).get_children()[0].get_text)
                    
                    box.set_model(self.rg.get_attribute_model(a))
                    box.set_text_column(0)
                    cb_extras.setup_completion(box)
                elif w=='Entry':
                    if hasattr(box,'get_value'):
                        method = box.get_value
                    else:
                        method = box.get_text
                    self.get_data_methods[a] = (checkbutton,
                                                method)

    def set_values_from_recipe (self, recipe):
        for attribute,box in self.attribute_widgets.items():
            if hasattr(recipe,attribute):
                val = getattr(recipe,attribute)
            elif attribute == 'category':
                val = ', '.join(self.rg.rd.get_cats(recipe))
            if val:
                if hasattr(box,'set_value'):
                    box.set_value(val)
                elif hasattr(box,'set_text'):
                    box.set_text(val)
                elif hasattr(box.get_children()[0],'set_text'):
                    box.get_children()[0].set_text(val)
                else:
                    print "Can't figure out how to set value for ",attribute,box

    def toggle_cb (self, widg, attr):
        box = self.attribute_widgets[attr]
        if widg.get_active(): box.set_sensitive(True)
        else: box.set_sensitive(False)
        
    def get_values (self):
        changed = {}
        for attribute in self.get_data_methods.keys():
            cb,get_method = self.get_data_methods[attribute]
            if cb.get_active():
                val = get_method()
                changed[attribute]=val
        return changed
    
    def response_cb (self, dialog, resp):
        if resp == gtk.RESPONSE_OK:
            self.setFieldWhereBlank = self.setFieldWhereBlankButton.get_active()
            self.values =  self.get_values()
        else:
            self.setFieldWhereBlank = None
            self.values = None
        

if __name__ == '__main__':
    import GourmetRecipeManager
    rg = GourmetRecipeManager.RecGui()
    be=BatchEditor(rg)
    be.set_values_from_recipe(rg.rd.fetch_one(rg.rd.recipe_table))
    be.dialog.run()

########NEW FILE########
__FILENAME__ = check_encodings
import gtk
from gdebug import debug
from gtk_extras import dialog_extras as de
from gettext import gettext as _
from prefs import get_prefs

class CheckEncoding:

    """A class to read a file and guess the correct text encoding."""

    encodings = ['iso8859','ascii','latin_1','cp850','cp1252','utf-8']
    all_encodings= ['ascii','cp037','cp424',
                        'cp437','cp500','cp737','cp775','cp850','cp852',
                        'cp855','cp856','cp857','cp860','cp861','cp862',
                        'cp863','cp864','cp865','cp869','cp874','cp875',
                        'cp1006','cp1026','cp1140','cp1250','cp1251',
                        'cp1252','cp1253','cp1254','cp1255','cp1256',
                        'cp1258','latin_1','iso8859_2','iso8859_3',
                        'iso8859_4','iso8859_5','iso8859_6','iso8859_7',
                        'iso8859_8','iso8859_9','iso8859_10','iso8859_13',
                        'iso8859_14','iso8859_15','koi8_r','koi8_u',
                        'mac_cyrillic','mac_greek','mac_iceland','mac_latin2',
                        'mac_roman','mac_turkish','utf_16','utf_16_be',
                        'utf_16_le','utf_7','utf_8']
    
    def __init__ (self, file, encodings=None):
        if get_prefs().get('utf-16',False):
            self.encodings.extend(['utf_16','utf_16_le','utf_16_be'])
        if encodings: self.encodings = encodings
        if type(file)==str:
            file = open(file,'r')
        self.txt = file.read()
        file.close()

    def test_encodings (self):
        """Move through self.encodings one at a time and return the first
        encoding that decodes our text cleanly. We return a tuple (encoding,decoded_text)"""
        for e in self.encodings:
            try:
                t=self.txt.decode(e)
                return (e,t)
            except UnicodeDecodeError:
                pass

    def get_encodings (self):
        encs = self.test_all_encodings(self.encodings)
        if encs:
            return encs
        else:
            return self.test_all_encodings(self.all_encodings)
            
    def test_all_encodings (self,encodings=None):
        """Test all encodings and return a dictionary of possible encodings."""
        if not encodings: encodings=self.all_encodings
        self.possible_encodings = {}
        for e in encodings:
            try:
                d=self.txt.decode(e)
                if d and (not d in self.possible_encodings.values()):
                    # if we don't already have this possibility, add
                    self.possible_encodings[e]=d.encode('utf8')
            except UnicodeDecodeError:
                pass
        return self.possible_encodings

class GetFile (CheckEncoding):
    """Handed a filename, return a list of lines."""
    def __init__ (self,file,encodings=None):
        CheckEncoding.__init__(self,file,encodings)
        encs=self.get_encodings()
        if encs:
            if len(encs.keys()) > 1:
                encoding = getEncoding(encodings=encs)
            else:
                encoding = encs.keys()[0]
            self.enc = encoding
            self.lines = encs[self.enc].splitlines()
            debug('reading file %s as encoding %s'%(file, self.enc))
            self.lines = [l.encode() for l in self.lines]
        else:
            raise Exception("Cannot decode file %s" % file)

def get_file (file, encodings=None):
    gf = GetFile(file, encodings)
    return gf.lines

class EncodingDialog (de.OptionDialog):
    """Create a dialog to allow user to select correct encoding for an input file."""

    context_lines = 2

    def __init__ (self, default=None, label=_("Select encoding"),
                  sublabel=_("Cannot determine proper encoding. Please select the correct encoding from the following list."),
                  expander_label=_("See _file with encoding"),
                  encodings={},
                 ):
        self.diff_lines = {}
        self.cursor_already_set = False
        self.expander_label=expander_label
        self.encodings = encodings
        self.current_error = 0
        self.diff_texts()
        self.options = self.create_options()
        expander=self.create_expander()
        self.setup_buffers()
        de.OptionDialog.__init__(self, default=default,label=label, sublabel=sublabel,
                                 options=self.options, expander=expander)
        self.set_default_size(700,500)
        self.optionMenu.connect('activate',self.change_encoding)
        self.change_encoding()
        self.created = False
        self.expander.set_expanded(True)

    def setup_motion_buttons (self):
        self.hbb = gtk.HButtonBox()
        self.fb = gtk.Button('Next Difference')
        self.pb = gtk.Button('Previous Difference')
        self.pb.connect('clicked',lambda *args: self.move_to_difference(forward=False))
        self.fb.connect('clicked',lambda *args: self.move_to_difference(forward=True))
        self.hbb.add(self.pb)
        self.hbb.add(self.fb)
        self.evb.add(self.hbb)
        self.hbb.show_all()

    def get_option (self,widget):
        de.OptionDialog.get_option(self,widget)
        self.change_encoding()

    def create_options (self):
        options = self.encodings.keys()
        masterlist = CheckEncoding.encodings + CheckEncoding.all_encodings
        def comp (a,b):
            return cmp(masterlist.index(a),masterlist.index(b))
        options.sort(comp)
        return options

    def create_expander (self):
        self.evb = gtk.VBox()
        self.sw = gtk.ScrolledWindow()
        self.sw.set_policy(gtk.POLICY_AUTOMATIC,gtk.POLICY_AUTOMATIC)
        self.tv = gtk.TextView()
        self.tv.set_editable(False)
        self.buffer = self.tv.get_buffer()
        self.sw.add(self.tv)
        self.sw.show_all()
        self.evb.add(self.sw)
        #self.setup_motion_buttons() # doesn't work yet
        self.evb.show_all()
        return self.expander_label,self.evb
    
    def setup_buffers (self):
        self.encoding_buffers={}
        for k,t in self.encodings.items():
            self.encoding_buffers[k]=gtk.TextBuffer()
            self.highlight_tags = [self.encoding_buffers[k].create_tag(background='yellow')]
            self.line_highlight_tags = [self.encoding_buffers[k].create_tag(background='green')]
            self.set_buffer_text(self.encoding_buffers[k],t)

    def change_encoding (self):
        if self.cursor_already_set:
            im=self.buffer.get_insert()
            ti=self.buffer.get_iter_at_mark(im)
            offset=ti.get_offset()
        self.tv.set_buffer(self.encoding_buffers[self.ret])
        self.buffer = self.encoding_buffers[self.ret]
        debug('changed text to encoding %s'%self.ret,0)        
        
    def move_to_difference (self, forward=True):        
        dkeys = self.diff_lines.keys()
        dkeys.sort()
        if forward:
            self.current_error += 1
        else:
            self.current_error = self.current_error - 1
        if self.current_error > len(dkeys): self.current_error = 0
        if self.current_error < 0: self.current_error = len(dkeys)-1
        mark=self.buffer.create_mark(
            None,
            self.buffer.get_iter_at_line_index(dkeys[self.current_error],0),
            False,
            )
        self.tv.scroll_to_mark(mark,0)

    def set_buffer_text (self, buffer, text):
        """Set buffer text to show encoding differences."""
        lines = text.splitlines()
        totl = len(lines)
        shown = []
        for line,diffs in self.diff_lines.items():
            if line in shown: continue
            start_at = line - self.context_lines
            if start_at < 0: start_at = 0
            end_at = line + self.context_lines
            if end_at >= totl: end_at = totl-1
            if start_at != 0:
                buffer.insert_with_tags(buffer.get_end_iter(),
                                        '\n...\n',
                                        )
            for n in range(start_at,end_at):
                if n in shown:
                    continue
                shown.append(n)
                l = lines[n]
                if n==line:
                    start = 0
                    for sdiff,ediff in diffs:
                        buffer.insert_with_tags(buffer.get_end_iter(),
                                                l[start:sdiff],
                                                *self.line_highlight_tags)
                        buffer.insert_with_tags(buffer.get_end_iter(),
                                                l[sdiff:ediff],
                                                *self.highlight_tags)
                        start = ediff
                    buffer.insert_with_tags(buffer.get_end_iter(),
                                            l[start:],
                                            *self.line_highlight_tags)
                else:
                    buffer.insert_with_tags(buffer.get_end_iter(),l)

    def diff_texts (self):
        """Look at our differently encoded buffers for characters where they differ."""
        encoded_buffers = self.encodings.values()
        def mycmp (a,b):
            '''Sort by number of newlines (most first)'''
            return cmp(len(b.splitlines()),len(a.splitlines()))
        encoded_buffers.sort(mycmp)
        enc1 = encoded_buffers[0]
        enc_rest = [e.splitlines() for e in encoded_buffers[1:]]
        for linenum, l in enumerate(enc1.splitlines()):
            other_lines = [len(e)>linenum and e[linenum] for e in enc_rest]
            # Remove any Falses returned by above 
            other_lines = filter(lambda x: type(x) != bool, other_lines)
            if False in [l==ol for ol in other_lines]:
                ranges = []
                for chnum,ch in enumerate(l):
                    if False in [len(line)>ch and ch == line[chnum] for line in other_lines]:
                        if ranges and ranges[-1][1]==chnum:
                            ranges[-1][1]=chnum+1
                        else:
                            ranges.append([chnum,chnum+1])
                self.diff_lines[linenum]=ranges
        
def getEncoding (*args,**kwargs):
    d=EncodingDialog(*args,**kwargs)
    result = d.run()
    if (not result) and d.encodings:
        return d.options[0]
    elif not result:
        return 'ascii'
    else:
        return result

if __name__ == '__main__':
    print 'grabbing dialog extras'
    #import gtk_extras.dialog_extras as de
    #print 'selecting file'
    #fn=de.select_file('Select file to decode',filters=[['Plain Text',['text/plain'],'*txt']],)
    #print 'fn = ',fn
    print "Got file ", get_file('/tmp/foo.txt')[0:5]



########NEW FILE########
__FILENAME__ = clockDB
import recipeManager as rm
import time, random, tempfile

class StressTester:

    times = []

    CUISINES = ['Indian','American','Spanish','Italian','Polish']
    INGS = ['Chicken','Beef','Broccoli','Tofu','Shrimp']
    SOURCES = ['Sue','Sally',
               'Jon','Meg',
               'Tom','Judy',
               'Martha','Steve',
               'Fred','Priscilla']

    def time_method (fun):
        name = fun.__name__
        def _ (self,*args, **kwargs):
            t = time.time()
            ret = fun(self,*args,**kwargs)
            total = time.time() - t
            self.times.append((name,total))
            return ret
        return _

    def __init__ (self):
        rm.dbargs['file']=tempfile.mktemp('test.db')
        self.db = rm.RecipeManager(**rm.dbargs)

    def run_tests (self):
        for n in range(3):
            print 'Start',(n+1),'*1000','recipes'
            self.add_1000_recipes()
            print 'fetching'
            self.test_fetch_recipe()
            print 'exact searches'
            self.test_exact_search()
            print 'regexp searches'
            self.test_regexp_search()
            print 'ing search'
            self.test_ing_search()
            #print 'like searches'            
            #self.test_like_search()            
            print 'committing...'
            self.commit_recs()
        print 'Done running tests!'
        print
        print 'Method\t\tTime'
        print '------\t\t----'
        for t in self.times:
            print t[0],"\t\t",t[1]

    @time_method
    def commit_recs (self):
        self.db.save()

    @time_method
    def add_1000_recipes (self):
        count = 0
        t = time.time()
        # 4 * 
        for cat in ['Dessert','Entree','Salad','Appetizer']:
            # 5 = 20
            for cuisine in self.CUISINES:
                # * 5 = 100
                for main_ing in self.INGS:
                    # * 10 = 1000
                    for source in self.SOURCES:
                        r = self.db.add_rec(
                            {'title':"%(source)s's %(cuisine)s %(main_ing)s %(cat)s"%locals(),
                             'category':cat,
                             'cuisine':cuisine,
                             'source':source,
                             'preptime':60*random.randint(5,240),
                             'cooktime':60*random.randint(10,90),
                             'instructions':'This is a long long description of how you cook'*25,
                             'modifications':'These are some funny notes.'*5,
                             })
                        self.db.add_ing({'id':r.id,'unit':'piece','item':main_ing,'ingkey':main_ing})
                        for n in range(3):
                            for u in ['tsp.','c.','lb.','oz.']:
                                self.db.add_ing(
                                    {'id':r.id,
                                     'unit':u,
                                     'item':'Item number %s'%n,
                                     'ingkey':'ingredient, %s'%n,
                                     }
                                    )
                        count += 1
                        if count % 100 == 0:
                            print "At ",count,"recipes.",time.time()-t,'seconds'

    def search (self,operator):
        for cuisine in random.sample(self.CUISINES,2):
            self.db.search_recipes([{'column':'deleted','search':False,'operator':'='},
                                    {'column':'cuisine','search':cuisine,'operator':operator},
                                    ])
            for source in random.sample(self.SOURCES,2):
                self.db.search_recipes([{'column':'deleted','search':False,'operator':'='},
                                        {'column':'cuisine','search':cuisine,'operator':operator},
                                        {'column':'source','search':cuisine,'operator':operator},
                                        ])

    @time_method
    def test_ing_search (self):
        for ing in random.sample(self.INGS,2):
            srch = ''
            for ltr in ing[0:4]:
                srch += ltr
                self.db.search_recipes([{'column':'deleted','search':False,'operator':'='},
                                        {'column':'ingredient',
                                         'search':srch+'%',
                                         'operator':'LIKE'}]
                                       )

    @time_method
    def test_exact_search (self): self.search('=')

    @time_method
    def test_regexp_search (self): self.search('regexp')

    @time_method
    def test_like_search (self): self.search('LIKE')

    @time_method
    def test_fetch_recipe (self,min=0,max=10):
        for r in range(100):
            recipe = self.db.fetch_all(self.db.recipe_table)[random.randint(min,max)]
            for prop in ['title','cuisine','source',
                         'preptime','cooktime','instructions',
                         'modifications']:
                getattr(recipe,prop)
            self.db.get_cats(recipe)
            for i in self.db.get_ings(recipe):
                getattr(i,'amount')
                getattr(i,'rangeamount')
                getattr(i,'unit')
                getattr(i,'item')
                getattr(i,'optional')
                getattr(i,'ingkey')

if __name__ == '__main__':
    st = StressTester()
    st.run_tests()

########NEW FILE########
__FILENAME__ = convert
import re, locale, math
from defaults.defaults import lang as defaults
from gettext import gettext as _
from gettext import ngettext
from gdebug import debug

FRACTIONS_ALL = 1
FRACTIONS_NORMAL = 0
FRACTIONS_ASCII = -1
FRACTIONS_OFF = -2

USE_FRACTIONS = FRACTIONS_NORMAL 

class PossiblyCaseInsensitiveDictionary (dict):

    transformations = ["lower","title","upper"]

    def has_key (self, k):
        if dict.has_key(self,k): return True
        else:
            for t in self.transformations:
                if hasattr(k,t):
                    if dict.has_key(self,getattr(k,t)()): return True
        return False

    def __getitem__ (self, k):
        if dict.has_key(self,k):
            return dict.__getitem__(self,k)
        else:
            for t in self.transformations:
                if hasattr(k,t):
                    nk = getattr(k,t)()
                    if dict.has_key(self,nk):
                        return dict.__getitem__(self,nk)
        # Raise plain old error
        dict.__getitem__(self,k)
        

class Converter:

    __single = None

    unit_to_seconds = {
    'seconds':1,
    'minutes':60,
    'hours':60*60,
    'days':24*60*60,
    'weeks':7*24*60*60,
    'months':31*24*60*60,
    'years':365.25*24*60*60,
    #'decades':10*365.25*24*60*60,
    #'centuries':100*365.25*24*60*60,
    #'millenia':1000*365.25*24*60*60,
    }

    # this is a bit of a hackish attempt to make a matcher for all
    # plural forms of time units. We use range(5) since as far as I
    # can see, enumerating the forms for 0 through 5 should give you
    # all possible forms in all languages.
    #
    # See http://www.sbin.org/doc/glibc/libc_8.html
    time_units = [('seconds',[ngettext('second','seconds',n) for n in range(5)] + ['s.', 'sec', 'secs','s' ]),
                  # min. = abbreviation for minutes
                  ('minutes',[_('min'),'min.','min','mins','m'] + [ngettext('minute','minutes',n) for n in range(5)]),
                  # hrs = abbreviation for hours
                  ('hours',[_('hrs.'),'hrs','hr','h'] + [ngettext('hour','hours',n) for n in range(5)]),
                  ('days',[ngettext('day','days',n) for n in range(5)]),
                  ('years',[ngettext('year','years',n) for n in range(5)]),
                  #('decades',[ngettext('decade','decades',n) for n in range(5)]),
                  #('centuries',[ngettext('century','centuries',n) for n in range(5)]),
                  #('millenia',[ngettext('millenium','millenia',n) for n in range(5)]),
                  ]
    
    def __init__(self):
        if Converter.__single: raise Converter.__single
        else: Converter.__single = self
        self.create_conv_table()
        self.create_density_table()
        self.create_cross_unit_table()
        self.create_vol_to_mass_table()
        # right now we only track densities, but we might convert
        # between other kinds of units eventually
        self.cross_unit_dicts={'density':self.density_table}
        ## This allows for varied spellings of units to be entered.
        self.create_unit_dict()
        self.add_time_table()
        self.build_converter_dictionary()
        self.build_converter_dictionary(self.v2m_table,density=True)

    def add_time_table (self):
        for u,conv in self.unit_to_seconds.items():
            self.conv_table[(u,'seconds')]=conv        

    def create_conv_table(self):
        self.conv_table = defaults.CONVERTER_TABLE.copy()

    def create_density_table (self):
        self.density_table = defaults.DENSITY_TABLE.copy()

    def create_vol_to_mass_table (self):
        self.v2m_table = defaults.VOL_TO_MASS_TABLE.copy()

    def create_cross_unit_table (self):
        self.cross_unit_table = defaults.CROSS_UNIT_TABLE.copy()

    def create_unit_dict(self):
        self.units = defaults.UNITS[0:]
        for u,alts in self.time_units:
            lst = []
            for a in alts:
                if not a in lst: lst.append(a)
                if not a.title() in lst: lst.append(a.title())
                if not a.capitalize() in lst: lst.append(a.capitalize())
                if not a.upper() in lst: lst.append(a.upper())
                if not a.lower() in lst: lst.append(a.lower())
            self.units.append((u,lst))
        self.unit_dict=PossiblyCaseInsensitiveDictionary()
        for itm in self.units:
            key = itm[0]
            variations = itm[1]
            self.unit_dict[key] = key
            for v in variations:
                self.unit_dict[v] = key

    def build_converter_dictionary (self, table=None, density=False):
        # first, make a list of all units in our dictionaries
        if not density:
            convert = self.convert_simple
        else:
            def convert (u1,u2):
                # Ignore anything that doesn't need density
                if self.convert_simple(u1,u2): return None
                return self.convert_w_density(u1,u2,density=1)
        units = []
        if not table:
            table=self.conv_table
        #else:
            #print "We were handed a table: ",table
        for u1,u2 in filter(lambda x: len(x)==2, table.keys()):
            if u1 not in units: units.append(u1)
            if u2 not in units: units.append(u2)
        #print 'done looping through list'
        for u in units:
            #print 'grabbing possible conversions for ',u
            debug('unit=%s'%u)
            d=self.possible_conversions(u,dict=table)
            to_expand = d.keys()
            # keep a list of what we've expanded
            expanded = []
            while len(to_expand) >= 1:
                itm = to_expand.pop()
                if itm not in expanded:
                    #debug('Expanding %s'%itm)
                    factor = convert(itm,u)
                    #debug('There are %s %s in a %s'%(factor,u,itm))
                    d2 = self.possible_conversions(itm)
                    if factor:
                        for k,v in d2.items():
                            if not convert(u,k):
                                #debug('and there are %s %s in a %s'%(v,itm,k))
                                conversion = float(v) * float(factor)
                                # If we're doing density, we want to
                                # make sure we always have our tuples
                                # (volume,density)
                                if density and itm not in [key[0] for key in table.keys()]:
                                    table[(u,k)]=float(1)/conversion
                                else: table[(k,u)]= conversion
                            if k not in expanded and k not in to_expand and k != itm and k != u:
                                to_expand.append(k)
                    expanded.append(itm)

    def convert_simple (self, u1, u2, item=None):
        if u1 == u2:
            return 1.0
        else:
            dict=self.conv_table
            if dict.has_key((u1,u2)):
                return dict[(u1,u2)]
            elif dict.has_key((u2,u1)):
                return float(1) / float(dict[(u2,u1)])
            else:
                return 0

    def convert_w_density (self, u1, u2, density=None, item=None):
        if u1 == u2:
            return 1.0
        if not density:
            if self.density_table.has_key(item):
                density=self.density_table[item]
            else:
                return None
        if self.v2m_table.has_key((u1,u2)):
            conv = self.v2m_table[(u1,u2)]                
            return conv * density
        elif self.v2m_table.has_key((u2,u1)):
            conv = float(1) / float(self.v2m_table[(u2,u1)])
            return conv / density
        else:
            return None

    def list_of_cu_tables (self, dictcu=None):
        if (not dictcu):
            dictcu = self.cross_unit_table
        values = dictcu.values()
        ret = []
        for v in values:
            if not v[0] in ret:
                ret.append(v[0])
        return ret
                
    def conv_dict_for_item (self, item=None, dictcu=None, mult=None):
        """item overrides mult"""
        if (not dictcu):
            dictcu = self.cross_unit_table
#        tbls = self.list_of_cu_tables(dictcu)
#        my_tbls = []
        ret = {}
        for itm in dictcu.items():
            k = itm[0]
            v = itm[1]
            dct = self.cross_unit_dicts[v[0]]
            conv = v[1]
            if item and dct.has_key(item):
                mult = dct[item]
            if mult: 
                ret[k] = conv * mult
        return ret

    def converter (self, u1, u2, item=None, density=None):
        ## Just a front end to convert_fancy that looks up units
        if self.unit_dict.has_key(u1):
            unit1 = self.unit_dict[u1]
        else:
            unit1 = u1
        if self.unit_dict.has_key(u2):
            unit2 = self.unit_dict[u2]
        else:
            unit2 = u2
        ## provide some kind of item lookup?
        return self.convert_fancy(unit1, unit2, item=item, density=density)

    def convert_fancy (self, u1, u2, item=None, density=None):
        simple = self.convert_simple(u1,u2,self.conv_table)
        if simple: return simple
        # otherwise, we need to grab use a density table
        debug('using density data')
        return self.convert_w_density(u1,u2,item=item,density=density)

    def get_conversions (self, u, item=None, density=None):
        dct = None
        if item or density:
            dct = self.conv_table.copy()
            if item:
                dct.update(self.conv_dict_for_item(item))
            elif density:
                dct.update(self.conv_dict_for_item(mult=density))
        return self.possible_conversions(u, dct)

    def get_all_conversions (self, u, item=None, density=None):
        dict = self.get_conversions(u, item, density)
        expanded = []
        conversions = dict.keys()
        lst = conversions[0:] # make another copy to chew up
        while len(lst) >= 1:
            itm = lst.pop()
            if not itm in conversions:
                conversions.append(itm)
            if not itm in expanded:
                d = self.get_conversions(u,itm,density)
                lst.extend(d.keys())
                expanded.append(itm)
        return conversions
    
    def possible_conversions(self, u, dict=0):
        """Return a dictionary of everything that unit u can convert to
        The keys are what it can convert to and the values are the conversion
        factor."""
        if (not dict):
            dict=self.conv_table
        ret = {}
        entries = dict.items()
        for item in entries:
            i1 = item[0][0]
            i2 = item[0][1]
            if u == i1:
                ret[i2] = float(1) / item[1]
            elif u == i2:
                ret[i1] = float(item[1])
        return ret            

    def readability_score (self,amt,unit=None):
        """We rate the readability of a number and unit

        This is rather advanced. We presume a few things -- such as that we
        like integers and simple fractions 1/2 1/3 1/4 better than other things.

        We also learn from the defaults module what the bounds are for readability
        for each amount given.
        """
        readability = 0
        ## We like our numbers whole or in normal fractions
        if integerp(amt):
            readability += 1
        elif integerp(amt * 2):
            readability += 1
        elif integerp(amt * 4):
            readability += 1
        elif integerp(amt * 3):
            readability += 1
        elif integerp (amt * 8):
            readability += 0.8
        elif integerp (amt * 6):
            readability += 0.3
        elif integerp (amt * 5):
            readability += 0.2
        elif integerp (amt * 10):
            readability += 0.05
        ## If it is not a normal fraction, readability takes a hit
        else:
            readability += -2
        ## If it is exactly 1 it gets a bump:
        if amt == 1: readability += 0.5
        if unit:
            # if we are beyond the min or max for our group, we take
            # a substantial readability hit (this is worse than anything
            # else)
            try:
                u = self.unit_dict[unit]
            except KeyError:
                debug("KeyError looking up unit",1)
                u = unit
            try:
                ugroup,n = defaults.unit_group_lookup[u]
            except KeyError:
                debug('Key Error for %s in \nunit_group_lookup: %s'%(unit,defaults.unit_group_lookup),
                      0)
                #raise
                return -10
            else:
                u,rng = defaults.UNIT_GROUPS[ugroup][n]
                mn,mx = rng
                debug('Readability range for %s = %s:%s'%(u,mn,mx),8)
                if mn and amt and  amt < mn:
                    readability += -2
                    # we add a penalty proportional to the undersizedness
                    if (mn-amt): readability += -(2 * (mn - amt))/amt
                if mx and amt > mx:
                    readability += -2
                    # now we get clever and add a penalty proportional to the oversizedness
                    if (amt-mx): readability += - ((amt - mx)/float(mx))*2
        else:
            # otherwise, we'll make some assumptions about numbers
            # we don't like things over a thousand and we really don't
            # or under a hundredth
            if amt > 1000: readability += -2
            elif amt < .1:
                readability += -1
                if amt < .01:
                    readability += -1
                    if amt < .001:
                        readability += -1
                        if amt < .0001:
                            readability += -1
        ## And we like numbers between 1/8 and 4
        #if 0.25 <= amt <= 4:
        #    readability += 1
        ### Less than 1/10th is getting too small
        #elif 0.1 >= amt:
        #    readability += -1
        ## And we rather dislike numbers over 10
        #elif 20 >= amt > 10:
        #    readability += -0.9
        ## And we really can't have numbers over 20
        #elif 100 >= amt > 20:
        #    readability += -5
        ## And we really, really, really can't have numbers over 100
        #elif 1000 >= amt > 100:
        #    readability += -10
        #elif amt >= 1000:
        #    readability += -20
        return readability

    def adjust_unit (self, amt, unit, item=None, favor_current_unit=True, preferred_unit_groups=[]):

        """Return the most readable equivalent of amount and unit for item ITM

        amt - our amount
        unit - our current unit
        item - the item (in case it makes a difference -- currently not implemented)
        favor_current_item - a flag; if True (default) we give our current unit a slight
                             preference, to avoid changing the unit if unnecessary.
        Here we do our best to provide readable units, so that the user is presented
        with 1/2 cup rather than 8 tablespoons, for example.
        """
        if not amt: return amt,unit
        try:
            u = self.unit_dict[unit]
            ugroup,n = defaults.unit_group_lookup[u]
        except KeyError:
            return amt,unit
        else:
            units=defaults.UNIT_GROUPS[ugroup]                
            if preferred_unit_groups:
                if ugroup not in preferred_unit_groups:
                    for ug in preferred_unit_groups:
                        conv = self.converter(u,defaults.UNIT_GROUPS[ug][0][0])
                        if conv:
                            units = defaults.UNIT_GROUPS[ug]
                            amt = conv * amt
                            u = unit = defaults.UNIT_GROUPS[ug][0][0]
                            break
                        else:
                            continue
            ret_readability = self.readability_score(amt,unit)
            if favor_current_unit: ret_readability += 1
            ret_amt = amt
            ret_unit = unit
            ret_distance = 0
            n1 = 0
            for u2,rng in units:
                conv = self.converter(u,u2)
                if not conv:
                    continue
                new_amt = conv * amt
                readability = self.readability_score(new_amt,u2)
                debug('%s %s, Readability = %s'%(new_amt,u2,readability),6)
                use_us = False
                if readability > ret_readability:
                    use_us = True
                elif readability == ret_readability and abs(n-n1) < ret_distance:
                    use_us = True
                if use_us:
                    ret_amt = new_amt
                    ret_distance = abs(n-n1)
                    ret_unit = u2
                    ret_readability = readability
                n1 += 1
            debug('adjust unit called with %s %s, returning %s %s (R:%s)'%(amt,unit,ret_amt,ret_unit,
                                                                           ret_readability),
                  3)
            return ret_amt,ret_unit

    def use_reasonable_unit (self, amt1, u1, amt2, u2, conv):
        """Given the conversion factor and the amounts,
        we're going to try to figure out which unit
        is the most human-readable.  conv is what converts
        from amt1 into amt2.  We return a list of
        amt unit, where the amount is our total, and the unit
        is our chosen unit."""
        u1amt = amt1 + amt2 * (1 / float(conv))
        u2amt = amt2 + amt1 * conv
        if self.readability_score(u1amt) >= self.readability_score(u2amt):
            return [u1amt, u1]
        else:
            return [u2amt, u2]

    def add_reasonably (self, a1, u1, a2, u2, item=None):
        """Return a list with amount and unit if conversion is possible.
        Else return None"""
        if not (a1 and a2):
            # we give up if these aren't numbers
            return None
        conv = self.converter(u1,u2, item)
        if conv:
            ## Don't bother with all the work if the conversion factor is 1
            if conv == 1:
                return [a1 + a2, u1]
            else:
                return self.use_reasonable_unit(a1, u1, a2, u2, conv)
        else:
            return None

    def amt_string(self, amt, approx=0.01):
        """Given list of [amount unit], hand back a string
        representing amount.  We'll do our best to turn numbers back
        into fractions here so that they will look easily readable.

        We can also handle amounts handed to us as tuples (as ranges)!"""
        num = amt[0]
        un = amt[1]
        if type(num)==tuple or type(num)==list:
            nstring=float_to_frac(num[0],approx=approx).strip()
            if len(num)>1 and num[1]:
                nstring += "-"
                nstring += float_to_frac(num[1],approx=approx).strip()
        else:
            nstring = float_to_frac(num,approx=approx)
        if un:
            return "%s %s" %(nstring, un)
        else:
            return "%s"%nstring

    def timestring_to_seconds (self, timestring):
        """Take a timestring and parse it into seconds.

        We assume numbers come before time units - surely this will
        break some languages(?). We'll build the parameter in when the
        time comes...

        Return 0 if timestring is unparsable
        """
        # Before we do our real work, parse times that look like this 0:30
        # Note the following will be true
        # 1:30 = 1 1/2 hours
        # 00:00:20 = 20 seconds
        if re.match('^\d\d?:\d\d(:\d\d)?$',timestring):
            times = [locale.atof(s) for s in timestring.split(':')]
            if len(times) == 3:
                h,m,s = times
            else:
                h,m = times; s = 0
            return h*60*60 + m*60 + s
        numbers = []
        for match in NUMBER_FINDER.finditer(timestring):
            if numbers: numbers[-1].append(match.start())
            numbers.append([match.start(),match.end()])
        if numbers: numbers[-1].append(None)
        secs = 0
        for num_start,num_end,section_end in numbers:
            num = frac_to_float(timestring[num_start:num_end])
            unit = timestring[num_end:section_end].strip()
            if self.unit_dict.has_key(unit):
                conv = self.converter(unit,'seconds')
                if conv and num:
                    secs += num * conv
        return secs

    def timestring_to_seconds_old (self, timestring):
        """Take a timestring and parse it into seconds.

        This logic may be a little fragile for non-English languages.
        """
        words = re.split('[ \s,;]+',str(timestring))
        seconds = 0
        num = []
        for n,w in enumerate(words):
            if NUMBER_MATCHER.match(w): num.append(w)
            elif num and self.unit_dict.has_key(w):                
                conv = self.converter(w,'seconds')
                if conv:
                    n = frac_to_float(" ".join(num))
                    if n: seconds += n * conv
                    num = []
        if seconds: return seconds

def get_converter ():
    try:
        return Converter()
    except Converter, c:
        return c

# Each of our time formatting functions takes two arguments, which
# allows us to handle fractions in the outside world
time_formatters = {
    #'millennia':lambda decades: ngettext("millenium","millenia",round(decades))
    #'centuries':lambda decades: ngettext("century","centuries",round(decades))
    #'decades':lambda decades: ngettext("decade","decades",round(decades))
    'years':lambda years: ngettext("year","years",years),
    'months':lambda months: ngettext("month","months",months),
    'weeks':lambda weeks: ngettext("week","weeks",weeks),
    'days':lambda days: ngettext("day","days",days),
    'hours':lambda hours: ngettext("hour","hours",hours),
    'minutes':lambda minutes: ngettext("minute","minutes",minutes),
    'seconds':lambda seconds: ngettext("second","seconds",seconds),
    }    

def seconds_to_timestring (time, round_at=None, fractions=FRACTIONS_NORMAL):
    time = int(time)
    time_strings = []
    units = Converter.unit_to_seconds.items()
    units.sort(lambda a,b: a[1]<b[1] and 1 or a[1]>b[1] and -1 or 0)
    for unit,divisor in units:  
        time_covered = time / int(divisor)
        # special case hours, which we English speakers anyway are
        # used to hearing in 1/2s -- i.e. 1/2 hour is better than 30
        # minutes.
        add_half = 0
        if time % divisor == .5*divisor and not time_strings:
            add_half = 0.5
            time_covered += 0.5
        if time_covered or add_half:
            #print time_covered,'(rounds to ',round(time_covered),')'
            if round_at and len(time_strings)+1>=round_at:
                if not add_half: time_covered = int(round(float(time)/divisor))
                time_strings.append(" ".join([
                    float_to_frac(time_covered,fractions=fractions),
                    # round because 1/2 = 1 as far as plural formas are concerned
                    time_formatters[unit](round(time_covered)) 
                    ])
                                    )
                break
            else:
                time_strings.append(" ".join([
                    float_to_frac(time_covered,fractions=fractions),
                    # round because 1/2 = 1 as far as plural forms are concerned
                    time_formatters[unit](round(time_covered))
                    ]))
                time = time - time_covered * divisor
                if time==0: break
    if len(time_strings)>2:
        # Translators... this is a messay way of concatenating
        # lists. In English we do lists this way: 1, 2, 3, 4, 5
        # and 6. This set-up allows for variations of this system only.
        # You can of course make your language only use commas or
        # ands or spaces or whatever you like by translating both
        # ", " and " and " with the same string.
        return _(" and ").join([_(", ").join(time_strings[0:-1]),time_strings[-1]])
    else:
        return _(" ").join(time_strings)    

def integerp (num, approx=0.01):
    """approx can be a decimal that is a guide to rounding.
    That is, if approx is 0.001, then we will consider
    0.9991 and 1.0009 both to be the integer 1.  This feature
    will only work for positive, non-zero numbers."""
    try:
        if int(num) == float(num):
            return int(num)
        elif approx:
            bigside = int(num+approx)
            smallside = int(num-approx)
            if bigside != smallside:
                return bigside
            else:
                return None
    except:
        return None


# Fractions used in most charsets -- for certain exports, etc., we
# want to limit special fractions to these and use straight-up ascii
# fractions otherwise. These fractions must also be keys in
# NUM_TO_FRACTIONS

NUMBER_WORDS = {}
if hasattr(defaults,'NUMBERS'):
    for n,words in defaults.NUMBERS.items():
        for w in words:
            NUMBER_WORDS[w] = n
all_number_words = NUMBER_WORDS.keys()
all_number_words.sort(
    lambda x,y: ((len(y)>len(x) and 1) or (len(x)>len(y) and -1) or 0)
    )

NUMBER_WORD_REGEXP = '|'.join(all_number_words).replace(' ','\s+')
FRACTION_WORD_REGEXP = '|'.join(filter(lambda n: NUMBER_WORDS[n]<1.0,
                                       all_number_words)
                                ).replace(' ','\s+')

NORMAL_FRACTIONS = [(1,2),(1,4),(3,4)] 

NUM_TO_FRACTIONS = {
    (1,2) : u'\u00BD',
    (1,4) : u'\u00BC',
    (3,4) : u'\u00BE',
    (1,3) : u'\u2153',
    (2,3) : u'\u2154',
    (1,5) : u'\u2155',
    (2,5) : u'\u2156',
    (3,5) : u'\u2157',
    (4,5) : u'\u2158',
    (1,6) : u'\u2159',
    (5,6) : u'\u215A',
    (1,8) : u'\u215B',
    (3,8) : u'\u215C',
    (5,8) : u'\u215D',
    (7,8) : u'\u215E',
    }

UNICODE_FRACTIONS = {
    # a dictionary of funky unicode numbers not recognized by standard
    # python float() and int() functions
    u'\u00BD':1.0/2,
    u'\u00BC':1.0/4,
    u'\u00BE':3.0/4,
    u'\u2153':1.0/3,
    u'\u2154':2.0/3,
    u'\u2155':1.0/5,
    u'\u2156':2.0/5,
    u'\u2157':3.0/5,
    u'\u2158':4.0/5,
    u'\u2159':1.0/6,
    u'\u215A':5.0/6,
    u'\u215B':1.0/8,
    u'\u215C':3.0/8,
    u'\u215D':5.0/8,
    u'\u215E':7.0/8,
    }

SUP_DICT = {1:u'\u00B9',
            2:u'\u00B2',
            3:u'\u00B3',
            }

SLASH = u'\u2044'
SUB_DICT = {1:u'\u2081',
            2:u'\u2082',
            3:u'\u2083',
            4:u'\u2084',
            5:u'\u2085',
            6:u'\u2086',
            7:u'\u2087',
            8:u'\u2088',
            9:u'\u2089',
            }
            
# nonstandard integers (sub or sup) that may be used in fractions
UNICODE_INTEGERS = {}
for d in SUB_DICT,SUP_DICT:
    for k,v in d.items():
        UNICODE_INTEGERS[v]=k

NUMBER_REGEXP = "[\d"
#for k in UNICODE_INTEGERS.keys(): NUMBER_REGEXP+=k # COVERED by re.UNICODE
for k in UNICODE_FRACTIONS.keys(): NUMBER_REGEXP+=k
NUMBER_START_REGEXP = NUMBER_REGEXP + ']'
NUMBER_END_NO_RANGE_REGEXP = NUMBER_START_REGEXP # Is this right -- quick fix here.
NUMBER_MID_REGEXP = NUMBER_REGEXP + ',.' + SLASH
NUMBER_MID_NO_RANGE_REGEXP = NUMBER_MID_REGEXP + " /]"
NUMBER_MID_REGEXP += " /-"
NUMBER_MID_REGEXP += "]"
NUMBER_END_REGEXP = NUMBER_START_REGEXP
NUMBER_REGEXP = "("+NUMBER_START_REGEXP+"*"+NUMBER_MID_REGEXP+"*"+NUMBER_END_REGEXP
if NUMBER_WORD_REGEXP:
     NUMBER_REGEXP = NUMBER_REGEXP + '|' + NUMBER_WORD_REGEXP + ')'
     NUMBER_NO_RANGE_REGEXP = '(' + NUMBER_START_REGEXP + '+|' + NUMBER_WORD_REGEXP + ')'
else:
    NUMBER_REGEXP = NUMBER_REGEXP + ")"
    NUMBER_NO_RANGE_REGEXP = NUMBER_START_REGEXP + '+'
NUMBER_MATCHER = re.compile("^%s$"%NUMBER_REGEXP,re.UNICODE)

UNICODE_FRACTION_REGEXP = "[" + "".join(UNICODE_FRACTIONS.keys()) + "]"
DIVIDEND_REGEXP = "[0-9" + "".join(SUP_DICT.values()) + "]+"
SLASH_REGEXP = "[/" + SLASH + "]"
SLASH_MATCHER = re.compile(SLASH_REGEXP)
DIVISOR_REGEXP = "[0-9" + "".join(SUB_DICT.values()) + "]+"
FRACTION_REGEXP = "(" + UNICODE_FRACTION_REGEXP + "|" + DIVIDEND_REGEXP + \
                          SLASH_REGEXP + DIVISOR_REGEXP + ")"

AND_REGEXP = "(\s+%s\s+|\s*[&+]\s*|\s+)"%_('and')

# Match a fraction
if NUMBER_WORD_REGEXP:
    NUM_AND_FRACTION_REGEXP = "((?P<int>%s+|%s)%s)?(?P<frac>(%s|%s))"%(NUMBER_START_REGEXP,
                                                                       NUMBER_WORD_REGEXP,
                                                                       AND_REGEXP,
                                                                       FRACTION_REGEXP,
                                                                       FRACTION_WORD_REGEXP
                                                                       )
    
else:
    NUM_AND_FRACTION_REGEXP = "((?P<int>%s)+\s+)?(?P<frac>%s)"%(NUMBER_START_REGEXP,FRACTION_REGEXP)

FRACTION_MATCHER = re.compile(NUM_AND_FRACTION_REGEXP,re.UNICODE)

NUMBER_FINDER_REGEXP = "(%(NUM_AND_FRACTION_REGEXP)s|%(NUMBER_NO_RANGE_REGEXP)s)(?=($| |[\s]))"%locals()
NUMBER_FINDER = re.compile(NUMBER_FINDER_REGEXP,re.UNICODE)

# Note: the order matters on this range regular expression in order
# for it to properly split things like 1 - to - 3, which really do
# show up sometimes.
RANGE_REGEXP = '([ -]*%s[ -]*|\s*-\s*)'%_('to') # for 'to' used in a range, as in 3-4
RANGE_MATCHER = re.compile(RANGE_REGEXP[1:-1]) # no parens for this one


# We need a special matcher to match known units when they are more
# than one word. The assumption remains that units should be one word
# -- but if we already know about two word units, then we should
# recognize them.

multi_word_units = []
for canonical_name,other_names in defaults.UNITS:
    if ' ' in canonical_name: multi_word_units.append(canonical_name)
    for n in other_names:
        if ' ' in n: multi_word_units.append(n)
MULTI_WORD_UNIT_REGEXP = '(' + \
                       '|'.join([re.escape(unicode(u)) for u in multi_word_units]) \
                       + ')'


# generic ingredient matcher. This is far from a good matcher -- it's
# used as a fallback to test for things that obviously look like
# ingredients (e.g. 1 cup milk) that get misparsed by other ingredient
# parsers. This is often necessary because formats like mealmaster and
# mastercook are rarely actually followed.
NUMBER_FINDER_REGEXP2 = NUMBER_FINDER_REGEXP.replace('int','int2').replace('frac','frac2')

try:
    ING_MATCHER_REGEXP = """
 \s* # opening whitespace
 (?P<amount>
 %(NUMBER_FINDER_REGEXP)s # a number
 \s* # Extra whitespace
 (%(RANGE_REGEXP)s # a possible range delimiter
 \s* #More extra whitespace
 %(NUMBER_FINDER_REGEXP2)s)? # and more numbers
 )? # and of course no number is possible
 \s* # Whitespace between number and unit
 (?P<unit>\s*(%(MULTI_WORD_UNIT_REGEXP)s|[\w.]+))?\s+ # a unit
 (?P<item>.*?)$ # and the rest of our stuff...
 """
    ING_MATCHER_REGEXP = ING_MATCHER_REGEXP%locals()
except:
    print 'Failure with local vars...'
    for s in ['NUMBER_FINDER_REGEXP',
              'NUMBER_FINDER_REGEXP2',
              'RANGE_REGEXP',
              'MULTI_WORD_UNIT_REGEXP',]:
        try: print 'DOUBLE CHECK',s,'%%(%s)s'%s%locals()
        except:
            print 'Failed with ',s,locals()[s]
    raise

ING_MATCHER = re.compile(ING_MATCHER_REGEXP,
                         re.VERBOSE|re.UNICODE)

ING_MATCHER_AMT_GROUP = 'amount'
ING_MATCHER_UNIT_GROUP = 'unit'
ING_MATCHER_ITEM_GROUP = 'item'

def convert_fractions_to_ascii (s):
    """Convert all unicode-like fractions in string S with their ASCII equivalents"""
    for nums,uni in NUM_TO_FRACTIONS.items():
        s=re.sub(uni,"%s/%s"%(nums[0],nums[1]),s)
    for d in SUB_DICT,SUP_DICT:
        for num,uni in d.items():
            s=re.sub(uni,str(num),s)
    s=re.sub(SLASH,'/',s)
    return s

def fractify (decimal, divisor, approx=0.01, fractions=FRACTIONS_NORMAL):
    """Return fraction equivalent of decimal using divisor

    If we don't have a fit within our approximation, return the
    fraction. Otherwise, return False.
    """
    dividend = integerp(decimal*divisor)
    if dividend:
        if fractions==FRACTIONS_ASCII:
            return "%s/%s"%(dividend,divisor)
        elif fractions==FRACTIONS_ALL:
            # otherwise, we have to do nice unicode magic
            if NUM_TO_FRACTIONS.has_key((dividend,divisor)):
                return NUM_TO_FRACTIONS[(dividend,divisor)]
            else:
                if SUP_DICT.has_key(dividend): dividend = SUP_DICT[dividend]
                if SUB_DICT.has_key(divisor): divisor = SUB_DICT[divisor]
                return '%s%s%s'%(dividend,SLASH,divisor)
        else: # fractions==FRACTIONS_NORMAL
            #fallback to "normal" fractions -- 1/4, 1/2, 3/4 are special
            if (dividend,divisor) in NORMAL_FRACTIONS:
                return NUM_TO_FRACTIONS[(dividend,divisor)]
            else:
                return "%s/%s"%(dividend,divisor)
            
def float_to_frac (n, d=[2,3,4,5,6,8,10,16],approx=0.01,fractions=FRACTIONS_NORMAL):
    """Take a number -- or anything that can become a float --
    and attempt to return a fraction with a denominator in the list `d'. We
    approximate fractions to within approx. i.e. if approx=0.01, then 0.331=1/3"""
    if USE_FRACTIONS == FRACTIONS_OFF:
        return float_to_metric(n,approx)
    else:
        if not n: return ""
        n=float(n)
        i = int(n)
        if i >= 1:
            i="%s"%int(n)
        else:
            i=""
        rem = n - int(n)
        if rem==0 or rem<approx:
            if i:
                return "%i"%round(n)
            else:
                return "0"
        else:
            flag = False
            for div in d:
                f = fractify(rem,div,approx=approx,fractions=fractions)
                if f:
                    return " ".join([i,f]).strip()
             # use locale-specific metric formatting if fractions don't work
            return float_to_metric(n,approx)

def float_to_metric(n, approx=0.01):
    """Returns a formatted string in metric format, using locale-specific formatting"""    
    decimals_to_preserve = int(round(math.log(float(1)/approx,10)))
    if decimals_to_preserve > 0:
        format_string = "%."+str(decimals_to_preserve)+"f"
    else:
        format_string = "%i"
    if n is not None:
     if int(n) != n:
         if (n - int(n) < approx) or ((n - int(n) + approx) > 1):
             rounded = round(n)
             if rounded == 0:
                 return float_to_metric(n,approx*.01)
             return locale.format("%i",int(rounded),True)
         else:
             rounded = round(n,decimals_to_preserve)
             if rounded == 0:
                 return float_to_metric(n,approx*.01)
             return locale.format("%."+str(decimals_to_preserve)+"f",rounded,True) # format(formatstring, number, use_thousands_separator)
     else:
         return locale.format("%i",n,True)
    else:
         return ""

def float_string (s):
    """Convert string to a float, assuming it is some sort of decimal number

    locale.atof should handle this, but we wrote our own to be a bit more flexible.
    Specifically, we assume most numbers are decimals since recipes calling for
    thousands and thousands of things are rare.
    Also, we recognize items outside of our locale, since e.g. American might well be
    importing British recipes and viceversa.
    """
    if NUMBER_WORDS.has_key(s.lower()):
        print 'We have key',s.lower()
        return NUMBER_WORDS[s.lower()]
    THOUSEP = locale.localeconv()['thousands_sep']
    DECSEP = locale.localeconv()['decimal_point']
    if s.count(',') > 1 and s.count('.') <= 1:
        # if we have more than one comma and less than one .
        # then we assume ,s are thousand-separators
        s=s.replace(',','')
        return float(s)
    elif s.count(',') <= 1 and s.count('.') > 1:
        # if we have more than one . and less than one ,,
        # then we assume . is the thousand-separators
        s=s.replace('.','')
        s=s.replace(',','.')
        return float(s)
    # otherwise let's check if this actually looks like a thousands separator
    # before trusting our locale
    elif re.search('[0-9]+%s[0-9][0-9][0-9]'%re.escape(THOUSEP),s):
        return locale.atof(s)
    elif THOUSEP and s.find(THOUSEP)>-1:
        # otherwise, perhaps our thousand separator is really a
        # decimal separator (we're out of our locale...)
        print 'Warning: assuming %s is a decimal point in %s'%(THOUSEP,s)
        s = s.replace(DECSEP,'!!!')
        s = s.replace(THOUSEP,DECSEP)
        s = s.replace('!!!',THOUSEP) # and remove any commas for good measure
        return locale.atof(s)
    else:
        # otherwise just trust our locale float
        return locale.atof(s)

def frac_to_float (s):
    """We assume fractions look like this (I )?N/D"""
    if NUMBER_WORDS.has_key(s): return NUMBER_WORDS[s]
    if hasattr(s,'lower') and NUMBER_WORDS.has_key(s.lower()):
        return NUMBER_WORDS[s.lower()]    
    s = unicode(s)
    m=FRACTION_MATCHER.match(s)
    if m:
        i = m.group('int')
        frac = m.group('frac')
        if i: i=float_string(i)
        else: i = 0
        if UNICODE_FRACTIONS.has_key(frac):
            return i+UNICODE_FRACTIONS[frac]
        elif NUMBER_WORDS.has_key(frac):
            return i+NUMBER_WORDS[frac]
        else:
            n,d = SLASH_MATCHER.split(frac)
            n = SUP_DICT.get(n,n)
            d = SUB_DICT.get(d,d)
            return float(i)+(float(n)/float(d))
    # else...
    try:
        return float_string(s)
    except:
        None
    else:
        #If this isn't a fraction, we're just using float
        try:
            return float_string(s)
        except:
            None

#class ConverterSingleton:
#    
#    __impl == Converter
#
#    def __init__ (


if __name__ == '__main__' and False:
    class InteractiveConverter:
        def __init__ (self):
            self.c = get_converter()
            self.options = {'Convert':self.converter,
                            'Add':self.adder,
                            'Adjust':self.adjuster,
                            'Quit':self.quit}
            while 1:
                self.offer_options()
            
        def offer_options (self):
            print 'Choose one of the following actions:'
            for k in self.options.keys(): print k
            choice = raw_input('Type your choice: ')
            if self.options.has_key(choice):
                self.options[choice]()
            else:
                print "I'm afraid I didn't understand your choice!"
                self.return_to_continue()
                self.offer_options()
                          
        def get_unit (self, prompt="Enter unit: "):
            u = raw_input(prompt).strip()
            if self.c.unit_dict.has_key(u):
                return u
            elif u=='list':
                for u in self.c.unit_dict.keys():
                    print u,", ",
                print ""
                return self.get_unit(prompt)
            else:
                print u, 'Is not a unit I know about! Please try again.'
                print '(Type "list" for a list of valid units)'
                return self.get_unit(prompt)

        def get_amount (self, prompt="Enter amount: "):
            amt = frac_to_float(raw_input(prompt))
            if not amt:
                print "Please enter an amount!"
                return self.get_amount(prompt)
            else:
                return amt
                
        def converter (self):
            u1 = self.get_unit("Enter source unit: ")
            amt = self.get_amount("Enter source amount: ")
            u2 = self.get_unit("Enter target unit: ")
            conv = self.c.converter(u1,u2)
            print '%s %s = %s %s'%(amt,u1,conv*amt,u2)
            self.return_to_continue()

        def adjuster (self):
            u1 = self.get_unit('Original unit: ')
            a1 = self.get_amount('Original amount: ')
            a,u = self.c.adjust_unit(a1,u1)
            print 'Most readable unit = %s %s'%(a,u)

        def return_to_continue (self):
            print 'Enter return to continue: '
            raw_input()

        def adder (self):
            u1 = self.get_unit('Enter unit 1: ')
            a1 = self.get_amount("Enter amount 1: ")
            u2 = self.get_unit('Enter unit 2: ')
            a2 = self.get_amount('Enter amount 2: ')
            result = self.c.add_reasonably(a1,u1,a2,u2)
            if result:
                print "%s %s + %s %s = %s"%(u1,a1,u2,a2,result)
            else:
                print "I'm sorry, I couldn't add that together!"
            self.return_to_continue()
            
        def quit (self):
            import sys
            sys.exit()
        
    
    #i=InteractiveConverter()

########NEW FILE########
__FILENAME__ = defaults
import locale, os
deflang = 'en'
lang = None

if os.name == 'posix':
    try:
        locale.setlocale(locale.LC_ALL,'')
    except:
        loc,enc = locale.getdefaultlocale()
    else:
        loc, enc = locale.getlocale()

# Windows locales are named differently, e.g. German_Austria instead of de_AT
# Fortunately, we can find the POSIX-like type using a different method.
elif os.name == 'nt':
    from ctypes import windll
    locid = windll.kernel32.GetUserDefaultLangID()
    loc = locale.windows_locale[locid]

if loc:
    try:
        lang = __import__('defaults_%s'%loc,globals(),locals())
    except ImportError:
        try:
            lang = __import__('defaults_%s'%loc[0:2],globals(),locals())
        except ImportError:
            lang = __import__('defaults_%s'%deflang,globals(),locals())

if not lang: lang = __import__('defaults_%s'%deflang,globals(),locals())

# The next item is used to allow us to know some things about handling the language
try:
    langProperties=lang.LANG_PROPERTIES
except:
    lang.LANG_PROPERTIES=langProperties={'hasAccents':False, 'capitalisedNouns':False, 'useFractions':True} 
    # 'hasAccents' includes accents, umlauts etc, that might not be correctly handled
    # by eg lower()
    # 'capitalisedNouns' means that you don't want to use lower() anyway, cos it's
    #  ungramatical e.g. in the german Language, Nouns are written with Capital-Letters.

# NOW WE DO AUTOMATED STUFF
def add_itm (kd, k, v):
    if kd.has_key(k):
        kd[k].append(v)
    else:
        kd[k]=[v]

## now we set up our dictionaries
lang.keydic = {}
lang.shopdic = {}
for lst in lang.SYNONYMS:
    k = lst[0]
    for i in lst:
        add_itm(lang.keydic,k,i)

for amb,lst in lang.AMBIGUOUS.items():
    if lang.keydic.has_key(amb):
        lang.keydic[amb] += lst
    else:
        lang.keydic[amb] = lst

for row in lang.INGREDIENT_DATA:
    name,key,shop=row
    add_itm(lang.keydic,key,name)
    lang.shopdic[key]=shop

lang.unit_group_lookup = {}

unit_rounding_guide = {
    'ml':1,
    'l':0.001,
    'mg':1,
    'g':1,
    'tsp.':0.075,
    'Tbs.':0.02,
    'c.':0.125,
    }

if hasattr(lang,'unit_rounding_guide'):
    unit_rounding_guide.update(lang.unit_rounding_guide)

lang.unit_rounding_guide = unit_rounding_guide


for group,v in lang.UNIT_GROUPS.items():
    n = 0
    for u,rng in v:
        lang.unit_group_lookup[u] = group,n
        n += 1

WORD_TO_SING_PLUR_PAIR = {}
if hasattr(lang,'PLURALS'):
    for forms in lang.PLURALS:
        for f in forms:
            WORD_TO_SING_PLUR_PAIR[f] = forms

def get_pluralized_form (word, n):
    from gettext import ngettext
    if not word:
        return ''
    lword=word.lower()
    if WORD_TO_SING_PLUR_PAIR.has_key(lword):
        forms = list(WORD_TO_SING_PLUR_PAIR[lword])
        forms += [n]
        return ngettext(*forms)
    elif lang.guess_singulars(lword):
        # Arbitrarily use the first item in the list returned by
        # lang.guess_singulars().
        forms = lang.guess_singulars(lword)[0:1]
        forms += [lword]
        forms += [n]
        return ngettext(*forms)
    else:
        return word


########NEW FILE########
__FILENAME__ = defaults_de
# -*- coding: utf-8 -*-
# we set up default information for our locale. 
# Translators should use this file as the basis of their translation.
# Copy this file and rename it for you locale.
#
# For example, Spanish uses:
# defaults_es.py
#
# British English uses:
# defaults_en_GB.py
#
# Please fill in the below fields:

# Language: Deutsch (German)
# Translator: 
# Last-updated: 2005-01-15 (07/18/05)

CREDITS = u""

#The next line can be used to determine some things about how to handle this language
LANG_PROPERTIES={'hasAccents':True, 'capitalisedNouns':True,'useFractions':False} 


# TRANSLATOR WARNING: DO NOT TRANSLATE THE FIELD NAMES: ONLY THE VALUES!!!

# only translate the items in the list [..] (and feel free to create
# categories that make sense for your locale -- no need to translate
# these ones). DO NOT translate 'cuisine','rating','source' or
# 'category'

# The below are Gourmet's standard fields and the default categories for them.
# Do not translate the field names ('cuisine','rating','source,'category').
# Instead, fill in the list with categories that make sense for your locale.
# Feel free to change the number or content of categories to be consistent
# with what users in your locale are likely to be familiar with.

fields={'cuisine': ['deutsch', 'amerikanisch','italienisch','französisch',
		    'mexikanisch','asiatisch','indisch','griechisch','vegetarisch'],

        'rating' : ['5 - ausgezeichnet','4 - lecker',
		    '3 - OK','2 - mittelmäßig','1 - vergiss es!',
                    '(nicht geprüft)'],

        'source' : [],

        'category' :[
		     'Nachspeise','Vorspeise','Hauptgericht',
		     'Beilage','Salat','Suppe','Frühstück',
		     'Picknick','Andere','Plan'],
                  }

# In English, there are a heck of a lot of synonyms. This is a list
# for those synonyms.  [u"preferred word","alternate word","alternate word"]
# If there are none of these that you can think of in your language, just
# set this to:
# SYNONYMS=[]

# note from translator: some terms are not standard but used in common langugage, some are used in a fautive manner, 
# I decided to put them in different sections so it is still clear what is a synonym and what should not be a synonym.
SYNONYMS=[
    # the first item of each list is the default
    [u"Cocktailtomaten", u"Tomaten, cherry"],
    [u"Alfaalfa",u"Alfapha",u"Luzerne"],
    [u"Porree",u"Lauch"],
    [u"Frühlingszwiebel",u"Lauch-Zwiebeln"],
    [u"Zuckermelone",u"Gartenmelone"],
    [u"Bleichsellerie",u"Stangensellerie", u"Straudensellerie"],
    [u"Hammelfleisch",u"Hammel"],
    [u"Kalbfleisch",u"Kalb"],
    [u"Truthahn",u"Puter",u"Pute"],
    [u"Rindfleisch",u"Rind"],
    [u"Rotbusch",u"Rooibos",u"Rooibosch"],
    [u"Seelachs",u"Köhler"],
    [u"Anschovis",u"Anchovis",u"Sardelle"],
    [u"Kabeljau",u"Dorsch"],
    [u"Nutella", u"Nusspli"],
    [u"Tomatenmark",u"Tomatenkonzentrat"],
    [u"Weizenmehl",u"Mehl, weiß"],
    [u"Soja-Milch",u"Sojamilch",u"Soya-Milch", u"Soja Milch"],
    [u"Soja-Sauce", u"sauce soja",u"sauce soya",u"Soya-Sauce",u"Sojasoße", u"Sojasosse"],
    [u"Soja",u"Soya"], 
    [u"Sojabohnen",u"Soyabohnen"], 
    [u"Püree",u"Kartoffelpüree"],
    [u"Müsli",u"Muesli"],
    [u"Nudeln",u"Pasta"],
    [u"Chile",u"Chili",u"Chilli"],
    [u"Zucchini", u"Zuchini", u"Courgette"],
    [u"Tafeltrauben",u"Trauben, weiß",u"Trauben, grün"],
    [u"Garam Masala",u"Masala",u"Massala",u"Garam Massala"],
    [u"Gemüsebouillon",u"Gemüsebrühe"],
    [u"Hühnerbouillon",u"Hühnerbrühe"],
    [u"Muskat",u"Muskatnuss",u"Muscat",u"Muscatnuss"],
    [u"Sesammus",u"Tahin"],
    [u"Brokkoli", u"Broccoli"], 
    [u"Kräuter",u"gemischte Kräuter"],
    [u"Langkornreis",u"Reis"],
    [u"Eierschwammerl",u"Pfifferlinge"],
    [u"Herrenpilze",u"Steinpilze"],
    [u"Paradeiser",u"Tomaten"],

    # Irregular plurals
    [u"Äpfel",u"Apfel"],
    [u"Pfirsiche"u"Pfirsich"],
    [u"Nüsse", u"Nuss"],
    [u"Eier",u"Ei"]

    #non-standard usage
 
    #fautive/discouraged usages
     ]

# A DICTIONARY CONTAINING INGREDIENT KEYS AND NDBNO for the USDA
# nutritional database. For these items, we will have nutritional
# information by default.

NUTRITIONAL_INFO = {}

# a dictionary for ambiguous words.
# key=ambiguous word, value=list of possible non-ambiguous terms
#
# Translators: if you have a word that has more than one food meaning
# in your language, you can add an entry as follow

# AMBIGUOUS = {
#              'word':['meaning1','meaning2','meaning3'],
#             }

AMBIGUOUS = {
    'Sellerie':['Sellerie','Straudensellerie'],
    }


# triplicates ITEM, KEY, SHOPPING CATEGORY
# These will be defaults.

# They should include whatever foods might be standard for your
# locale, with whatever sensible default categories you can think of
# (again, thinking of your locale, not simply translating what I've
# done).

# Items provided here will automatically be recognized and go onto the
# given category in a user's shopping list by default.

# Don't feel obligated to translate every item -- especially since not
# all items will be common for all locales. However, the more items
# you can put here, the more the user will get the sense that gourmet
# u"knows" about foods that they enter.

# I generated the below list using the wikipedia entry on foods as my
# starting point. You may want to do something similar for your
# locale.  Also, if the syntax of the below is too complicated, you
# can send me a list of category headings and ingredients for your
# locale and I'll do the necessary formatting <Thomas_Hinkle@alumni.brown.edu>

INGREDIENT_DATA = [  ## G e m ü s e  
		   [u"Alfaalfa",u"Alfalfa",u"Gemüse"],                 			#alfalfa sprouts
                   [u"Anis",u"Anis",u"Gemüse"],                       			#anise
                   [u"Artischocke",u"Artischocke",u"Gemüse"],				#artichoke
                   [u"Ölranke",u"Ölranke",u"Gemüse"],					#rocket
                   [u"Spargel",u"Spargel",u"Gemüse"],					#asparagus (white)
                   [u"weißer Spargel",u"Spargel, weißer",u"Gemüse"],			#asparagus - white
                   [u"grüner Spargel",u"Spargel, grüner",u"Gemüse"],			#asparagus - green
                   [u"Aubergine",u"Aubergine",u"Gemüse"],					#aubergine
                   [u"Avocado",u"Avocado",u"Gemüse"],					#avocado
                   [u"Brokkoli",u"Brokkoli",u"Gemüse"],					#broccoli
	           [u"Spinat",u"Spinat",u"Gemüse"],					#spinach
                   [u"Rosenkohl",u"Kohl, Rosenkohl",u"Gemüse"],				#brussels sprouts
                   [u"Kohl",u"Kohl",u"Gemüse"],						#cabbage
                   [u"Weißkohl",u"Kohl, Weißkohl",u"Gemüse"],				#white cabbage
                   [u"Rotkohl",u"Kohl, Rotkohl",u"Gemüse"],				#red cabbage
                   [u"Blumenkohl",u"Kohl, Blumenkohl",u"Gemüse"],				#cauliflower
                   [u"Chinakohl",u"Kohl, Chinakohl",u"Gemüse"],				#china cabbage
                   [u"Kohlrabi",u"Kohl, Kohlrabi",u"Gemüse"],				#kohlrabi
                   [u"Grünkohl",u"Kohl, Grünkohl",u"Gemüse"],				#kale

                   [u"Bleichsellerie",u"Bleichsellerie",u"Gemüse"],			#celery
                   [u"Zitronengras",u"Zitronengras",u"Gemüse"],				#lemon grass
                   [u"Mais",u"Mais",u"Gemüse"],						#corn

                   [u"Champignons",u"Champignons",u"Gemüse"],				#button mushrooms
                   [u"Pilze",u"Pilze",u"Gemüse"],						#large mushrooms
                   [u"Steinpilz",u"Steinpilze",u"Gemüse"],				#mushrooms
		   [u"Pfifferlinge",u"Pfifferlinge",u"Gemüse"],				#other woodland fungus

                   [u"Senfkeimlinge",u"Senfkeimlinge",u"Gemüse"],				#mustard greens
                   [u"Brennessel",u"Brennessel",u"Gemüse"],				#nettles
                   [u"Okra",u"Okra",u"Gemüse"],						#okra
                   [u"Schnittlauch",u"Schnittlauch",u"Gemüse"],				#chives

                   [u"Zwiebeln",u"Zwiebeln",u"Gemüse"],					#onion
                   [u"Schalotte",u"Schalotte",u"Gemüse"],					#shallot
                   [u"Frühlingszwiebel",u"Frühlingszwiebel",u"Gemüse"],			#spring onion, scallion
                   [u"rote Zwiebeln, rot",u"Zwiebeln, rote",u"Gemüse"],			#red (spanish) onion
                   [u"weiße Zwiebeln",u"Zwiebeln, weiße",u"Gemüse"],			#white onion
                   [u"gelbe Zwiebeln",u"Zwiebeln, gelbe",u"Gemüse"],			#yellow onion
                   [u"Metzgerzwiebeln",u"Zwiebeln, Metzger-",u"Gemüse"],			#large onion (salad)
                   [u"Speisezwiebeln",u"Zwiebeln, Speise-",u"Gemüse"],			#standard cooking onion
                   [u"Knoblauch",u"Knoblauch",u"Gemüse"],					#garlic
                   [u"Porree",u"Porree",u"Gemüse"],					#leek

                   [u"Paprika",u"Paprika",u"Gemüse"],					#pepper
                   [u"rote Paprika",u"Paprika, rote",u"Gemüse"],				#red bell pepper
                   [u"grüne Paprika",u"Paprika, grüne",u"Gemüse"],			#
                   [u"gelbe Paprika",u"Paprika, gelbe",u"Gemüse"],			#
                   [u"Chile",u"Chile",u"Gemüse"],						#chilli pepper
                   [u"Jalapeño-Chile",u"Chile, Jalapeño",u"Gemüse"],			#jalapeño pepper
                   [u"Habanero-Chile",u"Chile, Habanero",u"Gemüse"],			#habanero pepper

                   [u"Radieschen",u"Radieschen",u"Gemüse"],				#radish
                   [u"Rote Beet",u"Rote Beet",u"Gemüse"],					#beetroot
                   [u"Möhren",u"Möhren",u"Gemüse"],					#carrot
	           [u"Rettich",u"Rettich",u"Gemüse"],					#horse radish
                   [u"Wasabi",u"Wasabi",u"Gemüse"],					#japanese horseraddish
                   [u"Sellerie",u"Sellerie",u"Gemüse"],					#celeriac
                   [u"Pastinake",u"Pastinake",u"Gemüse"],					#parsnip
                   [u"Kohlrübe",u"Kohlrübe",u"Gemüse"],					#turnip
                   [u"Fenchel",u"Fenchel",u"Gemüse"],					#fennel

                   [u"Kopfsalat",u"Kopfsalat",u"Gemüse"],					#lettuce 
                   [u"Rucolasalat",u"Rucolasalat",u"Gemüse"],				#rucola 
                   [u"Friseesalat",u"Friseesalat",u"Gemüse"],				#open lettuce 
                   [u"Feldsalat",u"Feldesalat",u"Gemüse"],				#lettuce 

                   [u"Saubohnen",u"Saubohnen",u"Gemüse"],					#broad beans
                   [u"Bobby Bohnen",u"Bobby Bohnen",u"Gemüse"],				#small green beans
                   [u"Haricots",u"Haricots",u"Gemüse"],					#haricot beans
                   [u"Carbasc",u"Carbasc",u"Gemüse"],					#runner beans
                   [u"Erbsen",u"Erbsen",u"Gemüse"],					#peas
                   [u"Zuckererbsen",u"Zuckererbsen",u"Gemüse"],				#mange tous

                   [u"Zucchini",u"Zucchini",u"Gemüse"],					#zucchini
                   [u"Gurke (Salat-)",u"Gurke (Salat-)",u"Gemüse"],			#cucumber

                   [u"Kürbis",u"Kürbis",u"Gemüse"],					#pumpkin

                   [u"Cocktailtomaten",u"Tomaten, Cocktail-",u"Gemüse"],			#cocktail (cherry) tomato
                   [u"Tomaten",u"Tomaten",u"Gemüse"],					#cherry tomato
                   [u"Rispentomaten",u"Tomaten, Rispen-",u"Gemüse"],			#tomato on stems

                   [u"Kartoffel",u"Kartoffel",u"Gemüse"],					#potato
                   [u"Speisekartoffeln",u"Kartoffeln, Speise-",u"Gemüse"],		#standard cooking potatoes
                   [u"Süßkartoffel",u"Süßkartoffel",u"Gemüse"],				#sweet potato

                   [u"Jamswurzel",u"Jamswurzel",u"Gemüse"],				#yam
                   [u"Wasserkastanie",u"Wasserkastanie",u"Gemüse"],			#water chestnut
                   [u"Brunnenkresse",u"Brunnenkresse",u"Gemüse"],				#watercress

                   [u"Oliven",u"Oliven",u"Gemüse"],					#
                   [u"grüne Oliven",u"Oliven, grüne",u"Gemüse"],				#
                   [u"schwarze Oliven",u"Oliven, schwarze",u"Gemüse"],			#


                   ## H ü l s e n f r u c h t e
                   [u"grüne Bohnen",u"Bohnen, grüne",u"Gemüse"],				#green beans
                   [u"weiße Bohnen",u"Bohnen, weiße",u"Hülsenfrüchte"],			#green beans
                   [u"Azuki Bohnen",u"Bohnen, Azuki",u"Hülsenfrüchte"],			#azuki beans
                   [u"schwarze Bohnen",u"Bohnen, schwarze",u"Hülsenfrüchte"],		#black beans
                   [u"Borlottibohnen",u"Bohnen, Borlotti-",u"Hülsenfrüchte"],		#borlotti beans (not sure)
                   [u"Kichererbsen",u"Kichererbsen",u"Hülsenfrüchte"],			#chickpeas, garbanzos, or ceci beans
                   [u"Kidneybohnen",u"Bohnen, Kidney-",u"Hülsenfrüchte"],			#kidney beans
                   [u"Teller-Linsen",u"Linsen, Teller-",u"Hülsenfrüchte"],			#standard lentils
                   [u"rote Linsen",u"Linsen, rote",u"Hülsenfrüchte"],			#red lentils
                   [u"grüne Linsen",u"Linsen, grüne",u"Hülsenfrüchte"],			#green lentils
                   [u"schwarze Linsen",u"Linsen, schwarze",u"Hülsenfrüchte"],		#black lentils
                   [u"Gartenbohnen",u"Gartenbohnen",u"Gemüse"],				#lima bean or butter bean
                   [u"Mungbohnen",u"Bohnen, Mung-",u"Hülsenfrüchte"],			#mung beans
                   [u"Sojabohnen",u"Bohnen, Soja-",u"Hülsenfrüchte"],			#soybeans
                   [u"grüne Erbsen",u"Erbsen, grüne",u"Hülsenfrüchte"],			#green dried peas
                   [u"gelbe Erbsen",u"Erbsen, gelbe",u"Hülsenfrüchte"],			#yellow dried peas
                   [u"Schälerbsen",u"Erbsen, Schälerbsen",u"Hülsenfrüchte"],		#

                   ## F r u c h t e
                   [u"Obst",u"Obst",u"Obst"],						#general fruit
                   [u"Äpfel",u"Äpfel",u"Obst"],						#apple
                   [u"rote Äpfel",u"Äpfel, rote",u"Obst"],					#
                   [u"goldene Äpfel",u"Äpfel, goldene",u"Obst"],				#
                   [u"Granny Smith Äpfel",u"Äpfel, Granny Smith",u"Obst"],		#
                   [u"Fuji Äpfel",u"Äpfel, Fuji-",u"Obst"],				#
                   [u"grüne Äpfel",u"Äpfel, grüne",u"Obst"],				#green apple
                   [u"Granatäpfel",u"Granatäpfel",u"Obst"],				#pomegranate
                   [u"Quitte",u"Quitte",u"Obst"],						#quince
                   [u"Hagebutten",u"Hagebutten",u"Obst"],					#rose hip
                   [u"Aprikosen",u"Aprikosen",u"Obst"],					#apricot
                   [u"Birnen",u"Birnen",u"Obst"],						#pear
                   [u"Conference Birnen",u"Birnen, Conference",u"Obst"],			#pear, large conference
                   [u"William Birnen",u"Birnen, William",u"Obst"],			#pear, standard william
                   [u"Kirschen",u"Kirschen",u"Obst"],					#cherry
                   [u"Pflaumen",u"Pflaumen",u"Obst"],					#plum
                   [u"Pfirsiche",u"Pfirsiche",u"Obst"],					#peach
                   [u"Nektarinen",u"Nektarinen",u"Obst"],					#nectarine
                   [u"Brombeeren",u"Beeren, Brombeeren",u"Obst"],				#blackberry
                   [u"Himbeeren",u"Beeren, Himbeeren",u"Obst"],				#raspberry
                   [u"Erdbeeren",u"Beeren, Erdbeeren",u"Obst"],				#raspberry
                   [u"Heidelbeeren",u"Beeren, Heidelbeeren",u"Obst"],			#bilberry
                   [u"Blaubeeren",u"Beeren, Blaubeeren",u"Obst"],				#blueberry
                   [u"Preiselbeeren",u"Beeren, Preiselbeeren",u"Obst"],			#cranberry
                   [u"Johannisbeeren",u"Beeren, Johannisbeeren",u"Obst"],			#red currant
                   [u"schwarze Johannisbeeren",u"Beeren, schwarze Johannisbeeren",u"Obst"],#black currant
                   [u"Holunderbeeren",u"Beeren, Holunderbeeren",u"Obst"],			#elderberry
                   [u"Stachelbeeren",u"Stachelbeeren",u"Obst"],				#gooseberry
                   [u"Kiwi",u"Kiwi",u"Obst"],						#kiwi fruit
                   [u"Papaya",u"Papaya",u"Obst"],						#pawpaw
                   [u"Zuckermelonen",u"Zucker-",u"Obst"],					#cantaloupe
                   [u"Honigmelonen",u"Melonen, Honig-",u"Obst"],				#honeydew melon
                   [u"Galiamelonen",u"Melonen, Galia-",u"Obst"],				#galia melon
                   [u"Netzmelonen",u"Melonen, Netz-",u"Obst"],				#net melon
                   [u"Wassermelonen",u"Melonen, Wasser-",u"Obst"],			#watermelon
                   [u"Feigen",u"Feigen",u"Obst"],						#fig
                   [u"Weintrauben",u"Weintrauben",u"Obst"],				#grape
                   [u"Tafeltrauben",u"Weintrauben, Tafel",u"Obst"],			#green grapes
                   [u"blaue Weintrauben",u"Weintrauben, blau",u"Obst"],			#black grapes
                   [u"Datteln",u"Datteln",u"Obst"],					#date
                   [u"Grapefruit",u"Grapefruit",u"Obst"],					#grapefruit
                   [u"Limetten",u"Limetten",u"Obst"],					#lime
                   [u"Kumquat",u"Kumquat",u"Obst"],					#kumquat
                   [u"Zitronen",u"Zitronen",u"Obst"],					#lemon
                   [u"Mandarinen",u"Mandarinen",u"Obst"],					#mandarin
                   [u"Klementinen",u"Klementinen",u"Obst"],				#clementine
                   [u"Tangerinen",u"Tangerinen",u"Obst"],					#tangerine
                   [u"Orangen",u"Orangen",u"Obst"],					#orange
                   [u"Ugli",u"Ugli",u"Obst"],						#ugli fruit
                   [u"Guave",u"Guave",u"Obst"],						#guava
                   [u"Litschi",u"Litschi",u"Obst"],					#lychee
                   [u"Passionsfrucht",u"Passionsfrucht",u"Obst"],				#passion fruit
                   [u"Banane",u"Banane",u"Obst"],						#banana
                   [u"Wegerich",u"Wegerich",u"Obst"],					#plantain
                   [u"Kokosnuss",u"Kokosnuss",u"Obst"],					#coconut
                   [u"Durion",u"Durion",u"Obst"],						#durian
                   [u"Mango",u"Mangue",u"Obst"],						#mango
                   [u"Papaya",u"Papaya",u"Obst"],						#papaya
                   [u"Ananas",u"Ananas",u"Obst"],						#pineapple
                   [u"Tamarinde",u"Tamarinde",u"Obst"],					#tamarind
                   [u"Rhabarber",u"Rhabarber",u"Obst"],					#rhubarb
 

                   ## M e e r e s f r ü c h t e
                   [u"Anchovis",u"Anchovis",u"Meeresfrüchte"],				#anchovy
                   [u"Barsch",u"Barsch",u"Meeresfrüchte"],					#bass
                   [u"Kugelfisch",u"Kugelfisch",u"Meeresfrüchte"],				#blowfish
                   [u"Wels",u"Wels",u"Meeresfrüchte"],					#catfish
                   [u"Dorsch",u"Dorsch",u"Meeresfrüchte"],					#cod
                   [u"Aal",u"Aal",u"Meeresfrüchte"],					#eel
                   [u"Flunder",u"Flunder",u"Meeresfrüchte"],				#flounder
                   [u"Schellfisch",u"Schellfisch",u"Meeresfrüchte"],			#haddock
                   [u"Haddock",u"Haddock",u"Meeresfrüchte"],				#smoked haddock
                   [u"Heilbutt",u"Heilbutt",u"Meeresfrüchte"],				#halibut
                   [u"Zander",u"Zander",u"Meeresfrüchte"],					#pike
                   [u"Seelachs",u"Seelachs",u"Meeresfrüchte"],				#pollock
                   [u"Sardine",u"Sardine",u"Meeresfrüchte"],				#sardine
                   [u"Sprotte",u"Sprotte",u"Meeresfrüchte"],				#sprat
                   [u"Lachs",u"Lachs",u"Meeresfrüchte"],					#salmon
                   [u"Sägebarsch",u"Sägebarsch",u"Meeresfrüchte"],				#sea bass
                   [u"Hai",u"Hai",u"Meeresfrüchte"],					#shark
                   [u"Seezunge",u"Seezunge",u"Meeresfrüchte"],				#sole
                   [u"Stör",u"Stör",u"Meeresfrüchte"],					#sturgeon
                   [u"Schwertfisch",u"Schwertfisch",u"Meeresfrüchte"],			#swordfish
                   [u"Forelle",u"Forelle",u"Meeresfrüchte"],				#trout
                   [u"Thunfisch",u"Thunfisch",u"Meeresfrüchte"],				#tuna
                   [u"Weißfisch",u"Weißfisch",u"Meeresfrüchte"],				#whitefish
                   [u"Wittling",u"Wittling",u"Meeresfrüchte"],				#whiting
                   [u"Rogen",u"Rogen",u"Meeresfrüchte"],					#roe of fish
                   [u"Kaviar",u"Kaviar",u"Meeresfrüchte"],					#caviar
                   [u"Krebs",u"Krebs",u"Meeresfrüchte"],					#crab
                   [u"Hummer",u"Hummer",u"Meeresfrüchte"],				#lobster
                   [u"Garnele",u"Garnele",u"Meeresfrüchte"],				#prawns
                   [u"Krabbe",u"Krabbe",u"Meeresfrüchte"],					#shrimp
                   [u"Klaffmuschel",u"Klaffmuschel",u"Meeresfrüchte"],			#clam
                   [u"Muschel",u"Muschel",u"Meeresfrüchte"],				#mussel
                   [u"Tintenfisch",u"Tintenfisch",u"Meeresfrüchte"],			#octopus
                   [u"Auster",u"Auster",u"Meeresfrüchte"],					#oyster
                   [u"Schnecke",u"Schnecke",u"Meeresfrüchte"],				#snail
                   [u"Kalmar",u"Kalmar",u"Meeresfrüchte"],				#squid
                   [u"Kammuschel",u"Kammuschel",u"Meeresfrüchte"],			#scallop

                   ## F l e i s c h
                   [u"Speck",u"Speck",u"Fleisch"],						#chopped bacon 
                   [u"Bacon",u"Bacon",u"Fleisch"],						#bacon 
                   [u"Schinken",u"Schinken",u"Fleisch"],					#ham
                   [u"Hammel",u"Hammel",u"Fleisch"],					#mutton
                   [u"Lamm",u"Lamm",u"Fleisch"],						#lamb
                   [u"Kalb",u"Kalb",u"Fleisch"],						#veal
                   [u"Steak",u"Steak",u"Fleisch"],						#steak
                   [u"Hamburger",u"Hamburger",u"Fleisch"],				#hamburger
                   [u"Roastbeef",u"Roastbeef",u"Fleisch"],					#roast beef
                   [u"Hähnchen",u"Hähnchen",u"Fleisch"],					#chicken
                   [u"Pute",u"Pute",u"Fleisch"],						#turkey
                   [u"Ente",u"Ente",u"Fleisch"],						#duck
                   [u"Gans",u"Gans",u"Fleisch"],						#goose
		   [u"Rind",u"Rind",u"Fleisch"],						#beef
		   [u"Hackfleisch",u"Hackfleisch",u"Fleisch"],				#mince beef
		   [u"Hase",u"Hase",u"Fleisch"],						#hare
		   [u"Kaninchen",u"Kaninchen",u"Fleisch"],					#rabbit
		   [u"Hirsch",u"Hirsch",u"Fleisch"],					#deer
                   [u"Hühnerbrust",u"Hühnerbrust",u"Fleisch"],				#chicken breast
                   [u"Schweinefleisch",u"Schweinefleisch",u"Fleisch"],			#pork
                   [u"Chorizo",u"Chorizo",u"Fleisch"],					#chorizo
                   [u"Salami",u"Salami",u"Fleisch"],					#salami
                   [u"Wurst",u"Wurst",u"Fleisch"],						#sausage
                   [u"Bratwurst",u"Bratwurst",u"Fleisch"],					#sausage
                   [u"Weißwurst",u"Weißwurst",u"Fleisch"],					#sausage
                   [u"Currywurst",u"Currywurst",u"Fleisch"],				#sausage

		   ## L e b e n s m i t t e l
                   [u"Weizenmehl",u"Mehl, Weizen-",u"Lebensmittel"],			#all purpose flour
                   [u"Vollkorn Weizenmehl",u"Mehl, Vollkorn Weizen-",u"Lebensmittel"],	#wholemeal flour 
                   [u"Hirsemehl",u"Mehl, Hirse-",u"Lebensmittel"],			#flour
                   [u"Roggenmischung",u"Mehl, Roggenmischung",u"Lebensmittel"],		#rye flour
                   [u"Backpulver",u"Backpulver",u"Lebensmittel"],				#baking powder
                   [u"Natron",u"Natron",u"Lebensmittel"],					#baking soda
                   [u"Schokolade",u"Schokolade",u"Lebensmittel"],				#chocolate
                   [u"Schokotröpfen",u"Schokotröpfen",u"Lebensmittel"],			#chocolate chips
                   [u"Zucker",u"Zucker",u"Lebensmittel"],					#suger
		   [u"Süßstoff",u"Süßstoff",u"Lebensmittel"],				#artificial sweetner 
                   [u"brauner Zucker",u" Zucker, braun",u"Lebensmittel"],			#brown suger
                   [u"weißer Zucker",u"Zucker, weiß",u"Lebensmittel"],			#white sugar
                   [u"Raffinade",u"Zucker, Raffinade",u"Lebensmittel"],			#castor sugar
                   [u"Salz",u"Salz",u"Lebensmittel"],					#salt
                   [u"Meersalz",u"Salz, Meer-",u"Lebensmittel"],				#sea salt
                   [u"Rosinen",u"Rosinen",u"Lebensmittel"],				#currents
                   [u"Sultanienen",u"Sultanienen",u"Lebensmittel"],			#sultanas
                   [u"geraspelte Kokosnuss",u"Kokosnuss, geraspelt",u"Lebensmittel"],	#(modifier?)
                   [u"Vanille",u"Vanille",u"Lebensmittel"],				#vanilla
                   [u"Vanilleessenz",u"Vanilleessenz",u"Lebensmittel"],			#vanilla extract
                   [u"Walnusskerne",u"Walnusskerne",u"Lebensmittel"],			#walnut
                   [u"Cashewnüsse",u"Cashewnüsse",u"Lebensmittel"],			#cashew nut
                   [u"Mandeln",u"Mandeln",u"Lebensmittel"],				#almonds
                   [u"Erdnüsse",u"Erdnüsse",u"Lebensmittel"],				#peanut
                   [u"Kartoffelpüree",u"Kartoffelpüree",u"Lebensmittel"],			#potato mash
                   [u"Klöße",u"Klöße",u"Lebensmittel"],					#potato dumplings
                   [u"Polenta",u"Polenta",u"Lebensmittel"],				#yellow cornmeal
                   [u"kernige Haferflocken",u"Haferflocken, kernig",u"Lebensmittel"],	#rolled oats
                   [u"zarte Haferflocken",u"Haferflocken, zart",u"Lebensmittel"],		#fine rolled oats
                   [u"Ketchup",u"Ketchup",u"Lebensmittel"],				#ketchup
                   [u"Mayonnaise",u"Mayonnaise",u"Lebensmittel"],				#mayonnaise
		   [u"Knäckebrot",u"Knäckebrot",u"Lebensmittel"],				#ryebread wafers
		   [u"Dosentomaten",u"Tomaten, Dosen-",u"Lebensmittel"],			#canned tomatoes
		   [u"Dosenmais",u"Mais, Dosen-",u"Lebensmittel"],			#canned sweetcorn

                   [u"Sonnenblumenkerne",u"Sonnenblumenkerne",u"Lebensmittel"],		#sunflower seeds
                   [u"Sesammus",u"Sesammus",u"Lebensmittel"],				#sesame seeds

                   [u"Zitronensaft",u"Zitronensaft",u"Lebensmittel"],			#lemon juice
                   [u"Zitronenkonzentrat",u"Zitronenkonzentrat",u"Lebensmittel"],		#lemon concentrate
                   [u"Limettensaft",u"Saft, Limetten-",u"Lebensmittel"],			#lime juice
                   [u"Orangensaft",u"Saft, Orangen",u"Lebensmittel"],			#whole orange juice
                   [u"Orangennektar",u"Saft, Orangennektar",u"Lebensmittel"],		#orange juice

                   [u"Tomatensuppe",u"Tomatensuppe",u"Lebensmittel"],			#tomato sauce
                   [u"Bouillon",u"Bouillon",u"Lebensmittel"],				#broth
		   [u"Gemüsebouillon",u"Bouillon, Gemüse-",u"Lebensmittel"],		#vegetable broth
    		   [u"Hühnerbouillon",u"Bouillon, Hühner-",u"Lebensmittel"],		#broth, chicken
                   [u"Hollandaise",u"Hollandaise",u"Lebensmittel"],			#hollandais sauce

                   [u"gehackte Tomaten",u"Tomaten, gehackt",u"Lebensmittel"],		#chopped tomato
                   [u"geschälte Tomaten",u"Tomaten, geschält",u"Lebensmittel"],		#peeled tomato
                   [u"passierte Tomaten",u"Tomaten, passiert",u"Lebensmittel"],		#mashed tomato
                   [u"Tomatenmark",u"Tomatenmark",u"Lebensmittel"],			#pureed tomato

                   [u"Kekse",u"Kekse",u"Lebensmittel"],					#biscuits
                   [u"Müsli",u"Müsli",u"Lebensmittel"],					#muesli
                   [u"Pudding",u"Pudding",u"Lebensmittel"],				#instant custard pudding
		   [u"Stärke",u"Stärke",u"Lebensmittel"],					#corn starch

		   ## R e i s   u n d   T e i g w a r e n
                   [u"Nudeln",u"Nudeln",u"Reis & Teigwaren"],				#pasta
                   [u"Spaghetti",u"Spagghetti",u"Reis & Teigwaren"],			#spaghetti
                   [u"Penne",u"Penne",u"Reis & Teigwaren"],				#pasta tubes
                   [u"Canelonni",u"Canelonni",u"Reis & Teigwaren"],			#
                   [u"Fusilli",u"Fusilli",u"Reis & Teigwaren"],				#pasta twirls
                   [u"Riccioli",u"Riccioli",u"Reis & Teigwaren"],				#pasta twirls
                   [u"Lasagna",u"Lasagna",u"Reis & Teigwaren"],				#pasta sheets
		   [u"Vermicelli",u"Vermicelli",u"Reis & Teigwaren"],			#vermicelli

                   [u"Teig",u"Teig",u"Reis & Teigwaren"],					#dough
		   [u"Hefeteig", u"Teig, Hefe-",u"Reis & Teigwaren"],			#pastry dough
                   [u"Pizzateig",u"Teig, Pizza-",u"Reis & Teigwaren"],			#pizza dough

                   [u"Langkornreis",u"Reis, Langkorn-",u"Reis & Teigwaren"],		#rice longcorn
                   [u"Basmatireis",u"Reis, Basmati-",u"Reis & Teigwaren"],		#basmati rice
                   [u"Milchreis",u"Reis, Milch-",u"Reis & Teigwaren"],			#pudding rice
                   [u"Naturreis",u"Reis, Natur-",u"Reis & Teigwaren"],			#whole rice
                   [u"Wildreis",u"Reis, Wild-",u"Reis & Teigwaren"],			#wild (black) rice
                   [u"Spitzenlangkornreis",u"Reis, Spitzenlangkorn-",u"Reis & Teigwaren"],	#rice longcorn cook

                   ## B r o t
                   [u"Brot",u"Brot, allgemeines",u"Brot"],				#bread, any
                   [u"Weißbrot",u"Brot, weiß",u"Brot"],					#white bread
                   [u"Toastbrot",u"Brot, Toast-",u"Brot"],					#sliced white toasting bread
                   [u"Vollkornbrot",u"Brot, Vollkorn-",u"Brot"],				#wholemeal bread
                   [u"Sonnenblumenkernbrot",u"Brot, Sonnenblumenkern-",u"Brot"],		#sunflower seed wholmeal
                   [u"Kürbiskernbrot",u"Brot, Kürbiskern-",u"Brot"],			#pupkin seed wholemeal
                   [u"Sesambrot",u"Brot, Sesam-",u"Brot"],				#sesame seed wholemeal
                   [u"Dreikornbrot",u"Brot, Dreikorn-",u"Brot"],				#3 corn wholemeal bread
                   [u"Krustenbrot",u"Brot, Krusten-",u"Brot"],				#Crusty wholemeal bread
                   [u"Landbrot",u"Brot, Land-",u"Brot"],					#wholemeal bread
                   [u"Fladenbrot",u"Brot, Fladen-",u"Brot"],				#turkish round bread
                   [u"Pumpernickel",u"Pumpernickel",u"Brot"],				#pumpernickel bread


		   ## K r ä u t e r   u n d   G e w ü r z e
                   [u"Kräuter",u"Kräuter, gemischt",u"Gemüse"],				#mixed herbs
                   [u"Petersilie",u"Petersilie",u"Gemüse"],				#parsley
                   [u"schwarze Pfeffer",u"Pfeffer schwarz",u"Kräuter u Gewürze"],		#black pepper
                   [u"Cayennepfeffer",u"Pfeffer, Cayenne",u"Kräuter u Gewürze"],           #cayenne
                   [u"Kräuter de Provence",u"Kräuter de Provence",u"Kräuter u Gewürze"],   #Herbs de Provence
                   [u"Kräutersalz",u"Kräutersalz",u"Kräuter u Gewürze"],                   #Herbed salt
                   [u"Lorbeerblatt",u"Lorbeerblatt",u"Kräuter u Gewürze"],                 #Bay leaf
                   [u"Gewürznelken",u"Gewürznelken",u"Kräuter u Gewürze"],                 #
                   [u"Chilipulver",u"Chilipulver",u"Kräuter u Gewürze"],			#(modifier?)
                   [u"Curry",u"Curry",u"Kräuter u Gewürze"],				#curry powder
                   [u"Currypaste",u"Currypaste",u"Kräuter u Gewürze"],			#curry paste
                   [u"Madras Curry",u"Curry, madras",u"Kräuter u Gewürze"],		#hotter curry powder
                   [u"Garam Masala",u"Garam Masala",u"Kräuter u Gewürze"],		#
                   [u"Zimtschote",u"Zimt, Zimtschote",u"Kräuter u Gewürze"],		#(modifier?)
                   [u"gemahlener Zimt",u"Zimt, gemahlener",u"Kräuter u Gewürze"],		#(modifier?)
                   [u"Korianderkerne",u"Korianderkerne",u"Kräuter u Gewürze"],		#(modifier?)
                   [u"gemahlener Koriander",u"Koriander, gemahlener",u"Kräuter u Gewürze"],#(modifier?)
                   [u"Cuminkerne",u"Cuminkerne",u"Kräuter u Gewürze"],			#(modifier?)
                   [u"gemahlener Cumin",u"Cumin, gemahlener",u"Kräuter u Gewürze"],	#(modifier?)
                   [u"Senfkerne",u"Senfkerne",u"Kräuter u Gewürze"],			#(modifier?)
                   [u"Senf",u"Senf",u"Kräuter u Gewürze"],					#(modifier?)
                   [u"Dijon-Senf",u"Senf, Dijon",u"Kräuter u Gewürze"],			#(modifier?)
                   [u"Muskatnuss",u"Muskatnuss",u"Kräuter u Gewürze"],			#nutmeg
                   [u"Paprika, gemahlen",u"Paprika, gemahlen",u"Kräuter u Gewürze"],	#
                   [u"Ingwerpulver",u"Ingwer, Ingwerpulver",u"Kräuter u Gewürze"],		#ground ginger
                   [u"Kurkuma",u"Kurkuma",u"Kräuter u Gewürze"],				#turmeric, curcuma
                   [u"Majoran",u"Majoran",u"Kräuter u Gewürze"],				#turmeric, curcuma
                   [u"Oregano",u"Oregano",u"Kräuter u Gewürze"],				#oregano
                   [u"Basilikum, gerebelt",u"Basilikum, gerebelt",u"Kräuter u Gewürze"],	#basil, crushed
                   [u"frisches Basilikum",u"Basilikum, frisches",u"Kräuter u Gewürze"],	#fresh basil leaves
                   [u"frischer Koriander",u"Koriander, frischer",u"Kräuter u Gewürze"],	#fresh coriander leaves
                   [u"frisches Schnittlauch",u"Schnittlauch, frisches",u"Kräuter u Gewürze"],	#fresh chives
                   [u"frischer Ingwer",u"Ingwer, frischer",u"Kräuter u Gewürze"],		#fresh ginger
                   [u"Ingwerpaste",u"Ingwerpaste",u"Kräuter u Gewürze"],			#ginger paste


		   ## M a r m e l a d e
		   [u"Pflaumenmarmelade",u"Marmelade, Pflaumen-",u"Konfitüren"],		#plum jam
		   [u"Aprikosenmarmelade",u"Marmelade, Aprikosen-",u"Konfitüren"],	#apricot jam
		   [u"Orangenmamalade",u"Marmalade, Orangen-",u"Konfitüren"],		#orange jam
		   [u"Marmelade",u"Marmelade",u"Konfitüren"],				#jam - general
		   [u"Erdbeermarmelade",u"Marmelade, Erdbeer-",u"Konfitüren"],		#strawberry jam
		   [u"Himbeermarmelade",u"Marmelade, Himbeer-",u"Konfitüren"],		#raspberry jam
		   [u"Erdnussbutter",u"Erdnussbutter",u"Konfitüren"],			#peanut butter
		   [u"Nutella",u"Nutella",u"Konfitüren"],					#nussply
		   [u"Sesammus",u"Sesammus",u"Konfitüren"],				#tahini - sesame spread
                   [u"Honig",u"Honig",u"Konfitüren"],					#honey

		   ## I n t e r n a t i o n a l
                   [u"Tartex",u"Tartex",u"International"],					#tartex spread
                   [u"Kokosmilch",u"Kokusmilch",u"International"],			#coconut milk
                   [u"Kokoscreme",u"Kokuscreme",u"International"],			#coconut cream
                   [u"grüne Currypaste",u"Currypaste, grüne",u"International"],		#green curry paste
                   [u"rote Currypaste",u"Currypaste, rote",u"International"],		#red curry paste
                   [u"Reisessig",u"Essig, Reis-",u"International"],			#rice vinegar
                   [u"Salsa",u"Salsa",u"International"],					#salsam
                   [u"Sesamkerne",u"Sesamkerne",u"International"],			#sesame seeds
                   [u"Soja-Sauce",u"Soja-Sauce",u"International"],				#soy sauce
                   [u"Sojacreme",u"Sojacreme",u"International"],		                #soya cream
		   [u"Bulgur",u"Bulgur",u"International"],					#bulgar
                   [u"Couscous",u"Couscous",u"International"],				#couscous
                   [u"Falafel",u"Falafel",u"International"],				#felafel
                   [u"Tofu",u"Tofu",u"International"],					#tofu
                   [u"Pak-choï",u"Pak-choï",u"Gemüse"],					#bok choy
	
		   ## M i l c h p r o d u k t e
                   [u"Milch",u"Milch",u"Milchprodukte"],					#milk, unspecified
                   [u"Käse",u"Käse, allgemeiner",u"Milchprodukte"],			#cheese, any
                   [u"Butter",u"Butter",u"Milchprodukte"],					#butter
                   [u"Margarine",u"Margarine",u"Milchprodukte"],				#	
                   [u"Eier",u"Eier",u"Milchprodukte"],					#egg
                   [u"frische Milch",u"Milch, frische",u"Milchprodukte"],			#milk
                   [u"fettarme Milch",u"Milch, fettarme",u"Milchprodukte"],		#skimmed milk
		   [u"H-Milch",u"Milch, H-Milch",u"Milchprodukte"],			#long-life milk
		   [u"Sojamilch",u"Milch, Sojamilch", u"Milchprodukte"],			#soya milk
		   [u"Buttermilch",u"Milch, Buttermilch",u"Milchprodukte"],		#buttermilk
                   [u"Sauerrahm",u"Sauerrahm",u"Milchprodukte"],				#sour cream
		   [u"Sahne",u"Sahne",u"Milchprodukte"],					#
		   [u"Sahne 10% Fett",u"Sahne, 10% Fett",u"Milchprodukte"],		#
		   [u"Sahne 15% Fett",u"Sahne, 15% Fett",u"Milchprodukte"],		#
		   [u"Sahne 35% Fett",u"Sahne, 35% Fett",u"Milchprodukte"],		#
                   [u"Joghurt",u"Joghurt",u"Milchprodukte"],				#yogurt
		   [u"Quark",u"Quark",u"Milchprodukte"],					#
		   [u"Speisequark Magerstufe",u"Quark, Speise- Magerstufe",u"Milchprodukte"],	#
		   [u"Kräuterquark",u"Quark, Kräuter",u"Milchprodukte"],			#
                   [u"Cheddar-Käse",u"Käse, Cheddar",u"Milchprodukte"],			#cheddar cheese
                   [u"Hartkäse",u"Käse, Hart-",u"Milchprodukte"],				#general hard cheese
                   [u"Hüttenkäse",u"Käse, Hüttenkäse",u"Milchprodukte"],			#cottage cheese
                   [u"Schnittkäse",u"Käse, Schnittkäse",u"Milchprodukte"],			#cottage cheese
                   [u"Fetakäse",u"Käse, Fetakäse",u"Milchprodukte"],			#feta cheese
                   [u"Ziegenkäse",u"Käse, Ziegenkäse",u"Milchprodukte"],			#fresh cheese white goat
                   [u"Schaffskäse",u"Schaffskäse",u"Milchprodukte"],			#sheeps cheese
                   [u"Emmentaler",u"Käse, Emmentalerkäse",u"Milchprodukte"],		#emmental
                   [u"Mozzarella",u"Käse, Mozzarella",u"Milchprodukte"],			#mozzarella cheese
                   [u"Parmesan",u"Käse, Parmesan",u"Milchprodukte"],			#parmesan cheese
                   [u"Provolone",u"Käse, Provolone",u"Milchprodukte"],			#provolone cheese
                   [u"Ricotta",u"Käse, Ricotta",u"Milchprodukte"],				#ricotta cheese
                   [u"Gouda",u"Käse, Gouda",u"Milchprodukte"],				#cheese Gouda
                   [u"Brie",u"Käse, Brie",u"Milchprodukte"],				#cheese Brie
                   [u"Streichkäse",u"Käse, Steich",u"Milchprodukte"],			#spreading cheese
                   [u"Philladelphia",u"Käse, Philladelphia",u"Milchprodukte"],		#philladelphia cheese


		   ## h e i ß e   G e t r ä n k e
                   [u"schwarzer Tee",u"Tee, schwarzer",u"Getränke, heiß"],			#black tea
                   [u"gemahlener Kaffee, ",u"Kaffee, gemahlener",u"Getränke, heiß"],	#ground coffee
                   [u"gemahler entkoffeinierter Kaffee",u"Kaffee, gemahlener entkoffeinierter",u"Getränke, heiß"],	#decaff ground coffee
                   [u"Kaffeefilter",u"Kaffeefilter",u"Getränke, heiß"],			#coffee filters
                   [u"Kakao",u"Kakao",u"Getränke, heiß"],					#drinking chocolate
                   [u"Carokaffee",u"Carokaffee",u"Getränke, heiß"],			#caro coffee
                   [u"Früchtetee, ",u"Tee, Früchtetee",u"Getränke, heiß"],			#fruit tea
                   [u"Pfefferminztee",u"Tee, Pfefferminztee",u"Getränke, heiß"],		#peppermint tea
                   [u"Hagebuttentee",u"Tee, Hagebuttentee",u"Getränke, heiß"],		#rosehip tea
                   [u"Kamillentee",u"Tee, Kamillentee",u"Getränke, heiß"],		#camomile tea
                   [u"Fencheltee",u"Tee, Fencheltee",u"Getränke, heiß"],			#fenchel tea
                   [u"Rotbuschtee",u"Tee, Rotbuschtee",u"Getränke, heiß"],			#roobusch tea
                   [u"Kräutertee",u"Tee, Kräutertee",u"Getränke, heiß"],			#herb tea
                   [u"grüner Tee",u"Tee, grüner",u"Getränke, heiß"],			#green tea
                   [u"Yogitee",u"Tee, Yogitee",u"Getränke, heiß"],				#yogi (ayurvedic) tea

		   ## F l u ß i g k e i t e n
                   [u"Tafelessig",u"Essig, Tafel-",u"Flüssigkeiten"],			#table vinegar
                   [u"Obstessig",u"Essig, Obst-",u"Flüssigkeiten"],			#table vinegar
                   [u"Balsamico-Essig",u"Essig, Balsamico-",u"Flüssigkeiten"],		#balsamic vinegar
                   [u"Sonnenblumenöl",u"Öl, Sonnenblumenöl",u"Flüssigkeiten"],		#sunflower oil
                   [u"Olivenöl",u"Öl, Olivenöl",u"Flüssigkeiten"],				#olive oil
                   [u"Sesamöl",u"Öl, Sesamöl",u"Flüssigkeiten"],				#sesame oil
                   [u"Pflanzenöl",u"Öl, Pflanzenöl",u"Flüssigkeiten"],			#vegetable oil
		   [u"Sojaöl",u"Öl, Sojaöl",u"Flüssigkeiten"],				#soya oil
                   [u"Weißwein",u"Wein, weiß",u"Flüssigkeiten"],				#white wine
                   [u"Rotwein",u"Wein, rot",u"Flüssigkeiten"],				#red wine

                   ## t h i n g   y o u   s h o u l d   h a v e   a t   h o m e 
                   [u"Wasser",u"Wasser",u"Flüssigkeiten"]					#water

                   ]

# THESE ARE STANDARD UNIT CONVERSIONS. You can simply translate unit names where
# you know them. Eliminate entries that are untranslatable or don't exist in your
# locale. And please add any additional units that you know of.
# Each unit is of the following format:
# (u"unit1",u"unit2"):conversion_factor, where unit1 contains conversion_factor X unit2
# For example: 1 cup has 16 tablespoons.
CONVERTER_TABLE = {
    (u"Tasse", u"EL"):16,
    (u"EL", u"TL"):3,
    (u"pt.", u"Tasse"):2,
    (u"qt.", u"Tasse"):4,
    (u"l", u"ml"):1000,
    (u"l", u"cl"):100,
    (u"l", u"dl"):10,
    (u"oz.", u"g"):28.35,
    (u"kg", u"g"):1000,
    (u"g", u"mg"):1000,
    (u"TL", u"Tröpchen"):76,
    (u"Dose, mittel", u"g"):400,
    (u"Dose, groß",   u"g"):800,
    (u"Dose, klein",  u"g"):200,
    (u"lb.", u"oz."):16,
    (u"l", u"qt."):1.057
}


# DENSITIES of common foods. This allows us to convert between mass and volume.
# Translators: You may be best off translating the food names below, since lists
# of food densities can be hard to come by!
DENSITY_TABLE={
    u"Wasser":1,				#water
    u"Traubensaft":1.03,			#juice, grape
    u"Bouillon, gemüse":1,		#vegetable broth
    u"Bouillon, hühner":1,		#broth, chicken
    u"Milch":1.029,			#milk
    u"Milch entier":1.029,		#milk, whole
    u"Milch, fettarm":1.033,		#milk, skim
    u"Milch 2%":1.031,			#milk, 2%
    u"Milch 1%":1.03,			#milk, 1%
    u"Kokosmilch":0.875,		#coconut milk
    u"Buttermilch":1.03,		#buttermilk
    u"Sahne riche":0.994,		#heavy cream
    u"Sahne légère":1.012,		#light cream
    u"Sahne 11,5%":1.025,		#half-and-half
    u"Honig":1.420,			#honey
    u"Zucker":1.550,			#sugar, white
    u"Salz":2.165,			#salt
    u"Butter":0.911,			#butter
    u"Pflanzen Öl":0.88,			#oil, vegetable
    u"Oliven Öl":0.88,			#oil, olive
    u"Sonnenblumen Öl":0.88,		#oil, corn
    u"Sesam Öl":0.88,			#oil, sesame
    u"Mehl": 0.6,			#flour, all purpose
    u"Vollkornmehl": 0.6,		#flour, whole wheat
    u"Stärke": 0.6,			#corn starch
    u"Zucker en poudre": 0.6,		#sugar, powdered
    u"Zucker glace": 0.6			#sugar, confectioners
      }

### ORIGINAL TABLES FROM ENGLISH

# Standard unit names and alternate unit names that might appear.  For
# example: u"c." is our standard abbreviation for cup.  u"cup",u"c." or
# u"cups" might appear in a recipe we are importing.  Each item of this
# list looks like this:
#
# [u"standard", [u"alternate1",u"alternate2",u"alternate3",...]]
#
# The first item should be the preferred abbreviation
# The second item should be the full name of the unit
# e.g. [u"c.", [u"cup",...]]
#
UNITS = [
         [u"ml", [u"Milliliter",u"milliliter",u"Milliliters",u"milliliters",u"ml", u"ml."]],
         [u"cl", [u"Centiliter",u"centiliter",u"Centiliters",u"centiliters",u"cl", u"cl."]],
         [u"dl", [u"Deciliter",u"deciliter",u"Deciliters",u"deciliters",u"dl", u"dl."]],
         [u"l", [u"Liter",u"Liters",u"liter",u"liters",u"l.", u"lit.", u"l"]],

         [u"g", [u"Gramm",u"Gramme",u"gramm", u"gramme", u"g.",u"g",u"gram",u"grams"]],
         [u"mg", [u"Milligramm",u"milligramm",u"Milligramme",u"milligramme",u"mg.", u"mg",u"milligram",u"milligrams"]],
         [u"kg", [u"Kilogramm",u"kilogramm",u"Kilogramme",u"kilogramme",u"kg.", u"kg",u"kilogram",u"kilograms"]],

         [u"cm", [u"Centimeter",u"centimeter",u"Centimeters",u"centimeters",u"cm", u"cm."]],
         [u"mm", [u"Millimeter",u"millimeter",u"Millimeters",u"millimeters",u"mm", u"mm."]],
         [u"m", [u"Meter",u"meter",u"Meters",u"meters",u"m", u"m."]],

         [u"Tröpfchen",[u"Tröpfchen",u"tröpfchen",u"troepfchen",u"Troepfchen",u"drop",u"drops"]],
         [u"TL", [u"Teelöffel",u"Teelöffeln",u"teelöffel",u"teelöffeln",u"tl",u"TL",u"tsp", u"tsp.",u"tea spoon", u"teaspoon"]],
         [u"EL", [u"Esslöffel",u"Esslöffeln",u"esslöffel",u"esslöffeln",u"el",u"EL",u"tbs", u"tbsp", u"tbs.", u"tbsp.", u"table spoon",u"tablespoon"]],
         [u"Tasse", [u"Tasse",u"Tassen",u"tasse",u"tassen",u"cup", u"c.", u"cups",u"Glas",u"glas", u"Glass", u"glass"]],
	 [u"Becher", [u"Becher",u"becher"]],

         [u"St.", [u"St.",u"Stück",u"Stücke",u"Stueck",u"Stuecke",u"Mal",u"stück",u"stücke",u"stueck",u"stuecke", u"mal",u"piece", u"pieces",u"St",u"st"]],
         [u"Dose, mittel", [u"Dose, mittel",u"dose, mittel",u"mittlere Dose",u"mittlere dose"]],
         [u"Dose, groß", [u"Dose, groß", u"dose, groß",u"größe Dose",u"größe dose"]],
         [u"Dose, klein", [u"Dose, klein",u"dose, klein",u"kleine Dose",u"kleine dose"]],
	 [u"Zeh", [u"Zeh",u"Zehen",u"zeh",u"zehen"]],           #garlic
	 [u"Paket",[u"Paket",u"Pakete",u"paket",u"pakete", u"Packung", u"packung", u"pack"]],
	 [u"Prise",[u"Prise",u"Prisen",u"prise",u"prisen"]],    #pinch
	 [u"Bund",[u"Bund",u"Bunde",u"bund",u"bunde"]],         #bunch

         [u"lb.", [u"Pfund",u"pfund",u"pound",u"pounds",u"lb",u"lb.", u"lbs."]],
         [u"oz.", [ u"ounce",u"ounces",u"oz",u"oz."]],
         [u"qt.", [u"quart", u"qt.", u"quarts"]],
         [u"pt.", [u"pint", u"pt.", u"pints"]],
         [u"gallon", [u"gallon", u"gallons",u"gal."]]

         ]

METRIC_RANGE = (1,999)

# The following sets up unit groups. Users will be able to turn
# these on or off (American users, for example, would likely turn
# off metric units, since we don't use them).
# (User choice not implemented yet)
UNIT_GROUPS = {
    'metric mass':[('mg',METRIC_RANGE),
                   ('g',METRIC_RANGE),
                   ('kg',(1,None))],
    'metric volume':[('ml',METRIC_RANGE),
                     ('cl',(1,99)),
                     ('dl',(1,9)),
                     ('l',(1,None)),],
    'imperial weight':[('oz.',(0.25,32)),
                       ('lb.',(0.25,None)),
                       ],
    'imperial volume':[('Tröpfchen',(0,3)),
                       ('TL',(0.125,3)),
                       ('EL',(1,4)),
                       ('Tasse',(0.25,6)),
                       ('pt.',(1,1)),
                       ('qt.',(1,3))]
    }

# The units here need to correspond to the standard unit names defined
# above in UNITS
CROSS_UNIT_TABLE = {
    ## This if for units that require an additional
    ## bit of information -- i.e. to convert between
    ## volume and mass you need the density of an
    ## item.  In these cases, the additional factor
    ## will be provided as an 'item' that is then looked
    ## up in the dictionary referenced here (i.e. the density_table)
    ## currently, 'density' is the only keyword used
    (u"pt.", u"lb."):['density',1],
    (u"EL", u"oz."):['density',0.5],
    (u"Tasse", u"oz."):['density',8],
    (u"l", u"kg"):['density',1],
    (u"ml", u"g"):['density',1]
    }

# The units here need to correspond to the standard unit names defined
# in UNITS.  These are some core conversions from mass-to-volume,
# assuming a density of 1 (i.e. the density of water).
VOL_TO_MASS_TABLE = {
    (u"pt.", u"lb.") : 1,
    (u"tbs.", u"oz.") : 0.5,
    (u"c.", u"oz.") : 8,
    (u"pt.", u"oz.") : 16,
    (u"ml", u"g") : 1,
    (u"ml", u"mg") : 1000,
    (u"ml", u"kg"): 0.001,
    (u"cl", u"kg"): 0.01,
    (u"cl", u"g") : 10,
    (u"dl", u"kg") : 0.1,
    (u"dl", u"g") : 100,    
    (u"l", u"kg") : 1
    }

### From translator :
### FRENCH PART TO BE REVISED !!! US units != UK units != Canadian units !!!
### I will work on these later... 
# VOL_TO_MASS_TABLE = {
#     (u"chop",u"lb") : 1,					#(warning, might not be accurate, see below)
#     (u"c. à table",u"oz") : 0.5,
#     (u"tasse",u"oz") : 8,
#     (u"chop",u"oz") : 20,					#(warning, modified, see u"chopine" in granddictionnaire)
#     (u"ml",u"g") : 1,
#     (u"ml",u"mg") : 1000,
#     (u"ml",u"kg"): 0.001,
#     (u"cl",u"kg"): 0.01,
#     (u"cl",u"g") : 10,
#     (u"dl",u"kg") : 0.1,
#     (u"dl",u"g") : 100,    
#     (u"l",u"kg") : 1}

# TIME ABBREVIATIONS (this is new!)
TIME_ABBREVIATIONS = {
    'sec':'Sek.',
    'min':'Min.',
    'hr':'Std.'
    }

IGNORE = [u"und",u"mit",u"von",u"für",
          u"kalt",u"kalter",u"kalte",u"kaltes",u"kalten",
          u"warm",u"warmer",u"warme",u"warmes",u"warmen",
          u"dünn",u"dünner",u"dünne",u"dünnes",u"dünnen",
          u"dick",u"dicker",u"dicke",u"dickes",u"dicken"
          ]

NUMBERS = {
    }
                    
# These functions are rather important! Our goal is simply to
# facilitate look ups -- if the user types in u"tomatoes", we want to
# find "tomato." Note that the strings these functions produce will
# _never_ be shown to the user, so it's fine to generate nonsense
# words as well as correct answers -- our goal is to generate a list
# of possible hits rather than to get the plural/singular form "right".

def guess_singulars (s):
    # Note - German, here we're not only going to try to make nouns singular,
    # we could also get an adjective, so lets also take the adjectival endings off
    if len(s)<3: return []
    ret = []
    if s[-1]=='n':
        if s[-2]=='e':
            ret.append(s[0:-2]) # try chopping off 'en'
        if (s[-2]!='u') & (s[-2]!='o') & (s[-2]!='a') & (s[-2]!='i'):
            ret.append(s[0:-1]) # try chopping off the n

    if s[-1]=='s':
        ret.append(s[0:-1]) # try chopping off the s
        if s[-2]=='e':
            ret.append(s[0:-2]) # try chopping off 'es'

    if s[-1]=='e':
        ret.append(s[0:-1]) # try chopping off the 'e'

    if (s[-1]=='r') & (s[-2]=='e'):
        ret.append(s[0:-2]) # try chopping off the 'er'
    
    return ret

def guess_plurals (s): 
    # Ditto above, assume this could also be an adjective, so try adding the common agreements
    return [s+'n', s+'en', s+'e', s+'er', s+'s', s+'es']


########NEW FILE########
__FILENAME__ = defaults_en
# -*- coding: utf-8 -*-
#
# we set up default information for our locale.
# Translators should use this file as the basis of their translation.
# Copy this file and rename it for you locale.
#
# For example, Spanish uses:
# defaults_es.py
#
# British English uses:
# defaults_en_GB.py
#
# Please fill in the below fields:

# Language: English
# Translator: None (English is our default language).
# Last-updated: 4/27/05

# TRANSLATOR WARNING: DO NOT TRANSLATE THE FIELD NAMES: ONLY THE VALUES!!!

# only translate the items in the list [..] (and feel free to create
# categories that make sense for your locale -- no need to translate
# these ones). DO NOT translate 'cuisine','rating','source' or
# 'category'

# The below are Gourmet's standard fields and the default categories for them.
# Do not translate the field names ('cuisine','rating','source,'category').
# Instead, fill in the list with categories that make sense for your locale.
# Feel free to change the number or content of categories to be consistent
# with what users in your locale are likely to be familiar with.

fields={'cuisine': ['American','Italian','French','Mexican',
                    'Southwestern','Asian/Thai','Asian/Vietnamese',
                    'Asian/Chinese','Asian/Japanese','Asian/Indian'],
        'rating' : ['Excellent','Great','Good','Fair','Poor'],
        'source' : [],
        'category' : ['Dessert','Entree','Salad','Soup',
                      'Breakfast'],
        'yield_unit':['servings','cups','pints','gallons','ounces',
                      'cookies','crusts',
                      ],

                  }

# In English, there are a heck of a lot of synonyms. This is a list
# for those synonyms.  ["preferred word","alternate word","alternate word"]
# If there are none of these that you can think of in your language, just
# set this to:
# SYNONYMS=[]
SYNONYMS=[
    # the first item of each list is the default
    ["arugula","rocket"],
    ["azuki beans", "adzuki beans", "adzuki", "azuki"],
    ["beet","beetroot"],
    ["bell pepper, green", "green pepper", "bell pepper","green bell pepper", "pepper"],
    ["black cod","sablefish"],
    ["bok choy","chinese leaves"],
    ["chilean sea bass","patagonian toothfish"],
    ["chilli pepper","capsicum"],
    ["chokeberry","cooking apple"],
    ["cilantro","coriander"],
    ["collard greens","spring greens"],
    ["corn","sweetcorn","maize","sweet corn"],
    ["dragonfruit" , "pitaya"],
    ["eggplant","aubergine"],
    ["flour, all purpose","flour, all-purpose","flour","white flour"],
    ["jackfruit","nangka"],
    ["juneberry","saskatoon"],
    ["kiwi fruit","chinese gooseberry"],
    ["langsat","longkong", "duku"],
    ["mamoncillo", "quenepa", "genip"],
    ["nannyberry","sheepberry"],
    ["red bell pepper","red pepper"],
    ["rose apple", "malay apple"],
    ["rutabaga","swede"],
    ["salak", "snakefruit"],
    ["sapodilla", "chiku", "sapadilla", "snake fruit", "sawo"],
    ["scallion","green onion","spring onion"],
    ["snap peas","mangetout"],
    ["soursop", "guanabana"],
    ["start fruit","carambola"],
    ["sugar, granulated","sugar"],
    ["sunberry","wonderberry"],
    ["velvet persimmon","mabolo"],
    ["zucchini","courgette"],
    ]

# A DICTIONARY CONTAINING INGREDIENT KEYS AND NDBNO for the USDA
# nutritional database. For these items, we will have nutritional
# information by default.

NUTRITIONAL_INFO = {}

# a dictionary for ambiguous words.
# key=ambiguous word, value=list of possible non-ambiguous terms
#
# Translators: if you have a word that has more than one food meaning
# in your language, you can add an entry as follow

# AMBIGUOUS = {
#              'word':['meaning1','meaning2','meaning3'],
#             }

AMBIGUOUS = {}


# triplicates ITEM, KEY, SHOPPING CATEGORY
# These will be defaults.

# They should include whatever foods might be standard for your
# locale, with whatever sensible default categories you can think of
# (again, thinking of your locale, not simply translating what I've
# done).

# Items provided here will automatically be recognized and go onto the
# given category in a user's shopping list by default.

# Don't feel obligated to translate every item -- especially since not
# all items will be common for all locales. However, the more items
# you can put here, the more the user will get the sense that gourmet
# "knows" about foods that they enter.

# I generated the below list using the wikipedia entry on foods as my
# starting point. You may want to do something similar for your
# locale.  Also, if the syntax of the below is too complicated, you
# can send me a list of category headings and ingredients for your
# locale and I'll do the necessary formatting <Thomas_Hinkle@alumni.brown.edu>

INGREDIENT_DATA = [["alfalfa sprouts","alfalfa sprouts","produce"],
                   ["anise","anise","produce"],
                   ["artichoke","artichoke","produce"],
                   ["arugula","arugula","produce"],
                   ["asparagus","asparagus","produce"],
                   ["eggplant","eggplant","produce"],
                   ["avocado","avocado","produce"],
                   ["green beans","green beans","produce"],
                   ["azuki beans","azuki beans","produce"],
                   ["bean sprouts","bean sprouts","produce"],
                   ["black beans","black beans","produce"],
                   ["black-eyed peas","black-eyed peas","produce"],
                   ["borlotti beans","borlotti beans","produce"],
                   ["broad beans","broad beans","produce"],
                   ["chickpeas, garbanzos, or ceci beans","chickpeas, garbanzos, or ceci beans","produce"],
                   ["green beans","green beans","produce"],
                   ["kidney beans","kidney beans","produce"],
                   ["lentils","lentils","produce"],
                   ["lima bean","butter bean","produce"],
                   ["mung beans","mung beans","produce"],
                   ["navy beans","navy beans","produce"],
                   ["runner beans","runner beans","produce"],
                   ["soybeans","soybeans","produce"],
                   ["peas","peas","produce"],
                   ["snap peas","snap peas","produce"],
                   ["bok choy","bok choy","produce"],
                   ["breadfruit","breadfruit","produce"],
                   ["broccoflower","broccoflower","produce"],
                   ["broccoli","broccoli","produce"],
                   ["brussels sprouts","brussels sprouts","produce"],
                   ["cabbage","cabbage","produce"],
                   ["calabrese","calabrese","produce"],
                   ["cauliflower","cauliflower","produce"],
                   ["celery","celery","produce"],
                   ["chard","chard","produce"],
                   ["cilantro","cilantro","produce"],
                   ["collard greens","collard greens","produce"],
                   ["corn salad","corn salad","produce"],
                   ["endive","endive","produce"],
                   ["fennel","fennel","produce"],
                   ["fiddleheads","fiddleheads","produce"],
                   ["frisee","frisee","produce"],
                   ["kale","kale","produce"],
                   ["kohlrabi","kohlrabi","produce"],
                   ["lemon grass","lemon grass","produce"],
                   ["lettuce lactuca sativa","lettuce lactuca sativa","produce"],
                   ["corn","corn","produce"],
                   ["mushrooms","mushrooms","produce"],
                   ["mustard greens","mustard greens","produce"],
                   ["nettles","nettles","produce"],
                   ["new zealand spinach","new zealand spinach","produce"],
                   ["okra","okra","produce"],
                   ["onion family","onion family","produce"],
                   ["chives","chives","produce"],
                   ["garlic","garlic","produce"],
                   ["leek allium porrum","leek allium porrum","produce"],
                   ["onion","onion","produce"],
                   ["shallot","shallot","produce"],
                   ["scallion","scallion","produce"],
                   ["parsley","parsley","produce"],
                   ["green pepper","bell pepper, green","produce"],
                   ["red bell pepper","bell pepper, red","produce"],
                   ["chilli pepper","chilli pepper","produce"],
                   ["jalapeño pepper","pepper, jalapeño","produce"],
                   ["habañero pepper","pepper, habañero","produce"],
                   ["radicchio","radicchio","produce"],
                   ["rapini","rapini","produce"],
                   ["rhubarb","rhubarb","produce"],
                   ["root vegetables","root vegetables","produce"],
                   ["beet","beet","produce"],
                   ["carrot","carrot","produce"],
                   ["cassava (manioc)","cassava (manioc)","produce"],
                   ["celeriac","celeriac","produce"],
                   ["daikon","daikon","produce"],
                   ["fennel","fennel","produce"],
                   ["ginger","ginger","produce"],
                   ["parsnip","parsnip","produce"],
                   ["radish","radish","produce"],
                   ["rutabaga","rutabaga","produce"],
                   ["turnip","turnip","produce"],
                   ["wasabi","wasabi","produce"],
                   ["white radish","white radish","produce"],
                   ["skirret","skirret","produce"],
                   ["spinach","spinach","produce"],
                   ["acorn squash","squash, acorn","produce"],
                   ["butternut squash","squash, butternut","produce"],
                   ["zucchini","zucchini","produce"],
                   ["cucumber","cucumber","produce"],
                   ["gem squash","squash, gem","produce"],
                   ["patty pans","patty pans","produce"],
                   ["pumpkin","pumpkin","produce"],
                   ["spaghetti squash","squash, spaghetti","produce"],
                   ["tat soi","tat soi","produce"],
                   ["tomato","tomato","produce"],
                   ["jicama","jicama","produce"],
                   ["jerusalem artichoke","jerusalem artichoke","produce"],
                   ["potato","potato","produce"],
                   ["sweet potato","sweet potato","produce"],
                   ["taro","taro","produce"],
                   ["yam","yam","produce"],
                   ["water chestnut","water chestnut","produce"],
                   ["watercress","watercress","produce"],
                   # fruits, from wikipedia list
                   ["apple","apple","produce"],
                   ["green apple","green apple","produce"],
                   ["crabapple","crabapple","produce"],
                   ["chokeberry","chokeberry","produce"],
                   ["hawthorn","hawthorn","produce"],
                   ["juneberry","juneberry","produce"],
                   ["loquat","loquat","produce"],
                   ["medlar","medlar","produce"],
                   ["pomegranate","pomegranate","produce"],
                   ["quince","quince","produce"],
                   ["rowan","rowan","produce"],
                   ["rose hip","rose hip","produce"],
                   ["apricot","apricot","produce"],
                   ["cherry","cherry","produce"],
                   ["plum","plum","produce"],
                   ["peach","peach","produce"],
                   ["nectarine","nectarine","produce"],
                   ["blackberry","blackberry","produce"],
                   ["boysenberry","boysenberry","produce"],
                   ["raspberry","raspberry","produce"],
                   ["cloudberry","cloudberry","produce"],
                   ["wineberry","wineberry","produce"],
                   ["bearberry","bearberry","produce"],
                   ["bilberry","bilberry","produce"],
                   ["blueberry ","blueberry ","produce"],
                   ["cranberry ","cranberry ","produce"],
                   ["huckleberry ","huckleberry ","produce"],
                   ["lingonberry","lingonberry","produce"],
                   ["barberry ","barberry ","produce"],
                   ["red currant","currant, red","produce"],
                   ["black currant","currant, black","produce"],
                   ["white currant","currant, white","produce"],
                   ["elderberry ","elderberry ","produce"],
                   ["gooseberry ","gooseberry ","produce"],
                   ["nannyberry","nannyberry","produce"],
                   ["sea-buckthorn","sea-buckthorn","produce"],
                   ["wolfberry","wolfberry","produce"],
                   ["crowberry","crowberry","produce"],
                   ["mulberry","mulberry","produce"],
                   ["goumi","goumi","produce"],
                   ["kiwi fruit ","kiwi fruit ","produce"],
                   ["persimmon ","persimmon ","produce"],
                   ["buffaloberry","buffaloberry","produce"],
                   ["pawpaw","pawpaw","produce"],
                   ["american persimmon","american persimmon","produce"],
                   ["prickly pear ","prickly pear ","produce"],
                   ["saguaro","saguaro ","produce"],
                   ["pitaya","pitaya","produce"],
                   ["cantaloupe","cantaloupe","produce"],
                   ["honeydew","honeydew","produce"],
                   ["sunberry","sunberry","produce"],
                   ["watermelon ","watermelon ","produce"],
                   ["strawberry ","strawberry ","produce"],
                   ["angelica","angelica","produce"],
                   ["rhubarb","rhubarb","produce"],
                   ["fig ","fig ","produce"],
                   ["grape","grape","produce"],
                   ["jujube","jujube","produce"],
                   ["black mulberry","black mulberry","produce"],
                   ["pomegranate","pomegranate","produce"],
                   ["date","date","produce"],
                   ["citron","citron","produce"],
                   ["grapefruit","grapefruit","produce"],
                   ["pommelo","pommelo","produce"],
                   ["key lime","key lime","produce"],
                   ["kumquat","kumquat","produce"],
                   ["lemon","lemon","produce"],
                   ["lime","lime","produce"],
                   ["mandarin","mandarin","produce"],
                   ["clementine","clementine","produce"],
                   ["tangelo","tangelo","produce"],
                   ["tangerine","tangerine","produce"],
                   ["orange","orange","produce"],
                   ["ugli fruit","ugli fruit","produce"],
                   ["guava ","guava ","produce"],
                   ["longan","longan","produce"],
                   ["lychee","lychee","produce"],
                   ["passion fruit","passion fruit","produce"],
                   ["feijoa","feijoa","produce"],
                   ["akee","akee","produce"],
                   ["banana","banana","produce"],
                   ["plantain","plantain","produce"],
                   ["breadfruit","breadfruit","produce"],
                   ["camucamu","camucamu","produce"],
                   ["star fruit","star fruit","produce"],
                   ["cempedak","cempedak","produce"],
                   ["cherimoya","cherimoya","produce"],
                   ["coconut","coconut","produce"],
                   ["custard apple","custard apple","produce"],
                   ["dragonfruit","dragonfruit","produce"],
                   ["durian","durian","produce"],
                   ["guarana","guarana","produce"],
                   ["jackfruit","jackfruit","produce"],
                   ["keppel fruit","keppel fruit","produce"],
                   ["langsat","langsat","produce"],
                   ["velvet persimmon","velvet persimmon","produce"],
                   ["mamey sapote","mamey sapote","produce"],
                   ["mamoncillo","mamoncillo","produce"],
                   ["mango","mango","produce"],
                   ["mangosteen","mangosteen","produce"],
                   ["marang","marang","produce"],
                   ["papaya","papaya","produce"],
                   ["peanut butter fruit","peanut butter fruit","produce"],
                   ["pineapple","pineapple","produce"],
                   ["poha","poha","produce"],
                   ["rambutan","rambutan","produce"],
                   ["rose apple","rose apple","produce"],
                   ["salak","salak","produce"],
                   ["sapodilla","sapodilla","produce"],
                   ["soursop","soursop","produce"],
                   ["sugar apple","sugar apple","produce"],
                   ["tamarind","tamarind","produce"],
                   ## seafood, from wikipedia list
                   ["anchovy","anchovy","seafood"],
                   ["bass","bass","seafood"],
                   ["striped bass","striped bass","seafood"],
                   ["black cod","black cod","seafood"],
                   ["blowfish","blowfish","seafood"],
                   ["catfish","catfish","seafood"],
                   ["cod","cod","seafood"],
                   ["eel","eel","seafood"],
                   ["flounder","flounder","seafood"],
                   ["haddock","haddock","seafood"],
                   ["halibut","halibut","seafood"],
                   ["lingcod","lingcod","seafood"],
                   ["mahi mahi","mahi mahi","seafood"],
                   ["monkfish","monkfish","seafood"],
                   ["orange roughy","orange roughy","seafood"],
                   ["chilean sea bass","chilean sea bass","seafood"],
                   ["pike","pike","seafood"],
                   ["pollock","pollock","seafood"],
                   ["sanddab","sanddab","seafood"],
                   ["sardine","sardine","seafood"],
                   ["salmon","salmon","seafood"],
                   ["sea bass","sea bass","seafood"],
                   ["shark","shark","seafood"],
                   ["snapper","snapper","seafood"],
                   ["rockfish","rockfish","seafood"],
                   ["rock cod","rock cod","seafood"],
                   ["pacific snapper","pacific snapper","seafood"],
                   ["red snapper","red snapper","seafood"],
                   ["sole","sole","seafood"],
                   ["sturgeon","sturgeon","seafood"],
                   ["surimi","surimi","seafood"],
                   ["swordfish","swordfish","seafood"],
                   ["tilapia","tilapia","seafood"],
                   ["tilefish","tilefish","seafood"],
                   ["trout","trout","seafood"],
                   ["tuna","tuna","seafood"],
                   ["whitefish","whitefish","seafood"],
                   ["whiting","whiting","seafood"],
                   ["roe","roe","seafood"],
                   ["caviar","caviar","seafood"],
                   ["salmon roe","salmon roe","seafood"],
                   ["crab","crab","seafood"],
                   ["dungness crab","dungness crab","seafood"],
                   ["king crab","king crab","seafood"],
                   ["snow crab","snow crab","seafood"],
                   ["crayfish","crayfish","seafood"],
                   ["lobster","lobster","seafood"],
                   ["shrimp","shrimp","seafood"],
                   ["prawns","prawns","seafood"],
                   ["abalone","abalone","seafood"],
                   ["clam","clam","seafood"],
                   ["mussel","mussel","seafood"],
                   ["octopus","octopus","seafood"],
                   ["oyster","oyster","seafood"],
                   ["snail","snail","seafood"],
                   ["squid","squid","seafood"],
                   ["scallop","scallop","seafood"],
                   ## meats (garnered from wikipedia lists)
                   ["bacon","bacon","meats"],
                   ["chorizo","chorizo","meats"],
                   ["fuet","fuet","meats"],
                   ["salami","salami","meats"],
                   ["ham","ham","meats"],
                   ["mutton","mutton","meats"],
                   ["lamb","lamb","meats"],
                   ["veal","veal","meats"],
                   ["steak","steak","meats"],
                   ["hamburger","hamburger","meats"],
                   ["roast beef","roast beef","meats"],
                   ["chicken","chicken","meats"],
                   ["turkey","turkey","meats"],
                   ["duck","duck","meats"],
                   ["goose","goose","meats"],
                   ## my old list
                   ["tamarind water","tamarind water", "international"],
                   ["tamarind juice","tamarind juice", "international"],
                   ['vegetable broth','broth, vegetable', 'soups&sauces'],
                   ['fresh basil','basil, fresh', 'produce',],
                   ['light sugar brown','sugar, light brown', 'baking',],
                   ['balsamic vinegar','vinegar, balsamic', 'wines&oils',],
                   ['zuchini','zuchini', 'produce',],
                   ['avocado','avocado', 'produce',],
                   ['walnut','walnut', 'baking',],
                   ['celery','celery', 'produce',],
                   ['coriander seeds','coriander, seeds', 'spices',],
                   ['provolone cheese','cheese, provolone', 'dairy',],
                   ['galanga','galanga', 'produce',],
                   ['couscous','couscous', 'pastas',],
                   ['rice','rice', 'pastas',],
                   ['flour tortillas','tortillas, flour', 'dairy',],
                   ['olive oil','oil, olive', 'wines&oils',],
                   ['vanilla extract','vanilla extract', 'baking',],
                   ['red potato-skinned','potato, red-skinned', 'produce',],
                   ['powdered ginger','ginger, powdered', 'spices',],
                   ['roasted chili paste','roasted chili paste', 'international',],
                   ['curry powder','curry powder', 'spices',],
                   ['dried shrimp','shrimp, dried', 'international',],
                   ['dijon mustard','mustard, dijon', 'condiments',],
                   ['whole rock cod or snapper','whole rock cod or snapper', 'seafood',],
                   ['shells pasta','pasta, shells', 'pastas',],
                   ['green canned chiles','green chiles, canned', 'international',],
                   ['nutmeg','nutmeg', 'spices',],
                   ['sourdough bread','bread, sourdough', 'bread',],
                   ['corn oil','oil, corn', 'wines&oils',],
                   ['lemon grass','lemon grass', 'produce',],
                   ['feta cheese','cheese, feta', 'dairy',],
                   ['jack cheese','cheese, jack', 'dairy',],
                   ['grape tomato','tomato, grape', 'produce',],
                   ['cherry tomato','tomato, cherry', 'produce',],
                   ['spaghetti','spaghetti', 'pastas',],
                   ['cottage cheese','cheese, cottage', 'dairy',],
                   ['white onion','onion, white', 'produce',],
                   ['baking soda','baking soda', 'baking',],
                   ['garam masala','garam masala', 'spices',],
                   ['yogurt','yogurt', 'dairy',],
                   ['monkfish','monkfish', 'seafood',],
                   ['croutons','croutons', 'bread',],
                   ['ground coriander','coriander, ground', 'spices',],
                   ['chili powder','chili powder', 'spices',],
                   ['curly lettuce leaf','lettuce, curly leaf', 'produce',],
                   ['dark sugar brown','sugar, dark brown', 'baking',],
                   ['rice vinegar','vinegar, rice', 'international',],
                   ['pasta','pasta', 'pastas',],
                   ['sesame oil','oil, sesame', 'wines&oils',],
                   ['water','water', ''],
                   ['sour cream','sour cream', 'dairy',],
                   ['orange juice','orange juice', 'produce',],
                   ['spinach','spinach', 'produce',],
                   ['stick cinnamon','cinnamon, stick', 'spices',],
                   ['shrimp paste','shrimp paste', 'international',],
                   ['ground cinnamon','cinnamon, ground', 'spices',],
                   ['salad greens','salad greens', 'produce',],
                   ['garlic','garlic', 'produce',],
                   ['vegetable oil','oil, vegetable', 'wines&oils',],
                   ['peanut butter','peanut butter', 'bread',],
                   ['seeds ajowan','ajowan, seeds', 'spices',],
                   ['apple','apple', 'produce',],
                   ['cayenne','cayenne', 'spices',],
                   ['arugula','arugula', 'produce',],
                   ['linguine pasta','pasta, linguine', 'pastas',],
                   ['scallion','scallion', 'produce',],
                   ['egg','egg', 'dairy',],
                   ['lime','lime', 'produce',],
                   ['olives','olives', 'produce',],
                   ['basil, thai fresh','basil, fresh, thai', 'produce',],
                   ['bean sprouts','bean sprouts', 'produce',],
                   ['ricotta cheese','cheese, ricotta', 'dairy',],
                   ['parsley','parsley', 'produce',],
                   ['acorn squash','squash, acorn', 'produce',],
                   ['yellow onion','onion, yellow', 'produce',],
                   ['chiles, dried red','chiles, red, dried', 'produce',],
                   ['portobello mushroom','mushroom, portobello', 'produce',],
                   ['nappa cabbage','cabbage, nappa', 'produce',],
                   ['lime leaves','lime leaves', 'produce',],
                   ['butter','butter', 'dairy',],
                   ['bell red pepper','bell pepper, red', 'produce',],
                   ['mushroom','mushroom', 'produce',],
                   ['shallot','shallot', 'produce',],
                   ['cheddar cheese','cheese, cheddar', 'dairy',],
                   ['mozzarella cheese','cheese, mozzarella', 'dairy',],
                   ['squash','squash', 'produce',],
                   ['fish sauce','fish sauce', 'international',],
                   ['green curry paste','green curry paste', 'international',],
                   ['curly endive','endive, curly', 'produce',],
                   ['granulated sugar','sugar, granulated', 'baking',],
                   ['fresh cheese white goat','cheese, fresh white goat', 'dairy',],
                   ['cilantro stems','cilantro stems', 'produce',],
                   ['yellow cornmeal','cornmeal, yellow', 'baking',],
                   ['paprika','paprika', 'spices',],
                   ['chocolate chips','chocolate chips', 'baking',],
                   ['star anise','star anise', 'spices',],
                   ['brown sugar','sugar, brown', 'baking',],
                   ['roasted peanuts','peanuts, roasted', 'produce',],
                   ['fresh cilantro','cilantro, fresh', 'produce',],
                   ['honey','honey', 'baking',],
                   ['russet potato','potato, russet', 'produce',],
                   ['lemon juice','lemon juice', 'produce',],
                   ['carrot','carrot', 'produce',],
                   ['penne pasta','pasta, penne', 'pastas',],
                   ['red onion','onion, red', 'produce',],
                   ['shredded coconut','coconut, shredded', 'baking',],
                   ['peppered linguini','linguini, peppered', 'pastas',],
                   ['milk','milk', 'dairy',],
                   ['tahitian squash','squash, tahitian', 'produce',],
                   ['baking powder','baking powder', 'baking',],
                   ['tomato sauce','tomato sauce', 'soups&sauces',],
                   ['seeds mustard','mustard, seeds', 'spices',],
                   ['flat rice flour noodles','flat rice flour noodles', 'international',],
                   ['parmesan cheese','cheese, parmesan', 'pastas',],
                   ['mayonnaise','mayonnaise', 'bread',],
                   ['leek','leek', 'produce',],
                   ['zucchini','zucchini', 'produce',],
                   ['smoked cheese Gouda','cheese, smoked Gouda', 'dairy',],
                   ['lime juice','lime juice', 'produce',],
                   ['coconut milk','coconut milk', 'international',],
                   ['eggs','egg', 'dairy',],
                   ['salmon','salmon', 'seafood',],
                   ['lasagna pasta noodles','pasta, lasagna noodles', 'pastas',],
                   ['all purpose flour','flour, all purpose', 'baking',],
                   ['flour','flour, all purpose','baking',],
                   ['all-purpose flour','flour, all purpose','baking',],
                   ['ground cumin','cumin, ground', 'spices',],
                   ['cucumber','cucumber', 'produce',],
                   ['salsa','salsa', 'international',],
                   ['broccoli','broccoli', 'produce',],
                   ['rolled oats','rolled oats', 'pastas',],
                   ['tomato','tomato', 'produce',],
                   ['potato','potato', 'produce',],
                   ['white wine','wine, white', 'wines&oils',],
                   ['black ground pepper','black pepper, ground', 'spices',],
                   ['seeds cumin','cumin, seeds', 'spices',],
                   ['soy sauce','soy sauce', 'international',],
                   ['sesame seeds','sesame seeds', 'international',],
                   ['radicchio','radicchio', 'produce',],
                   ['salt','salt', 'baking',],
                   ['fresh ginger','ginger, fresh', 'produce',],
                   ['turmeric','turmeric', 'spices',],
                   ['chicken breast' ,'chicken, breast' , 'meats',],
                   ['whole chicken' ,'chicken, whole' , 'meats',],
                   ['chicken leg' ,'chicken, leg' , 'meats',],
                   ['beef' ,'beef' , 'meats',],
                   ['ground beef' ,'beef, ground' , 'meats',],
                   ['pork' ,'pork' , 'meats',],
                   ['turkey' ,'turkey' , 'meats',],
                   ]

# THESE ARE STANDARD UNIT CONVERSIONS. You can simply translate unit names where
# you know them. Eliminate entries that are untranslatable or don't exist in your
# locale. And please add any additional units that you know of.
# Each unit is of the following format:
# ("unit1","unit2"):conversion_factor, where unit1 contains conversion_factor X unit2
# For example: 1 cup has 16 tablespoons.
CONVERTER_TABLE = {
    ("c", "Tbs"):16,
    ("lb", "oz"):16,
    ("Tbs", "tsp"):3,
    ("pt", "c"):2,
    ("qt", "c"):4,
    ("gallon", "qt"):4,
    ("l", "qt"):1.057,
    ('Japanese cup','ml'):200,
    ('metric cup','ml'):250,
    ('Imperial cup','ml'):284.130625,
    ('Imperial pint','oz'):20,
    ("l", "ml"):1000,
    ("l", "cl"):100,
    ("l", "dl"):10,
    ("oz", "g"):28.35,
    ("fl oz","Tbs"):2,
    ("kg", "g"):1000,
    ("g", "mg"):1000,
    ("tsp", "drop"):76,
    ("oz", "dram"):16,
    ("dram", "grains"):27.34375,
    ("peck", "gallon"):2,
    ("bucket", "peck"):2,
    ("bushel", "bucket"):2,
    ("lb", "grains"):7000}

# DENSITIES of common foods. This allows us to convert between mass and volume.
# Translators: You may be best off translating the food names below, since lists
# of food densities can be hard to come by!
DENSITY_TABLE={
    "water":1,
    "juice, grape":1.03,
    "vegetable broth":1,
    "broth, vegetable":1,
    "broth, chicken":1,
    "milk":1.029,
    "milk, whole":1.029,
    "milk, skim":1.033,
    "milk, 2%":1.031,
    "milk, 1%":1.03,
    "coconut milk":0.875,
    "buttermilk":1.03,
    "heavy cream":0.994,
    "light cream":1.012,
    "half and half":1.025,
    "honey":1.420,
    "sugar, granulated":0.9,
    "salt":2.165,
    "butter":0.911,
    "oil, vegetable":0.88,
    "oil, olive":0.88,
    "oil, corn":0.88,
    "oil, sesame":0.88,
    "flour, all purpose": 0.55,
    "flour, whole wheat": 0.53,
    "corn starch": 0.6,
    "sugar, powdered": 0.6,
    "sugar, confectioners": 0.6
            }

# Standard unit names and alternate unit names that might appear.  For
# example: "c." is our standard abbreviation for cup.  "cup","c." or
# "cups" might appear in a recipe we are importing.  Each item of this
# list looks like this:
#
# ["standard", ["alternate1","alternate2","alternate3",...]]
#
# The first item should be the preferred abbreviation
# The second item should be the full name of the unit
# e.g. ["c.", ["cup",...]]
#
UNITS = [["",       ["each",   "eaches",  "ea",   "ea."]],
         ["bucket", ["bucket", "buckets", "bckt", "bckt."]],
         ["peck",   ["peck",   "pecks"]],
         ["bushel", ["bushel", "bushels", "bshl", "bshl.", "bsh", "bsh.", "bu", "bu."]],
         ["grains", ["grain",  "grains"]],
         ["dram",   ["dram",   "drams"]],
         ["drop",   ["drop",   "drops"]],
         ["fl oz",  ["fl oz",      "fluid ounce","fluid ounces","fl ounces",   "fl. ounces","fl. oz",     "fl oz.",     "fl. oz."]],
         ["tsp",    ["teaspoon",   "teaspoons",  "tea_spoon",   "tea_spoons",  "Teaspoon",  "Teaspoons",  "Tea_spoon",  "Tea_spoons",  "tsps","tsps.","Tsps","Tsps.","tsp","tsp.","Tsp","Tsp.","ts","ts.","Ts","Ts.","t","t."]],
         ["Tbs",    ["tablespoon", "tablespoons","table_spoon", "table_spoons","Tablespoon","Tablespoons","Table_spoon","Table_spoons","tbsp","tbsp.","Tbsp","Tbsp.","tbs","tbs.","Tbs","Tbs.","tb","tb.","Tb","Tb.","T","T."]],
         ["lb",     ["pound",      "pounds",     "lbs",  "lbs.",  "lb",  "lb."]],
         ["oz",     ["ounce",      "ounces",     "oz",   "oz."]],
         ["c",      ["cup",        "cups",       "c."]],
         ["qt",     ["quart",      "quarts",     "qt.",  "Qt", "Qt."]],
         ["pt",     ["pint",       "pints",      "pt.",  "Pt", "Pt."]],
         ["gallon", ["gallon",     "gallons",    "gal",  "gal."]],
         ["ml",     ["mililiter",  "mililiters", "ml",   "ml."]],
         ["cl",     ["centiliter", "centiliters","cl",   "cl."]],
         ["dl",     ["deciliter",  "deciliters", "dl",   "dl."]],
         ["l",      ["liter",      "liters",     "lit.", "l", "l."]],
         ["g",      ["grams",    "gram",      "g.", "g", "gr", "gr."]],
         ["mg",     ["miligram", "miligrams", "mg", "mg."]],
         ["kg",     ["kilogram", "kilograms", "kg", "kg."]],
         # These names aren"t really convertible, but we want them to
         # be recognized as units.
         ["small",  ["small",  "Small",    "sm",  "sm."]],
         ["medium", ["medium", "Medium",   "med", "med.", "Med", "Med."]],
         ["large",  ["large",  "Large",    "lg",  "lg.",  "Lg",  "Lg."]],
         ["box",    ["box",    "Box",      "bx"]],
         ["whole",  ["whole",  "whl",      "wh."]],
         ["clove",  ["clove",  "cloves",   "clv",    "clv."]],
         ["can",    ["can",    "Can",      "cn",      "cn."]],
         ["head",   ["head",   "heads",    "Head",    "Heads",    "hd",       "hd."]],
         ["package",["pkg.",   "package",  "Package", "packages", "Packages", "pkg", "Pkg.", "pack"]],
         ["slice",  ["slice",  "slices"]],
         ["bunch",  ["bunch",  "bunches"]],
         ]

METRIC_RANGE = (1,999)

# The following sets up unit groups. Users will be able to turn
# these on or off (American users, for example, would likely turn
# off metric units, since we don't use them).
# (User choice not implemented yet)
UNIT_GROUPS = {
    'metric mass':[('mg',METRIC_RANGE),
                   ('g',METRIC_RANGE),
                   ('kg',(1,None))],
    'metric volume':[('ml',METRIC_RANGE),
                     ('cl',(1,99)),
                     ('dl',(1,9)),
                     ('l',(1,None)),],
    'imperial weight':[('grains',(0,27)),
                       ('dram',(0.5,15)),
                       ('oz',(0.25,32)),
                       ('lb',(0.25,None)),
                       ],
    'imperial volume':[('drop',(0,3)),
                       ('tsp',(0.125,5.9)),
                       ('Tbs',(1,4)),
                       ('c',(0.25,6)),
                       ('pt',(1,1)),
                       ('qt',(1,3)),
                       ('gallon',(1,None)),
                       ('peck',(1,2)),
                       ('bucket',(1,2)),
                       ('bushel',(1,None)),
                       ('fl oz',(1,None)),
                       ]
    }



# The units here need to correspond to the standard unit names defined
# above in UNITS
CROSS_UNIT_TABLE = {
    ## This if for units that require an additional
    ## bit of information -- i.e. to convert between
    ## volume and mass you need the density of an
    ## item.  In these cases, the additional factor
    ## will be provided as an 'item' that is then looked
    ## up in the dictionary referenced here (i.e. the density_table)
    ## currently, 'density' is the only keyword used
    ("pt", "lb"):['density',1],
    ("Tbs", "oz"):['density',0.5],
    ("c", "oz"):['density',8],
    ("pt", "oz"):['density',16],
    ("ml", "g"):['density',1],
    ('oz','fl oz'):['density',1],
    }

# The units here need to correspond to the standard unit names defined
# in UNITS.  These are some core conversions from mass-to-volume,
# assuming a density of 1 (i.e. the density of water).
VOL_TO_MASS_TABLE = {
    ("pt", "lb") : 1,
    ("Tbs", "oz") : 0.5,
    ("c", "oz") : 8,
    ("pt", "oz") : 16,
    ("ml", "g") : 1,
    ("ml", "mg") : 1000,
    ("ml", "kg"): 0.001,
    ("cl", "kg"): 0.01,
    ("cl", "g") : 10,
    ("dl", "kg") : 0.1,
    ("dl", "g") : 100,
    ("l", "kg") : 1}

# TIME ABBREVIATIONS (this is new!)
TIME_ABBREVIATIONS = {
    'sec':'seconds',
    'min':'minutes',
    'hr':'hours'
    }

# These functions are rather important! Our goal is simply to
# facilitate look ups -- if the user types in "tomatoes", we want to
# find "tomato." Note that the strings these functions produce will
# _never_ be shown to the user, so it's fine to generate nonsense
# words as well as correct answers -- our goal is to generate a list
# of possible hits rather than to get the plural/singular form "right".

irregular_plurals={
    "geese":"goose",
    }
import re
two_digit_plural_matcher = re.compile('[szxo]es$')
one_digit_plural_matcher = re.compile("[^s]s$")
v_plural_matcher = re.compile('ves')

def guess_singulars (s):
    if len(s)<3: return []
    rets = []
    if irregular_plurals.has_key(s):
        rets.append(irregular_plurals[s])
    if two_digit_plural_matcher.search(s):
        wrd=s[0:-2]
        if not wrd in rets: rets.append(wrd)
    if v_plural_matcher.search(s):
        rets.append(s[0:-3]+'f')
    if one_digit_plural_matcher.search(s): rets.append(s[0:-1])
    return rets

def guess_plurals (s):
    if not s: return []
    ret = [s+'s',s+'es']
    if s[-1]=='f': ret.append(s[0:-1]+'ves')
    return ret

IGNORE = ["and","with","of","for","cold","warm","finely","thinly","roughly","coarsely"]

NUMBERS = {
    (1.0/8):['eighth','an eigth'],
    (1.0/4):['quarter','a quarter'],
    (3.0/4):['three quarters'],
    (2.0/3):['two thirds'],
    (1.0/3):['third','a third'],
    (1.0/2):['one half','a half','half'],
    1:['an','a','one'],
    2:['two','a couple','a couple of','a pair of'],
    3:['three'],
    4:['four'],
    5:['five'],
    6:['six'],
    7:['seven'],
    8:['eight'],
    9:['nine'],
    10:['ten'],
    11:['eleven'],
    12:['twelve','a dozen'],
    20:['twenty'],
    30:['thirty'],
    40:['forty'],
    50:['fifty'],
    60:['sixty'],
    }

PLURALS = [
    ('loaf','loaves'),
    ('box','boxes'),
    ]

PLURALS += [(s,s+'s') for s in
                       ['cup','crust','clove','serving','pound','gram',
                        'ounce','tablespoon','teaspoon','gallon','can',
                        'slice','pie','package','quart','pint','muffin',
                        'cookie',]
                       ]

########NEW FILE########
__FILENAME__ = defaults_en_GB
# -*- coding: utf-8 -*-
#
## we set up default information.

## first, easy to maintain lists which can eventually be moved to
## files.

# TRANSLATOR WARNING: DO NOT TRANSLATE THE FIELD NAMES: ONLY THE VALUES!!!
fields={'cuisine': ['English','Scottish','Welsh','Irish','American',
                    'Italian','French','Mexican','Indian',
                    'Southwestern','Asian/Thai','Asian/Vietnamese',
                    'Asian/Chinese','Asian/Japanese',],
        'rating' : ['Excellent','Great','Good','Fair','Poor'],
        'source' : [],
        'category' : ['Dessert','Entree','Salad','Soup',
                      'Breakfast'],
                  }

SYNONYMS=[
    # the first item of each list is the
    ["aubergine","eggplant"],
    ["azuki beans", "adzuki beans", "adzuki", "azuki"],
    ["beet","beetroot"],
    ["capsicum","chilli pepper"],
    ["chinese gooseberry","kiwi fruit","kiwi"],
    ["chinese leaves","bok choy"],
    ["chokeberry","cooking apple"],
    ["coriander","cilantro"],
    ["courgette","zucchini"],
    ["dragonfruit" , "pitaya"],
    ["green pepper", "bell pepper","green bell pepper", "pepper"],
    ["jackfruit","nangka"],
    ["juneberry","saskatoon"],
    ["langsat","longkong", "duku"],
    ["maise","sweetcorn","corn","sweet corn"],
    ["mamoncillo", "quenepa", "genip"],
    ["mangetout","snap peas"],
    ["nannyberry","sheepberry"],
    ["red bell pepper","red pepper"],
    ["rocket","arugula"],
    ["rose apple", "malay apple"],
    ["salak", "snakefruit"],
    ["sapodilla", "chiku", "sapadilla", "snake fruit", "sawo"],
    ["soursop", "guanabana"],
    ["spring greens","collard greens"],
    ["spring onion","scallion","green onion"],
    ["start fruit","carambola"],
    ["sunberry","wonderberry"],
    ["swede","rutubaga"],
    ["velvet persimmon","mabolo"],
    ["black cod","sablefish"],
    ["patagonian toothfish","chilean sea bass"],
    ]

# a dictionary key=ambiguous word, value=list of terms
AMBIGUOUS = {}


# triplicates ITEM, KEY, SHOPPING CATEGORY
INGREDIENT_DATA = [["alfalfa sprouts","alfalfa sprouts","produce"],
                   ["anise","anise","produce"],
                   ["artichoke","artichoke","produce"],
                   ["arugula","arugula","produce"],
                   ["asparagus","asparagus","produce"],
                   ["aubergine","aubergine","produce"],
                   ["avocado","avocado","produce"],
                   ["green beans","green beans","produce"],
                   ["azuki beans","azuki beans","produce"],
                   ["bean sprouts","bean sprouts","produce"],
                   ["black beans","black beans","produce"],
                   ["black-eyed peas","black-eyed peas","produce"],
                   ["borlotti beans","borlotti beans","produce"],
                   ["broad beans","broad beans","produce"],
                   ["chickpeas, garbanzos, or ceci beans","chickpeas, garbanzos, or ceci beans","produce"],
                   ["green beans","green beans","produce"],
                   ["kidney beans","kidney beans","produce"],
                   ["lentils","lentils","produce"],
                   ["lima bean or butter bean","lima bean or butter bean","produce"],
                   ["mung beans","mung beans","produce"],
                   ["navy beans","navy beans","produce"],
                   ["runner beans","runner beans","produce"],
                   ["soybeans","soybeans","produce"],
                   ["peas","peas","produce"],
                   ["snap peas","snap peas","produce"],
                   ["bok choy","bok choy","produce"],
                   ["breadfruit","breadfruit","produce"],
                   ["broccoflower","broccoflower","produce"],
                   ["broccoli","broccoli","produce"],
                   ["brussels sprouts","brussels sprouts","produce"],
                   ["cabbage","cabbage","produce"],
                   ["calabrese","calabrese","produce"],
                   ["cauliflower","cauliflower","produce"],
                   ["celery","celery","produce"],
                   ["chard","chard","produce"],
                   ["cilantro","cilantro","produce"],
                   ["collard greens","collard greens","produce"],
                   ["corn salad","corn salad","produce"],
                   ["endive","endive","produce"],
                   ["fennel","fennel","produce"],
                   ["fiddleheads","fiddleheads","produce"],
                   ["frisee","frisee","produce"],
                   ["kale","kale","produce"],
                   ["kohlrabi","kohlrabi","produce"],
                   ["lemon grass","lemon grass","produce"],
                   ["lettuce lactuca sativa","lettuce lactuca sativa","produce"],
                   ["corn","corn","produce"],
                   ["mushrooms","mushrooms","produce"],
                   ["mustard greens","mustard greens","produce"],
                   ["nettles","nettles","produce"],
                   ["new zealand spinach","new zealand spinach","produce"],
                   ["okra","okra","produce"],
                   ["onion family","onion family","produce"],
                   ["chives","chives","produce"],
                   ["garlic","garlic","produce"],
                   ["leek allium porrum","leek allium porrum","produce"],
                   ["onion","onion","produce"],
                   ["shallot","shallot","produce"],
                   ["scallion","scallion","produce"],
                   ["parsley","parsley","produce"],
                   ["pepper","pepper","produce"],
                   ["red bell pepper","red bell pepper","produce"],
                   ["chilli pepper","chilli pepper","produce"],
                   ["jalapeño pepper","pepper, jalapeño","produce"],
                   ["habanero pepper","pepper, habanero","produce"],
                   ["radicchio","radicchio","produce"],
                   ["rapini","rapini","produce"],
                   ["rhubarb","rhubarb","produce"],
                   ["root vegetables","root vegetables","produce"],
                   ["beet","beet","produce"],
                   ["carrot","carrot","produce"],
                   ["cassava (manioc)","cassava (manioc)","produce"],
                   ["celeriac","celeriac","produce"],
                   ["daikon","daikon","produce"],
                   ["fennel","fennel","produce"],
                   ["ginger","ginger","produce"],
                   ["parsnip","parsnip","produce"],
                   ["radish","radish","produce"],
                   ["rutabaga","rutabaga","produce"],
                   ["turnip","turnip","produce"],
                   ["wasabi","wasabi","produce"],
                   ["white radish","white radish","produce"],
                   ["skirret","skirret","produce"],
                   ["spinach","spinach","produce"],
                   ["acorn squash","squash, acorn","produce"],
                   ["butternut squash","squash, butternut","produce"],
                   ["courgette","courgette","produce"],
                   ["cucumber","cucumber","produce"],
                   ["gem squash","squash, gem","produce"],
                   ["patty pans","patty pans","produce"],
                   ["pumpkin","pumpkin","produce"],
                   ["spaghetti squash","squash, spaghetti","produce"],
                   ["tat soi","tat soi","produce"],
                   ["tomato","tomato","produce"],
                   ["jicama","jicama","produce"],
                   ["jerusalem artichoke","jerusalem artichoke","produce"],
                   ["potato","potato","produce"],
                   ["sweet potato","sweet potato","produce"],
                   ["taro","taro","produce"],
                   ["yam","yam","produce"],
                   ["water chestnut","water chestnut","produce"],
                   ["watercress","watercress","produce"],
                   # fruits, from wikipedia list
                   ["apple","apple","produce"],
                   ["green apple","green apple","produce"],
                   ["crabapple","crabapple","produce"],
                   ["chokeberry","chokeberry","produce"],
                   ["hawthorn","hawthorn","produce"],
                   ["juneberry","juneberry","produce"],
                   ["loquat","loquat","produce"],
                   ["medlar","medlar","produce"],
                   ["pomegranate","pomegranate","produce"],
                   ["quince","quince","produce"],
                   ["rowan","rowan","produce"],
                   ["rose hip","rose hip","produce"],
                   ["apricot","apricot","produce"],
                   ["cherry","cherry","produce"],
                   ["plum","plum","produce"],
                   ["peach","peach","produce"],
                   ["nectarine","nectarine","produce"],
                   ["blackberry","blackberry","produce"],
                   ["boysenberry","boysenberry","produce"],
                   ["raspberry","raspberry","produce"],
                   ["cloudberry","cloudberry","produce"],
                   ["wineberry","wineberry","produce"],
                   ["bearberry","bearberry","produce"],
                   ["bilberry","bilberry","produce"],
                   ["blueberry ","blueberry ","produce"],
                   ["cranberry ","cranberry ","produce"],
                   ["huckleberry ","huckleberry ","produce"],
                   ["lingonberry","lingonberry","produce"],
                   ["barberry ","barberry ","produce"],
                   ["red currant","currant, red","produce"],
                   ["black currant","currant, black","produce"],
                   ["white currant","currant, white","produce"],
                   ["elderberry ","elderberry ","produce"],
                   ["gooseberry ","gooseberry ","produce"],
                   ["nannyberry","nannyberry","produce"],
                   ["sea-buckthorn","sea-buckthorn","produce"],
                   ["wolfberry","wolfberry","produce"],
                   ["crowberry","crowberry","produce"],
                   ["mulberry","mulberry","produce"],
                   ["goumi","goumi","produce"],
                   ["kiwi fruit ","kiwi fruit ","produce"],
                   ["persimmon ","persimmon ","produce"],
                   ["buffaloberry","buffaloberry","produce"],
                   ["pawpaw","pawpaw","produce"],
                   ["american persimmon","american persimmon","produce"],
                   ["prickly pear ","prickly pear ","produce"],
                   ["saguaro","saguaro ","produce"],
                   ["pitaya","pitaya","produce"],
                   ["cantaloupe","cantaloupe","produce"],
                   ["honeydew","honeydew","produce"],
                   ["sunberry","sunberry","produce"],
                   ["watermelon ","watermelon ","produce"],
                   ["strawberry ","strawberry ","produce"],
                   ["angelica","angelica","produce"],
                   ["rhubarb","rhubarb","produce"],
                   ["fig ","fig ","produce"],
                   ["grape","grape","produce"],
                   ["jujube","jujube","produce"],
                   ["black mulberry","black mulberry","produce"],
                   ["pomegranate","pomegranate","produce"],
                   ["date","date","produce"],
                   ["citron","citron","produce"],
                   ["grapefruit","grapefruit","produce"],
                   ["pommelo","pommelo","produce"],
                   ["key lime","key lime","produce"],
                   ["kumquat","kumquat","produce"],
                   ["lemon","lemon","produce"],
                   ["lime","lime","produce"],
                   ["mandarin","mandarin","produce"],
                   ["clementine","clementine","produce"],
                   ["tangelo","tangelo","produce"],
                   ["tangerine","tangerine","produce"],
                   ["orange","orange","produce"],
                   ["ugli fruit","ugli fruit","produce"],
                   ["guava ","guava ","produce"],
                   ["longan","longan","produce"],
                   ["lychee","lychee","produce"],
                   ["passion fruit","passion fruit","produce"],
                   ["feijoa","feijoa","produce"],
                   ["akee","akee","produce"],
                   ["banana","banana","produce"],
                   ["plantain","plantain","produce"],
                   ["breadfruit","breadfruit","produce"],
                   ["camucamu","camucamu","produce"],
                   ["star fruit","star fruit","produce"],
                   ["cempedak","cempedak","produce"],
                   ["cherimoya","cherimoya","produce"],
                   ["coconut","coconut","produce"],
                   ["custard apple","custard apple","produce"],
                   ["dragonfruit","dragonfruit","produce"],
                   ["durian","durian","produce"],
                   ["guarana","guarana","produce"],
                   ["jackfruit","jackfruit","produce"],
                   ["keppel fruit","keppel fruit","produce"],
                   ["langsat","langsat","produce"],
                   ["velvet persimmon","velvet persimmon","produce"],
                   ["mamey sapote","mamey sapote","produce"],
                   ["mamoncillo","mamoncillo","produce"],
                   ["mango","mango","produce"],
                   ["mangosteen","mangosteen","produce"],
                   ["marang","marang","produce"],
                   ["papaya","papaya","produce"],
                   ["peanut butter fruit","peanut butter fruit","produce"],
                   ["pineapple","pineapple","produce"],
                   ["poha","poha","produce"],
                   ["rambutan","rambutan","produce"],
                   ["rose apple","rose apple","produce"],
                   ["salak","salak","produce"],
                   ["sapodilla","sapodilla","produce"],
                   ["soursop","soursop","produce"],
                   ["sugar apple","sugar apple","produce"],
                   ["tamarind","tamarind","produce"],
                   ## seafood, from wikipedia list
                   ["anchovy","anchovy","seafood"],
                   ["bass","bass","seafood"],
                   ["striped bass","striped bass","seafood"],
                   ["black cod","black cod","seafood"],
                   ["blowfish","blowfish","seafood"],
                   ["catfish","catfish","seafood"],
                   ["cod","cod","seafood"],
                   ["eel","eel","seafood"],
                   ["flounder","flounder","seafood"],
                   ["haddock","haddock","seafood"],
                   ["halibut","halibut","seafood"],
                   ["lingcod","lingcod","seafood"],
                   ["mahi mahi","mahi mahi","seafood"],
                   ["monkfish","monkfish","seafood"],
                   ["orange roughy","orange roughy","seafood"],
                   ["chilean sea bass","chilean sea bass","seafood"],
                   ["pike","pike","seafood"],
                   ["pollock","pollock","seafood"],
                   ["sanddab","sanddab","seafood"],
                   ["sardine","sardine","seafood"],
                   ["salmon","salmon","seafood"],
                   ["sea bass","sea bass","seafood"],
                   ["shark","shark","seafood"],
                   ["snapper","snapper","seafood"],
                   ["rockfish","rockfish","seafood"],
                   ["rock cod","rock cod","seafood"],
                   ["pacific snapper","pacific snapper","seafood"],
                   ["red snapper","red snapper","seafood"],
                   ["sole","sole","seafood"],
                   ["sturgeon","sturgeon","seafood"],
                   ["surimi","surimi","seafood"],
                   ["swordfish","swordfish","seafood"],
                   ["tilapia","tilapia","seafood"],
                   ["tilefish","tilefish","seafood"],
                   ["trout","trout","seafood"],
                   ["tuna","tuna","seafood"],
                   ["whitefish","whitefish","seafood"],
                   ["whiting","whiting","seafood"],
                   ["roe","roe","seafood"],
                   ["caviar","caviar","seafood"],
                   ["salmon roe","salmon roe","seafood"],
                   ["crab","crab","seafood"],
                   ["dungness crab","dungness crab","seafood"],
                   ["king crab","king crab","seafood"],
                   ["snow crab","snow crab","seafood"],
                   ["crayfish","crayfish","seafood"],
                   ["lobster","lobster","seafood"],
                   ["shrimp","shrimp","seafood"],
                   ["prawns","prawns","seafood"],
                   ["abalone","abalone","seafood"],
                   ["clam","clam","seafood"],
                   ["mussel","mussel","seafood"],
                   ["octopus","octopus","seafood"],
                   ["oyster","oyster","seafood"],
                   ["snail","snail","seafood"],
                   ["squid","squid","seafood"],
                   ["scallop","scallop","seafood"],
                   ## meats (garnered from wikipedia lists)
                   ["bacon","bacon","meats"],
                   ["chorizo","chorizo","meats"],
                   ["fuet","fuet","meats"],
                   ["salami","salami","meats"],
                   ["ham","ham","meats"],
                   ["mutton","mutton","meats"],
                   ["lamb","lamb","meats"],
                   ["veal","veal","meats"],
                   ["steak","steak","meats"],
                   ["hamburger","hamburger","meats"],
                   ["roast beef","roast beef","meats"],
                   ["chicken","chicken","meats"],
                   ["turkey","turkey","meats"],
                   ["duck","duck","meats"],
                   ["goose","goose","meats"],
                   ## my old list
                   ["tamarind water","tamarind water", "international"],
                   ["tamarind juice","tamarind juice", "international"],
                   ['vegetable broth','broth, vegetable', 'soups&sauces'],
                   ['fresh basil','basil, fresh', 'produce',],
                   ['light sugar brown','sugar, light brown', 'baking',],
                   ['balsamic vinegar','vinegar, balsamic', 'wines&oils',],
                   ['zuchini','zuchini', 'produce',],
                   ['avocado','avocado', 'produce',],
                   ['walnut','walnut', 'baking',],
                   ['celery','celery', 'produce',],
                   ['coriander seeds','coriander, seeds', 'spices',],
                   ['provolone cheese','cheese, provolone', 'dairy',],
                   ['galanga','galanga', 'produce',],
                   ['couscous','couscous', 'pastas',],
                   ['rice','rice', 'pastas',],
                   ['flour tortillas','tortillas, flour', 'dairy',],
                   ['olive oil','oil, olive', 'wines&oils',],
                   ['vanilla extract','vanilla extract', 'baking',],
                   ['red potato-skinned','potato, red-skinned', 'produce',],
                   ['powdered ginger','ginger, powdered', 'spices',],
                   ['roasted chili paste','roasted chili paste', 'international',],
                   ['curry powder','curry powder', 'spices',],
                   ['dried shrimp','shrimp, dried', 'international',],
                   ['dijon mustard','mustard, dijon', 'condiments',],
                   ['whole rock cod or snapper','whole rock cod or snapper', 'seafood',],
                   ['shells pasta','pasta, shells', 'pastas',],
                   ['green canned chiles','green chiles, canned', 'international',],
                   ['nutmeg','nutmeg', 'spices',],
                   ['sourdough bread','bread, sourdough', 'bread',],
                   ['corn oil','oil, corn', 'wines&oils',],
                   ['lemon grass','lemon grass', 'produce',],
                   ['feta cheese','cheese, feta', 'dairy',],
                   ['jack cheese','cheese, jack', 'dairy',],
                   ['grape tomato','tomato, grape', 'produce',],
                   ['cherry tomato','tomato, cherry', 'produce',],
                   ['spaghetti','spaghetti', 'pastas',],
                   ['cottage cheese','cheese, cottage', 'dairy',],
                   ['white onion','onion, white', 'produce',],
                   ['baking soda','baking soda', 'baking',],
                   ['garam masala','garam masala', 'spices',],
                   ['yogurt','yogurt', 'dairy',],
                   ['monkfish','monkfish', 'seafood',],
                   ['croutons','croutons', 'bread',],
                   ['ground coriander','coriander, ground', 'spices',],
                   ['chili powder','chili powder', 'spices',],
                   ['curly lettuce leaf','lettuce, curly leaf', 'produce',],
                   ['dark sugar brown','sugar, dark brown', 'baking',],
                   ['rice vinegar','vinegar, rice', 'international',],
                   ['pasta','pasta', 'pastas',],
                   ['sesame oil','oil, sesame', 'wines&oils',],
                   ['water','water', ''],
                   ['sour cream','sour cream', 'dairy',],
                   ['orange juice','orange juice', 'produce',],
                   ['spinach','spinach', 'produce',],
                   ['stick cinnamon','cinnamon, stick', 'spices',],
                   ['shrimp paste','shrimp paste', 'international',],
                   ['ground cinnamon','cinnamon, ground', 'spices',],
                   ['salad greens','salad greens', 'produce',],
                   ['garlic','garlic', 'produce',],
                   ['vegetable oil','oil, vegetable', 'wines&oils',],
                   ['peanut butter','peanut butter', 'bread',],
                   ['seeds ajowan','ajowan, seeds', 'spices',],
                   ['apple','apple', 'produce',],
                   ['cayenne','cayenne', 'spices',],
                   ['arugula','arugula', 'produce',],
                   ['linguine pasta','pasta, linguine', 'pastas',],
                   ['scallion','scallion', 'produce',],
                   ['egg','egg', 'dairy',],
                   ['lime','lime', 'produce',],
                   ['olives','olives', 'produce',],
                   ['basil, thai fresh','basil, fresh, thai', 'produce',],
                   ['bean sprouts','bean sprouts', 'produce',],
                   ['ricotta cheese','cheese, ricotta', 'dairy',],
                   ['parsley','parsley', 'produce',],
                   ['acorn squash','squash, acorn', 'produce',],
                   ['yellow onion','onion, yellow', 'produce',],
                   ['chiles, dried red','chiles, red, dried', 'produce',],
                   ['portobello mushroom','mushroom, portobello', 'produce',],
                   ['nappa cabbage','cabbage, nappa', 'produce',],
                   ['lime leaves','lime leaves', 'produce',],
                   ['butter','butter', 'dairy',],
                   ['bell red pepper','bell pepper, red', 'produce',],
                   ['mushroom','mushroom', 'produce',],
                   ['shallot','shallot', 'produce',],
                   ['cheddar cheese','cheese, cheddar', 'dairy',],
                   ['mozzarella cheese','cheese, mozzarella', 'dairy',],
                   ['squash','squash', 'produce',],
                   ['fish sauce','fish sauce', 'international',],
                   ['green curry paste','green curry paste', 'international',],
                   ['curly endive','endive, curly', 'produce',],
                   ['white sugar','sugar, white', 'baking',],
                   ['fresh cheese white goat','cheese, fresh white goat', 'dairy',],
                   ['cilantro stems','cilantro stems', 'produce',],
                   ['yellow cornmeal','cornmeal, yellow', 'baking',],
                   ['paprika','paprika', 'spices',],
                   ['chocolate chips','chocolate chips', 'baking',],
                   ['star anise','star anise', 'spices',],
                   ['brown sugar','sugar, brown', 'baking',],
                   ['roasted peanuts','peanuts, roasted', 'produce',],
                   ['fresh cilantro','cilantro, fresh', 'produce',],
                   ['honey','honey', 'baking',],
                   ['russet potato','potato, russet', 'produce',],
                   ['lemon juice','lemon juice', 'produce',],
                   ['carrot','carrot', 'produce',],
                   ['penne pasta','pasta, penne', 'pastas',],
                   ['red onion','onion, red', 'produce',],
                   ['shredded coconut','coconut, shredded', 'baking',],
                   ['peppered linguini','linguini, peppered', 'pastas',],
                   ['milk','milk', 'dairy',],
                   ['tahitian squash','squash, tahitian', 'produce',],
                   ['baking powder','baking powder', 'baking',],
                   ['tomato sauce','tomato sauce', 'soups&sauces',],
                   ['seeds mustard','mustard, seeds', 'spices',],
                   ['flat rice flour noodles','flat rice flour noodles', 'international',],
                   ['parmesan cheese','cheese, parmesan', 'pastas',],
                   ['mayonnaise','mayonnaise', 'bread',],
                   ['leek','leek', 'produce',],
                   ['zucchini','zucchini', 'produce',],
                   ['smoked cheese Gouda','cheese, smoked Gouda', 'dairy',],
                   ['lime juice','lime juice', 'produce',],
                   ['coconut milk','coconut milk', 'international',],
                   ['eggs','egg', 'dairy',],
                   ['salmon','salmon', 'seafood',],
                   ['lasagna pasta noodles','pasta, lasagna noodles', 'pastas',],
                   ['all flour purpose','flour, all purpose', 'baking',],
                   ['ground cumin','cumin, ground', 'spices',],
                   ['cucumber','cucumber', 'produce',],
                   ['salsa','salsa', 'international',],
                   ['broccoli','broccoli', 'produce',],
                   ['rolled oats','rolled oats', 'pastas',],
                   ['tomato','tomato', 'produce',],
                   ['potato','potato', 'produce',],
                   ['white wine','wine, white', 'wines&oils',],
                   ['black ground pepper','black pepper, ground', 'spices',],
                   ['seeds cumin','cumin, seeds', 'spices',],
                   ['soy sauce','soy sauce', 'international',],
                   ['sesame seeds','sesame seeds', 'international',],
                   ['radicchio','radicchio', 'produce',],
                   ['salt','salt', 'baking',],
                   ['fresh ginger','ginger, fresh', 'produce',],
                   ['turmeric','turmeric', 'spices',],
                   ['chicken breast' ,'chicken, breast' , 'meats',],
                   ['whole chicken' ,'chicken, whole' , 'meats',],
                   ['chicken leg' ,'chicken, leg' , 'meats',],
                   ['beef' ,'beef' , 'meats',],
                   ['ground beef' ,'beef, ground' , 'meats',],
                   ['pork' ,'pork' , 'meats',],
                   ['turkey' ,'turkey' , 'meats',],
                   ]

CONVERTER_TABLE = {
    ("c", "Tbs."):16,
    ("lb", "oz."):16,
    ("Tbs", "tsp."):3,
    ("pt", "c."):2,
    ("qt", "c."):4,
    ("gallon", "qt."):4,
    #("l", "qt."):1.057,
    ('qt.','l'):0.946,
    ('Japanese cup','ml'):200,
    ('metric cup','ml'):250,
    ('imperial cup','ml'):284.130625,
    ('Imperial pint','oz'):20,
    ("l", "ml"):1000,
    ("l", "cl"):100,
    ("l", "dl"):10,
    ("oz", "g"):28.35,
    ("kg", "g"):1000,
    ("g", "mg"):1000,
    ("tsp", "drop"):76,
    ("oz", "dram"):16,
    ("dram", "grains"):27.34375,
    ("peck", "gallon"):2,
    ("bucket", "peck"):2,
    ("bushel", "bucket"):2,
    ("lb", "grains"):7000}

DENSITY_TABLE={
    "water":1,
    "juice, grape":1.03,
    "vegetable broth":1,
    "broth, vegetable":1,
    "broth, chicken":1,
    "milk":1.029,
    "milk, whole":1.029,
    "milk, skim":1.033,
    "milk, 2%":1.031,
    "milk, 1%":1.03,
    "coconut milk":0.875,
    "buttermilk":1.03,
    "heavy cream":0.994,
    "light cream":1.012,
    "half and half":1.025,
    "honey":1.420,
    "sugar, white":1.550,
    "salt":2.165,
    "butter":0.911,
    "oil, vegetable":0.88,
    "oil, olive":0.88,
    "oil, corn":0.88,
    "oil, sesame":0.88,
    "flour, all purpose": 0.6,
    "flour, whole wheat": 0.6,
    "corn starch": 0.6,
    "sugar, powdered": 0.6,
    "sugar, confectioners": 0.6
            }

UNITS = [["",       ["each",   "eaches",  "ea",   "ea."]],
         ["bucket", ["bucket", "buckets", "bckt", "bckt."]],
         ["peck",   ["peck",   "pecks"]],
         ["bushel", ["bushel", "bushels", "bshl", "bshl.", "bsh", "bsh.", "bu", "bu."]],
         ["grains", ["grain",  "grains"]],
         ["dram",   ["dram",   "drams"]],
         ["drop",   ["drop",   "drops"]],
         ["fl oz",  ["fl oz",      "fluid ounce","fluid ounces","fl ounces",   "fl. ounces","fl. oz",     "fl oz.",     "fl. oz."]],
         ["tsp",    ["teaspoon",   "teaspoons",  "tea_spoon",   "tea_spoons",  "Teaspoon",  "Teaspoons",  "Tea_spoon",  "Tea_spoons",  "tsps","tsps.","Tsps","Tsps.","tsp","tsp.","Tsp","Tsp.","ts","ts.","Ts","Ts.","t","t."]],
         ["Tbs",    ["tablespoon", "tablespoons","table_spoon", "table_spoons","Tablespoon","Tablespoons","Table_spoon","Table_spoons","tbsp","tbsp.","Tbsp","Tbsp.","tbs","tbs.","Tbs","Tbs.","tb","tb.","Tb","Tb.","T","T."]],
         ["lb",     ["pound",      "pounds",     "lbs",  "lbs.",  "lb",  "lb."]],
         ["oz",     ["ounce",      "ounces",     "oz",   "oz."]],
         ["c",      ["cup",        "cups",       "c."]],
         ["qt",     ["quart",      "quarts",     "qt.",  "Qt", "Qt."]],
         ["pt",     ["pint",       "pints",      "pt.",  "Pt", "Pt."]],
         ["gallon", ["gallon",     "gallons",    "gal",  "gal."]],
         ["ml",     ["mililiter",  "mililiters", "ml",   "ml."]],
         ["cl",     ["centiliter", "centiliters","cl",   "cl."]],
         ["dl",     ["deciliter",  "deciliters", "dl",   "dl."]],
         ["l",      ["liter",      "liters",     "lit.", "l", "l."]],
         ["g",      ["grams",    "gram",      "g.", "g", "gr", "gr."]],
         ["mg",     ["miligram", "miligrams", "mg", "mg."]],
         ["kg",     ["kilogram", "kilograms", "kg", "kg."]],
         # These names aren"t really convertible, but we want them to
         # be recognized as units.
         ["small",  ["small",  "Small",    "sm",  "sm."]],
         ["medium", ["medium", "Medium",   "med", "med.", "Med", "Med."]],
         ["large",  ["large",  "Large",    "lg",  "lg.",  "Lg",  "Lg."]],
         ["box",    ["box",    "Box",      "bx"]],
         ["whole",  ["whole",  "whl",      "wh."]],
         ["clove",  ["clove",  "cloves",   "clv",    "clv."]],
         ["can",    ["can",    "Can",      "cn",      "cn."]],
         ["head",   ["head",   "heads",    "Head",    "Heads",    "hd",       "hd."]],
         ["package",["pkg.",   "package",  "Package", "packages", "Packages", "pkg", "Pkg.", "pack"]],
         ["slice",  ["slice",  "slices"]],
         ["bunch",  ["bunch",  "bunches"]],
         ]

METRIC_RANGE = (1,999)

UNIT_GROUPS = {
    'metric mass':[('mg',METRIC_RANGE),
                   ('g',METRIC_RANGE),
                   ('kg',(1,None))],
    'metric volume':[('ml',METRIC_RANGE),
                     ('cl',(1,99)),
                     ('dl',(1,9)),
                     ('l',(1,None)),],
    'imperial weight':[('grain',(0,27)),
                       ('dram',(0.5,15)),
                       ('oz',(0.25,15)),
                       ('lb',(0.25,None)),
                       ],
    'imperial volume':[('drop',(0,10)),
                       ('tsp',(0.125,5.9)),
                       ('Tbs',(1,4)),
                       ('c',(0.25,4)),
                       ('pt',(1,1)),
                       ('qt',(1,3)),
                       ('gallon',(1,None)),
                       ('peck',(1,2)),
                       ('bucket',(1,2)),
                       ('bushel',(1,None))]
    }


CROSS_UNIT_TABLE = {
    ## This if for units that require an additional
    ## bit of information -- i.e. to convert between
    ## volume and mass you need the density of an
    ## item.  In these cases, the additional factor
    ## will be provided as an 'item' that is then looked
    ## up in the dictionary referenced here (i.e. the density_table)
    ## currently, 'density' is the only keyword used
    ("pt", "lb"):['density',1],
    ("Tbs", "oz"):['density',0.5],
    ("c", "oz"):['density',8],
    ("pt", "oz"):['density',16],
    ("ml", "g"):['density',1]}

VOL_TO_MASS_TABLE = {
    ("pt.", "lb") : 1,
    ("Tbs.", "oz") : 0.5,
    ("c", "oz") : 8,
    ("pt", "oz") : 16,
    ("ml", "g") : 1,
    ("ml", "mg") : 1000,
    ("ml", "kg"): 0.001,
    ("cl", "kg"): 0.01,
    ("cl", "g") : 10,
    ("dl", "kg") : 0.1,
    ("dl", "g") : 100,
    ("l", "kg") : 1}

def add_itm (kd, k, v):
    if kd.has_key(k):
        kd[k].append(v)
    else:
        kd[k]=[v]

## now we set up our dictionaries
keydic = {}
shopdic = {}
for lst in SYNONYMS:
    k = lst[0]
    for i in lst:
        add_itm(keydic,i,k)

for amb,lst in AMBIGUOUS.items():
    if keydic.has_key(amb):
        keydic[amb] += lst
    else:
        keydic[amb] = lst

for row in INGREDIENT_DATA:
    name,key,shop=row
    add_itm(keydic,name,key)
    shopdic[name]=shop


irregular_plurals={
    "geese":"goose",
    }
import re
two_digit_plural_matcher = re.compile('[szxo]es$')
one_digit_plural_matcher = re.compile("[^s]s$")
v_plural_matcher = re.compile('ves')

def guess_singulars (s):
    if len(s)<3: return []
    rets = []
    if irregular_plurals.has_key(s):
        rets.append(irregular_plurals[s])
    if two_digit_plural_matcher.search(s):
        wrd=s[0:-2]
        if not wrd in rets: rets.append(wrd)
    if v_plural_matcher.search(s):
        if not wrd in rets: rets.append(wrd)
        rets.append(s[0:-3]+'f')
    if one_digit_plural_matcher.search(s): rets.append(s[0:-1])
    return rets

def guess_plurals (s):
    ret = [s+'s',s+'es']
    if s[-1]=='f': ret.append(s[0:-1]+'ves')
    return ret

IGNORE = ["and","with","of","for","cold","warm","finely","thinly","roughly","coarsely"]

NUMBERS = {
    (1.0/8):['eighth','an eigth'],
    (1.0/4):['quarter','a quarter'],
    (3.0/4):['three quarters'],
    (2.0/3):['two thirds'],
    (1.0/3):['third','a third'],
    (1.0/2):['half','a half','one half'],
    1:['an','a','one'],
    2:['two','a couple','a couple of','a pair of'],
    3:['three'],
    4:['four'],
    5:['five'],
    6:['six'],
    7:['seven'],
    8:['eight'],
    9:['nine'],
    10:['ten'],
    11:['eleven'],
    12:['twelve','a dozen'],
    20:['twenty'],
    30:['thirty'],
    40:['forty'],
    50:['fifty'],
    60:['sixty'],
    }

########NEW FILE########
__FILENAME__ = defaults_es
# -*- coding: utf-8 -*-
#
# we set up default information for our locale (Spanish)
# Translators should use this file as the basis of their translation.
# Copy this file and rename it for you locale.
#
# Language: Spanish
# Translator: Thomas M. Hinkle
# Last-updated: 4/27/05
CREDITS="Thomas M. Hinkle"

## first, easy to maintain lists which can eventually be moved to
## files.

# TRANSLATOR WARNING: DO NOT TRANSLATE THE FIELD NAMES: ONLY THE VALUES!!!
fields={'cuisine': ['Español','Mejicano','Cubano','Argentino','Brazileño','Italiano','Griego',
                   'Chino','Francés','Vasco','Indio'],
        'rating' : ['Excelente','Muy Bueno','Bueno','Así Así','Malo'],
        'source' : [],
        'category' : ['Postre','Aperitivo','Ensalada','Sopa',
                      'Desayuno','Plato principal','Tapa'],
                  }

SYNONYMS=[
    # the first item of each list is the most common
    # word, the others are synonyms
    ['durazno','melocotón'],
    ['camarón','gamba'],
    ]

# a dictionary key=ambiguous word, value=list of terms
AMBIGUOUS = {}


# triplicates ITEM, KEY, SHOPPING CATEGORY
INGREDIENT_DATA = [
    ["albahaca","albahaca",'especias'],
    ["ajedrea","ajedrea",'especias'],
    ["estragón","estragón",'especias'],
    ["laurel","laurel",'especias'],
    ["menta","menta",'especias'],
    ["salvia","salvia",'especias'],
    ["orégano","orégano",'especias'],
    ["romero","romero",'especias'],
    ["salvia","salvia",'especias'],
    ["tomillo","tomillo",'especias'],
    ["amapola","amapola",'especias'],
    ["anís","anís",'especias'],
    ["comino","comino",'especias'],
    ["mostaza","mostaza",'especias'],
    ["nuez moscada","moscada",'especias'],
    ["pimienta","pimienta",'especias'],
    ["el sésamo","sésamo",'especias'],
    ["canela","canela",'especias'],
    ["azafrán","azafrán",'especias'],
    ["clavo de olor","olor",'especias'],
    ["vainilla","vainilla",'especias'],
    ["rizoma","rizoma",'especias'],
    ["cúrcuma","cúrcuma",'especias'],
    ["jengibre","jengibre",'especias'],
    ["aceite","aceite",""],
    ["aceituna","aceituna",""],
    ["acelga","acelga",""],
    ["aguacate","aguacate",""],
    ["ají","ají",""],
    ["ajo","ajo",""],
    ["albaricoque","albaricoque",""],
    ["alcachofa","alcachofa",""],
    ["almeja","almeja",""],
    ["almendra","almendra",""],
    ["ananá","ananá",""],
    ["anchoa","anchoa",""],
    ["anguila","anguila",""],
    ["angula","angula",""],
    ["apio","apio",""],
    ["arándano","arándano",""],
    ["arenque","arenque",""],
    ["arroz","arroz",""],
    ["atún","atún",""],
    ["avellana","avellana",""],
    ["avena","avena",""],
    ["azúcar","azúcar",""],
    ["bacaladilla","bacaladilla",""],
    ["bacalao","bacalao",""],
    ["bacon","bacon",""],
    ["banana","banana",""],
    ["barbo","barbo",""],
    ["batata","batata",""],
    ["berberecho","berberecho",""],
    ["berenjena","berenjena",""],
    ["berro","berro",""],
    ["besugo","besugo",""],
    ["bogavante","bogavante",""],
    ["boniato","boniato",""],
    ["bonito","bonito",""],
    ["boquerón","boquerón",""],
    ["breca","breca",""],
    ["breva","breva",""],
    ["bróculi","bróculi",""],
    ["caballa","caballa",""],
    ["caballo","caballo",""],
    ["cabrito","cabrito",""],
    ["cacahuete","cacahuete",""],
    ["cacao","cacao",""],
    ["café","café",""],
    ["calabacín","calabacín",""],
    ["calabaza","calabaza",""],
    ["calamar","calamar",""],
    ["camarón","camarón",""],
    ["cangrejo","cangrejo",""],
    ["caracol","caracol",""],
    ["caramelo","caramelo",""],
    ["cardillo","cardillo",""],
    ["cardo","cardo",""],
    ["carpa","carpa",""],
    ["castaña","castaña",""],
    ["caviar","caviar",""],
    ["cebolla","cebolla",""],
    ["cebolleta","cebolleta",""],
    ["cecina","cecina",""],
    ["centeno","centeno",""],
    ["centollo","centollo",""],
    ["cerdo","cerdo",""],
    ["cereza","cereza",""],
    ["champiñón","champiñón",""],
    ["chile","chile",""],
    ["chiria","chiria",""],
    ["chirimoya","chirimoya",""],
    ["chirivia","chirivia",""],
    ["chirla","chirla",""],
    ["chocolate","chocolate",""],
    ["choclo","choclo",""],
    ["chorizo","chorizo",""],
    ["ciervo","ciervo",""],
    ["cigala","cigala",""],
    ["ciruela","ciruela",""],
    ["coco","coco",""],
    ["codorniz","codorniz",""],
    ["col","col",""],
    ["col de Bruselas","col de Bruselas",""],
    ["col lombarda","col lombarda",""],
    ["coliflor","coliflor",""],
    ["conejo","conejo",""],
    ["congrio","congrio",""],
    ["cuajada","cuajada",""],
    ["dátil","dátil",""],
    ["dorada","dorada",""],
    ["endibia","endibia",""],
    ["escarola","escarola",""],
    ["espárrago","espárrago",""],
    ["espagueti","espagueti",""],
    ["espinaca","espinaca",""],
    ["faisán","faisán",""],
    ["fiambre","fiambre",""],
    ["fideo","fideo",""],
    ["foie-gras","foie-gras",""],
    ["frambuesa","frambuesa",""],
    ["fresa","fresa",""],
    ["fresón","fresón",""],
    ["frutilla","frutilla",""],
    ["gallina","gallina",""],
    ["gallo","gallo",""],
    ["gamba","gamba",""],
    ["ganso","ganso",""],
    ["garbanzo","garbanzo",""],
    ["gofio","gofio",""],
    ["granada","granada",""],
    ["grelo","grelo",""],
    ["grosella","grosella",""],
    ["guinda","guinda",""],
    ["guisante","guisante",""],
    ["haba","haba",""],
    ["harina de arroz","harina de arroz",""],
    ["harina de avena","harina de avena",""],
    ["harina de centeno","harina de centeno",""],
    ["harina de maíz","harina de maíz",""],
    ["harina de soja","harina de soja",""],
    ["harina de trigo","harina de trigo",""],
    ["higo","higo",""],
    ["hueva","hueva",""],
    ["huevo","huevo",""],
    ["jabalí","jabalí",""],
    ["jamón","jamón",""],
    ["judía blanca","judía blanca",""],
    ["judía pinta","judía pinta",""],
    ["judía verde","judía verde",""],
    ["jurel","jurel",""],
    ["kiwi","kiwi",""],
    ["langosta (crustáceo)","langosta (crustáceo)",""],
    ["leche","leche",""],
    ["lechuga","lechuga",""],
    ["lenguado","lenguado",""],
    ["lenteja","lenteja",""],
    ["levadura","levadura",""],
    ["liebre","liebre",""],
    ["limón","limón",""],
    ["lubina","lubina",""],
    ["macarrón","macarrón",""],
    ["maíz","maíz",""],
    ["malta","malta",""],
    ["mandarina","mandarina",""],
    ["mandioca","mandioca",""],
    ["mango","mango",""],
    ["manteca","manteca",""],
    ["mantequilla","mantequilla",""],
    ["manzana","manzana",""],
    ["margarina","margarina",""],
    ["mazorca","mazorca",""],
    ["mejillón","mejillón",""],
    ["melaza","melaza",""],
    ["melocotón","melocotón",""],
    ["melón","melón",""],
    ["membrillo","membrillo",""],
    ["merluza","merluza",""],
    ["mero","mero",""],
    ["miel","miel",""],
    ["mora","mora",""],
    ["morcilla","morcilla",""],
    ["mortadela","mortadela",""],
    ["nabo","nabo",""],
    ["naranja","naranja",""],
    ["nata","nata",""],
    ["navaja","navaja",""],
    ["nécora","nécora",""],
    ["níspero","níspero",""],
    ["nuez","nuez",""],
    ["ostra","ostra",""],
    ["paloma","paloma",""],
    ["palometa","palometa",""],
    ["pan","pan",""],
    ["panceta","panceta",""],
    ["papa","papa",""],
    ["pasta","pasta",""],
    ["paté","paté",""],
    ["pato","pato",""],
    ["pavo","pavo",""],
    ["pepino","pepino",""],
    ["pera","pera",""],
    ["perca","perca",""],
    ["percebe","percebe",""],
    ["perdiz","perdiz",""],
    ["pescadilla","pescadilla",""],
    ["pez espada","pez espada",""],
    ["pimiento","pimiento",""],
    ["piña","piña",""],
    ["piñón","piñón",""],
    ["pistacho","pistacho",""],
    ["plátano","plátano",""],
    ["platija","platija",""],
    ["pollo","pollo",""],
    ["pomelo","pomelo",""],
    ["puerro","puerro",""],
    ["pulpo","pulpo",""],
    ["queso","queso",""],
    ["rábano","rábano",""],
    ["rape","rape",""],
    ["raya","raya",""],
    ["remolacha","remolacha",""],
    ["repollo","repollo",""],
    ["rodaballo","rodaballo",""],
    ["salchicha","salchicha",""],
    ["salchichón","salchichón",""],
    ["salmón","salmón",""],
    ["salmonete","salmonete",""],
    ["sandía","sandía",""],
    ["sardinas","sardinas",""],
    ["sargo","sargo",""],
    ["sémola","sémola",""],
    ["setas","setas",""],
    ["soda","soda",""],
    ["soja","soja",""],
    ["tapioca","tapioca",""],
    ["tomate","tomate",""],
    ["toronja","toronja",""],
    ["trucha","trucha",""],
    ["uva","uva",""],
    ["vieira","vieira",""],
    ["yoghurt","yoghurt",""],
    ["yuca","yuca",""],
    ]

CONVERTER_TABLE = {
    ("tazas", "tbs."):16,
    ("libra", "onza"):16,
    ("cuchara", "cucharilla"):3,
    ("pt.", "tazas"):2,
    ("qt.", "tazas"):4,
    ("galón", "quarto de galón"):4,
    ("l", "quarto de galón"):1.057,
    ("l", "ml"):1000,
    ("l", "cl"):100,
    ("l", "dl"):10,
    ("onza", "g"):28.35,
    ("kg", "g"):1000,
    ("g", "mg"):1000,
    ("cucharilla", "drop"):76,
    # Are there translations for these units?   Not really, they're english-imperial units, not adopted by Spain...  :-)
    # ("onza", "dram"):16,
    # ("dram", "grains"):27.34375,
    # ("peck", "galón"):2,
    # ("bucket", "peck"):2,
    # ("bushel", "bucket"):2,
    # ("lb.", "grains"):7000,
    }

METRIC_RANGE = (1,999)

UNIT_GROUPS = {
    'metric mass':[('mg',METRIC_RANGE),
                   ('g',METRIC_RANGE),
                   ('kg',(1,None))],
    'metric volume':[('ml',METRIC_RANGE),
                     ('cl',(1,99)),
                     ('dl',(1,9)),
                     ('l',(1,None)),],
    'imperial weight':[
    # ('grain',(0,27)),
    # ('dram',(0.5,15)),
    ('onza',(0.25,15)),
    ('libra',(0.25,None)),
    ],
    'imperial volume':[
    #('drop',(0,10)),
    ('cucharilla',(0.125,3)),
    ('cuchara',(1,4)),
    ('taza',(0.25,4)),
    # ('pt.',(1,1)),
    ('quarto de galón',(1,3)),
    ('galón',(1,None)),
    # ('peck',(1,2)),
    # ('bucket',(1,2)),
    # ('bushel',(1,None))
    ]
    }

DENSITY_TABLE={
    "agua":1,
    "zumo":1.03,
    "caldo":1,
    "leche":1.029,
    "leche entera":1.029,
    "leche desnatada":1.033,
    # "milk, 2%":1.031,
    # "milk, 1%":1.03,
    "leche de coco":0.875,
    "suero de la leche":1.03,
    # heavy cream -- I don't know the differences in Sp.
    "crema":0.994,
    # "light cream":1.012,
    # "half and half":1.025,
    "miel":1.420,
    "azúcar":1.550,
    "sal":2.165,
    "mantequilla":0.911,
    "aceite vegetal":0.88,
    "aceite de oliva":0.88,
    "aceite de sésame":0.88,
    "harina": 0.6,
    "harina de trigo entero": 0.6,
    "almidón de maíz": 0.6,
    "azúcar impalpable": 0.6,
            }

UNITS = [
    ["ml", ["ml.", "mL", "mL.", "ml"]],
    # ["bucket" , ["bucket", "buckets", "bckt."]],
    # ["peck", ["peck", "pecks"]],
    # ["bushel", ["bushel", "bushels", "bsh.", "bu.", "bu", "bsh", "bshl", "bshl."]],
    # ["grains", ["grain", "grains"]],
    # ["dram", ["dram", "drams"]],
    ["cucharilla", ["cucharilla"]],
    ["cuchara", ["cuchara","tbs", "tbsp","tbsp.", "tablespoon", "table spoon", "tbsps.", "tablespoons", "Tablespoon", "T"]],
    ["libra", ["libra","libras"]],
    ["onza", ["onza","onzas"]],
    ["taza", ["taza","tazas"]],
    ["quarto de galón", ["quarto de galón","quarto"]],
    # ["pt.", ["pint", "pt.", "pints"]],
    ["galón", ["galón", "galones", "gal."]],
    ["ml", ["ml", "ml.", "mililitro", "mililitros"]],
    ["cl", ["cl", "cl.", "centilitro", "centilitros"]],
    ["dl", ["dl", "dl.", "decilitro", "decilitros"]],
    ["l", ["litro", "l.", "lit.", "litros"]],
    ["g", ["gramos", "gramo", "g.","gr.","g","gr"]],
    ["mg", ["mg.", "mg", "miligramo", "miligramos"]],
    ["kg", ["kg.", "kg", "kilogramo", "kilogramos"]],
    ]

CROSS_UNIT_TABLE = {
    ## This if for units that require an additional
    ## bit of information -- i.e. to convert between
    ## volume and mass you need the density of an
    ## item.  In these cases, the additional factor
    ## will be provided as an 'item' that is then looked
    ## up in the dictionary referenced here (i.e. the density_table)
    ## currently, 'density' is the only keyword used
    ("pt.", "lb."):['density',1],
    ("cuchara", "onza"):['density',0.5],
    ("taza", "onza"):['density',8],
    # ("pt.", "onza"):['density',16],
    ("ml", "g"):['density',1]}

VOL_TO_MASS_TABLE = {
    ("pt.", "lb.") : 1,
    ("cuchara", "onza") : 0.5,
    ("tazas", "onza") : 8,
    ("pt.", "onza") : 16,
    ("ml", "g") : 1,
    ("ml", "mg") : 1000,
    ("ml", "kg"): 0.001,
    ("cl", "kg"): 0.01,
    ("cl", "g") : 10,
    ("dl", "kg") : 0.1,
    ("dl", "g") : 100,
    ("l", "kg") : 1}

TIME_ABBREVIATIOSN = {
    'hrs' : 'horas',
    'hra' : 'horas',
    'mntas' : 'minutas',
    'mnta' : 'minutas',
    }

# These functions are rather important! Our goal is simply to
# facilitate look ups -- if the user types in "tomatoes", we want to
# find "tomato." Note that the strings these functions produce will
# _never_ be shown to the user, so it's fine to generate nonsense
# words as well as correct answers -- our goal is to generate a list
# of possible hits rather than to get the plural/singular form "right".

def guess_singulars (s):
    if len(s)<3: return []
    rets = []
    if s[-1]=='s':
        rets.append(s[0:-1])
        if s[-2]=='e':
            rets.append(s[0:-2])
    return rets

def guess_plurals (s):
    return [s+'s',s+'es']

IGNORE = []

NUMBERS = {
    (1.0/8):['octavo','un octavo'],
    (1.0/4):['cuarto','un cuarto'],
    (3.0/4):['tres cuartos'],
    (2.0/3):['dos tercios'],
    (1.0/3):['un tercio',],
    (1.0/2):['una mitad','la mitad'],
    1:['un','una','uno'],
    2:['dos','un par','un par de'],
    3:['tres'],
    4:['cuatro'],
    5:['cinco'],
    6:['seis'],
    7:['siete'],
    8:['ocho'],
    9:['nueve'],
    10:['diez'],
    11:['once'],
    12:['doce','una docena','una dozena','una docena de','una dozena de'],
    20:['veinte'],
    30:['treinta'],
    40:['cuarenta'],
    50:['cincuenta'],
    60:['sesenta'],
    100:['cien'],
    }

########NEW FILE########
__FILENAME__ = defaults_fr
# -*- coding: utf-8 -*-
# we set up default information for our locale.
# Translators should use this file as the basis of their translation.
# Copy this file and rename it for you locale.
#
# For example, Spanish uses:
# defaults_es.py
#
# British English uses:
# defaults_en_GB.py
#
# Please fill in the below fields:

# Language: Français (French)
# Translator: Luc Charest.
# Last-updated: 2005-07-18 (07/18/05)

CREDITS = "Luc Charest"

# TRANSLATOR WARNING: DO NOT TRANSLATE THE FIELD NAMES: ONLY THE VALUES!!!

# only translate the items in the list [..] (and feel free to create
# categories that make sense for your locale -- no need to translate
# these ones). DO NOT translate 'cuisine','rating','source' or
# 'category'

# The below are Gourmet's standard fields and the default categories for them.
# Do not translate the field names ('cuisine','rating','source,'category').
# Instead, fill in the list with categories that make sense for your locale.
# Feel free to change the number or content of categories to be consistent
# with what users in your locale are likely to be familiar with.

fields={'cuisine': ['Américaine','Italienne','Mexicaine'
                    'Américaine/sud-ouest','Asiatique/thaïlandaise','Asiatique/vietnamienne',
                    'Asiatique/chinoise','Asiatique/japonaise','Asiatique/indienne','Canadienne'
		    'Canadienne/québécoise','Grecque','Française'],
        'rating' : ['5 - Excellent','4 - Très bon','3 - Bon','2 - Moyen','1 - Mauvais','(non-testé)'],
        'source' : [],
        'category' : ['Dessert','Entrée','Salade','Soupe',
                      'Petit-déjeuné'],
                  }

# In English, there are a heck of a lot of synonyms. This is a list
# for those synonyms.  ["preferred word","alternate word","alternate word"]
# If there are none of these that you can think of in your language, just
# set this to:
# SYNONYMS=[]

# note from translator: some terms are not standard but used in common langugage, some are used in a fautive manner, 
# I decided to put them in different sections so it is still clear what is a synonym and what should not be a synonym.
SYNONYMS=[
    # the first item of each list is the default
    ["anis","anis vert"],
    ["doliques à œil noir","haricot à œil noir"],
    ["gourganes","fèves des marais"],
    ["haricots de Lima","haricot de Siéva","haricot du Cap","haricot du Tchad","haricot de Madagascar"],
    ["soya","soja"], 
    ["fruit à pain","fruit de l'arbre à pain"],
    ["chou pommé","chou cabus"],
    ["bette à carde","bette","poirée","carde","bette poirée","bette à côtes",
	"blète","blette","carde poirée","bette à cardes"],
    ["coriandre","persil chinois","persil arabe"],
    ["mâche commune","mâche","doucette"],
    ["endive","chicorée de Bruxelles","chicon","witloof","chicorée witloof"],
    ["crosses de fougère","crosses de fougère-à-l'autruche","tête-de-violon"],
    ["chou vert frisé","chou frisé"], 
    ["maïs","blé d'Inde","blé d'Espagne","blé de Turquie"],
    ["tétragone","épinard de la Nouvelle-Zélande","épinard d'été","tétragone cornue","tétragone étalée"],
    ["gombo","okra","ketmie comestible","ketmie-gombo","gombaud"],
    ["ciboulette","civette"],
    ["poivron","piment doux"],
    ["chile","chili","chilli"],
    ["chicorée de Vérone","chicorée rouge de Vérone"],
    ["betterave","betterave potagère"],
    ["carotte","carotte potagère"],
    ["céleri-rave","céleri tubéreux","céleri rave"],
    ["daïkon","radis oriental","radis blanc","radis blanc chinois","radis de Satzouma",
	"radis de Satsuma","radis du Japon","daikon","radis japonais"],
    ["navet","rabiole"],					
    ["courge poivrée","courgeron","courge gland"],
    ["courgette","zucchini"],
    ["pâtisson","bonnet d'électeur","bonnet-d'électeur","bonnet-de-prêtre",
	"bonnet de prêtre","patisson","pastisson"],
    ["dolique bulbeux","dolique tubéreux"],
    ["topinambour","artichaut de Jérusalem","poire de terre","artichaut du Canada",
	"artichaut d'hiver","artichaut des neiges","soleil vivace","topine","topinambourg"],
    ["patate douce","patate sucrée"],
    ["taro","colocase","colocasie"],
    ["cenelle","senelle"],
    ["amélanche","Saskatoon"],
    ["nèfle du Japon","bibace","bibasse ","loquat"],
    ["fruit du rosier","fruit d'églantier","cynorhodon","cynorrhodon"],
    ["cerise de terre","alkékenge"],
    ["mûre","mûre sauvage","mûron","mûre des haies"],
    ["chicouté","plaquebière","mûre des marais","chicoutai","chicoutée"],
    ["bearberry","raisin d'ours","cerise d'ours"],
    ["myrtille","airelle noire","brimbelle","raisin des bois","teint-vin","airelle"],
    ["canneberge","atoca","ataca","mocauque","airelle canneberge"],
    ["airelle","airelle rouge","airelle ponctuée","pomme de terre","graine rouge","berri"],
    ["groseille rouge à grappes","gadelle rouge"],
    ["cassis","groseille noire","gadelle noire"],
    ["groseille blanche à grappes","gadelle blanche"],
    ["baie de sureau","sureau"], 
    ["groseille à maquereau","groseille"],
    ["symphorine occidentale","graine de loup","symphorine du Nord-Ouest"],
    ["kaki","plaquemine","fruit de Sharon"],
    ["Shepherdie du Canada","Shépherdie du Canada","Shéferdie du Canada",
	"Shéferdie argentée","graines de bœuf"], 
    ["pitahaya","pitaya"],
    ["melon d'eau","pastèque"],
    ["raisin vert","raisin blanc"],
    ["jujube","datte chinoise"],
    ["cédrat","poncire","pomme du paradis"],
    ["pomélo","pomelo"],
    ["lime","citron vert","lime acide","limette acide","lime mexicaine","limette mexicaine"],
    ["longane","œil-de-dragon"],
    ["litchi","letchi"],
    ["fruit de la Passion","passiflore","fruit de la passion"],
    ["akée","akee","aki"],
    ["banane à cuire","banane plantain","plantain"],
    ["carambole","fruit étoile","pomme de Goa"],
    ["anone cœur de bœuf","cachiman cœur de bœuf","cœurde bœuf"],
    ["durion","dourian"],
    ["jaque","jacque"],
    ["mangoustan","mangouste"],
    ["langsat","duku"],
    ["ramboutan","litchi chevelu"],
    ["pomme-rose","pomme de rose","jamerose"],
    ["sapodilla","nèfle d'Amérique"],
    ["corossol épineux","corossol","anone","anone muriquée",
	"cachiman épineux","sapadille","Guanabana"],
    ["pomme cannelle","anone écailleuse","pomme-cannelle"],
    ["bar d'Amérique","loup de mer","bar rayé","bar de mer"],
    ["flet","flondre"],
    ["églefin","aiglefin"],
    ["flétan de l'Atlantique","flétan","flétan atlantique","flétan blanc"],
    ["grand brochet","brochet du Nord","grand brochet du Nord","brochet commun"],
    ["goberge","lieu noir"],
    ["plie canadienne","plie du Canada","balai de l'Atlantique","balai"],
    ["tilapia","perche d'Afrique"],
    ["tile","achigan","achigan de mer","doré de mer","tile de mer"],
    ["truite","ombles"],
    ["caviar","caviar noir"],
    ["calmar","encornet"],
    ["bifteck","biftèque"],
    ["hamburger","hambourgeois","burger"],
    ["dinde","dindon"],
    ["cerf de Virginie","chevreuil","cerf à queue blanche"],
    ["levure chimique","levure artificielle","poudre levante","poudre à lever"],
    ["hydrogénocarbonate de sodium","carbonate acide de sodium"],
    ["cassonade","sucre roux"],
    ["beurre d'arachide","pâte de cacahuète","pâte d'arachide","beurre de cacahouètes",
	"beurre de cacahuètes","pâte de cacahuètes","beurre d'arachides"],
    ["mozzarella","mozzarelle"],
    ["féta","feta"],
    ["yogourt","yaourt","yoghourt"],
    ["linguines","languettes"],
    ["tomate cerise","tomate cocktail"],
    ["tomate en grappe","tomate grappe"],
    ["nappa","chou nappa","chou napa","napa"],
    ["plumes rayées","penne rigate"],
    ["plumes","penne"],
    ["pâtes alimentaires","pâtes"],
    ["sauce de soja","sauce soja","sauce soya","sauce de soya"],
    ["poivre de Cayenne","piment de Cayenne","cayenne"],
    ["cari","curry"],
    ["garam masala","masala","massala","garam massala"],

    #non-standard usage
    ["morue charbonnière","morue noire"],
    ["barbue de rivière","barbue d'Amérique","barbue du Nord","barbue"],
    ["barbotte","barbotte brune"],
    ["morue","cabillaud"],
    ["lamproie","grande lamproie marine"],
    ["morue-lingue","abadèche lingue"],
    ["coryphène","dauphin","dorade tropicale"],
    ["baudroie","crapaud de mer"],
    ["hoplostète orange","hoplostète rouge","perche de mer néo-zélandaise"],
    ["goberge","colin","colin noir"],
    ["goberge de l'Alaska","morue du Pacifique occidental","morue des neiges","lieu de l'Alaska"],
    ["turbot de sable","turbot"],
    ["plie canadienne","plie blanche","faux flétan","flétan nain","carrelet"],
    ["sprat","esprot"],
    ["bar commun","corvine","loubine"],
    ["vivaneau","lutian"],
    ["scorpène","rascasse"],
    ["vivaneau rouge","vivaneau campèche"],
    ["merlu blanc","merlu du Sud"],
    ["crabe royal","crabe d'Alaska"],
    ["crabe des neiges","crabe araignée"],
    ["ormeau","abalone","oreille de mer"],
    ["mye","coque","palourde","quahog"],
    ["hydrogénocarbonate de sodium","bicarbonate de sodium","bicarbonate de soude","sel de Vichy"],
    ["grains de chocolat","brisures de chocolat","larmes de chocolat","pépites de chocolats"],
    ["crème 10% M.G.","crème à café"],
    ["crème 15% M.G.","crème de table"],
    ["crème 35% M.G.","crème à fouetter"],
    ["vermicelle","vermicelli","capellini"],

    #fautive/discouraged usages
    #["oignon vert","échalote"],   
    #["chile","piment du Chili"],
    #["poivron","piment"],
    ["germes de haricot","fèves germées","haricots germés","pousses de soja","pousse de soya"], 
    ["navet","navet blanc"],
    ["pommette","pomme sauvage"],
    ["amélanche","petite poire"],
    ["figue de Barbarie","poire cactus"],
    ["melon à cornes","Kiwano"],
    ["litchi","cerise de Chine"],
    ["barbue de rivière","poisson-chat"],
    ["églefin","haddeck"],
    ["baudroie","lotte"],
    #["turbot de sable","sole","plie"],
    #["plie canadienne","sole"],
    ["vivaneau","dorade"],
    ["espadon","poisson sabre","poisson épée"], 
    ["mye","clam"],
    ["poulpe","pieuvre"],
    ["levure chimique","poudre à pâte"],
    ["hydrogénocarbonate de sodium","soda à pâte"],
    ["beurre d'arachide","beurre de peanut","beurre de peanuts"],
    ["tomate en grappe","tomate sur vigne","tomate sur la vigne","tomate en vigne",
	"tomate en branches","tomate sur tige","tomate à tiges"],
    ]

# a dictionary for ambiguous words.
# key=ambiguous word, value=list of possible non-ambiguous terms
#
# Translators: if you have a word that has more than one food meaning
# in your language, you can add an entry as follow

# AMBIGUOUS = {
#              'word':['meaning1','meaning2','meaning3'],
#             }

AMBIGUOUS = {
    'chou-navet':['chou-navet blanc','rutabaga'],
    'chou navet':['chou-navet blanc','rutabaga'],
    'patate':['pomme de terre','patate douce']  
    }


# triplicates ITEM, KEY, SHOPPING CATEGORY
# These will be defaults.

# They should include whatever foods might be standard for your
# locale, with whatever sensible default categories you can think of
# (again, thinking of your locale, not simply translating what I've
# done).

# Items provided here will automatically be recognized and go onto the
# given category in a user's shopping list by default.

# Don't feel obligated to translate every item -- especially since not
# all items will be common for all locales. However, the more items
# you can put here, the more the user will get the sense that gourmet
# "knows" about foods that they enter.

# I generated the below list using the wikipedia entry on foods as my
# starting point. You may want to do something similar for your
# locale.  Also, if the syntax of the below is too complicated, you
# can send me a list of category headings and ingredients for your
# locale and I'll do the necessary formatting <Thomas_Hinkle@alumni.brown.edu>

INGREDIENT_DATA = [## l é g u m e s	   
		   ["luzerne","luzerne","fruits et légumes"],                 			#alfalfa sprouts
                   ["anis","anis","fruits et légumes"],                       			#anise
                   ["artichaut","artichaut","fruits et légumes"],				#artichoke
                   ["roquette","roquette","fruits et légumes"],					#arugula
                   ["asperges","asperges","fruits et légumes"],					#asparagus
                   ["aubergine","aubergine","fruits et légumes"],				#(same)
                   ["avocat","avocat","fruits et légumes"],					#avocado
                   ["haricots verts","haricots verts","fruits et légumes"],			#green beans
                   ["haricots azuki","haricots azuki","fruits et légumes"],			#azuki beans
                   ["germes de haricot","germes de haricot","fruits et légumes"],		#bean sprouts
                   ["haricots noirs","haricots noirs","fruits et légumes"],			#black beans
                   ["doliques à œil noir","doliques à œil noir","fruits et légumes"], #black-eyed peas
                   ["haricots borlotti","haricots borlotti","fruits et légumes"],		#borlotti beans (not sure)
                   ["gourganes","gourganes","fruits et légumes"],				#broad beans
                   ["pois chiche ou garbanzos","pois chiche ou garbanzos","fruits et légumes"],
			#chickpeas, garbanzos, or ceci beans
                   #["green beans","green beans","fruits et légumes"],				#(already in the list !)
                   ["haricots rouges","haricots rouges","fruits et légumes"],			#kidney beans
                   ["lentilles","lentilles","fruits et légumes"],				#lentils
                   ["haricots de Lima ou haricots jaunes","haricots de Lima ou haricots jaunes","fruits et légumes"],
			#lima bean or butter bean
                   ["haricots mungo","haricots mungo","fruits et légumes"],			#mung beans
                   ["petits haricots blancs","petits haricots blancs","fruits et légumes"],	#navy beans
                   ["haricots d'Espagne","haricots d'Espagne","fruits et légumes"],		#runner beans
                   ["soya","soya","fruits et légumes"],						#soybeans
                   ["pois","pois","fruits et légumes"],						#peas
                   #["snap peas","snap peas","fruits et légumes"],				#(unknown)
                   ["pak-choï","pak-choï","fruits et légumes"],					#bok choy
                   ["fruit à pain","fruit à pain","fruits et légumes"],				#breadfruit
                   ["brocofleur","brocofleur","fruits et légumes"],				#broccoflower
                   ["brocoli","brocoli","fruits et légumes"],					#broccoli
                   ["chou de Bruxelles","chou de Bruxelles","fruits et légumes"],		#brussels sprouts
                   ["chou pommé","chou pommé","fruits et légumes"],				#cabbage
                   #["calabrese","calabrese","fruits et légumes"],				#(unknown)
                   ["chou-fleur","chou-fleur","fruits et légumes"],				#cauliflower
                   ["céleri","céleri","fruits et légumes"],					#celery
                   ["bette à carde","bette à carde","fruits et légumes"],			#chard
                   ["coriandre","coriandre","fruits et légumes"],				#cilantro
                   ["feuilles de chou","feuilles de chou","fruits et légumes"],			#collard greens
                   ["mâche commune","mâche commune","fruits et légumes"],			#corn salad
                   ["endive","endive","fruits et légumes"],					#(same)
                   ["fenouil","fenouil","fruits et légumes"],					#fennel
                   ["crosses de fougère","crosses de fougère","fruits et légumes"],		#fiddleheads
                   ["chicorée frisée","chicorée frisée","fruits et légumes"],			#frisee
                   ["chou vert frisé","chou vert frisé","fruits et légumes"],			#kale
                   ["chou-rave","chou-rave","fruits et légumes"],				#kohlrabi
                   ["citronnelle","citronnelle","fruits et légumes"],				#lemon grass
                   ["laitue","laitue","fruits et légumes"],					#lettuce lactuca sativa
                   ["maïs","maïs","fruits et légumes"],						#corn
                   ["champignons","champignons","fruits et légumes"],				#mushrooms
                   ["feuilles de moutarde","feuilles de moutarde","fruits et légumes"],		#mustard greens
                   ["orties","orties","fruits et légumes"],					#nettles
                   ["tétragone","tétragone","fruits et légumes"],				#new zealand spinach
                   ["gombo","gombo","fruits et légumes"],					#okra
                   #["onion family","onion family","fruits et légumes"], 			#(title?)
                   ["ciboulette","ciboulette","fruits et légumes"],				#chives
                   ["ail","ail","fruits et légumes"],						#garlic
                   ["poireau","poireau","fruits et légumes"],					#leek allium porrum
                   ["oignon","oignon","fruits et légumes"],					#onion
                   ["échalote","échalote","fruits et légumes"],					#shallot
                   ["oignon vert","oignon vert","fruits et légumes"],				#scallion
                   ["persil","persil","fruits et légumes"],					#parsley
                   ["piment","piment","fruits et légumes"],					#pepper
                   ["poivron rouge","poivron rouge","fruits et légumes"],			#red bell pepper
                   ["poivron vert","poivron vert","fruits et légumes"],				#(added)
                   ["poivron jaune","poivron jaune","fruits et légumes"],			#(added)
                   ["chile","chile","fruits et légumes"],					#chilli pepper
                   ["piment Jalapeño","piment Jalapeño","fruits et légumes"],			#jalapeño pepper
                   ["piment habanero","piment habanero","fruits et légumes"],			#habanero pepper
                   ["chicorée de Vérone","chicorée de Vérone","fruits et légumes"],		#radicchio
                   ["rapini","rapini","fruits et légumes"],					#(same)
                   ["rhubarbe","rhubarbe","fruits et légumes"],					#rhubarb
                   #["root vegetables","root vegetables","fruits et légumes"],			#(title?)
                   ["betterave","betterave","fruits et légumes"],				#beet
                   ["carotte","carotte","fruits et légumes"],					#carrot
                   ["manioc","manioc","fruits et légumes"],					#cassava (manioc)
                   ["céleri-rave","céleri-rave","fruits et légumes"],				#celeriac
                   ["daïkon","daïkon","fruits et légumes"],					#daikon
                   #["fennel","fennel","fruits et légumes"],					#(already in the list !)
                   ["gingembre","gingembre","fruits et légumes"],				#ginger
                   ["panais","panais","fruits et légumes"],					#parsnip
                   ["radis","radis","fruits et légumes"],					#radish
                   ["rutabaga","rutabaga","fruits et légumes"],					#(same)
                   ["chou-navet blanc","chou-navet blanc","fruits et légumes"],			#(added)
                   ["navet","navet","fruits et légumes"],					#turnip
                   ["wasabi","wasabi","fruits et légumes"],					#(same)
                   #["white radish","white radish","fruits et légumes"],			#(daikon synonym)
                   ["chervis","chervis","fruits et légumes"],					#skirret
                   ["épinard","épinard","fruits et légumes"],					#spinach
                   ["courge poivrée","courge poivrée","fruits et légumes"],			#acorn squash
                   ["courge musquée","courge musquée","fruits et légumes"],			#butternut squash
                   ["courgette","courgette","fruits et légumes"],				#zucchini
                   ["concombre","concombre","fruits et légumes"],				#cucumber
                   #["gem squash","squash, gem","fruits et légumes"],				#(unknown)
                   ["pâtisson","pâtisson","fruits et légumes"],					#patty pans
                   ["citrouille","citrouille","fruits et légumes"],				#pumpkin
                   ["courge spaghetti","courge spaghetti","fruits et légumes"],			#spaghetti squash
                   #["tat soi","tat soi","fruits et légumes"],					#(unknown)
                   ["tomate","tomate","fruits et légumes"],					#tomato
                   ["dolique bulbeux","dolique bulbeux","fruits et légumes"],			#jicama	
                   ["topinambour","topinambour","fruits et légumes"],				#jerusalem artichoke
                   ["pomme de terre","pomme de terre","fruits et légumes"],			#potato
                   ["patate douce","patate douce","fruits et légumes"],				#sweet potato
                   ["taro","taro","fruits et légumes"],						#(same)
                   ["igname","igname","fruits et légumes"],					#yam
                   ["châtaigne d'eau","châtaigne d'eau","fruits et légumes"],			#water chestnut
                   ["cresson de fontaine","cresson de fontaine","fruits et légumes"],		#watercress
                   ## f r u i t s
                   ["pomme","pomme","fruits et légumes"],					#apple
                   ["pomme cortland","pomme cortland","fruits et légumes"],			#(added)
                   ["pomme délicieuse rouge","pomme délicieuse rouge","fruits et légumes"],	#(added)
                   ["pomme golden","pomme golden","fruits et légumes"],				#(added)
                   ["pomme granny smith","pomme granny smith","fruits et légumes"],		#(added)
                   ["pomme mcIntosh","pomme mcIntosh","fruits et légumes"],			#(added)
                   ["pomme lobo","pomme lobo","fruits et légumes"],				#(added)
                   ["pomme spartan","pomme spartan","fruits et légumes"],			#(added)
                   ["pomme melba","pomme melba","fruits et légumes"],				#(added)
                   ["pomme jerseymac","pomme jerseymac","fruits et légumes"],			#(added)
                   ["pomme fuji","pomme fuji","fruits et légumes"],				#(added)
                   ["pomme verte","pomme verte","fruits et légumes"],				#green apple
                   ["pommette","pommette","fruits et légumes"],					#crabapple
                   #["chokeberry","chokeberry","fruits et légumes"],				#(unknown)
                   ["cenelle","cenelle","fruits et légumes"],					#hawthorn
                   ["amélanche","amélanche","fruits et légumes"],				#juneberry
                   ["nèfle du Japon","nèfle du Japon","fruits et légumes"],			#loquat
                   ["nèfle","nèfle","fruits et légumes"],					#medlar
                   ["grenade","grenade","fruits et légumes"],					#pomegranate
                   ["coing","coing","fruits et légumes"],					#quince
                   ["sorbe","sorbe","fruits et légumes"],					#rowan
                   ["fruit du rosier","fruit du rosier","fruits et légumes"],			#rose hip
                   ["abricot","abricot","fruits et légumes"],					#apricot
                   ["cerise","cerise","fruits et légumes"],					#cherry
                   ["cerise de terre","cerise de terre","fruits et légumes"],			#(added)
		   ["griotte","griotte","fruits et légumes"],					#(added)
		   ["cerise montmorency","cerise montmorency","fruits et légumes"],		#(added)
                   ["prune","prune","fruits et légumes"],					#plum
                   ["prune reine-claude","prune reine-claude","fruits et légumes"],		#(added)
                   ["prune mirabelle","prune mirabelle","fruits et légumes"],			#(added)
                   ["prune quetsche","prune quetsche","fruits et légumes"],			#(added)
                   ["prune black beaut","prune black beaut","fruits et légumes"],		#(added)
                   ["prune friard","prune friard","fruits et légumes"],				#(added)
                   ["prune laroda","prune laroda","fruits et légumes"],				#(added)
                   ["prune santa rosa","prune santa rosa","fruits et légumes"],			#(added)
                   ["prune simka","prune simka","fruits et légumes"],				#(added)
                   ["pêche","pêche","fruits et légumes"],					#peach
                   ["nectarine","nectarine","fruits et légumes"],				#(same)
                   ["mûres","mûres","fruits et légumes"],					#blackberry
                   ["mûre de Boysen","mûre de Boysen","fruits et légumes"],			#boysenberry
                   ["framboise","framboise","fruits et légumes"],				#raspberry
                   ["framboise blanche","framboise blanche","fruits et légumes"], 		#(added)
                   ["framboise pourpre","framboise pourpre","fruits et légumes"], 		#(added) 
                   ["framboise orange","framboise orange","fruits et légumes"], 		#(added) 
                   ["framboise jaune","framboise jaune","fruits et légumes"], 			#(added)
                   ["chicouté","chicouté","fruits et légumes"],					#cloudberry
                   #["wineberry","wineberry","fruits et légumes"],				#(unknown)
                   ["busserole","busserole","fruits et légumes"],				#bearberry
                   ["myrtille","myrtille","fruits et légumes"],					#bilberry
                   ["bleuet","bleuet","fruits et légumes"],					#blueberry
                   ["canneberge","canneberge","fruits et légumes"],				#cranberry
                   #["huckleberry","huckleberry","fruits et légumes"],				#(myrtille synonym) 
                   ["airelle","airelle","fruits et légumes"],					#lingonberry
                   #["barberry ","barberry ","fruits et légumes"],				#(unknown)
                   ["groseille rouge à grappes","groseille rouge à grappes","fruits et légumes"],#red currant
                   ["cassis","cassis","fruits et légumes"],					#black currant
                   ["groseille blanche à grappes","groseille blanche à grappes","fruits et légumes"],#white currant
                   ["baie de sureau","baie de sureau","fruits et légumes"],			#elderberry
                   ["groseille à maquereau","groseille à maquereau","fruits et légumes"],	#gooseberry
                   #["nannyberry","nannyberry","fruits et légumes"],				#(unknown)
                   ["argouse","argouse","fruits et légumes"],					#sea-buckthorn
                   ["symphorine occidentale"," symphorine occidentale","fruits et légumes"], 	#wolfberry
                   ["camarine","camarine","fruits et légumes"],					#crowberry
                   #["mulberry","mulberry","fruits et légumes"],				#(blackberry synonym)
                   #["goumi","goumi","fruits et légumes"],					#(unknown)
                   ["kiwi","kiwi","fruits et légumes"],						#kiwi fruit
                   ["kaki","kaki","fruits et légumes"],						#persimmon
                   ["Shepherdie du Canada","Shepherdie du Canada","fruits et légumes"],		#buffaloberry
                   ["asimine","asimine","fruits et légumes"],					#pawpaw
                   #["american persimmon","american persimmon","fruits et légumes"],		#(unknown)
                   ["figue de Barbarie","figue de Barbarie","fruits et légumes"],		#prickly pear
                   #["saguaro","saguaro ","fruits et légumes"],					#(unknown)
                   ["pitahaya","pitahaya","fruits et légumes"],					#pitaya
                   ["cantaloup","cantaloup","fruits et légumes"],				#cantaloupe
                   ["melon miel Honeydew","melon miel Honeydew","fruits et légumes"],		#honeydew
		   ["melon brodé","melon brodé","fruits et légumes"],				#(added)
		   ["melon à cornes","melon à cornes","fruits et légumes"],			#(added)
		   ["melon Casaba","melon Casaba","fruits et légumes"],				#(added)
		   ["melon Santa Claus","melon Santa Claus","fruits et légumes"],		#(added)
		   #["sunberry","sunberry","fruits et légumes"],				#(unknown)
                   ["melon d'eau","","fruits et légumes"],					#watermelon
                   ["fraise","fraise","fruits et légumes"],					#strawberry
                   ["angélique","angélique","fruits et légumes"],				#angelica
                   #["rhubarb","rhubarb","fruits et légumes"],					#(already in the list !)
                   ["figue","figue","fruits et légumes"],					#fig
                   ["raisin","raisin","fruits et légumes"],					#grape
                   ["raisin vert","raisin vert","fruits et légumes"],				#(added)
                   ["raisin rouge","raisin rouge","fruits et légumes"],				#(added)
                   ["jujube","jujube","fruits et légumes"],					#(same)
                   ["mûre noir","mûre noir","fruits et légumes"],				#black mulberry
                   #["pomegranate","pomegranate","fruits et légumes"],				#(already in the list !)
                   ["datte","datte","fruits et légumes"],					#date
                   ["cédrat","cédrat","fruits et légumes"],					#citron
                   ["pamplemousse","pamplemousse","fruits et légumes"],				#grapefruit
                   ["pomélo","pomélo","fruits et légumes"],					#pommelo
                   ["lime","lime","fruits et légumes"],						#key lime
                   ["kumquat","kumquat","fruits et légumes"],					#(same)
                   ["citron","citron","fruits et légumes"],					#lemon
                   ["lime","lime","fruits et légumes"],						#(key lime synonym)
                   ["mandarine","mandarine","fruits et légumes"],				#mandarin
                   ["clémentine","clémentine","fruits et légumes"],				#clementine
                   ["tangelo","tangelo","fruits et légumes"],					#(same)
                   ["tangerine","tangerine","fruits et légumes"],				#(same)
                   ["orange","orange","fruits et légumes"],					#(same)
                   ["ugli","ugli","fruits et légumes"],						#ugli fruit
                   ["goyave","goyave","fruits et légumes"],					#guava
                   ["longane","longane","fruits et légumes"],					#longane
                   ["litchi","litchi","fruits et légumes"],					#lychee
                   ["fruit de la Passion","fruit de la Passion","fruits et légumes"],		#passion fruit
                   ["feijoa","feijoa","fruits et légumes"],					#(same)
                   ["akée","akée","fruits et légumes"],						#akee 
                   ["banane","banane","fruits et légumes"],					#banana
                   ["banane cavendish","banane cavendish","fruits et légumes"],			#(added)
                   ["banane gros michel","banane gros michel","fruits et légumes"],		#(added)
                   ["banane à cuire"," banane à cuire","fruits et légumes"],			#plantain
                   #["breadfruit","breadfruit","fruits et légumes"],				#(already in the list !)
                   #["camucamu","camucamu","fruits et légumes"],				#(unknown)
                   ["carambole","carambole","fruits et légumes"],				#star fruit
                   #["cempedak","cempedak","fruits et légumes"],				#(unknown)
                   ["chérimole","chérimole","fruits et légumes"],				#cherimoya
                   ["noix de coco","noix de coco","fruits et légumes"],				#coconut
                   ["anone cœur de bœuf","anone cœur de bœuf","fruits et légumes"],		#custard apple
                   #["dragonfruit","dragonfruit","fruits et légumes"],				#(unknown)
                   ["durion","durion","fruits et légumes"],					#durian
                   #["guarana","guarana","fruits et légumes"],					#(unknown)
                   ["jaque","jaque","fruits et légumes"],					#jackfruit
                   #["keppel fruit","keppel fruit","fruits et légumes"],			#(unknown)
                   ["langsat","langsat","fruits et légumes"],					#(same)
                   #["velvet persimmon","velvet persimmon","fruits et légumes"],		#(unknown)
                   ["abricot de Saint-Domingue","abricot de Saint-Domingue","fruits et légumes"],#mamey sapote(apple)?
                   ["sapote","sapote","fruits et légumes"],					#mamey sapote(apple)?
                   #["mamoncillo","mamoncillo","fruits et légumes"],				#(unknown)
                   ["mangue","mangue","fruits et légumes"],					#mango
                   ["mangoustan","mangoustan","fruits et légumes"],				#mangosteen
                   #["marang","marang","fruits et légumes"],					#(unknown)
                   ["papaye","papaye","fruits et légumes"],					#papaya
                   #["peanut butter fruit","peanut butter fruit","fruits et légumes"],		#(unknown)
                   ["ananas","ananas","fruits et légumes"],					#pineapple
                   #["poha","poha","fruits et légumes"],					#(unknown)
                   ["ramboutan","ramboutan","fruits et légumes"],				#rambutan
                   ["pomme-rose","pomme-rose","fruits et légumes"],				#rose apple
                   ["salak","salak","fruits et légumes"],					#(same)
                   ["sapotille","sapotille","fruits et légumes"],				#sapodilla
                   ["corossol épineux","corossol épineux","fruits et légumes"],			#soursop
                   ["pomme cannelle","pomme cannelle","fruits et légumes"],			#sugar apple
                   ["tamarin","tamarin","fruits et légumes"],					#tamarind
                   #["acorn squash","squash, acorn","fruits et légumes"],			#(already in the list !)
                   #["apple","apple","fruits et légumes"],					#(already in the list !)
                   #["arugula","arugula","fruits et légumes"],					#(already in the list !)
                   #["avocado","avocado","fruits et légumes"],					#(already in the list !)
                   #["basil, thai fresh","basil, fresh, thai","fruits et légumes"],		#(modifier?)
                   #["bean sprouts","bean sprouts","fruits et légumes"],			#(already in the list !)
                   #["broccoli","broccoli","fruits et légumes"],				#(already in the list !)
                   #["carrot","carrot","fruits et légumes"],					#(already in the list !)
                   #["celery","celery","fruits et légumes"],					#(already in the list !)
                   ["tomate cerise","tomate cerise","fruits et légumes"],			#cherry tomato
                   #["chiles, dried red","chiles, red, dried","fruits et légumes"],		#(modifier?)
                   #["cilantro stems","cilantro stems","fruits et légumes"],			#(modifier?)
                   #["cucumber","cucumber","fruits et légumes"],				#(already in the list !)
                   #["curly endive","endive, curly","fruits et légumes"],			#(same as frisee?)
                   #["curly lettuce leaf","lettuce, curly leaf","fruits et légumes"],		#(unknown)
                   #["fresh basil","basil, fresh","fruits et légumes"],				#(modifier?)
                   #["fresh cilantro","cilantro, fresh","fruits et légumes"],			#(modifier?)
                   #["fresh ginger","ginger, fresh","fruits et légumes"],			#(modifier?)
                   ["galanga","galanga","fruits et légumes"],					#(same)
                   #["garlic","garlic","fruits et légumes"],					#(already in the list !)
                   ["tomate en grappe","tomate en grappe","fruits et légumes"],			#grape tomato
                   #["leek","leek","fruits et légumes"],					#(already in the list !)
                   #["lemon grass","lemon grass","fruits et légumes"],				#(already in the list !)
                   ["jus de citron","jus de citron","fruits et légumes"],			#lemon juice
                   ["jus de lime","jus de lime","fruits et légumes"],				#lime juice
                   #["lime leaves","lime leaves","fruits et légumes"],				#(modifier)
                   #["lime","lime","fruits et légumes"],					#(already in the list !)
                   ["nappa","nappa","fruits et légumes"],					#nappa cabbage
                   ["olives","olives","fruits et légumes"],					#(same)
                   ["olives vertes","olives vertes","fruits et légumes"],			#(added)
                   ["olives noirs","olives noirs","fruits et légumes"],				#(added)
                   ["jus d'orange","jus d'orange","fruits et légumes"],				#orange juice
                   #["parsley","parsley","fruits et légumes"],					#(already in the list !)
                   #["portobello mushroom","mushroom, portobello","fruits et légumes"],		#(unknown)
                   #["potato","potato","fruits et légumes"],					#(already in the list !)
                   #["radicchio","radicchio","fruits et légumes"],				#(already in the list !)
                   ["oignon rouge","oignon rouge","fruits et légumes"],				#red onion
                   #["red potato-skinned","potato, red-skinned","fruits et légumes"],		#(unknown)
                   #["roasted peanuts","peanuts, roasted","fruits et légumes"],			#(modifier?)
                   #["russet potato","potato, russet","fruits et légumes"],			#(unknown)
                   #["salad greens","salad greens","fruits et légumes"],			#(unknown)
                   #["scallion","scallion","fruits et légumes"],				#(already in the list !)
                   #["spinach","spinach","fruits et légumes"],					#(already in the list !)
                   ["courge","courge","fruits et légumes"],					#squash
                   #["tahitian squash","squash, tahitian","fruits et légumes"],			#(unknown)
                   #["tomato","tomato","fruits et légumes"],					#(already in the list !)
                   ["oignon blanc","oignon blanc","fruits et légumes"],				#white onion
                   ["oignon jaune","oignon jaune","fruits et légumes"],				#yellow onion
                   #["zucchini","zucchini","fruits et légumes"],				#(already in the list !)
                   #["zuchini","zuchini","fruits et légumes"],					#(already in the list !)
                   #["mushroom","mushroom","fruits et légumes"],				#(already in the list !)
                   #["shallot","shallot","fruits et légumes"],					#(already in the list !)
		   #["bell red pepper","bell pepper, red","fruits et légumes"],			#(already in the list !)
                   ## f r u i t s   d e   m e r 
                   ["anchois","anchois","fruits de mer"],					#anchovy
                   ["achigan","achigan","fruits de mer"],					#bass
                   ["bar d'Amérique","bar d'Amérique","fruits de mer"],				#striped bass
                   ["morue charbonnière","morue charbonnière","fruits de mer"],			#black cod
                   ["poisson globe","poisson globe","fruits de mer"],				#blowfish
                   ["barbue de rivière","barbue de rivière","fruits de mer"],			#catfish
		   ["barbotte","barbotte","fruits de mer"],					#(added)
                   ["morue","morue","fruits de mer"],						#cod
                   ["lamproie","lamproie","fruits de mer"],					#eel
                   ["flet","flet","fruits de mer"],						#flounder
                   ["églefin","églefin","fruits de mer"],					#haddock
                   ["flétan de l'Atlantique","flétan de l'Atlantique","fruits de mer"],		#halibut
                   ["morue-lingue","morue-lingue","fruits de mer"],				#lingcod
                   ["coryphène","coryphène","fruits de mer"],					#mahi mahi
                   ["baudroie","baudroie","fruits de mer"],					#monkfish
                   ["hoplostète orange","hoplostète orange","fruits de mer"],			#orange roughy
                   #["chilean sea bass","chilean sea bass","fruits de mer"],			#(unknown)
                   ["brochet","brochet","fruits de mer"],					#pike
		   ["grand brochet","grand brochet","fruits de mer"],				#(added)
                   ["goberge","goberge","fruits de mer"],					#pollock
                   ["goberge de l'Alaska","goberge de l'Alaska","fruits de mer"],		#(added)
                   ["turbot de sable","turbot de sable","fruits de mer"],			#sanddab
                   ["plie canadienne","plie canadienne","fruits de mer"],			#(added)
                   ["sardine","sardine","fruits de mer"],					#(same)
                   ["sprat","sprat","fruits de mer"],						#(added)
                   ["saumon","saumon","fruits de mer"],						#salmon
                   ["bar commun","bar commun","fruits de mer"],					#sea bass
                   ["requin","requin","fruits de mer"],						#shark
                   ["vivaneau","vivaneau","fruits de mer"],					#snapper
                   ["scorpène","scorpène","fruits de mer"],					#rockfish
                   #["rock cod","rock cod","fruits de mer"],					#(rockfish synonym?)
                   ["sébaste aux yeux jaunes","sébaste aux yeux jaunes","fruits de mer"],	#pacific snapper
                   ["vivaneau rouge","vivaneau rouge","fruits de mer"],				#red snapper
                   ["sole","sole","fruits de mer"],						#(same)
                   ["esturgeon","esturgeon","fruits de mer"],					#sturgeon
                   ["surimi","surimi","fruits de mer"],						#(same)
                   ["espadon","espadon","fruits de mer"],					#swordfish
                   ["tilapia","tilapia","fruits de mer"],					#(same)
                   ["tile","tile","fruits de mer"],						#tilefish
                   ["truite","truite","fruits de mer"],						#trout
                   ["thon","thon","fruits de mer"],						#tuna
                   ["poisson maigre","poisson maigre","fruits de mer"],				#whitefish
                   ["merlu blanc","merlu blanc","fruits de mer"],				#whiting
                   #["roe","roe","fruits de mer"],						#(title?)
                   ["caviar","caviar","fruits de mer"],						#(same)
                   ["œufs de saumon","œufs de saumon","fruits de mer"],				#salmon roe
                   ["crabe","crabe","fruits de mer"],						#crab
                   ["crabe dormeur","crabe dormeur","fruits de mer"],				#dungeness crab
                   ["crabe royal","crabe royale","fruits de mer"],				#king crab
                   ["crabe des neiges","crabe des neiges","fruits de mer"],			#snow crab
                   ["écrevisse","écrevisse","fruits de mer"],					#écrevisse
                   ["homard","homard","fruits de mer"],						#lobster
                   ["crevette","crevette","fruits de mer"],					#shrimp
                   ["crevettes roses","crevettes roses","fruits de mer"],			#prawns
                   ["ormeau","ormeau","fruits de mer"],						#abalone
                   ["mye","mye","fruits de mer"],						#clam
                   ["moules","moules","fruits de mer"],						#mussel
                   ["poulpe","poulpe","fruits de mer"],						#octopus
                   ["huître","huître","fruits de mer"],						#oyster
                   ["escargot","escargot","fruits de mer"],					#snail
                   ["calmar","calmar","fruits de mer"],						#squid
                   ["pétoncle","pétoncle","fruits de mer"],					#scallop
                   ## v i a n d e s
                   ["bacon","bacon","viandes"],							#(same)
                   ["chorizo","chorizo","viandes"],						#(same)
                   #["fuet","fuet","viandes"],							#(unknown)
                   ["salami","salami","viandes"],						#(same)
                   ["jambon","jambon","viandes"],						#ham
                   ["mouton","mouton","viandes"],						#mutton
                   ["agneau","agneau","viandes"],						#lamb
                   ["veau","veau","viandes"],							#veal
                   ["bifteck","bifteck","viandes"],						#steak
                   ["hamburger","hamburger","viandes"],						#(same)
                   ["rôti de bœuf","rôti de bœuf","viandes"],					#roast beef
                   ["poulet","poulet","viandes"],						#chicken
                   ["dinde","dinde","viandes"],							#turkey
                   ["canard","canard","viandes"],						#duck
                   ["oie","oie","viandes"],							#goose
                   ["sanglier","sanglier","viandes"],						#(added)
		   ["bœuf","bœuf","viandes"],							#beef
		   ["bœuf haché","bœuf, haché","viandes"],					#ground beef
		   ["cerf","cerf","viandes"],							#(added)
		   ["lapin","lapin","viandes"],							#(added)
                   ["poitrine de poulet","poulet, poitrine","viandes"],				#chicken breast
                   ["poulet entier","poulet, entier","viandes"],				#whole chicken
                   ["patte de poulet","poulet, patte","viandes"],				#chicken leg
                   ["porc","porc","viandes"],							#pork
		   ## Q u é b e c ' s   l o c a l e
		   ["beurre d'érable","beurre d'érable","épicerie sucrée"],			#(added)
		   ["sirop d'érable","sirop d'érable","épicerie sucrée"],			#(added)
		   ["tire d'érable","tire d'érable","épicerie sucrée"],				#(added)
		   ["tire à l'érable","tire à l'érable","épicerie sucrée"],			#(added)
                   ["caribou","caribou","viandes"],						#(added)
		   ["cerf de Virginie","cerf de Virginie","viandes"],				#(added)
                   ["relish","relish","condiments"],						#(added)
		   ## é p i c e r i e
                   ["farine tout usage","farine tout usage","épicerie"],			#all flour purpose
                   ["levure chimique","levure chimique","épicerie"],				#baking powder
                   ["hydrogénocarbonate de sodium","hydrogénocarbonate de sodium","épicerie"],	#baking soda
                   ["cassonade","cassonade","épicerie"],					#brown sugar
                   ["grains de chocolat","grains de chocolat","épicerie"],			#chocolate chips
                   #["dark sugar brown","sugar, dark brown","épicerie"],			#(unknown)
                   ["miel","miel","épicerie"],							#honey
                   #["light sugar brown","sugar, light brown","épicerie"],			#(unknown)
                   ["sel","sel","épicerie"],							#salt
                   ["gros sel","sel, gros","épicerie"],						#(added)
                   ["sel de mer","sel de mer","épicerie"],					#(added)
                   #["shredded coconut","coconut, shredded","épicerie"],			#(modifier?)
                   ["extrait de vanille","vanille, extrait de","épicerie"],			#vanilla extract
                   ["noix","noix","épicerie"],							#walnut
                   ["sucre blanc","sucre blanc","épicerie"],					#white sugar
                   ["farine de maïs jaune","farine de maïs jaune","épicerie"],			#yellow cornmeal
                   ["flocons d'avoine","flocons d'avoine","épicerie"],				#rolled oats
                   ["riz","riz","épicerie"],							#rice
                   ## p a i n
                   ["croûtons","croûtons","pain"],						#croutons
                   ["pain au levain","pain au levain","pain"],					#sourdough bread
		   ## c o n d i m e n t s
                   ["moutarde de Dijon","moutarde de Dijon","condiments"],			#dijon mustard
                   ["ketchup","ketchup","condiments"],						#(added)
                   ["mayonnaise","mayonnaise","condiments"],					#(same)
		   ## t a r t i n a d e s
                   ["beurre d'arachide","beurre d'arachide","tartinades"],			#peanut butter
		   ## é p i c e s
                   #["black ground pepper","black pepper, ground","épices"],			#(modifier?)
                   ["poivre de cayenne","poivre de cayenne","épices"],				#cayenne
                   #["chili powder","chili powder","épices"],					#(modifier?)
                   #["coriander seeds","coriander, seeds","épices"],				#(modifier?)
                   ["cari","cari","épices"],							#curry powder
                   ["garam masala","garam masala","épices"],					#(same)
                   #["ground cinnamon","cinnamon, ground","épices"],				#(modifier?)
                   #["ground coriander","coriander, ground","épices"],				#(modifier?)
                   #["ground cumin","cumin, ground","épices"],					#(modifier?)
                   #["nutmeg","nutmeg","épices"],						#(modifier?)
                   ["paprika","paprika","épices"],						#(same)
                   #["powdered ginger","ginger, powdered","épices"],				#(modifier?)
                   #["seeds ajowan","ajowan, seeds","épices"],					#(modifier?)
                   #["seeds cumin","cumin, seeds","épices"],					#(modifier?)
                   #["seeds mustard","mustard, seeds","épices"],				#(modifier?)
                   #["star anise","star anise","épices"],					#(modifier?)
                   #["stick cinnamon","cinnamon, stick","épices"],				#(modifier?)
                   ["curcuma","curcuma","épices"],						#turmeric
                   #["monkfish","monkfish","fruits de mer"],					#(already in the list !)
                   #["salmon","salmon","fruits de mer"],					#(already in the list !)
                   #["whole rock cod or snapper","whole rock cod or snapper","fruits de mer"],  #(unknown)
		   ## i n t e r n a t i o n a l
                   ["lait de coco","lait de coco","international"],				#coconut milk
                   #["dried shrimp","shrimp, dried","international"],				#(modifier?)
                   #["fish sauce","fish sauce","international"],				#(unknown)
                   #["flat rice flour noodles","flat rice flour noodles","international"],	#(unknown)
                   #["green canned chiles","green chiles, canned","international"],		#(unknown)
                   #["green curry paste","green curry paste","international"],			#(unknown)
                   ["vinaigre de riz","vinaigre de riz","international"],			#rice vinegar
                   #["roasted chili paste","roasted chili paste","international"],		#(unknown)
                   ["salsa","salsa","international"],						#(same)
                   ["graine de sésame","graine de sésame","international"],			#sesame seeds
                   ["pâte de crevettes","pâte de crevettes","international"],			#shrimp paste
                   ["sauce de soja","sauce de soja","international"],				#soy sauce
                   #["tamarind juice","tamarind juice","international"],			#(unknown)
                   #["tamarind water","tamarind water","international"],			#(unknown)
                   ["couscous","couscous","international"],					#(same)
		   ## p â t e s
                   ["pâtes à lasagne","pâtes à lasagne","pâtes"],			        #lasagna pasta noodles
                   ["linguines","linguines","pâtes"],						#linguine pasta
                   ["pâtes alimentaires","pâtes alimentaires","pâtes"],				#pasta
                   ["plumes rayées","plumes rayées","pâtes"],					#penne pasta
                   ["plumes","plumes","pâtes"],							#(added)
                   #["peppered linguini","linguini, peppered","pâtes"],				#(modifier?)
                   ["coquilles","coquilles","pâtes"],						#shells pasta
                   ["coquilles petites","coquilles petites","pâtes"],				#(added)
                   ["coquilles géantes","coquilles géantes","pâtes"],				#(added)
                   ["spaghettis","spaghettis","pâtes"],						#(same)
		   ["vermicelles","vermicelles","pâtes"],					#(added)
		   ## p r o d u i t s   l a i t i e r s
                   ["beurre","beurre","produits laitiers"],					#butter
                   ["margarine","margarine","produits laitiers"],				#(added)	
                   ["œuf","œuf","produits laitiers"],						#egg
                   ["œufs","œufs","produits laitiers"],					        #eggs
                   #["flour tortillas","tortillas, flour","produits laitiers"],			#(unknown)
                   ["lait","lait","produits laitiers"],						#milk
                   ["crème sure","crème sure","produits laitiers"],				#sour cream
		   ["crème","crème","produits laitiers"],					#(added)
		   ["crème 10% M.G.","crème, 10% M.G.","produits laitiers"],			#(added)
		   ["crème 15% M.G.","crème, 15% M.G.","produits laitiers"],			#(added)
		   ["crème 35% M.G.","crème, 35% M.G.","produits laitiers"],			#(added)
                   ["yogourt","yogourt","produits laitiers"],					#yogurt
		   ## f r o m a g e s
                   ["cheddar","fromage, cheddar","fromages"],					#cheddar cheese
                   ["cottage","fromage, cottage","fromages"],					#cottage cheese
                   ["féta","fromage, féta","fromages"],						#feta cheese
                   ["fromage de chèvre blanc","fromage de chèvre blanc","fromages"],		#fresh cheese white goat
                   ["jack","fromage, jack","fromages"],						#jack cheese
                   ["mozzarella","fromage, mozzarella","fromages"],				#mozzarella cheese
                   ["parmesan","fromage, parmesan","fromages"],					#parmesan cheese
                   ["provolone","fromage, provolone","fromages"],				#provolone cheese
                   ["ricotta","fromage, ricotta","fromages"],					#ricotta cheese
                   ["Gouda fumé","fromage, Gouda fumé","fromages"],				#smoked cheese Gouda
		   ## s o u p e s   &   s a u c e s
                   ["soupe de tomates","soupe, tomate","soupes & sauces"],			#tomato sauce
                   ["bouillon de légumes","bouillon, légumes","soupes & sauces"],		#vegetable broth
		   ## h u i l e s   &   v i n a i g r e s
                   ["vinaigre balsamique","vinaigre balsamique","huiles & vinaigres"],		#balsamic vinegar
                   ["huile de maïs","huile de maïs","huiles & vinaigres"],			#corn oil
                   ["huile d'olive","huile d'olive","huiles & vinaigres"],			#olive oil
                   ["huile de sésame","huile de sésame","huiles & vinaigres"],			#sesame oil
                   ["huile végétale","huile végétale","huiles & vinaigres"],			#vegetable oil
		   ["huile de soja","huile de soja","huiles & vinaigres"],			#(added)
		   ## v i n   &   s p i r i t u e u x
                   ["vin blanc","vin, blanc","vin & spiritueux"],				#white wine
                   ["vin rouge","vin, rouge","vin & spiritueux"],				#(added)
                   ## t h i n g   y o u   s h o u l d   h a v e   a t   h o m e 
                   ["eau","eau",""]								#water
                   ]

# THESE ARE STANDARD UNIT CONVERSIONS. You can simply translate unit names where
# you know them. Eliminate entries that are untranslatable or don't exist in your
# locale. And please add any additional units that you know of.
# Each unit is of the following format:
# ("unit1","unit2"):conversion_factor, where unit1 contains conversion_factor X unit2
# For example: 1 cup has 16 tablespoons.
CONVERTER_TABLE = {
    ("c.", "tbs."):16,
    ("lb.", "oz."):16,
    ("tbs.", "tsp."):3,
    ("pt.", "c."):2,
    ("qt.", "c."):4,
    ("gallon", "qt."):4,
    ("l", "qt."):1.057,
    ("l", "ml"):1000,
    ("l", "cl"):100,
    ("l", "dl"):10,
    ("oz.", "g"):28.35,
    ("kg", "g"):1000,
    ("g", "mg"):1000,
    ("tsp.", "drop"):76,
    ("oz.", "dram"):16,
    ("dram", "grains"):27.34375,
    ("peck", "gallon"):2,
    ("bucket", "peck"):2,
    ("bushel", "bucket"):2,
    ("lb.", "grains"):7000}

### from translator : see note further... 

# # THESE ARE STANDARD UNIT CONVERSIONS. You can simply translate unit names where
# # you know them. Eliminate entries that are untranslatable or don"t exist in your
# # locale. And please add any additional units that you know of.
# # Each unit is of the following format:
# # ("unit1","unit2"):conversion_factor, where unit1 contains conversion_factor X unit2
# # For example: 1 cup has 16 tablespoons.
# CONVERTER_TABLE = {
#     ("tasse","c. à table"):16,
#     ("lb","oz"):16,
#     ("c. à table","c. à thé"):3,
#     ("chop","tasse"):2,
#     ("pte","tasse"):4,
#     ("gallon","pte"):4,
#     ("l","pte"):1.057,
#     ("l","ml"):1000,
#     ("l","cl"):100,
#     ("l","dl"):10,
#     ("oz","g"):28.35,
#     ("kg","g"):1000,
#     ("g","mg"):1000,
#     ("c. à thé","goutte"):76,
#     ("oz","dram"):16
#    }

# DENSITIES of common foods. This allows us to convert between mass and volume.
# Translators: You may be best off translating the food names below, since lists
# of food densities can be hard to come by!
DENSITY_TABLE={
    "eau":1,				#water
    "jus de raisins":1.03,		#juice, grape
    "bouillon de légumes":1,		#vegetable broth
    "bouillon de poulet":1,		#broth, chicken
    "lait":1.029,			#milk
    "lait entier":1.029,		#milk, whole
    "lait écrémé":1.033,		#milk, skim
    "lait 2%":1.031,			#milk, 2%
    "lait 1%":1.03,			#milk, 1%
    "lait de noix de coco":0.875,	#coconut milk
    "babeurre":1.03,			#buttermilk
    "crème riche":0.994,		#heavy cream
    "crème légère":1.012,		#light cream
    "crème 11,5%":1.025,		#half-and-half
    "miel":1.420,			#honey
    "sucre blanc":1.550,		#sugar, white
    "sel":2.165,			#salt
    "beurre":0.911,			#butter
    "huile végétale":0.88,		#oil, vegetable
    "huile d'olive":0.88,		#oil, olive
    "huile de maïs":0.88,		#oil, corn
    "huile de sésame":0.88,		#oil, sesame
    "farine tout usage": 0.6,		#flour, all purpose
    "farine de blé entier": 0.6,	#flour, whole wheat
    "fécule de maïs": 0.6,		#corn starch
    "sucre en poudre": 0.6,		#sugar, powdered
    "sucre glace": 0.6			#sugar, confectioners
            }

### ORIGINAL TABLES FROM ENGLISH

# THESE ARE STANDARD UNIT CONVERSIONS. You can simply translate unit names where
# you know them. Eliminate entries that are untranslatable or don't exist in your
# locale. And please add any additional units that you know of.
# Each unit is of the following format:
# ("unit1","unit2"):conversion_factor, where unit1 contains conversion_factor X unit2
# For example: 1 cup has 16 tablespoons.
CONVERTER_TABLE = {
    ("c.", "tbs."):16,
    ("lb.", "oz."):16,
    ("tbs.", "tsp."):3,
    ("pt.", "c."):2,
    ("qt.", "c."):4,
    ("gallon", "qt."):4,
    ("l", "qt."):1.057,
    ("l", "ml"):1000,
    ("l", "cl"):100,
    ("l", "dl"):10,
    ("oz.", "g"):28.35,
    ("kg", "g"):1000,
    ("g", "mg"):1000,
    ("tsp.", "drop"):76,
    ("oz.", "dram"):16,
    ("dram", "grains"):27.34375,
    ("peck", "gallon"):2,
    ("bucket", "peck"):2,
    ("bushel", "bucket"):2,
    ("lb.", "grains"):7000}

# Standard unit names and alternate unit names that might appear.  For
# example: "c." is our standard abbreviation for cup.  "cup","c." or
# "cups" might appear in a recipe we are importing.  Each item of this
# list looks like this:
#
# ["standard", ["alternate1","alternate2","alternate3",...]]
#
# The first item should be the preferred abbreviation
# The second item should be the full name of the unit
# e.g. ["c.", ["cup",...]]
#
UNITS = [["bucket" , ["bucket", "buckets", "bckt."]],
         ["peck", ["peck", "pecks"]],
         ["bushel", ["bushel", "bushels", "bsh.", "bu.", "bu", "bsh", "bshl", "bshl."]],
         ["grains", ["grain", "grains"]],
         ["dram", ["dram", "drams"]],
         ["drop",["drop"]],
         ["tsp.", ["teaspoon","tsp", "tsp.","tea spoon", "tsps.", "teaspoons", "tea spoons", "Teaspoon", "Teaspoons","t","Ts.","Tsp.","Tsp"]],
         ["tbs.", ["tablespoon","tbs", "tbsp", "tbs.", "tbsp.", "table spoon", "tbsps.", "tablespoons", "Tablespoon", "T", "Tbs.", "Tbsp", "Tbsp."]],
         ["lb.", [ "pound", "lb","lb.", "lbs.", "pounds"]],
         ["oz.", [ "ounce", "oz","ounces", "oz."]],
         ["c.", ["cup", "c.", "cups"]],
         ["qt.", ["quart", "qt.", "quarts"]],
         ["pt.", ["pint", "pt.", "pints"]],
         ["gallon", ["gallon", "gallons","gal."]],
         ["ml", ["mililiter","ml", "ml.","mililiters"]],
         ["cl", ["centiliter","cl", "cl.", "centiliters"]],
         ["dl", ["deciliter","dl", "dl.","deciliters"]],
         ["l", ["liter", "l.", "lit.", "liters"]],
         ["g", ["grams", "gram", "g."]],
         ["mg", ["miligram", "mg.", "mg", "miligrams"]],
         ["kg", ["kilogram","kg.", "kg",  "kilograms"]]
         ]

METRIC_RANGE = (1,999)

# The following sets up unit groups. Users will be able to turn
# these on or off (American users, for example, would likely turn
# off metric units, since we don't use them).
# (User choice not implemented yet)
UNIT_GROUPS = {
    'metric mass':[('mg',METRIC_RANGE),
                   ('g',METRIC_RANGE),
                   ('kg',(1,None))],
    'metric volume':[('ml',METRIC_RANGE),
                     ('cl',(1,99)),
                     ('dl',(1,9)),
                     ('l',(1,None)),],
    'imperial weight':[('grains',(0,27)),
                       ('dram',(0.5,15)),
                       ('oz.',(0.25,32)),
                       ('lb.',(0.25,None)),
                       ],
    'imperial volume':[('drop',(0,3)),
                       ('tsp.',(0.125,3)),
                       ('tbs.',(1,4)),
                       ('c.',(0.25,6)),
                       ('pt.',(1,1)),
                       ('qt.',(1,3)),
                       ('gallon',(1,None)),
                       ('peck',(1,2)),
                       ('bucket',(1,2)),
                       ('bushel',(1,None))]
    }

# The units here need to correspond to the standard unit names defined
# above in UNITS
CROSS_UNIT_TABLE = {
    ## This if for units that require an additional
    ## bit of information -- i.e. to convert between
    ## volume and mass you need the density of an
    ## item.  In these cases, the additional factor
    ## will be provided as an 'item' that is then looked
    ## up in the dictionary referenced here (i.e. the density_table)
    ## currently, 'density' is the only keyword used
    ("pt.", "lb."):['density',1],
    ("tbs.", "oz."):['density',0.5],
    ("c.", "oz."):['density',8],
    ("pt.", "oz."):['density',16],
    ("ml", "g"):['density',1]}

# The units here need to correspond to the standard unit names defined
# in UNITS.  These are some core conversions from mass-to-volume,
# assuming a density of 1 (i.e. the density of water).
VOL_TO_MASS_TABLE = {
    ("pt.", "lb.") : 1,
    ("tbs.", "oz.") : 0.5,
    ("c.", "oz.") : 8,
    ("pt.", "oz.") : 16,
    ("ml", "g") : 1,
    ("ml", "mg") : 1000,
    ("ml", "kg"): 0.001,
    ("cl", "kg"): 0.01,
    ("cl", "g") : 10,
    ("dl", "kg") : 0.1,
    ("dl", "g") : 100,    
    ("l", "kg") : 1}

### From translator :
### FRENCH PART TO BE REVISED !!! US units != UK units != Canadian units !!!
### I will work on these later... 

# # Stand unit names and alternate unit names that might appear.  For
# # example: "c." is our standard abbreviation for cup.  "cup","c." or
# # "cups" might appear in a recipe we are importing.  Each item of this
# # list looks like this:
# #
# # ["standard", ["alternate1","alternate2","alternate3",...]]

# UNITS = [
#         #["bucket" , ["bucket","buckets","bckt."]],
#          ["picotin", ["peck","pecks","picotin"]],							#peck
#          ["boisseau", ["bushel","bushels","bsh.","bu.","bu","bsh","bshl","bshl.","boisseau","minot"]],	#bushel
#          #["grains", ["grain","grains"]],
#          ["dram", ["dram","drams"]],									#(same)
#          ["goutte", ["drop","goutte","gouttes"]],							#drop
#          ["c. à thé", ["teaspoon","tsp","tsp.","tea spoon","tsps.","teaspoons","tea spoons","Teaspoon", 
# 	               "cuiller à thé","cuillers à thé","cuiller a the","cuillers a the","cuiller à th.",
# 		       "cuillers a th.", "c. à th.","c. a th."]],					#tsp. 
# 	 ["c. à table", ["tablespoon","tbs","tbsp","tbs.","tbsp.","table spoon","tbsps.","tablespoons", 
# 		         "Tablespoon", "cuillère à table","cuillères à table","cuillere a table","cuilleres a table",
# 		         "cuillerée à soupe","cuillerées à soupe","cuilleree a soupe","cuillerees a soupe"]],	#tbs.
#          ["lb", [ "pound","lb","lb.","lbs.","pounds","livre","livres"]],				#lb.
#          ["oz", [ "ounce","oz","ounces","oz.","once","onces"]],						#oz.
#          ["tasse", ["cup","c.","cups","tasse","tasses","t"]],						#c.
#          ["pte", ["quart","qt.","quarts","pte","pinte","pintes"]],					#qt.
#          ["chop", ["pint","pt.","pints","chop","chopine","chopines","chopine liquide"]],		#pt.
#          ["gallon", ["gallon","gallons","gal."]],
#          ["gallon US", ["gallon US","gallon amériacain"]],
#          ["ml", ["mililiter","ml","ml.","mililiters","millilitre","millilitres"]],			#ml.
#          ["cl", ["centiliter","cl","cl.","centiliters","centilitre","centilitres"]],			#cl.
#          ["dl", ["deciliter","dl","dl.","deciliters","décilitre","decilitre","décilitres","décilitres"]],#dl.
#          ["l", ["liter","l.","lit.","liters","litre","litres"]],					#l.
#          ["g", ["grams","gram","g","gramme","grammes"]],						#g.
#          ["mg", ["miligram","mg.","mg","miligrams","milligramme","milligrammes"]],			#mg.
#          ["kg", ["kilogram","kg.","kg","kilograms","kilogramme","kilogrammes"]]				#kg.
#          ]

# METRIC_RANGE = (1,999)

# # The following sets up unit groups. Users will be able to turn
# # these on or off (American users, for example, would likely turn
# # off metric units, since we don"t use them).
# # (User choice not implemented yet)
# UNIT_GROUPS = {
#     "metric mass":[("mg",METRIC_RANGE),
#                    ("g",METRIC_RANGE),
#                    ("kg",(1,None))],
#     "metric volume":[("ml",METRIC_RANGE),
#                      ("cl",(1,99)),
#                      ("dl",(1,9)),
#                      ("l",(1,None))],
#     "imperial weight":[#("grains",(0,27)),
#                        ("dram",(0.5,15)),
#                        ("oz",(0.25,32)),
#                        ("lb",(0.25,None))
#                        ],
#     "imperial volume":[("goutte",(0,3)),
#                        ("c. à thé",(0.125,3)),
#                        ("c. à table",(1,4)),
#                        ("tasse",(0.25,6)),
#                        ("chop",(1,1)),
#                        ("pte",(1,3)),
#                        ("gallon US",(1,None)),
#                        ("picotin",(1,2)),
#                        #("bucket",(1,2)),
#                        ("boisseau",(1,None))]
#     }

# # The units here need to correspond to the standard unit names defined
# # above in UNITS
# CROSS_UNIT_TABLE = {
#     ## This if for units that require an additional
#     ## bit of information -- i.e. to convert between
#     ## volume and mass you need the density of an
#     ## item.  In these cases, the additional factor
#     ## will be provided as an "item" that is then looked
#     ## up in the dictionary referenced here (i.e. the density_table)
#     ## currently, "density" is the only keyword used
#     ("chop","lb"):["density",1],
#     ("c. à table","oz"):["density",0.5],
#     ("tasse","oz"):["density",8],
#     ("chop","oz"):["density",16],
#     ("ml","g"):["density",1]}

# # The units here need to correspond to the standard unit names defined
# # in UNITS.  These are some core conversions from mass-to-volume,
# # assuming a density of 1 (i.e. the density of water).
# VOL_TO_MASS_TABLE = {
#     ("chop","lb") : 1,					#(warning, might not be accurate, see below)
#     ("c. à table","oz") : 0.5,
#     ("tasse","oz") : 8,
#     ("chop","oz") : 20,					#(warning, modified, see "chopine" in granddictionnaire)
#     ("ml","g") : 1,
#     ("ml","mg") : 1000,
#     ("ml","kg"): 0.001,
#     ("cl","kg"): 0.01,
#     ("cl","g") : 10,
#     ("dl","kg") : 0.1,
#     ("dl","g") : 100,    
#     ("l","kg") : 1}


# These functions are rather important! Our goal is simply to
# facilitate look ups -- if the user types in "tomatoes", we want to
# find "tomato." Note that the strings these functions produce will
# _never_ be shown to the user, so it's fine to generate nonsense
# words as well as correct answers -- our goal is to generate a list
# of possible hits rather than to get the plural/singular form "right".

def guess_singulars (s):
    """I don't really know French, but I'm going to guess it's
    like English and Spanish with regard to plurals and try some basic
    rules here.
    """
    if len(s)<3: return []
    ret = []
    if s[-1]=='s':
        ret.append(s[0:-1]) # try chopping off the s
        if s[-2]=='e':
            ret.append(s[0:-2]) # try chopping off 'es'
    return ret

def guess_plurals (s): return [s+'s',s+'es']


IGNORE=["et","avec","de","des","d'","pour","froid","froide","froids","froides",
         "chaud","chaude","chauds","chaudes","finement","mince","minces",
         "approximativement","grosso modo","vulgairement"]

NUMBERS = {
    }

########NEW FILE########
__FILENAME__ = defaults_nl
# -*- coding: utf-8 -*-
#
## we set up default information.
## first, easy to maintain lists which can eventually be moved to
## files.

# TRANSLATOR WARNING: DO NOT TRANSLATE THE FIELD NAMES: ONLY THE VALUES!!!
CREDITS = "Gregory"

# only translate the items in the list [..] (and feel free to create categories
# that make sense for your locale -- no need to translate these ones). DO NOT
# translate 'cuisine','rating','source' or 'category'
fields={'cuisine': ['Amerikaans','Italiaans','Mexicaans',
                    'Zuid-westers','Aziatisch/Thais','Aziatisch/Vietnamees',
                    'Aziatisch/Chinees','Aziatisch/Japans',],
        'rating' : ['Excellent','Zeer goed','Goed','Matig','Zwak'],
        'source' : ['Kookboek'],
        'category' : ['Dessert','Voorgerecht','Salade','Soep',
                      'Ontbijt'],
                  }

# In English, there are a heck of a lot of synonyms. This is a list
# for those synonyms.  ["preferred word","alternate word","alternate word"]
# If there are none of these that you can think of in your language, just
# set this to:
# SYNONYMS=[]
SYNONYMS=[]

# a dictionary key=ambiguous word, value=list of possible non-ambiguous terms
AMBIGUOUS = {}


# triplicates ITEM, KEY, SHOPPING CATEGORY
# These will be defaults. They should include whatever foods might be
# standard for your locale, with whatever sensible default categories
# you can think of (again, thinking of your locale, not simply translating
# what I've done).
INGREDIENT_DATA = [["alfalfa spruiten","alfalfa spruiten","land- en tuinbouw producten"],
                   ["anijs","anijs","land- en tuinbouw producten"],
                   ["artisjok","artisjok","land- en tuinbouw producten"],
                   ["arugula","arugula","land- en tuinbouw producten"],
                   ["asperge","asperge","land- en tuinbouw producten"],
                   ["aubergine","aubergine","land- en tuinbouw producten"],
                   ["avocado","avocado","land- en tuinbouw producten"],
                   ["groene bonen","groene bonen","land- en tuinbouw producten"],
                   ["azukibonen","azukibonen","land- en tuinbouw producten"],
                   ["boonspruiten","boonspruiten","land- en tuinbouw producten"],
                   ["zwarte bonen","zwarte bonen","land- en tuinbouw producten"],
                   ["black-eyed peas","black-eyed peas","land- en tuinbouw producten"],
                   ["borlotti bonen","borlotti bonen","land- en tuinbouw producten"],
                   ["broad bonen","broad bonen","land- en tuinbouw producten"],
                   ["kikkererwten, garbanzos","kikkererwten, garbanzos","land- en tuinbouw producten"],
                   ["nierbonen","nierbonen","land- en tuinbouw producten"],
                   ["linzen","linzen","land- en tuinbouw producten"],
                   ["limabonen of boterbonen","limabonen of boterbonen","land- en tuinbouw producten"],
                   ["mung bonen","mung bonen","land- en tuinbouw producten"],
                   ["navy bonen","navy bonen","land- en tuinbouw producten"],
                   ["pronkbonen of Spaase bonen","pronkbonen of Spaanse bonen","land- en tuinbouw producten"],
                   ["sojabonen","sojabonen","land- en tuinbouw producten"],
                   ["erwten","erwten","land- en tuinbouw producten"],
                   ["snap peas","snap peas","land- en tuinbouw producten"],
                   ["bok choy","bok choy","land- en tuinbouw producten"],
                   ["broodfruit","broodfruit","land- en tuinbouw producten"],
                   ["groene bloemkool","groene bloemkool","land- en tuinbouw producten"],
                   ["broccoli","broccoli","land- en tuinbouw producten"],
                   ["spruitjes","spruitjes","land- en tuinbouw producten"],
                   ["kool","kool","land- en tuinbouw producten"],
                   ["bloemkool","bloemkool","land- en tuinbouw producten"],
                   ["selder","selder","land- en tuinbouw producten"],
                   ["maïssalade","maïssalade","land- en tuinbouw producten"],
                   ["witloof","witloof","land- en tuinbouw producten"],
                   ["kropsla","kropsla","land- en tuinbouw producten"],
                   ["maïs","maïs","land- en tuinbouw producten"],
                   ["champignons","champignons","land- en tuinbouw producten"],
                   ["netels","netels","land- en tuinbouw producten"],
                   ["bieslook","bieslook","land- en tuinbouw producten"],
                   ["look","look","land- en tuinbouw producten"],
                   ["prei","prei","land- en tuinbouw producten"],
                   ["ajuin","ajuin","land- en tuinbouw producten"],
                   ["sjalot","sjalot","land- en tuinbouw producten"],
                   ["peterselie","peterselie","land- en tuinbouw producten"],
                   ["peper","peper","land- en tuinbouw producten"],
                   ["zwarte peper","zwarte peper","land- en tuinbouw producten"],
                   ["witte peper","witte peper","land- en tuinbouw producten"],
                   ["chili peper","chili peper","land- en tuinbouw producten"],
                   ["jalapeño peper","peper, jalapeño","land- en tuinbouw producten"],
                   ["habanero peper","peper, habanero","land- en tuinbouw producten"],
                   ["rabarber","rabarber","land- en tuinbouw producten"],
                   ["biet","biet","land- en tuinbouw producten"],
                   ["wortel","wortel","land- en tuinbouw producten"],
                   ["maniok","maniok","land- en tuinbouw producten"],
                   ["ginger","ginger","land- en tuinbouw producten"],
                   ["radijs","radijs","land- en tuinbouw producten"],
                   ["wasabi","wasabi","land- en tuinbouw producten"],
                   ["witte radijs","witte radijs","land- en tuinbouw producten"],
                   ["spinazie","spinazie","land- en tuinbouw producten"],
                   ["komkommer","komkommer","land- en tuinbouw producten"],
                   ["pompoen","pompoen","land- en tuinbouw producten"],
                   ["spaghetti squash","squash, spaghetti","land- en tuinbouw producten"],
                   ["tomaat","tomaat","land- en tuinbouw producten"],
                   ["aardappel","aardappel","land- en tuinbouw producten"],
                   ["zoete aardappel","zoete aardappel","land- en tuinbouw producten"],
                   ["waterkers","waterkers","land- en tuinbouw producten"],
                   ["appel","appel","land- en tuinbouw producten"],
                   ["juneberry","juneberry","land- en tuinbouw producten"],
                   ["granaatappel","granaatappel","land- en tuinbouw producten"],
                   ["abricot","abricot","land- en tuinbouw producten"],
                   ["kers","kers","land- en tuinbouw producten"],
                   ["perzik","perzik","land- en tuinbouw producten"],
                   ["nectarine","nectarine","land- en tuinbouw producten"],
                   ["braambes","braambes","land- en tuinbouw producten"],
                   ["framboos","framboos","land- en tuinbouw producten"],
                   ["bergbraambes","bergbraambes","land- en tuinbouw producten"],
                   ["beredruif","beredruif","land- en tuinbouw producten"],
                   ["bosbes","bosbes","land- en tuinbouw producten"],
                   ["Amerikaanse veenbes","Amerikaanse veenbes","land- en tuinbouw producten"],
                   ["lingonberry","lingonberry","land- en tuinbouw producten"],
                   ["berberis","berberis","land- en tuinbouw producten"],
                   ["rode bes","bes, rood","land- en tuinbouw producten"],
                   ["zwarte bes","bes, zwart","land- en tuinbouw producten"],
                   ["witte bes","bes, wit","land- en tuinbouw producten"],
                   ["vlierbes","vlierbes","land- en tuinbouw producten"],
                   ["kruisbes","kruisbes","land- en tuinbouw producten"],
                   ["overzees-wegedoorn","overzees-wegedoorn","land- en tuinbouw producten"],
                   ["moerbeiboom","moerbeiboom","land- en tuinbouw producten"],
                   ["kiwi","kiwi","land- en tuinbouw producten"],
                   ["papaja","papaja","land- en tuinbouw producten"],
                   ["peer","peer","land- en tuinbouw producten"],
                   ["kantaloep","kantaloep","land- en tuinbouw producten"],
                   ["watermeloen","watermeloen","land- en tuinbouw producten"],
                   ["aardbei","aardbei","land- en tuinbouw producten"],
                   ["vijg","vijg","land- en tuinbouw producten"],
                   ["druif","druif","land- en tuinbouw producten"],
                   ["pompelmoes","pompelmoes","land- en tuinbouw producten"],
                   ["citroen","citroen","land- en tuinbouw producten"],
                   ["limoen","limoen","land- en tuinbouw producten"],
                   ["mandarijn","mandarijn","land- en tuinbouw producten"],
                   ["clementine","clementine","land- en tuinbouw producten"],
                   ["sinaasappel","sinaasappel","land- en tuinbouw producten"],
                   ["lychee","lychee","land- en tuinbouw producten"],
                   ["passievrucht","passievrucht","land- en tuinbouw producten"],
                   ["banaan","banaan","land- en tuinbouw producten"],
                   ["ster fruit","ster fruit","land- en tuinbouw producten"],
                   ["kokosnoot","kokosnoot","land- en tuinbouw producten"],
                   ["durian","durian","land- en tuinbouw producten"],
                   ["mango","mango","land- en tuinbouw producten"],
                   ["ananas","ananas","land- en tuinbouw producten"],

                   ["ansjovis","ansjovis","vis & zeevruchten"],
                   ["baars","baars","vis & zeevruchten"],
                   ["blowfish","blowfish","vis & zeevruchten"],
                   ["meerval","meerval","vis & zeevruchten"],
                   ["kabeljouw","kabeljouw","vis & zeevruchten"],
                   ["paling","paling","vis & zeevruchten"],
                   ["bot","bot","vis & zeevruchten"],
                   ["schelvis","schelvis","vis & zeevruchten"],
                   ["heilbot","heilbot","vis & zeevruchten"],
                   ["zeebaars","zeebaars","vis & zeevruchten"],
                   ["snoek","snoek","vis & zeevruchten"],
                   ["sardien","sardien","vis & zeevruchten"],
                   ["zalm","zalm","vis & zeevruchten"],
                   ["zeebaars","zeebaars","vis & zeevruchten"],
                   ["haai","haai","vis & zeevruchten"],
                   ["snapper","snapper","vis & zeevruchten"],
                   ["schorpioenvis","schorpioenvis","vis & zeevruchten"],
                   ["tong","tong","vis & zeevruchten"],
                   ["steur","steur","vis & zeevruchten"],
                   ["zwaardvis","zwaardvis","vis & zeevruchten"],
                   ["tegelvis","tegelvis","vis & zeevruchten"],
                   ["forel","forel","vis & zeevruchten"],
                   ["tonijn","tonijn","vis & zeevruchten"],
                   ["witing","witing","vis & zeevruchten"],
                   ["kuiten","kuiten","vis & zeevruchten"],
                   ["kaviaar","kaviaar","vis & zeevruchten"],
                   ["zalmkuiten","zalmkuiten","vis & zeevruchten"],
                   ["krab","krab","vis & zeevruchten"],
                   ["rivierkreeften","rivierkreeften","vis & zeevruchten"],
                   ["kreeft","kreeft","vis & zeevruchten"],
                   ["garnaal","garnaal","vis & zeevruchten"],
                   ["scampi","scampi","vis & zeevruchten"],
                   ["tweekleppig schelpdier","tweekleppig schelpdier","vis & zeevruchten"],
                   ["mossel","mossel","vis & zeevruchten"],
                   ["octopus","octopus","vis & zeevruchten"],
                   ["oester","oester","vis & zeevruchten"],
                   ["slak","slak","vis & zeevruchten"],
                   ["inktvis","inktvis","vis & zeevruchten"],
                   ["kammossel","kammossel","vis & zeevruchten"],

                   ["spek","spek","vlees"],
                   ["chorizo","chorizo","vlees"],
                   ["fuet","fuet","vlees"],
                   ["salami","salami","vlees"],
                   ["ham","ham","vlees"],
                   ["mutton","mutton","vlees"],
                   ["lam","lam","vlees"],
                   ["kalf","kalf","vlees"],
                   ["steak","steak","vlees"],
                   ["hamburger","hamburger","vlees"],
                   ["roast beef","roast beef","vlees"],
                   ["konijn","konijn","vlees"],
                   ["struisvogel","struisvogel","vlees"],
                   ["muskusrat","muskusrat","vlees"],
                   ["waterkonijn","waterkonijn","vlees"],
                   ["kip","kip","vlees"],
                   ["kalkoen","kalkoen","vlees"],
                   ["eend","eend","vlees"],
                   ["gans","gans","vlees"],

                   ## my old list
                   ['plantaardige bouillon','bouillon, plantaardig','soepen & sausen'],
                   ['basilicum','basilicum','land- en tuinbouw producten',],
                   ['lichtbruine suiker','suiker, lichtbruin','bakken',],
                   ['azijn','azijn','wijnen & oliën',],
                   ['okkernoot','okkernoot','bakken',],
                   ['korianderzaadjes','korianderzaadjes','kruiden',],
                   ['couscous','couscous','pasta\'s',],
                   ['rijst','rijst','pasta\'s',],
                   ['olijfolie','olie, olijf','wijnen & oliën',],
                   ['vanille extract','vanille extract','bakken',],
                   ['rode aardappel','aardappel, rood','land- en tuinbouw producten',],
                   ['currypoeder','currypoeder','kruiden',],
                   ['gedroogde garnaal','garnaal, gedroogd','internationaal',],
                   ['dijon mosterd','mosterd, dijon','condiments',],
                   ['maïsolie','olie, maïs','wijnen & oliën',],
                   ['feta kaas','kaas, feta','zuivelproducten',],
                   ['kerstomaat','tomaat, kers','land- en tuinbouw producten',],
                   ['spaghetti','spaghetti','pasta\'s',],
                   ['witte ajuin','ajuin, wit','land- en tuinbouw producten',],
                   ['yoghurt','yoghurt','zuivelproducten',],
                   ['croutons','croutons','brood',],
                   ['chili poeder','chili poeder','kruiden',],
                   ['krulsla','sla, gekruld','land- en tuinbouw producten',],
                   ['rijstazijn','azijn, rijst','internationaal',],
                   ['pasta','pasta','pasta\'s',],
                   ['zure room','zure room','zuivelproducten',],
                   ['sinaasappelsap','sinaasappelsap','land- en tuinbouw producten',],
                   ['spinazie','spinazie','land- en tuinbouw producten',],
                   ['plantaardige olie','olie, plantaardig','wijnen & oliën',],
                   ['pindakaas','pindakaas','brood',],
                   ['ei','ei','zuivelproducten',],
                   ['limoen','limoen','land- en tuinbouw producten',],
                   ['olijven','olijven','land- en tuinbouw producten',],
                   ['boter','boter','zuivelproducten',],
                   ['cheddar kaas','kaas, cheddar','zuivelproducten',],
                   ['mozzarella kaas','kaas, mozzarella','zuivelproducten',],
                   ['witte suiker','suiker, wit','bakken',],
                   ['fresh kaas white goat','kaas, fresh white goat','zuivelproducten',],
                   ['geel maïsmeel','maïsmeel, geel','bakken',],
                   ['paprika','paprika','kruiden',],
                   ['ster anijs','ster anijs','kruiden',],
                   ['bruine suiker','suiker, bruin','bakken',],
                   ['honing','honing','bakken',],
                   ['citroensap','citroensap','land- en tuinbouw producten',],
                   ['rode ajuin','ajuin, rood','land- en tuinbouw producten',],
                   ['melk','melk','zuivelproducten',],
                   ['bakpoeder','bakpoeder','bakken',],
                   ['tomatensap','tomatensap','soepen & sausen',],
                   ['mosterdzaadjes','zaadjes, mosterd','kruiden',],
                   ['parmesan kaas','kaas, parmesan','pasta\'s',],
                   ['mayonnaise','mayonnaise','brood',],
                   ['gerookte Gouda kaas','kaas, gerookte Gouda','zuivelproducten',],
                   ['kokosmelk','kokosmelk','internationaal',],
                   ['bloem','bloem','bakken',],
                   ['salsa','salsa','internationaal',],
                   ['broccoli','broccoli','land- en tuinbouw producten',],
                   ['witte wijn','wijn, wit','wijnen & oliën',],
                   ['rode wijn','wijn, rood','wijnen & oliën',],
                   ['bruin bier','bier, bruin','wijnen & oliën',],
                   ['blond bier','bier, blond','wijnen & oliën',],
                   ['witbier','bier, wit','wijnen & oliën',],
                   ['zwarte gemalen peper','zwarte peper, gemalen','kruiden',],
                   ['witte gemalen peper','witte peper, gemalen','kruiden',],
                   ['sojasaus','sojasaus','internationaal',],
                   ['sesamzaadjes','sesamzaadjes','internationaal',],
                   ['zout','zout','bakken',],
                   ['kurkuma','kurkuma','kruiden',],
                   ['kipfilet' ,'kip, filet' , 'vlees',],
                   ['hele kip' ,'kip, heel' , 'vlees',],
                   ['kippenboutje' ,'kip, bouten' , 'vlees',],
                   ['rundsvlees' ,'rundsvlees' , 'vlees',],
                   ['gehakt' ,'gehakt' , 'vlees',],
                   ['varkensvlees' ,'varkensvlees' , 'vlees',],
                   ]

# THESE ARE STANDARD UNIT CONVERSIONS. You can simply translate unit names where
# you know them. Eliminate entries that are untranslatable or don't exist in your
# locale. And please add any additional units that you know of.
CONVERTER_TABLE = {
    ("l", "ml"):1000,
    ("l", "cl"):100,
    ("l", "dl"):10,
    ("kg", "g"):1000,
    ("g", "mg"):1000
    }

# DENSITIES of common foods. This allows us to convert between mass and volume.
DENSITY_TABLE={
    "water":1,
    "sap, druif":1.03,
    "plantaardige bouillon":1,
    "bouillon, plantaardig":1,
    "bouillon, kip":1,
    "melk":1.029,
    "melk, vol":1.029,
    "melk, mager":1.033,
    "melk, 2%":1.031,
    "melk, 1%":1.03,
    "kokosmelk":0.875,
    "karnemelk":1.03,
    "zware room":0.994,
    "lichte room":1.012,
    "half en half":1.025,
    "honing":1.420,
    "suiker, wit":1.550,
    "zout":2.165,
    "boter":0.911,
    "olie, plantaardig":0.88,
    "olie, olijf":0.88,
    "olie, maïs":0.88,
    "olie, sesam":0.88,
    "bloem, alle doeleinden": 0.6,
    "bloem, whole wheat": 0.6,
    "maïszetmeel": 0.6,
    "suiker, bloem": 0.6,
    "suiker, zoetigheden": 0.6
    }

# Stand unit names and alternate unit names that might appear.
# For example: "c." is our standard for cup. "cup","c." or "cups" might appear
# in a recipe we are importing.
# Each item of this list looks like this:
#
# ["standard", ["alternate1","alternate2","alternate3",...]]

UNITS = [["bucket" , ["bucket","buckets","bckt."]],
         ["grains", ["grain","grains"]],
         ["dram", ["dram","drams"]],
         ["drop",["drop"]],
         ["bos", ["bossen","bosje"]],
         ["theelp.", ["theelepel","theelepels","theelepeltje","theelepeltjes","theelpl.","theelpl"]],
         ["eetlp.", ["eetlepel","eetlepels","eetlpl.","eetlpl"]],
         ["lb.", [ "pond","lb","lb.","lbs.","ponden"]],
         ["k.", ["kop","kopje","kp.","koppen"]],
         ["qt.", ["quart","qt.","quarts"]],
         ["pt.", ["pint","pt.","pints"]],
         ["ml", ["mililiter","ml.","mlit.","mililiters"]],
         ["cl", ["centiliter","cl.","clit.","centiliters"]],
         ["dl", ["deciliter","dl.","dlit.","deciliters"]],
         ["l", ["liter","l.","lit.","liters"]],
         ["g", ["gram","g.","gr","gr.","grammen"]],
         ["mg", ["miligram","mg.","mg","miligrammen"]],
         ["kg", ["kilogram","kg.","kg","kilogrammen"]]
         ]

# The following sets up unit groups. Users will be able to turn
# these on or off (American users, for example, would likely turn
# off metric units, since we don't use them).
METRIC_RANGE = (1,999)

UNIT_GROUPS = {
    'metric mass':[('mg',METRIC_RANGE),
                   ('g',METRIC_RANGE),
                   ('kg',(1,None))],
    'metric volume':[('ml',METRIC_RANGE),
                     ('cl',(1,99)),
                     ('dl',(1,9)),
                     ('l',(1,None)),],
    'imperial weight':[('grains',(0,27)),
                       ('dram',(0.5,15)),
                       ('oz.',(0.25,32)),
                       ('lb.',(0.25,None)),
                       ],
    'imperial volume':[('drop',(0,3)),
                       ('tsp.',(0.125,3)),
                       ('tbs.',(1,4)),
                       ('k.',(0.25,6)),
                       ('pt.',(1,1)),
                       ('qt.',(1,3)),
                       ('gallon',(1,None)),
                       ('peck',(1,2)),
                       ('bucket',(1,2)),
                       ('bushel',(1,None))]
    }

# The units here need to correspond to the standard unit names defined
# above in UNITS
CROSS_UNIT_TABLE = {
    ## This if for units that require an additional
    ## bit of information -- i.e. to convert between
    ## volume and mass you need the density of an
    ## item.  In these cases, the additional factor
    ## will be provided as an 'item' that is then looked
    ## up in the dictionary referenced here (i.e. the density_table)
    ## currently, 'density' is the only keyword used
    ("pt.", "lb."):['density',1],
    ("tbs.", "oz."):['density',0.5],
    ("k.", "oz."):['density',8],
    ("pt.", "oz."):['density',16],
    ("ml", "g"):['density',1]}

# The units here need to correspond to the standard unit names defined
# in UNITS
VOL_TO_MASS_TABLE = {
    ("pt.", "lb.") : 1,
    ("tbs.", "oz.") : 0.5,
    ("c.", "oz.") : 8,
    ("pt.", "oz.") : 16,
    ("ml", "g") : 1,
    ("ml", "mg") : 1000,
    ("ml", "kg"): 0.001,
    ("cl", "kg"): 0.01,
    ("cl", "g") : 10,
    ("dl", "kg") : 0.1,
    ("dl", "g") : 100,    
    ("l", "kg") : 1}
    
# These functions are rather important! Our goal is simply to
# facilitate look ups -- if the user types in "tomatoes", we want to
# find "tomato." Note that the strings these functions produce will
# _never_ be shown to the user, so it's fine to generate nonsense
# words as well as correct answers -- our goal is to generate a list
# of possible hits rather than to get the plural/singular form "right".

def guess_singulars (s): return []
def guess_plurals (s):
    """This is a very lame attempt at Dutch grammar!

    Obviously this isn't close to a good plural generator, but I
    thought it might make an occasional match, so what the hell.
    """
    return [s+"en",s+"s"]

IGNORE = []

########NEW FILE########
__FILENAME__ = defaults_pt
# -*- coding: utf-8 -*-
#
## we set up default information.
## first, easy to maintain lists which can eventually be moved to
## files.

# TRANSLATOR WARNING: DO NOT TRANSLATE THE FIELD NAMES: ONLY THE VALUES!!!

CREDITS = "Leandro Guimarães Faria Corcete Dutra"

# only translate the items in the list [..] (and feel free to create categories
# that make sense for your locale -- no need to translate these ones). DO NOT
# translate 'cuisine','rating','source' or 'category'
fields={'cuisine': ['Estadunidense','Italiana','Mexicana',
                    'Sudoeste dos Estados Unidos','Tailandesa','Vietnamita',
                    'Chinesa','Japonesa','Mineira','Nordestina','Portuguesa','Brasileira'],
        'rating' : ['Excelente','Ótima','Boa','Razoável','Fraca'],
        'source' : [],
        'category' : ['Sobremesa','Entrada','Salada','Sopa',
                      'Café da manhã'],
                  }

# In English, there are a heck of a lot of synonyms. This is a list
# for those synonyms.  ["preferred word","alternate word","alternate word"]
# If there are none of these that you can think of in your language, just
# set this to:
# SYNONYMS=[]
SYNONYMS=[
    # the first item of each list is the default
    ]

# a dictionary key=ambiguous word, value=list of possible non-ambiguous terms
AMBIGUOUS = {}


# triplicates ITEM, KEY, SHOPPING CATEGORY
# These will be defaults. They should include whatever foods might be
# standard for your locale, with whatever sensible default categories
# you can think of (again, thinking of your locale, not simply translating
# what I've done).
INGREDIENT_DATA = [
                   # fruits, from wikipedia list
                   ## seafood, from wikipedia list
                   ## meats (garnered from wikipedia lists)
                   ## my old list
                   ]

# THESE ARE STANDARD UNIT CONVERSIONS. You can simply translate unit names where
# you know them. Eliminate entries that are untranslatable or don't exist in your
# locale. And please add any additional units that you know of.
CONVERTER_TABLE = {
    ("c.", "tbs."):16,
    ("lb.", "oz."):16,
    ("tbs.", "tsp."):3,
    ("pt.", "c."):2,
    ("qt.", "c."):4,
    ("gallon", "qt."):4,
    ("l", "qt."):1.057,
    ("l", "ml"):1000,
    ("l", "cl"):100,
    ("l", "dl"):10,
    ("oz.", "g"):28.35,
    ("kg", "g"):1000,
    ("g", "mg"):1000,
    ("tsp.", "drop"):76,
    ("oz.", "dram"):16,
    ("dram", "grains"):27.34375,
    ("peck", "gallon"):2,
    ("bucket", "peck"):2,
    ("bushel", "bucket"):2,
    ("lb.", "grains"):7000}

# DENSITIES of common foods. This allows us to convert between mass and volume.
DENSITY_TABLE={
    "água":1,
    "suco, uva":1.03,
    "caldo de vegetais":1,
    "caldo, vegetais":1,
    "caldo, galinha":1,
    "leite":1.029,
    "leite, integral":1.029,
    "leite, desnatado":1.033,
    "leite, 2%":1.031,
    "leite, 1%":1.03,
    "leite de coco":0.875,
    "mel":1.420,
    "açúcar, branco":1.550,
    "sal":2.165,
    "manteiga":0.911,
    "óleo, vegetal":0.88,
    "azeite":0.88,
    "óleo, milho":0.88,
    "óleo, gergelim":0.88,
    "farinha, branca": 0.6,
    "farinha, integral": 0.6,
    "açúcar, refinado": 0.6,
    "açúcar, cristal": 0.6
            }

# Stand unit names and alternate unit names that might appear.
# For example: "c." is our standard for cup. "cup","c." or "cups" might appear
# in a recipe we are importing.
# Each item of this list looks like this:
#
# ["standard", ["alternate1","alternate2","alternate3",...]]

UNITS = [["caixa" , ["cx", "cx."]],
         ["gota", ["gota"]],
         ["pitada", ["pitada"]],
         ["colher de café", ["Colher de café"]],
         ["colher de chá", ["Colher de chá"]],
         ["colher de sobremesa", ["Colher de sobremesa"]],
         ["colher de sopa", ["Colher de sopa"]],
         ["kg", ["quilograma"]],
         ["xícara de chá", ["Xícara de chá"]],
         ["xícara de café", ["Xícara de café"]],
         ["ml", ["mililitro"]],
         ["cl", ["centilitro"]],
         ["dl", ["decilitro"]],
         ["l", ["litro"]],
         ["g", ["grama"]],
         ["mg", ["miligrama"]],
         ["kg", ["quilograma"]]
         ]

# The following sets up unit groups. Users will be able to turn
# these on or off (American users, for example, would likely turn
# off metric units, since we don't use them).
METRIC_RANGE = (1,999)

UNIT_GROUPS = {
    'metric mass':[('mg',METRIC_RANGE),
                   ('g',METRIC_RANGE),
                   ('kg',(1,None))],
    'metric volume':[('ml',METRIC_RANGE),
                     ('cl',(1,99)),
                     ('dl',(1,9)),
                     ('l',(1,None)),],
    }

# The units here need to correspond to the standard unit names defined
# above in UNITS
CROSS_UNIT_TABLE = {
    ## This if for units that require an additional
    ## bit of information -- i.e. to convert between
    ## volume and mass you need the density of an
    ## item.  In these cases, the additional factor
    ## will be provided as an 'item' that is then looked
    ## up in the dictionary referenced here (i.e. the density_table)
    ## currently, 'density' is the only keyword used
    ("ml", "g"):['density',1]}

# The units here need to correspond to the standard unit names defined
# in UNITS
VOL_TO_MASS_TABLE = {
    ("ml", "g") : 1,
    ("ml", "mg") : 1000,
    ("ml", "kg"): 0.001,
    ("cl", "kg"): 0.01,
    ("cl", "g") : 10,
    ("dl", "kg") : 0.1,
    ("dl", "g") : 100,    
    ("l", "kg") : 1}
    


# These functions are rather important! Our goal is simply to
# facilitate look ups -- if the user types in "tomatoes", we want to
# find "tomato." Note that the strings these functions produce will
# _never_ be shown to the user, so it's fine to generate nonsense
# words as well as correct answers -- our goal is to generate a list
# of possible hits rather than to get the plural/singular form "right".

def guess_singulars (s):
    """I don't really know portuguese, but I'm going to guess it's
    like English and Spanish with regard to plurals and try some basic
    rules here.
    """
    if len(s)<3: return []
    ret = []
    if s[-1]=='s':
        ret.append(s[0:-1]) # try chopping off the s
        if s[-2]=='e':
            ret.append(s[0:-2]) # try chopping off 'es'
    return ret

def guess_plurals (s): return [s+'s',s+'es']

IGNORE=[]

NUMBERS = {
    }

########NEW FILE########
__FILENAME__ = defaults_ru
# -*- coding: utf-8 -*-
#
# we set up default information for our locale.
# Translators should use this file as the basis of their translation.
# Copy this file and rename it for you locale.
#
# For example, Spanish uses:
# defaults_es.py
#
# British English uses:
# defaults_en_GB.py
#
# Please fill in the below fields:

# Language: Russian
# Translator: Alexandre Prokoudine <alexandre.prokoudine[NOSPAM]gmail.com
# Last-updated: July 12, 2009

# TRANSLATOR WARNING: DO NOT TRANSLATE THE FIELD NAMES: ONLY THE VALUES!!!

# only translate the items in the list [..] (and feel free to create
# categories that make sense for your locale -- no need to translate
# these ones). DO NOT translate 'cuisine','rating','source' or
# 'category'

# The below are Gourmet's standard fields and the default categories for them.
# Do not translate the field names ('cuisine','rating','source,'category').
# Instead, fill in the list with categories that make sense for your locale.
# Feel free to change the number or content of categories to be consistent
# with what users in your locale are likely to be familiar with.

fields={'cuisine': ['Американская','Итальянская','Мексиканская',
                    'Юго-западная','Азиатская/Тайская','Азиатская/Вьетнамская',
                    'Азиатская/Китайская','Азиатская/Японская',],
        'rating' : ['Превосходно','Отлично','Хорошо','Сойдет','Ужасно'],
        'source' : [],
        'category' : ['Десерт','Основное блюдо','Салат','Суп',
                      'Завтрак'],
                  }

# In English, there are a heck of a lot of synonyms. This is a list
# for those synonyms.  ["preferred word","alternate word","alternate word"]
# If there are none of these that you can think of in your language, just
# set this to:
# SYNONYMS=[]
SYNONYMS=[
    # the first item of each list is the default
    ["eggplant","aubergine"],
    ["scallion","green onion","spring onion"],
    ["arugula","rocket"],
    ["azuki beans", "adzuki beans", "adzuki", "azuki"],
    ["snap peas","mangetout"],
    ["bok choy","chinese leaves"],
    ["chilli pepper","capsicum"],
    ["corn","sweetcorn","maise","sweet corn"],
    ["red bell pepper","red pepper"],
    ["bell pepper, green", "green pepper", "bell pepper","green bell pepper", "pepper"],
    ["beet","beetroot"],
    ["collard greens","spring greens"],
    ["cilantro","coriander"],
    ["turabaga","swede"],
    ["zucchini","courgette"],
    ["chokeberry","cooking apple"],
    ["juneberry","saskatoon"],
    ["nannyberry","sheepberry"],
    ["kiwi fruit","chinese gooseberry"],
    ["sunberry","wonderberry"],
    ["start fruit","carambola"],
    ["dragonfruit" , "pitaya"],
    ["jackfruit","nangka"],
    ["langsat","longkong", "duku"],
    ["velvet persimmon","mabolo"],
    ["mamoncillo", "quenepa", "genip"],
    ["rose apple", "malay apple"],
    ["salak", "snakefruit"],
    ["sapodilla", "chiku", "sapadilla", "snake fruit", "sawo"],
    ["soursop", "guanabana"],
    ['black cod','sablefish'],
    ['chilean sea bass','patagonian toothfish'],
    ['flour, all purpose','flour, all-purpose','flour','white flour'],
    ['sugar, granulated','sugar'],    
    ]

# A DICTIONARY CONTAINING INGREDIENT KEYS AND NDBNO for the USDA
# nutritional database. For these items, we will have nutritional
# information by default.

NUTRITIONAL_INFO = {}

# a dictionary for ambiguous words.
# key=ambiguous word, value=list of possible non-ambiguous terms
#
# Translators: if you have a word that has more than one food meaning
# in your language, you can add an entry as follow

# AMBIGUOUS = {
#              'word':['meaning1','meaning2','meaning3'],
#             }

AMBIGUOUS = {}


# triplicates ITEM, KEY, SHOPPING CATEGORY
# These will be defaults.

# They should include whatever foods might be standard for your
# locale, with whatever sensible default categories you can think of
# (again, thinking of your locale, not simply translating what I've
# done).

# Items provided here will automatically be recognized and go onto the
# given category in a user's shopping list by default.

# Don't feel obligated to translate every item -- especially since not
# all items will be common for all locales. However, the more items
# you can put here, the more the user will get the sense that gourmet
# "knows" about foods that they enter.

# I generated the below list using the wikipedia entry on foods as my
# starting point. You may want to do something similar for your
# locale.  Also, if the syntax of the below is too complicated, you
# can send me a list of category headings and ingredients for your
# locale and I'll do the necessary formatting <Thomas_Hinkle@alumni.brown.edu>

INGREDIENT_DATA = [["авокадо","авокадо","produce"],
                   ["анис","анис","produce"],
                   ["артишок","артишок","produce"],
                   ["арум","аронник","produce"],
                   ["баклажан","баклажан","produce"],
                   ["брокколи","капуста спаржевая","produce"],
                   ["брюква","брюква","produce"],
                   ["васаби","васаби","produce"],
                   ["горох","горох","produce"],
                   ["грибы","грибы","produce"],
                   ["зеленый перец","bell pepper, green","produce"],
                   ["имбирь","имбирь","produce"],
                   ["капуста брюссельская","капуста брюссельская","produce"],
                   ["капуста кормовая","капуста кормовая","produce"],
                   ["капуста кочанная","капуста кочанная","produce"],
                   ["капуста цветная","капуста цветная","produce"],
                   ["картофель","картофель","produce"],
                   ["кольраби","кольраби","produce"],
                   ["кормовые бобы","кормовые бобы","produce"],
                   ["крапива","крапива","produce"],
                   ["кресс водяной","кресс водяной","produce"],
                   ["лимская фасоль","butter bean","produce"],
                   ["лук-порей","лук-порей","produce"],
                   ["лук-резанец","лук-резанец","produce"],
                   ["лук репчатый","лук репчатый","produce"],
                   ["лук-шалот","лук-шалот","produce"],
                   ["мангольд","мангольд","produce"],
                   ["маниока","маниока","produce"],
                   ["морковь","морковь","produce"],
                   ["новозеландский шпинат","новозеландский шпинат","produce"],
                   ["огурец","огурец","produce"],
                   ["окра","окра","produce"],
                   ["пастернак","пастернак","produce"],
                   ["петрушка","петрушка","produce"],
                   ["плод хлебного дерева","плод хлебного дерева","produce"],
                   ["ревень","ревень","produce"],
                   ["редис белый","редис белый","produce"],
                   ["редис","редис","produce"],
                   ["репа","репа","produce"],
                   ["реснички","реснички","produce"],
                   ["салат-латук","салат-латук","produce"],
                   ["свекла","свекла","produce"],
                   ["сельдерей корневой","сельдерей корневой","produce"],
                   ["сельдерей","сельдерей","produce"],
                   ["сладкий картофель","сладкий картофель","produce"],
                   ["сладкий укроп","фенхель обыкновенный","produce"],
                   ["соевые бобы","соевые бобы","produce"],
                   ["спаржа","спаржа","produce"],
                   ["таро","таро","produce"],
                   ["томат","томат","produce"],
                   ["топинамбур","топинамбур","produce"],
                   ["турецкий горох","турецкий горох","produce"],
                   ["тыква","тыква","produce"],
                   ["фасоль обыкновенная","фасоль обыкновенная","produce"],
                   ["цукини","zucchini","produce"],
                   ["чеснок","чеснок","produce"],
                   ["чечевица","чечевица","produce"],
                   ["чилийский перец","перец, чилийский","produce"],
                   ["шпинат","шпинат","produce"],
                   ["эндивий","эндивий","produce"],
                   ["ям","ям","produce"],
#                   ["alfalfa sprouts","alfalfa sprouts","produce"].
#                   ["acorn squash","squash, acorn","produce"],
#                   ["azuki beans","azuki beans","produce"],
#                   ["bean sprouts","bean sprouts","produce"],
#                   ["black beans","black beans","produce"],
#                   ["black-eyed peas","black-eyed peas","produce"],
#                   ["bok choy","bok choy","produce"],
#                   ["borlotti beans","borlotti beans","produce"],
#                   ["broccoflower","broccoflower","produce"],
#                   ["butternut squash","squash, butternut","produce"],
#                   ["calabrese","calabrese","produce"],
#                   ["collard greens","collard greens","produce"],
#                   ["corn","corn","produce"],
#                   ["corn salad","corn salad","produce"],
#                   ["daikon","daikon","produce"],
#                   ["fiddleheads","fiddleheads","produce"],
#                   ["frisee","frisee","produce"],
#                   ["gem squash","squash, gem","produce"],
#                   ["green beans","green beans","produce"],
#                   ["green beans","green beans","produce"],
#                   ["habanero pepper","pepper, habanero","produce"],
#                   ["jalapeño pepper","pepper, jalapeño","produce"],
#                   ["jicama","jicama","produce"],
#                   ["lemon grass","lemon grass","produce"],
#                   ["mung beans","mung beans","produce"],
#                   ["mustard greens","mustard greens","produce"],
#                   ["navy beans","navy beans","produce"],
#                   ["onion family","onion family","produce"],
#                   ["patty pans","patty pans","produce"],
#                   ["radicchio","radicchio","produce"],
#                   ["rapini","rapini","produce"],
#                   ["red bell pepper","bell pepper, red","produce"],
#                   ["root vegetables","root vegetables","produce"],
#                   ["runner beans","runner beans","produce"],
#                   ["scallion","scallion","produce"],
#                   ["skirret","skirret","produce"],
#                   ["snap peas","snap peas","produce"],
#                   ["spaghetti squash","squash, spaghetti","produce"],
#                   ["tat soi","tat soi","produce"],
#                   ["water chestnut","water chestnut","produce"],
                   # fruits, from wikipedia list
#                   ["bilberry","bilberry","produce"],
#                   ["buffaloberry","buffaloberry","produce"],
#                   ["camucamu","camucamu","produce"],
#                   ["cempedak","cempedak","produce"],
#                   ["cherimoya","cherimoya","produce"],
#                   ["citron","citron","produce"],
#                   ["clementine","clementine","produce"],
#                   ["custard apple","custard apple","produce"],
#                   ["dragonfruit","dragonfruit","produce"],
#                   ["elderberry ","elderberry ","produce"],
#                   ["gooseberry ","gooseberry ","produce"],
#                   ["goumi","goumi","produce"],
#                   ["green apple","green apple","produce"],
#                   ["honeydew","honeydew","produce"],
#                   ["huckleberry","huckleberry","produce"],
#                   ["keppel fruit","keppel fruit","produce"],
#                   ["key lime","key lime","produce"],
#                   ["langsat","langsat","produce"],
#                   ["longan","longan","produce"],
#                   ["mamey sapote","mamey sapote","produce"],
#                   ["mamoncillo","mamoncillo","produce"],
#                   ["nannyberry","nannyberry","produce"],
#                   ["passion fruit","passion fruit","produce"],
#                   ["pawpaw","pawpaw","produce"],
#                   ["peanut butter fruit","peanut butter fruit","produce"],
#                   ["pitaya","pitaya","produce"],
#                   ["poha","poha","produce"],
#                   ["pommelo","pommelo","produce"],
#                   ["prickly pear ","prickly pear ","produce"],
#                   ["rose apple","rose apple","produce"],
#                   ["salak","salak","produce"],
#                   ["sapodilla","sapodilla","produce"],
#                   ["sea-buckthorn","sea-buckthorn","produce"],
#                   ["star fruit","star fruit","produce"],
#                   ["sugar apple","sugar apple","produce"],
#                   ["sunberry","sunberry","produce"],
#                   ["ugli fruit","ugli fruit","produce"],
#                   ["wineberry","wineberry","produce"],
                   ["абрикос","абрикос","produce"],
                   ["айва","айва","produce"],
                   ["американская хурма","хурма, американская","produce"],
                   ["ананас","ананас","produce"],
                   ["ангелика","ангелика","produce"],
                   ["анона игольчатая","анона игольчатая","produce"],
                   ["апельсин","апельсин","produce"],
                   ["арбуз","арбуз","produce"],
                   ["арония","арония","produce"],
                   ["банан","банан","produce"],
                   ["барбарис","барбарис","produce"],
                   ["бархатная хурма","хурма, бархатная","produce"],
                   ["белая смородина","смородина, белая","produce"],
                   ["бойзенова ягода","бойзенова ягода","produce"],
                   ["боярышник","боярышник","produce"],
                   ["брусника","брусника","produce"],
                   ["виноград","виноград","produce"],
                   ["вишня","вишня","produce"],
                   ["водосбор","водосбор","produce"],
                   ["волчья ягода","волчья ягода","produce"],
                   ["вороника","вороника","produce"],
                   ["голубика","голубика","produce"],
                   ["гранат","гранат","produce"],
                   ["гранат","гранат","produce"],
                   ["грейпфрут","грейпфрут","produce"],
                   ["гуава","гуава","produce"],
                   ["гуарана","гуарана","produce"],
                   ["джекфрут","джекфрут","produce"],
                   ["дуриан","дуриан","produce"],
                   ["ежевика","ежевика","produce"],
                   ["индийский финик","индийский финик","produce"],
                   ["ирга","ирга","produce"],
                   ["киви","киви","produce"],
                   ["клубника ","клубника ","produce"],
                   ["клюква","клюква","produce"],
                   ["кокосовый орех","кокосовый орех","produce"],
                   ["красная смородина","смородина, красная","produce"],
                   ["кумкват","кумкват","produce"],
                   ["лайм","лайм","produce"],
                   ["лимон","лимон","produce"],
                   ["локва","локва","produce"],
                   ["малина","малина","produce"],
                   ["манго","манго","produce"],
                   ["мангустан","мангустан","produce"],
                   ["мандарин","мандарин","produce"],
                   ["марабу","марабу","produce"],
                   ["медвежья ягода","медвежья ягода","produce"],
                   ["морошка","морошка","produce"],
                   ["мускусная дыня","мускусная дыня","produce"],
                   ["мушмула","мушмула","produce"],
                   ["нектарин","нектарин","produce"],
                   ["нефелиум","нефелиум","produce"],
                   ["нефелиум","нефелиум","produce"],
                   ["папайя","папайя","produce"],
                   ["персик","персик","produce"],
                   ["плод хлебного дерева","плод хлебного дерева","produce"],
                   ["плод шиповника","плод шиповника","produce"],
                   ["подорожник","подорожник","produce"],
                   ["ревень","ревень","produce"],
                   ["рябина","рябина","produce"],
                   ["слива","слива","produce"],
                   ["танжело","танжело","produce"],
                   ["танжерин","танжерин","produce"],
                   ["фейхоа","фейхоа","produce"],
                   ["фига","фига","produce"],
                   ["финик","финик","produce"],
                   ["хурма","хурма","produce"],
                   ["цереус гигантский","цереус гигантский ","produce"],
                   ["черная смородина","смородина, черная","produce"],
                   ["черная шелковица","черная шелковица","produce"],
                   ["шелковица","шелковица","produce"],
                   ["ююба","ююба","produce"],
                   ["яблоко-кислица","яблоко-кислица","produce"],
                   ["яблоко","яблоко","produce"],
                   ## seafood, from wikipedia list
#                   ["black cod","black cod","морепродукты"],
#                   ["blowfish","blowfish","морепродукты"],
#                   ["catfish","catfish","морепродукты"],
#                   ["clam","clam","морепродукты"],
#                   ["dungness crab","dungness crab","морепродукты"],
#                   ["halibut","halibut","морепродукты"],
#                   ["king crab","king crab","морепродукты"],
#                   ["lingcod","lingcod","морепродукты"],
#                   ["mahi mahi","mahi mahi","морепродукты"],
#                   ["monkfish","monkfish","морепродукты"],
#                   ["orange roughy","orange roughy","морепродукты"],
#                   ["pacific snapper","pacific snapper","морепродукты"],
#                   ["prawns","prawns","морепродукты"],
#                   ["red snapper","red snapper","морепродукты"],
#                   ["rock cod","rock cod","морепродукты"],
#                   ["rockfish","rockfish","морепродукты"],
#                   ["roe","roe","морепродукты"],
#                   ["snapper","snapper","морепродукты"],
#                   ["sole","sole","морепродукты"],
#                   ["surimi","surimi","морепродукты"],
#                   ["tilapia","tilapia","морепродукты"],
#                   ["tilefish","tilefish","морепродукты"],
#                   ["whitefish","whitefish","морепродукты"],
                   ["акула","акула","морепродукты"],
                   ["анчоус","анчоус","морепродукты"],
                   ["гребешок","гребешок","морепродукты"],
                   ["икра","икра","морепродукты"],
                   ["икра лосося","икра лосося","морепродукты"],
                   ["кальмар","кальмар","морепродукты"],
                   ["камбала","камбала","морепродукты"],
                   ["камбала-лиманда","камбала-лиманда","морепродукты"],
                   ["краб","краб","морепродукты"],
                   ["креветка","креветка","морепродукты"],
                   ["мерланг","мерланг","морепродукты"],
                   ["меч-рыба","меч-рыба","морепродукты"],
                   ["мидия","мидия","морепродукты"],
                   ["морское ушко","морское ушко","морепродукты"],
                   ["морской окунь","морской окунь","морепродукты"],
                   ["окунь","окунь","морепродукты"],
                   ["омар","омар","морепродукты"],
                   ["осетр","осетр","морепродукты"],
                   ["осьминог","осьминог","морепродукты"],
                   ["пикша","пикша","морепродукты"],
                   ["полосатый окунь","полосатый окунь","морепродукты"],
                   ["речной рак","речной рак","морепродукты"],
                   ["сайда","сайда","морепродукты"],
                   ["сардина","сардина","морепродукты"],
                   ["семга","семга","морепродукты"],
                   ["снежный краб","снежный краб","морепродукты"],
                   ["треска","треска","морепродукты"],
                   ["тунец","тунец","морепродукты"],
                   ["угорь","угорь","морепродукты"],
                   ["улитка","улитка","морепродукты"],
                   ["устрица","устрица","морепродукты"],
                   ["форель","форель","морепродукты"],
                   ["чилийский морской окунь","чилийский морской окунь","морепродукты"],
                   ["щука","щука","морепродукты"],
                   ## meats (garnered from wikipedia lists)
                   ["fuet","fuet","мясо"],
                   ["veal","veal","мясо"],
                   ["баранина","баранина","мясо"],
                   ["бекон","бекон","мясо"],
                   ["ветчина","ветчина","мясо"],
                   ["гамбургер","гамбургер","мясо"],
                   ["гусь","гусь","мясо"],
                   ["индейка","индейка","мясо"],
                   ["молодая баранина","молодая баранина","мясо"],
                   ["ростбиф","ростбиф","мясо"],
                   ["салями","салями","мясо"],
                   ["стейк","steak","мясо"],
                   ["утка","утка","мясо"],
                   ["цыпленок","цыпленок","мясо"],
                   ["чоризо","чоризо","мясо"],
                   ## my old list
                   ["tamarind water","tamarind water", "international"],
                   ["tamarind juice","tamarind juice", "international"],
                   ['vegetable broth','broth, vegetable', 'soups&sauces'],
                   ['fresh basil','basil, fresh', 'produce',],
                   ['light sugar brown','sugar, light brown', 'baking',],
                   ['balsamic vinegar','vinegar, balsamic', 'wines&oils',],
                   ['zuchini','zuchini', 'produce',],
                   ['avocado','avocado', 'produce',],
                   ['walnut','walnut', 'baking',],
                   ['celery','celery', 'produce',],
                   ['coriander seeds','coriander, seeds', 'spices',],
                   ['provolone cheese','cheese, provolone', 'dairy',],
                   ['galanga','galanga', 'produce',],
                   ['couscous','couscous', 'pastas',],
                   ['rice','rice', 'pastas',],
                   ['flour tortillas','tortillas, flour', 'dairy',],
                   ['olive oil','oil, olive', 'wines&oils',],
                   ['vanilla extract','vanilla extract', 'baking',],
                   ['red potato-skinned','potato, red-skinned', 'produce',],
                   ['powdered ginger','ginger, powdered', 'spices',],
                   ['roasted chili paste','roasted chili paste', 'international',],
                   ['curry powder','curry powder', 'spices',],
                   ['dried shrimp','shrimp, dried', 'international',],
                   ['dijon mustard','mustard, dijon', 'condiments',],
                   ['whole rock cod or snapper','whole rock cod or snapper', 'морепродукты',],
                   ['shells pasta','pasta, shells', 'pastas',],
                   ['green canned chiles','green chiles, canned', 'international',],
                   ['nutmeg','nutmeg', 'spices',],
                   ['sourdough bread','bread, sourdough', 'bread',],
                   ['corn oil','oil, corn', 'wines&oils',],
                   ['lemon grass','lemon grass', 'produce',],
                   ['feta cheese','cheese, feta', 'dairy',],
                   ['jack cheese','cheese, jack', 'dairy',],
                   ['grape tomato','tomato, grape', 'produce',],
                   ['cherry tomato','tomato, cherry', 'produce',],
                   ['spaghetti','spaghetti', 'pastas',],
                   ['cottage cheese','cheese, cottage', 'dairy',],
                   ['white onion','onion, white', 'produce',],
                   ['baking soda','baking soda', 'baking',],
                   ['garam masala','garam masala', 'spices',],
                   ['yogurt','yogurt', 'dairy',],
                   ['monkfish','monkfish', 'морепродукты',],
                   ['croutons','croutons', 'bread',],
                   ['ground coriander','coriander, ground', 'spices',],
                   ['chili powder','chili powder', 'spices',],
                   ['curly lettuce leaf','lettuce, curly leaf', 'produce',],
                   ['dark sugar brown','sugar, dark brown', 'baking',],
                   ['rice vinegar','vinegar, rice', 'international',],
                   ['pasta','pasta', 'pastas',],
                   ['sesame oil','oil, sesame', 'wines&oils',],
                   ['water','water', ''],
                   ['sour cream','sour cream', 'dairy',],
                   ['orange juice','orange juice', 'produce',],
                   ['spinach','spinach', 'produce',],
                   ['stick cinnamon','cinnamon, stick', 'spices',],
                   ['shrimp paste','shrimp paste', 'international',],
                   ['ground cinnamon','cinnamon, ground', 'spices',],
                   ['salad greens','salad greens', 'produce',],
                   ['garlic','garlic', 'produce',],
                   ['vegetable oil','oil, vegetable', 'wines&oils',],
                   ['peanut butter','peanut butter', 'bread',],
                   ['seeds ajowan','ajowan, seeds', 'spices',],
                   ['apple','apple', 'produce',],
                   ['cayenne','cayenne', 'spices',],
                   ['arugula','arugula', 'produce',],
                   ['linguine pasta','pasta, linguine', 'pastas',],
                   ['scallion','scallion', 'produce',],
                   ['egg','egg', 'dairy',],
                   ['lime','lime', 'produce',],
                   ['olives','olives', 'produce',],
                   ['basil, thai fresh','basil, fresh, thai', 'produce',],
                   ['bean sprouts','bean sprouts', 'produce',],
                   ['ricotta cheese','cheese, ricotta', 'dairy',],
                   ['parsley','parsley', 'produce',],
                   ['acorn squash','squash, acorn', 'produce',],
                   ['yellow onion','onion, yellow', 'produce',],
                   ['chiles, dried red','chiles, red, dried', 'produce',],
                   ['portobello mushroom','mushroom, portobello', 'produce',],
                   ['nappa cabbage','cabbage, nappa', 'produce',],
                   ['lime leaves','lime leaves', 'produce',],
                   ['butter','butter', 'dairy',],
                   ['bell red pepper','bell pepper, red', 'produce',],
                   ['mushroom','mushroom', 'produce',],
                   ['shallot','shallot', 'produce',],
                   ['cheddar cheese','cheese, cheddar', 'dairy',],
                   ['mozzarella cheese','cheese, mozzarella', 'dairy',],
                   ['squash','squash', 'produce',],
                   ['fish sauce','fish sauce', 'international',],
                   ['green curry paste','green curry paste', 'international',],
                   ['curly endive','endive, curly', 'produce',],
                   ['granulated sugar','sugar, granulated', 'baking',],
                   ['fresh cheese white goat','cheese, fresh white goat', 'dairy',],
                   ['cilantro stems','cilantro stems', 'produce',],
                   ['yellow cornmeal','cornmeal, yellow', 'baking',],
                   ['paprika','paprika', 'spices',],
                   ['chocolate chips','chocolate chips', 'baking',],
                   ['star anise','star anise', 'spices',],
                   ['brown sugar','sugar, brown', 'baking',],
                   ['roasted peanuts','peanuts, roasted', 'produce',],
                   ['fresh cilantro','cilantro, fresh', 'produce',],
                   ['honey','honey', 'baking',],
                   ['russet potato','potato, russet', 'produce',],
                   ['lemon juice','lemon juice', 'produce',],
                   ['carrot','carrot', 'produce',],
                   ['penne pasta','pasta, penne', 'pastas',],
                   ['red onion','onion, red', 'produce',],
                   ['shredded coconut','coconut, shredded', 'baking',],
                   ['peppered linguini','linguini, peppered', 'pastas',],
                   ['milk','milk', 'dairy',],
                   ['tahitian squash','squash, tahitian', 'produce',],
                   ['baking powder','baking powder', 'baking',],
                   ['tomato sauce','tomato sauce', 'soups&sauces',],
                   ['seeds mustard','mustard, seeds', 'spices',],
                   ['flat rice flour noodles','flat rice flour noodles', 'international',],
                   ['parmesan cheese','cheese, parmesan', 'pastas',],
                   ['mayonnaise','mayonnaise', 'bread',],
                   ['leek','leek', 'produce',],
                   ['zucchini','zucchini', 'produce',],
                   ['smoked cheese Gouda','cheese, smoked Gouda', 'dairy',],
                   ['lime juice','lime juice', 'produce',],
                   ['coconut milk','coconut milk', 'international',],
                   ['eggs','egg', 'dairy',],
                   ['salmon','salmon', 'морепродукты',],
                   ['lasagna pasta noodles','pasta, lasagna noodles', 'pastas',],
                   ['all purpose flour','flour, all purpose', 'baking',],
                   ['flour','flour, all purpose','baking',],
                   ['all-purpose flour','flour, all purpose','baking',],
                   ['ground cumin','cumin, ground', 'spices',],
                   ['cucumber','cucumber', 'produce',],
                   ['salsa','salsa', 'international',],
                   ['broccoli','broccoli', 'produce',],
                   ['rolled oats','rolled oats', 'pastas',],
                   ['tomato','tomato', 'produce',],
                   ['potato','potato', 'produce',],
                   ['white wine','wine, white', 'wines&oils',],
                   ['black ground pepper','black pepper, ground', 'spices',],
                   ['seeds cumin','cumin, seeds', 'spices',],
                   ['soy sauce','soy sauce', 'international',],
                   ['sesame seeds','sesame seeds', 'international',],
                   ['radicchio','radicchio', 'produce',],
                   ['salt','salt', 'baking',],
                   ['fresh ginger','ginger, fresh', 'produce',],
                   ['turmeric','turmeric', 'spices',],
                   ['chicken breast' ,'chicken, breast' , 'мясо',],
                   ['whole chicken' ,'chicken, whole' , 'мясо',],
                   ['chicken leg' ,'chicken, leg' , 'мясо',],
                   ['beef' ,'beef' , 'мясо',],
                   ['ground beef' ,'beef, ground' , 'мясо',],
                   ['pork' ,'pork' , 'мясо',],
                   ['turkey' ,'turkey' , 'мясо',],
                   ]

# THESE ARE STANDARD UNIT CONVERSIONS. You can simply translate unit names where
# you know them. Eliminate entries that are untranslatable or don't exist in your
# locale. And please add any additional units that you know of.
# Each unit is of the following format:
# ("unit1","unit2"):conversion_factor, where unit1 contains conversion_factor X unit2
# For example: 1 cup has 16 tablespoons.
CONVERTER_TABLE = {
    ("c", "Tbs"):16,
    ("lb", "oz"):16,
    ("Tbs", "tsp"):3,
    ("pt", "c"):2,
    ("qt", "c"):4,
    ("gallon", "qt"):4,
    ("l", "qt"):1.057,
    ("l", "ml"):1000,
    ("l", "cl"):100,
    ("l", "dl"):10,
    ("oz", "g"):28.35,
    ("fl oz","Tbs"):2,
    ("kg", "g"):1000,
    ("g", "mg"):1000,
    ("tsp", "drop"):76,
    ("oz", "dram"):16,
    ("dram", "grains"):27.34375,
    ("peck", "gallon"):2,
    ("bucket", "peck"):2,
    ("bushel", "bucket"):2,
    ("lb", "grains"):7000}

# DENSITIES of common foods. This allows us to convert between mass and volume.
# Translators: You may be best off translating the food names below, since lists
# of food densities can be hard to come by!
DENSITY_TABLE={
    "вода":1,
    "сок, виноградный":1.03,
    "vegetable broth":1,
    "broth, vegetable":1,
    "бульон, куриный":1,
    "молоко":1.029,
    "молоко, цельное":1.029,
    "молоко, пена":1.033,
    "молоко, 2%":1.031,
    "молоко, 1%":1.03,
    "кокосовое молоко":0.875,
    "пахта":1.03,
    "жирные сливки":0.994,
    "light cream":1.012,
    "half and half":1.025,
    "мед":1.420,
    "сахар-песок":1.550,
    "соль":2.165,
    "масло":0.911,
    "масло растительное":0.88,
    "масло оливковое":0.88,
    "кукурузное масло":0.88,
    "кунжутное масло":0.88,
    "мука общего назначения": 0.6,
    "мука пшеничная": 0.6,
    "крахмал кукурузный": 0.6,
    "сахарная пудра": 0.6
            }

# Standard unit names and alternate unit names that might appear.  For
# example: "c." is our standard abbreviation for cup.  "cup","c." or
# "cups" might appear in a recipe we are importing.  Each item of this
# list looks like this:
#
# ["standard", ["alternate1","alternate2","alternate3",...]]
#
# The first item should be the preferred abbreviation
# The second item should be the full name of the unit
# e.g. ["c.", ["cup",...]]
#
UNITS = [["bucket" , ["bucket", "buckets", "bckt."]],
         ["peck", ["peck", "pecks"]],
         ["bushel", ["bushel", "bushels", "bsh.", "bu.", "bu", "bsh", "bshl", "bshl."]],
         ["grains", ["grain", "grains"]],
         ["dram", ["dram", "drams"]],
         ["drop",["drop"]],
         ["fl oz",["fl oz","fluid ounce","fluid ounces","fl. oz.","fl oz.","fl. oz"]],
         ['',['each','ea','ea.']],
         ["tsp", ["teaspoon","tsp", "tsp.","tea spoon", "tsps.", "teaspoons", "tea spoons", "Teaspoon", "Teaspoons","t",'ts',"Ts.","Tsp.","Tsp"]],
         ["Tbs", ["tablespoon","tbs", "tbsp", "tbs.", "tbsp.", "table spoon", "tbsps.", "tablespoons", "Tablespoon", "T",'tb',"Tbs.", "Tbsp", "Tbsp."]],
         ["lb", [ "pound", "lb","lb.", "lbs.", "pounds"]],
         ["oz", [ "ounce", "oz","ounces", "oz."]],
         ["c", ["cup", "c.", "cups"]],
         ["qt", ["quart", "qt.", "quarts","Qt","Qt."]],
         ["pt", ["pint", "pt.", "pints"]],
         ["gallon", ["gallon", "gallons","gal."]],
         ["мл", ["миллилитр","мл", "мл","миллилитр"]],
         ["сл", ["сантилитр","сл", "сл", "сантилитр"]],
         ["дл", ["децилитр","дл", "дл","децилитр"]],
         ["л", ["литр", "л", "л", "литров",'литр']],
         ["г", ["грамм", "грамм", "г",'г','г','грамм']],
         ["мг", ["миллиграмм", "мг", "мг", "миллиграмм"]],
         ["кг", ["килограмм","кг", "кг", "килограмм"]],
         # These names aren't really convertible, but we want them to
         # be recognized as units...
         ['мало', ['мало']],
         ['средне', ['средне']],
         ['много', ['много']],
         ['луковица', ['луковица','луковиц']],
         ['целый', ['целый','целое','целая']],
         ['упаковка',['упаковка','пакет']],
         ['ящик', ['ящик']],
         ['банка', ['банка']],
         ['ломтей', ['ломтей','ломоть','ломти']],
         ]

METRIC_RANGE = (1,999)

# The following sets up unit groups. Users will be able to turn
# these on or off (American users, for example, would likely turn
# off metric units, since we don't use them).
# (User choice not implemented yet)
UNIT_GROUPS = {
    'metric mass':[('мг',METRIC_RANGE),
                   ('г',METRIC_RANGE),
                   ('кг',(1,None))],
    'metric volume':[('мл',METRIC_RANGE),
                     ('сл',(1,99)),
                     ('дл',(1,9)),
                     ('л',(1,None)),],
#    'imperial weight':[('grains',(0,27)),
#                       ('dram',(0.5,15)),
#                       ('oz',(0.25,32)),
#                       ('lb',(0.25,None)),
#                       ],
#    'imperial volume':[('drop',(0,3)),
#                       ('tsp',(0.125,5.9)),
#                       ('Tbs',(1,4)),
#                       ('c',(0.25,6)),
#                       ('pt',(1,1)),
#                       ('qt',(1,3)),
#                       ('gallon',(1,None)),
#                       ('peck',(1,2)),
#                       ('bucket',(1,2)),
#                       ('bushel',(1,None)),
#                       ('fl oz',(1,None)),
#                       ]
    }



# The units here need to correspond to the standard unit names defined
# above in UNITS
CROSS_UNIT_TABLE = {
    ## This if for units that require an additional
    ## bit of information -- i.e. to convert between
    ## volume and mass you need the density of an
    ## item.  In these cases, the additional factor
    ## will be provided as an 'item' that is then looked
    ## up in the dictionary referenced here (i.e. the density_table)
    ## currently, 'density' is the only keyword used
    ("pt", "lb"):['density',1],
    ("Tbs", "oz"):['density',0.5],
    ("c", "oz"):['density',8],
    ("pt", "oz"):['density',16],
    ("ml", "g"):['density',1],
    ('oz','fl oz'):['density',1],
    }

# The units here need to correspond to the standard unit names defined
# in UNITS.  These are some core conversions from mass-to-volume,
# assuming a density of 1 (i.e. the density of water).
VOL_TO_MASS_TABLE = {
    ("pt", "lb") : 1,
    ("Tbs", "oz") : 0.5,
    ("c", "oz") : 8,
    ("pt", "oz") : 16,
    ("ml", "g") : 1,
    ("ml", "mg") : 1000,
    ("ml", "kg"): 0.001,
    ("cl", "kg"): 0.01,
    ("cl", "g") : 10,
    ("dl", "kg") : 0.1,
    ("dl", "g") : 100,    
    ("l", "kg") : 1}

# TIME ABBREVIATIONS (this is new!)
TIME_ABBREVIATIONS = {
    'с':'секунд',
    'мин':'минут',
    'ч':'часов'
    }

# These functions are rather important! Our goal is simply to
# facilitate look ups -- if the user types in "tomatoes", we want to
# find "tomato." Note that the strings these functions produce will
# _never_ be shown to the user, so it's fine to generate nonsense
# words as well as correct answers -- our goal is to generate a list
# of possible hits rather than to get the plural/singular form "right".

irregular_plurals={
    "geese":"goose",
    }
import re
two_digit_plural_matcher = re.compile('[szxo]es$')
one_digit_plural_matcher = re.compile("[^s]s$")
v_plural_matcher = re.compile('ves')

def guess_singulars (s):
    if len(s)<3: return []
    rets = []
    if irregular_plurals.has_key(s):
        rets.append(irregular_plurals[s])
    if two_digit_plural_matcher.search(s):
        wrd=s[0:-2]
        if not wrd in rets: rets.append(wrd)
    if v_plural_matcher.search(s):
        rets.append(s[0:-3]+'f')
    if one_digit_plural_matcher.search(s): rets.append(s[0:-1])
    return rets

def guess_plurals (s):
    if not s: return []
    ret = [s+'s',s+'es']
    if s[-1]=='f': ret.append(s[0:-1]+'ves')
    return ret
    
IGNORE = ["and","with","of","for","cold","warm","finely","thinly","roughly","coarsely"]

NUMBERS = {
    (1.0/8):['eighth','an eigth'],
    (1.0/4):['quarter','a quarter'],
    (3.0/4):['three quarters'],
    (2.0/3):['two thirds'],
    (1.0/3):['third','a third'],
    (1.0/2):['one half','a half','half'],
    1:['an','a','one'],
    2:['two','a couple','a couple of','a pair of'],
    3:['three'],
    4:['four'],
    5:['five'],
    6:['six'],
    7:['seven'],
    8:['eight'],
    9:['nine'],
    10:['ten'],
    11:['eleven'],
    12:['twelve','a dozen'],
    20:['twenty'],
    30:['thirty'],
    40:['forty'],
    50:['fifty'],
    60:['sixty'],
    }

########NEW FILE########
__FILENAME__ = defaults_sk
# -*- coding: utf-8 -*-
#
## we set up default information.
## first, easy to maintain lists which can eventually be moved to
## files.

# TRANSLATOR WARNING: DO NOT TRANSLATE THE FIELD NAMES: ONLY THE VALUES!!!
CREDITS = "Branislav Brango Hanáček"

# only translate the items in the list [..] (and feel free to create categories
# that make sense for your locale -- no need to translate these ones). DO NOT
# translate 'cuisine','rating','source' or 'category'
fields={'cuisine': [
                    'Americká',
                    'Čínska',
                    'Čínska kantonská',
                    'Čínska kantonská',
                    'Čínska šanghajská',
                    'Čínska pekingská',
                    'Čínska sečuánska',
                    'Česká',
                    'Francouzská',
                    'Indická',
                    'Japonská',
                    'Juhozápadná',
                    'Maďarská',
                    'Mexická',
                    'Nemecká',
                    'Nemecká porýnie',
                    'Slovenská',
                    'Talianska',
                    'Thajská',
                    'Vietnamská'
                   ],
        'rating' : [
                    'Výnikajúce',
                    'Výborné',
                    'Dobré',
                    'Jedlé',
                    'Slabé',
                    'Nechutné'
                   ],
        'source' : [],
        'category' : [
                      'Cestovinový šalát',
                      'Cestoviny bezmäsité',
                      'Cestoviny skoro bezmäsité',
                      'Cestoviny s mäsom',
                      'Grilovanie',
                      'Jedlá z bravčového mäsa',
                      'Jedlá z diviny',
                      'Jedlá z húb',
                      'Jedlá z hovädzieho mäsa',
                      'Jedlá z hydiny',
                      'Jedlá z mäsa',
                      'Jedlá z rýb',
                      'Jedlá z teľacieho mäsa',
                      'Konzervovanie',
                      'Konzervovanie - nátierky',
                      'Šalát',
                      'Polievka',
                      'Polievka bezmäsitá',
                      'Polievka mäsová',
                      'Polievka skoro bezmäsitá',
                      'Polievka z rýb', 
                      'Predjedlo',
                      'Skoro bezmäsité jedlá',
                      'Zákusok',
                      'Zeleninový šalát',
                      'Zeleninový šalát s mäsom'
                     ],
                  }

# In English, there are a heck of a lot of synonyms. This is a list
# for those synonyms.  ["preferred word","alternate word","alternate word"]
# If there are none of these that you can think of in your language, just
# set this to:
SYNONYMS=[]

# a dictionary key=ambiguous word, value=list of possible non-ambiguous terms
AMBIGUOUS = {}


# triplicates ITEM, KEY, SHOPPING CATEGORY
#
# These will be defaults. They should include whatever foods might be
# standard for your locale, with whatever sensible default categories
# you can think of (again, thinking of your locale, not simply translating
# what I've done).
INGREDIENT_DATA = [
# základné potraviny
                   ["voda","voda","základné potraviny"],
                   ["hnedý cukor","hnedý cukor","základné potraviny"],
                   ["cukor","cukor","základné potraviny"],
                   ["balzamikový ocot","balzamikový ocot","základné potraviny"],
                   ["vínny ocot","vínny ocot","základné potraviny"],
                   ["jablčný ocot","jablčný ocot","základné potraviny"],
                   ["ryžové víno","ryžové víno","základné potraviny"],
                   ["ryža","ryža","základné potraviny"],
                   ["guľatá ryža","guľatá ryža","základné potraviny"],
                   ["ryža basmati","ryža basmati","základné potraviny"],
                   ["dlhozrnná ryža","dlhozrnná ryža","základné potraviny"],
                   ["ryža natural","ryža natural","základné potraviny"],
                   ["kuskus","kuskus","základné potraviny"],
                   ["špagety","špagety","základné potraviny"],
                   ["cestoviny","cestoviny","základné potraviny"],
                   ["chlieb","chlieb","základné potraviny"],
                   ["pečivo","pečivo","základné potraviny"],
                   ["žemľa","žemľa","základné potraviny"],
                   ["horčica","horčica","základné potraviny"],
                   ["kremžská horčica","kremžská horčica","základné potraviny"],
                   ["dijonská horčica","dijonská horčica","základné potraviny"],
                   ["krutóny","krutóny","základné potraviny"],
                   ["pomarančová šťava","pomarančová šťava","základné potraviny"],
                   ["citrónová šťava","citrónová šťava","základné potraviny"],
                   ["vajce","vajce","základné potraviny"],
                   ["med","med","základné potraviny"],
                   ["droždie","droždie","základné potraviny"],
                   ["sušené droždie","sušené droždie","základné potraviny"],
                   ["paradajkový pretlak","paradajkový pretlak","základné potraviny"],
                   ["hladká múka","hladká múka","základné potraviny"],
                   ["polohrubá múka","polohrubá múka","základné potraviny"],
                   ["hrubá múka","hrubá múka","základné potraviny"],
                   ["celozrnná múka","celozrnná múka","základné potraviny"],
                   ["krupica","krupica","základné potraviny"],
                   ["biele víno", "biele víno","základné potraviny"],
                   ["červené víno", "červené víno","základné potraviny"],
                   ["soľ", "soľ","základné potraviny"],
                   ["morská soľ", "morská soľ","základné potraviny"],

# oleje a tuky
                   ["olej","olej","oleje a tuky"],
                   ["slnečnicový olej","slnečnicový olej","oleje a tuky"],
                   ["olivový olej","olivový olej","oleje a tuky"],
                   ["sójový olej","sójový olej","oleje a tuky"],
                   ["sezamový olej","sezamový olej","oleje a tuky"],
                   ["ľanový olej","ľanový olej","oleje a tuky"],
                   ["bravčová masť","bravčová masť","oleje a tuky"],
                   ["husacia masť","husacia masť","oleje a tuky"],
                   ["kačacia masť","kačacia masť","oleje a tuky"],
                   ["vlašský orech","vlašský orech","oleje a tuky"],
                   ["arašídy","arašídy","oleje a tuky"],
                   ["pražené arašídy","pražené arašídy","oleje a tuky"],
                   ["orechy kešu","orechy kešu","oleje a tuky"],
                   ["majonéza","majonéza","oleje a tuky"],
                   ["sezamové semená","sezamové semená","oleje a tuky"],
                   ["slnečnicové semená","slnečnicové semená","oleje a tuky"],
                   ["píniové semená","píniové semená","oleje a tuky"],

# mlieko a mliečne výrobky
                   ["mlieko","mlieko","mlieko a mliečne výrobky"],
                   ["maslo","maslo","mlieko a mliečne výrobky"],
                   ["syr","syr","mlieko a mliečne výrobky"],
                   ["strúhaný syr","strúhaný syr","mlieko a mliečne výrobky"],
                   ["syr Niva","syr Niva","mlieko a mliečne výrobky"],
                   ["camembert","camembert","mlieko a mliečne výrobky"],
                   ["bryndza","bryndza","mlieko a mliečne výrobky"],
                   ["tavený syr","tavený syr","mlieko a mliečne výrobky"],
                   ["tvaroh","tvaroh","mlieko a mliečne výrobky"],
                   ["syr feta","syr feta","mlieko a mliečne výrobky"],
                   ["parmezán","parmezán","mlieko a mliečne výrobky"],
                   ["mozarella","mozarella","mlieko a mliečne výrobky"],
                   ["jogurt","jogurt","mlieko a mliečne výrobky"],
                   ["kefír","kefír","mlieko a mliečne výrobky"],
                   ["sladká smotana","sladká smotana","mlieko a mliečne výrobky"],
                   ["kyslá smotana","kyslá smotana","mlieko a mliečne výrobky"],
                   ["syr ricotta","syr ricotta","mlieko a mliečne výrobky"],
                   ["čedar","čedar","mlieko a mliečne výrobky"],
# bylinky
                   ["koriandrová vňať","koriandrová vňať","bylinky"],
                   ["pažítka","pažítka","zelenina"],
                   ["petržlenová vňať","petržlenová vňať","zelenina"],
                   ["zelerová vňať","zelerová vňať","zelenina"],
# strukoviny
                   ["bôb","bôb","strukoviny"],
                   ["čierna fazuľa","čierna fazuľa","strukoviny"],
                   ["cícer","cícer","strukoviny"],
                   ["fazuľa azuki","fazuľa azuki","strukoviny"],
                   ["fazuľa borlotti","fazuľa borlotti","strukoviny"],
                   ["fazuľa","fazuľa","strukoviny"],
                   ["fazuľa šarlátová","fazuľa šarlátová","strukoviny"],
                   ["fazuľa mungo","fazuľa mungo","strukoviny"],
                   ["fazuľové klíčky","fazuľové klíčky","strukoviny"],
                   ["maslová fazuľa","maslová fazuľa","strukoviny"],
                   ["sója","sója","strukoviny"],
                   ["šošovica","šošovica","strukoviny"],
# koreniny
                   ["aníz","aníz","korenie"],
                   ["citrónová tráva","citrónová tráva","korenie"],
                   ["čilli paprička","čilli paprička","korenie"],
                   ["paprika jalapeno","paprika jalapeno","korenie"],
                   ["zázvor","zázvor","korenie"],
                   ["mletý zázvor","mletý zázvor","korenie"],
                   ["koriandrové semeno","koriandrové semeno", "korenie"],
                   ["bazalka čerstvá","bazalka čerstvá", "korenie"],
                   ["bazalka sušená","bazalka sušená", "korenie"],
                   ["garam masala","garam masala", "korenie"],
                   ["škorica celá","škorica celá", "korenie"],
                   ["škorica mletá","škorica mletá", "korenie"],
                   ["rasca celá","rasca celá", "korenie"],
                   ["rasca mletá","rasca mletá", "korenie"],
                   ["čierne korenie celé","čierne korenie celé", "korenie"],
                   ["čierne korenie mleté","čierne korenie mleté", "korenie"],
                   ["biele korenie celé","biele korenie celé", "korenie"],
                   ["biele korenie mleté","biele korenie mleté", "korenie"],
                   ["zelené korenie celé","zelené korenie celé", "korenie"],
                   ["zelené korenie mleté","zelené korenie mleté", "korenie"],
                   ["salsa","salsa", "korenie"],
                   ["sójová omáčka","sójová omáčka", "korenie"],
                   ["sójová omáčka svetlá","sójová omáčka svetlá", "korenie"],

# huby
                   ["bedľa","bedľa","huby"],
                   ["huby","huby","huby"],
                   ["šampiňóny","šampiňóny","huby"],
                   ["kuriatka","kuriatka","huby"],
                   ["huby šintake","huby šintake","huby"],
                   ["hliva ustricová","hliva ustricová","huby"],
# zelenina
                   ["artičoky","artičoky","zelenina"],
                   ["avokádo","avokádo","zelenina"],
                   ["baklažán","baklažán","zelenina"],
                   ["biela reďkovka","biela reďkovka","zelenina"],
                   ["brokolica","brokolica","zelenina"],
                   ["bruselská kapusta","bruselská kapusta","zelenina"],
                   ["cesnak","cesnak","zelenina"],
                   ["cibuľa","cibuľa","zelenina"],
                   ["biela cibuľa","biela cibuľa","zelenina"],
                   ["červená cibuľa","červená cibuľa","zelenina"],
                   ["cukini","cukini","zelenina"],
                   ["cukrová repa","cukrová repa","zelenina"],
                   ["cvikľa","cvikľa","zelenina"],
                   ["čínska kapusta (bok choy)","čínska kapusta (bok choy)","zelenina"],
                   ["červená paprika","červená paprika","zelenina"],
                   ["dyňa","dyňa","zelenina"],
                   ["envídia","envídia","zelenina"],
                   ["fenikel","fenikel","zelenina"],
                   ["frisee šalát","frisee šalát","zelenina"],
                   ["hlávkový šalát","hlávkový šalát","zelenina"],
                   ["hrach","hrach","strukoviny"],
                   ["jarná cibuľka","jarná cibuľka","zelenina"],
                   ["jeruzalemské artičoky","jeruzalemské artičoky","zelenina"],
                   ["kaleráb","kaleráb","zelenina"],
                   ["kapusta","kapusta","zelenina"],
                   ["karfiol","karfiol","zelenina"],
                   ["koreňová zelenina","koreňová zelenina","zelenina"],
                   ["koriander","koriander","korenie"],
                   ["kukurica","kukurica","obilniny"],
                   ["kvaka","kvaka","zelenina"],
                   ["kvasená uhorka","kvasená uhorka","zelenina"],
                   ["šalátová uhorka","šalátová uhorka","zelenina"],
                   ["uhorka","uhorka","zelenina"],
                   ["šalotka","šalotka","zelenina"],
                   ["špargľa","špargľa","zelenina"],
                   ["špenát","špenát","zelenina"],
                   ["žerucha","žerucha","zelenina"],
                   ["žihľava","žihľava","zelenina"],
                   ["mrkva","mrkva","zelenina"],
                   ["paštrnák","paštrnák","zelenina"],
                   ["pór","pór","zelenina"],
                   ["paprika","paprika","zelenina"],
                   ["paradajka","paradajka","zelenina"],
                   ["kokteilové paradajky","kokteilové paradajky","zelenina"],
                   ["petržlen","petržlen","zelenina"],
                   ["radicchio","radicchio","zelenina"],
                   ["reďkovka","reďkovka","zelenina"],
                   ["rukola","rukola","zelenina"],
                   ["sladký zemiak","sladký zemiak","zelenina"],
                   ["tekvica","tekvica","zelenina"],
                   ["uhorka","uhorka","zelenina"],
                   ["vodný gaštan","vodný gaštan","zelenina"],
                   ["wasabi","wasabi","zelenina"],
                   ["zelená fazuľka","zelená fazuľka","strukoviny"],
                   ["zelená fazuľka","zelená fazuľka","zelenina"],
                   ["zeler","zeler","zelenina"],
                   ["zemiak","zemiak","zelenina"],
                   ["olivy zelené","olivy zelené","zelenina"],
                   ["olivy čierne","olivy čierne","zelenina"],
# Ovocie
                   ["ananás","ananás","ovocie"],
                   ["ananásový melón","ananásový melón","ovocie"],
                   ["arónia","arónia","ovocie"],
                   ["banán","banán","ovocie"],
                   ["baza ","baza ","ovocie"],
                   ["biela ríbezľa","biela ríbezľa","ovocie"],
                   ["borievka","borievka","ovocie"],
                   ["broskyňa","broskyňa","ovocie"],
                   ["brusnica ","brusnica ","ovocie"],
                   ["citrón","citrón","ovocie"],
                   ["clementine","clementine","ovocie"],
                   ["čerešňa","čerešňa","ovocie"],
                   ["černica","černica","ovocie"],
                   ["červená ríbezľa","červená ríbezľa","ovocie"],
                   ["čierna ríbezľa","čierna ríbezľa","ovocie"],
                   ["dráč ","dráč ","ovocie"],
                   ["dula","dula","ovocie"],
                   ["durian","durian","ovocie"],
                   ["ďatľa","ďatľa","ovocie"],
                   ["figa","figa","ovocie"],
                   ["granátové jablko","granátové jablko","ovocie"],
                   ["grepfruit","grepfruit","ovocie"],
                   ["guáve ","guáve ","ovocie"],
                   ["hloh","hloh","ovocie"],
                   ["hrozno","hrozno","ovocie"],
                   ["jablko","jablko","ovocie"],
                   ["jahoda ","jahoda ","ovocie"],
                   ["jarabina","jarabina","ovocie"],
                   ["jojoba","jojoba","ovocie"],
                   ["kiwi","kiwi","ovocie"],
                   ["kokosový orech","kokosový orech","ovocie"],
                   ["liči","liči","ovocie"],
                   ["limeta","limeta","ovocie"],
                   ["malina","malina","ovocie"],
                   ["mandarínka","mandarínka","ovocie"],
                   ["mango","mango","ovocie"],
                   ["maracuja","maracuja","ovocie"],
                   ["marhuľa","marhuľa","ovocie"],
                   ["medový melón","medový melón","ovocie"],
                   ["mišpuľa","mišpuľa","ovocie"],
                   ["moruša","moruša","ovocie"],
                   ["nektarinka","nektarinka","ovocie"],
                   ["ostružina moruška","ostružina moruška","ovocie"],
                   ["papája","papája","ovocie"],
                   ["pitaya","pitaya","ovocie"],
                   ["plané jablko","plané jablko","ovocie"],
                   ["pomaranč","pomaranč","ovocie"],
                   ["rakytník","rakytník","ovocie"],
                   ["rebarbora","rebarbora","zelenina"],
                   ["trnka","trnka","zelenina"],
                   ["slivka","slivka","ovocie"],
                   ["vodný melón ","vodný melón ","ovocie"],
                   ["zelené jablko","zelené jablko","ovocie"],
## ryby a morské potvory
                   ["ančivičky","ančivičky","ryby a morské potvory"],
                   ["okún","okún","ryby a morské potvory"],
                   ["treska","treska","ryby a morské potvory"],
                   ["úhor","úhor","ryby a morské potvory"],
                   ["platesa","platesa","ryby a morské potvory"],
                   ["šťuka","šťuka","ryby a morské potvory"],
                   ["sardinka","sardinka","ryby a morské potvory"],
                   ["losos","losos","ryby a morské potvory"],
                   ["morský okún","morský okún","ryby a morské potvory"],
                   ["žralok","žralok","ryby a morské potvory"],
                   ["chňapáč","chňapáč","ryby a morské potvory"],
                   ["jeseter","jeseter","ryby a morské potvory"],
                   ["mečiar","mečiar","ryby a morské potvory"],
                   ["pstruh","pstruh","ryby a morské potvory"],
                   ["tuniak","tuniak","ryby a morské potvory"],
                   ["belica","belica","ryby a morské potvory"],
                   ["ikry","ikry","ryby a morské potvory"],
                   ["kaviár","kaviár","ryby a morské potvory"],
                   ["krab","krab","ryby a morské potvory"],
                   ["rak","rak","ryby a morské potvory"],
                   ["homár","homár","ryby a morské potvory"],
                   ["kreveta","kreveta","ryby a morské potvory"],
                   ["garnát","garnát","ryby a morské potvory"],
                   ["mäkkýš","mäkkýš","ryby a morské potvory"],
                   ["mušľa","mušľa","ryby a morské potvory"],
                   ["chobotnica","chobotnica","ryby a morské potvory"],
                   ["ustrica","ustrica","ryby a morské potvory"],
                   ["slimák","slimák","ryby a morské potvory"],
                   ["kalmar","kalmar","ryby a morské potvory"],
                   ["hrebenatka","hrebenatka","ryby a morské potvory"],
## mäso a mäsové výrobky
                   ["slanina","slanina","mäso a údeniny"],
                   ["oravská slanina","oravská slanina","mäso a údeniny"],
                   ["anglická slanina","anglická slanina","mäso a údeniny"],
                   ["klobása","klobása","mäso a údeniny"],
                   ["párky","párky","mäso a údeniny"],
                   ["saláma","saláma","mäso a údeniny"],
                   ["maďarská saláma","maďarská saláma","mäso a údeniny"],
                   ["suchá saláma","suchá saláma","mäso a údeniny"],
                   ["šunka","šunka","mäso a údeniny"],
                   ["baranie mäso","baranie mäso","mäso a údeniny"],
                   ["jahňacie mäso","jahňacie mäso","mäso a údeniny"],
                   ["teľacie mäso","teľacie mäso","mäso a údeniny"],
                   ["steak","steak","mäso a údeniny"],
                   ["hamburger","hamburger","mäso a údeniny"],
                   ["bravčové mäso","bravčové mäso","mäso a údeniny"],
                   ["hovädzie mäso","hovädzie mäso","mäso a údeniny"],
                   ["kuracie mäso","kuracie mäso","mäso a údeniny"],
                   ["slepačie mäso","slepačie mäso","mäso a údeniny"],
                   ["morčacie mäso","morčacie mäso","mäso a údeniny"],
                   ["husacie mäso","husacie mäso","mäso a údeniny"],
                   ["kačacie mäso","kačacie mäso","mäso a údeniny"],
                   ["kuracie prsia","kuracie prsia","mäso a údeniny"],
                   ["kuracie krídla","kuracie krídla","mäso a údeniny"],
                   ["morčacie prsia","morčacie prsia","mäso a údeniny"],
                   ["tlačenka","tlačenka","mäso a údeniny"],
                   ["celé kura","celé kura","mäso a údeniny"],
                   ["celá sliepka","celá sliepka","mäso a údeniny"],
                   ["bravčové kolienko","bravčové kolienko","mäso a údeniny"],
                   ["bravčové paprčky","bravčové paprčky","mäso a údeniny"],
                   ["údené karé","údené karé","mäso a údeniny"],
                   ["bravčová krkovička","bravčová krkovička","mäso a údeniny"],
                   ["bravčová panenka","bravčová panenka","mäso a údeniny"],
                   ["sviečkovica","sviečkovica","mäso a údeniny"]
                   ]

# THESE ARE STANDARD UNIT CONVERSIONS. You can simply translate unit names where
# you know them. Eliminate entries that are untranslatable or don't exist in your
# locale. And please add any additional units that you know of.
CONVERTER_TABLE = {
    ("Šálka", "ČL"):16,
    ("PL", "ČL"):3,
    ("l", "ml"):1000,
    ("l", "cl"):100,
    ("l", "dl"):10,
    ("kg", "g"):1000,
    ("g", "mg"):1000
    }

# DENSITIES of common foods. This allows us to convert between mass and volume.
DENSITY_TABLE={
    "voda":1,
    "juice, grape":1.03,
    "vegetable broth":1,
    "broth, vegetable":1,
    "broth, chicken":1,
    "milk":1.029,
    "milk, whole":1.029,
    "milk, skim":1.033,
    "milk, 2%":1.031,
    "milk, 1%":1.03,
    "coconut milk":0.875,
    "buttermilk":1.03,
    "heavy cream":0.994,
    "light cream":1.012,
    "half and half":1.025,
    "honey":1.420,
    "sugar, white":1.550,
    "salt":2.165,
    "butter":0.911,
    "oil, vegetable":0.88,
    "oil, olive":0.88,
    "oil, corn":0.88,
    "oil, sesame":0.88,
    "flour, all purpose": 0.6,
    "flour, whole wheat": 0.6,
    "corn starch": 0.6,
    "sugar, powdered": 0.6,
    "sugar, confectioners": 0.6
            }

# Stand unit names and alternate unit names that might appear.
# For example: "c." is our standard for cup. "cup","c." or "cups" might appear
# in a recipe we are importing.
# Each item of this list looks like this:
#
# ["standard", ["alternate1","alternate2","alternate3",...]]

UNITS = [
         ["ČL",    ["čajová lyžička","ČL.", "čajové lyžičky", "čajovej lyžičky", "čajových lyžičiek"]],
         ["PL",    ["polievková lyžica","PL.", "polievkové lyžice", "polievovej lyžice", "polievkových lyžíc"]],
         ["šálka", ["šálky", "šálok"]],
         ["ml",    ["mililiter", "ml.", "mililitre", "mililitrov", "mililitra"]],
         ["cl",    ["centiliter","cl.", "centilitre", "centiliterov", "centilitra"]],
         ["dl",    ["deciliter","dl.", "decilitre","decilitrov", "decilitra"]],
         ["l",     ["liter", "l.", "litre", "litrov", "litra"]],
         ["g",     ["gram", "g.", "gramy", "gramov", "gramu"]],
         ["mg",    ["miligram", "mg.", "miligramy", "miligramov", "miligramu"]],
         ["kg",    ["kilogram","kg.", "kilogramy",  "kilogramov", "kilogramu"]]
         ]

WEIGHTS = ['g','mg','kg']
VOLUMES = ['ČL','PL','ml','cl','dl','l', 'šálka']

# The following sets up unit groups. Users will be able to turn
# these on or off (American users, for example, would likely turn
# off metric units, since we don't use them).
METRIC_RANGE = (1,999)

UNIT_GROUPS = {
    'metric mass':[('mg',METRIC_RANGE),
                   ('g',METRIC_RANGE),
                   ('kg',(1,None))],
    'metric volume':[('ml',METRIC_RANGE),
                     ('cl',(1,99)),
                     ('dl',(1,9)),
                     ('l',(1,None)),]
    }



# The units here need to correspond to the standard unit names defined
# above in UNITS
CROSS_UNIT_TABLE = {
    ## This if for units that require an additional
    ## bit of information -- i.e. to convert between
    ## volume and mass you need the density of an
    ## item.  In these cases, the additional factor
    ## will be provided as an 'item' that is then looked
    ## up in the dictionary referenced here (i.e. the density_table)
    ## currently, 'density' is the only keyword used
    ("ml", "g"):['density',1]}

# The units here need to correspond to the standard unit names defined
# in UNITS
VOL_TO_MASS_TABLE = {
    ("ml", "g") : 1,
    ("ml", "mg") : 1000,
    ("ml", "kg"): 0.001,
    ("cl", "kg"): 0.01,
    ("cl", "g") : 10,
    ("dl", "kg") : 0.1,
    ("dl", "g") : 100,    
    ("l", "kg") : 1}
    

# These functions are rather important! Our goal is simply to
# facilitate look ups -- if the user types in "tomatoes", we want to
# find "tomato." Note that the strings these functions produce will
# _never_ be shown to the user, so it's fine to generate nonsense
# words as well as correct answers -- our goal is to generate a list
# of possible hits rather than to get the plural/singular form "right".

# A quick look at the wikipedia suggests that plural forms of nouns
# may be rather complex
# http://en.wikipedia.org/wiki/Slovak_declension#Nouns so I won't
# attempt it myself.

# If someone implements this at a later date, please note that if
# guess_singulars() returns something, guess_plurals() usually won't
# be called (Gourmet uses these when trying to find a key for a word
# -- if it sees "Tomatoes" and believes that the word is "Tomato", it
# won't bother trying to guess "Tomatoeses".

def guess_singulars (s): return []
def guess_plurals (s): return []

IGNORE=[]

NUMBERS = {
    }

########NEW FILE########
__FILENAME__ = defaults_sv
# -*- coding: utf-8 -*-
#
# we set up default information for our locale.
# Translators should use this file as the basis of their translation.
# Copy this file and rename it for you locale.
#
# For example, Spanish uses:
# defaults_es.py
#
# British English uses:
# defaults_en_GB.py
#
# Please fill in the below fields:

# Language: Swedish
# Translator: jens persson (jens@persson.cx)
# Last-updated: 2006-06-28

# TRANSLATOR WARNING: DO NOT TRANSLATE THE FIELD NAMES: ONLY THE VALUES!!!

# only translate the items in the list [..] (and feel free to create
# categories that make sense for your locale -- no need to translate
# these ones). DO NOT translate 'cuisine','rating','source' or
# 'category'

# The below are Gourmet's standard fields and the default categories for them.
# Do not translate the field names ('cuisine','rating','source,'category').
# Instead, fill in the list with categories that make sense for your locale.
# Feel free to change the number or content of categories to be consistent
# with what users in your locale are likely to be familiar with.

fields={'cuisine': ['Husmanskost','Italienskt','Thai',
                    'Indiskt','Spanskt','Asian/Vietnamese',
                    'Asian/Chinese','Asian/Japanese',],
        'rating' : ['Fantastiskt','Utmärkt','Bra','Hyfsat','Dåligt'],
        'source' : [],
        'category' : ['Efterrätt','Förrätt','Varmrätt',
                      'Sallad','Soppa','Bröd'],
                  }

# In English, there are a heck of a lot of synonyms. This is a list
# for those synonyms.  ["preferred word","alternate word","alternate word"]
# If there are none of these that you can think of in your language, just
# set this to:
# SYNONYMS=[]
SYNONYMS=[
    # the first item of each list is the default
    ["aubergin","äggplanta"],
    ["squash","zucchini"],
    ["stenbit","sjurygg"],
    ["morot","morötter"],
    ["soja","soya"],
    ["kvarg","kesella"],
    ["palsternacka","palsternackor"],
    ["gul lök","gula lökar","lök","lökar"],
    ["gurka","slanggurka"],
    ]

# A DICTIONARY CONTAINING INGREDIENT KEYS AND NDBNO for the USDA
# nutritional database. For these items, we will have nutritional
# information by default.

NUTRITIONAL_INFO = {}

# a dictionary for ambiguous words.
# key=ambiguous word, value=list of possible non-ambiguous terms
#
# Translators: if you have a word that has more than one food meaning
# in your language, you can add an entry as follow

# AMBIGUOUS = {
#              'word':['meaning1','meaning2','meaning3'],
#             }

AMBIGUOUS = {}


# triplicates ITEM, KEY, SHOPPING CATEGORY
# These will be defaults.

# They should include whatever foods might be standard for your
# locale, with whatever sensible default categories you can think of
# (again, thinking of your locale, not simply translating what I've
# done).

# Items provided here will automatically be recognized and go onto the
# given category in a user's shopping list by default.

# Don't feel obligated to translate every item -- especially since not
# all items will be common for all locales. However, the more items
# you can put here, the more the user will get the sense that gourmet
# "knows" about foods that they enter.

# I generated the below list using the wikipedia entry on foods as my
# starting point. You may want to do something similar for your
# locale.  Also, if the syntax of the below is too complicated, you
# can send me a list of category headings and ingredients for your
# locale and I'll do the necessary formatting <Thomas_Hinkle@alumni.brown.edu>

INGREDIENT_DATA = [["ananas","ananas","Frukt och grönt"],
	["anis","anis","Kryddor"],
	["ankbröst","ankbröst","Kött"],
	["apelsin","apelsin","Frukt och grönt"],
	["apelsinjuice","apelsinjuice","Mejeri"],
	["apelsinskal","apelsinskal","Frukt och grönt"],
	["aprikos","aprikos","Frukt och grönt"],
	["aromat","aromat","Kryddor"],
	["aromsalt","aromsalt","Kryddor"],
	["aubergine","aubergine","Frukt och grönt"],
	["avokado","avokado","Frukt och grönt"],
	["bacon","bacon","Kött"],
	["bakpulver","bakpulver","Torrvaror"],
	["banan","banan","Frukt och grönt"],
	["basilika","basilika","Kryddor"],
	["basilikaolja","basilikaolja","Kryddor"],
	["bearnaisesås","bearnaisesås","Djupfryst"],
	["biff","biff","Kött"],
	["bladpersilja","bladpersilja","Frukt och grönt"],
	["blandfärs","blandfärs","Kött"],
	["blomkål","blomkål","Frukt och grönt"],
	["bockhornsklöver","bockhornsklöver","Kryddor"],
	["broccoli","broccoli","Frukt och grönt"],
	["brysselkål","brysselkål","Frukt och grönt"],
	["buljongtärning","buljongtärning","Kryddor"],
	["capsaicin","capsaicin","Kryddor"],
	["carambola","carambola","Frukt och grönt"],
	["cayennepeppar","cayennepeppar","Kryddor"],
	["chilipeppar","chilipeppar","Kryddor"],
	["chilipulver","chilipulver","Kryddor"],
	["chilisås","chilisås","Torrvaror"],
	["citron","citron","Frukt och grönt"],
	["citrongräs","citrongräs","Kryddor"],
	["citronmeliss","citronmeliss","Kryddor"],
	["coctailbär","coctailbär","Torrvaror"],
	["cottage cheese","cottage cheese","Ost"],
	["crème fraiche","crème fraiche","Mejeri"],
	["curry","curry","Kryddor"],
	["dadelpalm","dadelpalm","Frukt och grönt"],
	["dansk körvel","dansk körvel","Kryddor"],
	["dessertost","dessertost","Ost"],
	["dill","dill","Frukt och grönt"],
	["dragon","dragon","Kryddor"],
	["endiv","endiv","Frukt och grönt"],
	["entrecôte","entrecôte","Kött"],
	["falukorv","falukorv","Kött"],
	["fikon","fikon","Frukt och grönt"],
	["filmjölk","filmjölk","Mejeri"],
	["fiskbuljong","fiskbuljong","Kryddor"],
	["flintastek","flintastek","Kött"],
	["florsocker","florsocker","Torrvaror"],
	["flytande margarin","flytande margarin","Mejeri"],
	["fläskfilé","fläskfilé","Kött"],
	["fläsk","fläsk","Kött"],
	["fläskfärs","fläskfärs","Kött"],
	["fransk senap","fransk senap","Torrvaror"],
	["fänkål","fänkål","Frukt och grönt"],
	["färskost","färskost","Ost"],
	["galiamelon","galiamelon","Frukt och grönt"],
	["garam masala","garam masala","Kryddor"],
	["grahamsmjöl","grahamsmjöl","Torrvaror"],
	["granatäpple","granatäpple","Frukt och grönt"],
	["griskött","griskött","Kött"],
	["grynpipig ost","grynpipig ost","Ost"],
	["grädde","grädde","Mejeri"],
	["gräddfil","gräddfil","Mejeri"],
	["gräslök","gräslök","Frukt och grönt"],
	["gröna oliver","gröna oliver","Torrvaror"],
	["grönkål","grönkål","Frukt och grönt"],
	["grönmynta","grönmynta","Kryddor"],
	["grönpeppar","grönpeppar","Kryddor"],
	["grön sparris","grön sparris","Frukt och grönt"],
	["gul lök","gul lök","Frukt och grönt"],
	["gurka","gurka","Frukt och grönt"],
	["gurkmeja","gurkmeja","Kryddor"],
	["gurkört","gurkört","Kryddor"],
	["herbes de provence","herbes de provence","Kryddor"],
	["hjorthornssalt","hjorthornssalt","Kryddor"],
	["honung","honung","Torrvaror"],
	["honungsmelon","honungsmelon","Frukt och grönt"],
	["honungssenap","honungssenap","Torrvaror"],
	["hp sauce","hp sauce","Kryddor"],
	["hårdost","hårdost","Ost"],
	["ingefära","ingefära","Frukt och grönt"],
	["ingefära","ingefära","Kryddor"],
	["isop","isop","Kryddor"],
	["johannesört","johannesört","Kryddor"],
	["jordnötter","jordnötter","Torrvaror"],
	["julskinka","julskinka","Kött"],
	["jäst","jäst","Torrvaror"],
	["kaffegrädde","kaffegrädde","Mejeri"],
	["kakao","kakao","Torrvaror"],
	["kalvkött","kalvkött","Kött"],
	["kamomill","kamomill","Kryddor"],
	["kanel","kanel","Kryddor"],
	["kapris","kapris","Kryddor"],
	["kardemumma","kardemumma","Kryddor"],
	["kassler","kassler","Kött"],
	["kesella gourmet","kesella gourmet","Mejeri"],
	["kikärter","kikärter","Torrvaror"],
	["kinakål","kinakål","Frukt och grönt"],
	["kinesisk gräslök","kinesisk gräslök","Kryddor"],
	["kinesisk soja","kinesisk soja","Kryddor"],
	["kiwi","kiwi","Frukt och grönt"],
	["kokosnöt","kokosnöt","Frukt och grönt"],
	["koriander","koriander","Kryddor"],
	["krasse","krasse","Frukt och grönt"],
	["kronärtskocka","kronärtskocka","Frukt och grönt"],
	["krossat vete","krossat vete","Torrvaror"],
	["krydda","krydda","Kryddor"],
	["kryddnejlika","kryddnejlika","Kryddor"],
	["kryddost","kryddost","Ost"],
	["kryddpeppar","kryddpeppar","Kryddor"],
	["kryddsalvia","kryddsalvia","Kryddor"],
	["kryddtimjan","kryddtimjan","Kryddor"],
	["kummin","kummin","Kryddor"],
	["kvanne","kvanne","Kryddor"],
	["kvitten","kvitten","Frukt och grönt"],
	["kycklingfilé","kycklingfilé","Kött"],
	["kyckling","kyckling","Kött"],
	["kål","kål","Frukt och grönt"],
	["körsbär","körsbär","Frukt och grönt"],
	["köttfärs","köttfärs","Kött"],
	["lagerblad","lagerblad","Kryddor"],
	["lammkött","lammkött","Kött"],
	["lantvetemjöl","lantvetemjöl","Torrvaror"],
	["lavendel","lavendel","Kryddor"],
	["lax","lax","Fisk"],
	["leverpastej","leverpastej","Pålägg"],
	["libbsticka","libbsticka","Kryddor"],
	["ljus sirap","ljus sirap","Torrvaror"],
	["lökar","lökar","Frukt och grönt"],
	["lök","lök","Frukt och grönt"],
	["löpe","löpe","Ost"],
	["lövbiff","lövbiff","Kött"],
	["maizena","maizena","Torrvaror"],
	["maizenamjöl","maizenamjöl","Torrvaror"],
	["maizenaredning","maizenaredning","Torrvaror"],
	["majonnäs","majonnäs","Torrvaror"],
	["majs","majs","Frukt och grönt"],
	["malört","malört","Kryddor"],
	["mandel","mandel","Torrvaror"],
	["mango","mango","Frukt och grönt"],
	["mangostan","mangostan","Frukt och grönt"],
	["margarin","margarin","Mejeri"],
	["matfett","matfett","Mejeri"],
	["medwurst","medwurst","Kött"],
	["mejram","mejram","Kryddor"],
	["melon","melon","Frukt och grönt"],
	["mjölk","mjölk","Mejeri"],
	["mjöl","mjöl","Torrvaror"],
	["morot","morot","Frukt och grönt"],
	["morötter","morötter","Frukt och grönt"],
	["muskot","muskot","Kryddor"],
	["musslor","musslor","Fisk"],
	["myrten","myrten","Kryddor"],
	["mörk sirap","mörk sirap","Torrvaror"],
	["nejlikor","nejlikor","Kryddor"],
	["nektarin","nektarin","Frukt och grönt"],
	["nötfärs","nötfärs","Kött"],
	["nötkött","nötkött","Kött"],
	["okra","okra","Frukt och grönt"],
	["olivolja","olivolja","Torrvaror"],
	["olja","olja","Torrvaror"],
	["oregano","oregano","Kryddor"],
	["ost","ost","Ost"],
	["ost","ost","Pålägg"],
	["oxfilé","oxfilé","Kött"],
	["palsternacka","palsternacka","Frukt och grönt"],
	["palsternackor","palsternackor","Frukt och grönt"],
	["papaya","papaya","Frukt och grönt"],
	["paprika","paprika","Frukt och grönt"],
	["paprikapulver","paprikapulver","Kryddor"],
	["paradiscorn","paradiscorn","Kryddor"],
	["parakasein","parakasein","Ost"],
	["parmesanost","parmesanost","Pålägg"],
	["passionsfrukt","passionsfrukt","Frukt och grönt"],
	["pata negra","pata negra","Kött"],
	["pepparmynta","pepparmynta","Kryddor"],
	["peppar","peppar","Kryddor"],
	["pepparrot","pepparrot","Kryddor"],
	["persika","persika","Frukt och grönt"],
	["persilja","persilja","Frukt och grönt"],
	["pimpinell","pimpinell","Kryddor"],
	["piplök","piplök","Kryddor"],
	["plommon","plommon","Frukt och grönt"],
	["pomerans","pomerans","Kryddor"],
	["potatismjöl","potatismjöl","Torrvaror"],
	["pumpa","pumpa","Frukt och grönt"],
	["purjolök","purjolök","Frukt och grönt"],
	["päron","päron","Frukt och grönt"],
	["rabarber","rabarber","Frukt och grönt"],
	["rambutan","rambutan","Frukt och grönt"],
	["renfana","renfana","Kryddor"],
	["renkött","renkött","Kött"],
	["renskav","renskav","Kött"],
	["ris","ris","Torrvaror"],
	["romansallad","romansallad","Frukt och grönt"],
	["rosenböna","rosenböna","Frukt och grönt"],
	["rosmarin","rosmarin","Kryddor"],
	["rostbiff","rostbiff","Kött"],
	["ruccola","ruccola","Frukt och grönt"],
	["rullad","rullad","Kött"],
	["rundpipig ost","rundpipig ost","Ost"],
	["russin","russin","Frukt och grönt"],
	["ryggbiff","ryggbiff","Kött"],
	["råbiff","råbiff","Kött"],
	["rågsikt","rågsikt","Torrvaror"],
	["rädisa","rädisa","Frukt och grönt"],
	["rädisor","rädisor","Frukt och grönt"],
	["räkor","räkor","Fisk"],
	["rättika","rättika","Frukt och grönt"],
	["röda vinbär","röda vinbär","Frukt och grönt"],
	["rödbeta","rödbeta","Frukt och grönt"],
	["röd caviar","röd caviar","Fisk"],
	["rött vin","rött vin","Vin och sprit"],
	["saffran","saffran","Kryddor"],
	["sallat","sallat","Frukt och grönt"],
	["salt","salt","Kryddor"],
	["salvior","salvior","Kryddor"],
	["schalottenlök","schalottenlök","Frukt och grönt"],
	["selleri","selleri","Frukt och grönt"],
	["senap","senap","Torrvaror"],
	["senapsfrö","senapsfrö","Kryddor"],
	["sesamolja","sesamolja","Torrvaror"],
	["sherry","sherry","Vin och sprit"],
	["sichuanpeppar","sichuanpeppar","Kryddor"],
	["sirap","sirap","Torrvaror"],
	["skinka","skinka","Kött"],
	["skånsk senap","skånsk senap","Kryddor"],
	["slanggurka","slanggurka","Frukt och grönt"],
	["smältost","smältost","Ost"],
	["smör","smör","Mejeri"],
	["snöripa","snöripa","Kött"],
	["socker","socker","Torrvaror"],
	["soja","soja","Kryddor"],
	["sommarkyndel","sommarkyndel","Kryddor"],
	["spansk körvel","spansk körvel","Kryddor"],
	["sparris","sparris","Frukt och grönt"],
	["spenat","spenat","Frukt och grönt"],
	["spiskummin","spiskummin","Kryddor"],
	["spättafilé","spättafilé","Fisk"],
	["squash","squash","Frukt och grönt"],
	["ströbröd","ströbröd","Torrvaror"],
	["stureost","stureost","Ost"],
	["svarta oliver","svarta oliver","Torrvaror"],
	["svartpeppar","svartpeppar","Kryddor"],
	["sylta","sylta","Kött"],
	["tabasco","tabasco","Kryddor"],
	["taggannona","taggannona","Frukt och grönt"],
	["timjan","timjan","Kryddor"],
	["tjälknöl","tjälknöl","Kött"],
	["tomatpuré","tomatpuré","Torrvaror"],
	["tomat","tomat","Frukt och grönt"],
	["tonfisk","tonfisk","Fisk"],
	["tryffelsvamp","tryffelsvamp","Kryddor"],
	["valnötskärnor","valnötskärnor","Torrvaror"],
	["vaniljkräm","vaniljkräm","Mejeri"],
	["vaniljsocker","vaniljsocker","Torrvaror"],
	["vattenmelon","vattenmelon","Frukt och grönt"],
	["vatten","vatten","Vatten"],
	["vetemjöl","vetemjöl","Torrvaror"],
	["viltkött","viltkött","Kött"],
	["vinbärsgele","vinbärsgele","Torrvaror"],
	["vinruta","vinruta","Kryddor"],
	["vinterkyndel","vinterkyndel","Kryddor"],
	["vispgrädde","vispgrädde","Mejeri"],
	["vitkål","vitkål","Frukt och grönt"],
	["vitlöksklyfta","vitlöksklyfta","Frukt och grönt"],
	["vitlökspulver","vitlökspulver","Kryddor"],
	["vitlök","vitlök","Frukt och grönt"],
	["vitpeppar","vitpeppar","Kryddor"],
	["vitt vin","vitt vin","Vin och sprit"],
	["vitvinsvinäger","vitvinsvinäger","Torrvaror"],
	["åbrodd","åbrodd","Kryddor"],
	["ägg","ägg","Mejeri"],
	["äpple","äpple","Frukt och grönt"],
	["ärtor","ärtor","Frukt och grönt"],
	["ättika","ättika","Torrvaror"],
	["ölost","ölost","Ost"],
	["örtsalt","örtsalt","kryddor"]
                   ]

# THESE ARE STANDARD UNIT CONVERSIONS. You can simply translate unit names where
# you know them. Eliminate entries that are untranslatable or don't exist in your
# locale. And please add any additional units that you know of.
# Each unit is of the following format:
# ("unit1","unit2"):conversion_factor, where unit1 contains conversion_factor X unit2
# For example: 1 cup has 16 tablespoons.
CONVERTER_TABLE = {
    ("tsk", "ml"):5,
    ("msk", "ml"):15,
    ("krm", "ml"):1,
    ("l", "ml"):1000,
    ("l", "cl"):100,
    ("l", "dl"):10,
    ("kg", "g"):1000,
    ("g", "mg"):1000}

# DENSITIES of common foods. This allows us to convert between mass and volume.
# Translators: You may be best off translating the food names below, since lists
# of food densities can be hard to come by!
DENSITY_TABLE={
    "vatten":1,
    "vindruvs juice":1.03,
    "grönsaksbuljong":1,
    "mjölk":1.029,
    "standardmjölk":1.029,
    "skummjölk":1.033,
    "kokosmjölk":0.875,
    "vispgrädde":0.994,
    "kaffegrädde":1.012,
    "honung":1.420,
    "socker":1.550,
    "salt":2.165,
    "smör":0.911,
    "olja":0.88,
    "olivolja":0.88,
    "majsolja":0.88,
    "sesamolja":0.88,
    "vetemjöl": 0.6,
    "mjöl": 0.6,
    "majsstärkelse": 0.6,
    "florsocker": 0.6
            }

# Standard unit names and alternate unit names that might appear.  For
# example: "c." is our standard abbreviation for cup.  "cup","c." or
# "cups" might appear in a recipe we are importing.  Each item of this
# list looks like this:
#
# ["standard", ["alternate1","alternate2","alternate3",...]]
#
# The first item should be the preferred abbreviation
# The second item should be the full name of the unit
# e.g. ["c.", ["cup",...]]
#
UNITS = [["tsk", ["tesked", "tsk", 'teskedar']],
         ["msk", ["matsked", "msk",'matskedar']],
         ["krm", ["kryddmått", "krm"]],
         ["ml", ["mililiter","ml", "ml."]],
         ["cl", ["centiliter","cl", "cl."]],
         ["dl", ["deciliter","dl", "dl."]],
         ["l", ["liter", "l.", "lit.",'l']],
         ["g", ["gram", "g.",'g']],
         ["mg", ["miligram", "mg.", "mg"]],
         ["kg", ["kilogram","kg.", "kg","kilo"]],
         # These names aren't really convertible, but we want them to
         # be recognized as units...
         ['liten',['liten','små']],
         ['normal',['normal','normalstor','normala','normalstora']],
         ['stor',['stor','stora']],
         ['klyfta',['klyfta','klyftor']],
         ['hel',['hel','hela']],
         ['paket',['paket']],
         ['låda',['låda','lådor']],
         ['burk',['burk','burkar']],
         ['skiva',['skiva','skivor']],
         ]

METRIC_RANGE = (1,999)

# The following sets up unit groups. Users will be able to turn
# these on or off (American users, for example, would likely turn
# off metric units, since we don't use them).
# (User choice not implemented yet)
UNIT_GROUPS = {
    'metric mass':[('mg',METRIC_RANGE),
                   ('g',METRIC_RANGE),
                   ('kg',(1,None))],
    'metric volume':[('ml',METRIC_RANGE),
                     ('cl',(1,99)),
                     ('dl',(1,9)),
                     ('l',(1,None)),],
    'imperial weight':[('grains',(0,27)),
                       ('dram',(0.5,15)),
                       ('oz.',(0.25,32)),
                       ('lb.',(0.25,None)),
                       ],
    'imperial volume':[('drop',(0,3)),
                       ('tsp.',(0.125,3)),
                       ('tbs.',(1,4)),
                       ('c.',(0.25,6)),
                       ('pt.',(1,1)),
                       ('qt.',(1,3)),
                       ('gallon',(1,None)),
                       ('peck',(1,2)),
                       ('bucket',(1,2)),
                       ('bushel',(1,None))]
    }



# The units here need to correspond to the standard unit names defined
# above in UNITS
CROSS_UNIT_TABLE = {
    ## This if for units that require an additional
    ## bit of information -- i.e. to convert between
    ## volume and mass you need the density of an
    ## item.  In these cases, the additional factor
    ## will be provided as an 'item' that is then looked
    ## up in the dictionary referenced here (i.e. the density_table)
    ## currently, 'density' is the only keyword used
    ("pt.", "lb."):['density',1],
    ("tbs.", "oz."):['density',0.5],
    ("c.", "oz."):['density',8],
    ("pt.", "oz."):['density',16],
    ("ml", "g"):['density',1],
    ('oz.','fl. oz.'):['density',1],
    }

# The units here need to correspond to the standard unit names defined
# in UNITS.  These are some core conversions from mass-to-volume,
# assuming a density of 1 (i.e. the density of water).
VOL_TO_MASS_TABLE = {
    ("ml", "g") : 1,
    ("ml", "mg") : 1000,
    ("ml", "kg"): 0.001,
    ("cl", "kg"): 0.01,
    ("cl", "g") : 10,
    ("dl", "kg") : 0.1,
    ("dl", "g") : 100,
    ("l", "kg") : 1}

# TIME ABBREVIATIONS (this is new!)
TIME_ABBREVIATIONS = {
    'sek':'sekunder',
    'min':'minuter',
    'tim':'timmar',
    's':'sekunder',
    'm':'minuter',
    't':'timmar',
    'h':'timmar'
    }

# These functions are rather important! Our goal is simply to
# facilitate look ups -- if the user types in "tomatoes", we want to
# find "tomato." Note that the strings these functions produce will
# _never_ be shown to the user, so it's fine to generate nonsense
# words as well as correct answers -- our goal is to generate a list
# of possible hits rather than to get the plural/singular form "right".

irregular_plurals={
    "geese":"goose",
    }
import re
two_digit_plural_matcher = re.compile('[szxo]es$')
one_digit_plural_matcher = re.compile("[^s]s$")
v_plural_matcher = re.compile('ves')

def guess_singulars (s):
    if len(s)<3: return []
    rets = []
    if irregular_plurals.has_key(s):
        rets.append(irregular_plurals[s])
    if two_digit_plural_matcher.search(s):
        wrd=s[0:-2]
        if not wrd in rets: rets.append(wrd)
    if v_plural_matcher.search(s):
        rets.append(s[0:-3]+'f')
    if one_digit_plural_matcher.search(s): rets.append(s[0:-1])
    return rets

def guess_plurals (s):
    if not s: return []
    ret = [s+'s',s+'es']
    if s[-1]=='f': ret.append(s[0:-1]+'ves')
    return ret
    
IGNORE = ["and","with","of","for","cold","warm","finely","thinly","roughly","coarsely"]

NUMBERS = {
    (1.0/8):['åttondel'],
    (1.0/4):['kvarts', 'en kvarts'],
    (3.0/4):['trekvarts'],
    (2.0/3):['två tredjedelar'],
    (1.0/3):['en tredjedel','en tredjedels'],
    (1.0/2):['en halv','halv'],
    1:['en','ett'],
    2:['två','ett par'],
    3:['tre'],
    4:['fyra'],
    5:['fem'],
    6:['sex'],
    7:['sju'],
    8:['åtta'],
    9:['nio'],
    10:['tio'],
    11:['elva'],
    12:['tolv','ett dussin'],
    20:['tjugo','ett tjog'],
    30:['trettio'],
    40:['förtio'],
    50:['femtio'],
    60:['sextio'],
    }

########NEW FILE########
__FILENAME__ = eatdrinkfeelgood_exporter
# Export Gourmet recipes to eatdrinkfeelgood XML format 
# Copyright (c) 2005 cozybit, Inc. 
#
# Author: Javier Cardona <javier_AT_cozybit.com>
# 
# Based on the Gourmet exporter interface developed by Thomas Hinkle
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
# USA.

from gourmet.exporters import exporter
import xml.dom
import sys, xml.sax.saxutils, base64
from gourmet.gdebug import debug
from gourmet.gglobals import NAME_TO_ATTR
import gourmet.convert as convert
import unittest

def string_to_number_type (n):
    if n.find('/')>-1:
        return 'frac'
    elif n.find('.')>-1:
        return 'float'
    else:
        return 'int'

def set_attribute (xmlDoc, element, attribute, value):
    a = xmlDoc.createAttribute(attribute)
    element.setAttributeNode(a)
    element.setAttribute(attribute,value)

class EdfgXmlBase:
    def write_header (self):
        a = self.xmlDoc.createAttribute('xmlns')
        self.top_element.setAttributeNode(a)
        self.top_element.setAttribute('xmlns',
            'http://www.eatdrinkfeelgood.org/1.1/ns')
        a = self.xmlDoc.createAttribute('xmlns:dc')
        self.top_element.setAttributeNode(a)
        self.top_element.setAttribute('xmlns:dc',
            'http://purl.org/dc/elements/1.1')
        a = self.xmlDoc.createAttribute('xmlns:xlink')
        self.top_element.setAttributeNode(a)
        self.top_element.setAttribute('xmlns:xlink',
            'http://www.w3.org/1999/xlink')
        a = self.xmlDoc.createAttribute('xmlns:xi')
        self.top_element.setAttributeNode(a)
        self.top_element.setAttribute('xmlns:xi',
            'http://www.w3.org/2001/XInclude')

class EdfgXml(exporter.exporter_mult, EdfgXmlBase):

    """ An XML exported for the eatdrinkfeelgood dtd """

    units = ['kilogram','gram','milligram',
             'litre','millilitre','gallon',
             'quart','pint','gill','cup',
             'tablespoon','teaspoon','bushel',
             'peck','pound','dram','ounce']
    
    def __init__ (self, rd, r, out, xmlDoc = None, conv = None, attdics={}, 
            change_units=False, mult=1):
        self.e_current_step = None
        self.e_directions = None
        if xmlDoc:
            self.single_recipe_file = False
            self.xmlDoc = xmlDoc
        else:
            # no xmlDoc passed.  create one...
            self.single_recipe_file = True
            impl = xml.dom.getDOMImplementation()
            doctype = impl.createDocumentType("eatdrinkfeelgood",
                "-//Aaron Straup Cope//DTD Eatdrinkfeelgood 1.2//EN//XML",
                "./eatdrinkfeelgood.dtd")
            self.write_header()

        exporter.exporter_mult.__init__(self, rd,r,out, use_ml=True,
                                        order=['attr','image','ings','text'],
                                        do_markup=True,
                                        change_units=change_units,
                                        mult=mult)


    def write_head (self):
        e = self.xmlDoc.createElement('recipe')
        self.xmlDoc.documentElement.appendChild(e)
        self.e_recipe = e
        

    def write_attr (self, label, text):
        attr = NAME_TO_ATTR[label]
        e_parent = self.e_recipe
        if attr == 'title':
            e = self.xmlDoc.createElement('name') 
            e_parent.appendChild(e)
            e_parent = e
            attr = 'common'
        e = self.xmlDoc.createElement(attr)
        t = self.xmlDoc.createTextNode(xml.sax.saxutils.escape(text))
        e.appendChild(t)
        e_parent.appendChild(e)
        
    def write_text (self, label, text, time=None):
        """write_text() is called for each 'step' in the recipe"""
        if not self.e_directions:
            self.e_directions = self.xmlDoc.createElement('directions')
            self.e_recipe.appendChild(self.e_directions)
        e = self.xmlDoc.createElement('step')
        self.e_directions.appendChild(e)
        self.e_current_step = e
        e_para = self.xmlDoc.createElement('para')
        self.e_current_step.appendChild(e_para)
        t = self.xmlDoc.createTextNode(xml.sax.saxutils.escape(text))
        e_para.appendChild(t)
        if time:
            second_element = self.xmlDoc.createElement('seconds')
            n_element = self.n_element(time)
            second_element.appendChild(n_element)
            prep_element = self.xmlDoc.createElement('preparation')
            prep_element.appendChild(second_element)
            self.e_current_step.appendChild(prep_element)
        
        

    def write_image (self, image):
        e = self.xmlDoc.createElement('image')
        a = self.xmlDoc.createAttribute('content-type')
        e.setAttributeNode(a)
        e.setAttribute('content-type', 'jpeg')
        a = self.xmlDoc.createAttribute('rel')
        e.setAttributeNode(a)
        e.setAttribute('content-type', 'photo')

        e_bin64b = self.xmlDoc.createElement('bin64b')
        t = self.xmlDoc.createTextNode(base64.b64encode(image))
        e_bin64b.appendChild(t)
        e.appendChild(e_bin64b)
        if self.e_current_step:
            self.e_current_step.appendChild(e)
        else:
            self.e_recipe.appendChild(e)
    
    def handle_italic (self, chunk): return '&lt;i&gt;'+chunk+'&lt;/i&gt;'
    def handle_bold (self, chunk): return '&lt;b&gt;'+chunk+'&lt;/b&gt;'
    def handle_underline (self, chunk): return '&lt;u&gt;'+chunk+'&lt;/u&gt;'
    def write_foot (self):
        if self.single_recipe_file:
            self.xmlDoc.writexml(self.out, newl = '\n', addindent = "\t",
                    encoding = "UTF-8")

    def write_inghead (self):
        req_el = self.xmlDoc.createElement('requirements')
        self.e_recipe.appendChild(req_el)
        ing_el = self.xmlDoc.createElement('ingredients')
        req_el.appendChild(ing_el)
        self.e_ingredients  = ing_el

    def write_ingfoot (self):
        pass

    def write_ingref (self, amount=1, unit=None, item=None,
                      refid=None, optional=False):
        print 'write_ingref not implemented yet'
        
    def write_ing (self, amount=1, unit=None, item=None,
                   key=None, optional=False):
        # item's are the same as keys in cozyland...
        if not key: key = item
        # grab info from our nutrition data info. This relies on rd.nd
        # being a reference to our NutritionData class -- this is
        # hackishly taken care of in CozyImporter.py.
        #
        # If this code is ever included in Gourmet proper, we should
        # delete all references to self.rd.nd
        ndbno = self.rd.nd.get_ndbno(key)
        if amount.find('-')>=0:
            gram_amount = [self.rd.nd.convert_to_grams(convert.frac_to_float(a),
                                                       unit,
                                                       item)
                           for a in amount.split('-')]
        else:
            gram_amount = self.rd.nd.convert_to_grams(convert.frac_to_float(amount),unit,item)
        # Write our XML
        e_parent = self.e_ingredients
        e = self.xmlDoc.createElement('ing')
        e_parent.appendChild(e)
        e_parent = e
        e_amount = self.xmlDoc.createElement('amount')        
        if gram_amount:
            if type(gram_amount) not in [tuple,list] or None not in gram_amount:
                e_amount.appendChild(
                    self.quantity_element(gram_amount,
                                          'gram')
                    )
        e_parent.appendChild(e_amount)
        e_displayamount = self.xmlDoc.createElement('displayamount')
        e_displayamount.appendChild(
            self.quantity_element(amount,unit)
            )
        e_parent.appendChild(e_displayamount)
        e_item = self.xmlDoc.createElement('item')
        e_parent.appendChild(e_item)
        t = self.xmlDoc.createTextNode(item)
        e_item.appendChild(t)
        if ndbno:
            e_usda = self.xmlDoc.createElement('usdaid')
            if ndbno:
                t = self.xmlDoc.createTextNode("%05i"%ndbno)
                e_usda.appendChild(t)
                e_parent.appendChild(e_usda)

    def write_grouphead (self, name):
        print 'write_grouphead not implemented yet'
        
    def write_groupfoot (self):
        print 'write_groupfoot not implemented yet'

    def quantity_element (self, amount, unit):
        """Make a quantity element based on our amount and unit.
        """
        customunit = unit not in self.units
        e_qty = self.xmlDoc.createElement('quantity')
        if amount:
            if type(amount)==str and amount.find('-')>=0:
                amount = amount.split('-')
            if isinstance(amount,tuple) or isinstance(amount,list) and len(amount)==2:
                e_rng = self.xmlDoc.createElement('range')
                e_qty.appendChild(e_rng)
                for a,typ in [(amount[0],'min'),(amount[1],'max')]:
                    e = self.xmlDoc.createElement(typ)
                    e_rng.appendChild(e)
                    e.appendChild(self.n_element(a))
            else:
                if type(amount) in [list,tuple]:
                    # If we have a list here, something's gone a bit screwy...
                    for possible_n in amount:
                        try:
                            e = self.n_element(amount)
                        except TypeError:
                            continue
                        else:
                            e_qty.appendChild(e)
                            break
                else:
                    e_qty.appendChild(self.n_element(amount))
        # Now for the measure...        
        if unit:
            e_msr = self.xmlDoc.createElement('measure')
            e_qty.appendChild(e_msr)
            if customunit:
                e_unit = self.xmlDoc.createElement('customunit')
                e_unit.appendChild(
                    self.xmlDoc.createTextNode(unit)
                    )
            else:
                e_unit = self.xmlDoc.createElement('unit')
                set_attribute(self.xmlDoc,e_unit,'unit',unit)
            e_msr.appendChild(e_unit)                
        return e_qty

    def n_element (self, n):
        if type(n)==str: typ = string_to_number_type(n)
        elif type(n)==int: typ = 'int'
        elif type(n)==float: typ = 'float'
        else: raise TypeError("%s is not a number"%n)
        e_n = self.xmlDoc.createElement('n')
        set_attribute(self.xmlDoc,e_n,'type',typ)
        set_attribute(self.xmlDoc,e_n,'value',str(n))
        return e_n
        

class EdfgXmlM(exporter.ExporterMultirec, EdfgXmlBase):
    def __init__ (self, rd, recipe_table, out, one_file=True, progress_func=None,
        change_units=False, mult=1):
        self.rd=rd
        impl = xml.dom.getDOMImplementation()
        doctype = impl.createDocumentType("eatdrinkfeelgood", 
            "-//Aaron Straup Cope//DTD Eatdrinkfeelgood 1.2//EN//XML",
            "./eatdrinkfeelgood.dtd")
        self.xmlDoc = impl.createDocument(None, "eatdrinkfeelgood", doctype)
        self.top_element = self.xmlDoc.documentElement
        exporter.ExporterMultirec.__init__(
            self, rd, recipe_table, out, one_file=True, ext='xml', exporter=EdfgXml,
            progress_func=progress_func,
            exporter_kwargs={'change_units':change_units,
                             'mult':mult,
                             'xmlDoc':self.xmlDoc
                             }
            )

    def write_footer (self):
        self.xmlDoc.writexml(self.ofi, newl = '\n', addindent = "\t", 
                encoding = "UTF-8")

class ExportTestCase (unittest.TestCase):

    TEST_RECS = [
        [{'title':'Foo',
          'source':'Bar',
          'season':'Winter'},
         ['1 tsp. sugar',
          '2 c. wine',
          '3 cloves garlic',
          '4 1/2 apples'
          'salt',
          'pepper'],
         ['Eat','Cook','Try\nSome\nNew\nLines']
         ],
        [{'title':'Screwy',
          'season':'123',
          'servings':'34'},
         ['1- baseballs',
          '2-3 cups',
          '3-4 wild and crazy recipes.'],
         []],
        ]

    out_file = 'eatdrinkfeelgood_test.xml'

    def setUp (self):
        import fake_db, tempfile
        from cozy_interactive_importer import CozyInteractiveImporter
        from gourmet.importers.interactive_importer import ConvenientImporter
        self.rd = fake_db.RecData(tempfile.mktemp('.db'))
        import gourmet.nutrition.nutrition as nutrition
        import gourmet.convert
        c = gourmet.convert.Converter()
        self.rd.nd = nutrition.NutritionData(self.rd,c)

        class DumbImporter (CozyInteractiveImporter):
            added_to = False
            def __init__ (self, rd):
                ConvenientImporter.__init__(self,rd,threaded=True)
            def set_added_to (self,bool):
                self.added_to = bool

        imp = DumbImporter(self.rd)
        for attrs,ings,steps in self.TEST_RECS:
            imp.start_rec()
            for a,v in attrs.items(): imp.add_attribute(a,v)
            for i in ings:
                imp.add_ing_from_text(i)
            for s in steps:
                imp.add_text('step',s)
            imp.commit_rec()


    def testExport (self):
        from gourmet.exporters import exporter
        e=EdfgXmlM(
            self.rd,
            [self.rd.recipe_table[k] for k in self.rd.recipe_table],
            self.out_file,
            #threaded = False
            )
        e.run()

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = exporter
import re, os.path, os, xml.sax.saxutils, time, shutil, urllib, textwrap, types
from gourmet import convert
from gourmet.gglobals import REC_ATTR_DIC, DEFAULT_ATTR_ORDER, DEFAULT_TEXT_ATTR_ORDER, TEXT_ATTR_DIC, use_threads
from gourmet.gdebug import TimeAction, debug, print_timer_info
from gettext import gettext as _
from gourmet.plugin_loader import Pluggable, pluggable_method
from gourmet.plugin import BaseExporterPlugin, BaseExporterMultiRecPlugin
from gourmet.threadManager import SuspendableThread

class exporter (SuspendableThread, Pluggable):
    """A base exporter class.

    All Gourmet exporters should subclass this class or one of its
    derivatives.

    This class can also be used directly for plain text export.
    """
    DEFAULT_ENCODING = 'utf-8'

    name='exporter'
    ALLOW_PLUGINS_TO_WRITE_NEW_FIELDS = True
    
    def __init__ (self, rd, r, out,
                  conv=None,
                  imgcount=1,
                  order=['image','attr','ings','text'],
                  attr_order=DEFAULT_ATTR_ORDER,
                  text_attr_order = DEFAULT_TEXT_ATTR_ORDER,
                  do_markup=True,
                  use_ml=False,
                  convert_attnames=True,
                  fractions=convert.FRACTIONS_ASCII,

                  ):
        """Instantiate our exporter.

        conv is a preexisting convert.converter() class
        imgcount is a number we use to start counting our exported images.
        order is a list of our core elements in order: 'image','attr','text' and 'ings'
        attr_order is a list of our attributes in the order we should export them:
                   title, category, cuisine, servings, source, rating, preptime, cooktime
        text_attr_order is a list of our text attributes.
        do_markup is a flag; if true, we interpret tags in text blocks by calling
                  self.handle_markup to e.g. to simple plaintext renderings of tags.
        use_ml is a flag; if true, we escape strings we output to be valid *ml
        convert_attnames is a flag; if true, we hand write_attr a translated attribute name
                         suitable for printing or display. If not, we just hand it the standard
                         attribute name (this is a good idea if a subclass needs to rely on the
                         attribute name staying consistent for processing, since converting attnames
                         will produce locale specific strings.
        """
	self.attr_order=attr_order
        self.text_attr_order = text_attr_order
        self.out = out
        self.r = r
        self.rd=rd
        self.do_markup=do_markup
        self.fractions=fractions
        self.use_ml=use_ml
        self.convert_attnames = convert_attnames
        if not conv: conv=convert.get_converter()
        self.conv=conv
        self.imgcount=imgcount
        self.images = []
        self.order = order
        Pluggable.__init__(self,[BaseExporterPlugin])
        SuspendableThread.__init__(self,self.name)

    def do_run (self):
        self.write_head()
        for task in self.order:
            if task=='image':
                if self._grab_attr_(self.r,'image'):
                    self.write_image(self.r.image)
            if task=='attr':
                self._write_attrs_()

            elif task=='text':
                self._write_text_()
            elif task=='ings': self._write_ings_()
        self.write_foot()


    # Internal methods -- ideally, subclasses should have no reason to
    # override any of these methods.
    @pluggable_method
    def _write_attrs_ (self):
        self.write_attr_head()
        for a in self.attr_order:
            txt=self._grab_attr_(self.r,a)
            debug('_write_attrs_ writing %s=%s'%(a,txt),1)
            if txt and (
                (type(txt) not in [str,unicode])
                or
                txt.strip()
                ):
                if (a=='preptime' or a=='cooktime') and a.find("0 ")==0: pass
                else:
                    if self.convert_attnames:
                        self.write_attr(REC_ATTR_DIC.get(a,a),txt)
                    else:
                        self.write_attr(a,txt)
        self.write_attr_foot()

    @pluggable_method
    def _write_text_ (self):
        #print 'exporter._write_text_',self.text_attr_order,'!'
        for a in self.text_attr_order:
            # This code will never be called for Gourmet
            # proper... here for convenience of symbiotic project...
            if a=='step':
                steps = self._grab_attr_(self.r,a)
                if not steps: continue
                for s in steps:
                    if isinstance(s,dict):
                        dct = s
                        s = dct.get('text','')
                        img = dct.get('image','')
                        time = dct.get('time',0)
                        #print 'Exporter sees step AS:'
                        #print '  text:',s
                        #print '  image:',img
                        #print '  time:',time
                    else:
                        img = ''
                    if self.do_markup:
                        txt=self.handle_markup(s)
                    if not self.use_ml: txt = xml.sax.saxutils.unescape(s)
                    if self.convert_attnames:
                        out_a = TEXT_ATTR_DIC.get(a,a)
                    else:
                        out_a = a
                    # Goodness this is an ugly way to pass the
                    # time as a parameter... we use try/except to
                    # allow all gourmet exporters to ignore this
                    # attribute.
                    try: self.write_text(a,s,time=time)
                    except:
                        self.write_text(a,s)
                        print 'Failed to export time=',time
                        raise
                    if img:
                        self.write_image(img)
                continue
            # End of non-Gourmet code
            txt=self._grab_attr_(self.r,a)
            if txt and txt.strip():
                if self.do_markup:  txt=self.handle_markup(txt)
                #else: print 'exporter: do_markup=False'
                if not self.use_ml: txt = xml.sax.saxutils.unescape(txt)
                if self.convert_attnames:
                    self.write_text(TEXT_ATTR_DIC.get(a,a),txt)
                else:
                    self.write_text(a,txt)

    @pluggable_method
    def _write_ings_ (self):
        """Write all of our ingredients.
        """
        ingredients = self.rd.get_ings(self.r)
        if not ingredients:
            return
        self.write_inghead()
        for g,ings in self.rd.order_ings(ingredients):
            if g:
                self.write_grouphead(g)            
            for i in ings:
                amount,unit = self._get_amount_and_unit_(i)
                if self._grab_attr_(i,'refid'):
                    self.write_ingref(amount=amount,
                                      unit=unit,
                                      item=self._grab_attr_(i,'item'),
                                      refid=self._grab_attr_(i,'refid'),
                                      optional=self._grab_attr_(i,'optional')
                                      )
                else:
                    self.write_ing(amount=amount,
                                   unit=unit,
                                   item=self._grab_attr_(i,'item'),
                                   key=self._grab_attr_(i,'ingkey'),
                                   optional=self._grab_attr_(i,'optional')
                                   )
            if g:
                self.write_groupfoot()
        self.write_ingfoot()

    def _grab_attr_ (self, obj, attr):
        # This is a bit ugly -- we allow exporting categories as if
        # they were a single attribute even though we in fact allow
        # multiple categories.
        if attr=='category':
            return ', '.join(self.rd.get_cats(obj))
        try:
            ret = getattr(obj,attr)
        except:
            return None
        else:
            if attr in ['preptime','cooktime']:
                # this 'if' ought to be unnecessary, but is kept around
                # for db converting purposes -- e.g. so we can properly
                # export an old DB
                if ret and type(ret)!=str: 
                    ret = convert.seconds_to_timestring(ret,fractions=self.fractions)
            elif attr=='rating' and ret and type(ret)!=str:
                if ret/2==ret/2.0:
                    ret = "%s/5 %s"%(ret/2,_('stars'))
                else:
                    ret = "%s/5 %s"%(ret/2.0,_('stars'))
            elif attr=='servings' and type(ret)!=str:
                ret = convert.float_to_frac(ret,fractions=self.fractions)
            elif attr=='yields':
                ret = convert.float_to_frac(ret,fractions=self.fractions)
                yield_unit = self._grab_attr_(obj,'yield_unit')
                if yield_unit:
                    ret = '%s %s'%(ret,yield_unit) # FIXME: i18n? (fix also below in exporter_mult)
            if type(ret) in [str,unicode] and attr not in ['thumb','image']:
                try:
                    ret = ret.encode(self.DEFAULT_ENCODING)
                except:
                    print "oops:",ret,"doesn't look like unicode."
                    raise
            return ret

    def _get_amount_and_unit_ (self, ing):
        return self.rd.get_amount_and_unit(ing,fractions=self.fractions)

    # Below are the images inherited exporters should
    # subclass. Subclasses overriding methods should make these
    # pluggable so that plugins can fiddle about with things as they
    # see fit.

    def write_image (self, image):
        """Write image based on binary data for an image file (jpeg format)."""
        pass


    def write_head (self):
        """Write any necessary header material at recipe start."""
        pass

    def write_foot (self):
        """Write any necessary footer material at recipe end."""
        pass

    @pluggable_method
    def write_inghead(self):
        """Write any necessary markup before ingredients."""
        self.out.write("\n---\n%s\n---\n"%_("Ingredients"))

    @pluggable_method
    def write_ingfoot(self):
        """Write any necessary markup after ingredients."""
        pass

    @pluggable_method
    def write_attr_head (self):
        """Write any necessary markup before attributes."""
        pass

    @pluggable_method
    def write_attr_foot (self):
        """Write any necessary markup after attributes."""
        pass

    @pluggable_method
    def write_attr (self, label, text):
        """Write an attribute with label and text.

        If we've been initialized with convert_attnames=True, the
        label will already be translated to our current
        locale. Otherwise, the label will be the same as it used
        internally in our database.

        So if your method needs to do something special based on the
        attribute name, we need to set convert_attnames to False (and
        do any necessary i18n of the label name ourselves.
        """
        self.out.write("%s: %s\n"%(label, text.strip()))

    @pluggable_method
    def write_text (self, label, text):
        """Write a text chunk.

        This could include markup if we've been initialized with
        do_markup=False.  Otherwise, markup will be handled by the
        handle_markup methods (handle_italic, handle_bold,
        handle_underline).
        """
        self.out.write("\n---\n%s\n---\n"%label)
        ll=text.split("\n")
        for l in ll:
            for wrapped_line in textwrap.wrap(l):
                self.out.write("\n%s"%wrapped_line)
        self.out.write('\n\n')

    def handle_markup (self, txt):
        """Handle markup inside of txt."""
        if txt == None:
            print 'Warning, handle_markup handed None'
            return ''
        import pango
        outtxt = ""
        try:
            al,txt,sep = pango.parse_markup(txt,u'\x00')
        except:
            al,txt,sep = pango.parse_markup(xml.sax.saxutils.escape(txt),u'\x00')
        ai = al.get_iterator()
        more = True
        while more:
            fd,lang,atts=ai.get_font()
            chunk = xml.sax.saxutils.escape(txt.__getslice__(*ai.range()))
            trailing_newline = ''
            fields=fd.get_set_fields()
            if fields != 0: #if there are fields
                # Sometimes we get trailing newlines, which is ugly
                # because we end up with e.g. <b>Foo\n</b>
                #
                # So we define trailing_newline as a variable
                if chunk and chunk[-1]=='\n':
                    trailing_newline = '\n'; chunk = chunk[:-1]
                if 'style' in fields.value_nicks and fd.get_style()==pango.STYLE_ITALIC:
                    chunk=self.handle_italic(chunk)
                if 'weight' in fields.value_nicks and fd.get_weight()==pango.WEIGHT_BOLD:
                    chunk=self.handle_bold(chunk)
            for att in atts:
                if att.type==pango.ATTR_UNDERLINE and att.value==pango.UNDERLINE_SINGLE:
                    chunk=self.handle_underline(chunk)
            outtxt += chunk + trailing_newline
            more=ai.next()
        return outtxt

    def handle_italic (self,chunk):
        """Make chunk italic, or the equivalent."""
        return "*"+chunk+"*"
    
    def handle_bold (self,chunk):
        """Make chunk bold, or the equivalent."""
        return chunk.upper()
    
    def handle_underline (self,chunk):
        """Make chunk underlined, or the equivalent of"""
        return "_" + chunk + "_"

    @pluggable_method
    def write_grouphead (self, text):
        """The start of group of ingredients named TEXT"""
        self.out.write("\n%s:\n"%text.strip())

    @pluggable_method
    def write_groupfoot (self):
        """Mark the end of a group of ingredients.
        """
        pass
    
    @pluggable_method
    def write_ingref (self, amount=1, unit=None,
                      item=None, optional=False,
                      refid=None):
        """By default, we don't handle ingredients as recipes, but
        someone subclassing us may wish to do so..."""
        self.write_ing(amount=amount,
                       unit=unit, item=item,
                       key=None, optional=optional)

    @pluggable_method
    def write_ing (self, amount=1, unit=None, item=None, key=None, optional=False):
        """Write ingredient."""
        if amount:
            self.out.write("%s"%amount)
        if unit:
            self.out.write(" %s"%unit)
        if item:
            self.out.write(" %s"%item)
        if optional:
            self.out.write(" (%s)"%_("optional"))
        self.out.write("\n")

class exporter_mult (exporter):
    """A basic exporter class that can handle a multiplied recipe."""
    def __init__ (self, rd, r, out,
                  conv=None, 
                  change_units=True,
                  mult=1,
                  imgcount=1,
                  order=['image','attr','ings','text'],
                  attr_order=DEFAULT_ATTR_ORDER,
                  text_attr_order=DEFAULT_TEXT_ATTR_ORDER,
                  do_markup=True,
                  use_ml=False,
                  convert_attnames=True,
                  fractions=convert.FRACTIONS_ASCII,
                    ):
        """Initiate an exporter class capable of multiplying the recipe.

        We allow the same arguments as the base exporter class plus
        the following

        mult = number (multiply by this number)

        change_units = True|False (whether to change units to keep
        them readable when multiplying).
        """
        self.mult = mult
        self.change_units = change_units
        exporter.__init__(self, rd, r, out, conv, imgcount, order,
                          attr_order=attr_order,
                          text_attr_order=text_attr_order,
                          use_ml=use_ml, do_markup=do_markup,
                          convert_attnames=convert_attnames,
                          fractions=fractions,
                          )

    @pluggable_method
    def write_attr (self, label, text):
        #attr = NAME_TO_ATTR[label]
        self.out.write("%s: %s\n"%(label, text))

    def _grab_attr_ (self, obj, attr):
        """Grab attribute attr of obj obj.

        Possibly manipulate the attribute we get to hand out export
        something readable.
        """        
        if attr=='servings' or attr=='yields' and self.mult:
            ret = getattr(obj,attr)
            if type(ret) in [int,float]:
                fl_ret = float(ret)
            else:
                if ret is not None:
                    print 'WARNING: IGNORING serving value ',ret
                fl_ret = None
            if fl_ret:
                ret = convert.float_to_frac(fl_ret * self.mult,
                                            fractions=self.fractions)
                if attr=='yields' :
                    yield_unit = self._grab_attr_(obj,'yield_unit')
                    if yield_unit:
                        ret = '%s %s'%(ret,yield_unit) # FIXME: i18n?
                return ret
        else:
            return exporter._grab_attr_(self,obj,attr)

    def _get_amount_and_unit_ (self, ing):
        if self.mult != 1 and self.change_units:
            return self.rd.get_amount_and_unit(ing,mult=self.mult,conv=self.conv,
                                               fractions=self.fractions)
        else:
            return self.rd.get_amount_and_unit(ing,mult=self.mult,conv=self.conv,
                                               fractions=self.fractions)

    @pluggable_method
    def write_ing (self, amount=1, unit=None, item=None, key=None, optional=False):
        if amount:
            self.out.write("%s"%amount)
        if unit:
            self.out.write(" %s"%unit)
        if item:
            self.out.write(" %s"%item)
        if optional:
            self.out.write(" (%s)"%_("optional"))
        self.out.write("\n")        

class ExporterMultirec (SuspendableThread, Pluggable):

    name = 'Exporter'

    def __init__ (self, rd, recipes, out, one_file=True,
                  ext='txt',
                  conv=None,
                  imgcount=1,
                  progress_func=None,
                  exporter=exporter,
                  exporter_kwargs={},
                  padding=None):
        """Output all recipes in recipes into a document or multiple
        documents. if one_file, then everything is in one
        file. Otherwise, we treat 'out' as a directory and put
        individual recipe files within it."""
        self.timer=TimeAction('exporterMultirec.__init__()')
        self.rd = rd
        self.recipes = recipes
        self.out = out
        self.padding=padding
        self.one_file = one_file
        Pluggable.__init__(self,[BaseExporterMultiRecPlugin])
        SuspendableThread.__init__(self,self.name)
        if progress_func: print 'Argument progress_func is obsolete and will be ignored:',progress_func
        self.ext = ext
        self.exporter = exporter
        self.exporter_kwargs = exporter_kwargs
        self.fractions = self.exporter_kwargs.get('fractions',
                                                  convert.FRACTIONS_ASCII)
        self.DEFAULT_ENCODING = self.exporter.DEFAULT_ENCODING
        self.one_file = one_file

    def _grab_attr_ (self, obj, attr):
        if attr=='category':
            return ', '.join(self.rd.get_cats(obj))
        try:
            ret = getattr(obj,attr)
        except:
            return None
        else:
            if attr in ['preptime','cooktime']:
                # this 'if' ought to be unnecessary, but is kept around
                # for db converting purposes -- e.g. so we can properly
                # export an old DB
                if ret and type(ret)!=str: 
                    ret = convert.seconds_to_timestring(ret,fractions=self.fractions)
            elif attr=='rating' and ret and type(ret)!=str:
                if ret/2==ret/2.0:
                    ret = "%s/5 %s"%(ret/2,_('stars'))
                else:
                    ret = "%s/5 %s"%(ret/2.0,_('stars'))
            if type(ret) in types.StringTypes and attr not in ['thumb','image']:
                try:
                    ret = ret.encode(self.DEFAULT_ENCODING)
                except:
                    print "oops:",ret,"doesn't look like unicode."
                    raise
            return ret

    def append_referenced_recipes (self):
        for r in self.recipes[:]:
            reffed = self.rd.db.execute(
                'select * from ingredients where recipe_id=? and refid is not null',r.id
                )
            for ref in reffed:
                rec = self.rd.get_rec(ref.refid)
                if not rec in self.recipes:
                    print 'Appending recipe ',rec.title,'referenced in ',r.title
                    self.recipes.append(rec)
        
    @pluggable_method
    def do_run (self):
        self.rcount = 0
        self.rlen = len(self.recipes)        
        if not self.one_file:
            self.outdir=self.out
            if os.path.exists(self.outdir):
                if not os.path.isdir(self.outdir):
                    self.outdir=self.unique_name(self.outdir)
                    os.makedirs(self.outdir)
            else: os.makedirs(self.outdir)
        if self.one_file and type(self.out)==str:
            self.ofi=open(self.out,'wb')
        else: self.ofi = self.out
        self.write_header()
        self.suspended = False
        self.terminated = False
        first = True
        self.append_referenced_recipes()
        for r in self.recipes:
            self.check_for_sleep()
            msg = _("Exported %(number)s of %(total)s recipes")%{'number':self.rcount,'total':self.rlen}
            self.emit('progress',float(self.rcount)/float(self.rlen), msg)
            fn=None
            if not self.one_file:
                fn=self.generate_filename(r,self.ext,add_id=True)
                self.ofi=open(fn,'wb')
            if self.padding and not first:
                self.ofi.write(self.padding)
            e=self.exporter(out=self.ofi, r=r, rd=self.rd, **self.exporter_kwargs)
            self.connect_subthread(e)
            e.do_run()
            self.recipe_hook(r,fn,e)
            if not self.one_file:
                self.ofi.close()
            self.rcount += 1
            first = False
        self.write_footer()
        if self.one_file:
            self.ofi.close()
        self.timer.end()
        self.emit('progress',1,_("Export complete."))
        print_timer_info()

    @pluggable_method
    def write_header (self):
        pass

    @pluggable_method
    def write_footer (self):
        pass

    def generate_filename (self, rec, ext, add_id=False):
        title=rec.title
        # get rid of potentially confusing characters in the filename
        # Windows doesn't like a number of special characters, so for
        # the time being, we'll just get rid of all non alpha-numeric
        # characters
        ntitle = ""
        for c in title:
            if re.match("[A-Za-z0-9 ]",c):
                ntitle += c
        title = ntitle
        # truncate long filenames
        max_filename_length = 252
        if len(title) > (max_filename_length - 4):
            title = title[0:max_filename_length-4]
        # make sure there is a title
        if not title:
            title = _("Recipe")
        title=title.replace("/"," ")
        title=title.replace("\\"," ")
        # Add ID #
        if add_id:
            title = title + str(rec.id)
        file_w_ext="%s%s%s"%(self.unique_name(title),os.path.extsep,ext)
        return os.path.join(self.outdir,file_w_ext)

    def recipe_hook (self, rec, filename=None, exporter=None):
        """Intended to be subclassed by functions that want a chance
        to act on each recipe, possibly knowing the name of the file
        the rec is going to. This makes it trivial, for example, to build
        an index (written to a file specified in write_header."""
        pass
    
    def unique_name (self, filename):
        if os.path.exists(filename):
            n=1
            fn,ext=os.path.splitext(filename)
            if ext: dot=os.path.extsep
            else: dot=""
            while os.path.exists("%s%s%s%s"%(fn,n,dot,ext)):
                n += 1
            return "%s%s%s%s"%(fn,n,dot,ext)
        else:
            return filename

    def check_for_sleep (self):
        if self.terminated:
            raise Exception("Exporter Terminated!")
        while self.suspended:
            if self.terminated:
                debug('Thread Terminated!',0)
                raise Exception("Exporter Terminated!")
            if use_threads:
                time.sleep(1)
            else:
                time.sleep(0.1)

    def terminate (self):
        self.terminated = True

    def suspend (self):
        self.suspended = True

    def resume (self):
        self.suspended = False

########NEW FILE########
__FILENAME__ = exportManager
import gourmet.plugin_loader as plugin_loader
from gourmet.plugin import ExporterPlugin
import gourmet.gtk_extras.dialog_extras as de
from gourmet.threadManager import get_thread_manager, get_thread_manager_gui
from glib import get_user_special_dir, USER_DIRECTORY_DOCUMENTS
from gettext import gettext as _
import os.path

EXTRA_PREFS_AUTOMATIC = -1
EXTRA_PREFS_DEFAULT = 0

class ExportManager (plugin_loader.Pluggable):

    '''A class to manage exporters.
    '''

    __single = None

    def __init__ (self):
        if ExportManager.__single: raise ExportManager.__single
        else: ExportManager.__single = self
        self.plugins_by_name = {}
        plugin_loader.Pluggable.__init__(self,
                                         [ExporterPlugin]
                                         )
        from gourmet.GourmetRecipeManager import get_application
        self.app = get_application()

    def offer_single_export (self, rec, prefs, mult=1, parent=None):
        """Offer to export a single file.

        Return the filename if we have in fact exported said file.
        """
        default_extension = prefs.get('save_recipe_as','html')
        # strip the period if one ended up on our default extension
        if default_extension and default_extension[0]=='.':
            default_extension = default_extension[1:]
        exp_directory = prefs.get('rec_exp_directory',
                                  get_user_special_dir(USER_DIRECTORY_DOCUMENTS)
                                  )
        filename,exp_type = de.saveas_file(_('Save recipe as...'),
                                           filename='%s%s%s%s%s'%(exp_directory,
                                                                  os.path.sep,
                                                                  rec.title,
                                                                  os.path.extsep,
                                                                  default_extension),
                                           filters=self.get_single_filters(),
                                           parent=parent
                                           )
        if not filename: return
        if not exp_type or not self.can_export_type(exp_type):
            de.show_message(label=_('Gourmet cannot export file of type "%s"')%os.path.splitext(filename)[1])
            return
        return self.do_single_export(rec, filename, exp_type, parent.get_child().get_children()[1], mult)
        
    def do_single_export (self, rec, filename, exp_type, messagebox, mult=1, extra_prefs=EXTRA_PREFS_AUTOMATIC):
        exporter_plugin = self.get_exporter(exp_type)
        extra_prefs = self.get_extra_prefs(exporter_plugin,extra_prefs)
        #extra_prefs = exporter_plugin.run_extra_prefs_dialog() or {}
        if hasattr(exporter_plugin,'mode'):
            export_file_mode = exporter_plugin.mode
            if export_file_mode not in ['w','a','wb']:
                print 'IGNORING INVALID FILE MODE',export_file_mode
                export_file_mode = 'w'
        else:
            export_file_mode = 'w'
        outfi = file(filename,
                     export_file_mode)
        # this should write to our file...
        exporter_plugin.do_single_export({
            'rd':self.app.rd,
            'rec':rec,
            'out':outfi,
            'conv':self.app.conv,
            'change_units':self.app.prefs.get('readableUnits',True),
            'mult':mult,     
            'extra_prefs':extra_prefs,
            })
        outfi.close()
        import gourmet.GourmetRecipeManager
        main_app =  gourmet.GourmetRecipeManager.get_application()
        main_app.offer_url(_('Recipe successfully exported to '
                             '<a href="file:///%s">%s</a>')%(filename,filename),
                           messagebox=messagebox, url='file:///%s'%filename)
        return filename

    def offer_multiple_export (self, recs, prefs, parent=None, prog=None):
        """Offer user a chance to export multiple recipes at once.

        Return the exporter class capable of doing this and a
        dictionary of arguments for the progress dialog.
        """
        if len(recs) < 950:
            # inelegantly avoid bug that happens when this code runs
            # on large numbers of recipes. The good news is that this
            # that that will almost only ever happen when we're
            # exporting all recipes, which makes this code irrelevant
            # anyway.
            self.app.rd.include_linked_recipes(recs)
        ext = prefs.get('save_recipes_as','%sxml'%os.path.extsep)
        exp_directory = prefs.get('rec_exp_directory',
                                  get_user_special_dir(USER_DIRECTORY_DOCUMENTS)
                                  )
        fn,exp_type=de.saveas_file(_("Export recipes"),
                                     filename="%s%s%s%s"%(exp_directory,
                                                          os.path.sep,
                                                          _('recipes'),
                                                          ext),
                                     parent=parent,
                                     filters=self.get_multiple_filters())
        if fn:
            prefs['rec_exp_directory']=os.path.split(fn)[0]
            prefs['save_recipes_as']=os.path.splitext(fn)[1]
            instance = self.do_multiple_export(recs, fn, exp_type)
            if not instance:
                de.show_message(
                    okay=gtk.STOCK_CLOSE,
                    cancel=False,
                    label=_('Unable to export: unknown filetype "%s"'%fn),
                    sublabel=_('Please make sure to select a filetype from the dropdown menu when saving.'),
                    message_type=gtk.MESSAGE_ERROR,
                    )
                return
            return instance

    def get_extra_prefs (self, myexp, extra_prefs):
        if extra_prefs == EXTRA_PREFS_AUTOMATIC:
            extra_prefs = myexp.run_extra_prefs_dialog() or {}
        elif extra_prefs == EXTRA_PREFS_DEFAULT:
            extra_prefs = myexp.get_default_prefs()
        else:
            extra_prefs = extra_prefs
        return extra_prefs
        
    def get_multiple_exporter (self, recs, fn, exp_type=None,
                               setup_gui=True, extra_prefs=EXTRA_PREFS_AUTOMATIC):
        if not exp_type:
            exp_type = de.get_type_for_filters(fn,self.get_multiple_filters())
        if self.can_export_type(exp_type):
            myexp = self.get_exporter(exp_type)
            extra_prefs = self.get_extra_prefs(myexp,extra_prefs)
            pd_args={'label':myexp.label,'sublabel':myexp.sublabel%{'file':fn}}
            exporterInstance = myexp.get_multiple_exporter({'rd':self.app.rd,
                                                         'rv': recs,
                                                            #'conv':self.app.conv,
                                                            #'prog':,
                                                         'file':fn,
                                                         'extra_prefs':extra_prefs,
                                                         })        
            return myexp, exporterInstance
        else:
            print 'WARNING: CANNOT EXPORT TYPE',exp_type        

    def do_multiple_export (self, recs, fn, exp_type=None,
                                           setup_gui=True, extra_prefs=EXTRA_PREFS_AUTOMATIC):
            myexp, exporterInstance = self.get_multiple_exporter(recs,fn,exp_type,setup_gui,extra_prefs)
            tm = get_thread_manager()
            tm.add_thread(exporterInstance)
            if setup_gui:
                tmg = get_thread_manager_gui()
                tmg.register_thread_with_dialog(_('Export')+' ('+myexp.label+')',
                                                _('Recipes successfully exported to <a href="file:///%s">%s</a>')%(fn,fn),
                                                exporterInstance)
                tmg.show()
            print 'Return exporter instance'
            return exporterInstance        

    def can_export_type (self, name): return self.plugins_by_name.has_key(name)

    def get_exporter (self, name):
        return self.plugins_by_name[name]

    def get_single_filters (self):
        filters = []
        for plugin in self.plugins:
            filters.append(plugin.saveas_single_filters)
        return filters

    def get_multiple_filters (self):
        filters = []
        for plugin in self.plugins:
            filters.append(plugin.saveas_filters)
        return filters

    def register_plugin (self, plugin):
        name = plugin.saveas_filters[0]
        if self.plugins_by_name.has_key(name):
            print 'WARNING','replacing',self.plugins_by_name[name],'with',plugin
        self.plugins_by_name[name] = plugin

    def unregister_plugin (self, plugin):
        name = plugin.saveas_filters[0]
        if self.plugins_by_name.has_key(name):
            del self.plugins_by_name[name]
        else:
            print 'WARNING: unregistering ',plugin,'but there seems to be no plugin for ',name
    
def get_export_manager ():
    try:
        return ExportManager()
    except ExportManager, em:
        return em

########NEW FILE########
__FILENAME__ = gxml_exporter
import exporter
import sys, xml.sax.saxutils
from gourmet.gdebug import debug
from gourmet.gglobals import NAME_TO_ATTR
import base64

class rec_to_xml (exporter.exporter):
    def __init__ (self, rd, r, out,attdics={}):
        self.attdics = attdics
        exporter.exporter.__init__(self, rd,r,out, use_ml=True,
                                   order=['attr','text','ings'],
                                   do_markup=True)

    def write_head (self):
        self.out.write("\n<recipe")

    def write_attr (self, label, text):
        if NAME_TO_ATTR[label]=="title":
            # title is not an xml attribute... we'll handle it later
            self.my_title=xml.sax.saxutils.escape(text)
        else:
            name = NAME_TO_ATTR[label]
            if self.attdics.has_key(name):
                text = self.attdics[name][text]
            self.out.write("\n %s=%s"%(name, quoteattr(text)))

    def write_attr_foot (self):
        self.out.write(">\n")
        # now we handle the title...
        if self.my_title:
            self.out.write("\n<title>%s</title>"%self.my_title)
        
    def write_text (self, label, text):
        self.out.write("\n<%s>%s</%s>\n"%(NAME_TO_ATTR[label],text,NAME_TO_ATTR[label]))

    def handle_italic (self, chunk): return '&lt;i&gt;'+chunk+'&lt;/i&gt;'
    def handle_bold (self, chunk): return '&lt;b&gt;'+chunk+'&lt;/b&gt;'    
    def handle_underline (self, chunk): return '&lt;u&gt;'+chunk+'&lt;/u&gt;'    
        
    def write_foot (self):
        self.out.write("</recipe>\n")

    def write_inghead (self):
        self.out.write("\n<ingredient-list>\n")

    def write_ingfoot (self):
        self.out.write("\n</ingredient-list>")

    def write_ingref (self, amount=1, unit=None, item=None, refid=None, optional=False):
        self.out.write("<ingref %srefid=%s amount=%s>%s</ingref>\n"%(
            (optional and " optional='yes'>" or ""),
            quoteattr(str(refid)),
            quoteattr(amount.strip()),
            xml.sax.saxutils.escape(item))
                       )
        
    def write_ing (self, amount=1, unit=None, item=None, key=None, optional=False):
        self.out.write("<ingredient")
        if optional: self.out.write(" optional='yes'>")
        else: self.out.write(">")
        if amount:
            self.out.write("<amount")
            if unit:
                self.out.write(" unit=%s"%quoteattr(unit))
            self.out.write(">%s</amount>"%xml.sax.saxutils.escape("%s"%amount).strip())
        self.out.write("<item key=%s>%s</item>"%(quoteattr(key),xml.sax.saxutils.escape(item)))
        self.out.write("</ingredient>\n")

    def write_grouphead (self, name):
        self.out.write('<inggroup name=%s>\n'%quoteattr(name))
        
    def write_groupfoot (self):
        self.out.write('</inggroup>\n')

    def write_image (self, image):
        self.out.write('<image format="jpeg"><![CDATA[')
        self.out.write(base64.b64encode(image))
        self.out.write(']]></image>')

class recipe_table_to_xml (exporter.ExporterMultirec):
    def __init__ (self, rd, recipe_table, out, one_file=True, progress_func=None):
        self.rd=rd
        self.catDic = self.createDictionary('category')
        self.srcDic = self.createDictionary('source')
        self.cuiDic = self.createDictionary('cuisine')
        exporter.ExporterMultirec.__init__(
            self, rd, recipe_table, out, one_file=True, ext='xml', exporter=rec_to_xml,
            exporter_kwargs={'attdics':{'cuisine':self.cuiDic,
                                        'category':self.catDic,
                                        'source':self.srcDic,},
                             },
            progress_func=progress_func)

    def write_header (self):        
        #self.ofi.write('<!DOCTYPE recipeDoc PUBLIC "-//GOURMET//GOURMET RECIPE MANAGER XML//EN" "%s/recipe.dtd">'%datad)
        self.ofi.write("<recipeDoc>\n")
        self.ofi.write( "<recipeHead>\n")
        self.dic2decl("category",self.catDic,self.ofi)
        self.dic2decl("cuisine",self.cuiDic,self.ofi)
        self.dic2decl("source",self.srcDic,self.ofi)
        self.ofi.write( "</recipeHead>\n")
        self.ofi.write( "<recipe-list>\n")
        
    def write_footer (self):
        self.ofi.write("</recipe-list>\n")
        self.ofi.write("</recipeDoc>\n")        

    def createDictionary(self,attr):
        dic = {}
        cnt = 1
        for r in self.rd.recipe_table:
            itm = getattr(r,attr)
            if not dic.has_key(itm):
                dic[itm]="%s%s"%(attr,cnt)
                cnt += 1
        return dic

    def dic2decl (self, name, dic, out=sys.stderr):
        out.write( "<%sDecl>\n"%name)
        for itm,key in dic.items():
            out.write( "<%s id=%s>%s</%s>\n"%(name,quoteattr(key),xml.sax.saxutils.escape(itm),name))
        out.write( "</%sDecl>\n"%name)

def quoteattr (str):
    return xml.sax.saxutils.quoteattr(xml.sax.saxutils.escape(str)).replace(" ","_")

########NEW FILE########
__FILENAME__ = MarkupString
import xml.sax

class simpleHandler (xml.sax.ContentHandler):
    """A simple handler that provides us with indices of marked up content."""
    def __init__ (self):        
        self.elements = [] #this will contain a list of elements and their start/end indices
        self.open_elements = [] #this holds info on open elements while we wait for their close
        self.content = ""

    def startElement (self,name,attrs):
        if name=='foobar': return # we require an outer wrapper, which we promptly ignore.
        self.open_elements.append({'name':name,
                                   'attrs':attrs.copy(),
                                   'start':len(self.content),
                                   })

    def endElement (self, name):
        if name=='foobar': return # we require an outer wrapper, which we promptly ignore.
        for i in range(len(self.open_elements)):
            e = self.open_elements[i]
            if e['name']==name:
                # append a  (start,end), name, attrs
                self.elements.append(((e['start'], #start position
                                       len(self.content)),# current (end) position
                                      e['name'],e['attrs'])
                                     )
                del self.open_elements[i]
                return

    def characters (self, chunk):
        self.content += chunk

class MarkupString (str):
    """A simple class for dealing with marked up strings. When we are sliced, we return
    valid marked up strings, preserving markup."""
    def __init__ (self, string):        
        str.__init__(self,string)
        self.handler = simpleHandler()
        try:
            xml.sax.parseString("<foobar>%s</foobar>"%str(string),self.handler)
        except:
            print 'Unable to parse "%s"'%string
            raise
        self.raw=self.handler.content

    def __getitem__ (self, n):
        return self.__getslice__(n,n+1)

    def __getslice__ (self, s, e):
        # only include relevant elements
        if not e or e > len(self.raw): e = len(self.raw)
        elements = filter(lambda tp: (tp[0][1] >= s and # end after the start...
                                      tp[0][0] <= e # and start before the end
                                      ),
                          self.handler.elements)
        ends = {}
        starts = {}
        for el in elements:
            # cycle through elements that effect our slice and keep track of
            # where their start and end tags should go.
            pos = el[0]
            name = el[1]
            attrs = el[2]
            # write our start tag <stag att="val"...>
            stag = "<%s"%name
            for k,v in attrs.items(): stag += " %s=%s"%(k,xml.sax.saxutils.quoteattr(v))
            stag += ">"
            etag = "</%s>"%name # simple end tag
            spos = pos[0]
            epos = pos[1]
            if spos < s: spos=s
            if epos > e: epos=e
            if epos != spos: # we don't care about tags that don't markup any text
                if not starts.has_key(spos): starts[spos]=[]
                starts[spos].append(stag)
                if not ends.has_key(epos): ends[epos]=[]
                ends[epos].append(etag)
        outbuf = "" # our actual output string
        for pos in range(s,e): # we move through positions
            char = self.raw[pos]
            if ends.has_key(pos):  # if there are endtags to insert...
                for et in ends[pos]: outbuf += et
            if starts.has_key(pos): # if there are start tags to insert
                mystarts = starts[pos]
                # reverse these so the order works out,e.g. <i><b><u></u></b></i>
                mystarts.reverse()
                for st in mystarts: outbuf += st
            outbuf += char
        if ends.has_key(e):
            for et in ends[e]: outbuf+= et
        return MarkupString(str(outbuf)) # the str call is necessary to avoid unicode messiness

########NEW FILE########
__FILENAME__ = printer
from gettext import gettext as _
import gettext
import gourmet.plugin_loader as plugin_loader
from gourmet.plugin import PrinterPlugin
from gourmet.threadManager import get_thread_manager, get_thread_manager_gui
import os

class NoRecRenderer ():

    def __init__ (self, *args, **kwargs):
        from gourmet.gtk_extras.dialog_extras import show_message
        show_message(label=_('Unable to print: no print plugins are active!'),
                     sublabel=_("To print, activate a plugin that provides printing support, such as the 'Printing & PDF export' plugin."),
                     )
        raise NotImplementedError
    
class NoSimpleWriter ():

    def __init__ (self, *args, **kwargs):
        from gourmet.gtk_extras.dialog_extras import show_message
        show_message(
            label=_('Unable to print: no print plugins are active!'),
            sublabel=_("To print, activate a plugin that provides printing support, such as the 'Printing & PDF export' plugin."),
            )
        raise NotImplementedError        

class PrintManager (plugin_loader.Pluggable):

    __single = None

    def __init__ (self):
        if PrintManager.__single:
            raise PrintManager.__single
        else:
            PrintManager.__single = self
        self.sws = [(-1,NoSimpleWriter)]
        self.rrs = [(-1,NoRecRenderer)]
        plugin_loader.Pluggable.__init__(self,
                                         [PrinterPlugin]
                                         )

    def register_plugin (self, plugin):
        assert(type(plugin.simpleWriterPriority)==int)
        assert(plugin.SimpleWriter)
        self.sws.append((plugin.simpleWriterPriority,plugin.SimpleWriter))
        assert(type(plugin.recWriterPriority)==int)
        assert(plugin.RecWriter)        
        self.rrs.append((plugin.recWriterPriority,plugin.RecWriter))

    def unregister_plugin (self, plugin):
        self.sws.remove(plugin.simpleWriterPriority,plugin.SimpleWriter)
        self.rrs.remove(plugin.recWriterPriority,plugin.RecWriter)        

    def get_simple_writer (self):
        self.sws.sort()
        return self.sws[-1][1]

    def get_rec_renderer (self):
        self.rrs.sort()
        return self.rrs[-1][1]

    def print_recipes (self, rd, recs, parent=None, change_units=None, **kwargs):
        renderer = self.get_rec_renderer()
        if len(recs) == 1:
            title = 'Print recipe "%s"'%recs[0].title
        else:
            title = gettext.ngettext(
                'Print %s recipe',
                'Print %s recipes',
                len(recs))%len(recs)
        try:
            renderer(rd,recs,
                     dialog_title=title,
                     dialog_parent=parent,
                     change_units=change_units,
                     **kwargs)
        except:
            from gourmet.gtk_extras.dialog_extras import show_traceback
            show_traceback(label='Error printing',
                           sublabel=_('Well this is embarassing. Something went wrong printing your recipe.')
                           )

    def show_error (self, *args):
        from gourmet.gtk_extras.dialog_extras import show_message
        show_message(sublabel='There was an error printing. Apologies')
    
def get_print_manager ():
    try:
        return PrintManager()
    except PrintManager, pm:
        return pm

#printManager = get_print_manager()

########NEW FILE########
__FILENAME__ = recipe_emailer
#!/usr/bin/env python
import urllib, StringIO, os.path
import exporter, html_exporter, pdf_exporter
from gourmet import gglobals
from gettext import gettext as _
import gourmet.gtk_extras.dialog_extras as de
from gourmet.gdebug import debug

class StringIOfaker (StringIO.StringIO):
    def __init__ (self, *args, **kwargs):
        StringIO.StringIO.__init__(self, *args, **kwargs)

    def close (self, *args):
        pass

    def close_really (self):
        StringIO.StringIO.close(self)

class Emailer:
    def __init__ (self, emailaddress=None, subject=None, body=None, attachments=[]):
        self.emailaddress=None
        self.subject=subject
        self.body=body
        self.attachments=attachments
        self.connector_string = "?"

    def send_email (self):
        self.url = "mailto:"
        if self.emailaddress: self.url += self.emailaddress
        if self.subject:
            self.url_append('subject',self.subject)
        if self.body:
            self.url_append('body',self.body)
        for a in self.attachments:
            self.url_append('attachment',a)              
        debug('launching URL %s'%self.url,0)
        gglobals.launch_url(self.url)

    def url_append (self, attr, value):
        self.url += "%s%s=%s"%(self.connector(),attr,urllib.quote(value.encode('utf-8','replace')))
                                                                   
    def connector (self):
        retval = self.connector_string
        self.connector_string = "&"
        return retval

class RecipeEmailer (Emailer):
    def __init__ (self, recipes, rd, conv=None, change_units=True):
        Emailer.__init__(self)
        self.recipes = recipes
        self.rd = rd
        self.conv = conv
        self.change_units=change_units
        if len(recipes) > 1:
            self.subject = _("Recipes")
        elif recipes:
            self.subject = recipes[0].title

    def write_email_text (self):
        s = StringIOfaker()
        first = True
        e=exporter.ExporterMultirec(self.rd,
                                    self.recipes,
                                    s,
                                    conv=self.conv,
                                    padding="\n\n-----\n")
        e.run()
        if not self.body: self.body=""
        self.body += s.getvalue()
        s.close_really()

    def write_email_html (self):
        for r in self.recipes:
            fi = os.path.join(gglobals.tmpdir,"%s.htm"%r.title)
            ofi = open(fi,'w')
            e=html_exporter.html_exporter(self.rd,
                                          r,
                                          ofi,
                                          conv=self.conv,
                                          embed_css=True,
                                          imagedir="")
            ofi.close()
            self.attachments.append(fi)
            for i in e.images:
                self.attachments.append(i)

    def write_email_pdf (self):
        prefs = pdf_exporter.get_pdf_prefs()
        for r in self.recipes:
            fi = os.path.join(gglobals.tmpdir,"%s.pdf"%r.title)
            ofi = open(fi,'w')
            e = pdf_exporter.PdfExporter(self.rd,
                                         r,
                                         ofi,
                                         conv=self.conv,
                                         change_units=self.change_units,
                                         pdf_args=prefs)
            ofi.close()
            self.attachments.append(fi)

    def send_email_html (self, emailaddress=None, include_plain_text=True):
        if include_plain_text: self.write_email_text()
        else: self.body = None
        if emailaddress: self.emailaddress=emailaddress
        self.write_email_html()
        self.send_email()

    def send_email_text (self, emailaddress=None):
        if emailaddress: self.emailaddress=emailaddress
        self.write_email_text()
        self.send_email()
            
class EmailerDialog (RecipeEmailer):
    def __init__ (self, recipes, rd, prefs, conv=None):
        RecipeEmailer.__init__(self, recipes, rd, conv=conv, change_units=prefs.get('readableUnits',True))
        self.prefs = prefs
        self.option_list = {'':''}
        self.options = {
            _('Include Recipe in Body of E-mail (A good idea no matter what)'):('email_include_body',True),
            _('E-mail Recipe as HTML Attachment'):('email_include_html',False),
            _('E-mail Recipe as PDF Attachment'):('email_include_pdf',True),
            }
        self.option_list = []
        self.email_options = {}
        for k,v in self.options.items():
            self.email_options[v[0]]=apply(self.prefs.get,v)
            self.option_list.append([k,self.email_options[v[0]]])

    def dont_ask_cb (self, widget, *args):
        if widget.get_active():
            self.prefs['emailer_dont_ask']=True
        else:
            self.prefs['emailer_dont_ask']=False

    def setup_dialog (self, force = False):
        if force or not self.prefs.get('emailer_dont_ask',False):
            d=de.PreferencesDialog(options=self.option_list,
                                   option_label=_("Email Options"),
                                   value_label="",
                                   dont_ask_cb=self.dont_ask_cb,
                                   dont_ask_custom_text=_("Don't ask before sending e-mail."))
            retlist = d.run()
            if retlist:
                for o in retlist:
                    k = o[0]
                    v = o[1]
                    pref = self.options[k][0]
                    self.email_options[pref]=v
                    self.prefs[pref]=v

    def email (self, address=None):
        if address: self.emailaddress=address
        if self.email_options['email_include_body']:
            self.write_email_text()
        if self.email_options['email_include_html']:
            self.write_email_html()
        if self.email_options['email_include_pdf']:
            self.write_email_pdf()
        if not self.email_options['email_include_body'] and not self.email_options['email_include_body']:
            de.show_message(_("E-mail not sent"),
                            sublabel=_("You have not chosen to include the recipe in the body of the message or as an attachment.")
                            )
        else:
            self.send_email()
            

if __name__ == '__main__':
    import gourmet.recipeManager
    rd = gourmet.recipeManager.default_rec_manager()
    rec = rd.fetch_one(rd.recipe_table)
    ed = EmailerDialog([rec],rd,{})
    ed.setup_dialog()
    ed.email()
    #ed.run()
    #e.write_email_text()
    #e.write_email_pdf()
    #e.write_email_html()
    #e.send_email()
    

########NEW FILE########
__FILENAME__ = rtf_exporter
import exporter, PyRTF, types
from gourmet import convert
from gourmet.gdebug import debug
from gourmet.ImageExtras import write_image_tempfile
from gettext import gettext as _

class rtf_exporter_multidoc (exporter.ExporterMultirec):
    def __init__ (self, rd, recipe_table, out, conv=None, progress_func=None):
        debug('rtf_exporter_multidoc starting!',5)
        self.doc = PyRTF.Document()
        exporter.ExporterMultirec.__init__(self,
                                           rd,
                                           recipe_table,
                                           out,
                                           one_file=True, ext='rtf',
                                           progress_func=progress_func,
                                           exporter=rtf_exporter,
                                           exporter_kwargs={'doc':self.doc,
                                                            'multidoc':True})        
        debug('rtf_exporter_multidoc done!',5)

    def write_footer (self):
        renderer = PyRTF.Renderer()
        renderer.Write(self.doc,self.ofi)
        
class rtf_exporter (exporter.exporter_mult):
    def __init__ (self, rd, r, out,
                  conv=convert.Converter(),
                  imgcount=1,
                  mult=1,
                  change_units=False,
                  order=['image','attr','ings','text'],
                  doc=None,
                  multidoc=False,
                  ss=None):
        self.setup_document(doc,ss)
        self.multidoc=multidoc
        exporter.exporter_mult.__init__(self, rd, r, out,
                                        conv=conv,
                                        imgcount=imgcount,
                                        order=order,
                                        change_units=change_units,
                                        mult=mult,
                                        fractions=convert.FRACTIONS_NORMAL, #1/2 1/4 3/4 fractions
                                        do_markup=False #we'll handle this internally...
                                        )


    def setup_document (self, doc=None, ss=None):
        if doc: self.doc=doc        
        else: self.doc = PyRTF.Document()
        if ss: self.ss=ss
        else: self.ss = self.doc.StyleSheet
        self.ss.ParagraphStyles.Normal.TextStyle.TextPropertySet.Font = self.ss.Fonts.TimesNewRoman
        self.ss.ParagraphStyles.Heading1.TextStyle.TextPropertySet.Bold = True
        if not hasattr(self.ss.ParagraphStyles, 'Heading3'):
            ps = PyRTF.ParagraphStyle('Heading 3',
                                      PyRTF.TextStyle(PyRTF.TextPropertySet(self.ss.Fonts.Arial, 22)),
                                      PyRTF.ParagraphPropertySet( space_before=240,
                                                                  space_after = 60),
                                      )
            self.ss.ParagraphStyles.append( ps )        

    def write_head (self):        
        self.recsection = PyRTF.Section(break_type=PyRTF.Section.PAGE)
        self.doc.Sections.append( self.recsection )
        self.add_paragraph("%s\n"%self.r.title,self.ss.ParagraphStyles.Heading1)
        
    def write_foot (self):
        if not self.multidoc:
            renderer = PyRTF.Renderer()
            renderer.Write(self.doc,self.out)
    
    def write_attr_head (self):
        #self.add_paragraph(" ")
        pass

    def write_attr (self, label, text):
        if label!=_('Title'):
            self.add_paragraph("\n%s: %s"%(label,text))
        
    def write_attr_foot (self):
        self.add_paragraph(" ")

    def write_text (self, label, text):
        if not text: return
        self.add_paragraph(label, style=self.ss.ParagraphStyles.Heading2)
        pars=text.split("\n")
        # since we may have to deal with markup, we're going to handle this
        # on our own...
        for par in pars:
            p = PyRTF.Paragraph(self.ss.ParagraphStyles.Normal)
            # this code is partly copied from handle_markup in
            # exporter.py (a bit dumb, I know...)
            import pango, xml.sax.saxutils
            try:
                al,txt,sep = pango.parse_markup(par,u'\x00')
            except:
                al,txt,sep = pango.parse_markup(xml.sax.saxutils.escape(par),u'\x00')
            ai = al.get_iterator()
            more = True
            while more:
                fd,lang,atts=ai.get_font()
                chunk=xml.sax.saxutils.escape(txt.__getslice__(*ai.range()))
                fields=fd.get_set_fields()
                style_args = {'font':self.ss.Fonts.TimesNewRoman}
                if fields != 0:
                    if 'style' in fields.value_nicks and fd.get_style()==pango.STYLE_ITALIC:
                        style_args['italic']=True
                    if 'weight' in fields.value_nicks and fd.get_weight()==pango.WEIGHT_BOLD:
                        style_args['bold']=True
                if filter(lambda att: att.type==pango.ATTR_UNDERLINE and att.value==pango.UNDERLINE_SINGLE,
                          atts):
                    style_args['underline']=True
                p.append(
                         PyRTF.Elements.TEXT(encode_text(chunk),
                                             **style_args)
                         )
                more = ai.next()
            self.recsection.append(p)

    def write_inghead (self):
        self.add_paragraph("Ingredients", style=self.ss.ParagraphStyles.Heading2)

    def write_grouphead (self, text):
        self.add_paragraph(text,style=self.ss.ParagraphStyles.Heading3)

    def write_ingref (self, amount=1, unit=None,
                      item=None, optional=False,
                      refid=None):
        ### DOES RTF SUPPORT LINKING? IF SO, WE SHOULD DO BETTER HERE...
        self.write_ing(amount,unit,item,None,optional)
        
    def write_ing (self, amount=1, unit=None, item=None, key=None, optional=False):
        txt = ""
        for p in amount, unit, item:
            if p: txt += "%s "%p
        if optional: txt += "(optional) "
        txt = txt[0:-1] #strip trailing space
        self.add_paragraph(txt)

    def write_image (self, image):
        try:
            i=PyRTF.Image(write_image_tempfile(image))
            self.recsection.append(i)
            self.add_paragraph(" ")
        except AttributeError:
            # If PyRTF has no attribute Image, this is an old version
            # and we can't do anything with images.
            pass
    
    def add_paragraph (self, text, style=None):
        args = []
        if style: args.append(style)
        else: args.append(self.ss.ParagraphStyles.Normal)
        p=PyRTF.Paragraph(*args)
        p.append(encode_text(text))
        self.recsection.append(p)


def encode_text (txt):
    """Encode our text in codepage 1252."""
    #return txt
    try:
        return txt.encode('cp1252','strict')
    except:
        try:
            return txt.encode('cp1252','strict')
        except:
            return txt.encode('cp1252','replace')
    
if __name__ == '__main__':
    from __init__ import Tester,RTF
    t = Tester()
    print 'Exporting test to /tmp/test_recs.rtf'
    import sys
    t.run_export(**{'format':RTF,
                    'rv':t.rm.recipe_table[4:9],
                    'rec':t.rm.recipe_table[-1],
                    #'mode':'exporter',
                    'mode':'mult_exporter',
                    'file':'/tmp/test_recs.rtf',
                    'prog':lambda *args,**kwargs: sys.stderr.write("%s%s"%(args,kwargs)),
                    'out':file('/tmp/test_rec.rtf','wb'),
                    })
    

########NEW FILE########
__FILENAME__ = test_exportManager
# -*- coding: utf-8 -*-
import unittest, tempfile, os
import gourmet.gglobals
tmpdir = tempfile.mktemp()
os.makedirs(tmpdir)
gourmet.gglobals.gourmetdir = tmpdir
import gourmet.GourmetRecipeManager
import gourmet.backends.db
gourmet.backends.db.RecData.__single = None
gourmet.GourmetRecipeManager.GourmetApplication.__single = None
import exportManager

class SampleRecipeSetterUpper:

    __single = None

    recipes = {
        'simple recipe' : {
            'recipe' : {'title':'Simple Test','cuisine':'Indian','instructions':'Cook as usual','modifications':'Unless you want to get fancy',
                        'preptime':3600,'cooktime':11239},
            'categories':['Healthy','Bread'],
            'ingredients':[
                {'amount':1,'unit':'cup','item':'water','ingkey':'water, municipal'},
                {'amount':2,'unit':'cups','item':'atta flour','ingkey':'flour, atta (whole wheat)'},
                {'amount':2,'unit':'Tbs','item':'salt','ingkey':'salt, table'},
                {'amount':1,'unit':'tsp','item':'black pepper','ingkey':'pepper, black', 'optional':True},                
                ],
            },
        'unicode': {
            'recipe' : {'title':u'¡Jalapeño extravaganza!','yields':3,'yield_unit':'cups'},
            'categories': ['Spicy','Healthy'],
            'ingredients':[
                {'amount':1,'unit':'cup','item':'water','ingkey':'water, municipal'},
                {'amount':1,'unit':'lb','item':u'jalapeño','ingkey':'pepper, habañero'},
                {'amount':2,'unit':u'más','item':u'habañeros','ingkey':u'pepper, habañero'},                
                ]
            },
        'formatting': {
            'recipe' : {
                'title':u'Recipe with formatting',
                'instructions':u'''These are my <i>instructions</i> I would like to <b>see</b> what you <u>think</u> of them.

<span color="red">Aren\'t these pretty nifty?</span>''',
                'modifications':u'''These are my <i>notes</i> I would like to <b>see</b> what you <u>think</u> of them.

<span color="blue">Aren\'t these pretty nifty?</span>''',
                },
            'ingredients':[
                {'amount':1,'unit':'cup','item':'water','ingkey':'water, municipal'},
                {'amount':1,'unit':'lb','item':u'jalapeño','ingkey':'pepper, habañero'},
                {'amount':2,'unit':u'más','item':u'habañeros','ingkey':u'pepper, habañero'},                
                ]
            },

        
        }
    
    def __init__ (self):
        print 'Instantiate SampleRecipeSetterUpper',self
        if SampleRecipeSetterUpper.__single: raise SampleRecipeSetterUpper.__single
        else: SampleRecipeSetterUpper.__single = self
        self.db = gourmet.backends.db.get_database()
        for rec in self.recipes:
            self.add_rec(self.recipes[rec])
    
    def add_rec (self, recdic):
        recdic['recipe']['deleted']=False
        r = self.db.add_rec(recdic['recipe'])
        recid = r.id; print 'added rec',r.id
        recdic['recipe_id'] = r.id
        if recdic.has_key('categories'):
            for c in recdic['categories']:
                print 'add categories',c
                self.db.do_add_cat({'recipe_id':recid,'category':c})
        if recdic.has_key('ingredients'):
            print 'Add ingredients...'
            for i in recdic['ingredients']:
                i['recipe_id'] = recid; i['deleted']=False
                print i
            self.db.add_ings(recdic['ingredients'])
        print 'done add_rec\n-------'
        rec = self.db.get_rec(recdic['recipe_id']); print rec
        print self.db.get_cats(rec)
        print self.db.get_ings(rec)
        print '^^^^^^^^^^^^^^^^^^^^'
    
def setup_sample_recs ():
    try:
        return SampleRecipeSetterUpper()
    except SampleRecipeSetterUpper, srsu:
        print 'Returning single...'
        return srsu

class TestSetterUpper (unittest.TestCase):
     def setUp (self):
         setup_sample_recs()
    
     def testSetup (self):
         from gourmet.GourmetRecipeManager import get_application, GourmetApplication
         #GourmetApplication.__single = None
         app = get_application(); app.window.show()
         import gtk
         gtk.main()
    
class TestExports (unittest.TestCase):
    def setUp (self):
        self.sample_recs = setup_sample_recs()
        self.recs = self.sample_recs.recipes
        self.em = exportManager.get_export_manager()
        self.db = gourmet.backends.db.get_database()

    def testMultipleExporters (self):

        def fail_on_fail (thread, errorval, errortext, tb):
            self.failUnless(False,errortext+'\n\n'+tb)

        for format,plugin in self.em.plugins_by_name.items():
            filters = plugin.saveas_filters
            ext = filters[-1][-1].strip('*.')
            exceptions = []
            recs =   [self.db.get_rec(self.recs['simple recipe']['recipe_id']),
                      self.db.get_rec(self.recs['unicode']['recipe_id']),
                      self.db.get_rec(self.recs['formatting']['recipe_id']),
                      ]
            plugin,exporter = self.em.get_multiple_exporter(recs,'/tmp/All.'+ext,format,
                                                   extra_prefs=exportManager.EXTRA_PREFS_DEFAULT)
            exporter.connect('error', fail_on_fail)
            done = False
            def done (*args):
                done = True
            exporter.connect('done',done)
            exporter.do_run()


    def testSingleExport (self):
        for format,plugin in self.em.plugins_by_name.items():
            filters = plugin.saveas_single_filters
            ext = filters[-1][-1].strip('*.')
            for rec, f in [(self.db.get_rec(self.recs['simple recipe']['recipe_id']),'/tmp/Simple.'+ext),
                           (self.db.get_rec(self.recs['unicode']['recipe_id']),'/tmp/Uni.'+ext),
                           (self.db.get_rec(self.recs['formatting']['recipe_id']),'/tmp/Formatted.'+ext),
                           ]:
                self.em.do_single_export(rec,f,format,
                                         extra_prefs=exportManager.EXTRA_PREFS_DEFAULT)
                if hasattr(plugin,'check_export'):
                    print 'Checking export for ',plugin,rec,f
                    fi = open(f,'r')
                    try:
                        plugin.check_export(rec,fi)
                    except:
                        import traceback
                        self.assertEqual(1,2,'Exporter test for %s on file %s raised error %s'%(
                            plugin,f,traceback.format_exc()
                            )
                                          )
                    finally:
                        fi.close()
    
if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = xml_exporter
from exporter import exporter_mult
import xml.dom
import types
# Base XML exporter class

class XmlExporter (exporter_mult):

    #doc_element = 'rec'
    #doctype_desc = ''
    #dtd_path = ''
    
    def __init__ (self, rd, r, out,
                  order=['attr','image','ings','text'],
                  xmlDoc=None,
                  **kwargs):
        if xmlDoc:
            self.xmlDoc = xmlDoc
            self.i_created_this_document = False
            self.top_element = self.xmlDoc.childNodes[1]
        else:
            self.create_xmldoc()
        exporter_mult.__init__(self, rd,r,out,
                               use_ml=True,
                               convert_attnames=False,
                               do_markup=True,
                               order=order,
                               **kwargs)

    def create_xmldoc (self):
        self.i_created_this_document = True
        impl = xml.dom.getDOMImplementation()
        doctype = impl.createDocumentType(
            self.doc_element,
            self.doctype_desc,
            self.dtd_path
            )
        self.xmlDoc = impl.createDocument(None,self.doc_element,doctype)
        self.top_element = self.xmlDoc.documentElement

    # Convenience methods
    def set_attribute (self, element, attribute, value):
        a = self.xmlDoc.createAttribute(attribute)
        element.setAttributeNode(a)
        element.setAttribute(attribute,value)
        
    def append_text (self, element, text):
        try:
            assert(type(text) in types.StringTypes)
        except:
            print 'Text is not text'
            print 'append_text received',element,text
            raise TypeError(text+' is not a StringType')
        try:
            t = self.xmlDoc.createTextNode(text)
            element.appendChild(t)
        except:
            print 'FAILED WHILE WORKING ON ',element
            print 'TRYING TO APPEND',text[:100]
            raise
            
    def create_text_element (self, element_name, text, attrs={}):
        element = self.create_element_with_attrs(element_name,attrs)
        self.append_text(element,text)
        return element

    def create_element_with_attrs (self, element_name, attdic):
        element = self.xmlDoc.createElement(element_name)
        for k,v in attdic.items():
            self.set_attribute(element,k,str(v))
        return element


########NEW FILE########
__FILENAME__ = gdebug
from OptionParser import args
import time,traceback

debug_level=args.debug
debug_file=args.debug_file
timestamp=args.time

if debug_file:
    import re
    debug_file = re.compile(debug_file)

if debug_level > 0: print 'DEBUG_LEVEL=',debug_level
if debug_file: print 'DEBUG_FILE=',debug_file

def debug_decorator (f):
    def _ (*args, **kwargs):
        print 'Calling ',f.__name__,'with ',args,kwargs
        ret = f(*args,**kwargs)
        print 'Returning:',ret
        return ret
    return _

def debug (message, level=10):
    if timestamp: ts= '%s:'%time.time()
    else: ts = ''
    if level <= debug_level:
        stack = traceback.extract_stack()
        if len(stack) >= 2:
            caller=stack[-2]
            finame=caller[0]
            line = caller[1]
        else:
            finame = " ".join(stack)
            line = ""
        if args.debug_file:
            if debug_file.search(finame):
                print "DEBUG: ",ts,"%s: %s"%(finame,line),message
        else:
            print "DEBUG: ",ts,"%s: %s"%(finame,line),message

timers = {}

class TimeAction:
    def __init__ (self, name, level=10):
        self.level = level
        if level <= debug_level:
            self.name = name            
            self.start = time.time()

    def end (self):   
        if self.level <= debug_level:
            end = time.time()
            t=end-self.start
            # grab our location
            stack=traceback.extract_stack()
            if len(stack)>2:
                caller=stack[-2]
                finame=caller[0]
                line = caller[1]
            else:
                finame = " ".join(stack)
                line = ""
            if not args.debug_file or debug_file.search(finame):
                print "DEBUG: %s TOOK %s SECONDS"%(self.name,t)
                if not timers.has_key(self.name): timers[self.name]=[t]
                else: timers[self.name].append(t)


def print_timer_info ():
    for n,times in timers.items():
        print "%s:"%n,
        for t in times: print "%.02e"%t,",",
        print ""
    
if __name__ == '__main__':
    t=TimeAction('this is a test',0)
    debug('This is a test',0)
    debug('This is another test',0)
    t.end()
    print_timer_info()

########NEW FILE########
__FILENAME__ = gglobals
import os, os.path, gobject, re, gtk
import tempfile
from gdebug import debug
from OptionParser import args

tmpdir = tempfile.gettempdir()

if args.gourmetdir:
    gourmetdir = args.gourmetdir
    debug("User specified gourmetdir %s"%gourmetdir,0)
else:
    if os.name =='nt':
        APPDATA = os.environ.get('APPDATA',None)
        gourmetdir = os.path.join(APPDATA,'gourmet')
    else:
        gourmetdir = os.path.join(os.path.expanduser('~'),'.gourmet')
try:
    if not os.path.exists(gourmetdir):
        debug('Creating %s'%gourmetdir,0)
        os.makedirs(gourmetdir)
except OSError:
    try:
        debug("Unable to create standard config directory in home directory. Looking for .gourmet in working directory instead.",0)
        gourmetdir = '.gourmet'
        if not os.path.exists(gourmetdir):
            debug("Creating .gourmet in working directory",0)
            os.makedirs(gourmetdir)
    except OSError:
        print "Unable to create gourmet directory."
        raise
        import sys
        sys.exit()


if not os.access(gourmetdir,os.W_OK):
    debug('Cannot write to configuration directory, %s'%gourmetdir,-1)
    import sys
    sys.exit()        
    
debug('gourmetdir=%s'%gourmetdir,2)

use_threads = args.threads
# Uncomment the below to test FauxThreads
#use_threads = False

# note: this stuff must be kept in sync with changes in setup.py
import settings
uibase = os.path.join(settings.ui_base)
lib_dir = os.path.join(settings.lib_dir,'gourmet')

# To have strings from .ui files (gtk.Builder) translated on all platforms,
# we need the following module to enable localization on all platforms.
try:
    import elib.intl
    elib.intl.install('gourmet', settings.locale_base)
except ImportError:
    print 'elib.intl failed to load.'
    print 'IF YOU HAVE TROUBLE WITH TRANSLATIONS, MAKE SURE YOU HAVE THIS LIBRARY INSTALLED.'
from gettext import gettext as _

data_dir = settings.data_dir
imagedir = os.path.join(settings.data_dir,'images')
style_dir = os.path.join(settings.data_dir,'style')

icondir = os.path.join(settings.icon_base,"48x48","apps")
doc_base = settings.doc_base
plugin_base = settings.plugin_base

# GRAB PLUGIN DIR FOR HTML IMPORT
if args.html_plugin_dir:
    html_plugin_dir = args.html_plugin_dir
else:
    html_plugin_dir = os.path.join(gourmetdir,'html_plugins')
    if not os.path.exists(html_plugin_dir):
        os.makedirs(html_plugin_dir)
        template_file = os.path.join(settings.data_dir,'RULES_TEMPLATE')
        if os.path.exists(template_file):
            import shutil
            shutil.copy(template_file,
                        os.path.join(html_plugin_dir,'RULES_TEMPLATE')
                        )

REC_ATTRS = [('title',_('Title'),'Entry'),
             ('category',_('Category'),'Combo'),
             ('cuisine',_('Cuisine'),'Combo'),
             ('rating',_('Rating'),'Entry'),
             ('source',_('Source'),'Combo'),
             ('link',_('Website'),'Entry'),
             ('yields',_('Yield'),'Entry'),
             ('yield_unit',_('Yield Unit'),'Combo'),             
             ('preptime',_('Preparation Time'),'Entry'),
             ('cooktime',_('Cooking Time'),'Entry'),
             ]

INT_REC_ATTRS = ['rating','preptime','cooktime']
FLOAT_REC_ATTRS = ['yields']
TEXT_ATTR_DIC = {'instructions':_('Instructions'),
                 'modifications':_('Notes'),
                 }

REC_ATTR_DIC={}
NAME_TO_ATTR = {_('Instructions'):'instructions',
                _('Notes'):'modifications',
                _('Modifications'):'modifications',
                }

DEFAULT_ATTR_ORDER = ['title',
                      #'servings',
                      'yields',
                      'cooktime',
                      'preptime',
                      'category',
                      'cuisine',
                      'rating',
                      'source',
                      'link',
                      ]

DEFAULT_TEXT_ATTR_ORDER = ['instructions',
                           'modifications',]

def build_rec_attr_dic ():
    for attr, name, widget in REC_ATTRS:
        REC_ATTR_DIC[attr]=name
        NAME_TO_ATTR[name]=attr

build_rec_attr_dic()

DEFAULT_HIDDEN_COLUMNS = [REC_ATTR_DIC[attr] for attr in
                          ['link','yields','yield_unit','preptime','cooktime']
                          ]
    
from gtk_extras import dialog_extras

def launch_url (url, ext=""):
    if os.name == 'nt':
        os.startfile(url)
    elif os.name == 'posix':
        try:
            gtk.show_uri(gtk.gdk.Screen(),url,0L)
        except gobject.GError, err:
            #print dir(err)
            label = _('Unable to open URL')
            for reg, msg in [('mailto:',_('Unable to launch mail reader.')),
                             ('http:',_('Unable to open website.')),
                             ('file:',_('Unable to open file.'))]:
                if re.match(reg,url.lower()): label = msg
            dialog_extras.show_message(
                label=label,
                sublabel=err.message,
                expander=[_('_Details'),
                          _("There was an error launching the url: %s"%url)]
                )

# Set up custom STOCK items and ICONS!
icon_factory = gtk.IconFactory()
    
def add_icon (file_name, stock_id, label=None, modifier=0, keyval=0):
    pb = gtk.gdk.pixbuf_new_from_file(file_name)
    iconset = gtk.IconSet(pb)
    icon_factory.add(stock_id,iconset)
    icon_factory.add_default()
    gtk.stock_add([(stock_id,
                    label,
                    modifier,
                    keyval,
                    "")])

for filename,stock_id,label,modifier,keyval in [    
    ('AddToShoppingList.png','add-to-shopping-list',_('Add to _Shopping List'),gtk.gdk.CONTROL_MASK,gtk.gdk.keyval_from_name('l')),
    ('reccard.png','recipe-card',None,0,0),
    ('reccard_edit.png','edit-recipe-card',None,0,0),    
    ]:
    add_icon(os.path.join(imagedir,filename),stock_id,label,modifier,keyval)

########NEW FILE########
__FILENAME__ = GourmetRecipeManager
#!/usr/bin/env python
import os.path, os, re, threading, string
import gtk, gobject, gtk.gdk
import batchEditor
import recipeManager
from exporters.printer import get_print_manager
import prefs, prefsGui, shopgui, reccard
import exporters
from exporters.exportManager import get_export_manager
from importers.importManager import get_import_manager
import convert, version
from gtk_extras import fix_action_group_importance
from gtk_extras import ratingWidget, WidgetSaver, mnemonic_manager
from gtk_extras import dialog_extras as de
from gtk_extras import treeview_extras as te
from gdebug import debug
from gglobals import DEFAULT_HIDDEN_COLUMNS, REC_ATTRS, doc_base, icondir, imagedir, launch_url, uibase
from recindex import RecIndex
from gettext import gettext as _
from gettext import ngettext
from timer import show_timer
from defaults.defaults import lang as defaults
from defaults.defaults import get_pluralized_form
import plugin_loader, plugin, plugin_gui
from threadManager import get_thread_manager, get_thread_manager_gui, SuspendableThread

UNDO = 1
SHOW_TRASH = 2

try:
    from exporters import rtf_exporter
    rtf=True
except ImportError:
    debug('No RTF support',0)
    rtf=False

class GourmetApplication:
    """The main Gourmet Application.

    This handles everything that needs to be handled across the
    different interfaces -- updating the view menu, and so on.

    This handles plugin registration, configuration, and so on.
    """

    shared_go_menu = '''
    <ui>
    <menubar name="%(name)s">
    <menu name="Go" action="Go">
    <menuitem action="GoRecipeIndex"/>
    </menu></menubar></ui>
    '''
    go_path = '/%(name)s/Go/'

    __single = None
    
    def __init__ (self, splash_label=None):
        if GourmetApplication.__single:
            raise GourmetApplication.__single
        GourmetApplication.__single = self
        # These first two items might be better handled using a
        # singleton design pattern... 
        self.splash_label = splash_label
        self.conv = convert.get_converter() 
        self.star_generator = ratingWidget.StarGenerator()        
        # Setup methods...
        self.setup_prefs() # Setup preferences...
        self.setup_plugins()
        self.setup_recipes() # Setup recipe database
        #self.setup_nutrition()
        self.setup_shopping()
        self.setup_go_menu()
        self.rc={}
        self.exportManager = get_export_manager()
        self.importManager = get_import_manager()

    def setup_plugins (self):
        pass

    def show_preferences (self, *args):
        self.prefsGui.show_dialog(page=self.prefsGui.INDEX_PAGE)

    # Setup preferences system
    def setup_prefs (self):
        self.conf = []        
        self.prefs = prefs.get_prefs()
        self.prefsGui = prefsGui.PreferencesGui(
            self.prefs,
            buttons={'clear_remembered_optional_button':lambda *args: self.forget_remembered_optional_ingredients()}
            )
        self.prefsGui.apply_prefs_dic['recipes_per_page'] = lambda p,v: getattr(getattr(self,'rmodel'),
                                                                               'change_items_per_page')(v)
        
        def toggleFractions (prefname,use):
            if use:
                convert.USE_FRACTIONS = convert.FRACTIONS_NORMAL
            else:
                convert.USE_FRACTIONS = convert.FRACTIONS_OFF
        self.prefsGui.apply_prefs_dic['useFractions'] = toggleFractions
        # Call our method once with the default prefs to apply saved
        # user settings
        toggleFractions(None,
                        self.prefs.get('useFractions',
                                       defaults.LANG_PROPERTIES['useFractions']
                                       )
                        )

    # Splash convenience method for start-up splashscreen
    def update_splash (self, text):
        """Update splash screen on startup."""
        debug("Setting splash text: %s"%text,3)
        if not self.splash_label: return
        self.splash_label.set_text(text)        
        while gtk.events_pending():
            gtk.main_iteration()
                
    # Convenience method for showing progress dialogs for import/export/deletion
    def show_progress_dialog (self, thread, progress_dialog_kwargs={},message=_("Import paused"),
                           stop_message=_("Stop import")):
        """Show a progress dialog"""
        if hasattr(thread,'name'): name=thread.name
        else: name = ''
        for k,v in [('okay',True),
                    ('label',name),
                    ('parent',self.app),
                    ('pause',self.pause_cb),
                    ('stop',self.stop_cb),
                    ('modal',False),]:
            if not progress_dialog_kwargs.has_key(k):
                progress_dialog_kwargs[k]=v
        if not hasattr(self,'progress_dialog') or not self.progress_dialog:
            self.progress_dialog = de.ProgressDialog(**progress_dialog_kwargs)
            self.prog = self.progress_dialog.progress_bar
        else:
            self.progress_dialog.reassign_buttons(pausecb=progress_dialog_kwargs['pause'],
                                              stopcb=progress_dialog_kwargs['stop'])
            self.progress_dialog.reset_label(progress_dialog_kwargs['label'])
        self.pause_message = message
        self.stop_message = stop_message
        self.thread = thread        
        self.progress_dialog.show()
        self.progress_dialog.connect('close',lambda *args: setattr(self.progress_dialog,None))
        
    def hide_progress_dialog (self):
        """Make the progress dialog go away."""
        if hasattr(self,'progress_dialog') and self.progress_dialog:
            self.progress_dialog.hide()
            self.progress_dialog.destroy()
            self.progress_dialog = None

    # setup recipe database
    def setup_recipes (self):
        """Initialize recipe database.

        We load our recipe database from recipeManager. If there's any problem,
        we display the traceback to the user so they can send it out for debugging
        (or possibly make sense of it themselves!)."""
        self.rd = recipeManager.default_rec_manager()
        # initiate autosave stuff autosave every 3 minutes
        # (milliseconds * 1000 milliseconds/second * 60
        # seconds/minute)
        def autosave ():
            self.rd.save()
            return True
        AUTOSAVE_EACH_N_MINUTES = 2
        gobject.timeout_add(1000*60*AUTOSAVE_EACH_N_MINUTES,autosave)
        # connect hooks to modify our view whenever and
        # whenceever our recipes are updated...
        self.rd.modify_hooks.append(self.update_attribute_models)
        self.rd.add_hooks.append(self.update_attribute_models)
        self.rd.delete_hooks.append(self.update_attribute_models)
        # we'll need to hand these to various other places
        # that want a list of units.
        self.umodel = UnitModel(self.conv)
        self.attributeModels = []
        self.inginfo = reccard.IngInfo(self.rd)

    def setup_shopping (self):
        """Setup shopping related stuff"""
        #self.create_rmodel(self.rd.recipe_table)
        self.sl = shopgui.ShopGui()
        self.sl.hide()

    # Methods for keeping track of open recipe cards...
    def del_rc (self, id):
        """Forget about recipe card identified by id"""
        if self.rc.has_key(id):
            del self.rc[id]
        self.update_go_menu()

    def update_reccards (self, rec):
        if self.rc.has_key(rec.id):
            rc=self.rc[rec.id]
            rc.updateRecipe(rec,show=False)
            self.update_go_menu()

    def go_menu (self):
        """Build a _View menu based on recipes currently
        opened in recipe cards."""
        m=gtk.Menu()
        ri=gtk.MenuItem(_('Recipe _Index'))
        sh=gtk.MenuItem(_('Shopping _List'))
        separator=gtk.MenuItem()
        ri.connect('activate',lambda *args: self.app.present())
        sh.connect('activate',self.sl.show)
        m.append(ri)
        ri.show()
        m.append(sh)
        sh.show()
        m.append(separator)
        separator.show()
        for rc in self.rc.values():
            i=gtk.MenuItem("_%s"%rc.current_rec.title)
            i.connect('activate',rc.show)
            m.append(i)
            i.show()
        return m

    def setup_go_menu (self):
        self.goActionGroup = gtk.ActionGroup('GoActions')
        self.goActionGroup.add_actions([('Go',None,_('_Go'))])
        self.uimanagers = {}
        self.merged_go_menus = {}

    def add_uimanager_to_manage (self, id, uimanager, menu_root_name):
        fix_action_group_importance(self.goActionGroup)
        uimanager.insert_action_group(self.goActionGroup,0)
        uimanager.add_ui_from_string(self.shared_go_menu%{'name':menu_root_name})
        self.uimanagers[id] = [uimanager,menu_root_name,
                               {} # a dictionary of added menu items
                               ]

    def update_action_group (self):
        for rc in self.rc.values():
            action_name = 'GoRecipe'+str(rc.current_rec.id)
            existing_action = self.goActionGroup.get_action(action_name)
            if not existing_action:
                self.goActionGroup.add_actions(
                    [(action_name,None,'_'+rc.current_rec.title,
                      None,None,rc.show)]
                    )
            else:
                if existing_action.get_property('label') != '_'+rc.current_rec.title:
                    existing_action.set_property('label','_'+rc.current_rec.title)

    def update_go_menu (self):
        self.update_action_group()
        for uiid in self.uimanagers:
            self.update_go_menu_for_ui(uiid)
            
    def update_go_menu_for_ui (self, id):
        """Update the go_menu of interface identified by ID

        The interface must have first been handed to
        add_uimanager_to_manage
        """
        uimanager,menu_root_name,merged_dic = self.uimanagers[id]
        for rc in self.rc.values():
            path = self.go_path%{'name':menu_root_name} + 'GoRecipe'+str(rc.current_rec.id)
            if not uimanager.get_widget(path):
                actionName = 'GoRecipe'+str(rc.current_rec.id)
                uistring = '''<menubar name="%(menu_root_name)s">
                <menu name="Go" action="Go">
                <menuitem action="%(actionName)s"/>
                </menu>
                </menubar>'''%locals()
                merge_id = uimanager.add_ui_from_string(uistring)
                merged_dic[rc.current_rec.id] = merge_id
                uimanager.ensure_update()                
        for idkey in merged_dic:
            if not self.rc.has_key(idkey):
                uimanager.remove_ui(merged_dic[idkey])

    # Methods to keep one set of listmodels for each attribute for
    # which we might want text completion or a dropdown...
    def update_attribute_models (self):
        for attr,mod in self.attributeModels:
            self.update_attribute_model(attr)
            
    def update_attribute_model (self, attribute):
        slist = self.create_attribute_list(attribute)
        model = getattr(self,'%sModel'%attribute)
        for n,item in enumerate(slist):
            if model[n][0] == item:
                continue
            else:
                # See if we match something later in the model -- if
                # we do, suck up the whole model
                additional = 1
                found_match = False
                while len(model) > (n+additional):
                    if model[n+additional][0] == item:
                        while additional > 0:
                            model.remove(model.get_iter(n))
                            additional -= 1
                            found_match = False
                        break
                    additional += 1
                if not found_match:
                    model.insert(n,[item])
        while len(model) > len(slist):
            last = model.get_iter(len(model) - 1)
            model.remove(last)

            return model

    def create_attribute_list (self, attribute):
        """Create a ListModel with unique values of attribute.
        """
        if attribute=='category':
            slist = self.rg.rd.get_unique_values(attribute,self.rg.rd.categories_table)
        else:
            slist = self.rg.rd.get_unique_values(attribute,deleted=False)
        if not slist:
            slist = self.rg.rd.get_default_values(attribute)
        else:
            for default_value in self.rg.rd.get_default_values(attribute):
                if default_value not in slist: slist.append(default_value)
        slist.sort()
        return slist

    def get_attribute_model (self, attribute):
        """Return a ListModel with a unique list of values for attribute.
        """
        # This was stored here so that all the different comboboxes that
        # might need e.g. a list of categories can share 1 model and
        # save memory.
        # if not hasattr(self,'%sModel'%attribute): 
        slist = self.create_attribute_list(attribute)
        m = gtk.ListStore(str)
        for i in slist: m.append([i])
        setattr(self,'%sModel'%attribute,m)
        self.attributeModels.append((attribute,getattr(self,'%sModel'%attribute)))
        return getattr(self,'%sModel'%attribute)

    # About/Help
    def show_about (self, *args):
        """Show information about ourselves."""
        debug("show_about (self, *args):",5)
        translator=_("translator-credits")
        # translators should translate the string 'translator-credits'
        # If we're not using a translation, then this isn't shown
        if translator == "translator-credits":
            translator = None
        # Grab CREDITS from our defaults_LANG file too!
        if hasattr(defaults,'CREDITS') and defaults.CREDITS:
            if translator and translator.find(defaults.CREDITS) > -1:
                translator += "\n%s"%defaults.CREDITS
            else:
                translator = defaults.CREDITS

        logo=gtk.gdk.pixbuf_new_from_file(os.path.join(icondir,"gourmet.png"))

        # load LICENSE text file
        try:
            license_text = open(os.path.join(doc_base,'LICENSE'),'r').read()
        except IOError, err:
            print "IO Error %s" % err
        except:
            print "Unexpexted error"

        paypal_link = """https://www.paypal.com/cgi-bin/webscr?cmd=_donations
&business=Thomas_Hinkle%40alumni%2ebrown%2eedu
&lc=US&item_name=Gourmet%20Recipe%20Manager%20Team&no_note=0&currency_code=USD
&bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHostedGuest"""
        gittip_link = "https://www.gittip.com/on/github/thinkle/"
        flattr_link = "http://flattr.com/profile/Thomas_Hinkle/things"

        about = gtk.AboutDialog()
        about.set_artists(version.artists)
        about.set_authors(version.authors)
        about.set_comments(version.description)
        about.set_copyright(version.copyright)
        #about.set_documenters(None)
        about.set_license(license_text)
        about.set_logo(logo)
        about.set_program_name(version.appname)
        about.set_translator_credits(translator)
        about.set_version(version.version)
        #about.set_wrap_license(True)
        about.set_website(version.website)
        #about.set_website_label('Gourmet website')

        donation_buttons = gtk.HButtonBox()
        donation_buttons.set_layout(gtk.BUTTONBOX_SPREAD)
        donations_label = gtk.Label(_("Please consider making a donation to "
        "support our continued effort to fix bugs, implement features, "
        "and help users!"))
        donations_label.set_line_wrap(True)
        donations_label.show()
        paypal_button = gtk.LinkButton(paypal_link, _("Donate via PayPal"))
        paypal_button.show()
        flattr_button = gtk.LinkButton(flattr_link, _("Micro-donate via Flattr"))
        flattr_button.show()
        gittip_button = gtk.LinkButton(gittip_link, _("Donate weekly via Gittip"))
        gittip_button.show()
        donation_buttons.add(paypal_button)
        donation_buttons.add(gittip_button)
        donation_buttons.add(flattr_button)
        donation_buttons.show()
        content = about.get_content_area()
        content.add(donations_label)
        content.add(donation_buttons)

        about.run()
        about.destroy()

    def show_help (self, *args):
        de.show_faq(os.path.join(doc_base,'FAQ'))

    def save (self, file=None, db=None, xml=None):
        debug("save (self, file=None, db=None, xml=None):",5)
        if file and not xml and not db:
            if re.search(".xml$",file):
                xml=file
            else:
                db=file
        if xml:
            self.exportXML(file)
        else:
            self.rd.file=db
            self.rd.save()
            self.message(_("Saved!"))
        self.loader.save_active_plugins() # relies on us being a pluggable...
        
    def quit (self):
        for c in self.conf:
            c.save_properties()
        for r in self.rc.values():
            for c in r.conf:
                c.save_properties()
            if r.edited and de.getBoolean(parent=self.app,
                                             label=_("Save your edits to %s")%r.current_rec.title):
                r.recipe_editor.save_cb()
            else:
                r.edited=False # in case someone else checks this (e.g. reccard on close)
        for conf in self.sl.conf:
            conf.save_properties()
        self.prefs.save()
        threads=threading.enumerate()        
        if len(threads) > 1:
            msg = "Another process is in progress"
            for t in threads:
                if "import" in t.getName(): msg = _("An import is in progress.")
                if "export" in t.getName(): msg = _("An export is in progress.")
                if "delete" in t.getName(): msg = _("A delete is in progress.")
            quit_anyway = de.getBoolean(label=msg,
                                        sublabel=_("Exit program anyway?"),
                                        custom_yes=gtk.STOCK_QUIT,
                                        custom_no=_("Don't exit!"),
                                        cancel=False)
            if quit_anyway:
                for t in threads:
                    if t.getName() !='MainThread':
                        try:
                            t.terminate()
                        except:
                            debug("Unable to terminate thread %s"%t,0)
                            # try not to lose data if this is going to
                            # end up in a force quit
                            #self.save_default() 
                            return True
                if not use_threads:
                    for t in self._threads:
                        try:
                            t.terminate()
                            self.threads = self.threads - 1
                        except:
                            # try not to lose data if this is going to
                            # end up in a force quit
                            #self.save_default()
                            return True
            else:
                return True
        # Delete our deleted ingredient keys -- we don't need these
        # for posterity since there is no "trash" interface for
        # ingredients anyway.
        self.rd.delete_by_criteria(self.rd.ingredients_table,{'deleted':True})
        # Save our recipe info...
        self.save()
        for r in self.rc.values():
            r.hide()

class SuspendableDeletions (SuspendableThread):

    def __init__ (self, recs, name=None):
        self.recs = recs
        self.rg = get_application()
        SuspendableThread.__init__(self, name=name)

    def do_run (self):
        tot = len(self.recs)
        for n,r in enumerate(self.recs):
            self.check_for_sleep()
            self.rg.rd.delete_rec(r)
            self.emit('progress',float(n)/tot,_('Permanently deleted %s of %s recipes')%(n,tot))

class RecTrash (RecIndex):

    default_searches = [{'column':'deleted','operator':'=','search':True}]
    RESPONSE_DELETE_PERMANENTLY = 1
    RESPONSE_UNDELETE = 2
    RESPONSE_EMPTY_TRASH = 3    
    
    def __init__ (self, rg):
        self.rg = rg
        self.rmodel = self.rg.rmodel
        self.ui=gtk.Builder()
        self.ui.add_from_file(os.path.join(uibase,'recipe_index.ui'))
        RecIndex.__init__(self, self.ui, self.rg.rd, self.rg)
        self.setup_main_window()
        
    def setup_main_window (self):
        self.window = gtk.Dialog(_("Trash"),
                                 self.rg.window,
                                 gtk.DIALOG_DESTROY_WITH_PARENT,
                                 ("_Empty trash",self.RESPONSE_EMPTY_TRASH,
                                  "_Delete permanently",self.RESPONSE_DELETE_PERMANENTLY,
                                  "_Undelete",self.RESPONSE_UNDELETE,
                                  gtk.STOCK_CLOSE,gtk.RESPONSE_CLOSE))
        self.window.set_default_response(gtk.RESPONSE_CLOSE)
        #a = gtk.Alignment(); a.set_padding(12,12,12,12)
        box = gtk.VBox(); box.show()
        box.set_border_width(12)
        #a.add(box); a.show(); 
        #self.window.vbox.add(a)
        self.window.vbox.add(box)
        top_label = gtk.Label(); top_label.set_alignment(0.0,0.5)
        top_label.set_markup('<span weight="bold" size="large">'+_('Trash')+'</span>\n<i>'+_('Browse, permanently delete or undelete deleted recipes')+'</i>')
        box.pack_start(top_label,expand=False,fill=False);top_label.show()
        self.recipe_index_interface = self.ui.get_object('recipeIndexBox')
        self.recipe_index_interface.unparent()
        box.pack_start(self.recipe_index_interface,fill=True,expand=True)
        self.recipe_index_interface.show()
        self.rg.conf.append(WidgetSaver.WindowSaver(self.window,
                                                    self.prefs.get('trash_window',
                                                                   {'size':(600,800)}),
                                                    show=False))
        self.window.connect('response',self.response_cb)
        # So we can let delete key delete recipe when treeview is focused

    def response_cb (self, dialog, response):
        if response==self.RESPONSE_DELETE_PERMANENTLY:
            self.purge_selected_recs()
        elif response==self.RESPONSE_UNDELETE:
            self.undelete_selected_recs()
        elif response==self.RESPONSE_EMPTY_TRASH:
            self.purge_all()
        else:
            self.dismiss()

    def dismiss (self, *args):
        self.window.hide()
        return True
    
    def show (self, *args, **kwargs):
        self.window.show(*args,**kwargs)
        self.srchentry.grab_focus()

    #def setup_search_views (self):
    #    self.last_search = ["",""]
    #    self.rvw = self.rd.fetch_all(self.rd.recipe_table,deleted=True)
    #    self.searches = self.default_searches
    #    self.sort_by = []

    def update_from_db (self):
        self.update_rmodel(self.rg.rd.fetch_all(
            self.rg.rd.recipe_table,deleted=True
            ))

    def undelete_selected_recs (self, *args):
        mod,rr = self.rectree.get_selection().get_selected_rows()
        recs = [mod[path][0] for path in rr]
        msg = ''
        for r in recs:
            msg += r.title + ', '
            self.rg.rd.modify_rec(r,{'deleted':False})
        if msg: msg = msg[0:-2] # cut off the last comma
        self.update_from_db()
        self.rg.redo_search()
        self.rg.message(_('Undeleted recipes ') + msg)

    def purge_selected_recs (self, *args):
        debug("recTreeDeleteRec (self, *args):",5)
        sel = self.rectree.get_selection()
        if not sel: return
        mod,rr=sel.get_selected_rows()
        recs = map(lambda path: mod[path][0],rr)
        self.rg.purge_rec_tree(recs,rr,mod)
        self.update_from_db()

    def purge_all (self, *args):
        self.rg.purge_rec_tree(self.rvw)
        self.update_from_db()

class UnitModel (gtk.ListStore):
    def __init__ (self, converter):
        debug('UnitModel.__init__',5)
        self.conv = converter
        gtk.ListStore.__init__(self, str, str)
        # the first item of each conv.units
        lst = map(lambda a: (a[1][0],a[0]), filter(lambda x: not (converter.unit_to_seconds.has_key(x[1][0])
                                                                  or
                                                                  converter.unit_to_seconds.has_key(x[0])
                                                                  )
                                                   ,
                                                   self.conv.units)
                  )
        lst.sort()
        for ulong,ushort in lst:
            iter=self.append()
            self.set_value(iter,0,ushort)
            if ulong != ushort:
                ulong = "%s (%s)"%(ulong,ushort)
            self.set_value(iter,1,"%s"%ulong)

def set_accel_paths (ui, widgets, base='<main>'):
    """A convenience function. Hand us a function and set accel
    paths based on it."""
    for s in widgets:
        w=ui.get_object(s)
        if type(w) == gtk.MenuItem: set_path_for_menuitem(w)
        else:
            for c in w.get_children():
                if type(c) == gtk.MenuItem:
                    set_path_for_menuitem(c,base)
                else:
                    debug("Can't handle %s"%c,1)

def set_path_for_menuitem (mi, base='<main>'):
    if mi.get_children():
        accelLab = mi.get_children()[0]
        l=accelLab.get_label().replace('_','')
        path = base + '/' + l
        mi.set_accel_path(path)
    sm = mi.get_submenu()
    if sm:
        sm.set_accel_path(path)
        for c in sm.get_children():
            set_path_for_menuitem(c,path)

def launch_webbrowser(dialog, link, user_data):
    import webbrowser
    webbrowser.open_new_tab(link)
    
def startGUI ():
    debug("startGUI ():",4)
    # show splash screen before we do anything...
    debug("showing splash screen...",1)    
    splash = gtk.Window()
    #splash.window_set_auto_startup_notification(False)
    splash.set_property('decorated',False)
    splash.set_position(gtk.WIN_POS_CENTER)
    splash.set_icon_from_file(os.path.join(icondir,'gourmet.png'))
    splash.set_title(_('Gourmet Recipe Manager starting up...'))
    pixbuf=gtk.gdk.pixbuf_new_from_file(os.path.join(imagedir,'splash.png'))
    pixmap, mask = pixbuf.render_pixmap_and_mask()
    width, height = pixmap.get_size()
    del pixbuf
    splash.set_app_paintable(True)
    splash.resize(width, height)
    splash.realize()
    splash.window.set_back_pixmap(pixmap, False)
    splash.label = gtk.Label(_("Starting gourmet..."))
    splash.label.set_alignment(0.5,1)
    splash.label.set_justify(gtk.JUSTIFY_CENTER)
    splash.label.set_line_wrap(True)
    #pal = pango.AttrList()
    #pal.insert(pango.AttrForeground(
    #    255,255,128
    #    ))
    #splash.label.set_property('attributes',pal)
    splash.label.show()
    splash.add(splash.label)    
    del pixmap
    splash.show()
    splash.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.WATCH))
    if os.name == 'nt':
        gtk.link_button_set_uri_hook(launch_webbrowser, None)
        gtk.about_dialog_set_url_hook(launch_webbrowser, None)
    #gtk.threads_enter()
    while gtk.events_pending():
        # show our GUI
        gtk.main_iteration()
    try:
        r=RecGui(splash_label=splash.label)
    except RecGui, rg:
        r=rg
    except:
        splash.hide()
        while gtk.events_pending():
            gtk.main_iteration()
        #gtk.main_quit()
        raise
    debug('hiding splash screen.',1)
    splash.hide()
    gtk.main()



class ImporterExporter:
    """Provide importer exporter classes."""
    # WARNING: This is not actually an independent class.  This is a
    # crude method of bookkeeping as we update. Everything contained
    # in this class should be reworked within a plugin system. For
    # now, we just attach it to this class so we can have cleaner code
    # and maintain old functionality as we implement plugins
    # piece-by-piece.
    # IMPORT/EXPORT - this will be reworked within a plugin framework...
    def print_recs (self, *args):
        debug('printing recipes',3)
        recs = self.get_selected_recs_from_rec_tree()
        printManager = get_print_manager()
        printManager.print_recipes(
            self.rd,
            recs,
            parent=self.app,
            change_units=self.prefs.get('readableUnits',True)
            )

    def import_webpageg (self, *args):
        self.importManager.offer_web_import(parent=self.app.get_toplevel())

    def do_import (self, *args):
        self.importManager.offer_import(self.window)

    def do_export (self, export_all=False):
        if not hasattr(self,'exportManager'):
            self.exportManager = get_export_manager()
        if export_all:
            recs = self.rd.fetch_all(self.rd.recipe_table,deleted=False,sort_by=[('title',1)])
        else:
            recs = self.get_selected_recs_from_rec_tree()
        self.exportManager.offer_multiple_export(
            recs,
            self.prefs,
            prog=self.set_progress_thr,
            parent=self.app.get_toplevel())


class StuffThatShouldBePlugins:
    # As you can tell by the name, everything in this class should
    # really be re-implemented as a plugin. Once that process is
    # complete, this class will disappear!

    def shop_recs (self, *args):
        debug("recTreeShopRec (self, *args):",5)
        rr=self.get_selected_recs_from_rec_tree()
        #r = self.recTreeSelectedRec()
        for r in rr:
            if r.yields and r.yields != "None":
                debug("yields=%s"%r.yields,5)
                serv = de.getNumber(default=float(r.yields),
                                    label=_("Number of %(unit)s of %(title)s to shop for")%{
                        'title':r.title,
                        'unit':get_pluralized_form(r.yield_unit,2),
                        },
                                    parent=self.app.get_toplevel()
                                    )
                if serv: mult = float(serv)/float(r.yields)
                else:
                    debug('getNumber cancelled',2)
                    return
            else:
                mult = de.getNumber(default=float(1),
                                    label=_("Multiply %s by:")%r.title,
                                    parent=self.app.get_toplevel(),
                                    digits=2)
                if not mult:
                    mult = float(1)
            d=self.sl.getOptionalIngDic(self.rd.get_ings(r),mult,self.prefs)
            self.sl.addRec(r,mult,d)
            self.sl.show()

    def batch_edit_recs (self, *args):
        recs = self.get_selected_recs_from_rec_tree()
        if not hasattr(self,'batchEditor'):
            self.batchEditor =  batchEditor.BatchEditor(self)
        self.batchEditor.set_values_from_recipe(recs[0])
        self.batchEditor.dialog.run()
        # If we have values...
        if self.batchEditor.values:
            changes = self.batchEditor.values
            only_where_blank = self.batchEditor.setFieldWhereBlank
            attributes = ', '.join([_(k) for k in changes.keys()])
            msg = ngettext('Set %(attributes)s for %(num)s selected recipe?',
                                   'Set %(attributes)s for %(num)s selected recipes?',
                                   len(recs))%{'attributes':attributes,
                                               'num':len(recs),
                                               }
            msg += '\n'
            if only_where_blank:
                msg += _('Any previously existing values will not be changed.')+'\n'
            else:
                msg += _('The new values will overwrite any previously existing values.')+'\n'
            msg += '<i>'+_('This change cannot be undone.')+'</i>'
            if de.getBoolean(label=_('Set values for selected recipes'),sublabel=msg,cancel=False,
                             custom_yes=gtk.STOCK_OK,custom_no=gtk.STOCK_CANCEL,):
                for r in recs:
                    # Need to copy in case we're dealing with
                    # categories as they would get messed up by
                    # modify_rec
                    changes = self.batchEditor.values.copy()
                    if only_where_blank:
                        for attribute in changes.keys():
                            if (attribute == 'category' and \
                                self.rd.get_cats(r)) or \
                                (hasattr(r, attribute) and \
                                getattr(r, attribute)):
                                del changes[attribute]
                        if changes:
                            self.rd.modify_rec(r,changes)
                    else:
                        self.rd.modify_rec(r,changes)
                    self.rmodel.update_recipe(r)
            else:
                print 'Cancelled'
        self.batchEditor.dialog.hide()
        self.update_attribute_models()

ui_string = '''<ui>
<menubar name="RecipeIndexMenuBar">
  <menu name="File" action="File">
    <menuitem action="New"/>
    <menuitem action="ImportFile"/>
    <menuitem action="ImportWeb"/>
    <separator/>
    <menuitem action="ExportSelected"/>
    <menuitem action="ExportAll"/>
    <separator/>
    <placeholder name="FileMenuTool"/>
    <separator/>
    <!-- <menuitem action="Email"/> -->
    <menuitem action="Print"/>
    <separator/>
    <menuitem action="Quit"/>
  </menu>
  <!--<menu name="Edit" action="Edit">
    <menuitem action="Undo"/>
    <menuitem action="Redo"/>
  </menu>-->  
  <menu name="Actions" action="Actions">
    <menuitem action="OpenRec"/>
    <menuitem action="ShopRec"/>
    <menuitem action="DeleteRec"/>    
    <separator/>
    <menuitem action="EditRec"/>    
    <menuitem action="BatchEdit"/>
  </menu>
  <menu name="Go" action="Go">
  </menu>
  <menu name="Tools" action="Tools">
    <placeholder name="StandaloneTool">
    <menuitem action="Timer"/>
    </placeholder>
    <separator/>
    <placeholder name="DataTool"/>
    <separator/>
    <menuitem action="ViewTrash"/>
  </menu>
  <menu name="Settings" action="Settings">
    <menuitem action="toggleRegexp"/>
    <menuitem action="toggleSearchAsYouType"/>
    <!--<menuitem action="toggleSearchBy"/>-->
    <separator/>
    <menuitem action="Preferences"/>
    <menuitem action="Plugins"/>
  </menu>
  <menu name="HelpMenu" action="HelpMenu">
    <menuitem action="About"/>
    <menuitem action="Help"/>
  </menu>
</menubar>

<toolbar name="RecipeIndexToolBar">
  <toolitem action="New"/>
  <toolitem action="DeleteRec"/>
  <toolitem action="OpenRec"/>
  <toolitem action="ShopRec"/>
  <toolitem action="Print"/>
</toolbar>
</ui>
'''

class RecGui (RecIndex, GourmetApplication, ImporterExporter, StuffThatShouldBePlugins, plugin_loader.Pluggable):

    __single = None
    
    def __init__ (self, splash_label=None):
        if RecGui.__single:
            raise RecGui.__single
        else:
            RecGui.__single = self
        self.doing_multiple_deletions = False
        GourmetApplication.__init__(self, splash_label=splash_label)
        self.setup_index_columns()
        self.setup_hacks()
        self.ui=gtk.Builder()
        self.ui.add_from_file(os.path.join(uibase,'recipe_index.ui'))
        self.setup_actions()
        RecIndex.__init__(self,
                          ui=self.ui,
                          rd=self.rd,
                          rg=self,
                          editable=False)
        self.setup_database_hooks()        
        fix_action_group_importance(self.search_actions)
        self.ui_manager.insert_action_group(self.search_actions,0)
        self.setup_main_window()
        self.window.add_accel_group(self.ui_manager.get_accel_group())
        self.setup_column_display_preferences()
        self.setup_toolbar_display_preferences()
        plugin_loader.Pluggable.__init__(self,
                                         [plugin.MainPlugin,plugin.ToolPlugin])
        self.mm = mnemonic_manager.MnemonicManager()
        self.mm.add_toplevel_widget(self.window)
        self.mm.fix_conflicts_peacefully()
        self.window.show()

    def setup_hacks (self):
        # THese are properties that we need to set to test with our
        # current recindex class. However, each of these properties
        # should die with our redesign once done.
        self.act_on_row_widgets = []

    def setup_column_display_preferences (self, *args):
        already_hidden=self.prefs.get('rectree_hidden_columns',DEFAULT_HIDDEN_COLUMNS)
        if not already_hidden: already_hidden=[]
        options=map(lambda i: self.rtcolsdic[i], self.rtcols)
        options=map(lambda i: [i, i not in already_hidden], options)
        #pd = de.preferences_dialog(options=options, option_label=None, value_label=_("Show in Index View"),
        #                           apply_func=self.configure_columns, parent=self.app)
        self.prefsGui.add_pref_table(options,
                                     'indexViewVBox',
                                     self.configure_columns)        

    def setup_toolbar_display_preferences (self):
        def toggleToolbar (prefname,use):
            tb = self.ui_manager.get_widget('/RecipeIndexToolBar')
            if use:
                tb.show()
            else:
                tb.hide()
        self.prefsGui.apply_prefs_dic['showToolbar'] = toggleToolbar
        # Call our method once with the default prefs to apply saved
        # user settings
        toggleToolbar(None, self.prefs.get('showToolbar',True))

    def configure_columns (self, retcolumns):
        hidden=[]
        for c,v in retcolumns:
            if not v: hidden.append(c)
        self.rectree_conf.hidden=self.prefs['rectree_hidden_columns']=hidden
        self.rectree_conf.apply_visibility()


    def setup_index_columns (self):
        self.rtcolsdic={}
        self.rtwidgdic={}
        for a,l,w in REC_ATTRS:
            self.rtcolsdic[a]=l
            self.rtwidgdic[a]=w
            self.rtcols = [r[0] for r in REC_ATTRS]        

    def setup_database_hooks (self):
        self.rd.delete_hooks.append(
            lambda self,*args: (self.doing_multiple_deletions==False and self.redo_search())
            )
        self.rd.modify_hooks.append(self.rmodel.update_recipe)

    def selection_changed (self, selected=False):
        if selected != self.selected:
            if selected: self.selected=True
            else: self.selected=False
            self.onSelectedActionGroup.set_sensitive(
                self.selected
                )

    def setup_main_window (self):
        self.window = self.app = gtk.Window()
        self.window.set_icon_from_file(os.path.join(icondir,'gourmet.png'))
        self.conf.append(WidgetSaver.WindowSaver(self.window,
                                                 self.prefs.get('app_window',
                                                                {'window_size':(800,600)}),
                                                 )
                         )
        self.window.set_default_size(*self.prefs.get('app_window')['window_size'])
        self.window.set_title(version.appname)
        self.main = gtk.VBox()
        self.window.add(self.main)
        self.window.connect('delete-event',self.quit)
        mb = self.ui_manager.get_widget('/RecipeIndexMenuBar'); mb.show()
        self.main.pack_start(mb,fill=False,expand=False)
        tb = self.ui_manager.get_widget('/RecipeIndexToolBar')
        self.main.pack_start(tb,fill=False,expand=False)
        self.messagebox = gtk.VBox()
        self.main.pack_start(self.messagebox,fill=False,expand=False)
        self.main_notebook = gtk.Notebook()
        self.recipe_index_interface = self.ui.get_object('recipeIndexBox')
        self.recipe_index_interface.unparent()
        self.main_notebook.append_page(self.recipe_index_interface,
                                       tab_label=gtk.Label(_('Search recipes')))
        self.main.add(self.main_notebook)
        self.recipe_index_interface.show()

        self.main_notebook.show(); self.main_notebook.set_show_tabs(False)

        # Set up right-clicking again
        self.rectree.connect('popup-menu',self.rectree_popup)
        def popcb (tv, event):
            if event.button==3:
                self.rectree_popup(tv,event)
                return True
        # Set up popup menu in treeview
        self.rectree.connect('button-press-event',popcb)
        # Set up delete key in recipe treeview
        self.rectree.connect('key-press-event',self.rec_tree_keypress_cb)
        self.srchentry.grab_focus()        
        self.main.show()

    def rectree_popup (self, tv, event, *args):
        menu = self.ui_manager.get_widget("/RecipeIndexMenuBar/Actions/").get_submenu()
        menu.popup(None,None,None,event.button,event.time)
        return True

    def setup_actions (self):
        self.ui_manager = gtk.UIManager()
        self.ui_manager.add_ui_from_string(ui_string)
        self.mainActionGroup = gtk.ActionGroup('MainActions')
        self.onSelectedActionGroup = gtk.ActionGroup('IndexOnSelectedActions')
        self.onSelectedActionGroup.add_actions([
            ('OpenRec','recipe-card',_('Open recipe'),
             '<Control>O',_('Open selected recipe'),self.rec_tree_select_rec),
            # We no longer bind "Delete" here -- instead, we'll do it
            # at the TreeView level to prevent the delete key
            # elsewhere (e.g. in search box) from muddling up users.
            ('DeleteRec',gtk.STOCK_DELETE,_('Delete recipe'),
             None,_('Delete selected recipes'),self.rec_tree_delete_rec_cb),
            ('EditRec',gtk.STOCK_EDIT,_('Edit recipe'),
             None,_('Open selected recipes in recipe editor view'),
             self.rec_tree_edit_rec),
            ('ExportSelected',None,_('E_xport selected recipes'),
             None,_('Export selected recipes to file'),
             lambda *args: self.do_export(export_all=False)),
            ('Print',gtk.STOCK_PRINT,_('_Print'),
             '<Control>P',None,self.print_recs),
            #('Email', None, _('E-_mail recipes'),
            #None,None,self.email_recs),
            ('BatchEdit',None,_('Batch _edit recipes'),
             '<Control>E',None,self.batch_edit_recs),
            ('ShopRec','add-to-shopping-list',None,None,None,self.shop_recs)
            ])

        self.mainActionGroup.add_actions([
            ('File',None,_('_File')),
            ('Edit',None,_('_Edit')),
            ('Actions',None,_('_Actions')),
            ('Settings',None,_('Setti_ngs')),
            ('HelpMenu',None,_('_Help')),            
            ('About',gtk.STOCK_ABOUT,_('_About'),
             None,None,self.show_about),
            ('New',gtk.STOCK_NEW,_('_New'),
             None,None,self.new_rec_card),
            ('Help',gtk.STOCK_HELP,_('_Help'),
             None,None,self.show_help),
            ('ImportFile',None,_('_Import file'),
             None,_('Import recipe from file'),self.do_import),
            ('ImportWeb',None,_('Import _webpage'),
             None,_('Import recipe from webpage'),self.import_webpageg),
            ('ExportAll',None,_('Export _all recipes'),
             None,_('Export all recipes to file'),lambda *args: self.do_export(export_all=True)),
            ('Plugins',None,_('_Plugins'),
             None,_('Manage plugins which add extra functionality to Gourmet.'),
             lambda *args: plugin_gui.show_plugin_chooser()),
            ('Preferences',gtk.STOCK_PREFERENCES,_('_Preferences'),
             None,None,self.show_preferences),
            #('Redo',gtk.STOCK_REDO,_('_Redo'),
            # None,None),
            #('Undo',gtk.STOCK_UNDO,_('_Undo'),
            # None,None),
            ('Quit',gtk.STOCK_QUIT,_('_Quit'),
             None,None,self.quit),
            ('ViewTrash',None,_('Open _Trash'),
             None,None,self.show_deleted_recs),
            ])

        self.toolActionGroup = gtk.ActionGroup('ToolActions')
        self.toolActionGroup.add_actions([
            ('Tools',None,_('_Tools')),
            ('Timer',None,_('_Timer'),
             None,_('Show timer'),lambda *args: show_timer()),
            ])

        
        self.goActionGroup.add_actions([
            ('GoRecipeIndex',None,_('Recipe _Index'),
             None,_('Searchable index of recipes in the database.'),self.present)]
                                       )
        fix_action_group_importance(self.onSelectedActionGroup)
        self.ui_manager.insert_action_group(self.onSelectedActionGroup,0)
        fix_action_group_importance(self.mainActionGroup)
        fix_action_group_importance(self.mainActionGroup)
        self.ui_manager.insert_action_group(self.mainActionGroup,0)
        fix_action_group_importance(self.toolActionGroup)
        self.ui_manager.insert_action_group(self.toolActionGroup,0)
        self.add_uimanager_to_manage(-1,self.ui_manager,'RecipeIndexMenuBar')

    # Status bar stuff
    def message (self, msg):
        debug("message (self, msg): %s"%msg,5)
        self.stat.push(self.contid,msg)
        gobject.timeout_add(1500,self.flush_messages)

    def flush_messages (self, ret=False):
        debug("flush_messages (self):",5)
        self.stat.pop(self.contid)
        return ret


    # Basic callbacks
    def new_rec_card (self, *args):
        self.app.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.WATCH))
        def show ():
            rc=reccard.RecCard(self)
            self.make_rec_visible(rc.current_rec)
            self.rc[rc.current_rec.id]=rc
            self.app.window.set_cursor(None)
            self.update_go_menu()
        gobject.idle_add(show)

    def open_rec_card (self, rec):
        if self.rc.has_key(rec.id):
            self.rc[rec.id].show()
        else:
            def show ():
                w=reccard.RecCard(self, rec)
                self.rc[rec.id]=w
                self.update_go_menu()
                self.app.window.set_cursor(None)
            self.app.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.WATCH))
            gobject.idle_add(show)
        

    # Extra callbacks for actions on our treeview
    @plugin_loader.pluggable_method
    def get_selected_recs_from_rec_tree (self):
        return RecIndex.get_selected_recs_from_rec_tree(self)

    @plugin_loader.pluggable_method
    def update_recipe (self, recipe):
        return RecIndex.update_recipe(self, recipe)

    @plugin_loader.pluggable_method
    def redo_search (self, *args):
        return RecIndex.redo_search(self, *args)

    def rec_tree_select_rec (self, *args):
        debug("rec_tree_select_rec (self, *args):",5)
        for rec in self.get_selected_recs_from_rec_tree():
            self.open_rec_card(rec)

    def rec_tree_edit_rec (self, *args):
        for rec in self.get_selected_recs_from_rec_tree():
            if self.rc.has_key(rec.id):
                self.rc[rec.id].show_edit()
            else:
                def show ():
                    w=reccard.RecCard(self, rec, manual_show=True)
                    self.rc[rec.id]=w
                    self.update_go_menu()
                    w.show_edit()
                    self.app.window.set_cursor(None)
                self.app.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.WATCH))
                gobject.idle_add(show)

    # Deletion
    def show_deleted_recs (self, *args):
        if not hasattr(self,'recTrash'):
            self.recTrash = RecTrash(self.rg)
            self.recTrash.show()
        else:
            self.recTrash.show()

    def rec_tree_keypress_cb (self, widget, event):
        keyname = gtk.gdk.keyval_name(event.keyval)
        if keyname == 'Delete' or keyname == 'BackSpace':
            self.rec_tree_delete_rec_cb()
            return True

    def rec_tree_delete_rec_cb (self, *args,**kwargs):
        """Make a watch show up (this can be slow
        if lots of recs are selected!"""
        self.rec_tree_delete_recs(
            self.get_selected_recs_from_rec_tree()
            )
        
    def delete_open_card_carefully (self, rec):
        """Delete any open card windows, confirming if the card is edited.

        We return True if the user cancels deletion.
        """
        if self.rc.has_key(rec.id):
            rc = self.rc[rec.id] 
            if rc.edited:
                rc.show_edit()
                if not de.getBoolean(
                    label=_('Delete %s?'),
                    sublabel=_('You have unsaved changes to %s. Are you sure you want to delete?'),
                    custom_yes=gtk.STOCK_DELETE,
                    custom_no=gtk.STOCK_CANCEL,
                    cancel=False):
                    return True
            rc.hide()
            self.del_rc(rec.id)
            
    @plugin_loader.pluggable_method
    def rec_tree_delete_recs (self, recs):
        cancelled = []
        for rec in recs:
            if self.delete_open_card_carefully(rec): # returns True if user cancels
                cancelled.append(rec)
        if cancelled:
            for c in cancelled: recs.remove(c)
        self.rd.undoable_delete_recs(
            [self.rd.get_rec(r.id) for r in recs],
            self.history,
            make_visible=lambda *args: self.redo_search()
            )
        self.setup_delete_messagebox(
            ngettext('You just moved %s recipe to the trash. You can recover this recipe or permanently delete it at any time by clicking Tools->Open Trash.',
                             'You just moved %s recipes to the trash. You can recover these recipes or permanently delete them at any time by clicking Tools->Open Trash',
                             len(recs))%len(recs)
            )
        self.set_reccount()
        if hasattr(self,'recTrash'):
            self.recTrash.update_from_db()
        self.message(_("Deleted") + ' ' + string.join([(r.title or _('Untitled')) for r in recs],', '))

    def purge_rec_tree (self, recs, paths=None, model=None):
        if not recs:
            # Do nothing if there are no recipes to delete.
            return
        if not paths: paths=[]
        expander=None
        bigmsg = _("Permanently delete recipes?")
        if len(recs) == 1:
            bigmsg = _("Permanently delete recipe?")
            msg = _("Are you sure you want to delete the recipe <i>%s</i>")%recs[0].title
        elif len(recs) < 5:
            msg = _("Are you sure you want to delete the following recipes?")
            for r in recs:
                msg += "\n<i>%s</i>"%r.title
        else:
            msg = _("Are you sure you want to delete the %s selected recipes?")%len(recs)
            tree = te.QuickTree([r.title for r in recs])
            expander = [_("See recipes"),tree]
        if de.getBoolean(parent=self.app,label=bigmsg,sublabel=msg,expander=expander):

            deleterThread = SuspendableDeletions(recs,name='delete_recs')
            deleterThread.connect('done',lambda *args: self.recTrash.update_from_db())
            tm = get_thread_manager()
            tmg = get_thread_manager_gui()
            tm.add_thread(deleterThread)
            tmg.register_thread_with_dialog(_('Delete Recipes'),_('Recipes deleted'),deleterThread)
            tmg.show()
        else:
            return True

    def delete_rec (self, rec):
        debug("delete_rec (self, rec): %s"%rec,5)
        debug("does %s have %s"%(self.rc,rec.id),5)
        if self.rc.has_key(rec.id):
            debug("Getting rid of open recipe card window.",2)
            w=self.rc[rec.id].widget
            self.rc[rec.id].hide()
            w.destroy()
            self.update_go_menu()
        if hasattr(rec,'id') and rec.id:
            if rec:
                titl = rec.title
                debug('deleting recipe %s'%rec.title,1)
                # try a workaround to segfaults -- grab rec anew from ID.
                dbrec = self.rd.get_rec(rec.id)
                if dbrec:
                    self.rd.delete_rec(dbrec)
                else:
                    print 'wtf?!?',rec,':',rec.id,' not real?'
            else: debug('no recipe to delete!?!',1)
            if not self.doing_multiple_deletions:
                gt.gtk_enter()
                self.message(_("Deleted recipe %s")%titl)
                self.doing_multiple_deletions=False
                gt.gtk_leave()
        else:
            debug("%s %s does not have an ID!"%(rec,rec.title),2)
        debug("returning None",2)
        return None

    def _on_bar_response(self, button, response_id):
        if (response_id == UNDO):
            self.history[-1].inverse()
        elif (response_id == SHOW_TRASH):
            self.show_deleted_recs()
        self.messagebox.hide()

    # Code to show message/undo-button on deletion
    def setup_delete_messagebox (self, msg):
        # Clear existing messages...
        for child in self.messagebox.get_children():
            self.messagebox.remove(child)
        # Add new message
        l = gtk.Label(msg)
        l.set_line_wrap(True)
        l.show()
        infobar = gtk.InfoBar()
        infobar.set_message_type(gtk.MESSAGE_INFO)
        infobar.get_content_area().add(l)
        infobar.add_button(_('See Trash Now'), SHOW_TRASH)
        infobar.add_button(gtk.STOCK_UNDO, UNDO)
        infobar.add_button(gtk.STOCK_DISCARD, gtk.RESPONSE_CLOSE)
        infobar.connect('response', self._on_bar_response)
        infobar.show()
        self.messagebox.pack_start(infobar)
        self.messagebox.show()
    # end deletion

    # end Extra Callbacks for actions on treeview

    def after_dialog_offer_url (self, linktype, file):
        url = "file:///%s"%file
        label = _("Export succeeded")
        if linktype == exporters.WEBPAGE:
            url += '/index.htm'
            linktype = _("webpage")
        sublabel = _("Exported %s to %s")%(linktype,file)
        def offerer (t):
            if t.completed:
                #self.idle_offer_url(label, sublabel, url, True)
                self.offer_url(label, sublabel, url, True)
        return offerer

    def idle_offer_url (self, label, sublabl, url, from_thread):
        if from_thread:
            gt.gtk_enter()
        gobject.idle_add(lambda *args: self.offer_url(label,sublabl,url,True))
        if from_thread:
            gt.gtk_leave()

    def offer_url (self, label, url, messagebox, from_thread=False):
        if from_thread:
            gt.gtk_enter()
        if hasattr(self,'progress_dialog'):
            self.hide_progress_dialog()
        # Clear existing messages...
        for child in messagebox.get_children():
            messagebox.remove(child)
        # Add new message
        l = gtk.Label()
        l.set_markup(label)
        infobar = gtk.InfoBar()
        infobar.set_message_type(gtk.MESSAGE_INFO)
        infobar.get_content_area().add(l)
        infobar.add_button(gtk.STOCK_DISCARD, gtk.RESPONSE_CLOSE)
        infobar.connect('response', lambda ib, response_id: messagebox.hide())
        messagebox.pack_start(infobar)
        messagebox.show_all()
        if from_thread:
            gt.gtk_leave()

    # Methods to handle threading
    def pause_cb (self, button, *args):
        if button.get_active():
            debug('Suspending thread from pause_cb',0)
            self.thread.suspend()
            self.stat.push(self.pauseid, self.pause_message)
            self.flusher = gobject.timeout_add(1000,lambda *args: self.flush_messages(True))
        else:
            self.stat.pop(self.pauseid)            
            gobject.source_remove(self.flusher)
            self.thread.resume()
            
    def stop_cb (self, *args):
        debug('Stop_cb called; pausing thread',1)
        self.thread.suspend()
        if de.getBoolean(label=self.stop_message):
            debug('Stopping thread from stop cb',0)
            self.thread.terminate()
            if self.threads > 0:
                self.threads = self.threads - 1
                try: self.lock.release()
                except: pass
            self.hide_progress_dialog()
        else:
            debug('Resuming thread: stop_cb cancelled',0)
            self.thread.resume()
            return True

    def reset_prog_thr (self,message=_("Done!")):
        debug('reset_prog_thr',0)
        #self.prog.set_fraction(1)
        self.set_progress_thr(1,message)
        gt.gtk_enter()
        self.set_reccount()
        gt.gtk_leave()

    def set_progress_thr (self, prog, message=_("Importing...")):
        debug("set_progress_thr (self, %s,%s)"%(prog,message),1)
        gt.gtk_enter()
        if hasattr(self,'progress_dialog'):
            self.progress_dialog.set_progress(prog,message)
        gt.gtk_leave()
        
    # Stuff to show and destroy ourselves

    def present (self, *args): self.window.present()
    
    def quit (self, *args):
        GourmetApplication.quit(self)
        self.window.destroy()
        gtk.main_quit()

def get_application ():
    try:
        return RecGui()
    except RecGui, rg:
        return rg

if __name__ == '__main__':
    if os.name!='nt':
        import profile, tempfile,os.path
        import hotshot, hotshot.stats
        #profi = os.path.join(tempfile.tempdir,'GOURMET_PROFILE')
        prof = hotshot.Profile(os.path.join(tempfile.tempdir,'GOURMET_HOTSHOT_PROFILE'))
        prof.runcall(startGUI)
        stats = hotshot.stats.load(os.path.join(tempfile.tempdir,'GOURMET_HOTSHOT_PROFILE'))
        stats.strip_dirs()
        stats.sort_stats('time','calls').print_stats()
        #profile.run('startGUI()',profi)
        #import pstats
        #p=pstats.Stats(profi)
        #p.strip_dirs().sort_stats('cumulative').print_stats()
    else:
        startGUI()

#elif __name__ == '__main__':
#    rgn = RecGui()
#    gtk.main()

########NEW FILE########
__FILENAME__ = cb_extras
import gtk, gobject
from gourmet.gdebug import debug

class FocusFixer:
    key = None
    def __init__ (self,cbe):
        self.e=cbe.get_children()[0]
        self.e.connect('key-press-event',self.keypress_event_cb)
        self.e.connect('focus-out-event',self.focus_out_cb)
        self.e.connect('focus-in-event',self.focus_in_cb)
        cbe.connect('focus-in-event',self.focus_in_cb)

    def focus_in_cb (self, widget, event):
        self.e.grab_focus()

    def focus_out_cb (self, widget, event):
        if not event.in_ and self.key in ['Tab']:
            parent = widget.get_parent()
            while parent and not isinstance(parent,gtk.Window) :
                parent = parent.get_parent()
            for n in range(2): parent.emit('move-focus',gtk.DIRECTION_LEFT)
            #parent.emit('move-focus',gtk.DIRECTION_LEFT)

    def keypress_event_cb (self, w, event):
        self.key = gtk.gdk.keyval_name(event.keyval)

def cb_get_active_text (combobox):
    """Get the selected/active text of combobox"""
    model = combobox.get_model()
    active = combobox.get_active()
    if active < 0:
        return None
    return model[active][0] 

def cb_set_active_text (combobox, text, col=0):
    """Set the active text of combobox to text. We fail
    if the text is not already in the model. Column is the column
    of the model from which text is drawn."""
    model = combobox.get_model()
    n = 0
    for rw in model:
        if rw[col]==text:
            combobox.set_active(n)
            return n
        n += 1
    return None

class setup_typeahead:
    """We setup selection of ComboBox items when the ComboBox
    is selected."""
    def __init__ (self, cb, col=0):
        self.cb = cb
        # we try to connect to our children renderers...
        if self.cb.get_children():
            for c in cb.get_children():
                #c.set_direction(gtk.DIR_UP)
                try:
                    c.connect('key_press_event',self.key_press_cb)
                except:
                    debug("couldn't connect key_press_event for %s"%c,1)
        self.col = col
        self.str = ""
        self.cb.connect('key_press_event',self.key_press_cb)
        self.typeahead_timeout = 1500
        self.last_timeout=None

    def key_press_cb (self, widget, event):
        newstr = event.string
        if not newstr: return
        self.str += newstr
        match=self.match_string_in_combo(self.str)
        if type(match) == type(0):
            self.cb.set_active(match)
        ## otherwise, perhaps they didn't mean to combine strings
        else:
            self.str = ""
            match=self.match_string_in_combo(newstr)
            if type(match) == type(0):
                self.cb.set_active(match)
                self.string = newstr
        if type(match)==type(0): 
            if self.last_timeout: gobject.source_remove(self.last_timeout)
            self.last_timeout=gobject.timeout_add(self.typeahead_timeout, self.reset_str)

    def reset_str (self, *args):
        self.string = ""

    def match_string_in_combo (self, str):
        mod = self.cb.get_model()
        n = 0
        for r in mod:
            modstr = r[self.col]
            if modstr.lower().find(str.lower()) == 0:
                return n
            n += 1
            

def setup_completion (cbe, col=0):
    """Setup an EntryCompletion on a ComboBoxEntry based on the
    items in the ComboBox's model"""
    model = cbe.get_model()
    entry = cbe.get_children()[0]
    cbe.entry = entry  # for convenience/backward compatability with gtk.Combo
    make_completion(entry, model, col)

def make_completion (entry, model, col=0):
    """Setup completion for an entry based on model."""
    if not isinstance(entry,gtk.Entry):
        import traceback
        if isinstance(entry.child,gtk.Entry):
            print 'WARNING: make_completion() called with ',entry,'and model',model
            entry = entry.child
            traceback.print_stack(limit=3)
            print 'Using its child, ',entry,'instead.'
        else:
            print 'WARNING: ',entry,'is not a GTK Entry'
            traceback.print_stack(limit=3)            
            return
    completion = gtk.EntryCompletion()
    completion.set_model(model)
    completion.set_text_column(col)
    entry.set_completion(completion)

    def on_activate (*args):
        txt = entry.get_text().lower()
        completion = False
        for r in model:
            if r[0].lower().startswith(txt):
                if completion:
                    # if there are more than one
                    # possible completion, we do nothing
                    return True
                completion = r[0]
        if completion != txt:
            if completion: entry.set_text(completion)
            return True
    entry.connect('activate',on_activate)

def set_model_from_list (cb, list, expand=True):
    """Setup a ComboBox based on a list of strings."""
    model = gtk.ListStore(str)
    for l in list:
        model.append([l])
    cb.set_model(model)
    if type(cb) == gtk.ComboBoxEntry:
        cb.set_text_column(0)        
        setup_completion(cb)
    elif type(cb) == gtk.ComboBox:
        cb.clear()
        cell = gtk.CellRendererText()
        cb.pack_start(cell, expand=expand)
        cb.add_attribute(cell, 'text',0)
        setup_typeahead(cb, 0)

if __name__ == '__main__':
    w = gtk.Window()
    vb = gtk.VBox()
    #vb.add(gtk.Button('Blank button'))
    #for n in range(10): vb.add(gtk.Button('Other blank'))
    hbox = gtk.HBox()
    label = gtk.Label()
    label.set_text_with_mnemonic('Enter a _fruit: ')
    cbe = gtk.ComboBoxEntry()
    FocusFixer(cbe)
    label.set_mnemonic_widget(cbe)
    set_model_from_list(cbe, ['Apples','Oranges','Grapes','Mango',
                              'Papaya','Plantain','Kiwi','Cherry',
                              'Bananas'])
    hbox.add(label)
    hbox.add(cbe)    
    vb.add(gtk.Label("""Here's an EntryCompletion widget automatically
    in sync with the ComboBoxEntry widget. Hitting return will select
    the first item in the EntryCompletion popup window."""))
    vb.add(hbox)
    def make_combo (expand=True):
        label2 = gtk.Label()
        label2.set_text_with_mnemonic('Mode of _Transportation')
        cb = gtk.ComboBox()
        label2.set_mnemonic_widget(cb)
        set_model_from_list(cb, ['Planes','Trains','Automobiles','Spacecraft','Bicycles'],
                            expand=expand)
        setup_typeahead(cb)
        hb2 = gtk.HBox()
        hb2.add(label2)
        hb2.add(cb)
        hb2.show_all()
        return hb2
    vb.add(gtk.Label("""Here's a ComboBox widget. With the widget selected,
    you can type e.g. "a" to select "airplane." Once the cb-popup window
    is up, however, typing doesn't do anything (doh!)"""))
    vb.add(make_combo())
    vb.add(gtk.Label("""ComboBox, expand=False"""))
    vb.add(make_combo(expand=False))
    vb.show_all()
    w.add(vb)
    w.show_all()
    w.connect('destroy',lambda *args: gtk.main_quit())
    gtk.main()
    
    

########NEW FILE########
__FILENAME__ = dialog_extras
#!/usr/bin/env python
import gtk, gobject, os.path, optionTable, thumbnail, fnmatch,  re
import pango
import xml.sax.saxutils
from gettext import gettext as _
from gourmet.gdebug import debug
from glib import get_user_special_dir, USER_DIRECTORY_PICTURES
H_PADDING=12
Y_PADDING=12

class UserCancelledError (Exception):
    pass

def is_markup (s):
    try:
        pango.parse_markup(s,u'0')
        return True
    except:
        return False

class ModalDialog (gtk.Dialog):
    def __init__ (self, default=None, title="", okay=True, label=False, sublabel=False, parent=None, cancel=True, modal=True, expander=None):
        """Our basic class. We allow for a label. Possibly an expander
        with extra information, and a simple Okay button.  The
        expander is are only fancy option. It should be a list ['Name
        of expander', CONTENTS]. CONTENTS can be a string (to be put
        in a label), a widget (to be packed in the expander), or a
        list of strings and widgets to be packed in order."""
        self.widget_that_grabs_focus = None
        self.setup_dialog(title=title, parent=parent)
        self.connect('destroy',self.cancelcb)
        self.set_border_width(15)
        self.default = default
        self.ret = default
        self.responses = {gtk.RESPONSE_OK:self.okcb,
                          gtk.RESPONSE_CANCEL:self.cancelcb,
                          gtk.RESPONSE_NONE:self.cancelcb,
                          gtk.RESPONSE_CLOSE:self.cancelcb,
                          gtk.RESPONSE_DELETE_EVENT:self.cancelcb}
        if modal: self.set_modal(True)
        else: self.set_modal(False)        
        if label:
            self.setup_label(label)
        if sublabel:
            self.setup_sublabel(sublabel)
        if expander:
            # if we have an expander, our window
            # should be resizable (just in case
            # the user wants to do more resizing)
            self.set_resizable(True)
            self.setup_expander(expander)
        self.setup_buttons(cancel, okay)
        self.vbox.show_all()

    def setup_dialog (self, *args, **kwargs):
        gtk.Dialog.__init__(self, *args, **kwargs)

    def setup_label (self, label):
        # we're going to add pango markup to our
        # label to make it bigger as per GNOME HIG
        self.set_title(label)
        label = '<span weight="bold" size="larger">%s</span>'%label
        self.label = gtk.Label(label)
        self.label.set_line_wrap(True)
        self.label.set_selectable(True)
        self.vbox.pack_start(self.label,expand=False)
        self.label.set_padding(H_PADDING,Y_PADDING)
        self.label.set_alignment(0,0)
        self.label.set_justify(gtk.JUSTIFY_LEFT)
        self.label.set_use_markup(True)
        self.label.show()
        
    def setup_sublabel (self,sublabel):
        self.sublabel = gtk.Label(sublabel)
        self.sublabel.set_selectable(True)
        self.vbox.pack_start(self.sublabel, expand=False)
        self.sublabel.set_padding(H_PADDING,Y_PADDING)
        self.sublabel.set_alignment(0,0)
        self.sublabel.set_justify(gtk.JUSTIFY_LEFT)
        self.sublabel.set_use_markup(True)
        self.sublabel.set_line_wrap_mode(pango.WRAP_WORD)
        self.sublabel.show()

    def setup_buttons (self, cancel, okay):
        if cancel:
            self.add_button(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL)
        if okay:
            self.add_button(gtk.STOCK_OK,gtk.RESPONSE_OK)
        self.connect('response',self.response_cb)

    def response_cb (self, dialog, response, *params):
        #print 'response CB ',dialog,response,params
        if self.responses.has_key(response):
            #print 'we have a response!'
            self.responses[response]()
        else:
            print 'WARNING, no response for ',response
            
    def setup_expander (self, expander):
            label=expander[0]
            body = expander[1]
            self.expander = gtk.Expander(label)
            self.expander.set_use_underline(True)
            self.expander_vbox = gtk.VBox()
            sw = gtk.ScrolledWindow()
            sw.add_with_viewport(self.expander_vbox)
            sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
            self.expander.add(sw)
            self._add_expander_item(body)
            self.expander.show()
            self.expander_vbox.show_all()
            self.vbox.add(self.expander)
            
    def _add_expander_item (self, item):
        if type(item)==type(""):
            l=gtk.Label(item)
            l.set_selectable(True)
            l.set_line_wrap_mode(pango.WRAP_WORD)
            self.expander_vbox.pack_start(l,
                                          expand=False,
                                          fill=False)
        elif type(item)==[] or type(item)==():
            map(self._add_expander_item,item)
        else:
            self.expander_vbox.pack_start(item)
            
    def run (self):
        self.show()
        if self.widget_that_grabs_focus: self.widget_that_grabs_focus.grab_focus()
        if self.modal: gtk.main()
        return self.ret

    def okcb (self, *args):
        self.hide()
        if self.modal: gtk.main_quit()

    def cancelcb (self, *args):
        self.hide()
        self.ret=None
        if self.modal: gtk.main_quit()

class MessageDialog (gtk.MessageDialog, ModalDialog):

    """A simple class for displaying messages to our users."""
    
    def __init__ (self, title="", default=None, okay=True, cancel=True, label=False, sublabel=False,
                  expander=None, message_type=gtk.MESSAGE_INFO, parent=None, modal=True):
        self.message_type=message_type
        ModalDialog.__init__(self, title=title, default=default, okay=okay, cancel=cancel, label=label, sublabel=sublabel, parent=parent, expander=expander, modal=modal)

    def setup_dialog (self, *args, **kwargs):
        kwargs['type']=self.message_type
        if kwargs.has_key('title'):
            title = kwargs['title']
            del kwargs['title']
        gtk.MessageDialog.__init__(self, *args, **kwargs)
        self.set_title(title)

    def setup_label (self, label):
        if not is_markup(label):
            label = xml.sax.saxutils.escape(label)
        label = '<span weight="bold" size="larger">%s</span>'%label
        self.set_markup(label)

    def setup_sublabel (self, sublabel):
        #curtext = self.label.get_text()
        #curtext += "\n%s"%sublabel
        #self.label.set_text(xml.sax.saxutils.escape(curtext))
        self.format_secondary_markup(sublabel)
        
                  
class NumberDialog (ModalDialog):

    """A dialog to get a number from our user."""

    def __init__(self,default=None,label=False,sublabel=False,step_incr=1,page_incr=10,digits=0,
                 min=0,max=10000, parent=None):
        ModalDialog.__init__(self,default=default, parent=parent)
        self.hbox=gtk.HBox()
        self.vbox.add(self.hbox)
        #self.spinButton=gtk.SpinButton(climb_rate=climb_rate,digits=digits)
        if not default:
            val = 0
        else:
            val = float(default)
        self.adjustment=gtk.Adjustment(val,
                                       lower=min,
                                       upper=max,
                                       step_incr=step_incr,
                                       page_incr=page_incr)
        self.spinButton=gtk.SpinButton(self.adjustment)
        if default:
            self.spinButton.set_value(default)
        if label:
            self.label=gtk.Label(label)
            self.label.set_selectable(True)
            self.label.set_line_wrap_mode(pango.WRAP_WORD)
            self.label.set_padding(H_PADDING, Y_PADDING)
            self.hbox.add(self.label)
            self.label.show()
        self.hbox.add(self.spinButton)
        self.spinButton.get_adjustment().connect("value_changed",self.update_value)
        self.spinButton.get_adjustment().connect("changed",self.update_value)
        self.spinButton.show()
        self.spinButton.connect('activate',self.entry_activate_cb)
        self.hbox.show()                
        
    def update_value (self, *args):
        self.ret=self.spinButton.get_value()

    def entry_activate_cb (self, *args):
        self.okcb()

class EntryDialog (ModalDialog):

    """A dialog to get some text from an Entry from our user."""
    
    def __init__ (self, default=None,
                  label=None,
                  sublabel=None,
                  entryLabel=False,
                  entryTip=None,
                  parent=None,
                  visibility=True,
                  default_value=None,
                  default_character_width=None):
        ModalDialog.__init__(self,default=default,parent=parent, label=label, sublabel=sublabel)
        self.hbox=gtk.HBox()
        self.vbox.add(self.hbox)
        if entryLabel:
            self.elabel=gtk.Label(entryLabel)
            self.elabel.set_line_wrap_mode(pango.WRAP_WORD)
            self.elabel.set_selectable(True)
            self.elabel.set_alignment(0,0)
            self.hbox.add(self.elabel)
            self.elabel.show()
            self.elabel.set_padding(H_PADDING,Y_PADDING)
        self.entry = gtk.Entry()
        self.entry.set_visibility(visibility)
        self.entry.connect('activate',self.entry_activate_cb)
        if default_character_width:
            if hasattr(self.entry,'set_width_chars'):
                self.entry.set_width_chars(default_character_width)
            if hasattr(self,'label') and hasattr(self.label,'set_width_chars'):
                self.label.set_width_chars(default_character_width)
            if hasattr(self,'sublabel') and hasattr(self.sublabel,'set_width_chars'):
                self.sublabel.set_width_chars(default_character_width)
        self.hbox.add(self.entry)
        self.entry.set_flags(gtk.CAN_DEFAULT)
        self.entry.grab_default()
        self.hbox.show()
        if default:
            self.entry.set_text(default)
        if entryTip:
            self.tt = gtk.Tooltips()
            self.tt.set_tip(self.entry,entryTip)
        self.entry.connect("changed",self.update_value)
        # Set the default value after connecting our handler so our
        # value gets updated!
        if default_value:
            self.entry.set_text(default_value)
        self.entry.show_all()
        self.entry.show()
        self.widget_that_grabs_focus = self.entry

    def update_value (self, *args):
        self.ret = self.entry.get_text()

    def entry_activate_cb (self, *args):
        if self.ret:
            self.okcb()

class RadioDialog (ModalDialog):


    """A dialog to offer our user a choice between a few options."""

    def __init__ (self, default=None, label="Select Option", sublabel=None, options=[],
                  parent=None,expander=None,cancel=True):
        ModalDialog.__init__(self, okay=True, label=label, sublabel=sublabel, parent=parent, expander=expander, cancel=cancel)
        # defaults value is first value...
        self.default = default
        self.setup_radio_buttons(options)
        if options and default==None:
            self.ret = options[0][1]

    def setup_radio_buttons (self,options):
        previous_radio = None
        self.buttons = []
        for label,value in options:
            rb = gtk.RadioButton(group=previous_radio, label=label, use_underline=True)
            rb.connect('activate',self.okcb)
            self.vbox.add(rb)
            rb.show()
            rb.connect('toggled',self.toggle_cb,value)
            self.buttons.append(rb)
            previous_radio=rb
            if self.default==value:
                rb.set_active(True)
                self.widget_that_grabs_focus = rb
        if self.default==None:
            self.buttons[0].set_active(True)
            self.widget_that_grabs_focus = self.buttons[0]

    def toggle_cb (self, widget, value):
        if widget.get_active():
            self.ret = value

class OptionDialog (ModalDialog):

    """A dialog to offer our user a choice between options using an option menu"""
    
    def __init__ (self, default=None, label="Select Option", sublabel=None, options=[], parent=None, expander=None, cancel=True):
        """Options can be a simple option or can be a tuple or a list
        where the first item is the label and the second the value"""
        ModalDialog.__init__(self, okay=True, label=label, sublabel=sublabel, parent=parent, expander=expander, cancel=cancel)
        self.menucb = self.get_option        
        self.optdic={}
        self.menu = gtk.Menu()
        # set the default value to the first item
        first = options[0]
        if type(first)==type(""): self.ret=first
        else: self.ret=first[1]
        for o in options:
            if type(o)==type(""):
                l=o
                v=o
            else:
                l=o[0]
                v=o[1]
            i = gtk.MenuItem(l)
            i.connect('activate',self.menucb)
            i.show()
            self.optdic[i]=v
            self.menu.append(i)
        self.optionMenu=gtk.OptionMenu()
        self.vbox.pack_start(self.optionMenu,expand=False,fill=False)
        self.optionMenu.set_menu(self.menu)
        self.optionMenu.show()
        self.menu.show()

    def get_option (self, widget):
        self.ret=self.optdic[widget]
        #return self.ret

    def set_value (self, value):
        self.ret=value

class ProgressDialog (ModalDialog):

    """A dialog to show a progress bar"""
    
    def __init__ (self, title="", okay=True, label="", sublabel=False, parent=None,
                  cancel=False, stop=False, pause=False,modal=False):
        """stop,cancel,and pause will be given as callbacks to their prospective buttons."""
        self.custom_pausecb=pause
        self.custom_cancelcb=cancel
        self.custom_pause_handlers = []
        self.custom_stop_handlers = []
        self.custom_stopcb=stop
        ModalDialog.__init__(self, title, okay=okay, label=label, sublabel=sublabel, parent=parent,
                         cancel=cancel,modal=modal)
        self.set_title(label)
        self.progress_bar = gtk.ProgressBar()
        self.vbox.add(self.progress_bar)
        self.detail_label = gtk.Label()
        self.vbox.add(self.detail_label)
        self.detail_label.set_use_markup(True)
        self.detail_label.set_padding(H_PADDING,Y_PADDING)
        self.detail_label.set_line_wrap_mode(pango.WRAP_WORD)
        self.vbox.show_all()
        if okay: self.set_response_sensitive(gtk.RESPONSE_OK,False) # we're false by default!
        if not stop: self.stop.hide()
        if not pause: self.pause.hide()

    def reset_label (self, label):
        self.set_title(label)
        self.label.set_text('<span weight="bold" size="larger">%s</span>'%label)
        self.label.set_use_markup(True)

    def reassign_buttons (self, pausecb=None, stopcb=None):
        debug('reassign_buttons called with pausecb=%s, stopcb=%s'%(pausecb,stopcb),1)
        while self.custom_pause_handlers:
            h=self.custom_pause_handlers.pop()
            if self.pause.handler_is_connected(h):
                self.pause.disconnect(h)
        if pausecb:
            self.pause.connect('toggled',pausecb)
            self.pause.set_property('visible',True)
        else:
            self.pause.set_property('visible',False)
        while self.custom_stop_handlers:
            h=self.custom_stop_handlers.pop()
            if self.stop.handler_is_connected(h):
                self.stop.disconnect(h)
        if stopcb:
            self.stop.connect('clicked',stopcb)
            #self.stop.connect('clicked',self.cancelcb)
            self.stop.set_property('visible',True)
        else:
            self.stop.set_property('visible',False)
            
    def setup_buttons (self, cancel, okay):                        
        # setup pause button 
        self.pause = gtk.ToggleButton(_('_Pause'))
        self.pause.set_use_underline(True)        
        self.action_area.pack_end(self.pause)
        # only show it/connect it if we want to...
        if self.custom_pausecb:
            # we keep a list of handlers for possible disconnection later
            self.custom_pause_handlers.append(self.pause.connect('toggled',self.custom_pausecb))
            self.pause.set_property('visible',True)
        else:
            self.pause.set_property('visible',False)
            self.pause.hide()
        # setup stop button
        self.stop = gtk.Button(_('_Stop'))
        self.action_area.pack_end(self.stop)
        if self.custom_stopcb:
            self.stop.set_property('visible',True)
            # we keep a list of handlers for possible disconnection later
            self.custom_stop_handlers.append(self.stop.connect('clicked',self.custom_stopcb))
            #self.custom_stop_handlers.append(self.stop.connect('clicked',self.cancelcb))
        else:
            self.stop.set_property('visible',False)
            self.stop.hide()
        ModalDialog.setup_buttons(self,cancel,okay)
        if self.custom_cancelcb:
            self.cancelcb = self.custom_cancelcb
            #self.cancel.connect('clicked',self.custom_cancelcb)            

    def set_progress (self, prog, message=None):
        if prog < 0:
            self.progress_bar.pulse()
        else:
            self.progress_bar.set_fraction(prog)
        if message: self.progress_bar.set_text(message)
        if prog==1:
            self.set_response_sensitive(gtk.RESPONSE_OK,True)

class PreferencesDialog (ModalDialog):

    """A dialog to get preferences from a user and return user preferences as a list."""
    
    def __init__ (self, options=([None,None]), option_label="Option",
                  value_label="Value", default=True, label=None,
                  apply_func=None, parent=None, dont_ask_cb=None,
                  dont_ask_custom_text=None):
        """Options is a tuple of tuples where each tuple is ('option', VALUE), handed to OptionTable
        
        VALUE can be any of the following:
        a string (will be editable)
        a number (will be editable and returned as a number)
        true or false (will be a checkbox)

        If apply_func is True, we will have an apply button, which
        will hand the option tuple as its argument. Otherwise, okay will simply
        return the list on okay."""
        if apply_func: modal=False
        else: modal=True
        self.apply_func = apply_func
        self.options = options        
        ModalDialog.__init__(self, okay=True, label=label, parent=parent, modal=modal)
        self.table = optionTable.OptionTable(options=self.options,
                                             option_label=option_label,
                                             value_label=value_label,
                                             changedcb=self.changedcb)
        self.hbox = gtk.HBox(); self.hbox.show()
        self.hbox.add(self.table)
        self.vbox.add(self.hbox)
        if dont_ask_cb:
            if not dont_ask_custom_text:
                dont_ask_custom_text=_("Don't ask me this again.")
            self.dont_ask = gtk.CheckButton(dont_ask_custom_text)
            self.dont_ask.connect('toggled',dont_ask_cb)
            self.vbox.add(self.dont_ask)
        self.vbox.show_all()

    def setup_buttons (self, cancel, okay):
        if self.apply_func:
            self.revert = gtk.Button(stock=gtk.STOCK_REVERT_TO_SAVED)
            self.revert.connect('clicked',self.revertcb)
            self.action_area.add(self.revert)
            self.apply = gtk.Button(stock=gtk.STOCK_APPLY)
            self.apply.set_sensitive(False)
            self.apply.connect('clicked',self.applycb)
            self.action_area.add(self.apply)
            self.apply.show()
            self.changedcb = lambda *args: self.apply.set_sensitive(True)
        else:
            self.changedcb=None
            self.set_modal(False)
        ModalDialog.setup_buttons(self, cancel, okay)

    def revertcb (self, *args):
        self.table.revert()
        
    def applycb (self, *args):
        self.table.apply()
        self.apply_func(self.table.options)
        self.apply.set_sensitive(False)

    def run (self):
        self.show()
        if self.apply_func:
            return
        else:
            gtk.main()
            return self.ret
        
    def okcb (self, *args):
        if self.apply_func:
            if self.apply.get_property('sensitive'):
                # if there are unsaved changes...
                if getBoolean(label="Would you like to apply the changes you've made?"):
                    self.applycb()
            self.hide()
        else:
            self.table.apply()
            self.ret = self.table.options
            self.hide()
            gtk.main_quit()
                   
    def cancelcb (self, *args):
        self.hide()
        self.ret=None
        
class BooleanDialog (MessageDialog):
    def __init__ (self, title="", default=True, label=_("Do you really want to do this"),
                  sublabel=False, cancel=True,
                  parent=None, custom_yes=None, custom_no=None, expander=None,
                  dont_ask_cb=None, dont_ask_custom_text=None,
                  cancel_returns=None, message_type=gtk.MESSAGE_QUESTION
                  ):
        """Setup a BooleanDialog which returns True or False.
        parent is our parent window.
        custom_yes is custom text for the button that returns true or a dictionary
                   to be handed to gtk.Button as keyword args.
        custom_no is custom text for the button that returns False or a dictionary
                   to be handed to gtk.Button as keyword args
        expander is a list whose first item is a label and second is a widget to be packed
        into an expander widget with more information.
        if dont_ask_variable is set, a Don't ask me again check
        button will be displayed which the user can check to avoid this kind
        of question again. (NOTE: if dont_ask_variable==None, this won't work!)
        dont_ask_custom_text is custom don't ask text."""
        self.cancel_returns = cancel_returns
        self.yes,self.no = custom_yes,custom_no
        if not self.yes: self.yes = gtk.STOCK_YES
        if not self.no: self.no = gtk.STOCK_NO
        MessageDialog.__init__(self,title=title,okay=False,label=label, cancel=cancel, sublabel=sublabel,parent=parent, expander=expander, message_type=message_type)
        self.responses[gtk.RESPONSE_YES]=self.yescb
        self.responses[gtk.RESPONSE_NO]=self.nocb
        if not cancel:
            # if there's no cancel, all cancel-like actions
            # are the equivalent of a NO response
            self.responses[gtk.RESPONSE_NONE]=self.nocb
            self.responses[gtk.RESPONSE_CANCEL]=self.nocb
            self.responses[gtk.RESPONSE_CLOSE]=self.nocb
            self.responses[gtk.RESPONSE_DELETE_EVENT]=self.nocb
        if dont_ask_cb:
            if not dont_ask_custom_text:
                dont_ask_custom_text=_("Don't ask me this again.")
            self.dont_ask = gtk.CheckButton(dont_ask_custom_text)            
            self.dont_ask.connect('toggled',dont_ask_cb)
            self.vbox.add(self.dont_ask)
            self.dont_ask.show()
        #self.action_area.add(self.no)
        #self.action_area.add(self.yes)
        #self.yes.connect('clicked',self.yescb)
        #self.no.connect('clicked',self.nocb)
        #self.action_area.show_all()

    def setup_buttons (self,*args,**kwargs):
        MessageDialog.setup_buttons(self,*args,**kwargs)
        self.add_button((self.no or gtk.STOCK_NO),gtk.RESPONSE_NO)
        self.add_button((self.yes or gtk.STOCK_YES),gtk.RESPONSE_YES)

    def yescb (self, *args):
        self.ret=True
        self.okcb()

    def cancelcb (self, *args):
        if self.cancel_returns != None:
            self.ret = self.cancel_returns
        self.okcb()

    def nocb (self, *args):
        self.ret=False
        self.okcb()

class SimpleFaqDialog (ModalDialog):
    """A dialog to view a plain old text FAQ in an attractive way"""

    INDEX_MATCHER = re.compile("^[0-9]+[.][A-Za-z0-9.]* .*")

    # We except one level of nesting in our headers.
    # NESTED_MATCHER should match nested headers
    NESTED_MATCHER = re.compile("^[0-9]+[.][A-Za-z0-9.]+ .*")

    def __init__ (self,
                  faq_file='/home/tom/Projects/grm-0.8/FAQ',
                  title="Frequently Asked Questions",
                  jump_to = None,
                  parent=None,
                  modal=True):
        #print faq_file
        ModalDialog.__init__(self,title=title,parent=parent,modal=modal,cancel=False)
        self.set_default_size(950,500)        
        self.textview = gtk.TextView()
        self.textview.set_editable(False)
        self.textview.set_wrap_mode(gtk.WRAP_WORD)
        self.textview.set_left_margin(18)
        self.textview.set_right_margin(18)
        self.textbuf = self.textview.get_buffer()
        self.boldtag = self.textbuf.create_tag()
        from pango import WEIGHT_BOLD
        self.boldtag.set_property('weight',WEIGHT_BOLD)
        self.textwin = gtk.ScrolledWindow()
        self.textwin.set_policy(gtk.POLICY_AUTOMATIC,gtk.POLICY_AUTOMATIC)
        self.textwin.add(self.textview)
        self.parse_faq(faq_file)
        if self.index_lines:
            self.hp = gtk.HPaned()
            self.indexView = gtk.TreeView()
            self.indexWin = gtk.ScrolledWindow()
            self.indexWin.set_policy(gtk.POLICY_AUTOMATIC,gtk.POLICY_AUTOMATIC)
            self.indexWin.add(self.indexView)
            self.setup_index()
            self.hp.add1(self.indexWin)
            self.hp.add2(self.textwin)
            self.vbox.add(self.hp)
            self.vbox.show_all()
            self.hp.set_position(325)
        else:
            self.vbox.add(textwin)
            self.vbox.show_all()
        if jump_to: self.jump_to_header(jump_to)

    def jump_to_header (self, text):
        """Jump to the header/index items that contains text.
        """
        text = text.lower()
        for l in self.index_lines:
            if l.lower().find(text) > 0:
                itr=self.index_iter_dic[l]
                # select our iter...
                # as a side effect, we will jump to the right part of the text
                self.indexView.get_selection().select_iter(itr)
                # expand our iter
                mod = self.indexView.get_model()
                self.indexView.expand_row(mod.get_path(itr),True)
                return

    def parse_faq (self, infile):
        """Parse file infile as our FAQ to display.

        infile can be a filename or a file-like object.
        We parse index lines according to self.INDEX_MATCHER
        """
        CLOSE=False
        if type(infile)==str:
            infile=open(infile)            
            CLOSE=True
        self.index_lines = []
        self.index_dic={}
        self.text = ""
        for l in infile.readlines():
            if self.INDEX_MATCHER.match(l):
                self.index_lines.append(l.strip())
                curiter = self.textbuf.get_iter_at_mark(self.textbuf.get_insert())
                self.index_dic[l.strip()]=self.textbuf.create_mark(None,curiter,left_gravity=True)
                self.textbuf.insert_with_tags(
                    curiter,
                    l.strip()+" ",
                    self.boldtag)
            # we unwrap lines (paragraphs in our source are
            # separated by blank lines
            elif l.strip():
                self.textbuf.insert_at_cursor(l.strip()+" ")
            else:
                self.textbuf.insert_at_cursor("\n\n")
        if CLOSE: infile.close()

    def setup_index (self):
        """Set up a clickable index view"""
        self.imodel = gtk.TreeStore(str)
        self.index_iter_dic={}
        last_parent = None
        for l in self.index_lines:
            if self.NESTED_MATCHER.match(l):
                itr=self.imodel.append(last_parent,[l])
            else:
                itr=self.imodel.append(None,[l])
                last_parent=itr
            self.index_iter_dic[l]=itr
        # setup our lone column
        self.indexView.append_column(
            gtk.TreeViewColumn("",
                               gtk.CellRendererText(),
                               text=0)
            )
        self.indexView.set_model(self.imodel)
        self.indexView.set_headers_visible(False)
        self.indexView.connect('row-activated',self.index_activated_cb)
        self.indexView.get_selection().connect('changed',self.index_selected_cb)

    def index_activated_cb (self, *args):
        """Toggle expanded state of rows."""
        mod,itr = self.indexView.get_selection().get_selected()
        path=mod.get_path(itr)
        if self.indexView.row_expanded(path):
            self.indexView.collapse_row(path)
        else:
            self.indexView.expand_row(path, True)

    def index_selected_cb (self,*args):
        mod,itr = self.indexView.get_selection().get_selected()
        val=self.indexView.get_model().get_value(itr,0)
        #self.jump_to_text(val)
        self.textview.scroll_to_mark(self.index_dic[val],False,use_align=True,yalign=0.0)

    def jump_to_text (self, txt, itr=None):
        if not itr:
            itr = self.textbuf.get_iter_at_offset(0)
        match_start,match_end=itr.forward_search(txt,gtk.TEXT_SEARCH_VISIBLE_ONLY)
        #print 'match_start = ',match_start
        self.textview.scroll_to_iter(match_start,False,use_align=True,yalign=0.1)
        
class RatingsConversionDialog (ModalDialog):
    """A dialog to allow the user to select the number of stars
    distinct ratings should convert to.

    This dialog exists to aid conversion of ratings from old gourmet
    exports or databases or from other imports that use strings of
    some kind ('great','groovy',etc.) to aid in conversion.
    """
    def __init__ (self,
                  strings,
                  star_generator,
                  defaults={_("excellent"):10,
                            _("great"):8,
                            _("good"):6,
                            _("fair"):4,
                            _("poor"):2,},
                  parent=None,
                  modal=True):
        """strings is a list of strings that are currently used for ratings.

        The user will be asked to give the star equivalent of each string.
        """
        self.strings = strings
        self.star_generator=star_generator
        self.defaults = defaults
        ModalDialog.__init__(
            self,
            title=_("Convert ratings to 5 star scale."),
            label=_("Convert ratings."),
            sublabel=_("Please give each of the ratings an equivalent on a scale of 1 to 5"),
            parent=parent,
            modal=modal
            )
        self.set_default_size(750,500)
        self.ret = {}
        self.setup_tree()

    def setup_tree (self):
        self.tv = gtk.TreeView()
        self.setup_model()
        self.tv.set_model(self.tm)
        from ratingWidget import TreeWithStarMaker
        textcol = gtk.TreeViewColumn(_('Current Rating'),gtk.CellRendererText(),text=0)
        textcol.set_sort_column_id(0)
        self.tv.append_column(textcol)
        TreeWithStarMaker(self.tv,
                          self.star_generator,
                          col_title=_("Rating out of 5 Stars"),
                          col_position=-1,
                          data_col=1,
                          handlers=[self.ratings_change_cb],
                          )
        self.sw = gtk.ScrolledWindow()
        self.sw.set_policy(gtk.POLICY_AUTOMATIC,gtk.POLICY_AUTOMATIC)
        self.sw.add(self.tv)
        self.vbox.add(self.sw)
        self.sw.show_all()

    def setup_model (self):
        self.tm = gtk.ListStore(str,int)
        for s in self.strings:
            val=self.defaults.get(s.lower(),0)
            self.tm.append([s,val])
            self.ret[s]=val

    def ratings_change_cb (self, value, model, treeiter, colnum):
        string = model.get_value(treeiter,0)
        self.ret[string]=value
        model.set_value(treeiter,colnum,value)

def show_traceback (label="Error", sublabel=None):
    """Show an error dialog with a traceback viewable."""
    from StringIO import StringIO
    import traceback
    #f = StringIO()
    #traceback.print_exc(file=f)
    #f.getvalue()
    error_mess =traceback.format_exc()
    show_message(label=label,
                 sublabel=sublabel,
                 expander=(_("_Details"),error_mess),
                 message_type=gtk.MESSAGE_ERROR
                 )

def show_message (*args, **kwargs):
    """Show a message dialog.
    Args and Kwargs are handed to MessageDialog
    We most likely want to hand it label= and sublabel=
    """
    #if not kwargs.has_key(message_type):
    #    message_type=gtk.MESSAGE_INFO
    if not kwargs.has_key('cancel'):
        kwargs['cancel']=False
    d=MessageDialog(*args,**kwargs)
    d.run()
    return d



def select_file (title,
                 filename=None,
                 filters=[],
                 # filters are lists of a name, a list of mime types and a list of
                 # patterns ['Plain Text', ['text/plain'], '*txt']
                 action=gtk.FILE_CHOOSER_ACTION_OPEN,
                 set_filter=True,
                 select_multiple=False,
                 buttons=None,
                 parent=None
                 ):
    sfd=FileSelectorDialog(title,
                           filename=filename,
                           filters=filters,
                           select_multiple=select_multiple,
                           action=action,
                           set_filter=set_filter,
                           buttons=buttons,parent=parent)
    return sfd.run()

def saveas_file (title,
                 filename=None,
                 filters=[],
                 action=gtk.FILE_CHOOSER_ACTION_SAVE,
                 set_filter=True,
                 buttons=None,
                 parent=None,
                 show_filetype=True):
    """Almost identical to select_file, except that we return a tuple containing
    the filename and the export type (the string the user selected)"""
    sfd=FileSelectorDialog(title,filename=filename,filters=filters,
                           action=action,set_filter=set_filter,buttons=buttons,
                           show_filetype=show_filetype,parent=parent)
    retval = sfd.run()
    if not retval:
        return None,None
    exp_type = get_type_for_filters(retval, filters[:])
    if not exp_type:
        # If we don't have a type based on our regexps... then lets
        # just see what the combobox was set to...
        try:
            exp_type = filters[sfd.saveas.get_active()][0]
        except:
            pass
    return retval, exp_type

def get_type_for_filters (fname, filters):
    base,ext = os.path.splitext(fname)
    exp_type = None
    while filters and not exp_type:
        name,mime,rgxps = filters.pop()
        for r in rgxps:
            if os.path.splitext(r)[1] == ext:
                exp_type = name
    return exp_type

def select_image (title,
                  filename=None,
                  action=gtk.FILE_CHOOSER_ACTION_OPEN,
                  buttons=None):    
    sfd=ImageSelectorDialog(title,filename=filename,action=action,buttons=buttons)
    return sfd.run()

class FileSelectorDialog:
    """A dialog to ask the user for a file. We provide a few custom additions to the
    standard file dialog, including a special choose-filetype menu and including dynamic update
    of the filetype based on user input of an extension"""
    def __init__ (self,
                  title,
                  filename=None,
                  filters=[],
                  # filters are lists of a name, a list of mime types and a list of
                  # patterns ['Plain Text', ['text/plain'], '*txt']
                  action=gtk.FILE_CHOOSER_ACTION_SAVE,
                  set_filter=True,
                  buttons=None,
                  show_filetype=True,
                  parent=None,
                  select_multiple=False
                  ):
        self.parent=parent
        self.buttons=buttons
        self.multiple=select_multiple
        self.set_filter=set_filter
        self.action=action
        self.filename=filename
        self.title=title
        self.filters=filters
        self.show_filetype=show_filetype
        self.setup_dialog()
        self.post_dialog()

    def post_dialog (self):
        """Run after the dialog is set up (to allow subclasses to do further setup)"""
        pass

    def setup_dialog (self):
        """Create our dialog"""
        self.setup_buttons()
        self.fsd = gtk.FileChooserDialog(self.title,
                                         action=self.action,
                                         parent=self.parent,
                                         buttons=self.buttons,
                                         #backend = (vfs_available and 'gnome-vfs') or None,
                                         )
        #if vfs_available:
        #    self.fsd.props.local_only = False
        self.fsd.set_default_response(gtk.RESPONSE_OK)
        self.fsd.set_select_multiple(self.multiple)
        self.fsd.set_do_overwrite_confirmation(True)
        if self.filename:
            path,name=os.path.split(os.path.expanduser(self.filename))
            if path: self.fsd.set_current_folder(path)
            if name: self.fsd.set_current_name(name)
        self.setup_filters()
        if self.action==gtk.FILE_CHOOSER_ACTION_SAVE:
            self.setup_saveas_widget()

    def setup_buttons (self):
        """Set our self.buttons attribute"""
        if not self.buttons:
            if self.action==gtk.FILE_CHOOSER_ACTION_OPEN or self.action==gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER:
                self.buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK)
            else:
                self.buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OK,gtk.RESPONSE_OK)
    
    def setup_filters (self):
        """Create and set filters for the dialog."""
        self.extensions = []
        for fil in self.filters:
            filter = gtk.FileFilter()
            filter_name, filter_mime_types, filter_patterns = fil
            filter.set_name(filter_name)
            if filter_mime_types:
                for f in filter_mime_types:
                    filter.add_mime_type(f)
            if filter_patterns:
                for f in filter_patterns:
                    filter.add_pattern(f)
                    self.extensions.append(f)
            self.fsd.add_filter(filter)
        if self.set_filter and self.filters:
            self.fsd.set_filter(self.fsd.list_filters()[0])

    def setup_saveas_widget (self):
        """Set up the filter widget."""
        if not self.filters:
            self.do_saveas = False
            return
        self.do_saveas = True
        n = 0
        self.ext_to_filter = {}
        self.name_to_ext = {}
        for name,mimetypes,regexps in self.filters:
            # name_to_ext lets us grab the correct extension from our active iter
            self.name_to_ext[name]=os.path.splitext(regexps[0])[-1]
            for r in regexps:
                ext = os.path.splitext(r)[-1]
                # ext_to_filter let's us select the correct iter from the extension typed in
                self.ext_to_filter[ext]=self.fsd.list_filters()[n]
            n += 1

        self.fn = None
        self.fsd.connect('notify::filter',self.change_file_extension)
        self.fsd.connect('selection-changed',self.update_filetype_widget)
        self.internal_extension_change=False
        self.update_filetype_widget()
        # and now for a hack -- since we can't connect to the Entry widget,
        # we're going to simply check to see if the filename has changed with
        # an idle call.
        self.timeout = gobject.timeout_add(100, self.update_filetype_widget)
        
    def update_filetype_widget (self, *args):
        fn=self.fsd.get_filename()
        if self.fn != fn:
            self.fn = fn
            if not fn:
                return True
            ext=os.path.splitext(fn)[1]
            if self.ext_to_filter.has_key(ext):
                self.internal_extension_change=True
                self.fsd.set_filter(self.ext_to_filter[ext])
                self.internal_extension_change=False
        return True

    def change_file_extension (self, fsd, data):
        if self.internal_extension_change: return
        fn = os.path.split(self.fsd.get_filename())[1]
        # strip off the old extension if it was one of our
        # filetypes and now we're changing
        if self.is_extension_legal(fn):
            base = os.path.splitext(fn)[0]
        else:
            base = fn
        ext = self.name_to_ext[fsd.get_filter().get_name()]
        if self.show_filetype:
            debug('changing file extension to %s'%(base + ext),3)
            self.fsd.set_current_name(base + ext)
        else:
            debug('changing file extension for %s to %s'%(base, ext))
            self.fsd.set_current_name(base)

    def is_extension_legal (self, fn):
        if not fn: return
        for e in self.extensions:
            if not e: e=""
            if fnmatch.fnmatch(fn, e):
                return True

    def run (self):
        """Run our dialog and return the filename or None"""
        response = self.fsd.run()
        if response == gtk.RESPONSE_OK:
            if self.multiple:
                #if vfs_available:
                #    fn = self.fsd.get_uris()
                #else:
                fn = self.fsd.get_filenames()
            else:
                #if vfs_available:
                #    fn = self.fsd.get_uri()
                #else:
                fn = self.fsd.get_filename()
            if not fn:
                show_message(label=_('No file selected'),
                             sublabel=_('No file was selected, so the action has been cancelled')
                             )
                return None
            if self.action==gtk.FILE_CHOOSER_ACTION_SAVE:
                # add the extension if need be...
                if self.do_saveas and not self.is_extension_legal(fn):
                    if self.name_to_ext.has_key(self.fsd.get_filter().get_name()):
                        add_ext = self.name_to_ext[self.fsd.get_filter().get_name()]
                        if add_ext: fn += add_ext
            self.quit()
            return fn
        else:
            self.quit()
            return None

    def quit (self, *args):
        if hasattr(self,'timeout'):
            gobject.source_remove(self.timeout)
        self.fsd.destroy()
        
    
class ImageSelectorDialog (FileSelectorDialog):
    IMAGE_FILTERS = [
        ['Image',
         ['image/jpeg','image/png','image/tiff',
          'image/bmp','image/cgf',],
         ['*.jpeg','*.jpg','gif','bmp','png',
          '*.JPEG','*.JPG','GIF','BMP','PNG']
         ],
        ['Jpeg Image',['image/jpeg'],['*.jpeg','*.jpg','*.JPG','*.JPEG']],
        ['PNG Image',['image/png'],['*.png','*.PNG']],
        ['Bmp Image',['image/bmp'],['*.bmp','*.BMP']],
        ['CGF Image',['image/cgf'],['*.cgf','*.CFG']],
        ['Tiff Image',['image/tiff'],['*.tiff','*.TIFF']]
        ]

    def __init__ (self,
                  title,
                  filename=None,
                  filters=IMAGE_FILTERS,
                  action=gtk.FILE_CHOOSER_ACTION_OPEN,
                  set_filter=True,
                  buttons=None
                  ):
        FileSelectorDialog.__init__(self, title, filename, filters, action, set_filter, buttons)
        pictures_dir = get_user_special_dir(USER_DIRECTORY_PICTURES)
        if not pictures_dir == None:
            self.fsd.set_current_folder(pictures_dir)

    def post_dialog (self):
        self.preview = gtk.Image()
        self.fsd.set_preview_widget(self.preview)
        self.fsd.connect('selection-changed',self.update_preview)
        self.preview.show()

    def update_preview (self, *args):
        uri = self.fsd.get_uri()
        # first, let's look for a large thumbnail
        thumbpath = thumbnail.check_for_thumbnail(uri) #default size is large
        if thumbpath:
            self.preview.set_from_file(thumbpath)
            self.preview.show()
        else:
            self.preview.hide()

def getNumber (*args, **kwargs):
    """Run NumberDialog, passing along all args, waiting on input and passing along
    the results."""
    d = NumberDialog(*args, **kwargs)
    return d.run()
                     
def getEntry (*args, **kwargs):
    """Run EntryDialog, passing along all args, waiting on input and passing along
    the results."""    
    d = EntryDialog(*args, **kwargs)
    return d.run()

def getBoolean (*args,**kwargs):
    """Run BooleanDialog, passing along all args, waiting on input and
    passing along the results."""
    d = BooleanDialog(*args,**kwargs)
    retval = d.run()
    if retval==None:
        raise UserCancelledError("getBoolean dialog cancelled!")
    else:
        return retval

def getOption (*args,**kwargs):
    d=OptionDialog(*args,**kwargs)
    return d.run()

def getRadio (*args,**kwargs):
    d=RadioDialog(*args,**kwargs)
    return d.run()

def show_faq (*args,**kwargs):
    d=SimpleFaqDialog(*args,**kwargs)
    return d.run()

def get_ratings_conversion (*args,**kwargs):
    d=RatingsConversionDialog(*args,**kwargs)
    return d.run()

def show_amount_error (txt):
    """Show an error that explains how numeric amounts work."""
    de.show_message(label=_("""I'm sorry, I can't understand
the amount "%s".""")%txt,
                    sublabel=_("Amounts must be numbers (fractions or decimals), ranges of numbers, or blank."),
                    expander=[_("_Details"),
                              _("""
The "unit" must be in the "unit" field by itself.
For example, if you want to enter one and a half cups,
the amount field could contain "1.5" or "1 1/2". "cups"
should go in the separate "unit" field.

To enter a range of numbers, use a "-" to separate them.
For example, you could enter 2-4 or 1 1/2 - 3 1/2.
""")])


if __name__ == '__main__':
    print 'Got',saveas_file('Saveas')
    w=gtk.Window()
    w.connect('delete_event',gtk.main_quit)
    b=gtk.Button("show dialog (modal)")
    opts=(["Toggle Option",True],
          ["String Option","Hello"],
          ["Integer Option",1],
          ["Float Option",float(3)],
          ["Option Option",("B",["A","B","C"])],
          )
    pd=PreferencesDialog(options=opts)
    def run_prefs (*args):
         pd.run()
    b.connect('clicked',run_prefs)
    def show_options (options):
        print options
    b2=gtk.Button("show dialog (not modal)")
    vb=gtk.VBox()
    def msg(*args):
        for a in args:
            print a
    char_measure = ""
    for n in range(10): char_measure="%s %s"%(char_measure,n)
    char_measure = char_measure * 50
    from ratingWidget import StarGenerator
    for s,f in [
        ['show dialog (modal)',run_prefs],
        ['show ratings dialog',lambda *args: get_ratings_conversion(['Good','Great','So so','Hot shit'],
                                                                    StarGenerator(),
                                                                    )],
        ['show dialog (not modal)',lambda *args: PreferencesDialog(options=opts,apply_func=show_options).show()],
        ['show FAQ',lambda *args: show_faq(jump_to='shopping')],
        ['show message',lambda *args: show_message('howdy',label='Hello there. This is a very long label for the top of a dialog.', sublabel='And this is a sub message.',message_type=gtk.MESSAGE_WARNING)],
        ['get entry', lambda *args: getEntry(label='Main label',sublabel='sublabel',entryLabel='Entry Label: ')],
        ['get number', lambda *args: getNumber(label='Main label',sublabel='sublabel')],        
        ['get long entry', lambda *args: getEntry(label='Main label', sublabel=char_measure, entryLabel='Entry Label: ',default_character_width=75,entryTip='Enter something long here.')],
        ['show boolean', lambda *args: getBoolean()],
        ['show custom boolean', lambda *args: getBoolean(custom_yes='_Replace',
                                                         custom_no=gtk.STOCK_CANCEL,
                                                         cancel=False
                                                         )],
        ['show radio dialog', lambda *args: getRadio(label='Main label',
                                                     sublabel='sublabel'*10,default=2,
                                                     options=[('First',1),
                                                              ('Second',2),
                                                              ('Third',3)]),],
        ['get image dialog',lambda *args: msg(select_image('Select Image'))],
        ['get file dialog',lambda *args: msg(select_file('Select File',
                                                     filters=[['Plain Text',['text/plain'],['*.txt','*.TXT']],
                                            ['PDF',['application/pdf'],['*.pdf','*.PDF']],
                                            ['Postscript',['application/postscript'],['*.ps','*.PS']],
                                            ['Web Page (HTML)',['text/html'],['*.htm','*.HTM','*.html','*.HTML']],
                                            ['Mealmaster File',['text/mmf'],['*.mmf','*.MMF']]],
                                                     select_multiple=True
                                                     )),
         ],
        ['save file with types',
         lambda *args: msg(saveas_file('export',filename='/tmp/test.mmf',
                                   filters=[['Plain Text',['text/plain'],['*.txt','*.TXT']],
                                            ['PDF',['application/pdf'],['*.pdf','*.PDF']],
                                            ['Postscript',['application/postscript'],['*.ps','*.PS']],
                                            ['Web Page (HTML)',['text/html'],['*.htm','*.HTM','*.html','*.HTML']],
                                            ['Mealmaster File',['text/mmf'],['*.mmf','*.MMF']]]))],
        ]:
        print b,f,s
        b = gtk.Button(s)
        def wrap (f):
            def _ (*args,**kwargs):
                print 'Doing ',f
                print 'f returns:',f()
                print 'Done'
            return _
        b.connect('clicked',wrap(f))
        vb.add(b)
    w.add(vb)
    vb.show_all()
    w.show_all()
    gtk.main()
    


########NEW FILE########
__FILENAME__ = LinkedTextView
### Copyright (C) 2005 Thomas M. Hinkle
### Copyright (C) 2009 Rolf Leggewie
###
### This library is free software; you can redistribute it and/or
### modify it under the terms of the GNU General Public License as
### published by the Free Software Foundation; either version 2 of the
### License, or (at your option) any later version.
###
### This library is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
### General Public License for more details.
###
### You should have received a copy of the GNU General Public License
### along with this library; if not, write to the Free Software
### Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
### USA 

# Largely based on hypertext.py example in pygtk docs by
# Maik Hertha <maik.hertha@berlin.de>

import pango,gtk,gobject
import re, xml.sax.saxutils
from TextBufferMarkup import PangoBuffer
from gourmet.gdebug import debug

class LinkedPangoBuffer (PangoBuffer):

    href_regexp = re.compile(r"<a href=['\"]([^'\"]+)['\"][^>]*>(.*?)</a>")

    url_markup = 'underline="single" color="blue"'

    url_props = [('underline',pango.UNDERLINE_SINGLE),
                 ('foreground-gdk',gtk.gdk.color_parse('blue')),
                 ]

    markup_dict = {}

    def set_text (self, txt):
        m = self.href_regexp.search(txt)
        if m:
            while m:
                href = m.groups()[0]
                body = m.groups()[1]
                if self.markup_dict.has_key(body) and self.markup_dict[body]!=href:
                    raise Exception("""Damn -- our not-so-clever implementation of <a href=""> parsing requires
                    that no two distinct links have the same text describing them!""")
                self.markup_dict[body]=href
                m = self.href_regexp.search(txt,m.end())
            txt = self.href_regexp.sub(r'<span %s>\2</span>'%self.url_markup,txt)
        PangoBuffer.set_text(self,txt)

    def insert_with_tags (self, itr, text, *tags):
        match = True
        for p,v in self.url_props:
            match = False
            for t in tags:
                if isinstance(v,gtk.gdk.Color):
                    c = t.get_property(p)
                    if v.red==c.red and v.blue==c.blue and v.green==c.green:
                        match=True
                elif t.get_property(p)==v:
                    match=True
            if not match:
                break
        text = unicode(text)
        if match and self.markup_dict.has_key(text):
            new_tag = self.create_tag()
            new_tag.set_data('href',self.markup_dict[text])
            tags = list(tags)
            tags.append(new_tag)
        elif match:
            print 'Funny',text,'looks like a link, but is not in markup_dict',self.markup_dict
        PangoBuffer.insert_with_tags(self,itr,text,*tags)

class LinkedTextView (gtk.TextView):
    __gtype_name__ = 'LinkedTextView'

    hovering_over_link = False
    hand_cursor = gtk.gdk.Cursor(gtk.gdk.HAND2)
    regular_cursor = gtk.gdk.Cursor(gtk.gdk.XTERM)

    __gsignals__ = {
        'link-activated':(gobject.SIGNAL_RUN_LAST,
                          gobject.TYPE_STRING,
                          [gobject.TYPE_STRING]),
        }
    
    def __init__ (self):
        gobject.GObject.__init__(self)
        gtk.TextView.__init__(self)
        self.set_buffer(self.make_buffer())
        buf = self.get_buffer()
        self.set_text = buf.set_text
        self.connect('key-press-event',self.key_press_event)
        self.connect('event-after',self.event_after)
        self.connect('motion-notify-event',self.motion_notify_event)
        self.connect('visibility-notify-event',self.visibility_notify_event)

    def make_buffer (self):
        return LinkedPangoBuffer()

    # Links can be activated by pressing Enter.
    def key_press_event(self, text_view, event):
        keyname = gtk.gdk.keyval_name(event.keyval)
        if keyname in ['Return','KP_Enter']:
            buffer = text_view.get_buffer()
            iter = buffer.get_iter_at_mark(buffer.get_insert())
            return self.follow_if_link(text_view, iter)
        return False
    # Links can also be activated by clicking.
    def event_after(self, text_view, event):
        if event.type != gtk.gdk.BUTTON_RELEASE:
            return False
        if event.button != 1:
            return False
        buffer = text_view.get_buffer()

        # we shouldn't follow a link if the user has selected something
        try:
            start, end = buffer.get_selection_bounds()
        except ValueError:
            # If there is nothing selected, None is return
            pass
        else:
            if start.get_offset() != end.get_offset():
                return False

        x, y = text_view.window_to_buffer_coords(gtk.TEXT_WINDOW_WIDGET,
            int(event.x), int(event.y))
        iter = text_view.get_iter_at_location(x, y)
        self.follow_if_link(text_view, iter)
        return False

    # Looks at all tags covering the position (x, y) in the text view,
    # and if one of them is a link, change the cursor to the "hands" cursor
    # typically used by web browsers.
    def set_cursor_if_appropriate(self, text_view, x, y):
        hovering = False
        buffer = text_view.get_buffer()
        iter = text_view.get_iter_at_location(x, y)
        tags = iter.get_tags()

        for tag in tags:
            href = tag.get_data("href")
            if href:
                hovering = True
                break
        if hovering != self.hovering_over_link:
            self.hovering_over_link = hovering

        if self.hovering_over_link:
            text_view.get_window(gtk.TEXT_WINDOW_TEXT).set_cursor(self.hand_cursor)
        else:
            text_view.get_window(gtk.TEXT_WINDOW_TEXT).set_cursor(self.regular_cursor)

    # Update the cursor image if the pointer moved.
    def motion_notify_event(self, text_view, event):
        x, y = text_view.window_to_buffer_coords(gtk.TEXT_WINDOW_WIDGET,
            int(event.x), int(event.y))
        self.set_cursor_if_appropriate(text_view, x, y)
        text_view.window.get_pointer()
        return False

    # Also update the cursor image if the window becomes visible
    # (e.g. when a window covering it got iconified).
    def visibility_notify_event(self, text_view, event):
        wx, wy, mod = text_view.window.get_pointer()
        bx, by = text_view.window_to_buffer_coords(gtk.TEXT_WINDOW_WIDGET, wx, wy)

        self.set_cursor_if_appropriate (text_view, bx, by)
        return False

    def follow_if_link (self, text_view, iter):
        ''' Looks at all tags covering the position of iter in the text view,
            and if one of them is a link, follow it by showing the page identified
            by the data attached to it.
        '''
        tags = iter.get_tags()
        for tag in tags:
            href = tag.get_data('href')
            if href:
                self.emit('link-activated',href)
                return True

if __name__ == '__main__':
    def print_link (tv,l):
        print l
    tv = LinkedTextView()
    tv.connect('link-activated',print_link)    
    w = gtk.Window()
    w.add(tv)
    tv.get_buffer().set_text(u"""This is some text
    Some <i>fancy</i>, <u>fancy</u>, text.
    This is <a href="foo">a link</a>, a
    <a href="fancy_desc">fancy, fancy</a> link.

    <a href="123:foo">recipe link</a>

    <a href="456:boo">\xbc recipe boogoochooboo</a>
    
    <b>Yeah!</b>
    """)

    w.show_all()
    w.connect('delete-event',lambda *args: gtk.main_quit())
    gtk.main()

########NEW FILE########
__FILENAME__ = mnemonic_manager
import gtk

def collect_descendants (parent, descendants=None):
    """Return all descendants of parent widget.

    Crawls tree recursively.
    """
    if not descendants: descendants = []
    if hasattr(parent,'get_children'):
        for c in parent.get_children():
            if c not in descendants: descendants.append(c)
            collect_descendants(c,descendants)
    if hasattr(parent,'get_submenu'):
        #print 'Getting submenu!'
        if parent.get_submenu():
            descendants.append(parent.get_submenu())
            collect_descendants(parent.get_submenu(),descendants)
    return descendants

class MnemonicManager:

    """This is a class to help prevent collisions of mnemonics. This
    works in an automated way, so that we don't have to rely on
    translators knowing which strings show up on the same page
    together in order to prevent collisions of mnemonics.

    This class can collect all mnemonics from a gtk.Builder file or by
    working down from a toplevel widget.

    mm = MnemonicManager()

    mm.add_toplevel_widget(widget)
    OR
    mm.add_builder(gtk.Builder instance)

    mm.fix_conflicts_peacefully()

    The fix_conflicts_peacefully algorithm will get rid of all the
    conflicts it can eliminate.  The algorithm knows that submenus are
    special animals and will set up a separate sub-instance of
    MnemonicManager to deal with each submenu within the menu system.

    mm.sacred_cows is a list of items that should never be changed.
    """

    sacred_cows = ['okay','cancel','close','file','edit']

    def __init__ (self):
        self.mnemonics = {}
        self.sub_managers = {}
        self.notebook_managers = {}
        self.untouchable_accels = []
        self.untouchable_widgs = []

    def get_submanager (self, w):
        p = w.parent
        while p:
            if self.sub_managers.has_key(p):
                return self.sub_managers[p]
            p = p.parent
        return self

    def add_toplevel_widget (self, w):
        widgets = collect_descendants(w)
        self.add_ui(widgets)

    def add_builder (self, ui=None, ui_file=None):
        """Add all mnemonic widgets in gtk.Builder object.

        We can be passed a gtk.Builder (.ui) file or a gtk.Builder object.
        Realistically, though, you'll want to pass the object and keep
        a reference around to use. The file option's really just for
        testing :)
        """
        if not ui:
            ui = gtk.Builder()
            ui.add_from_file(ui_file)
        widgets=ui.get_objects() # get all widgets
        # Check if there are more than one window, in which case we
        # each window gets its own sub_handler
        windows = filter(lambda w: isinstance(w,gtk.Window),widgets)
        if len(windows)>0:
            for w in windows:
                self.sub_managers[w]=MnemonicManager()
                self.sub_managers[w].add_toplevel_widget(w)
            return
        else:
            self.add_ui(widgets)

    def add_ui (self, widgets):
        added = []
        # handle menu items
        menus = filter(lambda x: isinstance(x,gtk.Menu),widgets)
        for menu in menus:
            #print 'Create submenu for ',menu
            self.sub_managers[menu] = MnemonicManager()
        menu_items = filter(lambda x: isinstance(x,gtk.MenuItem),widgets)
        for mi in menu_items:
            #print 'Looking at menu item',mi,mi.get_children()
            widgets.remove(mi)
            children =  mi.get_children()
            if children and isinstance(children[0],gtk.Label):
                lab = children[0]
            else:
                #print 'Ignoring menu',mi,mi.get_children()
                continue
            added.append(lab)
            if self.get_submanager(mi) == self:
                self.add_widget_mnemonic(lab,untouchable=True)
            else:
                self.get_submanager(mi).add_widget_mnemonic(lab)
        # handle other mnemonic labels we have
        has_keyval = filter(lambda x: (hasattr(x,'get_mnemonic_keyval')
                                       and
                                       gtk.gdk.keyval_name(x.get_mnemonic_keyval())!='VoidSymbol'),
                            widgets)
        more_mnemonics = []
        for w in widgets:
            mm = w.list_mnemonic_labels()
            more_mnemonics.extend(mm)
            if isinstance(w,gtk.TreeView):
                self.add_treeview(w)
        for l in more_mnemonics:
            if l not in has_keyval and l not in added: has_keyval.append(l)
        for w in has_keyval:
            # Are we in a notebook?
            nb = None
            p = w.parent
            added_to_sub = False
            while p:
                if isinstance(p.parent,gtk.Notebook):
                    break
                elif self.sub_managers.has_key(p.parent):
                    self.sub_managers[p.parent].add_widget_mnemonic(w)
                    added_to_sub = True
                    break
                else:
                    p=p.parent
            if added_to_sub: continue
            if p and isinstance(p.parent,gtk.Notebook):
                nb = p.parent
                page = nb.page_num(p)
                if not self.notebook_managers.has_key(nb):
                    self.notebook_managers[nb]={}
                if not self.notebook_managers[nb].has_key(page):
                    self.notebook_managers[nb][page]=MnemonicManager()
                self.notebook_managers[nb][page].add_widget_mnemonic(w)
            else:
                if isinstance(w.parent,gtk.Notebook):
                    # make notebook tab labels (should be our only
                    # direct descendant labels) untouchable.
                    self.add_widget_mnemonic(w,untouchable=True,fix_untouchables=True)
                else:
                    self.add_widget_mnemonic(w)
        more_mnemonics = []

    def add_treeview (self, tv):
        #print 'Mnemonic manager add TV'
        for c in tv.get_columns():
            t = c.get_title()
            #print 'Column:',t
            if t.find('_')>-1:
                widg = gtk.Label(t)
                widg.set_use_underline(True)
                c.set_widget(widg)
                widg.show()
                self.add_widget_mnemonic(widg)

    def add_widget_mnemonic (self, w, untouchable=False, fix_untouchables=False): 
        k = gtk.gdk.keyval_name(w.get_mnemonic_keyval())
        if w.get_text().lower().replace('_','') in self.sacred_cows:
            untouchable = True; fix_untouchables=False
        if untouchable:
            if k in self.untouchable_accels and fix_untouchables:
                # we have a conflict among untouchables to fix...
                alts = self.find_alternatives(w)
                if alts:
                    k = alts[0]
                    self.change_mnemonic(w,k)
            #print 'Add untouchable key:',k,w
            self.untouchable_accels.append(k)
            self.untouchable_widgs.append(w)
        if not self.mnemonics.has_key(k): self.mnemonics[k]=[]
        if not w in self.mnemonics[k]:
            self.mnemonics[k].append(w)

    def generate_new_mnemonic (self, text):
        for c in text:
            if not self.mnemonics.has_key(c.lower()):
                self.mnemonics[c.lower()]=[text]
                n = text.find(c)
                return text[0:n]+'_'+text[n:]
        # default to first character if there's no conflict-free
        # mnemonic available
        self.mnemonics[text[0].lower()].append(text)
        return '_'+text

    def find_alternatives (self, w, filter_untouchables = True):
        text = w.get_text()
        if not text: return []
        cur_ind = text.find('_')+1
        alts = [text[cur_ind].lower()]
        # Now we go through and find first letters of words...
        if cur_ind == 1: ind=2
        else: ind = 0
        ind = text.find(' ',ind)
        last_letter_that_could_be_word_start = len(text)-2
        while -1 < ind <= last_letter_that_could_be_word_start:
            alt = text[ind+1].lower()
            if alt not in alts: alts.append(alt)
            ind = text.find(' ',ind+1)
        for l in list(text):
            if l.lower() not in alts:
                if l in list(' (),_[]:;,.!{}/=+'): continue
                else: alts.append(l.lower())
        if filter_untouchables:
            alts = filter(lambda l: l not in self.untouchable_accels, alts)
        return alts

    def find_peaceful_alternatives (self, w):
        return filter(lambda l: not self.mnemonics.has_key(l),self.find_alternatives(w))
    
    def fix_conflicts_peacefully (self, do_submenus=True):
        """Remove all conflicts from mnemonics.

        Don't touch anything in self.sacred_cows.  if do_submenus is
        True, we will recursively resolve mnemonic conflicts within
        any sub-menus as well.
        """
        to_reconcile = []
        changed = []
        #print 'MNEMONICS: ',
        #for k,v in self.mnemonics.items():
        #    print k,[w.get_text() for w in v],
        #print
        for k,v in self.mnemonics.items():
            if len(v)>1:
                can_move = []
                for w in v:
                    if w in self.untouchable_widgs:
                        continue
                    if k in self.untouchable_accels:
                        alts = self.find_alternatives(w)
                    else:
                        alts = self.find_peaceful_alternatives(w)
                    if alts:
                        #print 'Generated alternatives for ',w,w.get_text(),':',alts
                        can_move.append((w,alts))
                if len(can_move)==len(v):
                    # If everything is movable, then we keep our first
                    # AccelLabel guy as it was and move the rest.
                    can_move.sort(self.sort_movables)
                    can_move=can_move[1:]
                # We extend our guys to move with to_move
                for w,alts in can_move:
                    #print 'Changing mnemonic',w,w.get_text(),alts[0]
                    self.change_mnemonic(w,alts[0])
                    changed.append(w)
        if changed:
            #print '>>>Recursing...'
            self.fix_conflicts_peacefully()
            #print '<<<Done recursing'
        if do_submenus:
            for mm in self.sub_managers.values():
                #print '>>>>>Submenus...'
                mm.fix_conflicts_peacefully()
                #print '<<<<<Done with submenus'
        # for each of our notebooks
        for nb in self.notebook_managers.values():
            # for each of our pages
            for pagemanager in nb.values():
                self.merge_notebook(pagemanager)
                pagemanager.fix_conflicts_peacefully()

    def merge_notebook (self, notebook_manager):
        """Add our own items to a notebook page manager as untouchables.

        In other words, the notebook's manager will know to avoid
        other widgets in the containing context, but won't touch us.
        """
        for ww in self.mnemonics.values():
            for w in ww:
                notebook_manager.add_widget_mnemonic(w,untouchable=True)

    def sort_movables (self, moveable1, moveable2):
        widg,alts = moveable1
        widg2,alts2 = moveable2
        al1 = isinstance(widg,gtk.AccelLabel)
        al2 = isinstance(widg2,gtk.AccelLabel)
        if al1 and not al2: return 1
        elif al2 and not al1: return -1
        else: return 0

    def get_all_possibilities (self):
        pass

    def change_mnemonic (self, widget, new_mnemonic):
        txt=widget.get_text()
        old = gtk.gdk.keyval_name(widget.get_mnemonic_keyval())
        if self.mnemonics.has_key(old) and widget in self.mnemonics[old]:
            self.mnemonics[old].remove(widget)
        if not self.mnemonics.has_key(new_mnemonic):
            self.mnemonics[new_mnemonic]=[]
        self.mnemonics[new_mnemonic].append(widget)
        start = 0
        index = 0
        found = txt.lower().find(new_mnemonic,start)
        while found != -1:
            index = found
            if index==0 or txt[index-1]==' ':
                break
            found = txt.lower().find(new_mnemonic,index+1)
        widget.set_text_with_mnemonic(txt[0:index] + '_' + txt[index:])
        
        
if __name__ == '__main__':
    from gourmet import gglobals
    import gtk
    import os.path
    mm=MnemonicManager()
    ui = gtk.Builder()
    ui.add_from_file(os.path.join(gglobals.uibase,'app.ui'))
    mm.add_builder(ui)
    #tree = ui.get_widget('recTree')
    #rend = gtk.CellRendererText()
    #cols = ['Cuisine','Rating','Preparation Time','Cooking Time','Title','Servings']
    #for i,l in enumerate(cols):
    #    col =  gtk.TreeViewColumn('_'+l,text=i)
    #    tree.append_column(col)
    #mod = gtk.ListStore(*[str]*(i+1))
    #for n in range(10): mod.append(cols)
    #tree.set_model(mod)
    #mm.add_treeview(tree)
    mm.fix_conflicts_peacefully()
    def show ():
        ui.get_widget('app').show()
        ui.get_widget('app').connect('delete-event',gtk.main_quit)
        gtk.main()
    show()
    

########NEW FILE########
__FILENAME__ = numberEntry
### Copyright (C) 2005 Thomas M. Hinkle
### Copyright (C) 2009 Rolf Leggewie
###
### This library is free software; you can redistribute it and/or
### modify it under the terms of the GNU General Public License as
### published by the Free Software Foundation; either version 2 of the
### License, or (at your option) any later version.
###
### This library is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
### General Public License for more details.
###
### You should have received a copy of the GNU General Public License
### along with this library; if not, write to the Free Software
### Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
### USA 


import validatingEntry
import gtk, gobject
import gourmet.convert as convert
import re
from gettext import gettext as _

class NumberEntry (validatingEntry.ValidatingEntry):
    __gtype_name__ = 'NumberEntry'

    error_message = _('Invalid input.') + ' ' + _('Not a number.')

    in_progress_regexp = """
        ^ # start at
        %(NUMBER_START_REGEXP)s+ # a number
        %(NUMBER_END_NO_RANGE_REGEXP)s*
        $ # end
        """%convert.__dict__

    def __init__ (self, default_to_fractions=False, decimals=2):
        """Decimals is the number of decimal places we set.

        Set decimals to -1 for as many as we have.
        """
        self.default_to_fractions = default_to_fractions
        self.decimals = decimals
        self.in_progress_matcher = re.compile(self.in_progress_regexp,
                                              re.VERBOSE|re.UNICODE)
        validatingEntry.ValidatingEntry.__init__(self)
        self.entry.get_value = self.get_value
        self.entry.set_value = self.get_value

    def find_errors_in_progress (self, txt):
        txt = txt.strip() # we don't care about leading/trailing space
        if not txt: return
        if not self.in_progress_matcher.match(txt):
            return self.error_message

    def find_completed_errors (self, txt):
        if txt and convert.frac_to_float(txt)==None:
            return self.error_message

    def set_value (self, n):
        if self.default_to_fractions:
            self.set_text(convert.float_to_frac(n,fractions=convert.FRACTIONS_ASCII))
        else:
            if self.decimals >= 0:
                decimals = self.decimals
                while n < 10**-decimals: decimals += 1
                format_string = "%" +"." + "%i"%decimals + "f"
                self.set_text(format_string%n)
            else:
                self.set_text("%s"%n)

    def get_value (self):
        return convert.frac_to_float(self.get_text())

class RangeEntry (NumberEntry):
    in_progress_regexp = """
        ^ # start at
        %(NUMBER_START_REGEXP)s+ # a number
        %(NUMBER_END_REGEXP)s*
        (%(RANGE_REGEXP)s|[Tt][Oo]?)?
        %(NUMBER_START_REGEXP)s*
        %(NUMBER_END_REGEXP)s*
        $ # end
        """%convert.__dict__

    def find_completed_errors (self, txt):
        split =  convert.RANGE_MATCHER.split(txt)
        if len(split)==1:
            return NumberEntry.find_completed_errors(self,txt)
        elif len(split)>2:
            return "A range can only have 2 items."
        else:
            error1 = NumberEntry.find_completed_errors(self,split[0])
            if error1: return error1
            error2 = NumberEntry.find_completed_errors(self,split[1])
            if error2: return error2

    def set_value (self, n):
        if type(n)==tuple:
            if len(n)==1:
                n = n[0]
            if len(n)>2:
                raise ValueError
            else:
                self.set_text(
                    convert.float_to_frac(n[0],
                                          fractions=convert.FRACTIONS_ASCII)\
                    +' - '+\
                    convert.float_to_frac(n[1],
                                          fractions=convert.FRACTIONS_ASCII)
                    )
                return
        NumberEntry.set_value(self,n)

    def get_value (self):
        txt = gtk.get_text()
        split = convert.RANGE_MATCHER.split(txt)
        if len(split)==1: return NumberEntry.get_value(self)
        if len(split)>2: return None
        else:
            return tuple([convert.frac_to_float(t) for t in split])

if __name__ == '__main__':
    w = gtk.Window()
    hb = gtk.HBox()
    w.connect('delete-event',lambda *args: gtk.main_quit())
    vb = gtk.VBox(); vb.show()
    l = gtk.Label('Number Entry:')
    l.show()
    hb.pack_start(l)
    ne = NumberEntry(); ne.show()
    def foo (widget):
        print 'Changed!',widget,widget.get_value()
    ne.connect('changed',foo)
    hb.pack_start(ne)
    hb.show()
    hb2 = gtk.HBox()
    l = gtk.Label('Range Entry:'); l.show()
    hb2.pack_start(l)
    rent = RangeEntry(); rent.show()
    hb2.pack_start(rent)
    hb2.show()
    vb.pack_start(hb, fill=False, expand=False)
    vb.pack_start(hb2,fill=False,expand=False)
    qb = gtk.Button(stock=gtk.STOCK_QUIT); qb.show()
    qb.connect('clicked',lambda *args: w.hide() or gtk.main_quit())
    vb.pack_start(qb, fill=False, expand=False)
    w.add(vb)
    w.present()
    gtk.main()

########NEW FILE########
__FILENAME__ = optionTable
#!/usr/bin/env python
import gtk, cb_extras, gobject

class CustomOption (gtk.HBox):

    __gsignals__ = {
        'changed':(gobject.SIGNAL_RUN_LAST,
                   gobject.TYPE_NONE,
                   []),
        }

    def __init__ (self):
        gobject.GObject.__init__(self)
        gtk.HBox.__init__(self)
        raise NotImplementedError

    def get_value (self):
        raise NotImplementedError

    def set_value (self, val):
        raise NotImplementedError

class OptionTable (gtk.Table):

    __gsignals__ = {
        'changed':(gobject.SIGNAL_RUN_LAST,
                   gobject.TYPE_NONE,
                   []),
        }
    
    def __init__ (self, options=([]), option_label=None, value_label=None,
                  changedcb=None, xpadding=5, ypadding=5):
        gobject.GObject.__init__(self)
        self.options=options
        self.defaults = options[0:]
        self.xpadding = xpadding
        self.ypadding = ypadding
        self.option_label=option_label
        self.value_label=value_label
        self.changedcb=changedcb
        cols = 2
        rows = len(self.options)
        if self.option_label or self.value_label:
            rows += 1
        gtk.Table.__init__(self, rows=rows, columns=cols)
        self.widgets = []
        self.createOptionWidgets()
        
    def createOptionWidgets (self):
        n=0
        if self.option_label:
            n=1
            lab=gtk.Label()
            lab.set_text('<span weight="bold"><u>%s</u></span>'%self.option_label)
            lab.set_use_markup(True)
            lab.set_alignment(0.0,0.5)
            lab.set_justify(gtk.JUSTIFY_LEFT)            
            self.attach(lab, 0, 1, 0, 1, xpadding=self.xpadding, ypadding=self.ypadding)
                        #xoptions=gtk.SHRINK, yoptions=gtk.SHRINK)
            lab.show()
        if self.value_label:
            n=1
            lab=gtk.Label()
            lab.set_markup('<span weight="bold"><u>%s</u></span>'%self.value_label)
            lab.set_alignment(0,0.5)
            lab.set_justify(gtk.JUSTIFY_CENTER)
            self.attach(lab, 1, 2, 0, 1, xpadding=self.xpadding, ypadding=self.ypadding,
                        xoptions=gtk.SHRINK, yoptions=gtk.SHRINK)
            lab.show()
        for l,v in self.options:
            if isinstance(v,CustomOption):
                w = v
                self.widgets.append([v,'get_value','set_value'])
                v.connect('changed',lambda * args: self.emit('changed'))
            elif type(v)==type(True):
                w=gtk.CheckButton()
                w.set_active(v)
                # widgets contains the widget, the get method and the set method
                self.widgets.append([w,'get_active','set_active'])
                w.connect('toggled',lambda *args: self.emit('changed'))
                if self.changedcb:
                    w.connect('toggled',self.changedcb)
            elif type(v)==type(""):
                w=gtk.Entry()
                w.set_text(v)
                self.widgets.append([w, 'get_text', 'set_text'])
                w.connect('changed',lambda *args: self.emit('changed'))
                if self.changedcb:
                    w.connect('changed',self.changedcb)
            elif type(v)==type(1) or type(v)==type(float(1)):
                adj = gtk.Adjustment(value=0, lower=0, upper=100*(v or 1), step_incr=(v or 1)*0.1, page_incr=(v or 1)*0.5)
                if type(v)==type(1):
                    # if an integer...
                    w=gtk.SpinButton(adj, digits=0)
                    self.widgets.append([w,'get_value_as_int','set_value'])
                else:
                    w=gtk.SpinButton(adj, digits=2)
                    self.widgets.append([w,'get_value','set_value'])
                w.set_value(v)
                w.connect('changed',lambda *args: self.emit('changed'))
                if self.changedcb:
                    w.connect('changed',self.changedcb)
            elif type(v) in (list,tuple):
                default,value_list = v
                w = gtk.combo_box_new_text()
                for itm in value_list:
                    w.append_text(itm)
                cb_extras.cb_set_active_text(w,default)
                cb_extras.setup_typeahead(w)
                self.widgets.append([w,'get_active_text',cb_extras.cb_set_active_text])
                w.connect('changed',lambda *args: self.emit('changed'))
                if self.changedcb: w.connect('changed',self.changedcb)
            else:
                raise Exception("I don't know what to do with a value of type %s (%s)" % (type(v),v))
            # attach out label and our widget
            lab = gtk.Label()
            lab.set_text_with_mnemonic(l)
            lab.set_mnemonic_widget(w)
            lab.set_justify(gtk.JUSTIFY_LEFT)
            lab.set_alignment(0,0)
            self.attach(lab, 0, 1, n, n+1, xpadding=self.xpadding, ypadding=self.ypadding,
                        xoptions=gtk.FILL,yoptions=gtk.SHRINK)
            lab.show()
            self.attach(w, 1, 2, n, n+1, xpadding=self.xpadding, ypadding=self.ypadding,
                        xoptions=gtk.FILL,yoptions=gtk.SHRINK)
            w.show()
            n += 1
            
    def set_option (self, n, val):
        widget,get_method,set_method=self.widgets[n]
        self.options[n][1]=val
        if type(set_method)==str:
            getattr(widget,set_method)(val)
        else:
            set_method(widget,val)
        
    def revert (self):
        for n in range(len(self.options)):
            default_val=self.default_options[n][1]
            self.set_option(n,default_val)

    def apply (self):
        for n in range(len(self.options)):
            widget,get_method,set_method=self.widgets[n]
            self.options[n][1]=getattr(widget,get_method)()

if __name__ == '__main__':
    w=gtk.Window()
    ot=OptionTable(options=(["_Toggle Option",True],
                            ["_String Option","Hello"],
                            ["_Integer Option",1],
                            ["_Float Option",float(3)],
                            ["_List Option",("C",["A","B","C","D"])],
                             ),
                   option_label="Option",
                   value_label="Value")
    w.add(ot)
    ot.show()
    w.show()
    w.connect('delete_event',gtk.main_quit)
    gtk.main()
    

########NEW FILE########
__FILENAME__ = pageable_store
import gtk, gobject

class PageableListStore (gtk.ListStore):
    """A ListStore designed to show bits of data at a time.

    We show chunks of data from our parent list in pages of a set size.

    parent_args and parent_kwargs get handed to setup_parent.

    It shouldn't be too hard to expand this to support TreeStores as well.
    """

    page = 0

    # convenient constants for sorting
    OFF = None
    FORWARD = gtk.SORT_ASCENDING
    REVERSE = gtk.SORT_DESCENDING

    __gsignals__ = {
        'page-changed':(gobject.SIGNAL_RUN_LAST,
                        gobject.TYPE_NONE, #RETURN
                        () # PARAMS
                        ),
        }
    
    def __init__ (self, types, parent_args=[], parent_kwargs={}, per_page=15):
        """
        types is handed to ListStore.__init__ and should be a list of
        types our treestore holds

        parent_args gets handed to setup_parent. In our simple self,
        this is a list of rows to be initiated.

        parent_kwargs are keyword arguments for setup_parent. In our
        simple self, this is unused.

        per_page is the default number of items we show at a time.
        """
        #gtk.ListStore.__init__(self,*types)
        self.__gobject_init__()
        gtk.ListStore.__init__(self, *types)
        self.per_page = per_page
        self._setup_parent_(*parent_args,**parent_kwargs)
        #self.grab_items()
        # a dictionary for tracking our sorting
        self.sort_dict = {}
        self.update_tree()

    def _setup_parent_ (self, *args, **kwargs):
        """By default, all we do is take parent_args as a list of rows to add."""
        self.parent_list = list(args)
        self.unsorted_parent = self.parent_list[0:]

    def _get_length_ (self):
        """Get the length of our full set of data."""
        return len(self.parent_list)

    def _get_slice_ (self,bottom,top):
        """Return a slice of our parent list from bottom to top"""
        return self.parent_list[bottom:top]

    def _get_item_ (self,indx):
        """Return an item for indx.

        By default, we use _get_slice_ to do this. This is somewhat
        counterintuitive, but allows subclasses to only bother writing
        a _get_slice_ method. they can implement the _get_item_ method
        if there is a reason to.
        """
        return self._get_slice_(indx,indx+1)[0]

    def showing (self):
        """Return information about the items we are currently showing.

        We return (bottom,top,total)
        """
        # Don't show an empty page -- if we find ourselves with no
        # recipes, back up a page automatically.
        if len(self)==0 and self.page!=0:
            self.goto_last_page()
        bottom = self.page*self.per_page + 1
        top = self.page*self.per_page+len(self)
        total = self._get_length_()
        return int(bottom),int(top),int(total)

    def set_page (self, n):
        """Set page to n and update our view accordingly"""
        self.page = n
        self.update_tree()
        self.emit('page-changed')
        
    def goto_first_page (self):
        if self.page!=0: self.set_page(0)

    def goto_last_page (self):
        last_page = self.get_last_page()
        if self.page != last_page:
            self.set_page(last_page)
    
    def next_page (self): 
        if (self.page+1)*self.per_page < self._get_length_():
            self.set_page(self.page + 1)
            
    def prev_page (self):
        if self.page > 0: self.set_page(self.page - 1)

    def get_last_page (self):
        """Return the number of our last page."""
        nrecs = int(self._get_length_())
        self.per_page = int(self.per_page)#just in case
        pages = (nrecs / self.per_page) - 1
        if nrecs % self.per_page: pages+=1
        return pages

    def change_items_per_page (self, n):
        current_indx = self.per_page * self.page
        self.per_page = n
        new_page = current_indx / self.per_page
        self.page = new_page
        self.update_tree()
        self.emit('page-changed')

    def update_iter (self, itr):
        """Update an iter so it reflects our background.

        itr can be a treeiter or a path"""
        # This will only work with ListStores -- if we update to
        # accomodate TreeStores, this is one of the things that must
        # change
        if type(itr)==tuple:
            path = itr
            itr=self.get_iter(path)
        else:
            path = self.get_path(itr)
        indx = path[0] + (self.page * self.per_page)
        # set takes column number, column value, column number, column value, etc.
        args = []
        for num_and_col in enumerate(self._get_item_(indx)): args.extend(num_and_col)
        self.set(itr,*args)
        

    def update_tree (self):
        """Update our tree based on current page, etc."""
        # clear the existing rows...
        for n in range(len(self)):
            self.remove(self.get_iter(0,))
        # and add the new ones...
        length = self._get_length_()
        start_at = self.page * self.per_page
        end_at = (self.page+1) * self.per_page
        if start_at > length: return # we're empty then...
        if end_at > length: end_at = length
        for row in self._get_slice_(int(start_at),int(end_at)):
            try: self.append(row)
            except TypeError:
                print 'columns          : ',self.columns
                print 'problem adding row ',row
                raise
            except ValueError:
                print 'columns          : ',self.columns
                print 'problem adding row ',row
                raise
    # Sorting functions

    def sort (self, column, direction=FORWARD):
        """Add new sort term in direction.

        Note -- to remove term we use direction=OFF
        """

        self.sort_dict[column]=direction
        if direction==self.OFF:
            self.parent_list = self.unsorted_parent
            return
        if direction==self.FORWARD: shift_by = 1
        elif direction==self.REVERSE: shift_by = -1
        self.parent_list.sort(lambda r1,r2: ((r1[column]>r2[column] and 1*shift_by) or
                                             (r1[column]<r2[column] and -1*shift_by) or
                                             0)
                              )
        self.update_tree()

    def toggle_sort (self, column):
        """Toggle sorting by column.

        We cycle through three positions: forward, backward, None,
        which is what standard gtk.TreeSort does as well!

        Return the direction we've toggled to (this allows our caller
        to be able to update the UI without having to know beforehand
        which direction the sort will end up in).
        """
        current = self.sort_dict.get(column,self.OFF)
        if current==self.OFF:
            toggle_to = self.FORWARD
        elif current==self.FORWARD:
            toggle_to = self.REVERSE
        else:
            toggle_to = self.OFF
        self.sort(column,toggle_to)
        return toggle_to

class PageableTreeStore (gtk.TreeStore, PageableListStore):
    """A TreeStore designed to show bits of data at a time.

    We show chunks of data from our parent in pages of a set size.

    Subclasses need to implement a setup_parent() method which can
    take args and kwargs.
    """

    __gsignals__ = {
        'page-changed':(gobject.SIGNAL_RUN_LAST,
                        gobject.TYPE_NONE, #RETURN
                        () # PARAMS
                        ),
        }

    page = 0

    # convenient constants for sorting
    OFF = None
    FORWARD = gtk.SORT_ASCENDING
    REVERSE = gtk.SORT_DESCENDING

    def __init__ (self, types, parent_args=[], parent_kwargs={}, per_page=15):
        """
        types is handed to TreeStore.__init__ and should be a list of
        types our treestore holds

        parent_args gets handed to setup_parent. In our simple self,
        this is a list of rows to be initiated.

        parent_kwargs are keyword arguments for _setup_parent_. In our
        simple self, this is unused.

        per_page is the default number of items we show at a time.

        We include all children by default -- subclasses can override
        update_tree to get fancier.
        """
        self.__gobject_init__()
        gtk.TreeStore.__init__(self, *types)        
        self.per_page = per_page
        self._setup_parent_(*parent_args,**parent_kwargs)
        self.update_tree()
        self.sort_dict = {}

    def update_tree (self):
        """Update our tree based on current page, etc."""
        # clear the existing rows...
        for n in range(len(self)):
            self.remove(self.get_iter(0,))
        # and add the new ones...
        length = self._get_length_()
        start_at = self.page * self.per_page
        end_at = (self.page+1) * self.per_page
        if start_at > length: return # we're empty then...
        if end_at > length: end_at = length
        for row in self._get_slice_(int(start_at),int(end_at)):
            itr=self.append(None,row)
            self.append_descendants(itr)
        self.emit('page-changed')

    def append_descendants (self, itr):
        for child in self._get_children_(itr):
            child_itr=self.append(itr,child)
            self.append_descendants(child_itr)

    def _get_children_ (self, itr):
        return []
    
class ColumnSortSetterUpper:
    """Make tree-column setting up easy for our custom models.

    Namely, sorting will simply involve

    cssu=ColumnSortSetterUpper(treemodel)
    cssu.setup_column_sort(tree_view_column,n)

    where n is the model column sorted on and tree_view_column is the
    column.

    This is necessary because sorting is a PITA with Custom models. 
    """
    def __init__ (self, treemod):
        self.mod = treemod

    def set_sort_column_id (self, tree_column, model_column):
        """Replace the built-in tree_column method with magic."""
        #tree_column.set_sort_column_id(model_column)
        tree_column.connect('clicked',self.sort_by_column_callback,model_column)
                                 
    def sort_by_column_callback (self,tree_column,model_column):
        toggle_to = self.mod.toggle_sort(model_column)
        if toggle_to==None:
            tree_column.set_sort_indicator(False)
        else:
            tree_column.set_sort_indicator(True)
            tree_column.set_sort_order(toggle_to)
        # stop propagation... (?)
        return True

class PageableViewStore (PageableListStore):

    __gsignals__ = {
        'view-changed':(gobject.SIGNAL_RUN_LAST,
                         gobject.TYPE_NONE,
                         ()
                         ),
        'view-sort':(gobject.SIGNAL_RUN_LAST,
                     gobject.TYPE_PYOBJECT,
                     (gobject.TYPE_PYOBJECT,)
                     ),
        }

    def __init__ (self, view, columns=['foo','bar'],column_types=[int,str],per_page=15,
                  length=None
                  ):
        self.__sorts__ = []
        self.__length__ = length
        PageableListStore.__init__(self,column_types, parent_args=[view],parent_kwargs={'columns':columns},
                                   per_page=per_page)

    def _setup_parent_ (self, view, columns=[]):
        self.parent_list = self.view = view
        self.unsorted_parent = self.unsorted_view = self.view
        self.columns = columns

    def _get_slice_ (self,bottom,top):
        return [[getattr(r,col) for col in self.columns] for r in self.view[bottom:top]]

    def _get_length_ (self):
        if self.__length__: return self.__length__
        else: return PageableListStore._get_length_(self)

    def sort (self, col, direction):
        attr = self.columns[col]
        self.sort_dict[col]=direction
        # Remove previous sorts by this attribute
        if (attr,-1) in self.__sorts__: self.__sorts__.remove((attr,-1))
        elif (attr, 1) in self.__sorts__: self.__sorts__.remove((attr,1))
        if direction==self.FORWARD:
            #self.__sorts__ = [(attr,1)] + self.__sorts__
            self.__sorts__.append((attr,1))
        elif direction==self.REVERSE:
            #self.__sorts__ = [(attr,-1)] + self.__sorts__
            self.__sorts__.append((attr,-1))
        self.emit('view-sort',self.__sorts__)

    #def _do_sort_ (self):
    #    if self.__all_sorts__:
    #        self.do_change_view(self.view.sortrev([getattr(self.view,a) for a in self.__all_sorts__],
    #                                              [getattr(self.view,a) for a in self.__reverse_sorts__])
    #                            )
    #    else:
    #        self.do_change_view(self.unsorted_view)

    def do_change_view (self, vw, length=None):
        self.parent_list = self.view = vw
        self.__length__ = None
        self.update_tree()
        self.emit('view-changed')

    def change_view (self, vw, length=None):
        self.do_change_view(vw,length=length)
        # Don't change the page anymore... it screws up a lot of
        # things... if we want to change the page during a search for
        # "usability", then we should do this from higher up so we can
        # have more fine-grained control of when it happens. 
        # if self.page != 0:
        #     self.page = 0
        #     self.emit('page-changed')

if __name__ == '__main__':
    pts=PageableTreeStore([str,str],parent_args=[[str(n),str(30-n)] for n in range(30)])
    #for n in range(30): pts.append(None,[str(n),str(n)])
    cssu = ColumnSortSetterUpper(pts)
    tv=gtk.TreeView()
    renderer = gtk.CellRendererText()
    tvc=gtk.TreeViewColumn('first',renderer,text=0)
    cssu.set_sort_column_id(tvc,0)
    tv.append_column(tvc)
    tvc2=gtk.TreeViewColumn('first',renderer,text=1)
    cssu.set_sort_column_id(tvc2,1)    
    tv.append_column(tvc2)
    tv.set_model(pts)
    sw = gtk.ScrolledWindow()
    sw.add(tv)
    vb = gtk.VBox()
    w = gtk.Window()
    w.add(vb)
    vb.add(sw)

    # add buttons
    b=gtk.Button('next page')
    def nxt ():
        #tv.set_model(None)
        pts.next_page()
        #tv.set_model(pts)
    def prv ():
        pts.prev_page()
    b.connect('clicked',lambda *args: nxt())
    vb.pack_start(b,False)
    pb = gtk.Button('prev')
    pb.connect('clicked',lambda *args: prv())
    vb.pack_start(pb,False)

    
    w.show_all()
    w.connect('delete-event',lambda *args: gtk.main_quit())
    gtk.main()
    

########NEW FILE########
__FILENAME__ = ratingWidget
import gtk, gtk.gdk
import gobject
import gourmet.gglobals as gglobals
import os.path
from gettext import gettext as _
import tempfile

try:
    from PIL import Image
except ImportError:
    import Image

PLUS_ONE_KEYS = ['plus',
                 'greater',
                 #'Up',
                 #'Right',
                 ]
MINUS_ONE_KEYS = ['minus',
                  'less',
                  #'Down',
                  #'Left'
                  ]
PLUS_MAX_KEYS = ['Page_Up']
MINUS_MAX_KEYS = ['Page_Down']
ACTIVATE_KEYS = ['space']

# An implement a star box for rating something (as in 1 to 5 stars) a
# la rhythmbox


# StarGenerator handles efficient creation/fetching of Pixbufs for various
# numbers of stars

class StarGenerator:

    """A convenient class that will give us a gtk.Pixbuf representing stars
    for any number.

    set_image and unset_image must have the same width!""" 

    def __init__ (self,
                    set_image=os.path.join(gglobals.imagedir,'gold_star.png'),
                    unset_image=os.path.join(gglobals.imagedir,'no_star.png'),
                    half_image=os.path.join(gglobals.imagedir,'half_gold_star.png'),
                    #background=(0,0,0,0),
                    background=0,
                    size=None,
                    ):
        self.set_img   = Image.open(set_image)
        if size:
            self.set_img = self.set_img.resize(size)
        self.unset_img = Image.open(unset_image).resize(self.set_img.size)
        self.halfset_img = Image.open(half_image).resize(self.set_img.size)
        #convert to RGBA self.set_img = self.set_img.convert('RGBA')
        self.set_img = self.set_img.convert('RGBA')
        self.unset_img = self.unset_img.convert('RGBA')
        self.halfset_img = self.halfset_img.convert('RGBA')
        self.width,self.height = self.set_img.size
        self.set_region = self.set_img.crop((0,0,
                                             self.width,
                                             self.height))
        self.unset_region = self.unset_img.crop((0,0,
                                             self.width,
                                             self.height))
        self.halfset_region = self.halfset_img.crop((0,0,
                                                     self.width,
                                                     self.height))
        self.background = background
        self.pixbufs = {}
        self.image_files = {}

    def get_pixbuf (self,n,max=10):

        """Return a pixbuf with an image representing n/max stars"""

        if self.pixbufs.has_key((n,max)):
            return self.pixbufs[(n,max)]
        else:
            img = self.build_image(n,max)
            pb=self.get_pixbuf_from_image(img)
            self.pixbufs[(n,max)]=pb
            return pb

    def get_full_width (self, max=10):
        return self.width*max/2

    def get_image (self, *args, **kwargs):
        """Get an Image (PIL) object representing n/max stars
        """
        # Just an alias for semantic clarity...
        return self.build_image(*args,**kwargs)

    def get_file (self, n, max=10, ext='.jpg'):
        if (self.image_files.has_key((n,max,ext))
            and
            os.path.exists(self.image_files[(n,max,ext)])
            ):
            return self.image_files[(n,max,ext)]
        fi = tempfile.mktemp("%s_of_%s.%s"%(n,max,ext))
        i = self.get_image(n,max)
        i = i.convert('RGB')
        i.save(fi)
        self.image_files[(n,max,ext)]=fi
        return fi
        
    def build_image (self, n, max=10):
        """Build an image representing n/max stars."""
        img=Image.new('RGBA',
                      (self.get_full_width(max),
                       self.height),
                      self.background)
        for i in range(0,(max/2)):
            if i*2+2 <= n:
                to_paste = self.set_region
            elif (i*2)+1 <= n:
                to_paste = self.halfset_region
            else:
                to_paste = self.unset_region
            xbase = self.width*i
            img.paste(to_paste,
                (xbase,
                 0,
                 xbase+self.width,
                 self.height))
        return img

    def get_pixbuf_from_image (self, image, make_white_opaque=True):

        """Get a pixbuf from a PIL Image.

        By default, turn all white pixels transparent.
        """

        is_rgba = image.mode=='RGBA'
        if is_rgba: rowstride = 4
        else: rowstride = 3
        pb=gtk.gdk.pixbuf_new_from_data(
            image.tostring(),
            gtk.gdk.COLORSPACE_RGB,
            is_rgba,
            8,
            image.size[0],
            image.size[1],
            (is_rgba and 4 or 3) * image.size[0] #rowstride
            )
        return pb
    
star_generator = StarGenerator()

# StarImage is a class that allows easy setting of an image from a value.

class StarImage (gtk.Image):
    __gtype_name__ = 'StarImage'

    def __init__ (self,
                  star_gen=star_generator,
                  value=0,
                  upper=10):
        """Create an Image widget with value/upper stars filled in.

        star_gen is an instance of the StarGenerator class which will do
        the work of creating the Pixbufs with the star images.

        The number can be changed via the get_value and set_value methods.

        If you want the user to be able to change the number of stars,
        use a StarButton.
        """
        gtk.Image.__init__(self)
        self.stars = star_gen
        self.upper = upper
        self.set_value(value)
        
    def set_value (self, value):

        """Set value. Silently floor value at 0 and cap it at self.upper"""

        if value > self.upper: value = self.upper
        if value < 0: value = 0
        self.set_from_pixbuf(
            self.stars.get_pixbuf(value,self.upper)
            )
        self.value=value

    def get_value (self): return self.value
        
    def set_upper (self, value):
        """Change the upper number of stars allowed.

        Update our image accordingly."""
        self.upper = upper
        self.set_value(self.value)

    def set_text (self, value): self.set_value(int(value))
    def get_text (self): return "%s"%self.get_value()
        
# Next is a Button type class that allows the user to set the value
# via the mouse or the keyboard

class StarButton (gtk.Button):
    __gtype_name__ = 'StarButton'

    """A StarButton, to allow the user to select a number using icons.

    'Stars' are one of the normal elements to select. So that a user
    could rate on a scale of one-to-four stars.
    """

    __custom_handler_names__ = ['changed']
    _custom_handlers_ = {}

    def __init__ (self,
                  star_gen=star_generator,
                  start_value = 0,
                  upper=10,
                  ):
        """Initiate a StarButton.

        star_gen is an instance of the StarGenerator class which will
        generate our actual images of stars or whatever else.

        Upper is the upper number of 'stars' the user can select.

        start_value is our initial value.

        if interactive is True, we will catch click and keyboard
        events and allow the user to change the value using the
        keyboard.

        """
        self.__gobject_init__()
        self.add_events(gtk.gdk.KEY_PRESS_MASK)
        self.add_events(gtk.gdk.BUTTON_PRESS_MASK)
        self.connect('button-press-event',
                     self.buttonpress_cb)
        self.connect('key-press-event',
                     self.keypress_cb)
        #self.connect('activate',
        #             self.activate_cb)
        self.connect('mnemonic-activate',
                     self.activate_cb)
        self.image = StarImage(star_gen, value=start_value, upper=upper)
        self.add(self.image)
        self.image.show()
        # set up convenience methods        
        self.get_value = self.image.get_value
        self.set_upper = self.image.set_upper

    def set_value (self, value):
        self.image.set_value(value)
        if self._custom_handlers_.has_key('changed'):
            for h in self._custom_handlers_['changed']:
                if h(self): break
        return True

    def set_text (self, value): self.set_value(int(value))
    def get_text (self): return "%s"%self.get_value()

    def connect (self, name, handler):
        """We do something very very bad."""
        if name in self.__custom_handler_names__:
            if self._custom_handlers_.has_key(name):
                self._custom_handlers_[name].append(handler)
            else:
                self._custom_handlers_[name]=[handler]
        else:
            gtk.Button.connect(self,name,handler)

    def activate_cb (self, *args):
        self.grab_focus()
        return True

    def buttonpress_cb (self, widget, event):
        x,y = event.get_coords()
        wx,wy = self.image.translate_coordinates(self.image,int(x),int(y))
        self.star_width =  self.image.get_pixbuf().get_width() / self.image.upper
        star = x / self.star_width + 1
        star = int(star)
        if self.image.value >= star:
            # if we're clicking on a set icon, we want it to go away
            self.set_value(star-1)
        else:
            # otherwise we want it to be filled            
            self.set_value(star)
        return True
        
    def keypress_cb (self, widget, event):
        name=gtk.gdk.keyval_name(event.keyval)
        if name in PLUS_ONE_KEYS:
            self.set_value(self.image.value+1)
            return True
        elif name in MINUS_ONE_KEYS:
            self.set_value(self.image.value-1)
            return True
        elif name in PLUS_MAX_KEYS:
            self.set_value(self.image.upper)
            return True
        elif name in MINUS_MAX_KEYS:
            self.set_value(0)
            return True
        elif name in ACTIVATE_KEYS:
            return True
        elif name in [str(x) for x in range(self.image.upper/2 + 1)]:
            self.set_value(int(name)*2)
            return True


class TreeWithStarMaker:
    """A class to automatically handle stars in trees.

    This is a little backasswards to be honest, but it's better than repeating
    code oodles of times.

    We implement our own "signal" handling of a sort, allowing users to connect
    to a change in value by calling connect_change_handler(handler).

    Handlers will take arguments like this and should return True to
    prevent us from setting the star value. (They will also prevent
    other handlers from doing their thing, as happens elsewhere in the
    gtk world).

    def handler (value, model, treeiter, colnum):
        '''This handler will just set the value in our model.
        Presumably you want to do something more with the data
        '''
        model.set_value(treeiter,colnum,value)
    """
    def __init__ (self,
                  tree,
                  star_generator,
                  col_title=_("Rating"),
                  col_position=-1,
                  data_col=0,
                  handlers=[],
                  upper=10,
                  editable=True,
                  properties={}
                  ):
        self.tree=tree
        self.star_generator=star_generator
        self.col_title=col_title
        self.col_position=col_position
        self.data_col=data_col
        self.handlers = handlers
        self.upper = upper
        self.editable=editable
        self.properties = properties
        # setup our column
        self.setup_column()
        self.setup_callbacks()
        
    def connect_change_handler (self, handler): self.handlers.append(handler)

    def call_handlers (self, *params):
        for handler in self.handlers:
            if handler(*params): break

    def setup_column (self):
        self.cellrenderer = gtk.CellRendererPixbuf()        
        tot_cols=self.tree.insert_column_with_data_func(
            self.col_position,
            self.col_title,
            self.cellrenderer,
            self.cell_data_func)
        if self.col_position == -1:
            self.col_position = tot_cols-1
        if self.editable:
            self.cellrenderer.set_property('mode',gtk.CELL_RENDERER_MODE_EDITABLE)
        self.cellrenderer.set_property('xalign',0)
        col=self.tree.get_column(self.col_position)
        col.set_sort_column_id(self.data_col)
        for p,v in self.properties.items():
            col.set_property(p,v)
        self.col = col        

    def setup_callbacks (self):
        self.tree.connect('button-press-event',self.tree_click_callback)
        self.tree.connect('key-press-event',self.tree_keypress_callback)

    def cell_data_func (self, tree_column, cell, model, tree_iter):
        """Populate our cell with a pixbuf based on an integer"""
        val = model.get_value(tree_iter,self.data_col)
        pb = self.star_generator.get_pixbuf(int(val),self.upper)
        cell.set_property('pixbuf',pb)

    def tree_click_callback (self, tv, event):
        x = int(event.x)
        y = int(event.y)
        try:
            path, col, cellx, celly = tv.get_path_at_pos(x,y)
        except:
            return
        if col.get_property('title')==self.col_title:
            # If we're changing rows, we assume our user doesn't want to
            # click this button yet. This may be bad behavior, but it seems
            # reasonable for the time being.
            if hasattr(self,'curpath') and path == self.curpath:
                mod=tv.get_model()
                itr=mod.get_iter(path)
                curval=mod.get_value(itr,0)
                self.star_width = self.cellrenderer.get_property('pixbuf').get_width()/self.upper
                starval = cellx / self.star_width + 1
                curval = mod.get_value(itr,self.data_col)
                if starval > curval:
                    self.call_handlers(starval, mod, itr, self.data_col)
                    #mod.set_value(itr,self.col_position,starval)
                else:
                    self.call_handlers(starval-1, mod, itr, self.data_col)
                    #mod.set_value(itr,self.col_position,starval-1)
            self.curpath = path

    def tree_keypress_callback (self, tv, event):
        path,col = tv.get_cursor()
        if not col: return
        if not path: return
        if col.get_property('title') == self.col_title:
            # go ahead and edit...
            name=gtk.gdk.keyval_name(event.keyval)
            mod = tv.get_model()
            itr = mod.get_iter(path)
            curval = mod.get_value(itr,self.data_col)
            if name in MINUS_ONE_KEYS:
                #mod.set_value(itr,self.col_position,curval - 1)
                self.call_handlers(curval - 1, mod, itr, self.data_col)
                return True
            if name in PLUS_ONE_KEYS:
                #mod.set_value(itr,self.col_position,curval + 1)
                self.call_handlers(curval + 1, mod, itr, self.data_col)
                return True
            elif name in [str(x) for x in range(self.upper/2 + 1)]:
                #mod.set_value(itr,self.col_position,int(name))
                self.call_handlers(int(name)*2, mod, itr, self.data_col)
                return True
        
    
# Next is a proof of concept making this work in a TreeView

class Tree(gtk.TreeView):
    def __init__(self,stars):
        self.stars = stars
        self.upper = 10
        self.store = gtk.ListStore(gobject.TYPE_STRING,
                                   gobject.TYPE_INT)
        for i in range(10):
            for n in range(6):
                self.store.append(['Test %s%s'%(i,n),n])
        gtk.TreeView.__init__(self)
        self.set_size_request(300, 200)
        self.set_model(self.store)
        self.set_headers_visible(True)
        rend = gtk.CellRendererText()
        column = gtk.TreeViewColumn('First', rend, text=0)
        column.set_sort_column_id(0)
        self.append_column(column)
        TreeWithStarMaker(self, self.stars, data_col=1, handlers=[self.rating_change_handler])
        column = gtk.TreeViewColumn('Second', rend, )
        self.append_column(column)

    def rating_change_handler (self, value, model, treeiter, colnum):
        model.set_value(treeiter,colnum,value)
        
if __name__ == '__main__':
    vb = gtk.VBox()
    s = StarGenerator()
    for i in range(10):
        hb = gtk.HBox()
        hb.pack_start(StarButton(s,start_value=i),fill=False,expand=False)
        vb.add(hb)
    w=gtk.Window()
    w.add(vb)
    b = gtk.Button(stock=gtk.STOCK_QUIT)
    b.connect('clicked',lambda *args: w.hide() or gtk.main_quit())
    vb.add(b)
    t = Tree(s)
    vb.add(t)
    vb.show_all()
    w.connect('delete-event',lambda *args: w.hide() or gtk.main_quit())
    w.show_all()
    gtk.main()
        
            
    

########NEW FILE########
__FILENAME__ = TextBufferMarkup
### Copyright (C) 2005 Thomas M. Hinkle
### Copyright (C) 2009 Rolf Leggewie
###
### This library is free software; you can redistribute it and/or
### modify it under the terms of the GNU General Public License as
### published by the Free Software Foundation; either version 2 of the
### License, or (at your option) any later version.
###
### This library is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
### General Public License for more details.
###
### You should have received a copy of the GNU General Public License
### along with this library; if not, write to the Free Software
### Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
### USA 

import pango,gtk, xml.sax.saxutils
from gourmet.gdebug import debug

class PangoBuffer (gtk.TextBuffer):
    desc_to_attr_table = {
        'family':[pango.AttrFamily,""],
        'style':[pango.AttrStyle,pango.STYLE_NORMAL],        
        'variant':[pango.AttrVariant,pango.VARIANT_NORMAL],
        'weight':[pango.AttrWeight,pango.WEIGHT_NORMAL],
        'stretch':[pango.AttrStretch,pango.STRETCH_NORMAL],
        }
    pango_translation_properties={
            # pango ATTR TYPE : (pango attr property / tag property)
            pango.ATTR_SIZE : 'size',
            pango.ATTR_WEIGHT: 'weight',
            pango.ATTR_UNDERLINE: 'underline',
            pango.ATTR_STRETCH: 'stretch',
            pango.ATTR_VARIANT: 'variant',
            pango.ATTR_STYLE: 'style',
            pango.ATTR_SCALE: 'scale',
            pango.ATTR_STRIKETHROUGH: 'strikethrough',
            pango.ATTR_RISE: 'rise',
            }
    attval_to_markup={
            'underline':{pango.UNDERLINE_SINGLE:'single',
                         pango.UNDERLINE_DOUBLE:'double',
                         pango.UNDERLINE_LOW:'low',
                         pango.UNDERLINE_NONE:'none'},
            'stretch':{pango.STRETCH_ULTRA_EXPANDED:'ultraexpanded',
                       pango.STRETCH_EXPANDED:'expanded',
                       pango.STRETCH_EXTRA_EXPANDED:'extraexpanded',
                       pango.STRETCH_EXTRA_CONDENSED:'extracondensed',
                       pango.STRETCH_ULTRA_CONDENSED:'ultracondensed',                                              
                       pango.STRETCH_CONDENSED:'condensed',
                       pango.STRETCH_NORMAL:'normal',
                       },
            'variant':{pango.VARIANT_NORMAL:'normal',
                       pango.VARIANT_SMALL_CAPS:'smallcaps',
                       },
            'style':{pango.STYLE_NORMAL:'normal',
                     pango.STYLE_OBLIQUE:'oblique',
                     pango.STYLE_ITALIC:'italic',
                     },
            'stikethrough':{1:'true',
                            True:'true',
                            0:'false',
                            False:'false'},
            }
    def __init__ (self):
        self.tagdict = {}
        self.tags = {}
        #self.buf = buf
        #self.set_text(txt)
        gtk.TextBuffer.__init__(self)

    def set_text (self, txt):
        gtk.TextBuffer.set_text(self,"")
        try:
            self.parsed,self.txt,self.separator = pango.parse_markup(txt,u'\x00')
        except:
            print 'Problem encountered escaping text: "%s"'%txt
            import traceback; traceback.print_exc()
            txt=xml.sax.saxutils.escape(txt)
            self.parsed,self.txt,self.separator = pango.parse_markup(txt,u'\x00')
        self.attrIter = self.parsed.get_iterator()
        self.add_iter_to_buffer()        
        while self.attrIter.next():
            self.add_iter_to_buffer()

    def add_iter_to_buffer (self):
        range=self.attrIter.range()
        font,lang,attrs = self.attrIter.get_font()
        tags = self.get_tags_from_attrs(font,lang,attrs)
        text = self.txt[range[0]:range[1]]        
        if tags: self.insert_with_tags(self.get_end_iter(),text,*tags)
        else: self.insert_with_tags(self.get_end_iter(),text)
        
    def get_tags_from_attrs (self, font,lang,attrs):
        tags = []
        if font:            
            font,fontattrs = self.fontdesc_to_attrs(font)
            fontdesc = font.to_string()
            if fontattrs:
                attrs.extend(fontattrs)
            if fontdesc and fontdesc!='Normal':
                if not self.tags.has_key(font.to_string()):                    
                    tag=self.create_tag()
                    tag.set_property('font-desc',font)
                    if not self.tagdict.has_key(tag): self.tagdict[tag]={}
                    self.tagdict[tag]['font_desc']=font.to_string()
                    self.tags[font.to_string()]=tag
                tags.append(self.tags[font.to_string()])
        if lang:
            if not self.tags.has_key(lang):
                tag = self.create_tag()
                tag.set_property('language',lang)
                self.tags[lang]=tag
            tags.append(self.tags[lang])
        if attrs:
            for a in attrs:
                if a.type == pango.ATTR_FOREGROUND:
                    gdkcolor = self.pango_color_to_gdk(a.color)
                    key = 'foreground%s'%self.color_to_hex(gdkcolor)
                    if not self.tags.has_key(key):
                        self.tags[key]=self.create_tag()
                        self.tags[key].set_property('foreground-gdk',gdkcolor)
                        self.tagdict[self.tags[key]]={}
                        self.tagdict[self.tags[key]]['foreground']="#%s"%self.color_to_hex(gdkcolor)
                    tags.append(self.tags[key])
                if a.type == pango.ATTR_BACKGROUND:
                    gdkcolor = self.pango_color_to_gdk(a.color)
                    key = 'background%s'%self.color_to_hex(gdkcolor)
                    if not self.tags.has_key(key):
                        self.tags[key]=self.create_tag()
                        self.tags[key].set_property('background-gdk',gdkcolor)
                        self.tagdict[self.tags[key]]={}
                        self.tagdict[self.tags[key]]['background']="#%s"%self.color_to_hex(gdkcolor)
                    tags.append(self.tags[key])
                if self.pango_translation_properties.has_key(a.type):
                    prop=self.pango_translation_properties[a.type]
                    #print 'setting property %s of %s (type: %s)'%(prop,a,a.type)
                    val=getattr(a,'value')
                    #tag.set_property(prop,val)
                    mval = val
                    if self.attval_to_markup.has_key(prop):
                        #print 'converting ',prop,' in ',val
                        if self.attval_to_markup[prop].has_key(val):
                            mval = self.attval_to_markup[prop][val]
                        else:
                            debug("hmmm, didn't know what to do with value %s"%val,0)
                    key="%s%s"%(prop,val)
                    if not self.tags.has_key(key):
                        self.tags[key]=self.create_tag()
                        self.tags[key].set_property(prop,val)
                        self.tagdict[self.tags[key]]={}
                        self.tagdict[self.tags[key]][prop]=mval
                    tags.append(self.tags[key])
                else:
                    debug("Don't know what to do with attr %s"%a,1)
        return tags
    
    def get_tags (self):
        tagdict = {}
        for pos in range(self.get_char_count()):
            iter=self.get_iter_at_offset(pos)
            for tag in iter.get_tags():
                if tagdict.has_key(tag):
                    if tagdict[tag][-1][1] == pos - 1:
                        tagdict[tag][-1] = (tagdict[tag][-1][0],pos)
                    else:
                        tagdict[tag].append((pos,pos))
                else:
                    tagdict[tag]=[(pos,pos)]
        return tagdict

    def get_text (self, start=None, end=None, include_hidden_chars=True):
        tagdict=self.get_tags()        
        if not start: start=self.get_start_iter()
        if not end: end=self.get_end_iter()
        txt = unicode(gtk.TextBuffer.get_text(self,start,end))
        cuts = {}
        for k,v in tagdict.items():
            if not self.tagdict.has_key(k): continue
            stag,etag = self.tag_to_markup(k)
            for st,e in v:
                if cuts.has_key(st): cuts[st].append(stag) #add start tags second
                else: cuts[st]=[stag]
                if cuts.has_key(e+1): cuts[e+1]=[etag]+cuts[e+1] #add end tags first
                else: cuts[e+1]=[etag]
        last_pos = 0
        outbuff = ""
        cut_indices = cuts.keys()
        cut_indices.sort()        
        soffset = start.get_offset()
        eoffset = end.get_offset()
        cut_indices = filter(lambda i: eoffset >= i >= soffset, cut_indices)
        for c in cut_indices:
            if not last_pos==c:
                outbuff += xml.sax.saxutils.escape(txt[last_pos:c])
                last_pos = c
            for tag in cuts[c]:
                outbuff += tag
        outbuff += xml.sax.saxutils.escape(txt[last_pos:])
        return outbuff

    def tag_to_markup (self, tag):
        stag = "<span"
        for k,v in self.tagdict[tag].items():
            stag += ' %s="%s"'%(k,v)
        stag += ">"
        return stag,"</span>"

    def fontdesc_to_attrs (self,font):
        nicks = font.get_set_fields().value_nicks
        attrs = []
        for n in nicks:
            if self.desc_to_attr_table.has_key(n):
                Attr,norm = self.desc_to_attr_table[n]
                # create an attribute with our current value
                attrs.append(Attr(getattr(font,'get_%s'%n)()))
                # unset our font's value
                getattr(font,'set_%s'%n)(norm)
        return font,attrs
        
    def pango_color_to_gdk (self, pc):
        return gtk.gdk.Color(pc.red,pc.green,pc.blue)

    def color_to_hex (self, color):
        hexstring = ""
        for col in 'red','green','blue':
            hexfrag = hex(getattr(color,col)/(16*16)).split("x")[1]
            if len(hexfrag)<2: hexfrag = "0" + hexfrag
            hexstring += hexfrag
        return hexstring
        
    def apply_font_and_attrs (self, font, attrs):
        tags = self.get_tags_from_attrs(font,None,attrs)
        for t in tags: self.apply_tag_to_selection(t)

    def remove_font_and_attrs (self, font, attrs):
        tags = self.get_tags_from_attrs(font,None,attrs)
        for t in tags: self.remove_tag_from_selection(t)

    def setup_default_tags (self):
        self.italics = self.get_tags_from_attrs(None,None,[pango.AttrStyle('italic')])[0]
        self.bold = self.get_tags_from_attrs(None,None,[pango.AttrWeight('bold')])[0]
        self.underline = self.get_tags_from_attrs(None,None,[pango.AttrUnderline('single')])[0]

    def get_selection (self):
        bounds = self.get_selection_bounds()
        if not bounds:
            iter=self.get_iter_at_mark(self.insert)
            if iter.inside_word():
                start_pos = iter.get_offset()
                iter.forward_word_end()
                word_end = iter.get_offset()
                iter.backward_word_start()
                word_start = iter.get_offset()
                iter.set_offset(start_pos)
                bounds = (self.get_iter_at_offset(word_start),
                          self.get_iter_at_offset(word_end+1))
            else:
                bounds = (iter,self.get_iter_at_offset(iter.get_offset()+1))
        return bounds

    def apply_tag_to_selection (self, tag):
        selection = self.get_selection()
        if selection:
            self.apply_tag(tag,*selection)

    def remove_tag_from_selection (self, tag):
        selection = self.get_selection()
        if selection:
            self.remove_tag(tag,*selection)

    def remove_all_tags (self):
        selection = self.get_selection()
        if selection:
            for t in self.tags.values():
                self.remove_tag(t,*selection)

class InteractivePangoBuffer (PangoBuffer):
    def __init__ (self, 
                  normal_button=None,
                  toggle_widget_alist=[]):
        """An interactive interface to allow marking up a gtk.TextBuffer.
        txt is initial text, with markup.
        buf is the gtk.TextBuffer
        normal_button is a widget whose clicked signal will make us normal
        toggle_widget_alist is a list that looks like this:
        [(widget, (font,attr)),
         (widget2, (font,attr))]
         """
        PangoBuffer.__init__(self)
        if normal_button: normal_button.connect('clicked',lambda *args: self.remove_all_tags())
        self.tag_widgets = {}
        self.internal_toggle = False
        self.insert = self.get_insert()
        self.connect('mark-set',self._mark_set_cb)
        self.connect('changed',self._changed_cb)        
        for w,tup in toggle_widget_alist:
            self.setup_widget(w,*tup)

    def setup_widget_from_pango (self, widg, markupstring):
        """setup widget from a pango markup string"""
        #font = pango.FontDescription(fontstring)
        a,t,s = pango.parse_markup(markupstring,u'\x00')
        ai=a.get_iterator()
        font,lang,attrs=ai.get_font()
        return self.setup_widget(widg,font,attrs)
    
    def setup_widget (self, widg, font, attr):
        tags=self.get_tags_from_attrs(font,None,attr)
        self.tag_widgets[tuple(tags)]=widg
        return widg.connect('toggled',self._toggle,tags)

    def _toggle (self, widget, tags):
        if self.internal_toggle: return
        if widget.get_active():
            for t in tags: self.apply_tag_to_selection(t)
        else:
            for t in tags: self.remove_tag_from_selection(t)

    def _mark_set_cb (self, buffer, iter, mark, *params):
        # Every time the cursor moves, update our widgets that reflect
        # the state of the text.
        if hasattr(self,'_in_mark_set') and self._in_mark_set: return
        self._in_mark_set = True
        if mark.get_name()=='insert':
            for tags,widg in self.tag_widgets.items():
                active = True
                for t in tags:
                    if not iter.has_tag(t):
                        active=False
                self.internal_toggle=True
                widg.set_active(active)
                self.internal_toggle=False
        if hasattr(self,'last_mark'):                
            self.move_mark(self.last_mark,iter)
        else:
            self.last_mark = self.create_mark('last',iter,left_gravity=True)
        self._in_mark_set = False
            
    def _changed_cb (self, tb):
        if not hasattr(self,'last_mark'): return
        # If our insertion point has a mark, we want to apply the tag
        # each time the user types...
        old_itr = self.get_iter_at_mark(self.last_mark)
        insert_itr = self.get_iter_at_mark(self.insert)
        if old_itr!=insert_itr:
            # Use the state of our widgets to determine what
            # properties to apply...
            for tags,w in self.tag_widgets.items():
                if w.get_active():
                    #print 'apply tags...',tags
                    for t in tags: self.apply_tag(t,old_itr,insert_itr)
        
                    



class SimpleEditor:
    def __init__ (self):
        self.w = gtk.Window()
        self.vb = gtk.VBox()
        self.editBox = gtk.HButtonBox()
        self.nb = gtk.Button('Normal')
        self.editBox.add(self.nb)        
        self.sw = gtk.ScrolledWindow()
        self.tv = gtk.TextView()
        self.sw.add(self.tv)
        self.ipb = InteractivePangoBuffer(
            normal_button=self.nb)
        self.ipb.set_text("""<b>This is bold</b>. <i>This is italic</i>
            <b><i>This is bold, italic, and <u>underlined!</u></i></b>
            <span background="blue">This is a test of bg color</span>
            <span foreground="blue">This is a test of fg color</span>
            <span foreground="white" background="blue">This is a test of fg and bg color</span>                        
            """)
        #    Here are some more: 1-2, 2-3, 3-4, 10-20, 30-40, 50-60
        #    This is <span color="blue">blue</span>, <span color="red">red</span> and <span color="green">green</span>""")
        #self.ipb.set_text("""This is a numerical range (three hundred and fifty to four hundred) 350-400 which may get messed up.
        #Here are some more: 1-2, 2-3, 3-4, 10-20, 30-40, 50-60""")

        self.tv.set_buffer(self.ipb)
        for lab,stock,font in [('gtk-italic',True,'<i>italic</i>'),
                               ('gtk-bold',True,'<b>bold</b>'),
                               ('gtk-underline',True,'<u>underline</u>'),
                               ('Blue',True,'<span foreground="blue">blue</span>'),
                               ('Red',False,'<span foreground="red">smallcaps</span>'),
                               ]:
            button = gtk.ToggleButton(lab)
            self.editBox.add(button)
            if stock: button.set_use_stock(True)
            self.ipb.setup_widget_from_pango(button,font)
        self.vb.add(self.editBox)
        self.vb.add(self.sw)
        self.actionBox = gtk.HButtonBox()        
        self.qb = gtk.Button(stock='quit')
        self.pmbut = gtk.Button('Print markup')
        self.pmbut.connect('clicked',self.print_markup)
        self.qb.connect('clicked',lambda *args: self.w.destroy() or gtk.main_quit())
        self.actionBox.add(self.pmbut)
        self.actionBox.add(self.qb)
        self.vb.add(self.actionBox)
        self.w.add(self.vb)
        self.w.show_all()

    def print_markup (self,*args):
        print self.ipb.get_text()
        
if __name__ == '__main__':
    se = SimpleEditor()
    se.w.connect('delete-event',lambda *args: gtk.main_quit())
    gtk.main()

########NEW FILE########
__FILENAME__ = thumbnail
import urllib, hashlib, os.path, os, StringIO
from gourmet.gdebug import debug
try:
    from PIL import Image
except ImportError:
    import Image

MAX_THUMBSIZE=10000000

# Keep track of uris we fetch...
fetched_uris = {}

def check_for_thumbnail (uri, type="large",reporthook=None):
    """Given a URI, return a file with a thumbnail of the image, or
    None if no thumbnail can be made."""
    if not uri:
        return ""
    m = hashlib.md5(uri)
    name= os.path.join("~",".thumbnails",type,m.hexdigest() + ".png")    
    name = os.path.expanduser(name)
    targetdir = os.path.split(name)[0]
    if not os.path.exists(targetdir):
        os.makedirs(targetdir)
    if not os.path.isdir(targetdir):
        import tempfile
        name = tempfile.mktemp()
    if fetched_uris.has_key(uri) and os.path.exists(fetched_uris[uri]):
        fn = fetched_uris[uri]
    else:
        try:
            fn,headers = urllib.urlretrieve(uri,reporthook=reporthook)
            fetched_uris[uri]=fn
        except UnicodeError:
            try:
                fn,headers = urllib.urlretrieve(urllib.quote(uri),reporthook=reporthook)
            except IOError:
                return None
        except IOError:
            return None
    if not os.path.exists(name):
        return create_thumbnail(fn,name,uri,type)
    try:
        i=Image.open(name)
    except:
        return create_thumbnail(fn,name,uri,type)
    if not i.info.has_key('Thumb::MTime'):
        debug('Thumbnail has no time registered, creating a new one.',1)
        return create_thumbnail(fn,name,uri,type)
    mtime = i.info['Thumb::MTime']
    # hackish... we want what's after the // of the uri's
    fmtime = os.stat(fn)[8] # grab the modification time of this file
    if int(mtime) != int(fmtime):
        debug('Thumbnail is older than file, updating thumbnail',1)
        return create_thumbnail(fn,name,uri,type)
    # make sure permissions are correct
    # since previous Gourmet's may have mucked them up :)
    os.chmod(name,0700)
    return name

def create_thumbnail (path, thumbpath, uri, type="large"):
    """Create a thumbnail at path and return path"""
    mtime = os.stat(path)[8]
    size = os.path.getsize(path)
    if int(size) > MAX_THUMBSIZE:
        debug('File too large!',0)
        return None
    try:
        im = Image.open(path)
    except:
        return None
    w,h = im.size
    if type=='large':
        geo = (256,256)
    else: geo = (128,128)
    im.thumbnail(geo)
    # set thumbnail attributes
    info={}
    info['Thumb::MTime']=str(mtime)
    info['Thumb::Image::Width']=str(w)
    info['Thumb::Image::Height'] =str(h)
    info['Software']='Gourmet Recipe Manager'
    info['URI']=str(uri)
    # now we must create our image guy
    try:
        from PIL import PngImagePlugin
    except ImportError:
        import PngImagePlugin
    pnginfo = PngImagePlugin.PngInfo()

    for k,v in info.items():
        pnginfo.add_text(k,v)
    im.save(thumbpath, pnginfo=pnginfo)
    # we must make all thumbnails permissions 700
    os.chmod(thumbpath,0700)
    return thumbpath


########NEW FILE########
__FILENAME__ = timeEntry
### Copyright (C) 2005 Thomas M. Hinkle
### Copyright (C) 2009 Rolf Leggewie
###
### This library is free software; you can redistribute it and/or
### modify it under the terms of the GNU General Public License as
### published by the Free Software Foundation; either version 2 of the
### License, or (at your option) any later version.
###
### This library is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
### General Public License for more details.
###
### You should have received a copy of the GNU General Public License
### along with this library; if not, write to the Free Software
### Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
### USA 

import gtk
from gettext import gettext as _
import gourmet.convert as convert
import validatingEntry

TIME_TO_READ = 1000

class TimeEntry (validatingEntry.ValidatingEntry):
    __gtype_name__ = 'TimeEntry'

    def __init__ (self, conv=None):
        if not conv: self.conv = convert.get_converter()
        else: self.conv = conv
        validatingEntry.ValidatingEntry.__init__(self)
        self.entry.get_value = self.get_value
        self.entry.set_value = self.set_value        

    def find_errors_in_progress (self, txt):
        if (not txt) or self.conv.timestring_to_seconds(txt):
            return None
        elif not convert.NUMBER_MATCHER.match(txt.split()[0]):
            return _('Time must begin with a number or fraction followed by a unit (minutes, hours, etc.).')
        else:
            words = txt.split()
            #if len(words) == 1:
            #    self._hide_warning_slowly()
            #    return
            if convert.NUMBER_MATCHER.match(words[-1]):
                return None
            else:
                partial_unit = words[-1]
            for u in self.conv.unit_to_seconds.keys():
                if u.lower().find(partial_unit.lower())==0:
                    return None
                    #self._hide_warning_slowly()
                    #return
            return _('Invalid input.') + \
                   _('Time must be expressed in hours, minutes, seconds, etc.')
            self._show_warning()
        #else:
        #    self.set_warning_text("Invalid or incomplete time")
        #    self._show_warning()

    def find_completed_errors (self,*args):
        txt = self.entry.get_text()
        if txt and not self.conv.timestring_to_seconds(txt):
            return _('Invalid input.') + \
                   _('Time must be expressed in hours, minutes, seconds, etc.')

            words = txt.split()
            if len(words) == 1:
                self._hide_warning_slowly()
                return
            elif convert.NUMBER_MATCHER.match(words[-1]):
                return
            else:
                partial_unit = words[-1]
            for u in self.conv.unit_to_seconds.keys():
                if u.lower().find(partial_unit.lower())==0:
                    self._hide_warning_slowly()
                    return
            self.valid = False
            self.warn = True
            self.set_warning_text('Invalid input.' + 'Time must be expressed in hours, minutes, seconds, etc.')
            self._show_warning()

    def set_value (self,seconds):
        self.entry.set_text(
            convert.seconds_to_timestring(seconds,
                                  fractions=convert.FRACTIONS_ASCII)
            )

    def get_value (self):
        return self.conv.timestring_to_seconds(self.entry.get_text())
        
def make_time_entry():
    te=TimeEntry()
    te.show()
    return te

if __name__ == '__main__':
    w=gtk.Window()
    vb = gtk.VBox()
    hb = gtk.HBox()
    l=gtk.Label('_Label')
    l.set_use_underline(True)
    l.set_alignment(0,0.5)
    hb.pack_start(l)
    te=TimeEntry()
    import sys
    te.connect('changed',lambda w: sys.stderr.write('Time value: %s'%w.get_value()))
    l.set_mnemonic_widget(te)
    hb.pack_start(te,expand=False,fill=False)
    vb.add(hb)
    qb = gtk.Button(stock=gtk.STOCK_QUIT)
    vb.add(qb)
    l.show()
    hb.show()
    qb.show()
    te.show()
    vb.show()
    qb.connect('clicked',lambda *args: w.hide() and gtk.main_quit() or gtk.main_quit())
    w.add(vb)
    w.show()
    w.connect('delete_event',gtk.main_quit)
    gtk.main()
    

########NEW FILE########
__FILENAME__ = treeview_extras
from gourmet.gdebug import debug
import gtk, gobject

def print_tree (mod):
    for row in mod:
        print [col for col in row]
        for child in row.iterchildren():
            print '-> ',[col for col in child]
        
def path_next (path, inc=1):
    """Return the path NEXT rows after PATH. Next can be negative, in
    which case we get previous paths."""
    next=list(path[0:-1])
    last=path[-1]
    last += inc
    if last < 0:
        last=0
    next.append(last)
    next=tuple(next)
    return next

def get_unique_iter_from_value (mod, col, val):
    for r in mod:
        if r[col]==val: return r.iter
        for rc in r.iterchildren():
            if rc[col]==val: return rc.iter

def move_iter (mod, iter, sibling=None, parent=None, direction="before"):
    """move_iter will move iter relative to sibling or
    parent. Direction (before or after) tells us whether to
    insert_before or insert_after (with a sib) or to prepend or append
    (with a parent)."""
    if direction != "after":
        direction = "before"
    path = mod.get_path(iter)
    if sibling:
        dpath = mod.get_path(sibling)
    elif parent:
        dpath = mod.get_path(parent)
    else:
        dpath = ()
    rowdata = get_row(mod, iter)
    children=harvest_children(mod, iter)
    if direction != "after":
        direction = "before"
    path = mod.get_path(iter)
    if sibling:
        dpath = mod.get_path(sibling)
    elif parent:
        dpath = mod.get_path(parent)
    else:
        dpath = ()
    rowdata = get_row(mod, iter)
    children=harvest_children(mod, iter)
    def insert_new (parent):
        """A little subroutine to insert our row. We'll call this at the appropriate
        time depending on the order of source and destination iters"""
        if not parent:
            parent=None
            if len(dpath) > 1:
                parent=mod.get_iter(dpath[0:-1])
        if parent==sibling or not sibling:
            """If our parent is our destination iter or if we have
            only a parent specified, we're moving inside, not before"""
            if direction=="before":
                return mod.append(parent, rowdata)
            else:
                return mod.prepend(parent, rowdata)
        elif direction=="before":
                return mod.insert_before(parent,sibling,rowdata)
        else:
            return mod.insert_after(parent,sibling,rowdata)
    # if the source is before the destination, we add then remove. otherwise, we remove then add.
    path_last = path_compare(path,dpath)
    if path_last==1:
        # Source after destination (remove, then add)
        remove_children(mod, iter)
        mod.remove(iter)
        new=insert_new(parent)
        insert_children(mod, new, children)
    elif path_last==0: debug("Moving into my self is nonsensical!",1)
    else:
        # Source before destination (add, then remove)
        new=insert_new(parent)
        insert_children(mod, new, children)
        remove_children(mod, iter)
        mod.remove(iter)

def insert_children (mod, iter, children):
    for row in children:
        mod.append(iter, row)

def remove_children (mod, iter):
    # in spite of its name, children gets the first child
    child = mod.iter_children(iter)
    while child:
        mod.remove(child)
        child = mod.iter_children(iter)        

def harvest_children (mod, iter):
    ret = []
    n = 0
    child = mod.iter_nth_child(iter, n)
    while child:
        ret.append(get_row(mod, child))
        n += 1
        child = mod.iter_nth_child(iter, n)
    return ret
            
def path_compare (p1, p2):
    """Return 1 if p1 > p2, 0 if p1 = p2 and -1 if p1 < p2
    Greater than means comes after."""
    flag = True
    retval = None
    n = 0
    while flag:
        if len(p1)>n and len(p2)>n:
            if p1[n] > p2[n]:
                retval=1
                flag=False
            elif p1[n] < p2[n]:
                retval=-1
                flag=False
            else: flag=True
        elif len(p1)<=n and len(p2)<=n:
            ## if we're both too short, we're done comparing and we're equal
            retval=0
            flag=False
        else:
            ## otherwise one of these is greater (the longer path comes after/is greater than the shorter)
            if len(p1) > len(p2):
                retval=1
                flag=False
            else:
                retval=-1
                flag=False
        n += 1
    return retval
        
def get_row (mod, iter):
        """Grab all values in iter and return as a list suitable for
        feeding to 'row' argument of append/prepend/insert"""
        n = 0
        flag = True
        row = []
        while flag:
            try:
                row.append(mod.get_value(iter,n))
            except:
                flag=False
            n += 1
        return row

class selectionSaver:
    """A class to save selections in a treeStore. This is implemented because it is too damned
    hard to follow iters when potentially moving around multiple items. It will only work if
    one column of data in the treeIter is a unique identifier. This happens to be true of all
    of my treeViews. To use this class, initilialize it before moving things around. Then call
    'restore_selections' to fix up your selections."""

    def __init__ (self, treeview, unique_column=0):
        """unique_column is the column with unique data (used to identify selections). treeview
        is the treeview in question"""
        self.expanded = {}
        self.tv = treeview
        self.uc = unique_column
        self.model=self.tv.get_model()
        self.selection=self.tv.get_selection()
        self.save_selections()
        
    def save_selections (self):
        self.selected = []
        self.expanded = {}        
        self.selection.selected_foreach(self._add_to_selected)

    def _add_to_selected (self, model, path, iter):
        self.add_selection(iter)
        
    def add_selection (self, itr):
        """Add iter to list of selected items"""
        v = self.model.get_value(itr,self.uc)
        self.selected.append(v)
        pth = self.model.get_path(itr)
        expandedp = self.tv.row_expanded(pth)
        if expandedp:
            self.expanded[v] = expandedp
        
    def rem_selection (self, itr):
        """Remove iter from list of selected items. Silently do nothing if
        handed an iter that wasn't selected in the first place."""
        try:
            selected.remove(self.model.get_value(itr,self.uc))
        except ValueError:
            pass

    def restore_selections (self, tv=None):
        """Restore selections. We can optionally do the unlikely task of
        restoring selections to a new treeView. This might come in handy
        w/ dragndrop within an application between treeViews. Otherwise,
        we remember and use the treeView we were initially handed."""
        if tv:
            self.tv=tv
            self.model=self.tv.get_model()
            self.selection=self.tv.get_selection()
        else:
            self.model = self.tv.get_model()
            self.selection = self.tv.get_selection()
        self.selection.unselect_all()
        itr = self.model.get_iter_first()
        new_paths=[]
        while itr:
            v = self.model.get_value(itr,self.uc)
            if self.selected.__contains__(v):
                self.selection.select_iter(itr)
                if isinstance(v,unicode) and self.expanded.get(v):
                    self.tv.expand_row(self.model.get_path(itr),True)
                new_paths.append(self.model.get_path(itr))
            child = self.model.iter_children(itr)            
            if child:
                itr = child
            else:
                next = self.model.iter_next(itr)
                if next:
                    itr = next
                else:
                    parent = self.model.iter_parent(itr)
                    if parent:
                        itr = self.model.iter_next(parent)
                    else:
                        itr = None
            
class TreeViewConf:
    """Handed a treeView and two configuration items, this class allows
    us to save user changes made to a treeView. Whoever calls us is responsible
    for saving our self.hidden and self.order at the appropriate times and handing
    them back to us when needed. Note: this will break if column titles aren't unique."""
    def __init__ (self, tv, hidden=[], order={}):
        self.tv=tv
        self.order=order
        self.hidden=hidden
        self.tv.connect("columns-changed",self.save_column_change_cb)
        
    def apply_visibility (self):
        for c in self.tv.get_columns():
            t=c.get_title()
            if t in self.hidden: c.set_visible(False)
            else:
                # and try with "_" removed
                l=list(t)
                if '_' in l: l.remove('_')
                t="".join(l)
                if t in self.hidden: c.set_visible(False)
                else: c.set_visible(True)

    def apply_column_order (self):
        coldic = {}
        for c in self.tv.get_columns():
            try:
                coldic[self.order[c.get_title()]]=c
            except:
                debug("I don't know about column titled %s"%c.get_title(),3)
        prevcol=None
        for n in range(len(self.tv.get_columns())):
            if coldic.has_key(n):
                c=coldic[n]
                self.tv.move_column_after(c,prevcol)
                prevcol=c
            else:
                debug("There is no column in position %s"%n,4)

    def save_column_change_cb (self,tv):
        self.order = {}
        n=0
        for c in tv.get_columns():
            titl=c.get_title()
            self.order[titl]=n
            n += 1

class QuickTree (gtk.ScrolledWindow):
    def __init__ (self, rows, titles=None):
        
        """Handed a list of data, we create a simple treeview.  The
        rules are simple. Each row can be a LIST in which case it is
        taken to be a list of columns (and each LIST is assumed to be
        the same length). Alternatively, each row can be an item, in
        which case there is only one column. All items must produce a
        string with str(item)."""
        debug('QuickTree got rows: %s'%rows,0)
        gtk.ScrolledWindow.__init__(self)
        self.tv=gtk.TreeView()
        self.rows = rows
        self.titles=titles
        if self.rows:
            first = self.rows[0]
            if type(first) != type(()) and type(first) != type([]):
                debug('Mappifying!',0)
                self.rows=map(lambda x: [x],self.rows)
            self.setup_columns()
            self.setup_model()
        self.add(self.tv)
        self.set_policy(gtk.POLICY_AUTOMATIC,gtk.POLICY_AUTOMATIC)
        self.show_all()


    def setup_columns (self):
        self.cols=len(self.rows[0])
        if not self.titles:
            self.titles = [None] * self.cols
        rend=gtk.CellRendererText()
        for n in range(self.cols):
            debug('Adding column: %s'%self.titles[n],0)
            col = gtk.TreeViewColumn(self.titles[n],rend,text=n)
            col.set_resizable(True)
            col.set_reorderable(n)
            col.set_sort_column_id(n)
            self.tv.append_column(col)

    def setup_model (self):
        self.model = apply(gtk.ListStore,[str]*self.cols)
        for row in self.rows:
            itr = self.model.append()
            while len(row) > self.cols:
                row.pop()
            while len(row) < self.cols:
                row.append("")
            self.model[itr]=map(lambda i: str(i),row)
        self.tv.set_model(self.model)
            
            
if __name__ == '__main__':
    vb = gtk.VBox()
    sw = QuickTree(
        [['Foo','Bar'],
        ['Bar','Foo'],
        ['Foob','Barb'],
        ['Baz','Bang'],      ]
        )
    sw.tv.set_reorderable(True)
    sw.tv.ss = selectionSaver(sw.tv,0)
    def ss_save (*args):
        sw.tv.ss.save_selections()
    def ss_get (*args):
        sw.tv.ss.restore_selections()
    sw.tv.connect('drag-begin',ss_save)
    sw.tv.connect('drag-end',ss_get)
    w = gtk.Window()
    w.add(sw)
    w.show_all()
    gtk.main()

########NEW FILE########
__FILENAME__ = validatingEntry
### Copyright (C) 2005 Thomas M. Hinkle
### Copyright (C) 2009 Rolf Leggewie
###
### This library is free software; you can redistribute it and/or
### modify it under the terms of the GNU General Public License as
### published by the Free Software Foundation; either version 2 of the
### License, or (at your option) any later version.
###
### This library is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
### General Public License for more details.
###
### You should have received a copy of the GNU General Public License
### along with this library; if not, write to the Free Software
### Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
### USA 

import gobject
import gtk, time

TIME_TO_READ = 1000

class ValidatingEntry (gtk.VBox, gobject.GObject):

    __gsignals__ = {
        #'activate':'override',
        'mnemonic-activate':'override'
        }

    def __init__ (self, conv=None):
        gobject.GObject.__init__(self)
        self.warning_box = gtk.HBox()
        self.entry = gtk.Entry()
        self.image = gtk.Image()
        self.warning = gtk.Label()
        self.warning_box.add(self.image)
        self.image.set_from_icon_name(gtk.STOCK_DIALOG_WARNING,gtk.ICON_SIZE_MENU)
        self.warning_box.add(self.warning)
        a = gtk.Alignment()
        a.set_property('xalign',0)
        a.set_property('xscale',1)
        a.add(self.entry)
        a.show()
        self.entry.show()
        self.warning_box.show()
        self.valid = True
        self.validating = False
        self.add(self.warning_box)
        self.add(a)
        self.show()
        self.entry.connect('changed',self._validate)
        self.entry.connect('focus-out-event',self._validate_completed)
        self.warned = -1
        self.get_text = self.entry.get_text
        self.set_text = self.entry.set_text

    def do_activate (self,*args):
        self.entry.grab_focus()
        return True

    def do_mnemonic_activate (self,*args):
        self.entry.grab_focus()
        return True

    def connect (self, *args,**kwargs):
        """Hackish override"""
        return self.entry.connect(*args,**kwargs)

    def set_warning_text (self,text):
        self.warning.set_text('<i><span color="red">%s</span></i>'%text)
        self.warning.set_use_markup(True)

    def _show_warning (self):
        if not self.warned > 0:
            self.warned = time.time()
            self.warning_box.show_all()

    def _hide_warning_slowly (self):
        self.warn = False
        if self.warned == -1: return #already hidden
        warned_for = time.time() - self.warned
        remaining = TIME_TO_READ - warned_for * 1000
        if remaining > 0:
            gobject.timeout_add(remaining,self._hide_warning)
        else:
            self._hide_warning()

    def _hide_warning (self):
        if not self.warn:
            self.warned = -1
            self.warning_box.hide()
            self.validating = False
    
    def _show_warning_on_delay (self,delay):
        if not self.validating:
            gobject.timeout_add(CHECK_DELAY,lambda *args: not self.valid and self._show_warning())
            self.validating = True

    def _validate (self, *args):
        txt = self.entry.get_text()
        error = self.find_errors_in_progress(txt)
        if not error:
            self.valid = True
            self.warn = False
            self._hide_warning()
        else:
            self.valid = False
            self.warn = True
            self.set_warning_text(error)
            self._show_warning()

    def _validate_completed (self, *args):
        txt = self.entry.get_text()
        error = self.find_completed_errors(txt)
        if error:
            self.set_warning_text(error)
            self._show_warning()
        else:
            self._hide_warning_slowly()

    def find_errors_in_progress (self, text):
        """Return a string describing any errors.
        Return None if there are no errors.

        This will be called as the user types.
        """
        raise NotImplementedError

    def find_completed_errors (self, text):
        """return a string describing any errors.
        Return none if there are no errors.

        This will be called when the user has finished typing.
        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = WidgetSaver
#!/usr/bin/env python
import gtk.gdk
import os
from gourmet.gdebug import debug

class WidgetSaver:

    """A class to save and load widget properties to/from a
    dictionary. We leave it to whoever hands us the dictionary to save
    the dictionary. dictionary should contain a property name as a key
    and a value as a value. On __init__, we will load these properties
    into the widget and who the widget. Each signal in signals will be
    connected to save_properties"""

    def __init__ (self, widget, dictionary={}, signals=['destroy'], show=True):
        self.w = widget
        self.dictionary = dictionary
        self.signals = signals
        self.load_properties()
        for s in self.signals:
            self.w.connect(s,self.save_properties)
        if show: self.w.show()

    def load_properties (self):
        for p,v in self.dictionary.items():
            self.w.set_property(p,v)

    def save_properties (self, *args):
        for p in self.dictionary.keys():
            self.dictionary[p]=self.w.get_property(p)
        return False # we don't handle any signals
    
class WindowSaver (WidgetSaver):
    def __init__ (self, widget, dictionary={},
                  signals=['configure-event','delete-event'],
                  show=True):
        """We save the position and state of the window
        in dictionary. The dictionary consists of
        {window_size: widget.get_size(),
         position: widget.get_position(),}"""

        # Window positioning is bad on Windows -- setting
        # GRAVITY_STATIC creates a nightmare for users, so we'll just
        # disable this whole thing
        if os.name=='nt': return 
        
        widget.set_gravity(gtk.gdk.GRAVITY_STATIC)
        #widget.set_gravity(gtk.gdk.GRAVITY_NORTH_WEST)
        WidgetSaver.__init__(self, widget, dictionary, signals, show)

    def load_properties (self):
        #if os.name=='nt': return
        for p,f in ['window_size', self.w.resize],['position',self.w.move]:
            if self.dictionary.has_key(p) and self.dictionary[p]:
                debug('applying %s %s'%(f,self.dictionary[p]),3)
                #if os.name=='nt' and p=='position' and self.dictionary['position'][1]<20:
                #    #print 'FIDDLING WITH WINDOW FOR WINDOWS'
                #    #self.dictionary[p] = self.dictionary[p][0],20
                apply(f,self.dictionary[p])
        
    def save_properties (self, *args):
        if os.name=='nt': return
        if self.w.window and not self.w.window.get_state()&gtk.gdk.WINDOW_STATE_MAXIMIZED:
            # ignore the maximized window when we save sizes
            self.dictionary['window_size']=self.w.get_size()
            self.dictionary['position']=self.w.get_position()
            # For Windows, we sometimes have windows put out of view...
            #if self.dictionary['position'][1] < 20:
            #    self.w.set_position((self.dictionary['position'][0],20))
            #    #self.dictionary['position']=self.w.get_position()
            debug('Saved properties: %s'%self.dictionary,4)
        return False
    
class WidgetPrefs:
    def __init__ (self, prefs, glade=None, hideable_widgets=[], basename='hide_'):
        """hideable_widgets is a list of tuples:
        (widget_name, widget_desc)
        OR
        ([widget_name,widget_name],widget_desc)
        
        widget_name is a string,  handed to glade: glade.get_widget(widget)
        Multiple widget_names are allowed so that we can hide things like widgets
        and labels in one fell swoop
        """
        self.glade = glade
        self.basename = basename
        self.hideable_widgets = hideable_widgets
        self.apply_widget_prefs()

    def toggle_widget (self, w, val):
        """Toggle the visibility of widget 'w'"""
        if val: method = 'hide'
        else: method = 'show'
        if type(w)==type(""): w = [w]
        for wn in w:
            widg = self.glade.get_widget(wn)
            if widg:
                getattr(widg,method)()
            else:
                debug('There is no widget %s'%wn,1)

    def apply_widget_prefs (self):
        """Apply our widget preferences."""
        for w,desc in self.hideable_widgets:
            if self.get_widget_pref(w):
                self.toggle_widget(w,True)
            else:
                self.toggle_widget(w,False)

    def get_widget_pref (self,w):
        """Get our widget preferences."""
        return self.prefs.get(self.keyname(w),False)

    def keyname (self, w):
        if type(w)==type([]): w = w[0]
        return "%s%s"%(self.basename,w)

    def set_widget_pref (self,w,val):
        self.prefs[self.keyname(w)]=val
        self.toggle_widget(w,val)

    def apply_option (self, options):
        for tup in options:
            desc,val = tup
            w=self.apply_pref_dic[desc]
            self.set_widget_pref(w,val)

    def make_option_list (self):
        option_list = []
        self.apply_pref_dic={}
        for w,desc in self.hideable_widgets:
            pref = (['Hide %s'%desc,self.get_widget_pref(w)])
            self.apply_pref_dic[pref[0]]=w
            option_list.append(pref)
        return option_list
    
    def show_pref_dialog (self,*args):
        import dialog_extras
        pd=dialog_extras.preferences_dialog(
            options=self.make_option_list(),
            apply_func=self.apply_option)
        pd.run()        

########NEW FILE########
__FILENAME__ = ImageExtras
import os, os.path, tempfile, gtk, StringIO
try:
    from PIL import Image
except ImportError:
    import Image
from gdebug import debug

TMPFILE = tempfile.mktemp(prefix='gourmet_tempfile_')

def resize_image (image, width=None, height=None):
    debug("resize_image (self, image, width=None, height=None):",5)
    """Resize an image to have a maximum width=width or height=height.
    We only shrink, we don't grow."""
    iwidth,iheight=image.size
    resized=False
    if width and iwidth > width:
	newheight=int((float(width)/float(iwidth)) * iheight)
	if not height or newheight < height:
	    retimage=image.resize((width, newheight))
	    resised=True
    if not resized and height and iheight > height:
	newwidth = int((float(height)/float(iheight)) * iwidth)
	retimage = image.resize((newwidth,height))
	resized=True
    if resized:
	return retimage
    else:
	return image

def get_image_from_string (raw):
    """Given raw image data, return an Image object."""
    if os.name =='posix':
        sfi=StringIO.StringIO()
        sfi.write(raw)
        sfi.seek(0)
    else:
        sfi = write_image_tempfile(raw)
    try:
        return Image.open(sfi)
    except:
        print 'Trouble in image land.'
        print 'We dumped the offending string here:'
        print sfi
        print "But we can't seem to load it..."

def get_string_from_image (image):
    """Convert an image into a string representing its JPEG self"""
    ofi = StringIO.StringIO()
    image = image.convert('RGB')
    image.save(ofi,"JPEG")
    ret = ofi.getvalue()
    ofi.close()
    return ret

def get_string_from_pixbuf (pb):
    fn = tempfile.mktemp('jpg')
    pb.save(fn,'jpeg')
    s = file(fn,'r').read()
    return s
    
def get_pixbuf_from_jpg (raw):
    """Given raw data of a jpeg file, we return a gtk.gdk.Pixbuf
    """
    #o=open('/tmp/recimage.jpg','w')
    fn=write_image_tempfile(raw,name=TMPFILE)
    i=gtk.Image()
    i.set_from_file(fn)
    return i.get_pixbuf()

def write_image_tempfile (raw, name=None, ext=".jpg"):
    """Write a temporary image file.

    If not given a name, generate one.
    """
    if name:
        fn = os.path.join(tempfile.gettempdir(),
                            name + ext)
    else:
        fn = tempfile.mktemp(ext)
    o=open(fn,'wb')
    o.write(raw)
    o.close()
    return fn
    

########NEW FILE########
__FILENAME__ = generic_recipe_parser
import re
import gourmet.convert as convert
import unittest
from gettext import gettext as _

def parse_group (match, text, group_number, tag):
    start,end = match.span(group_number)
    if start==-1:
        return None
    else:
        retv = []
        if start > 0:
            retv.append((text[0:start],None))
        retv.append((text[start:end],tag))
        if end < len(text):
            retv.append((text[end:],None))
        return retv

class RecipeParser:

    """A generic parser for doing rough mark up of unformatted recipes

    We pre-parse the text based on a set of rules which look a bit
    like the rules we use for HTML parsing (see
    html_plugins/__init__.py).

    Each rule is
    [recipe_part,regexp_matcher,post_processing]

    recipe_part is a string describing what part of the recipe
    ('ingredient','ingredients', 'serving', etc.)

    regexp_matcher is a compiled regular expression to match our part.

    By default, we simply mark the whole line as being the recipe_part.

    post_processing can refine our match:

    If post_processing is an integer, it is the number of the regexp
    group which should actually be labelled (the rest of the line will
    be marked"ignore")

    Otherwise, post_processing should be a function of the following form.

    def (match_object, full_text, attribute):
        ...
        return [(chunk, tag),(chunk, tag),...]
    the matcher and text as arguments and should return a list of
    chunks/tag with marked up text from our line.

    [(chunk, tag),(chunk, tag),...]
    """

    LONG_LINE = 80
    SHORT_LINE = 40

    ATTRIBUTES = ['servings',
                  'category',
                  'cuisine',                  
                  'rating',
                  'source',
                  'ignore',
                  'yields',
                  'yield_unit',
                  'modifications',
                  ]

    ALIASES = [('cooking time','cooktime'),
               ('preparation time','preptime'),
               ('time','preptime'),
               ('author','source'),
               ('by','source'),
               ('yield','yields'),
               ('notes','modifications'),
               ('note','modifications'),               
               ]

    IGNORE_ON_OWN = ['instructions','ingredients','directions']

    joinable_tags = ['instructions','ingredient','ingredients',None]
    change_on_join = {'ingredient':'ingredients'}

    ing_matcher = re.compile(u"^\s*\u2022?\u2023?\u2043?\u204C?\u204D?\u2219?\u25C9?\u25D8?\u25E6?\u2619?\u2765?\u2767?\u29BE?\u29BF?\s*(%s\s+\w+.*)"%convert.NUMBER_REGEXP)

    def __init__ (self):
        self.title_parsed = False
        self.make_rules()
    
    #INGREDIENT = 'ING'
    #INSTRUCTIONS = 'INSTRUCTIONS'
    #ATTRIBUTE = 'ATT'
    #TITLE = 'TIT'
    #IGNORE = 'IGN'
    def make_rules (self):
        self.rules = [
            ['ingredients',
             self.ing_matcher,
             1],
            ['servings',
             re.compile("serv(ing|e)s?:?\s*%(num)s|%(num)s\s*servings?"%{
            'num':convert.NUMBER_REGEXP},re.IGNORECASE),
             lambda m,txt,attr: (parse_group(m,txt,2,attr)
                                 or
                                 parse_group(m,txt,3,attr))
             ],]
        for a in self.ATTRIBUTES:
            self.rules.append([a,re.compile('\s*%s\s*:\s*(.*)'%a,
                                            re.IGNORECASE),
                               1])
        for name,attr in self.ALIASES:
            self.rules.append([attr,re.compile('\s*%s\s*:\s*(.*)'%name,
                                               re.IGNORECASE),
                               1])
        for ig in self.IGNORE_ON_OWN:
            self.rules.append([None,
                               re.compile('^\W*%s\W*$'%ig,re.IGNORECASE),
                               None])
        self.rules.append([
            # instructions are our generic fallback
            'instructions',
            re.compile('.*'),
            None])
        def parse_yield (match_obj, full_text, attr):
            colon,amt,unit = match_obj.groups()
            return [(amt.strip(),'yields'),(unit.strip(),'yield_unit')]
        self.rules = [[
                'yield',
                re.compile('%(yield)s(:|s|\s-)\s-*%(num)s\s-*(.*)'%{
                    'yield':_('yield'),
                    'num':convert.NUMBER_REGEXP
                    },re.IGNORECASE),
                parse_yield
                ]] + self.rules                    

    def break_into_paras (self):
        self.long_lines = False
        for l in self.txt.split('\n'):
            if len(l)>self.LONG_LINE:
                self.long_lines = True
                break
        if self.long_lines:
            self.paras = self.txt.split('\n')
        else:
            # Try to deal with wrapped lines reasonably...
            self.paras = []
            start_new_para = True
            for l in self.txt.split('\n'):                
                if start_new_para or self.ing_matcher.match(l):
                    self.paras.append(l)
                    if len(l) > self.SHORT_LINE: start_new_para = False
                else:
                    self.paras[-1] = self.paras[-1]+' '+l
                    start_new_para = (len(l) < self.SHORT_LINE)

    def parse (self, txt, parentThread=None):
        self.txt = txt
        self.parsed = []
        self.break_into_paras()
        tot=len(self.paras)
        n = 1
        for p in self.paras:
            # update a progress bar if necessary...
            if parentThread:
                parentThread.emit('progress',
                                  float(n)/tot,
                                  'Parsing unformatted recipe')
                n+=1
            self.parsed.append(('\n',None))
            # genericly guess that the title is the first line!
            if not self.title_parsed and p.strip():
                self.parsed.append((p,'title'))
                self.title_parsed = True
            elif not p.strip():
                self.parsed.append((p,None))
            else:
                for attr,regexp,postproc in self.rules:
                    m = regexp.search(p)
                    if m:
                        if postproc:
                            if type(postproc)==int:
                                proced = parse_group(
                                    m, p, postproc, attr
                                    )
                                if not proced:                                    
                                    continue
                            else:
                                proced = postproc(m,p,attr)
                            if proced:
                                self.parsed.extend(proced)
                                break
                        else:
                            self.parsed.append((p,attr))
                            break
        self.join_the_joinable()
        return self.parsed

    def join_the_joinable (self):
        """Go through self.parsed and join joinable elements.

        This means: produce fewer elements to jump through for the
        user if possible.
        """
        parsed = self.parsed[0:]
        self.parsed = []
        for chunk,tag in parsed:
            if tag not in self.joinable_tags or len(self.parsed)==0:
                self.parsed.append([chunk,tag])
                continue
            if self.change_on_join.has_key(tag):
                look_for = [tag,self.change_on_join[tag]]
            else:
                look_for = [tag]
            add_on = ''
            added = False
            for n in range(1,len(self.parsed)+1):
                oldchunk,oldtag = self.parsed[-n]
                if oldtag in look_for:
                    self.parsed[-n][0] = oldchunk+add_on+chunk
                    added = True
                    if self.change_on_join.has_key(oldtag):
                        self.parsed[-n][1] = self.change_on_join[oldtag]
                    # Strip off any added junk...
                    if n > 1:
                        self.parsed = self.parsed[0:-(n-1)]
                    break
                if oldtag == None:
                    add_on += oldchunk
                else:
                    break
            if not added:
                self.parsed.append([chunk,tag])

class RecipeTestCase (unittest.TestCase):
    def setUp (self):
        self.recipe = """
My Recipe

This is a test recipe. I hope it is really good.

This recipe serves 8
Category: dessert, quick, snack
Cuisine: Classic American!
Yield: 2 cups        

   1 tbs. milk
   3 tbs. unsweetened bakers chocolate
   2 tbs. sugar
   1/4 tsp. almond extract

   1 c. milk

   2 tbs. whipped cream (for garnish)
        
   Mix the first four ingredients together into a thick slurry.
   Add the milk. Heat and stir.

   Enjoy!!!
   """
        self.rp = RecipeParser()

    def testParser (self):
        parsed = self.rp.parse(self.recipe)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = html_importer
import urllib, re, tempfile, os.path
import importer
import BeautifulSoup
import socket
from gourmet.gdebug import debug
from gettext import gettext as _
import traceback

DEFAULT_SOCKET_TIMEOUT=45.0
URLOPEN_SOCKET_TIMEOUT=15.0

socket.setdefaulttimeout(DEFAULT_SOCKET_TIMEOUT)
# To add additional HTML import sites, see html_rules.py

def read_socket_w_progress (socket, progress, message):
    """Read piecemeal reporting progress as we go."""
    if not progress: data = socket.read()
    else:
        bs = 1024 * 8
        if hasattr(socket,'headers'):
            fs = int(socket.headers.get('content-length',-1))
        else: fs = -1
        block = socket.read(bs)
        data = block
        sofar = bs
        while block:
            if fs>0: progress(float(sofar)/fs, message)
            else: progress(-1, message)
            sofar += bs
            block = socket.read(bs)
            data += block
    socket.close()
    return data

def get_url (url, progress):
    """Return data from URL, possibly displaying progress."""
    if type(url)==str:
        socket.setdefaulttimeout(URLOPEN_SOCKET_TIMEOUT)
        sock = urllib.urlopen(url)
        socket.setdefaulttimeout(DEFAULT_SOCKET_TIMEOUT)
        return read_socket_w_progress(sock,progress,_('Retrieving %s'%url))
    else:
        sock = url
        return read_socket_w_progress(sock,progress,_('Retrieving file'))

class MyBeautifulSoup (BeautifulSoup.ICantBelieveItsBeautifulSoup):

    def __init__ (self, *args, **kwargs):
        # Avoid invalid doctype decls of the type
        # <!DOCTYPE foo ... />
        # From the overly XML zealous folks at sfgate...
        # http://sfgate.com/cgi-bin/article.cgi?f=/chronicle/archive/2006/08/16/FDG1LKHOMG1.DTL
        self.PARSER_MASSAGE.append(
            (re.compile('<!([^<>]*)/>',),
             lambda x: '<!'+x.group(1)+'>'
             )
            )
        kwargs['avoidParserProblems']=True
        BeautifulSoup.ICantBelieveItsBeautifulSoup.__init__(self,*args,**kwargs)

    
    def handle_comment (self, text): pass
    def handle_decl (self, data): pass
    def handle_pi (self, text): pass

class BeautifulSoupScraper:
    """We take a set of rules and create a scraper using BeautifulSoup.
    
    This will be quite wonderfully magical. Handed rules, we can
    customize a scraper for any set of data from any website.

    Writing new rules should be simpler than writing a new class would
    be. The rules will take the following form:
    ['foobar',DIRECTIONS_TO_TAG,METHOD_OF_STORAGE, POST_PROCESSING]

    DIRECTIONS_TO_TAG is a list of instructions followed to find our
    tag. We can search by tagname and attributes or by text. By
    default, we drill down the structure each time.
    
    METHOD_OF_STORAGE is either TEXT or MARKUP, depending what we want
    to store in our return dictionary.

    OPTIONAL POST_PROCESSING, which can be a function or a regexp.  If
    it is a regexp, it should have a grouping construct which will
    contain the text we want to keep.
    """
    TEXT = 'text'
    MARKUP = 'markup'
    def __init__ (self, rules):
        """Set up a scraper according to a list of rules."""
        self.rules = rules

    def feed_url (self, url,progress=None):
        """Feed ourselves a url.

        URL can be a string or an already open socket.
        """
        self.url = url
        self.feed_data(get_url(url,progress))

    def feed_data (self, data):
        self.soup = MyBeautifulSoup(data)

    def scrape_url (self, url, progress=None):
        self.feed_url(url,progress)
        return self.scrape()

    def scrape_data (self, data):
        self.feed_data(data)
        return self.scrape()

    def scrape (self):
        """Do our actual scraping according to our rules."""
        self.dic = {}
        for rule in self.rules:
            self.apply_rule(rule)
        return self.dic

    def apply_rule (self, rule):
        """Apply a rule from our rule list."""
        if len(rule)==3:
            store_as,tagpath,retmethod = rule
            post_processing=None
        elif len(rule)==4:
            store_as,tagpath,retmethod,post_processing=rule
        else:
            raise Exception("Rule %s is invalid (it should be 3 or 4 items long)." % rule)
        tag = self.get_tag_according_to_path(tagpath)
        self.store_tag(store_as,tag,retmethod,post_processing)

    def post_process (self, post_processing, value, tag):
        """Post process value according to post_processing

        post_processing is either callable (and will return a modified
        string based on what it's handed), or a tuple: (regexp,
        force_match).

        The regexp must always yield the desired value in the first
        grouping construct (if you require something more complicated,
        write a lambda).

        If force_match is True, return '' if there is no
        match. Otherwise, default to the unadulterated value.
        """
        if type(post_processing) == tuple and len(post_processing)==2:
            regexp=re.compile(post_processing[0],re.UNICODE)
            m=regexp.search(value)
            if m: return m.groups()[0]
            else:
                if post_processing[1]: return ""
                else: return value
        elif callable(post_processing):
            return post_processing(value,tag)
        else:
            return value
            
    def get_tag_according_to_path (self, path):
        """Follow path to tag.

        Path is a list of instructions.
        """
        base = self.soup
        for step in path:
            base=self.follow_path(base,step)
            if type(base)==list:
                # then we'd better be the last step
                break
        return base

    def follow_path (self, base, step):
        """Follow step from base of base.

        Base is a tag. Step is a set of instructions as a dictionary.

        {'regexp':regexp}
        {'string':string}
        OR
        {'tag':tagname,
         'attributes':{attr:name,attr:name,...},
         'index': NUMBER or [FIRST,LAST],
         }
        """
        if not base: return # path ran out...
        ind=step.get('index',0)
        if step.has_key('regexp'):
            ret = base.fetchText(re.compile(step['regexp']))
        elif step.has_key('string'):
            ret = base.fetchText('string')        
        else:
            get_to = None
            if ind:
                if type(ind)==list: get_to=ind[-1]
                elif type(ind)==int: get_to=ind
                if not get_to or get_to < 0: get_to=None
                else: get_to += 1
            if get_to:
                ret = base.fetch(step.get('tag'),
                                 step.get('attributes',{}),
                                 get_to)
            else:
                ret = base.fetch(step.get('tag'),step.get('attributes',{}))
        if ret:
            # if we have moveto, we do it with our index -- for
            # example, if we have step['moveto']='parent', we grab the
            # parents of each tag we would otherwise return. This can
            # also work for previousSibling, nextSibling, etc.
            if step.has_key('moveto'):
                ret = [getattr(o,step['moveto']) for o in ret]
            else:
                for motion in ['firstNext','firstPrevious','findParent']:
                    if step.has_key(motion):
                        ret = [getattr(o,motion)(step[motion]) for o in ret]
                        break
            if type(ind)==list or type(ind)==tuple:                 
                return ret[ind[0]:ind[1]]
            else: #ind is an integer
                if ind < len(ret):
                    return ret[ind]
                else:
                    print 'Problem following path.'
                    print 'I am supposed to get item: ',ind
                    print 'from: ',ret
                    print 'instructions were : ',
                    try: print 'base: ',base
                    except UnicodeDecodeError: print '(ugly unicodeness)'
                    try: print 'step: ',step
                    except UnicodeDecodeError: print '(ugly unicodeness)'

    def store_tag (self, name, tag, method, post_processing=None):
        """Store our tag in our dictionary according to our method."""
        if type(tag)==list:
            for t in tag: self.store_tag(name,t,method,post_processing)
            return
        if method==self.TEXT:
            if tag: val = get_text(tag)
            else: val = ""
        elif method==self.MARKUP: 
            if tag: val = tag.prettify()
            else: val = ""
        else: #otherwise, we assume our method is an attribute name
            val = ""
            if tag:
                for aname,aval in tag.attrs:
                    if aname==method: val=aval
        if post_processing:
            val=self.post_process(post_processing, val, tag)
        if not val: return # don't store empty values
        if self.dic.has_key(name):
            curval = self.dic[name]
            if type(curval)==list: self.dic[name].append(val)
            else: self.dic[name]=[self.dic[name],val]
        else:
            self.dic[name]=val

class GenericScraper (BeautifulSoupScraper):
    """A very simple scraper.

    We grab a list of images and all the text.
    """
    def __init__ (self):
        BeautifulSoupScraper.__init__(self,
            [['text',
              [{'tag':'body',
                # Believe it or not, I've found recipe webpages with
                # more than one body tag
                'index':[0,None],
                }],
              'text',
              ],
             ['images',
              [{'tag':'img',
                'index':[0,None]}],
              'src',
              ],
             ['title',
              [{'tag':'title'}],
              'text',],
             ]
            )

    def scrape (self):
        dic = BeautifulSoupScraper.scrape(self)
        text = dic.get('title','')+'\n'+dic.get('text','')
        images = dic.get('images',[])
        if type(images)!=list: images = [images]
        images = [urllib.basejoin(self.url,i) for i in images]
        return text,images

class FancyTextGetter:
    """Starting with a BeautifulSoup tag, get text in some kind of reasonable w3mish way.
    """

    IS_BREAK = ['br']
    TWO_LB_BEFORE = ['table','p','blockquote']
    LB_BEFORE = ['tr','li']
    TAB_BEFORE = ['td']
    IGNORE = ['script','meta','select']
    
    def __call__ (self, top_tag, strip=True):
        self.text = ''
        if hasattr(top_tag,'contents'):
            self.add_tag(top_tag)
        else:
            self.text = top_tag.string
        if strip:
            self.text = self.text.strip()
            # No more than two spaces!
            self.text = re.sub('\n\t','\n',self.text)
            self.text = re.sub('\n\s*\n\s+','\n\n',self.text)
        try:
            return unicode(self.text,errors='ignore')
        except:
            print 'Odd encoding problems with ',self.text
            return self.text
            
    def add_tag (self, t):
        for item in t.contents: self.get_text_fancy(item)

    def get_text_fancy (self, item):
        #print 'get_text_fancy looking at:',item
        if self.text and hasattr(item,'name'):
            if item.name in self.IGNORE: return
            if item.name in self.IS_BREAK:
                self.text += '\n'
                return
            elif item.name in self.TWO_LB_BEFORE:
                self.text += '\n\n'
            elif item.name in self.LB_BEFORE:
                self.text += '\n'
            elif item.name in self.TAB_BEFORE:
                self.text += '\t'
        if hasattr(item,'contents'):
            self.add_tag(item)
        else:
            try:
                s = item.string.encode('utf8','replace')
                self.text += s
            except UnicodeDecodeError:
                print 'UNICODE DECODING ERROR IN TAG',
                if hasattr(item,'name'):
                    print item.name
                if hasattr(item,'fetchParents'):
                    print 'CHILD OF: ','<'.join([p.name for p in item.fetchParents()])
                
get_text = FancyTextGetter()

img_src_regexp = re.compile('<img[^>]+src=[\'\"]([^\'"]+)')

def get_image_from_tag (iurl, page_url):
    if not iurl: return
    iurl = urllib.basejoin(page_url,iurl)
    tmpfi,info=urllib.urlretrieve(iurl)
    ifi=file(tmpfi,'rb')
    retval=ifi.read()
    ifi.close()
    return retval

def scrape_url (url, progress=None):
    if type(url)==str: domain=url.split('/')[2]
    if SUPPORTED_URLS.has_key(domain):
        bss = BeautifulSoupScraper(SUPPORTED_URLS[domain])
    else:
        bss = None
        for regexp,v in SUPPORTED_URLS_REGEXPS.items():
            if re.match(regexp,domain):
                bss=BeautifulSoupScraper(v)
                break
    if bss:
        return bss.scrape_url(url,progress=progress)

def add_to_fn (fn):
    '''Add 1 to a filename.'''
    f,e=os.path.splitext(fn)
    try:
        f,n=os.path.splitext(f)
        n = int(n[1:])
        n += 1
        return f + "%s%s"%(os.path.extsep,n) + e
    except:
        return f + "%s1"%os.path.extsep + e
    
def import_url (url, rd, progress=None, add_webpage_source=True, threaded=False,
                interactive=True):
    """Import information from URL.
    We handle HTML with scrape_url.

    Everything else, we hand back to our caller as a list of
    files. This is a little stupid -- it would be more elegant to just
    hand back a class, but our importer stuff is a little munged up
    with gui-ness and it's just going to have to be ugly for now
    """
    if progress: progress(0.01,'Fetching webpage')
    sock=urllib.urlopen(url)
    header=sock.headers.get('content-type','text/html')
    if progress: progress(0.02, 'Reading headers')
    if header.find('html')>=0:
        #return scrape_url(url,progress)
        return WebPageImporter(rd,
                               url,
                               prog=progress,
                               add_webpage_source=add_webpage_source,
                               threaded=threaded,
                               interactive=interactive)
    elif header=='application/zip':
        import zip_importer
        return zip_importer.zipfile_to_filelist(sock,progress,os.path.splitext(url.split('/')[-1])[0])
    else:
        fn = os.path.join(tempfile.tempdir,url.split('/')[-1])
        while os.path.exists(fn):
            fn=add_to_fn(fn)
        ofi = open(fn,'w')
        ofi.write(get_url(sock,progress))
        ofi.close()
        return [fn]

class WebPageImporter (importer.Importer):
    """Import a webpage as a recipe

    We use our BeautifulSoupScraper class to do the actual scraping.

    We use predefined webpages already registered in the global variable
    SUPPORTED_URLS in this module.

    If we don't know the web page, we will prompt the user to guide us
    through a generic import.

    To create a new type of web page import, create a new set of
    import rules and register them with SUPPORTED_URLS.
    """

    JOIN_AS_PARAGRAPHS = ['instructions','modifications','ingredient_block']

    def __init__ (self, rd, url, add_webpage_source=True,
                  threaded=False, total=0, prog=None,conv=None,
                  interactive=True):
        self.add_webpage_source=add_webpage_source
        self.url = url
        self.prog = prog
        self.interactive = interactive
        importer.Importer.__init__(self,rd,threaded=threaded,total=total,prog=prog,do_markup=True,
                                   conv=conv)

    def run (self):
        """Import our recipe to our database.

        This must be called after self.d is already populated by scraping
        our web page.
        """
        debug('Scraping url %s'%self.url,0)
        try:
            self.d = scrape_url(self.url, progress=self.prog)
        except:
            print 'Trouble using default recipe filter to download %s'%self.url
            traceback.print_exc()
            print 'We will use a generic importer instead.'
            self.d = {}
        debug('Scraping url returned %s'%self.d,0)
        do_generic = not self.d
        if not do_generic:
            try:
                if self.prog: self.prog(-1,'Parsing webpage based on template.')
                self.get_url_based_on_template()
            except:
                if not self.interactive: raise
                do_generic = True
                print """Automated HTML Import failed
                ***Falling back to generic import***

                We were attempting to scrape using the following rules:
                """
                print self.d
                print """The following exception was raised:"""
                traceback.print_exc()
                print """If you think automated import should have worked for the webpage you
                were importing, copy the output starting at "Automated HTML Import failed" into
                a bug report and submit it at the GitHub site
                
                https://github.com/thinkle/gourmet/issues

                Sorry automated import didn't work. I hope you like
                the new generic web importer!
                """
        if do_generic:
            if not self.interactive:
                raise Exception("Unable to find importer for %s" % self.url)
            # Interactive we go...
            self.prog(-1,_("Don't recognize this webpage. Using generic importer..."))
            gs = GenericScraper()
            text,images = gs.scrape_url(self.url, progress=self.prog)
            if not text and not images:
                raise Exception("Unable to obtain text or images from url %s" % self.url)
            import interactive_importer
            ii = interactive_importer.InteractiveImporter(self.rd)
            ii.set_text(text)
            ii.add_attribute('link',self.url)
            ii.set_images(images)
            ii.run()
            if self.prog: self.prog(1,_('Import complete.'))
            return
        
    def get_url_based_on_template (self):
        """Get URL based on template stored in d
        """
        self.start_rec()
        # Set link
        self.rec['link']=self.url
        # Add webpage as source
        if self.add_webpage_source:
            # add Domain as source
            domain = self.url.split('/')[2]
            src=self.d.get('source',None)
            add_str = '(%s)'%domain
            if type(src)==list: src.append(add_str)
            elif src: src = [src,add_str]
            else: src = domain # no parens if we're the only source
            self.d['source']=src
        for k,v in self.d.items():
            debug('processing %s:%s'%(k,v),1)
            if self.prog: self.prog(-1,_('Importing recipe'))
            # parsed ingredients...
            if k=='ingredient_parsed':
                if type(v) != list: v=[v]
                for ingdic in v:
                    
                    if self.prog: self.prog(-1,_('Processing ingredients'))
                    # we take a special keyword, "text", which gets
                    # parsed
                    if ingdic.has_key('text'):
                        d = self.rd.parse_ingredient(ingdic['text'],conv=self.conv)
                        if d:
                            for dk,dv in d.items():
                                if not ingdic.has_key(dk) or not ingdic[dk]:
                                    ingdic[dk]=dv
                        elif not ingdic.has_key('item'):
                            ingdic['item']=ingdic['text']
                        del ingdic['text']
                    self.start_ing(**ingdic)
                    self.commit_ing()
                continue

            # Listy stuff...
            elif type(v)==list:
                if k in self.JOIN_AS_PARAGRAPHS: v = "\n".join(v)
                else: v = " ".join(v)

            # Ingredients in blocks
            if k == 'ingredient_block':
                for l in v.split('\n'):
                    if self.prog: self.prog(-1,_('Processing ingredients.'))
                    dic=self.rd.parse_ingredient(l,conv=self.conv)
                    if dic:
                        self.start_ing(**dic)
                        self.commit_ing()
                        
            elif k == 'image':
                try:
                    if v: img = get_image_from_tag(v,self.url)
                except:
                    print 'Error retrieving image'
                    print 'tried to retrieve image from %s'%v
                else:
                    if img:
                        self.rec['image'] = img
            else: self.rec[k]=v
        #print 'COMMITTING RECIPE',self.rec
        self.commit_rec()
        if self.prog: self.prog(1,_('Import complete.'))

########NEW FILE########
__FILENAME__ = imageBrowser
import gtk, gtk.gdk, gobject, pango
from gourmet.ImageExtras import get_pixbuf_from_jpg
from gourmet.gtk_extras.thumbnail import check_for_thumbnail,fetched_uris
from gourmet.gtk_extras.dialog_extras import ModalDialog
import unittest
from gourmet.gdebug import debug,TimeAction
import threading, time

def grab_thumbnail (uri, type, iqueue, pqueue, progress_portion=1, progress_start_at=0):
    #print 'GRAB THUMBNAIL',uri,type,progress_portion,progress_start_at
    def reporthook (block, blocksize, total):
        #print 'REPORT HOOK',block,blocksize,total
        try:
            perc = progress_start_at + ((block*blocksize)/(float(total)) * progress_portion)
        except:
            #print 'problem getting percent from'
            #print "progress_start_at: %(progress_start_at)s, block: %(block)s, blocksize: %(blocksize)s, %(progress_portion)s progress_portion, %(total)s: total"%locals()
            raise
        #except:
        #    perc = -1
        #print "REPORT:",uri,perc
        #pqueue.put_nowait(('Getting %s'%uri,perc))
        pqueue.append(('Getting %s'%uri,perc))
    #print 'ADD Fetch starter to QUEUE'
    #pqueue.put_nowait(('Getting %s'%uri,0))
    pqueue.append(('Getting %s'%uri,0))
    import time
    #print 'Fetching ',uri
    try:
        fi = check_for_thumbnail(uri,type,reporthook)
    except:
        print 'WARNING: Error on creating thumbnail - ignoring'
        import traceback; traceback.print_exc()
    else:
        iqueue.append((fi,uri))
    #print 'Fetched'
    #print 'Adding result to Queue'
    #print 'Done'
    
class ImageBrowser (gtk.IconView):
    def __init__ (self,*args,**kwargs):
        gtk.IconView.__init__(self,*args,**kwargs)
        self.model = gtk.ListStore(gtk.gdk.Pixbuf,str)
        self.set_selection_mode(gtk.SELECTION_SINGLE)
        self.set_model(self.model)
        self.set_pixbuf_column(0)
        self.image_queue = []
        self.progress_queue = []
        self.to_add_lock = threading.Lock()
        self.updating = False
        self.adding = []
        self.alive = False
        gobject.timeout_add(100,self.update_progress)
        gobject.timeout_add(100,self.add_image_from_queue)
        #self.run_thread()

    def add_image_from_uri (self, u, progress_portion=1, progress_start_at=0):
        #print 'ADD_IMAGE_FROM_URI',u,progress_portion,progress_start_at
        self.to_add_lock.acquire()
        self.adding.append({'url':u,
                            'progress_portion':progress_portion,
                            'progress_start_at':progress_start_at,
                            }
                           )
        self.to_add_lock.release()
        if not self.alive:
            #print 'RUN THREAD!'
            self.run_thread()

    def quit (self):
        self.alive = False

    def run_thread (self):
        self.alive = True
        t=threading.Thread(target=self.fetch_images)
        t.start()

    def fetch_images (self):
        while self.alive:
            #print 'FETCH_IMAGES',time.time()
            if self.adding:
                self.to_add_lock.acquire()
                to_add = self.adding[0]; self.adding = self.adding[1:]
                #print 'TO_ADD',to_add
                self.to_add_lock.release()
                #print 'ADDING:',to_add,time.time()
                grab_thumbnail(
                    to_add['url'],
                    'small',
                    self.image_queue,
                    self.progress_queue,
                    progress_portion=to_add['progress_portion'],
                    progress_start_at=to_add['progress_start_at']
                    )
                #print 'ADDED!'
            else:
                time.sleep(0.1)

    def add_image_from_queue (self):
        try:
            #fi,u = self.image_queue.get_nowait()
            fi,u = self.image_queue.pop()
            if fi:
                pb = gtk.gdk.pixbuf_new_from_file(fi)
                self.model.append([pb,u])
        except IndexError:
            pass
        return True

    def update_progress (self):        
        try:
            #text,progress = self.progress_queue.get_nowait()
            text,progress = self.progress_queue.pop()
            #print 'Set progress',progress,text
            self.prog = progress,text
            self.set_progress(float(progress),text)
            #print 'UPDATE_PROGRESS',time.time(),progress,text
        except IndexError:
            if not self.adding and hasattr(self,'progressbar'):
                self.progressbar.hide()
            #elif hasattr(self,'progressbar'):
            #    self.progressbar.pulse()
        else:
            if progress == 1:
                print 'Done!'
                self.progressbar.hide()
                return None
        return True

    def set_progress (self, progress, text):
        if hasattr(self,'progressbar'):
            self.progressbar.show()
            self.progressbar.set_percentage(progress)
            self.progressbar.set_text(text)

class ImageBrowserDialog (ModalDialog):
    def __init__ (self, default=None, title="Select Image",okay=True,
                  label="Select an image", sublabel=None,parent=None, cancel=True, modal=True, expander=None):
        ModalDialog.__init__(self,default=default, title=title,
                             okay=okay,label=label,sublabel=sublabel,
                             parent=parent, cancel=cancel, modal=modal,
                             expander=expander)
        self.set_default_size(600,600)

    def setup_dialog (self, *args, **kwargs):
        ModalDialog.setup_dialog(self,*args,**kwargs)
        self.ib = ImageBrowser()
        self.ib.connect('selection-changed',self.selection_changed_cb)
        self.ib.connect('item-activated',self.okcb)
        self.sw = gtk.ScrolledWindow()
        self.pb = gtk.ProgressBar(); self.pb.set_ellipsize(pango.ELLIPSIZE_MIDDLE)
        self.vbox.pack_end(self.sw)
        self.vbox.pack_end(self.pb,expand=False)
        self.ib.progressbar = self.pb
        self.sw.add(self.ib)
        self.sw.show_all()
        self.sw.set_policy(gtk.POLICY_AUTOMATIC,gtk.POLICY_AUTOMATIC)

    def okcb (self, *args,**kwargs):
        self.ib.quit()
        ModalDialog.okcb(self,*args,**kwargs)
        

    def selection_changed_cb (self, iv):
        selected_paths = iv.get_selected_items()
        if selected_paths:
            itr = self.ib.model.get_iter(selected_paths[0])
            val = self.ib.model.get_value(itr,1)
            self.ret = val
        else:
            self.ret = None

    def add_images_from_uris_w_progress (self, uris):
        prog_perc = 1.0 / len(uris)
        for n,u in enumerate(uris):
            self.ib.add_image_from_uri(
                u,
                progress_portion=prog_perc,
                progress_start_at=prog_perc*n
                )

    def add_image_from_uri (self, u):
        self.ib.add_image_from_uri(u)

class ImageBrowserTest (unittest.TestCase):

    def setUp (self):
        self.ib = ImageBrowser()
        self.w = gtk.Window()
        self.sw = gtk.ScrolledWindow()
        self.sw.add(self.ib)
        self.sw.set_policy(gtk.POLICY_AUTOMATIC,gtk.POLICY_AUTOMATIC)
        self.w.add(self.sw)
        
    #def testWindow (self):
    #    self.w.show_all()
    #    self.ib.show_all()
    #    for image in ['Caneel beach.JPG','Cinnamon beach.JPG','dsc00258.jpg']:
    #        self.ib.add_image_from_uri('file:///home/tom/pictures/'+image)
    #    self.ib.add_image_from_uri('http://wikipes.com/wikipes-logo.gif')
    #    self.w.connect('delete-event',lambda *args: gtk.main_quit())
    #    gtk.main()

    def testDialog (self):
        self.ibd = ImageBrowserDialog()
        self.ibd.add_images_from_uris_w_progress(
            ['http://ideasinfood.typepad.com/ideas_in_food/images/katzs_pastrami_reuben.jpg'] \
#            + ['file:///home/tom/pictures/'+image for image in ['Caneel beach.JPG','Cinnamon beach.JPG','dsc00258.jpg']]
            )
        #for image in []:
        #    self.ibd.add_image_from_uri()
        import os
        if os.name!='nt':
            gtk.threads_init()
        self.ibd.run()

def get_image_file (uri):
    return fetched_uris[uri]

if __name__ == '__main__':
    try:
        # Make unit test not run from emacs C-c C-c into python shell...
        __file__
        print 'UNITTEST'
        unittest.main()
    except:
        pass
    
    

########NEW FILE########
__FILENAME__ = importer
import os,stat,re,time,StringIO
from gourmet import keymanager, convert, ImageExtras
from gourmet.gdebug import debug, TimeAction, print_timer_info, debug_decorator
import gourmet.gglobals
from gourmet.recipeManager import get_recipe_manager # for getting out database...
import xml.sax.saxutils
from gettext import gettext as _
import gettext
import gourmet.gtk_extras.dialog_extras as de
import re
from gourmet.threadManager import SuspendableThread, Terminated

# Convenience functions

def string_to_rating (s):
    m = simple_matcher.match(s)
    if m:
        top=float(convert.frac_to_float(m.groups()[0]))
        bottom = float(convert.frac_to_float(m.groups()[2]))
        return int(top/bottom * 10)

def add_to_fn (fn):
    '''Add 1 to a filename.'''
    f,e=os.path.splitext(fn)
    try:
        f,n=os.path.splitext(f)
        n = int(n[1:])
        n += 1
        return f + "%s%s"%(os.path.extsep,n) + e
    except:
        return f + "%s1"%os.path.extsep + e

class Importer (SuspendableThread):

    """Base class for all importers. We provide an interface to the recipe database
    for importers to use. Basically, the importer builds up a dictionary of properties inside of
    self.rec and then commits that dictionary with commit_rec(). Similarly, ingredients are built
    as self.ing and then committed with commit_ing()."""
    
    def __init__ (self,
                  rd = None, # OBSOLETE
                  total=0,
                  prog=None, # OBSOLETE
                  do_markup=True,conv=None,rating_converter=None,
                  name='importer'):
        """rd is our recipeData instance.

        Total is used to keep track of progress.

        do_markup should be True if instructions and modifications
        come to us unmarked up (i.e. if we need to escape < and &,
        etc. -- this might be False if importing e.g. XML).
        """

        timeaction = TimeAction('importer.__init__',10)
        if not conv: self.conv = convert.get_converter()
        self.id_converter = {} # a dictionary for tracking named IDs
        self.total = total
        if prog or rd:
            import traceback; traceback.print_stack()
            if prog:
                print 'WARNING: ',self,'handed obsolete parameter prog=',prog
            if rd:
                print 'WARNING: ',self,'handed obsolete parameter rd=',rd
        self.do_markup=do_markup
        self.count = 0
        self.rd = get_recipe_manager()
        self.rd_orig_ing_hooks = self.rd.add_ing_hooks
        self.added_recs=[]
        self.added_ings=[]
        #self.rd_orig_hooks = self.rd.add_hooks
        self.rd.add_ing_hooks = []
        #self.rd.add_hooks = []
        self.position=0
        self.group=None
        # allow threaded calls to pause
        self.suspended = False
        # allow threaded calls to be terminated (this
        # has to be implemented in subclasses).
        self.terminated = False
        # Our rating converter -- if we've been handed a class, we
        # assume our caller will handle doing the
        # conversion. Otherwise we do it ourselves.
        if rating_converter:
            self.rating_converter = rating_converter
            self.do_conversion = False
        else:
            self.rating_converter = RatingConverter()
            self.do_conversion = True
        self.km = keymanager.get_keymanager()
        timeaction.end()
        SuspendableThread.__init__(self,
                                   name=name)
    # end __init__

    def do_run (self):
        debug('Running ing hooks',0)
        for i in self.added_ings:
            for h in self.rd_orig_ing_hooks:
                h(i)
        #debug('Running rec hooks',0)  
        #for r in self._added_recs:
        #    for h in self.rd_orig_hooks:
        #        h(r)
        self.rd.add_ing_hooks = self.rd_orig_ing_hooks
        #self.rd.add_hooks = self.rd_orig_hooks        
        #print_timer_info()

    def _run_cleanup_ (self):
        if self.do_conversion:
            # if we have something to convert
            if self.rating_converter.to_convert:
                self.rating_converter.do_conversions(self.rd)

    def check_for_sleep (self):
        timeaction = TimeAction('importer.check_for_sleep',10)
        #gt.gtk_update()
        if self.terminated:
            raise Terminated("Importer Terminated!")
        while self.suspended:
            #gt.gtk_update()
            if self.terminated:
                raise Terminated("Importer Terminated!")
            else:
                time.sleep(1)
        timeaction.end()

    def start_rec (self, dict=None):
        self.rec_timer = TimeAction('importer RECIPE IMPORT',10)
        timeaction = TimeAction('importer.start_rec',10)
        self.check_for_sleep()
        if hasattr(self,'added_ings') and self.added_ings:
            print 'WARNING: starting new rec, but we have ingredients that we never added!'
            print 'Unadded ingredients: ',self.added_ings
        self.added_ings=[]
        self.group = None
        if dict:
            self.rec=dict
        else:
            self.rec = {}
        #if not self.rec.has_key('id'):
        #else:
        #    self.rec['id']=self.rd.new_id()
        #debug('New Import\'s ID=%s'%self.rec['id'],0)
        timeaction.end()

    def _move_to_instructions (self, recdic, attr):
        """A convenience method to shift information from an attribute
        to instructions.

        This is frequently a fallback for bad input -- we try to make
        sure we don't lose data this way."""
        # We add e.g. "Servings: lots" to instructions -- REC_ATTR_DIC
        # gets us the properly i18n'd name
        text_to_add = gourmet.gglobals.REC_ATTR_DIC['yields' if attr=='servings'
                                                    else attr] \
                      +': '+recdic[attr]
        if not recdic.has_key('instructions'):
            recdic['instructions']=text_to_add
        else:
            recdic['instructions']=recdic['instructions']+'\n'+text_to_add
        del recdic[attr]

    def commit_rec (self):
        timeaction = TimeAction('importer.commit_rec',10)
        for key in ['cuisine','category','title']:
            if self.rec.has_key(key):
                self.rec[key]=unicode(re.sub('\s+',' ',self.rec[key]).strip())
        # if yields/servings can't be recognized as a number, add them
        # to the instructions.
        if self.rec.has_key('yields'):
            try:
                self.rec['yields'] = float(self.rec['yields'])
            except:
                yields = self.convert_str_to_num(self.rec['yields'])
                if not yields:
                    print 'Moving yields to instructions!'
                    self._move_to_instructions(self.rec,'yields')
                else:
                    self.rec['yields'] = yields
        if self.rec.has_key('servings'):
            servs=self.convert_str_to_num(self.rec['servings'])
            if servs != None:
                #self.rec['servings'] = str(servs)
                self.rec['yields'] = float(servs)
                self.rec['yield_unit'] = gettext.ngettext('serving',
                                                          'servings',
                                                          servs)
            else:
                self._move_to_instructions(self.rec,'servings')
        # Check preptime and cooktime
        for t in ['preptime','cooktime']:
            if self.rec.has_key(t) and type(self.rec[t])!=int:
                secs = self.conv.timestring_to_seconds(self.rec[t])
                if secs != None:
                    self.rec[t]=secs
                else:
                    self._move_to_instructions(self.rec,t)
        # Markup instructions and mods as necessary
        if self.do_markup:
            for k in ['instructions','modifications']:
                if self.rec.has_key(k): self.rec[k] = xml.sax.saxutils.escape(self.rec[k])
        # A little strange, this is, but for UI reasons, we want to
        # keep track of any ratings that are not integers so that we
        # can ask the user how to convert them when we're all done
        # with importing.              
        remembered_rating = None
        if self.rec.has_key('rating') and type(self.rec['rating']) not in [int,float]:
            if string_to_rating(self.rec['rating']):
                self.rec['rating']=string_to_rating(self.rec['rating'])
            else:
                remembered_rating = self.rec['rating']
                del self.rec['rating']
        tt=TimeAction('importer.commit_rec - rd.add_rec',5)
        debug('commiting recipe %s'%self.rec,0)
        # Check for images without thumbnails
        if self.rec.get('image',None) and not self.rec.get('thumb',None):
            if not self.rec['image']: del self.rec['image']
            else:
                img = ImageExtras.get_image_from_string(self.rec['image'])
                if img:
                    thumb = ImageExtras.resize_image(img,40,40)
                    self.rec['thumb'] = ImageExtras.get_string_from_image(thumb)
                    # Make sure our image is properly formatted...
                    self.rec['image'] = ImageExtras.get_string_from_image(img)
                else:
                    print "ODD: we got no image from ",self.rec['image'][:100]
                    print 'Deleting "image"'
                    del self.rec['image']
                    del self.rec['thumb']                    
        ## if we have an ID, we need to remember it for the converter
        if self.rec.has_key('id'):
            id_to_convert = self.rec['id']            
        else:
            id_to_convert = None
        if id_to_convert:
            if self.id_converter.has_key(self.rec['id']):
                self.rec['id']=self.id_converter[self.rec['id']]
                r = self.rd.add_rec(self.rec,accept_ids=True) # See doc on add_rec
            else:
                del self.rec['id']
                r =  self.rd.add_rec(self.rec)
                self.id_converter[id_to_convert] = r.id
        else:
            r = self.rd.add_rec(self.rec)
        # Add ingredients...
        for i in self.added_ings:
            if i.has_key('id'):
                print 'WARNING: Ingredient has ID set -- ignoring value'
                del i['id']
            i['recipe_id'] = r.id
        self.rd.add_ings(self.added_ings)
        self.added_ings = []
        # Update hash-keys...
        self.rd.update_hashes(r)
        tt.end()
        self.added_recs.append(r)
        if remembered_rating: self.rating_converter.add(r.id,remembered_rating)
        self.check_for_sleep()
        timeaction.end()
        self.rec_timer.end()
        self.count += 1
        if self.total:
            self.emit(
                'progress',
                float(self.count)/self.total,
                _("Imported %s of %s recipes.")%(self.count,self.total)
                )
                      
    def convert_str_to_num (self, str):
        """Return a numerical servings value"""
        timeaction = TimeAction('importer.convert_str_to_num',10)
        debug('converting servings for %s'%str,5)
        try:
            return float(str)
        except:
            conv = convert.frac_to_float(str)
            if conv: return conv
            m=re.match("([0-9/. ]+)",str)
            if m:
                num=m.groups()[0]
                try:
                    return float(num)
                except:
                    return convert.frac_to_float(num)
        timeaction.end()
            
    def start_ing (self, **kwargs):
        timeaction = TimeAction('importer.start_ing',10)
        #gt.gtk_update()
        self.ing=kwargs
        #if self.ing.has_key('id'):
        #    self.ing['recipe_id']=self.ing['id']
        #    del self.ing['id']
        #    print 'WARNING: setting ingredients ID is deprecated. Assuming you mean to set recipe_id'
        #elif self.rec.has_key('id'):
        #    self.ing['recipe_id']=self.rec['id']
        #debug('ing ID %s, recipe ID %s'%(self.ing['recipe_id'],self.rec['id']),0)
        timeaction.end()

    def finish_ing (self):
        timeaction = TimeAction('importer.finish_ing 1',10)
        # Strip whitespace...
        for key in ['item','ingkey','unit']:
            if self.ing.has_key(key):
                self.ing[key]=re.sub('\s+',' ',self.ing[key]).strip()
        if not (
            (self.ing.has_key('refid') and
             self.ing['refid'])
            or
            (self.ing.has_key('ingkey') and
             self.ing['ingkey'])
            ):
            #self.ing['ingkey']=self.km.get_key(self.ing['item'],0.9)
            if self.ing.has_key('item'):
                self.ing['ingkey']=self.km.get_key_fast(self.ing['item'])
            else:
                debug('Ingredient has no item! %s'%self.ing,-1)
        timeaction.end()
        # if we have an amount (and it's not None), let's convert it
        # to a number
        if self.ing.has_key('amount') and self.ing['amount']\
               and not self.ing.has_key('rangeamount'):
            if convert.RANGE_MATCHER.search(str(self.ing['amount'])):
                self.ing['amount'],self.ing['rangeamount']=parse_range(self.ing['amount'])
        if self.ing.has_key('amount'):
            self.ing['amount']=convert.frac_to_float(
                self.ing['amount']
                )
        if self.ing.has_key('rangeamount'):
            self.ing['rangeamount']=convert.frac_to_float(
                self.ing['rangeamount']
                )
        timeaction = TimeAction('importer.commit_ing 2',10)
        if not (self.ing.has_key('position') and self.ing['position']):
            self.ing['position']=self.position
            self.position+=1
        timeaction.end()
        timeaction = TimeAction('importer.commit_ing 3',10)
        if self.group:
            self.ing['inggroup']=self.group
        timeaction.end()
        timeaction = TimeAction('importer.commit_ing 4',10)
        self.added_ings.append(self.ing); self.ing = {}
        timeaction.end()

    commit_ing = finish_ing
        
    def add_amt (self, amount):
        timeaction = TimeAction('importer.add_amt',10)
        """We should NEVER get non-numeric amounts.
        Amounts must contain [/.0-9 ] e.g. 1.2 or 1 1/5
        or 1/3 etc."""
        #gt.gtk_update()
        self.ing['amount'],self.ing['rangeamount']=parse_range(amount)
        timeaction.end()

    def add_ref (self, id):
        timeaction = TimeAction('importer.add_ref',10)
        if not self.id_converter.has_key(id):
            self.id_converter[id]=self.rd.new_id()
        self.ing['refid']=self.id_converter[id]
        self.ing['unit']='recipe'
        timeaction.end()

    def add_item (self, item):
        timeaction = TimeAction('importer.add_item',10)        
        itm=str(item.strip())
        itm=itm.replace("\n"," ")
        self.ing['item']=itm
        timeaction.end()
        
    def add_unit (self, unit):
        timeaction = TimeAction('importer.add_unit',10)
        self.ing['unit']=str(unit.strip())
        timeaction.end()

    def add_key (self, key):
        timeaction = TimeAction('importer.add_key',10)
        self.ing['ingkey']=str(key.strip())
        timeaction.end()

    def terminate (self):
        timeaction = TimeAction('importer.terminate',10)
        debug('Terminate!',0)
        self.terminated = True
        timeaction.end()

    def suspend (self):
        timeaction = TimeAction('importer.suspend',10)
        debug('Suspend!',0)
        self.suspended = True
        timeaction.end()
        print_timer_info()

    def resume (self):
        debug('Resume!',0)
        self.suspended = False

NUMBER_REGEXP = convert.NUMBER_REGEXP
simple_matcher = re.compile(
    '(%(NUMBER_REGEXP)s+)\s*/\s*([\d]+)'%locals()
    )

def parse_range (number_string):
    """Parse a range and return a tuple with a low and high number as floats.

    We will also parse regular numbers, in which case the tuple will
    only have one item.
    """
    if type(number_string) in [int,float]:
        return (float(number_string),None)
    nums=convert.RANGE_MATCHER.split(number_string.strip())
    if len(nums) > 2:
        debug('WARNING: String %s does not appear to be a normal range.'%number_string,0)
        retval = map(convert.frac_to_float,nums)
        # filter any non-numbers before we take 1 and 3
        retval = filter(lambda x: x, retval)        
        if len(retval) > 2:
            debug('Parsing range as %s-%s'%(retval[0],retval[-1]),0)
            retval = retval[0],retval[-1]
    else:
        retval = map(convert.frac_to_float,nums)
    if len(retval)==2: return tuple(retval)
    elif len(retval)==1: return tuple(retval+[None])
    else: return (None,None)
        
class Tester:
    def __init__ (self, regexp):
        self.regexp = regexp

    def test (self, filename):
        if not hasattr(self,'matcher'):
            # only compile our regexp when necessary
            self.matcher = re.compile(self.regexp)
        CLOSE=False
        if type(filename)==str:
            self.ofi = open(filename,'r')
            CLOSE=True
        else: self.ofi=filename
        l = self.ofi.readline()
        while l:
            if self.matcher.match(l):
                self.ofi.close()
                return True
            l = self.ofi.readline()
        if CLOSE:
            self.ofi.close()
        else:
            self.ofi.seek(0)
            
class RatingConverter:

    """A class to handle converting ratings from strings to integers.

    This is here since many of our imports will grab ratings for us in
    the form of 'excellent' or some such, and we'll want to let our
    user convert those to stars as they see fit.
    """
    
    conversions = {'excellent':10,
                   'great':8,
                   'good':6,
                   'fair':4,
                   'okay':4,
                   'poor':2,
                   _('excellent').lower():10,
                   _('great').lower():8,
                   _('good').lower():6,
                   _('fair').lower():4,
                   _('okay').lower():4,
                   _('poor').lower():2,
                   }
    
    def __init__ (self):
        self.to_convert = {}
        self.got_conversions = False

    def add (self, id, rating):
        if type(rating)==int:
            raise Exception("Why do you need me? id: %(id)s rating: %(rating)s" % locals())
        self.to_convert[id]=rating

    def get_conversions (self, star_generator=None):
        """Get our conversions.

        If necessary, ask user to convert for us.
        """
        self.got_conversions=True
        if not star_generator:
            from gourmet.gtk_extras.ratingWidget import star_generator
        ratings = []
        need_conversions = False
        for v in self.to_convert.values():
            if not need_conversions and not self.conversions.has_key(v.lower()):
                need_conversions = True
            if v not in ratings:
                ratings.append(v)
                conv = string_to_rating(v)
                if conv: self.conversions[v] = conv
        if need_conversions:
            self.conversions = de.get_ratings_conversion(ratings,star_generator,defaults=self.conversions)

    def do_conversions (self, db):
        if not self.got_conversions:
            self.get_conversions()
        for id,rating in self.to_convert.items():
            try:
                if not self.conversions.has_key(rating) and hasattr(rating,'lower') and self.conversions.has_key(rating.lower()):
                    rating = rating.lower()
                db.modify_rec(db.get_rec(id),{'rating':self.conversions[rating]})
            except:
                print 'wtf... problem with rating ',rating,'for recipe',id
                raise

import unittest

class RatingConverterTest (unittest.TestCase):

    def setUp (self):

        class FakeDB:

            recs = dict([(n,{}) for n in range(20)])
            
            def get_rec (self, n): return n
            def modify_rec (self, n, d):
                for attr,val in d.items(): self.recs[n][attr]=val

        self.db = FakeDB()

    def testAutomaticConverter (self):
        rc = RatingConverter()
        tests = ['good','Great','Excellent','poor','okay']
        for n,rating in enumerate(tests):
            rc.add(n,rating)
            self.db.recs[n]['rating']=rating
        total = n
        rc.do_conversions(self.db)
        print 'Conversions: '
        for n,rating in enumerate(tests):
            print 'Converted',rating,'->',self.db.recs[n]['rating']

    def testInteractiveConverter (self):
        rc = RatingConverter()
        tests = ['alright','pretty good','funny tasting',
                 'okeydokey','not bad','damn good.']
        for n,rating in enumerate(tests):
            rc.add(n,rating)
            self.db.recs[n]['rating']=rating
        total = n
        rc.do_conversions(self.db)
        #print 'Conversions: '
        #for n,rating in enumerate(tests):
        #    print 'Converted',rating,'->',self.db.recs[n]['rating']

    def testStringToRatingConverter (self):
        assert(string_to_rating('4/5 stars')==8)
        assert(string_to_rating('3 1/2 / 5 stars')==7)
        assert(string_to_rating('4/10 stars')==4)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = importManager
import gourmet.plugin_loader as plugin_loader
from gourmet.plugin import ImporterPlugin, ImportManagerPlugin
import gourmet.gtk_extras.dialog_extras as de
from gourmet.recipeManager import default_rec_manager
import os.path
from fnmatch import fnmatch
from gourmet.threadManager import get_thread_manager, get_thread_manager_gui, NotThreadSafe
from webextras import URLReader
import tempfile
from gettext import gettext as _

class ImportFileList (Exception):
    """A special case error -- if an importer throws this error
    instead of returning an importer, our importer will import the
    list of files returned... This is basically a thread-safe way
    around the problem of how to let an importer initiate other
    imports (for zip files etc)"""
    def __init__ (self, filelist):
        self.filelist = filelist

class ImportManager (plugin_loader.Pluggable):

    '''A class to
    manage importers.
    '''

    __single = None

    def __init__ (self):
        if ImportManager.__single: raise ImportManager.__single
        else: ImportManager.__single = self
        self.tempfiles = {}
        self.extensions_by_mimetype = {}
        self.plugins_by_name = {}
        self.plugins = []
        self.importer_plugins = []
        plugin_loader.Pluggable.__init__(self,
                                         [ImporterPlugin,
                                          ImportManagerPlugin]
                                         )
        self.get_app_and_prefs()

    def get_app_and_prefs (self):
        from gourmet.GourmetRecipeManager import get_application
        self.app = get_application()
        self.prefs = self.app.prefs

    def offer_web_import (self, parent=None):
        """Offer to import a URL.

        Once the file is downloaded, it can be treated by any of our
        normal plugins for acting on files, or by special web-aware
        plugins.
        """
        sublabel = _('Enter the URL of a recipe archive or recipe website.')
        url = de.getEntry(label=_('Enter website address'),
                          sublabel=sublabel,
                          entryLabel=_('Enter URL:'),
                          entryTip=_('Enter the address of a website or recipe archive.'),
                          default_character_width=60,
                          )
        if not url: return
        else: return self.import_url(url)

    def import_url (self, url):
        if url.find('//')<0:
            url = 'http://'+url
        reader = URLReader(url)
        reader.connect('completed',
                       self.finish_web_import)
        self.setup_thread(reader,'Downloading %s'%url, connect_follow_up=False)

    def finish_web_import (self, reader):
        # Filter by mimetype...
        if reader.content_type:
            base_content_type=reader.content_type.split(';')[0]
            possible_plugins = filter(
                lambda p: base_content_type in p.mimetypes,
                self.importer_plugins)
        else:
            possible_plugins = self.importer_plugins
        fallback = None; plugin = None
        for p in possible_plugins:
            result = p.test_url(reader.url,reader.data,reader.content_type)
            if result == -1:
                fallback = p
            elif result:
                plugin = p
                break
        if not plugin:
            plugin = fallback
        if not plugin:
            de.show_message(
                title=_('Unable to import URL'),
                label=_('Gourmet does not have a plugin capable of importing URL'),
                sublabel=_('Unable to import URL %(url)s of mimetype %(type)s. File saved to temporary location %(fn)s')%{
                'url':reader.url,
                'type':reader.content_type or 'Unknown',
                'fn':self.get_tempfilename(reader.url,reader.data,reader.content_type)
                },
                )
        else:
            print 'Doing import of',reader.url,plugin
            self.do_import(plugin,'get_web_importer',reader.url,reader.data,reader.content_type)

    def offer_import (self, parent=None):
        """Offer to import a file or group of files.

        Begin the import if we can in a separate dialog.
        """
        filenames = de.select_file(_('Open recipe...'),                                           
                                   filters=self.get_filters(),
                                   parent=parent,
                                   select_multiple = True
                                   )
        if not filenames: return
        self.import_filenames(filenames)
        
    def import_filenames (self, filenames):
        """Import list of filenames, filenames, based on our currently
        registered plugins.

        Return a list of importers (mostly useful for testing purposes)
        """
        importers = []
        while filenames:
            fn = filenames.pop()
            fallback = None
            found_plugin = False
            for plugin in self.importer_plugins:
                for pattern in plugin.patterns:
                    if fnmatch(fn.upper(),pattern.upper()):
                        result = plugin.test_file(fn)
                        if result==-1: # FALLBACK
                            fallback = plugin
                        elif result:
                            importers.append((fn,plugin))
                            found_plugin = True
                        else:
                            print 'File ',fn,'appeared to match ',plugin,'but failed test.'
                        break
                if found_plugin: break
            if not found_plugin:
                if fallback:
                    importers.append((fn,fallback))
                else:
                    print 'Warning, no plugin found for file ',fn
        ret_importers = [] # a list of importer instances to return
        for fn,importer_plugin in importers:
            print 'Doing import for ',fn,importer_plugin
            ret_importers.append(
                self.do_import(importer_plugin,'get_importer',fn)
                )
        print 'import_filenames returns',ret_importers
        return ret_importers

    def do_import (self, importer_plugin, method, *method_args):
        '''Import using importer_plugin.method(*method_args)
        '''
        try:
            importer = getattr(importer_plugin,method)(*method_args)
        except ImportFileList, ifl:
            # recurse with new filelist...
            return self.import_filenames(ifl.filelist)
        else:
            if hasattr(importer,'pre_run'):
                importer.pre_run()
            if isinstance(importer,NotThreadSafe):
                #print 'Running manually --- not threadsafe!'
                importer.run()
                self.follow_up(None,importer)
            else:
                label = _('Import') + ' ('+importer_plugin.name+')'
                self.setup_thread(importer, label)
            print 'do_importer returns importer:',importer
            return importer
                
    @plugin_loader.pluggable_method
    def follow_up (self, threadmanager, importer):
        if hasattr(importer,'post_run'):
            importer.post_run()
        if hasattr(self,'app'):
            self.app.make_rec_visible()                        

    def setup_thread (self, importer, label, connect_follow_up=True):
        tm = get_thread_manager()
        tm.add_thread(importer)
        tmg = get_thread_manager_gui()
        tmg.register_thread_with_dialog(label,
                                        _('Recipes successfully imported'),
                                        importer)
        tmg.show()
        if connect_follow_up:
            importer.connect('completed',
                             self.follow_up,
                             importer
                             )
        
    def get_importer (self, name):
        return self.plugins_by_name[name]

    def get_tempfilename (self, url, data, content_type):
        if self.tempfiles.has_key(url):
            return self.tempfiles[url]
        else:
            fn = url.split('/')[-1]
            if '.' in fn:
                ext = fn.split('.')[-1]
            elif content_type:
                ext = self.guess_extension(content_type)
        if ext:
            tf = tempfile.mktemp('.'+ext)
        else:
            tf = tempfile.mktemp()
        self.tempfiles[url] = tf
        ofi = open(tf,'w')
        ofi.write(data)
        ofi. close()
        return self.tempfiles[url]

    def guess_extension (self, content_type):
        if self.extensions_by_mimetype.has_key(content_type):
            answers = self.extensions_by_mimetype[content_type].items()
            answers.sort(lambda a,b: cmp(a[1],b[1])) # sort by count...
            return answers[-1][0] # Return the most frequent
        else:
            import mimetypes
            return mimetypes.guess_extension(content_type)
        
    def get_filters (self):
        all_importable_mimetypes = []
        all_importable_patterns = []
        filters = []; names = []
        for plugin in self.importer_plugins:
            if plugin.name in names:
                i = names.index(plugin.name)
                filters[i][1] += plugin.mimetypes
                filters[i][2] += plugin.patterns
            else:
                names.append(plugin.name)
                filters.append([plugin.name,plugin.mimetypes,plugin.patterns])
            all_importable_mimetypes += plugin.mimetypes
            all_importable_patterns += plugin.patterns
        filters = [[_('All importable files'),all_importable_mimetypes,all_importable_patterns]] + filters
        return filters

    def register_plugin (self, plugin):
        self.plugins.append(plugin)
        if isinstance(plugin,ImporterPlugin):
            name = plugin.name
            if self.plugins_by_name.has_key(name):
                print 'WARNING','replacing',self.plugins_by_name[name],'with',plugin
            self.plugins_by_name[name] = plugin
            self.learn_mimetype_extension_mappings(plugin)
            self.importer_plugins.append(plugin)
        

    def learn_mimetype_extension_mappings (self, plugin):
        for mt in plugin.mimetypes:
            if not self.extensions_by_mimetype.has_key(mt):
                self.extensions_by_mimetype[mt] = {}
            for ptrn in plugin.patterns:
                if ptrn.find('*.')==0:
                    ext = ptrn.split('.')[-1]
                    if ext.isalnum():
                        # Then increment our count for this...
                        self.extensions_by_mimetype[mt][ext] = self.extensions_by_mimetype[mt].get(ext,0) + 1

    def unregister_plugin (self, plugin):
        if isinstance(plugin,ImporterPlugin):
            name = plugin.name
            if self.plugins_by_name.has_key(name):
                del self.plugins_by_name[name]
                self.plugins.remove(plugin)
            else:
                print 'WARNING: unregistering ',plugin,'but there seems to be no plugin for ',name
        else:
            self.plugins.remove(plugin)
    
def get_import_manager ():
    try:
        return ImportManager()
    except ImportManager, im:
        return im
    
if __name__ == '__main__':
    im = ImportManager()
    im.offer_import()
    gtk.main()

########NEW FILE########
__FILENAME__ = interactive_importer
import gtk, pango
from xml.sax.saxutils import escape
from gettext import gettext as _
from generic_recipe_parser import RecipeParser
import gourmet.gtk_extras.cb_extras as cb
import gourmet.gglobals as gglobals
import importer
import re
import gourmet.convert as convert
from gourmet.threadManager import NotThreadSafe
import imageBrowser
import gourmet.ImageExtras as ImageExtras
from gettext import gettext as _
# TODO
# 1. Make this interface actually import recipes...
# 2. Add drop-down menu buttons in place of red labels to make it
#    trivial to change the label of something labelled.
# 3. Remove button-hell interface and come up with something cleaner
#    and more attractive.
# 4. Add Undo support to editing (ugh -- this will be a PITA)

DEFAULT_TAGS = []
DEFAULT_TAG_LABELS = gglobals.REC_ATTR_DIC.copy()
DEFAULT_TAG_LABELS.update(gglobals.TEXT_ATTR_DIC)

for attr in gglobals.DEFAULT_ATTR_ORDER:
    if attr != 'link':
        DEFAULT_TAGS.append(attr)
        if attr == 'yields':
            # a bit of a hack -- we want to make 'yield unit' a button
            DEFAULT_TAGS.append('yield_unit')
            DEFAULT_TAGS.append('servings')
            
DEFAULT_TAGS.extend(gglobals.DEFAULT_TEXT_ATTR_ORDER)

DEFAULT_TAGS.extend(['ingredients','inggroup','ignore'])
for tag,label in [
    ('servings',_('Servings')),
    ('ingredients',_('Ingredients')),
    ('inggroup',_('Ingredient Subgroup')),
    ('ignore',_('Hide'))
    ]:
    if not DEFAULT_TAG_LABELS.has_key(tag):
        DEFAULT_TAG_LABELS[tag] = label

UI_TAG_ORDER = [
    (_('Description'),[
        ('title','servings'),
        ('yields','yield_unit'),
        ('source','rating'),
        ('category','cuisine'),
        ('preptime','cooktime')]),
    (_('Text'),[('instructions','modifications')]),
    (_('Ingredients'),[('ingredients','inggroup')]),
    (_('Actions'),[('ignore','clear'),
                   ('newrec',)]),
    ]

class ConvenientImporter (importer.Importer):
    """Add some convenience methods to our standard importer.
    """
    def add_attribute (self, attname, txt):
        txt=txt.strip()
        if self.rec.has_key(attname):
            self.rec[attname] = self.rec[attname] + ', ' + txt
        else:
            self.rec[attname] = txt

    def add_text (self, attname, txt):
        if self.rec.has_key(attname):
            self.rec[attname] = self.rec[attname] + '\n' + txt
        else:
            self.rec[attname] = txt

    def add_ing_group (self, txt):
        self.group = txt.strip()

    def add_ing_from_text (self, txt):
        if not hasattr(self,'db'):
            import gourmet.backends.db as db
            self.db = db.get_database()
        parsed_dict = self.db.parse_ingredient(txt)
        self.ing = parsed_dict
        self.commit_ing()

    def add_ings_from_text (self, txt, break_at='\n'):
        """Add list of ingredients from block of text.

        By default, there is one ingredient per line of text."""
        txt=txt.strip()
        for i in txt.split(break_at):
            self.add_ing_from_text(i.strip())

class InteractiveImporter (ConvenientImporter, NotThreadSafe):

    NEW_REC_TEXT = _('New Recipe')

    def __init__ (self,
                  custom_parser = None,
                  tags=DEFAULT_TAGS,
                  tag_labels=DEFAULT_TAG_LABELS,
                  modal=True,
                  title=_('Import recipe')):
        self.title = title
        if custom_parser: self.parser = custom_parser
        else: self.parser = RecipeParser()
        self.labels_by_tag = tag_labels
        self.tags_by_label = {self.NEW_REC_TEXT:'newrec'}
        for k,v in self.labels_by_tag.items(): self.tags_by_label[v]=k
        self.tags = tags
        self.setup_window()
        self.setup_action_area()
        self.markup_marks = {}; self.markup_partners = {}
        self.anchors = []
        self.midno = 0 # an ID counter for markup marks we insert 
        self.labelled = []
        self.label_counts = {}
        self.modal = modal # If we're in an embedded gtk mainloop...
        ConvenientImporter.__init__(self)
        
    def setup_window (self):
        # set our parent...
        from gourmet.threadManager import get_thread_manager_gui
        import gourmet.GourmetRecipeManager
        tmg = get_thread_manager_gui()
        self.w = gtk.Window();
        self.w.set_title(self.title)
        main_app = gourmet.GourmetRecipeManager.get_application()
        self.w.set_transient_for(main_app.window)
        self.w.set_destroy_with_parent(False)
        self.hb = gtk.HBox()
        self.w.add(self.hb)
        self.tv = gtk.TextView()
        self.tv.set_size_request(600,500)
        self.tv.set_wrap_mode(gtk.WRAP_WORD)
        self.action_area = gtk.VBox()
        sw = gtk.ScrolledWindow(); sw.add(self.tv)
        sw.set_policy(gtk.POLICY_NEVER,gtk.POLICY_AUTOMATIC)
        self.hb.add(sw); sw.show(); self.tv.show()
        self.hb.pack_end(self.action_area,expand=False); self.action_area.show()
        self.tb = self.tv.get_buffer()
        self.setup_tags()

    def setup_action_area (self):
        # Set up hard-coded functional buttons...
        self.new_recipe_button = gtk.Button(_('_New Recipe'))
        self.new_recipe_button.connect('clicked',self.new_recipe_cb)
        self.remove_markup_button = gtk.Button(_('Clear _Tags'))
        self.remove_markup_button.connect('clicked',self.clear_tags)
        # Set up ActionModel (used for drop-down menu version of these commands)
        self.action_model = gtk.ListStore(str,str)
        action_table = gtk.Table()
        self.action_area.pack_start(action_table,expand=False)
        r = 0 #rownum
        # Get our UI layout from UI_TAG_ORDER
        for label,rows in UI_TAG_ORDER:
            if r != 0:
                blank = gtk.Label('')
                action_table.attach(blank,0,2,r,r+1);blank.show()
            r += 1                
            l = gtk.Label(); l.set_markup('<b>'+label+'</b>')
            l.set_alignment(0.0,0.5)
            action_table.attach(l,0,2,r,r+1); l.show()
            r += 1
            for row in rows:
                for c,t in enumerate(row): #column number, tag
                    if t == 'clear':
                        tag_button = self.remove_markup_button
                    elif t=='newrec':
                        tag_button = self.new_recipe_button
                    else:
                        tag_button = gtk.Button('_'+self.labels_by_tag[t])
                        self.action_model.append([self.labels_by_tag[t],t])
                        tag_button.connect('clicked',
                                           self.label_callback,
                                           self.labels_by_tag[t])
                    action_table.attach(
                        tag_button,
                        c,c+1,r,r+1,
                        xpadding=12,
                        )
                r += 1
        action_table.set_row_spacings(3)
        action_table.set_col_spacings(3)
        #for t in self.tags:
        #    
        #    self.action_model.append([self.labels_by_tag[t],t])
        #    tag_button = gtk.Button('_'+self.labels_by_tag[t])
        #    tag_button.connect('clicked',
        #                       self.label_callback,
        #                       self.labels_by_tag[t])
        #    self.action_area.pack_start(tag_button,expand=False,fill=False,padding=6)
        #    tag_button.show()
        #
        self.import_button = gtk.Button(_('Import Recipe'))
        self.import_button.connect('clicked',
                                      lambda *args: self.commit_changes())
        self.import_button.set_alignment(0.5,1.0)
        self.action_area.pack_end(self.import_button,fill=False,expand=False)
        self.action_area.show_all()

    def setup_tags (self):
        self.markup_tag = gtk.TextTag('markup')
        self.markup_tag.set_property('editable',False)
        self.markup_tag.set_property('scale',pango.SCALE_SMALL)
        self.markup_tag.set_property('rise',15)
        self.markup_tag.set_property('foreground',
                                     '#f00'
                                     )
        self.ignore_tag = gtk.TextTag('ignore')
        self.ignore_tag.set_property('invisible',True)
        self.ignore_tag.set_property('editable',False)
        self.tb.get_tag_table().add(self.markup_tag)
        self.tb.get_tag_table().add(self.ignore_tag)        
        
    def label_callback (self, button, label):
        self.label_selection(label)

    def label_selection (self, label):
        cursel = self.tb.get_selection_bounds()
        if cursel:
            st,end = cursel
        else:
            # Otherwise, there's no clear sane default... we'll just
            # select the current whole line
            cur_mark = self.tb.get_insert()
            cur_pos=gtk.TextBuffer.get_iter_at_mark(cur_pos)
            cur_pos.backward_chars(
                cur_pos.get_line_offset())
            st = cur_pos
            end = cur_pos.copy()
            end = cur_pos.forward_line()
        self.label_range(st,end,label)

    def insert_with_label (self, st, text, label):
        start_offset = st.get_offset()
        self.tb.insert(st,text)
        end_offset = start_offset + len(text)
        self.label_range(
            self.tb.get_iter_at_offset(start_offset),
            self.tb.get_iter_at_offset(end_offset),
            label
            )

    def unhide_area (self, midno):
        st,end = self.markup_marks[midno]
        self.tb.remove_tag(self.ignore_tag,
                           self.tb.get_iter_at_mark(st),
                           self.tb.get_iter_at_mark(end)
                           )

    def hide_range (self, st, end):
        """Hide text between start and end.

        Return midno that can be used to unhide the range."""
        midno = self.midno; self.midno += 1
        start_mark = gtk.TextMark('start-markup-%s'%midno,False)
        end_mark = gtk.TextMark('end-markup-%s'%midno,True)
        self.tb.apply_tag(self.ignore_tag,
                       st,end)
        self.tb.add_mark(start_mark,st)
        self.tb.add_mark(end_mark,end)
        self.markup_marks[midno] = (start_mark,end_mark)
        return midno

    def label_range (self, st, end, label):
        if self.tags_by_label.get(label,'')=='ignore':
            midno = self.hide_range(st,end)
            b = gtk.Button('Ignored text: Reveal hidden text')
            anchor = self.insert_widget(end,b)
            def unhide_text (*args):
                self.unhide_area(midno)
                self.remove_widget(anchor)
            b.connect('clicked',unhide_text)
            b.show()
            return
        if self.label_counts.has_key(label):
            count = self.label_counts[label]
            self.label_counts[label] += 1
        else:
            self.label_counts[label] = 1
            count = 0
        smark = gtk.TextMark(label+'-'+str(count)+'-start',True)
        emark = gtk.TextMark(label+'-'+str(count)+'-end',False)
        self.tb.add_mark(smark,st)
        self.tb.add_mark(emark,end)
        self.labelled.append((smark,emark))
        # Now we add the labels...
        start_txt = '['
        start_id = self.insert_markup_text(st,start_txt,self.markup_tag)
        # Now move the mark back up...
        new_pos = self.tb.get_iter_at_mark(smark); new_pos.forward_chars(len(start_txt))
        self.tb.move_mark(smark,new_pos)
        # Create a "Remove me" button
        #b = gtk.Button('_Remove tag'); b.show)(
        b = gtk.Button()
        i = gtk.Image(); i.set_from_stock(gtk.STOCK_REMOVE,gtk.ICON_SIZE_MENU)
        b.add(i); i.show()
        itr = self.tb.get_iter_at_mark(emark)        
        anchor = self.insert_widget(itr,b)
        # Set up combo button...
        labelbutton = gtk.combo_box_new_text()
        labelbutton.set_model(self.action_model)
        cb.cb_set_active_text(labelbutton,label)
        anchor2 = self.insert_widget(self.tb.get_iter_at_mark(smark),labelbutton)
        # Add final bracket for end of markup
        end_bracket_itr = self.tb.get_iter_at_mark(emark)
        end_id = self.insert_markup_text(end_bracket_itr,']',self.markup_tag)
        self.markup_partners[start_id]=end_id; self.markup_partners[end_id]=start_id
        # Now back up our itr one character (it got advanced by adding
        # the right bracket and the button)
        eitr = self.tb.get_iter_at_mark(emark)
        eitr.backward_chars(2)
        self.tb.move_mark(emark,eitr)
        # Define callback to remove our text when button is clicked
        def remove_markup (*args):
            self.labelled.remove((smark,emark))
            self.remove_markup_text(start_id)
            self.remove_markup_text(end_id)
            self.remove_widget(anchor)
            self.remove_widget(anchor2)
        def change_mark (cb):
            # copy marks for safekeeping...
            new_text = cb.get_active_text()
            sm = gtk.TextMark(None,True)
            self.tb.add_mark(sm,self.tb.get_iter_at_mark(smark))
            em = gtk.TextMark(None,False)
            self.tb.add_mark(em,self.tb.get_iter_at_mark(emark))
            # remove old marks...
            remove_markup()
            # And relabel!
            self.label_range(
                self.tb.get_iter_at_mark(sm),
                self.tb.get_iter_at_mark(em),
                new_text
                )
        labelbutton.connect('changed',change_mark)
        b.connect('clicked',remove_markup)

    def new_recipe_cb (self, *args):
        # Start a new recipe at cursor
        itr = self.tb.get_iter_at_mark(self.tb.get_insert())
        self.label_range(itr,itr,self.NEW_REC_TEXT)
        
    def insert_markup_text (self, itr, text, *tags):
        """Insert markup text into the buffer. We do this in such a
        way that we can remove it easily later.
        """
        midno = self.midno; self.midno += 1
        start_mark = gtk.TextMark('start-markup-%s'%midno,False)
        end_mark = gtk.TextMark('end-markup-%s'%midno,True)
        start_offset = itr.get_offset()
        if tags:
            self.tb.insert_with_tags(itr,text,*tags)
        else:
            self.tb.insert(itr,text)
        self.tb.add_mark(start_mark,self.tb.get_iter_at_offset(start_offset))
        end_offset = start_offset + len(text)
        end_itr = self.tb.get_iter_at_offset(end_offset)
        self.tb.add_mark(end_mark,end_itr)
        self.markup_marks[midno] = (start_mark,end_mark)
        return midno

    def change_mark (self, cb, smark, emark, start_id, end_id):

        new_label = cb.get_active_text()
        
        
    def insert_widget (self, itr, widget):
        anchor = self.tb.create_child_anchor(itr)
        self.anchors.append(anchor)
        self.tv.add_child_at_anchor(widget,anchor)
        widgetstart = self.tb.get_iter_at_child_anchor(anchor)
        widgetend = widgetstart.copy(); widgetend.forward_char()
        self.tb.apply_tag(self.markup_tag,widgetstart,widgetend)
        widget.show()
        return anchor

    def remove_widget (self, anchor):
        anchor_iter = self.tb.get_iter_at_child_anchor(anchor)
        delete_to = anchor_iter.copy()
        delete_to.forward_char()
        self.tb.delete(anchor_iter,delete_to)
        
    def remove_markup_text (self, idno):
        smark,emark = self.markup_marks[idno]
        sitr,eitr = (self.tb.get_iter_at_mark(smark),
                     self.tb.get_iter_at_mark(emark))
        self.tb.delete(sitr,eitr)

    def clear_tags (self, *args):
        """Clear all markup in current selection, or whole buffer if
        there is no selection
        """
        cursel = self.tb.get_selection_bounds()
        if cursel:
            st,end = cursel
        else:
            st,end = self.tb.get_bounds()
        st_offset = st.get_offset()
        e_offset = end.get_offset()
        for idno,iters in self.markup_marks.items():
            lst,lend = iters
            if ((e_offset > self.tb.get_iter_at_mark(lst).get_offset() > st_offset)
                or
                (e_offset > self.tb.get_iter_at_mark(lend).get_offset() > st_offset)):
                self.remove_markup_text(idno)
                if self.markup_partners.has_key(idno):
                    self.remove_markup_text(self.markup_partners[idno])
        for lst,lend in self.labelled[:]:
            if ((e_offset > self.tb.get_iter_at_mark(lst).get_offset() > st_offset)
                or
                (e_offset > self.tb.get_iter_at_mark(lend).get_offset() > st_offset)):
                self.labelled.remove((lst,lend))
        for anchor in self.anchors[:]:
            anchor_iter = self.tb.get_iter_at_child_anchor(anchor)
            if e_offset > anchor_iter.get_offset() > st_offset:
                self.anchors.remove(anchor)
                self.remove_widget(anchor)
        
    def commit_changes (self):
        def mark_sorter (a,b):
            a = self.tb.get_iter_at_mark(a[0]).get_offset()
            b = self.tb.get_iter_at_mark(b[0]).get_offset()
            return cmp(a,b)
        self.labelled.sort(mark_sorter)
        if not self.labelled: return
        self.start_rec()
        started = False
        for smark,emark in self.labelled:
            siter = self.tb.get_iter_at_mark(smark)
            eiter = self.tb.get_iter_at_mark(emark)
            text = siter.get_text(eiter)
            name = smark.get_name()
            label = name.split('-')[0]
            tag = self.tags_by_label[label]            
            if tag in gglobals.TEXT_ATTR_DIC:
                self.add_text(tag,text); started=True
            elif tag in gglobals.REC_ATTR_DIC:
                if text: self.add_attribute(tag,text)
            elif tag == 'ingredient':
                if text: self.add_ing_from_text(text); started=True
            elif tag == 'ingredients':
                if text: self.add_ings_from_text(text); started=True
            elif tag == 'inggroup':
                if text: self.add_ing_group(text); started=True
            elif tag=='newrec':
                if not started: continue
                # Then we're starting a new recipe at this point...
                # Commit old recipe...
                self.commit_rec(); started=False
                # Start new one...
                self.start_rec()
            elif tag=='ignore':
                continue
            elif tag == 'servings':
                self.add_attribute('yields',text)
                self.add_attribute('yield_unit','servings')
            else:
                try:
                    print 'UNKNOWN TAG',tag,text,label
                except UnicodeError:
                    print 'UNKNOWN TAG (unprintable)'
        if started: self.commit_rec()
        if hasattr(self,'images') and self.images:
            # This is ugly -- we run the dialog once per recipe. This
            # should happen rarely in current use-case (I don't know
            # of a usecase where many recipes will come from a single
            # text document / website); if in fact this becomes a
            # common usecase, we'll need to rework the UI here.
            for rec in self.added_recs:
                ibd = imageBrowser.ImageBrowserDialog(
                    title=_('Select recipe image'),
                    label=_('Select image for recipe "%s"')%escape(rec.title or _('Untitled')),
                    sublabel=_("Below are all the images found for the page you are importing. Select any images that are of the recipe, or don't select anything if you don't want any of these images."),
                    )
                for i in self.images: ibd.add_image_from_uri(i)
                ibd.run()
                if ibd.ret:
                    ifi = file(imageBrowser.get_image_file(ibd.ret),'r')
                    image_str = ifi.read(); ifi.close()
                    image = ImageExtras.get_image_from_string(image_str)
                    # Adding image!
                    thumb = ImageExtras.resize_image(image,40,40)
                    self.rd.modify_rec(rec,{'image':ImageExtras.get_string_from_image(image),
                                            'thumb':ImageExtras.get_string_from_image(thumb),
                                            })
        if self.modal:
            self.w.hide()
            gtk.main_quit()

    def set_text (self, txt):
        txt = unicode(txt) # convert to unicode for good measure
        txt = re.sub('(\n\s*\n)+','\n\n',txt) # Take out extra newlines
        txt = self.parser.parse(txt) # Parse
        self.set_parsed(txt)

    def set_parsed (self, parsed):
        #dbg_file = file('/tmp/out','w')
        for chunk,tag in parsed:
            #dbg_file.write(chunk)
            if tag==None:
                self.tb.insert(self.tb.get_end_iter(),
                               chunk)
            else:
                self.insert_with_label(
                    self.tb.get_end_iter(),
                    chunk,
                    self.labels_by_tag.get(tag,tag)
                    )
        #dbg_file.close()
        
    def do_run (self):
        self.w.show_all()
        if self.modal:
            self.w.connect('delete-event',gtk.main_quit)
            gtk.main()
        else:
            self.w.connect('delete-event',lambda *args: self.w.hide())
        
    
            
if __name__ == '__main__':
    ii = InteractiveImporter()
    ii.w.connect('delete-event',gtk.main_quit)
    ii.w.show_all()
    if True:
        ii.images = ['http://thinkle.github.io/gourmet/images/screenshots/CardView.png']
        ii.set_text(
        u"""
Quick Pesto Dinner

Category: Quick, Easy, Summer
Yield: 2 Servings

Ingredients:
1-2 c. fresh basil
\xbc  cup minced fresh ginger (about 6 inches ginger root, peeled)
\xbc lb. whole-wheat spaghetti
1-2 fresh tomatoes

To accompany dish:
1 loaf bread
1 head garlic
1/4 c. olive oil

In a food processor, mix together the basil, oil and nuts and garlic, altering as you like to make the pesto nuttier, more garlicky, or more oily.

Meanwhile, boil a large pot of water and cook spaghetti.

Chop up tomatoes roughly.

Toss spaghetti in pesto and tomatoes.

Ignore: this
""")
    gtk.main()
    

########NEW FILE########
__FILENAME__ = plaintext_importer
import importer, re, string
from gourmet import check_encodings
from gourmet.gdebug import debug
from gettext import gettext as _

class TextImporter (importer.Importer):
    ATTR_DICT = {'Recipe By':'source',
                 'Serving Size':'servings',
                 'Preparation Time':'preptime',
                 'Categories':'category',
                 }

    end_of_paragraph_length = 60

    def __init__ (self, filename, conv=None):
        self.fn = filename
        self.rec = {}
        self.ing = {}
        self.compile_regexps()
        importer.Importer.__init__(self,conv=conv)

    def pre_run (self):
        self.lines = check_encodings.get_file(self.fn)
        self.total_lines = len(self.lines)
        print 'we have ',self.total_lines,'lines in file',self.fn
        
    def do_run (self):
        if not hasattr(self,'lines'):
            raise Exception("pre_run has not been run!")
        for n in range(self.total_lines):
            l=self.lines[n]
            if n % 15 == 0:
                prog = float(n)/float(self.total_lines)
                msg = _("Imported %s recipes.")%(len(self.added_recs))
                self.emit('progress',prog,msg)
            self.handle_line(l)
        # commit the last rec if need be
        if self.rec:
            self.commit_rec()
        importer.Importer.do_run(self)

    def handle_line (self):
        raise NotImplementedError

    def compile_regexps (self):
        self.blank_matcher = re.compile("^\s*$")
        # out unwrap regexp looks for a line with no meaningful characters, or a line that starts in
        # ALLCAPS or a line that is only space. (we use this with .split() to break text up into
        # paragraph breaks.
        self.unwrap_matcher = re.compile('\n\W*\n')
        self.find_header_breaks_matcher = re.compile('\s+(?=[A-Z][A-Z][A-Z]+:.*)')
        
    def unwrap_lines (self, blob):
        if blob.find("") >= 0:
            debug('Using built-in paragraph markers',1)
            # then we have paragraph markers in the text already
            outblob = string.join(blob.split("\n")," ") # get rid of line breaks
            lines = outblob.split("") # split text up into paragraphs
            outblob = string.join(lines,"\n") # insert linebreaks where paragraphs where
            return outblob
        outblob = ""
        newline = True
        for l in blob.split('\n'):
            debug('examining %s'%l,3)
            if re.match('^\W*$',l):
                # ignore repeated nonword characters (hyphens, stars, etc.)
                outblob += "\n"
                continue
            # if we have a non-word character at the start of the line,
            # we assume we need to keep the newline.
            if len(l)>=3 and re.match('(\W|[0-9])',l[2]):
                debug('Match non-word character; add newline before: %s'%l,4)
                outblob += "\n"
                outblob += l
                newline = False
                continue
            # if we are continuing an old line, we add a space
            # (because we're generally stripping all spaces when
            # we write)
            if not newline: outblob += " "
            hmatch = self.find_header_breaks_matcher.search(l)
            if hmatch:
                # if there's a header in the middle, we go ahead
                # and start a new line
                debug('Splitting at header in line: %s'%l,4)
                outblob += l[:hmatch.start()]
                outblob += "\n"
                outblob += l[hmatch.start():]
                continue
            #else...
            outblob += l.strip()
            if len(l) < self.end_of_paragraph_length: #60 is our hard-coded end-o-paragraph length
                debug('line < %s characters, adding newline.'%self.end_of_paragraph_length,4)
                outblob += "\n"
                newline = True
            else:
                newline = False
        return outblob
        
class Tester (importer.Tester):
    def __init__ (self):
        importer.Tester.__init__(self,regexp=MASTERCOOK_START_REGEXP)
        self.not_me = "<[?]?(xml|mx2|RcpE|RTxt)[^>]*>"

    def test (self, filename):
        """Test file named filename.

        filename can also be a file object.
        """
        if not hasattr(self,'matcher'):
            self.matcher=re.compile(self.regexp)
            self.not_matcher = re.compile(self.not_me)
        if type(self.ofi)==str: self.ofi = open(filename,'r')
        l = self.ofi.readline()
        while l:
            if self.not_matcher.match(l):
                self.ofi.close()
                return False
            if self.matcher.match(l):
                self.ofi.close()
                return True
            l = self.ofi.readline()
        self.ofi.close()

########NEW FILE########
__FILENAME__ = rezkonv_importer
# -*- coding: utf-8 -*-
import mealmaster_importer, plaintext_importer, re
import gourmet.convert as convert
from gourmet.gdebug import debug, TimeAction

class rezconf_constants (mealmaster_importer.mmf_constants):
    def __init__ (self):
        mealmaster_importer.mmf_constants.__init__(self)
        for k,v in {'Titel':'title',
                    'Kategorien':'category',
                    'Menge':'servings',
                    }.items():
            self.recattrs[k]=v
        for k,v in {}.items():
            self.unit_conv[k]=v
        self.unit_convr = {}
        for k,v in self.unit_conv.items():
            self.unit_convr[v]=k

rzc = rezconf_constants()
rzc_start_pattern=r"^(?i)([m=-][m=-][m=-][m=-][m=-]+)-*\s*(rezkonv).*"

class rezkonv_importer (mealmaster_importer.mmf_importer):
    # with long German words, you can end up with short lines in the middle
    # of a block of text, so we'll shorten the length at which we assume
    # a short line means the end of a paragraph.
    end_paragraph_length = 45
    
    def compile_regexps (self):
        """Compile our regular expressions for the rezkonv format.
        """
        testtimer = TimeAction('mealmaster_importer.compile_regexps',10)
        debug("start compile_regexps",5)
        plaintext_importer.TextImporter.compile_regexps(self)
        self.start_matcher = re.compile(rzc_start_pattern)
        self.end_matcher = re.compile("^[=M-][=M-][=M-][=M-][=M-]\s*$")
        self.group_matcher = re.compile("^\s*([=M-][=M-][=M-][=M-][=M-]+)-*\s*([^-]+)\s*-*",re.IGNORECASE)
        self.ing_cont_matcher = re.compile("^\s*[-;]")
        self.ing_opt_matcher = re.compile("(.+?)\s*\(?\s*optional\)?\s*$",re.IGNORECASE)
        # or or the German, oder
        self.ing_or_matcher = re.compile("^[-= ]*[Oo][dD]?[eE]?[Rr][-= ]*$",re.IGNORECASE)
        self.variation_matcher = re.compile("^\s*(VARIATION|HINT|NOTES?|VERÄNDERUNG|VARIANTEN|TIPANMERKUNGEN)(:.*)?",re.IGNORECASE)
        # a crude ingredient matcher -- we look for two numbers, intermingled with spaces
        # followed by a space or more, followed by a two digit unit (or spaces)
        self.ing_num_matcher = re.compile(
            "^\s*%(top)s%(num)s+\s+[A-Za-z ][A-Za-z ]? .*"%{'top':convert.DIVIDEND_REGEXP,
                                                             'num':convert.NUMBER_REGEXP},
            re.IGNORECASE)
        self.amt_field_matcher = convert.NUMBER_MATCHER
        # we build a regexp to match anything that looks like
        # this: ^\s*ATTRIBUTE: Some entry of some kind...$
        attrmatch="^\s*("
        self.mmf = rzc
        for k in self.mmf.recattrs.keys():
            attrmatch += "%s|"%re.escape(k)
        attrmatch="%s):\s*(.*)\s*$"%attrmatch[0:-1]
        self.attr_matcher = re.compile(attrmatch)
        testtimer.end()
    
    def is_ingredient (self, l):
        """Return true if the line looks like an ingredient.
        """
        if self.ing_num_matcher.match(l):
            return True
        if len(l) >= 5 and self.blank_matcher.match(l[0:2]):
            return True

    

########NEW FILE########
__FILENAME__ = test_importer
import unittest
import importer

class TestImporter (unittest.TestCase):

    def setUp (self):
        self.i = importer.Importer()

    def _get_last_rec_ (self):
        return self.i.added_recs[-1] 

    def testRecImport (self):
        self.i.start_rec()
        attrs = [('title','Foo'),('cuisine','Bar'),('yields',3),('yield_unit','cups')]
        for att,val in attrs:
            self.i.rec[att] = val
        self.i.commit_rec()
        rec = self._get_last_rec_()
        for att,val in attrs:
            self.assertEqual(getattr(rec,att),val)
    
    def testIngredientImport (self):
        self.i.start_rec()
        self.i.rec['title']='Ingredient Import Test'
        self.i.start_ing()
        self.i.add_amt(2)
        self.i.add_unit('cups')
        self.i.add_item(u'water')
        self.i.commit_ing()
        self.i.commit_rec()
        ings = self.i.rd.get_ings(self._get_last_rec_())
        self.assertEqual(len(ings),1)
        ing = ings[0]
        self.assertEqual(ing.amount,2)
        self.assertEqual(ing.unit,'cups')
        self.assertEqual(ing.item,'water')

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_importManager
import tempfile, os, os.path, time

import unittest
import gourmet.gglobals

tmpdir = tempfile.mktemp()
os.makedirs(tmpdir)
gourmet.gglobals.gourmetdir = tmpdir

import gourmet.GourmetRecipeManager
import gourmet.backends.db

gourmet.backends.db.RecData.__single = None
gourmet.GourmetRecipeManager.GourmetApplication.__single = None

import importManager

class TestImports (unittest.TestCase):
    def setUp (self):
        self.im = importManager.get_import_manager()

    def testPlugins (self):
        for pi in self.im.importer_plugins:
            print 'I wonder, is there a test for ',pi
            if hasattr(pi,'get_import_tests'):
                for fn,test in pi.get_import_tests():
                    print 'Testing ',test,fn
                    self.__runImporterTest(fn,test)


    def done_callback (self,*args):
        print 'done!'
        self.done = True

    def __runImporterTest (self, fn, test):
        self.done = False
        importer = self.im.import_filenames([fn])[0]
        assert importer, 'import_filenames did not return an object'
        while not importer.done:
            time.sleep(0.2)
        print 'Done!'
        assert importer.added_recs,'Importer did not have any added_recs (%s,%s)'%(fn,test)
        try:
            test(importer.added_recs,fn)
        except:
            import traceback
            self.assertEqual(1,2,'Importer test for %s raised error %s'%(
                (fn, test),
                traceback.format_exc()
                )
                             )

########NEW FILE########
__FILENAME__ = test_interactive_importer
import unittest
import interactive_importer

class TestConvenientImporter (unittest.TestCase):

    def setUp (self):
        self.ci = interactive_importer.ConvenientImporter()

    def testImport (self):
        self.ci.start_rec()
        self.ci.add_attribute('title','Test')
        self.ci.add_attribute('category','foo')
        self.ci.add_attribute('category','bar')
        self.ci.add_ings_from_text(
            '''6 garlic cloves, peeled 
  1/2 pound linguine 
  1/4 cup plus 1 tablespoon olive oil 
  2 to 2 1/2 pounds small fresh squid (about 10), cleaned and cut into 3/4-inch thick rings, tentacles cut in half* 
  1 1/2 teaspoons Baby Bam or Emeril's Original Essence, to taste 
  1/4 cup chopped green onions 
  1 teaspoon crushed red pepper, or to taste 
  1/4 teaspoon salt 
  1/4 cup fish stock, shrimp stock, or water 
  2 tablespoons fresh lemon juice 
  1 tablespoon unsalted butter 
  1/4 cup chopped fresh parsley leaves 
  1/2 cup freshly grated Parmesan'''
            )
        self.ci.commit_rec()
        rec = self.ci.added_recs[-1]
        self.assertEqual(rec.title,'Test')
        cats = self.ci.rd.get_cats(rec)
        cats.sort()
        self.assertEqual(len(cats),2)
        self.assertEqual(cats[0],'bar')
        self.assertEqual(cats[1],'foo')
        ings = self.ci.rd.get_ings(rec)
        self.assertEqual(len(ings),13)
        self.assertEqual(ings[1].amount,0.5)
        self.assertEqual(ings[1].unit,'pound')
        self.assertEqual(ings[1].item,'linguine')                

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = webextras
import socket, gourmet.threadManager, urllib
from gettext import gettext as _
DEFAULT_SOCKET_TIMEOUT=45.0
URLOPEN_SOCKET_TIMEOUT=15.0

socket.setdefaulttimeout(DEFAULT_SOCKET_TIMEOUT)

class URLReader (gourmet.threadManager.SuspendableThread):

    def __init__ (self, url):
        self.url = url
        gourmet.threadManager.SuspendableThread.__init__(
            self,
            name=_('Downloading %s'%url)
            )

    def do_run (self):
        self.read()

    def read (self):
        message = _('Retrieving %s'%self.url)
        socket.setdefaulttimeout(URLOPEN_SOCKET_TIMEOUT)
        sock = urllib.urlopen(self.url)
        socket.setdefaulttimeout(DEFAULT_SOCKET_TIMEOUT)
        bs = 1024 * 8 # bite size...
        # Get file size so we can update progress correctly...
        self.content_type = None;
        if hasattr(sock,'headers'):
            fs = int(sock.headers.get('content-length',-1)) # file size..
            self.content_type = sock.headers.get('content-type')
            print 'CONTENT TYPE = ',self.content_type            
        else:
            fs = -1
        block = sock.read(bs)
        self.data = block
        sofar = bs
        while block:
            if fs>0:
                self.emit('progress',float(sofar)/fs, message)
            else:
                self.emit('progress',-1, message)
            sofar += bs
            block = sock.read(bs)
            self.data += block
        sock.close()
        self.emit('progress',1, message)
    
def read_socket_w_progress (sock, suspendableThread=None, message=None):
    """Read piecemeal reporting progress via our suspendableThread
    instance (most likely an importer) as we go."""
    if not suspendableThread:
        data = sock.read()
    else:
        bs = 1024 * 8 # bite size...
        if hasattr(sock,'headers'):
            fs = int(sock.headers.get('content-length',-1)) # file size..
        else: fs = -1
        block = sock.read(bs)
        data = block
        sofar = bs
        print "FETCHING:",data
        while block:
            if fs>0:
                suspendableThread.emit('progress',float(sofar)/fs, message)
            else:
                suspendableThread.emit('progress',-1, message)
            sofar += bs
            block = sock.read(bs)
            data += block
            print "FETCHED:",block
    sock.close()
    print "FETCHED ",data
    print "DONE FETCHING"
    suspendableThread.emit('progress',1, message)
    return data

def get_url (url, suspendableThread):
    """Return data from URL, possibly displaying progress."""
    if type(url)==str:
        socket.setdefaulttimeout(URLOPEN_SOCKET_TIMEOUT)
        sock = urllib.urlopen(url)
        socket.setdefaulttimeout(DEFAULT_SOCKET_TIMEOUT)
        return read_socket_w_progress(sock,suspendableThread,_('Retrieving %s'%url))
    else:
        sock = url
        return read_socket_w_progress(sock,suspendableThread,_('Retrieving file'))


########NEW FILE########
__FILENAME__ = xml_importer
import xml.sax, xml.sax.saxutils, re, sys
import importer
from gourmet.gdebug import TimeAction
from gourmet.recipeManager import get_recipe_manager # for getting out database...
from gourmet.threadManager import SuspendableThread

def unquoteattr (str):
    return xml.sax.saxutils.unescape(str).replace("_"," ")

class RecHandler (xml.sax.ContentHandler, importer.Importer):
    def __init__ (self, total=None, conv=None, parent_thread=None):
        self.elbuf = ""
        xml.sax.ContentHandler.__init__(self)
        importer.Importer.__init__(self,total=total,
                                   do_markup=False, conv=conv)
        self.parent_thread = parent_thread
        self.check_for_sleep = parent_thread.check_for_sleep
        self.terminate = parent_thread.terminate
        self.resume = parent_thread.resume
        self.suspend = parent_thread.suspend
        self.emit = parent_thread.emit
        
    def characters (self, ch):
        self.elbuf += ch

class Converter (importer.Importer):
    def __init__ (self, filename, recHandler, recMarker=None,
                  conv=None, name='XML Importer'):

        """Initialize an XML converter which will use recHandler to parse data.
        
        filename - our file to parse (or the name of the file).

        rd - our recdata object.

        recHandler - our recHandler class.

        recMarker - a string that identifies a recipe, so we can
        quickly count total recipes and update users as to progress)
        and our recHandler class.

        We expect subclasses effectively to call as as we are with
        their own recHandlers.
        """

        self.recMarker=recMarker
        self.fn = filename
        self.rh = recHandler(conv=conv,parent_thread=self)
        self.added_ings = self.rh.added_ings
        self.added_recs = self.rh.added_recs
        self.terminate = self.rh.terminate
        self.suspend = self.rh.suspend
        self.resume = self.rh.resume
        importer.Importer.__init__(self,name=name)

    def do_run (self):
        # count the recipes in the file        
        t = TimeAction("rxml_to_metakit.run counting lines",0)
        if isinstance(self.fn, basestring):
            f=file(self.fn,'rb')
        else:
            f=self.fn
        recs = 0
        for l in f.readlines():
            if l.find(self.recMarker) >= 0: recs += 1
            if recs % 5 == 0: self.check_for_sleep()
        f.close()
        t.end()
        self.rh.total=recs
        self.parse = xml.sax.parse(self.fn, self.rh)
        self.added_ings = self.rh.added_ings
        self.added_recs = self.rh.added_recs
        importer.Importer._run_cleanup_(self.rh)

        
        

########NEW FILE########
__FILENAME__ = keymanager
import string, re, time, sys
from defaults.defaults import lang as defaults
from defaults.defaults import langProperties as langProperties
from gdebug import debug, TimeAction

note_separator_regexp = '(;|\s+-\s+|--)'
note_separator_matcher = re.compile(note_separator_regexp)

def snip_notes (s):
    m = note_separator_matcher.search(s)
    if not m: return s
    ret = s[:m.start()].strip()
    if ret: return ret
    else: return s

class KeyManager:

    MAX_MATCHES = 10
    word_splitter = re.compile('\W+')

    __single = None

    def __init__ (self, kd={}, rm=None):
        if KeyManager.__single:
            raise KeyManager.__single
        else:
            KeyManager.__single = self
        self.kd = kd
        if not rm:
            import recipeManager
            rm = recipeManager.default_rec_manager()
        self.rm = rm
        self.cooking_verbs=cooking_verbs
        # This needs to be made sane i18n-wise
        self.ignored = defaults.IGNORE
        self.ignored.extend(self.cooking_verbs)
        self.ignored_regexp = re.compile("[,; ]?(" + '|'.join(self.ignored) + ")[,; ]?")
        if self.rm.fetch_len(self.rm.keylookup_table) == 0:
            self.initialize_from_defaults()
        self.initialize_categories()
        
    def initialize_from_defaults (self):
        dics = []
        for key,items in defaults.keydic.items():
            for i in items:
                dics.append(
                    {'ingkey':unicode(key),
                     'item':unicode(i),
                     'count':1}
                    )
        self.rm.keylookup_table.insert().execute(dics)

    def make_regexp_for_strings (self, ignored):
        ret = "("
        ignored.join("|")

    def regexp_for_all_words (self, txt):
        """Return a regexp to match any of the words in string."""
        regexp="(^|\W)("
        count=0
        for w in re.split("\W+",txt):
            #for each keyword, we create a search term
            if w: #no blank strings!
                count += 1
                regexp="%s%s|"%(regexp,re.escape(w))
        regex="%s)(?=\W|$)"%(regexp[0:-1]) #slice off extra |
        if count:
            return re.compile(regex), count
        else:
            return None, count

    def initialize_categories (self):
        """We treat things like flour as categories, usually
        designated as "flour, all purpose" or "flour, whole wheat". We
        look for this sort of thing, assuming the noun, descriptor
        format has been followed previously. With our handy list, we
        will more easily be able to guess correctly that barley flour
        should be flour, barley"""
        debug("Start initialize_categories",10)
        self.cats = []
        for k in self.rm.get_unique_values('ingkey',self.rm.ingredients_table,deleted=False):
            fnd=k.find(',')
            if fnd != -1:
                self.cats.append(k[0:fnd])
        debug("End initialize_categories",10)
    
    def grab_ordered_key_list (self, str):
        debug("Start grab_ordered_key_list",10)
        """We return a list of potential keys for string."""
        kl=self.look_for_key(str)
        gk = self.generate_key(str)
        nwlst = []
        added_gk = False
        for key,rnk in kl:
            if rnk < 0.9 and not added_gk:
                if not nwlst.__contains__(gk):
                    nwlst.append(gk)
                added_gk = True
            if not nwlst.__contains__(key):
                nwlst.append(key)
        if not added_gk :
            if not nwlst.__contains__(gk):
                nwlst.append(gk)
        debug("End grab_ordered_key_list",10)
        return nwlst

    def get_key_fast (self, s):
        try:
            if s: srch = self.rm.fetch_all(self.rm.keylookup_table,
                                           item=s,
                                           sort_by=[('count',1)]
                                           )
            else: srch = None
        except:
            print 'error seeking key for ',s
            raise
        else:
            if srch: return srch[-1].ingkey
            else:
                s = snip_notes(s)
                return self.generate_key(s)

    def get_key (self,txt, certainty=0.61):
        """Grab a single key. This is simply a best guess at the
        right key for an item (we can't be sure -- if we could be,
        we wouldn't need a key system in the first place!"""
        debug("Start get_key %s"%str,10)
        if not txt: return ''
        txt = snip_notes(txt)
        result = self.look_for_key(txt)
        if result and result[0][0] and result[0][1] > certainty:
            k=result[0][0]
        else:
            k=self.generate_key(txt)
        debug("End get_key",10)
        return k

    def look_for_key (self, txt):
        """handed a key, return a sorted ALIST of potential keys and
        scores.

        The higher the score, the more probable the match.
        """

        txt = txt.lower()
        retvals = {}
        # First look for matches for our full text (or full text +/- s
        main_txts = [txt]
        main_txts.extend(defaults.guess_singulars(txt))
        if len(main_txts)==1:
            main_txts.extend(defaults.guess_plurals(txt))
        for t in main_txts:
            is_key = self.rm.fetch_one(self.rm.ingredients_table,ingkey=t)
            if is_key>=0:
                retvals[t]=.9
            exact = self.rm.fetch_all(self.rm.keylookup_table,
                                      item=t)
            if exact:
                for o in exact:
                    k = o.ingkey
                    if not retvals.has_key(k):
                        retvals[k]=0
                    retvals[k]+=(float(o.count)/len(exact))*2
        # Part II -- look up individual words
        words = self.word_splitter.split(txt)
        nwords = len(words)
        extra_words = []
        # Include plural and singular variants
        for w in words:
            singulars = defaults.guess_singulars(w)
            for s in singulars:
                if not s in extra_words: extra_words.append(s)
            if not singulars:
                for p in defaults.guess_plurals(w):
                    if not p in extra_words:
                        extra_words.append(p)
        words.extend(extra_words)
        for w in words:
            if not w:
                continue
            srch = self.rm.fetch_all(self.rm.keylookup_table,word=w)
            total_count = sum([m.count for m in srch])
            for m in srch:
                ik = m.ingkey
                if not retvals.has_key(ik):
                    retvals[ik]=0
                # We have a lovely ratio.
                #
                # count      1
                # _____   x ___ 
                # total_count   words
                #
                # Where count is the number of times this word has
                # resulted in this key, matches is the number of keys
                # that match this word in all, and words is the number
                # of words we're dealing with.
                words_in_key = len(ik.split())
                if words_in_key > nwords: wordcount = words_in_key
                else: wordcount = nwords
                retvals[ik]+=(float(m.count)/total_count)*(float(1)/(wordcount))
                # Add some probability if our word shows up in the key
                if ik.find(w)>=0: retvals[ik]+=0.1
        retv = retvals.items()
        retv.sort(lambda a,b: a[1]<b[1] and 1 or a[1]>b[1] and -1 or 0)
        return retv

    def generate_key(self, ingr):
        """Generate a generic-looking key from a string."""
        timer = TimeAction('keymanager.generate_key 1',3)
        debug("Start generate_key(self,%s)"%ingr,10)
        ingr = ingr.strip()
        # language specific here - turn off the strip().lower() for German, 'cos:
        # i) german Nouns always start with an uppercase Letter.
        # ii) the function 'lower()' doesn't appear to work correctly with umlauts.
        if (not langProperties['capitalisedNouns']):
            # We want to use unicode's lower() method
            if not isinstance(ingr,unicode):
                ingr = unicode(ingr.decode('utf8'))
            ingr = ingr.lower()
        timer.end()
        timer = TimeAction('keymanager.generate_key 2',3)
        debug("verbless string=%s"%ingr,10)
        if ingr.find(',') == -1:
            # if there are no commas, we see if it makes sense
            # to turn, e.g. whole-wheat bread into bread, whole-wheat
            words = ingr.split()
            if len(words) >= 2:
                if self.cats.__contains__(words[-1]):
                    ingr = "%s, %s" %(words[-1],string.join(words[0:-1]))
        #if len(str) > 32:
        #    str = str[0:32]
        debug("End generate_key",10)
        timer.end()
        return ingr

    def sing_equal(self, str1, str2):
        debug("Start sing_equal(self,%s,%s)"%(str1,str2),10)
        sing_str1 = self.remove_final_s(str1)
        sing_str2 = self.remove_final_s(str2)
        return sing_str1 == sing_str2

    def remove_verbs (self,words):
        """Handed a list of words, we remove anything from the
        list that matches a regexp in self.ignored"""
        debug("Start remove_verbs",10)
        t=TimeAction('remove_verbs',0)
        stringp=True
        if type(words)==type([]):
            stringp=False
            words = string.join(words," ")
        words = words.split(';')[0] #we ignore everything after semicolon
        words = words.split("--")[0] # we ignore everything after double dashes too!
        m = self.ignored_regexp.match(words)
        while m:
            words = words[0:m.start()] + words[m.end():]
            m = self.ignored_regexp.match(words)            
        t.end()
        if stringp:
            return words
        else:
            return words.split()


class KeyDictionary:
    def __init__ (self, rm):
        """We create a readonly dictionary based on the metakit ingredients_table table."""
        self.rm = rm
        self.default = defaults.keydic

    def has_key (self, k):
        debug('has_key testing for %s'%k,1)
        if self.rm.fetch_one(self.rm.ingredients_table,item=k): return True
        elif self.default.has_key(k): return True
        else: return False

    def srt_by_2nd (self, i1, i2):
        """Sort by the reverse order of the second item in each of i1
        and i2"""
        if i1[1] < i2[1]:
            return 1
        if i2[1] < i1[1]:
            return -1
        else: return 0

    def __getitem__ (self, k):
        kvw = self.rm.fetch_count(
            self.rm.ingredients_table,
            'ingkey',
            sort_by=('count',-1),
            item=k
            )

    def keys (self):
        ll = self.rm.get_unique_values('item',self.rm.ingredients_table,deleted=False)
        ll.extend(self.default.keys())
        return ll

    def values (self):
        ll = self.rm.get_unique_values('ingkey',self.rm.ingredients_table,deleted=False)
        ll.extend(self.default.values())
        return ll

    def items (self):
        lst = []
        for i in self.keys():
            lst.append((i, self.__getitem__(i)))
        lst.extend(self.default.items())
        return lst
        
cooking_verbs=["cored",
               "peeled",
               "sliced",
               "chopped",
               "diced",
               "pureed",
               "blended",
               "grated",
               "minced",
               "cored",
               "heated",
               "warmed",
               "chilled"]

def get_keymanager (*args, **kwargs):
    try:
        return KeyManager(*args,**kwargs)
    except KeyManager, km:
        return km

if __name__ == '__main__':

    def timef (f):
        t = time.time()
        f()
        print time.time()-t
    import tempfile
    import recipeManager
    km = KeyManager(rm=recipeManager.RecipeManager(**recipeManager.dbargs))
    recipeManager.dbargs['file']=tempfile.mktemp('.mk')
    fkm = KeyManager(rm=recipeManager.RecipeManager(**recipeManager.dbargs))
    

########NEW FILE########
__FILENAME__ = OptionParser
import argparse
import version
try:
    import argcomplete
    has_argcomplete = True
except ImportError:
    has_argcomplete = False

parser = argparse.ArgumentParser(prog='gourmet',description=version.description)
parser.add_argument('--version',action='version',version=version.version)
parser.add_argument('--database-url',action='store',dest='db_url',
                     help='Custom url for database of form driver://args/location',default='')
parser.add_argument('--plugin-directory',action='store',dest='html_plugin_dir',
                     help='Directory for webpage import filter plugins.',default='')
parser.add_argument('--use-threads',action='store_const',const=True,dest='threads',
                     help='Enable threading support.',default=False)
parser.add_argument('--disable-threads',action='store_const',const=False,dest='threads',
                     help='Disable threading support.')
parser.add_argument('--gourmet-directory',action='store',dest='gourmetdir',
                     help='Gourmet configuration directory',default='')
parser.add_argument('--debug-threading-interval',action='store',type=float,dest='thread_debug_interval',
                     help='Interval for threading debug calls',default=5.0)
parser.add_argument('--debug-threading',action='store_true',dest='thread_debug',
                     help='Print debugging information about threading.')
parser.add_argument('--debug-file',action='store',dest='debug_file',
                     help='Regular expression that matches filename(s) containing code for which we want to display debug messages.',
                     default='')
parser.add_argument('--showtimes',action='store_true',dest='time',help='Print timestamps on debug statements.')
parser.add_argument('--disable-psyco',dest='psyco',action='store_false',help='Do not use psyco if it is installed.',
                     default=True)

group = parser.add_mutually_exclusive_group()
group.add_argument('-q',action='store_const',const=-1,dest='debug',help='Don\'t print gourmet error messages')
group.add_argument('-v',action='count',dest='debug',help='Be verbose (extra v\'s will increase the verbosity level')

if has_argcomplete:
    argcomplete.autocomplete(parser)

args = parser.parse_args()

########NEW FILE########
__FILENAME__ = plugin
# This module provides base classes for all of our plugins. Plugin
# writers will subclass these plugins in their own modules. Thus, each
# plugin module should start with
# 
# from gourmet.plugin import ...
#
# The plugins should then sub-class the relevant class.
#
# Importer and Exporter plugins are somewhat special -- they merely
# provide information about what they can import or export and then
# provide a do_import or do_export method to do the importing and
# exporting.
#
# StandardPlugins are given an instance of a pluggable class and are
# then imported and exported accordingly.
#
# UIPlugin - this is a useful sub-class that makes it trivial to use
# UIManager to add new actions to windows.
#
# ToolPlugin - will be plugged into all windows that have tool
# menus. Which menu bars we add ourselves to is controlled with the
# menu_bars parameter.
#
# MainPlugin - this is given an instance of the main Gourmet
# Application to muck about with.
#
# RecDisplayPlugin - given an instance of the recipe display card.
# RecEditorPlugin - given an instance of the recipe editor.
# DatabasePlugin - given an instance of the base database class.

import Undo, gtk, gobject, types
import plugin_loader
from gtk_extras import fix_action_group_importance

class Plugin:
    pass

class StandardPlugin (Plugin):

    def activate (self, pluggable):
        """Called when plugin is activated. Once each time the
        pluggable instance is instantiated.
        """
        pass

    def deactivate (self, pluggable):
        """Called when plugin is deactivated.
        
        Once each time the pluggable instance is destroyed.
        """
        pass
    
    def remove (self):
        """Remove the plugin from the UI (the user has turned it off).
        """
        pass

class ImportManagerPlugin (StandardPlugin):
    '''A class for extending the methods of the ImportManager itself.
    
    In order to add importers, subclass ImporterPlugin, not this class.
    '''
    pass
    
class ImporterPlugin (StandardPlugin): 

    # Do we let users type in a source to associate with these
    # recipes.
    ask_user_for_source = False
    
    name = None # The name of our importer
    patterns = [] # Glob patterns to match this filetype
    mimetypes = [] # mimetypes associated with this filetype

    def activate (self, pluggable):
        pluggable.register_plugin(self)
        self.importManager = pluggable

    def deactivate (self, pluggable):
        pluggable.unregister_plugin(self)

    def test_file (self,filename):
        '''Test whether file filename is importable by this plugin.'''
        return True

    def get_importer (self, filename):
        """Return an importer class for filename.

        rd is our recipe database object.
        """
        raise NotImplementedError

    def test_url (self, url, data, content_type):
        '''Test whether data retrieved from url is importable by this plugin.
        '''
        tempfilename = self.importManager.get_tempfilename(url,data,content_type)
        return self.test_file(tempfilename)

    def get_web_importer (self, url, data, content_type):
        '''Get an importer for data data retrieved from url'''
        tempfilename = self.importManager.get_tempfilename(url,data,content_type)
        return self.get_importer(tempfilename)
        



class ExporterPlugin (StandardPlugin):

    label = ''
    sublabel = ''
    single_completed_string = ''
    filetype_desc = ''
    saveas_filters = []
    saveas_single_filters = []

    def activate (self, pluggable):
        pluggable.register_plugin(self)

    def deactivate (self, pluggable):
        pluggable.unregister_plugin(self)

    def get_multiple_exporter (self, args):
        pass

    def do_single_export (self, args):
        pass

    def run_extra_prefs_dialog (self):
        pass

    def get_default_prefs (self):
        return {}

class BaseExporterPlugin (Plugin):
    '''This is designed to change the behavior of other exporters.

    For example, a plugin that created a new attribute or text field
    could add it to the export by creating a ChangeExporterPlugin that
    plugs into the write_attr or write_text methods.
    '''
    TEXT = 0
    ATTR = 1

    def __init__ (self):
        self.hooks_to_add = []

    def activate (self, pluggable):
        self.pluggable = pluggable
        for hook in self.hooks_to_add:
            pluggable.add_hook(*hook)

    def remove (self):
        for hook in self.hooks_to_add:
            self.pluggable.remove_hook(*hook)
        self.pluggable.plugins.remove(self)

    def add_field (self, field_name, field_fetcher,
                   type,
                   position=plugin_loader.POST,
                   write_empty_field=False):
        '''Add a text field to our export.

        field_name is the name of the field.
        
        field_fetcher is a function that is given the recipe object as
        its only argument and should return the text blurb.

        type is what kind of field we\'re adding to the export
        (self.TEXT, self.ATTR, self.ING, self.IMG)

        position is either PRE or POST -- whether we come before or
        after other text fields.

        if write_empty_field is True, we will write the field
        regardless of the value. Otherwise, non-True (i.e. blank)
        values will not print.
        '''
        if type==self.TEXT:
            def do_write (*args):
                #print 'do_write received arguments',args
                if position==plugin_loader.POST:
                    klass = args[1]
                else:
                    klass = args[0]
                val = field_fetcher(klass.r)
                if klass.do_markup:
                    val = klass.handle_markup(val)
                if not val: val = ''
                if klass.ALLOW_PLUGINS_TO_WRITE_NEW_FIELDS and (val or write_empty_field):
                    klass.write_text(field_name,val)
            self.hooks_to_add.append((position,'_write_text_',do_write))
        else:
            def do_write (*args):
                #print 'do_write received arguments',args                
                if position==plugin_loader.POST:
                    klass = args[1]
                else:
                    klass = args[0]
                val = field_fetcher(klass.r)
                if klass.do_markup:
                    val = klass.handle_markup(val)
                if klass.ALLOW_PLUGINS_TO_WRITE_NEW_FIELDS and (val or write_empty_field):                
                    klass.write_attr(field_name,val)
            self.hooks_to_add.append((position,'_write_attrs_',do_write))

class BaseExporterMultiRecPlugin (Plugin):
    '''This is designed to change the behavior of other exporters.

    This plugs in at the level of the MultiRecPlugin, used for
    exporting recipe collections.
    '''
    pass


class DatabasePlugin (StandardPlugin):

    name = '' # The name of our database -- subclasses should provide
              # this -- it will allow Gourmet to store version
              # information for database updates

    version = 1 # Version information -- this will allow Gourmet to
                # store information on the plugin version for future
                # updates.

    active = False

    def activate (self, db):
        if self.active:
            print 'Strange -- activate called twice'
            print 'Activate plugin',self,db,'from:'
            import traceback; traceback.print_stack()
            print 'ignoring'
            return 
        self.db = db
        if db._created:
            # For creation after DB is initialized...
            self.create_tables()
            
            self.db.metadata.create_all()
            db.update_plugin_version(self)
        else:
            db.add_hook(plugin_loader.POST,'setup_tables',self.create_tables)
        self.active = True
        
    def remove (self):
        self.db.remove_hook(plugin_loader.POST,'setup_tables',self.create_tables)
        self.active = False
        
    def create_tables (self):
        """Handed the database, create table definitions as necessary.

        This will happen at program initiation.
        """
        pass
    
    def update_version (self, gourmet_stored, plugin_stored,
                        gourmet_current, plugin_current):
        """Given the old version number, perform any updates to the
        database as necessary.

        The Gourmet version #s are tuples with version_super, version_major
        and version_minor.

        The plugin version numbers are single numbers corresponding to
        the version attribute of your your plugin class.
        """
        pass

class UIModule:
    ui_string = '' # an XML UI description for merging with the target UIManager
    name = '' # the name of this module (not i18n'd)
    label = '' # The label of the tab where this interface goes. (should be i18n'd)
    
    def __init__ (self):
        self.action_groups = []
        self.added = []
        self.setup_action_groups()
        self.setup_main_interface()

    def setup_action_groups (self):
        pass

    def setup_main_interface (self):
        pass

    def enter_page (self):
        pass

    def leave_page (self):
        pass

class UIPlugin (StandardPlugin, UIModule):

    """A plugin that works through UIManager.
    """

    def __init__ (self):
        self.merged = {}
        UIModule.__init__(self)

    def activate (self, pluggable):
        self.pluggable = pluggable
        self.add_to_uimanager(pluggable.ui_manager)

    def remove (self):
        for uimanager in self.merged:
            merge_id,action_ids = self.merged[uimanager]
            for ag in action_ids: uimanager.remove_action_group(ag)
            uimanager.remove_ui(merge_id)
    
    def add_to_uimanager (self, uimanager):
        merge_id = uimanager.add_ui_from_string(self.ui_string)
        action_ids = []
        for ag in self.action_groups:
            fix_action_group_importance(ag)
            uimanager.insert_action_group(ag,0)
            action_ids.append(ag)
        self.merged[uimanager] = merge_id,action_ids    

class ToolPlugin (UIPlugin):

    """A plugin that plugs an action into the tool menu.
    """

    menu_items = '<menuitem action=""/>'
    menu_bars = ['RecipeDisplayMenuBar','RecipeEditorMenuBar','RecipeIndexMenuBar']

    def __init__ (self):
        self.ui_string = '\n'.join('''<menubar name="%(mb)s">
        <menu name="Tools" action="Tools">
        %(menu_items)s
        </menu>
        </menubar>'''%{'menu_items':self.menu_items,
                       'mb':mb} for mb in self.menu_bars)
        UIPlugin.__init__(self)

class RecDisplayPlugin (StandardPlugin):

    moduleKlass = None
    
    def activate (self, pluggable):
        if not hasattr(self,'pluggables'): self.pluggables = []
        pluggable.add_plugin_to_left_notebook(self.moduleKlass)
        self.pluggables.append(pluggable)

    def remove (self):
        for pluggable in self.pluggables:
            pluggable.remove_plugin_from_left_notebook(self.moduleKlass)

class RecEditorPlugin (StandardPlugin):

    '''A plugin for our recipe editor.

    moduleKlass is a module to add (provides a new tabby interface on
    the recEditor) and position is the position of that new module.

    '''

    moduleKlass = None
    position = None

    def activate (self, pluggable):
        if not hasattr(self,'pluggables'): self.pluggables = []
        pluggable.add_plugin(self.moduleKlass,self.position)
        self.pluggables.append(pluggable)

class MainPlugin (StandardPlugin):

    added_tabs = []

    def activate (self, pluggable):
        self.main = pluggable

    def deactivate (self, pluggable):
        for t in self.added_tabs:
            pluggable.main_notebook.remove_page(t)
        if pluggable.main_notebook.get_n_pages() <= 1:
            pluggable.main_notebook.set_show_tabs(False)

    def add_tab (self, widget, label):
        self.added_tabs.append(self.main.main_notebook.append_page(widget,
                                                              gtk.Label(label))
                          )
        widget.show()
        self.main.main_notebook.set_show_tabs(True)
        

class PluginPlugin (StandardPlugin):
    """This class is used for plugins that plugin to other plugins.
    """

    target_pluggable = None
    
    def activate (self, pluggable):
        # Check whether we are actually intended for this pluggable,
        # then call do_activate, or remove ourselves from the plugins
        # list accordingly.
        if self.target_pluggable in pluggable.targets:
            # do_activate is where we do our real activation
            self.do_activate(pluggable)
        else:
            # nevermind... we're not for this pluggable
            pluggable.plugins.remove(self)
            
    def do_activate (self, pluggable):
        pass

class RecDisplayModule (UIModule):

    def __init__ (self, recDisplay):
        self.rd = recDisplay; self.rg = self.rd.rg
        UIModule.__init__(self)

class RecEditorModule (UIModule, gobject.GObject, object):

    __gsignals__ = {
        'saved':(gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE,[]),
        'toggle-edited':(gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE,[gobject.TYPE_BOOLEAN]),
        }
    
    def __init__ (self, recEditor):
        gobject.GObject.__init__(self)
        self.action_groups = [] # a list of ActionGroups to be inserted into the uimanager.        
        self.re = recEditor
        self.rg = self.re.rg
        self.current_rec = self.re.current_rec
        self.setup()
        self.setup_undo()
        self.setup_main_interface()

    __edited = False
    def get_edited (self):
        return self.__edited

    def set_edited (self, val):
        self.__edited = val
        self.emit('toggle-edited',val)
        return val

    edited = property(get_edited,set_edited)

    def setup_undo (self):
        self.undoActionGroup = gtk.ActionGroup(self.name+'UndoActions')
        self.undoActionGroup.add_actions([
            ('Undo',gtk.STOCK_UNDO,None,'<Control>Z'),
            ('Redo',gtk.STOCK_REDO,None,'<Control><Shift>Z'),
            ('Reapply',None,'Reapply','<Control>Y'),
            ])
        self.action_groups.append(self.undoActionGroup)
        self.history = Undo.UndoHistoryList(
            self.undoActionGroup.get_action('Undo'),
            self.undoActionGroup.get_action('Redo'),
            self.undoActionGroup.get_action('Reapply')
            )
        self.history.add_action_hook(self.undo_action_callback)
             
    def setup (self):
        pass

    def setup_main_interface (self):
        self.main = gtk.Label('%s Interface not yet implemented'%self.label)

    def save (self, recdict):
        """Modify recipe dictionary with properties to be saved.
        Do any modifications to other tables.
        Return possibly modified recipe dictionary
        """
        self.emit('saved')
        return recdict

    def undo_action_callback (self, undo_history, action, typ):
        # For all actions that go into the undo system, not just UNDO
        widget = action.widget
        #prop = self.get_prop_for_widget(widget)
        prop = (hasattr(widget,'db_prop') and getattr(widget,'db_prop')) or None
        if prop:
            # For all changes to simple recipe attributes (Title,
            # Cuisine, etc.), we look at every change and compare with
            # the original value. If it has, we delete the change from
            # our dictionary of changes. If all changes have been set
            # back to original value, we are no longer "Edited"            
            if hasattr(widget,'get_value'): val = widget.get_value()
            elif hasattr(widget,'get_text'): val = widget.get_text()
            elif hasattr(widget,'entry'): val = widget.entry.get_text()
            elif hasattr(widget,'get_buffer'): val = widget.get_buffer().get_text()
            else: raise TypeError("I don't know how to get the value from action %s widget %s"%(action,widget))
            # HAVE TO HANDLE CATEGORIES
            if prop=='category':
                orig_value = ', '.join(self.rg.rd.get_cats(self.current_rec))
            else:
                orig_value = getattr(self.current_rec,prop)
            if type(orig_value) in types.StringTypes:
                val = val.strip(); orig_value=orig_value.strip()
            else:
                if not val: val = 0
                if not orig_value: orig_value = 0
            if orig_value==val:
                if self.re.widgets_changed_since_save.has_key(prop):
                    del self.re.widgets_changed_since_save[prop]
            else:
                self.re.widgets_changed_since_save[prop]=val  
        else:
            # If we can't compare with original values, we keep a
            # dictionary of all changes made on a per-widget basis.
            if not widget:
                self.re.widgets_changed_since_save['UntrackableChange']=True
            else:
                # We store each change in our dictionary... if the
                # change has disappeared from the history list, then
                # we can surmise it has been "undone"
                if self.re.widgets_changed_since_save.has_key(widget):
                    old_change = self.re.widgets_changed_since_save[widget][-1]
                    if (old_change.is_undo != action.is_undo
                        and
                        old_change not in undo_history):
                        # If we are the inverse of the old action and
                        # the old action is no longer in history, then
                        # we can assume (safely?) that we have undone
                        # the old action
                        del self.re.widgets_changed_since_save[widget][-1]
                        if not self.re.widgets_changed_since_save[widget]:
                            del self.re.widgets_changed_since_save[widget]
                    else:
                        self.re.widgets_changed_since_save[widget].append(action)
                else:
                    self.re.widgets_changed_since_save[widget]=[action]
        if self.re.widgets_changed_since_save:
            self.edited = True
        else:
            self.edited = False
    
    def grab_focus (self):
        """Put focus on appropriate widget for editing."""
        pass

class IngredientControllerPlugin (StandardPlugin):
    '''Plugins for mucking about with how ingredient information is
    edited and stored.
    '''
    pass

class ShoppingListPlugin (UIPlugin):

    ui_string = ''

    def __init__ (self):
        UIPlugin.__init__(self)


class PrinterPlugin (StandardPlugin):

    # SimpleWriter class
    SimpleWriter = None
    # how good this printer is (0 = use it if nothing else is there,
    # and up from there)
    simpleWriterPriority = -2
    RecWriter = None # RecWriter class
    recWriterPriority = -2
    pass
    
    def activate (self, pluggable):
        pluggable.register_plugin(self)

    def deactivate (self, pluggable):
        pluggable.unregister_plugin(self)

class PrefsPlugin (StandardPlugin):

    '''Add a tab to the preferences notebook.

    Pretty much all of the handling is offloaded to the widget you add.

    If you want to handle applying using the prefsGui system, you can do it with...

    self.prefsGui.apply_prefs_dic['prefname']=function

    where function takes then name and value of the preference as its arguments.
    '''

    label = None
    widget = None

    def activate (self, pluggable):
        self.prefsGui = pluggable
        self.notebook = pluggable.notebook
        if self.label and self.widget:
            self.page_no = self.notebook.append_page(self.widget,tab_label=gtk.Label(self.label))
            self.widget.show()

    def deactivate (self, pluggable):
        self.notebook = None
        self.prefsGui = None

    def remove (self):
        if self.notebook:
            self.notebook.remove_page(self.page_no)
            
    def set_pref (self, name, value):
        self.prefsGui.set_pref(name,value)
        

########NEW FILE########
__FILENAME__ = browser
import gtk, gobject, os.path
from gourmet.gglobals import DEFAULT_ATTR_ORDER, REC_ATTR_DIC
from gourmet.ImageExtras import get_pixbuf_from_jpg
import gourmet.convert as convert
from gourmet.gtk_extras.ratingWidget import star_generator
from sqlalchemy.sql import and_, or_, not_
from sqlalchemy import func
from gettext import gettext as _
from icon_helpers import attr_to_icon, get_recipe_image, get_time_slice, scale_pb

curdir = os.path.split(__file__)[0]

class RecipeBrowserView (gtk.IconView):

    __gsignals__ = {
        'recipe-selected':(gobject.SIGNAL_RUN_LAST,
                           gobject.TYPE_INT,[gobject.TYPE_INT]),
        'path-selected':(gobject.SIGNAL_RUN_LAST,
                         gobject.TYPE_STRING,[gobject.TYPE_STRING])
        }

    def __init__ (self, rd):
        self.rd = rd
        gobject.GObject.__init__(self)
        gtk.IconView.__init__(self)
        self.set_selection_mode(gtk.SELECTION_MULTIPLE)
        self.models = {}
        self.set_model()
        self.set_text_column(1)
        self.set_pixbuf_column(2)
        self.connect('item-activated',self.item_activated_cb)
        self.switch_model('base')
        self.path = ['base']

    def new_model (self): return gtk.ListStore(str, # path
                                               str, # text
                                               gtk.gdk.Pixbuf, # image
                                               gobject.TYPE_PYOBJECT,
                                               )

    def switch_model (self, path, val=None):
        if not self.models.has_key(path):
            self.build_model(path,val)
        self.set_model(self.models[path])

    def build_model (self, path,val):
        if path == 'base':
            self.build_base_model()
        elif not '>' in path:
            self.build_first_level_model(path)
        else:
            self.build_recipe_model(path,val)

    def build_base_model (self):
        m = self.models['base'] = self.new_model()
        self.set_model(m)
        for itm in DEFAULT_ATTR_ORDER:
            if itm in ['title','link','yields']: continue
            pb = self.get_base_icon(itm)
            m.append((itm,(REC_ATTR_DIC[itm]),pb,None))

    def get_base_icon (self, itm):
        return attr_to_icon.get(itm,attr_to_icon['category'])

    def get_pixbuf (self, attr,val):
        if attr=='category':            
            tbl = self.rd.recipe_table.join(self.rd.categories_table)
            col = self.rd.categories_table.c.category
            if hasattr(self,'category_images'):
                stment = and_(col==val,self.rd.recipe_table.c.image!=None,
                              self.rd.recipe_table.c.image!='',
                              not_(self.rd.recipe_table.c.title.in_(self.category_images))
                              )
            else:
                stment = and_(col==val,self.rd.recipe_table.c.image!=None,self.rd.recipe_table.c.image!='')
            result = tbl.select(stment,limit=1).execute().fetchone()
            if not hasattr(self,'category_images'): self.category_images = []
            if result: self.category_images.append(result.title)
        elif attr=='rating':
            return star_generator.get_pixbuf(val)
        elif attr in ['preptime','cooktime']:
            return get_time_slice(val)
        else:
            tbl = self.rd.recipe_table
            col = getattr(self.rd.recipe_table.c,attr)
            stment = and_(col==val,self.rd.recipe_table.c.image!=None,self.rd.recipe_table.c.image!='')
            result = tbl.select(stment,limit=1).execute().fetchone()
        if result and result.thumb:
            return scale_pb(get_pixbuf_from_jpg(result.image))
        else:
            return self.get_base_icon(attr) or self.get_base_icon('category')

    def get_default_icon (self):
        if hasattr(self,'default_icon'):
            return self.default_icon
        else:
            #from gourmet.gglobals import imagedir
            path = os.path.join(curdir,'images','generic_category.png')
            self.default_icon = scale_pb(gtk.gdk.pixbuf_new_from_file(path),do_grow=True)
            return self.default_icon


    def convert_val (self, attr, val):
        if attr in ['preptime','cooktime']:
            if val:
                return convert.seconds_to_timestring(val)
            else:
                return 'None'
        elif attr=='rating':
            if not val: return 'Unrated'
            else:
                val = int(val)
                txt = str(int(val) / 2)
                if val % 2:
                    txt += ' 1/2'
                txt += ' ' + _('Stars')
                return txt
        else:
            return str(val)

    def build_first_level_model (self, attribute):
        m = self.models[attribute] = self.new_model()
        if attribute == 'category':
            for n,val in self.rd.fetch_count(self.rd.categories_table,'category'):
                # known bug here -- this includes deleted recs in the count
                m.append((attribute+'>'+str(val),str(val)+' (%s)'%n,self.get_pixbuf(attribute,val),val))
        else:
            for n,val in self.rd.fetch_count(self.rd.recipe_table,attribute,deleted=False):
                if n == 0: continue
                m.append((attribute+'>'+str(val),self.convert_val(attribute,val)+' (%s)'%n,
                          self.get_pixbuf(attribute,val),val))
                          
    def build_recipe_model (self, path, val):
        m = self.models[path] = self.new_model()
        searches = [{'column':'deleted','operator':'=','search':False}]
        path = path.split('>')
        while path:
            textval = path.pop()
            attr = path.pop()
            if val is None:
                val = None
                searches.append({'column':attr,'search':val,'operator':'='})
            else:
                searches.append({'column':attr,'search':val})
        for recipe in self.rd.search_recipes(searches):
            pb = get_recipe_image(recipe)
            m.append((recipe.id,recipe.title,pb,None))

    def set_path (self, path):
        self.path = ['base']
        for level in path.split('>'):
            self.path.append(level)
        self.switch_model(path)

    def item_activated_cb (self, iv, path):
        row = self.get_model()[path]
        step = row[0]; val = row[3]
        try:
            rid = int(step)
        except ValueError:
            self.switch_model(step,val)
            self.path.append(step)
            self.emit('path-selected',step)
        else:
            self.emit('recipe-selected',rid)

    def get_selected_recipes (self):
        paths = self.get_selected_items()
        model = self.get_model()
        recipes = [int(model[p][0]) for p in paths]
        def just_recs_filter (item):
            try:
                int(item)
            except:
                return False
            else:
                return True
        recipes = filter(just_recs_filter,recipes)
        return [r for r in self.rd.recipe_table.select(self.rd.recipe_table.c.id.in_(recipes)).execute()]

    def reset_model (self):
        self.models = {}
        self.switch_model(self.path[-1])

    def back (self):
        if len(self.path) > 1:
            self.ahead = self.path.pop()
            self.switch_model(self.path[-1])

class RecipeBrowser (gtk.VBox):

    def __init__ (self, rd):
        gtk.VBox.__init__(self)
        self.view = RecipeBrowserView(rd)
        self.buttons = []
        self.button_bar = gtk.HBox()
        self.button_bar.set_spacing(6)
        self.pack_start(self.button_bar,expand=False)
        sw = gtk.ScrolledWindow()
        sw.set_policy(gtk.POLICY_AUTOMATIC,gtk.POLICY_AUTOMATIC)
        sw.add(self.view)
        self.pack_start(sw)
        home_button = gtk.Button(stock=gtk.STOCK_HOME)
        self.button_bar.pack_start(home_button,expand=False,fill=False)
        home_button.connect('clicked',self.home); home_button.show()
        self.view.connect('path-selected',self.path_selected_cb)
        self.view.show(); sw.show()

    def home (self, *args):
        self.view.set_path('base')

    def path_selected_cb (self, view, path):
        self.button_bar.show()
        for b in self.buttons:
            self.button_bar.remove(b)
        self.buttons = []
        so_far = ''
        for step in path.split('>'):
            self.append_button(so_far + step)
            so_far += step + '>'
        
    def append_button (self, path):
        if '>' in path:
            txt = self.view.convert_val(*path.split('>'))
        else:
            txt = path
        self.buttons.append(gtk.Button(REC_ATTR_DIC.get(txt,txt)))
        self.buttons[-1].connect('clicked',lambda *args: self.view.set_path(path))
        self.button_bar.pack_start(self.buttons[-1],expand=False,fill=False)
        self.buttons[-1].show()
        

def try_out ():
    import gourmet.recipeManager
    rb = RecipeBrowser(gourmet.recipeManager.get_recipe_manager())
    vb = gtk.VBox()
    vb.pack_start(rb)
    rb.show()
    w = gtk.Window()
    w.add(vb)
    w.show(); vb.show()
    w.set_size_request(800,500)
    w.connect('delete-event',gtk.main_quit)
    gtk.main()
    
if __name__ == '__main__':
    try_out()

########NEW FILE########
__FILENAME__ = icon_helpers
import gtk.gdk, os.path
# mentioning PIL explicitly helps py2exe
try:
    from PIL import Image, ImageDraw
except ImportError:
    import Image, ImageDraw
from gourmet.ImageExtras import get_pixbuf_from_jpg
from gourmet.gtk_extras.ratingWidget import star_generator

curdir = os.path.split(__file__)[0]

ICON_SIZE=125

def scale_pb (pb, do_grow=True):
    w = pb.get_width()
    h = pb.get_height ()
    if not do_grow and (w < ICON_SIZE or h < ICON_SIZE):
        if w < h: target = w
        else: target = h
    else:
        target = ICON_SIZE
    if w > h:
        target_w = target
        target_h = int(target * (float(h)/w))
    else:
        target_h = target
        target_w = int(target * (float(w)/h))
    return pb.scale_simple(target_w,target_h,gtk.gdk.INTERP_BILINEAR)

def get_pixbuf_from_image (image):

    """Get a pixbuf from a PIL Image.

    By default, turn all white pixels transparent.
    """

    is_rgba = image.mode=='RGBA'
    if is_rgba: rowstride = 4
    else: rowstride = 3
    pb=gtk.gdk.pixbuf_new_from_data(
        image.tostring(),
        gtk.gdk.COLORSPACE_RGB,
        is_rgba,
        8,
        image.size[0],
        image.size[1],
        (is_rgba and 4 or 3) * image.size[0] #rowstride
        )
    return pb


generic_recipe_image = scale_pb(gtk.gdk.pixbuf_new_from_file(os.path.join(curdir,'images','generic_recipe.png')))
preptime_image = gtk.gdk.pixbuf_new_from_file(os.path.join(curdir,'images','preptime.png'))
preptime_empty_image = gtk.gdk.pixbuf_new_from_file(os.path.join(curdir,'images','preptime_empty_clock.png'))
cooktime_image = gtk.gdk.pixbuf_new_from_file(os.path.join(curdir,'images','cooktime.png'))
cooktime_empty_image = gtk.gdk.pixbuf_new_from_file(os.path.join(curdir,'images','cooktime_empty_clock.png'))
cuisine_image = scale_pb(gtk.gdk.pixbuf_new_from_file(os.path.join(curdir,'images','cuisine.png')))
rating_image =  scale_pb(gtk.gdk.pixbuf_new_from_file(os.path.join(curdir,'images','rating.png')))
source_image =  scale_pb(gtk.gdk.pixbuf_new_from_file(os.path.join(curdir,'images','source.png')))
category_image =  scale_pb(gtk.gdk.pixbuf_new_from_file(os.path.join(curdir,'images','generic_category.png')))

attr_to_icon = {
    'category':category_image,
    'source':source_image,
    'rating':rating_image,
    'cuisine':cuisine_image,
    'cooktime':scale_pb(cooktime_image),
    'preptime':scale_pb(preptime_image),
    }

def get_recipe_image (rec):
    if rec.image:
        pb = scale_pb(get_pixbuf_from_jpg(rec.image))
    else:
        pb = generic_recipe_image.copy()
    big_side = ((pb.get_property('height') > pb.get_property('width') and pb.get_property('height')) or pb.get_property('width'))
    if rec.rating:
        #sg = get_star_generator()
        sg = star_generator        
        ratingPB = sg.get_pixbuf(rec.rating)
        h = pb.get_height() - ratingPB.get_height() - 5
        w = pb.get_width() - ratingPB.get_width() - 5
        if h < 0: h = 0
        if w < 0: w = 0
        if ratingPB.get_property('width') > pb.get_property('width'):
            SCALE = float(pb.get_property('width'))/ratingPB.get_property('width')
        else:
            SCALE = 1
        ratingPB.composite(
            pb,
            w, #dest_x
            h, # dest_y
            int(ratingPB.get_width()*SCALE), # dest_width,
            int(ratingPB.get_height()*SCALE), #dest_height
            w, #offset_x,
            h, #offset_y
            SCALE,SCALE, #scale_x,scale_y
            gtk.gdk.INTERP_BILINEAR,
            255 # overall_alpha
            )
    if rec.preptime:
        #prepPB = get_time_slice(rec.preptime)
        prepPB = make_preptime_icon(rec.preptime)
        prepPB = prepPB.scale_simple(int(big_side*0.4),int(big_side*0.4),gtk.gdk.INTERP_BILINEAR)
        prepPB.composite(
            pb,
            pb.get_property('width')/2 + 5,5,
            prepPB.get_property('width'),prepPB.get_property('height'),
            pb.get_property('width')/2 + 5,5,
            1,1,gtk.gdk.INTERP_BILINEAR,
            127 # alpha
            )
    if rec.cooktime:
        cookPB = make_cooktime_icon(rec.cooktime)
        cookPB = cookPB.scale_simple(int(big_side*0.4),int(big_side*0.4),gtk.gdk.INTERP_BILINEAR)
        cookPB.composite(
            pb,
            pb.get_property('width')/2 + 5,pb.get_property('height')/2,
            cookPB.get_property('width'),cookPB.get_property('height'),
            pb.get_property('width')/2 + 5,pb.get_property('height')/2,
            1,1,gtk.gdk.INTERP_BILINEAR,
            188 # alpha
            )
    return pb

class PiePixbufGenerator:

    '''Generate Pie-chart style pixbufs representing circles'''

    def __init__ (self):
        self.slices = {}

    def get_image (self, angle, color):
        angle = int(angle)
        if self.slices.has_key((angle,color)): return self.slices[(angle,color)]
        img = Image.new('RGBA',
                        (ICON_SIZE,ICON_SIZE),
                        255 # background
                        )
        d = ImageDraw.Draw(img)
        d.pieslice((10,10,ICON_SIZE-10,ICON_SIZE-10),-90,-90 + angle, color)
        self.slices[(angle,color)] = get_pixbuf_from_image(img)
        return self.slices[(angle,color)]

    def get_time_image (self, time_in_seconds):
        if time_in_seconds <= 60:
            return self.get_image( (time_in_seconds/60.0) * 360, 'pink') # seconds (sweep hand)
        elif time_in_seconds <= 60 * 60:
            return self.get_image( (time_in_seconds/float(60*60)) * 360, 'red') # minutes (minute hand)
        elif time_in_seconds <= 60 * 60 * 60 * 12: # hours (12 hours)
            return self.get_image( (time_in_seconds/float(60*60*12) * 360), 'blue')
        else:
            return self.get_image(359, 'blue')

    
pie_generator = PiePixbufGenerator()
make_pie_slice = pie_generator.get_image
get_time_slice = pie_generator.get_time_image

def make_time_icon (text):
    img = Image.new('RGBA',
                    (ICON_SIZE,ICON_SIZE),
                    255 # background
                    )
    d = ImageDraw.Draw(img)
    #Thosed.text(    

PREP = 1
COOK = 2

def make_preptime_icon (preptime):
    return make_time_icon(preptime,mode=PREP)
    
def make_cooktime_icon (cooktime):
    return make_time_icon(cooktime,mode=COOK)

def make_time_icon (time, mode):
    LEFT_CORNER = (31,103)
    W,H = 65,65
    if mode == PREP:
        icon_image = preptime_empty_image.copy()
    elif mode == COOK:
        icon_image = cooktime_empty_image.copy()
    slice_pb = get_time_slice(time)
    SCALE_X = W / float(slice_pb.get_property('width'))
    SCALE_Y = H / float(slice_pb.get_property('height'))
    args = (icon_image,
           LEFT_CORNER[0],
           LEFT_CORNER[1],
           W,H,
           LEFT_CORNER[0],
           LEFT_CORNER[1],
           SCALE_X, SCALE_Y, gtk.gdk.INTERP_BILINEAR, 255)
    slice_pb.composite(*args)
    return icon_image

if __name__ == '__main__':
    t = 60*60*6
    hb = gtk.HBox()
    pb = make_preptime_icon(t)
    w = gtk.Window()
    i = gtk.Image(); i.set_from_pixbuf(pb)
    hb.pack_start(i)
    pb2 = get_time_slice(t)
    i2 = gtk.Image(); i2.set_from_pixbuf(pb2)
    hb.pack_start(i2)
    w.add(hb)
    w.show_all()
    w.connect('delete-event',lambda *args: gtk.main_quit())
    gtk.main()

########NEW FILE########
__FILENAME__ = recipeMerger
"""recipeMerger.py

This module contains code for handling the 'merging' of duplicate
recipes.
"""
import gtk, pango, os.path, time
import gourmet.recipeIdentifier
from gourmet.gtk_extras import ratingWidget, mnemonic_manager, dialog_extras
import gourmet.recipeIdentifier
import gourmet.convert as convert
import gourmet.gglobals as gglobals
import gourmet.recipeManager
from gettext import gettext as _

NEWER = 1
OLDER = 2

try:
    current_path = os.path.split(os.path.join(os.getcwd(),__file__))[0]
except:
    current_path = ''

def time_to_text (val):
    curtime = time.time()
    if val == 0:
        return 'Unknown'
    # within 18 hours, return in form 4 hours 23 minutes ago or some such    
    if curtime - val < 18 * 60 * 60:
        return _("%s ago")%convert.seconds_to_timestring(curtime-val,round_at=1)
    tupl=time.localtime(val)
    if curtime - val <  7 * 24 * 60 * 60:
        return time.strftime('%A %T',tupl)
    else:
        return time.strftime('%D %T',tupl)
       
    
class ConflictError (ValueError):
    def __init__ (self, conflicts):
        self.conflicts = conflicts

class RecipeMergerDialog:

    """A dialog to allow the user to merge recipes.
    """

    # These line up to the position of the options in the search-type
    # combo box in glade...
    RECIPE_DUP_MODE = 0
    ING_DUP_MODE = 1
    COMPLETE_DUP_MODE = 2

    DUP_INDEX_PAGE = 0
    MERGE_PAGE = 1
    
    def __init__ (self, rd=None, in_recipes=None, on_close_callback=None):
        if rd:
            self.rd = rd
        else:
            self.rd = gourmet.recipeManager.get_recipe_manager()
        self.in_recipes = in_recipes
        self.on_close_callback = on_close_callback
        self.to_merge = [] # Queue of recipes to be merged...
        self.ui = gtk.Builder()
        self.ui.add_from_file(os.path.join(current_path,'recipeMerger.ui'))
        self.get_widgets()
        self.searchTypeCombo.set_active(self.COMPLETE_DUP_MODE)
        self.mm = mnemonic_manager.MnemonicManager()
        self.mm.add_builder(self.ui)
        self.mm.fix_conflicts_peacefully()
        self.ui.connect_signals(
            {
            'on_searchTypeCombo_changed':lambda *args: self.populate_tree(),
            'on_includeDeletedRecipesCheckButton_toggled':lambda *args: self.populate_tree(),
            'on_mergeAllButton_clicked':self.merge_all,
            'on_cancelMergeButton_clicked':self.cancel_merge,
            'on_mergeSelectedButton_clicked':self.merge_selected,
            'on_applyButton_clicked':self.apply_merge,
            'auto_merge':self.offer_auto_merge,
            'close':self.close,
            }
            )
        
    def get_widgets (self):
        for w in [
            'recipeDiffScrolledWindow',
            'duplicateRecipeTreeView',
            'mergeAllButton','mergeSelectedButton', # buttons on list-dups page (minus close button)
            'applyMergeButton','closeMergeButton','cancelMergeButton', # buttons on merge-recs page
            'searchTypeCombo','includeDeletedRecipesCheckButton','notebook',
            'mergeInfoLabel'
            ]:
            setattr(self,w,self.ui.get_object(w))
        self.setup_treeview()

    def setup_treeview (self):
        renderer = gtk.CellRendererText()
        col = gtk.TreeViewColumn('Recipe',renderer,text=2)
        self.duplicateRecipeTreeView.append_column(col)
        self.duplicateRecipeTreeView.insert_column_with_data_func(
            -1, # position
             'Last Modified', # title
             renderer, # renderer
             self.time_cell_data_func, # function
             3 # data column
             )
        col = gtk.TreeViewColumn('Duplicates',renderer,text=4)
        self.duplicateRecipeTreeView.append_column(col)
        self.duplicateRecipeTreeView.get_selection().set_mode(gtk.SELECTION_MULTIPLE)

    def time_cell_data_func (self, tree_column, cell, model, titer, data_col):
        """Display time in treeview cell.
        """
        val = model.get_value(titer,data_col)
        cell.set_property('text',time_to_text(val))

    def populate_tree (self):
        """Populate treeview with duplicate recipes.
        """
        #print 'CALL: populate_tree'
        search_mode =self.searchTypeCombo.get_active()
        include_deleted = self.includeDeletedRecipesCheckButton.get_active()
        if search_mode == self.RECIPE_DUP_MODE:
            dups = self.rd.find_duplicates(by='recipe',
                                    recipes=self.in_recipes,
                                    include_deleted=include_deleted)
        elif search_mode == self.ING_DUP_MODE:
            dups = self.rd.find_duplicates(by='ingredient',
                                    recipes=self.in_recipes,
                                    include_deleted=include_deleted)
        else: # == self.COMPLETE_DUP_MODE
            dups = self.rd.find_complete_duplicates(include_deleted=include_deleted,
                                             recipes=self.in_recipes)
        self.setup_treemodel(dups)
        self.dups = dups
        self.duplicateRecipeTreeView.set_model(self.treeModel)

    def setup_treemodel (self, dups):
        self.treeModel = gtk.TreeStore(int,int,str,int,str) # dup_index, rec_id, rec_title, last_modified, number_of_duplicates
        for dup_index,duplicate_recipes in enumerate(dups):
            first = duplicate_recipes[0]
            others = duplicate_recipes[1:]
            nduplicates = len(duplicate_recipes)
            r = self.rd.get_rec(first)
            firstIter = self.treeModel.append(
                None,
                (dup_index or 0, first or 0, r.title or '', r.last_modified or 0, str(nduplicates))
                )
            for o in others:
                r = self.rd.get_rec(o)
                self.treeModel.append(firstIter,
                                      (dup_index,o,r.title,r.last_modified or 0,'')
                                      )
    def merge_next_recipe (self, ):
        if self.to_merge:
            self.current_dup_index = self.to_merge.pop(0)
            self.mergeInfoLabel.set_text(
                'Merging recipe %(index)s of %(total)s'%{
                    'index':self.total_to_merge - len(self.to_merge),
                    'total':self.total_to_merge
                    })
            duplicate_recipes = self.dups[self.current_dup_index]
            #self.idt = IngDiffTable(self.rd,duplicate_recipes[0],duplicate_recipes[1])
            self.current_recs = [self.rd.get_rec(i) for i in duplicate_recipes]
            last_modified = {'last_modified':[r.last_modified for r in self.current_recs]}
            self.current_diff_data = gourmet.recipeIdentifier.diff_recipes(self.rd,self.current_recs)
            last_modified.update(self.current_diff_data)            
            self.diff_table = DiffTable(last_modified,self.current_recs[0],parent=self.recipeDiffScrolledWindow)
            self.diff_table.add_ingblocks(self.rd, self.current_recs)
            if not self.diff_table.idiffs and not self.current_diff_data:
                # If there are no differences, just merge the recipes...
                self.apply_merge()
                return
            if self.recipeDiffScrolledWindow.get_child():
                self.recipeDiffScrolledWindow.remove(self.recipeDiffScrolledWindow.get_child())
            self.diff_table.show()
            #self.idt.show()
            vb = gtk.VBox()
            vb.add(self.diff_table)
            #vb.add(self.idt)
            vb.show()
            #self.recipeDiffScrolledWindow.add_with_viewport(self.diff_table)
            self.recipeDiffScrolledWindow.add_with_viewport(vb)
            self.notebook.set_current_page(self.MERGE_PAGE)
        else:
            self.notebook.set_current_page(self.DUP_INDEX_PAGE)

    def do_merge (self, merge_dic, recs, to_keep=None):
        if not to_keep:
            to_keep = recs[0]
        if type(to_keep)==int:
            to_keep = self.rd.get_rec(to_keep)
        self.rd.modify_rec(to_keep,merge_dic)
        for r in recs:
            if r.id != to_keep.id:
                self.rd.delete_rec(r)
        
    def apply_merge (self, *args):
        #print "CALL: apply_merge"
        #print 'Apply ',self.diff_table.selected_dic,'on ',self.diff_table.rec
        self.do_merge(self.diff_table.selected_dic,
                      self.current_recs,
                      to_keep=self.diff_table.rec)
        self.merge_next_recipe()
        if not self.to_merge:
            self.populate_tree()
            
    def merge_selected (self, *args):
        """Merge currently selected row from treeview.
        """
        #print "CALL: merge_selected"
        mod,rows = self.duplicateRecipeTreeView.get_selection().get_selected_rows()
        dup_indices = [mod[r][0] for r in rows]
        self.to_merge = []
        for d in dup_indices:
            if d not in self.to_merge:
                self.to_merge.append(d)
        self.total_to_merge = len(self.to_merge)
        self.merge_next_recipe()
        
    def merge_all (self, *args):
        """Merge all rows currently in treeview.
        """
        self.total_to_merge = len(self.dups)
        self.to_merge = range(self.total_to_merge)
        self.merge_next_recipe()

    def offer_auto_merge (self, *args):
        try:
            option =dialog_extras.getOption(
                label=_('Auto-Merge recipes'),
                options=[
                    (_('Always use newest recipe'),NEWER),
                    (_('Always use oldest recipe'),OLDER),
                    # The following would be nice to add eventually...
                    #_('Always use longer field'),
                    #_('Ignore differences in ingredient keys')
                    ]
                )
            if not option:
                return
            self.do_auto_merge(NEWER)
        except dialog_extras.UserCancelledError:
            pass

    def do_auto_merge (self, mode):
        if self.recipeDiffScrolledWindow.get_child():
            self.recipeDiffScrolledWindow.remove(self.recipeDiffScrolledWindow.get_child())        
        vb = gtk.VBox()
        l = gtk.Label()
        l.set_markup('<u>Automatically merged recipes</u>')
        vb.pack_start(l,expand=False,fill=False); vb.show_all()
        self.recipeDiffScrolledWindow.add_with_viewport(vb)
        def do_auto_merge ():
            kept = self.auto_merge_current_rec(mode)
            label = gtk.Label('%s'%kept.title)
            vb.pack_start(label,expand=False,fill=False); label.show()
        self.cancelMergeButton.hide()
        self.applyMergeButton.hide()
        self.closeMergeButton.set_sensitive(False)
        do_auto_merge()
        while self.to_merge:
            self.mergeInfoLabel.set_text(
                'Automatically merging recipe %(index)s of %(total)s'%{
                    'index':self.total_to_merge - len(self.to_merge),
                    'total':self.total_to_merge
                    })            
            self.current_dup_index = self.to_merge.pop(0)
            duplicate_recipes = self.dups[self.current_dup_index]            
            self.current_recs = [self.rd.get_rec(i) for i in duplicate_recipes]
            do_auto_merge()
            while gtk.events_pending(): gtk.main_iteration()
        self.mergeInfoLabel.set_text('Automatically merged %s recipes'%self.total_to_merge)
        self.closeMergeButton.set_sensitive(True)           
        
    def auto_merge_current_rec (self, mode):
        def compare_recs (r1, r2):
            result = cmp(r1.last_modified,r2.last_modified)
            if mode==NEWER: return result
            else: return -result
        self.current_recs.sort(compare_recs)
        keeper = self.current_recs[0]
        tossers = self.current_recs[1:]
        for to_toss in tossers:
            self.rd.delete_rec(to_toss)
        return keeper
        
    def cancel_merge (self, *args):
        self.merge_next_recipe()
        if not self.to_merge:
            self.populate_tree()

    def populate_tree_if_possible (self):
        self.populate_tree()
        if not self.dups:
            self.searchTypeCombo.set_active(self.RECIPE_DUP_MODE)
            self.populate_tree()
            if not self.dups:
                self.searchTypeCombo.set_active(self.ING_DUP_MODE)
                self.populate_tree()

    def show_if_there_are_dups (self, label=None):
        self.populate_tree_if_possible()
        if self.dups:
            self.show(label=label)
        else:
            self.ui.get_object('window1').destroy()
        
    def show (self, label=None):
        if label:
            messagebox = self.ui.get_object('messagebox')
            l = gtk.Label(label)
            l.set_line_wrap(True)
            infobar = gtk.InfoBar()
            infobar.set_message_type(gtk.MESSAGE_INFO)
            infobar.get_content_area().add(l)
            infobar.show_all()
            messagebox.pack_start(infobar, True, False)
        self.ui.get_object('window1').show()

    def close (self, *args):
        #print "CALL: close"
        w = self.ui.get_object('window1')
        w.hide()
        w.destroy()
        if self.on_close_callback:
            self.on_close_callback(self)
        
class RecipeMerger:

    """A class to handle recipe merging.
    """
    
    def __init__ (self, rd):
        self.rd = rd

    def autoMergeRecipes (self, recs):
        to_fill,conflicts = gourmet.recipeIdentifier.merge_recipes(self.rd,
                                                                   recs)
        if conflicts:
            raise ConflictError(conflicts)
        else:
            to_keep = recs[0]
            # Update a single recipe with our information...
            self.rd.modify_rec(to_keep,to_fill)
            # Delete the other recipes...
            for r in recs[1:]:
                self.rd.delete_rec(r.id)

    def uiMergeRecipes (self, recs):
        diffs = gourmet.recipeIdentifier.diff_recipes(self.rd,
                                              recs)
        idiffs = gourmet.recipeIdentifier.diff_ings(self.rd,r1,r2)
        if diffs:
            return DiffTable(diffs,recs[0])
        else:
            return None

class DiffTable (gtk.Table):

    """A Table displaying differences in a recipe.

    diff_dic is a dictionary with the differences.
    {'attribute':(VAL1,VAL2,...)}

    recipe_object is a recipe object representing one of our duplicate
    recs, from which we can grab attributes that are not different.

    dont_choose is a list of attributes whose differences are
    displayed, but where no choice is offered (such as modification
    time for the recipe).
    """

    def __init__ (self, diff_dic, recipe_object=None, parent=None,
                  dont_choose=[]):
        self.idiffs = []
        self.diff_dic = diff_dic
        gtk.Table.__init__(self)
        self.selected_dic = {}
        self.set_col_spacings(6)
        self.set_row_spacings(6)        
        self.row = 0
        self.max_cols = 1
        for attr,name,typ in [('last_modified','Last Modified',None)] + gglobals.REC_ATTRS \
                + [('image','Image',None)] \
                + [(attr,gglobals.TEXT_ATTR_DIC[attr],None) for attr in gglobals.DEFAULT_TEXT_ATTR_ORDER]:
            if diff_dic.has_key(attr):
                buttons = self.build_options(attr,self.diff_dic[attr])
                label = gtk.Label('_'+name+':')
                label.set_alignment(0.0,0.5)
                label.set_use_underline(True)
                label.show()
                self.attach(label,0,1,self.row,self.row+1,xoptions=gtk.SHRINK|gtk.FILL,yoptions=gtk.SHRINK|gtk.FILL)
                target = None
                for col,b in enumerate(buttons):
                    self.setup_widget_size(b,in_col=True)
                    b.show()
                    if not target:
                        target = b
                        label.set_mnemonic_widget(target)
                    self.attach(b,col+1,col+2,self.row,self.row+1,xoptions=gtk.SHRINK|gtk.FILL,yoptions=gtk.SHRINK|gtk.FILL)
                    if col > self.max_cols: self.max_cols = col
                self.row += 1
            elif recipe_object and hasattr(recipe_object,attr) and getattr(recipe_object,attr):
                att_label = gtk.Label(name+':')
                att_label.set_use_underline(True)
                att_label.set_alignment(0,0.5)
                att_label.show()
                constructor = get_display_constructor(attr)
                val = getattr(recipe_object,attr)
                val_label = constructor(getattr(recipe_object,attr))
                val_label.show()
                self.setup_widget_size(val_label,False)
                if hasattr(val_label,'set_alignment'): val_label.set_alignment(0,0.5)
                self.attach(att_label,0,1,self.row,self.row+1,xoptions=gtk.SHRINK|gtk.FILL,yoptions=gtk.SHRINK|gtk.FILL)
                self.attach(val_label,1,5,self.row,self.row+1,xoptions=gtk.SHRINK|gtk.FILL,yoptions=gtk.SHRINK|gtk.FILL)                
                self.row += 1
        self.mm = mnemonic_manager.MnemonicManager()
        self.mm.add_toplevel_widget(self)
        self.mm.fix_conflicts_peacefully()
        self.rec = recipe_object.id
        
    def setup_widget_size (self, w, in_col=True):
        if in_col:
            w.set_size_request(230,-1)
        else:
            w.set_size_request(650,-1)

    def build_options (self, attribute, values):
        buttons = []
        group_rb = None
        make_widget = get_display_constructor(attribute)
        for v in values:
            rb = gtk.RadioButton(group=group_rb)
            if not group_rb: group_rb = rb
            if v is not None:
                rb.add(make_widget(v))
            else:
                rb.add(gtk.Label(_("None")))
            rb.show_all()
            buttons.append(rb)
            rb.connect('toggled',self.value_toggled,attribute,v)
        self.selected_dic[attribute] = values[0]
        for n,v in enumerate(values):
            if v:
                buttons[n].set_active(True)
                break
        return buttons

    def value_toggled (self, rb, attribute, v):
        self.selected_dic[attribute] = v

    def add_ingblocks (self, rd, recs):
        #print 'add_ingblocks for ',[r.id for r in recs]
        self.rd = rd
        self.iblock_dic = {}
        if len(recs) == 1:
            blocks = gourmet.recipeIdentifier.format_ingdiff_line(
                gourmet.recipeIdentifier.format_ings(recs[0],self.rd)
                )
            self.iblock_dic[blocks[0]] = recs[0]
        else:
            blocks = []
            rec_0 = recs[0]
            for r in recs[1:]:
                chunks = self.get_ing_text_blobs(rec_0,r)
                if not chunks and not blocks:
                    # If there is no diff, in other words, and we
                    # don't yet have any block...
                    chunks = [gourmet.recipeIdentifier.format_ings(recs[0],self.rd)]
                elif not chunks:
                    # Otherwise if there are no diffs we just continue
                    # our loop...
                    continue
                if not blocks:
                    blocks = [chunks[0]]
                    self.iblock_dic[blocks[0]] = rec_0
                if chunks and len(chunks) > 1:
                    new_block = chunks[1]
                    if new_block not in blocks:
                        blocks.append(new_block)
                        self.iblock_dic[new_block] = r
        group_rb = None
        name = _('Ingredients')
        if len(blocks) > 1:
            lab = gtk.Label('_'+_("Ingredients")); lab.set_use_underline(True)
            for col,block in enumerate(blocks):
                rb = gtk.RadioButton(
                    label=_("Recipe")+ ' ' +'%i'%(col+1),
                    group=group_rb
                    )
                if not group_rb:
                    group_rb = rb
                    lab.set_mnemonic_widget(rb)
                if not block:
                    rb.add(gtk.Label(_("None")))                    
                else:
                    for n,txt in enumerate(block):
                        l = gtk.Label(txt)
                        l.set_alignment(0.0,0.0)                    
                        l.set_use_markup(True)
                        l.set_line_wrap(True); l.set_line_wrap_mode(pango.WRAP_WORD)
                        l.show()
                        self.setup_widget_size(l,in_col=True)
                        self.attach(l,col+1,col+2,self.row+1+n,self.row+2+n,
                                    xoptions=gtk.SHRINK|gtk.FILL,
                                    yoptions=gtk.SHRINK|gtk.FILL)
                    #rb.add(l)
                rb.connect('toggled',self.ing_value_toggled,block)
                self.setup_widget_size(rb,in_col=True)                
                rb.show()
                self.attach(rb,col+1,col+2,self.row,self.row+1,xoptions=gtk.SHRINK|gtk.FILL,yoptions=gtk.SHRINK|gtk.FILL)
        else:
            lab = gtk.Label(_("Ingredients")); lab.show()
            l = gtk.Label(blocks[0])
            l.set_alignment(0.0,0.0)
            l.set_use_markup(True)
            l.set_line_wrap(True); l.set_line_wrap_mode(pango.WRAP_WORD)
            l.show()
            self.attach(l,1,5,self.row,self.row+1,xoptions=gtk.SHRINK|gtk.FILL,yoptions=gtk.SHRINK|gtk.FILL)
        lab.set_alignment(0.0,0.0); lab.show()
        self.attach(lab,0,1,self.row,self.row+1,xoptions=gtk.SHRINK|gtk.FILL,yoptions=gtk.SHRINK|gtk.FILL)

    def ing_value_toggled (self, rb, block):
        if rb.get_active():
            #print 'RB clicked',rb,'for block',block
            #print 'ING TOGGLED - REC = ',
            self.rec = self.iblock_dic[block]
            #print self.rec

    def get_ing_text_blobs (self, r1, r2):
        """Return an ing-blurb for r1 and r2 suitable for display."""
        idiff = gourmet.recipeIdentifier.diff_ings(self.rd,r1,r2)
        if idiff: self.idiffs.append(idiff)
        def is_line (l):
            return not (l == '<diff/>')
        if idiff:
            return [
                tuple([gourmet.recipeIdentifier.format_ingdiff_line(i)
                 for i in filter(is_line,igroup)
                 ])
                for igroup in idiff
                ]
        else:
            return None
            
def put_text_in_scrolled_window (text):
    sw = gtk.ScrolledWindow()
    tv = gtk.TextView()
    sw.add(tv)
    tv.get_buffer().set_text(text)
    tv.set_editable(False)
    tv.set_wrap_mode(gtk.WRAP_WORD)
    sw.set_policy(gtk.POLICY_NEVER,gtk.POLICY_AUTOMATIC)
    tv.show()
    return sw

def make_text_label (t, use_markup=False):
    if not t:
        return gtk.Label(_('None'))
    elif len(t) < 30:
        return gtk.Label(t)
    elif len(t) < 250:
        l = gtk.Label(t)
        if use_markup: l.set_use_markup(use_markup)
        l.set_line_wrap_mode(pango.WRAP_WORD)
        return l
    else:
        return put_text_in_scrolled_window(t)

def get_display_constructor (attribute):
    if attribute == 'rating':
        return lambda v: ratingWidget.StarImage(
            ratingWidget.star_generator,
            value=v,
            upper=10)
    elif attribute in ['preptime','cooktime']:
        return lambda v: gtk.Label(convert.seconds_to_timestring(v))
    elif attribute=='image':
        return lambda v: (v and gtk.Label("An Image") or gtk.Label("No Image"))
    elif attribute in gglobals.DEFAULT_TEXT_ATTR_ORDER:        
        return make_text_label
    elif attribute == 'last_modified':
        return lambda v: gtk.Label(time_to_text(v))
    else:
        return lambda v: v and gtk.Label(v) or gtk.Label(_('None'))

if __name__ == '__main__':

    def test_in_window (widget):
        """Put widget in window and show it"""
        w = gtk.Window()
        w.add(widget)
        w.connect('delete-event',gtk.main_quit)
        w.show()
        gtk.main()
        
    def test_difftable ():
        class FakeRec:
            pass
        test_rec = FakeRec()
        test_rec.title = 'Shloppidy Recipe'
        test_data = {'rating':[4,7],
                     'category':['Dessert','Dessert, Cake'],
                     'cuisine':['American','All-American'],
                     'preptime':[6000,12000],
                     'cooktime':[6543,None]}
        
        t = DiffTable(test_data,test_rec)
        t.show()
        test_in_window(t)
        print t.selected_dic

    def test_merger (rd, conflicts):
        recs = [rd.get_rec(i) for i in conflicts]
        rmerger = RecipeMerger(rd)
        to_fill,conflict_dic = gourmet.recipeIdentifier.merge_recipes(rd,recs)
        if conflict_dic:
            dt = rmerger.uiMergeRecipes(recs)
            dt.show()
            test_in_window(dt)
            print dt.selected_dic
        elif to_fill:
            print 'Differences in ',conflicts,'can be auto-filled with',to_fill
        else:
            print 'No differences in ',conflicts
    import recipeManager
    rd = recipeManager.default_rec_manager()
    rmd = RecipeMergerDialog(rd)
    rmd.populate_tree()
    rmd.show()
    rmd.ui.get_object('window1').connect('delete-event',gtk.main_quit)
    gtk.main()
    #dups = rd.find_complete_duplicates()
    #for d in dups[5:]:
    #    test_merger(rd,d)
    
    
        

########NEW FILE########
__FILENAME__ = recipeMergerPlugin
from gourmet.plugin import ToolPlugin, ImportManagerPlugin
import gtk
import recipeMerger
from gettext import gettext as _
#from gourmet.gglobals import gt # for threading protection on import
#                                # hooks
from gourmet.plugin_loader import PRE,POST

class RecipeMergerImportManagerPlugin (ImportManagerPlugin):

    def activate (self, pluggable):
        pluggable.add_hook(PRE,'follow_up',self.follow_up_pre_hook)

    def follow_up_pre_hook (self, importManager, threadmanager, importer):
        print 'Running recipeMergerPlugin follow up post hook!'
        if importer.added_recs:
            print 'There are ',len(importer.added_recs),'added recs!'
            rmd = recipeMerger.RecipeMergerDialog(
                in_recipes=importer.added_recs,
                )
            rmd.show_if_there_are_dups(
                label=_('Some of the imported recipes appear to be duplicates. You can merge them here, or close this dialog to leave them as they are.')
                )
        return [threadmanager,importer],{}

class RecipeMergerPlugin (ToolPlugin):

    menu_items = '''
    <placeholder name="DataTool">
      <menuitem action="DuplicateMerger"/>
    </placeholder>'''

    menu_bars = ['RecipeIndexMenuBar']

    def activate (self, pluggable):
        ToolPlugin.activate(self,pluggable)
        pluggable.add_hook(PRE,'import_cleanup',self.import_cleanup_hook)

    def deactivate (self, pluggable):
        if hasattr(self,'pluggable'):
            pluggable.remove_hook(PRE,'import_cleanup',self.import_cleanup_hook)

    def remove (self):
        if hasattr(self,'pluggable'):
            self.pluggable.remove_hook(PRE,'import_cleanup',self.import_cleanup_hook)
        ToolPlugin.remove(self)                                     

    def import_cleanup_hook (self, rg, retval, *args, **kwargs):
        # Check for duplicates
        #gt.gtk_enter()
        if rg.last_impClass and rg.last_impClass.added_recs:
            rmd = recipeMerger.RecipeMergerDialog(
                rg.rd,
                in_recipes=rg.last_impClass.added_recs,
                on_close_callback=lambda *args: rg.redo_search()
                )
            rmd.show_if_there_are_dups(
                label=_('Some of the imported recipes appear to be duplicates. You can merge them here, or close this dialog to leave them as they are.')
                )
        #gt.gtk_leave()
    
    def setup_action_groups (self):
        self.action_group = gtk.ActionGroup('RecipeMergerPluginActionGroup')
        self.action_group.add_actions([
            ('DuplicateMerger',None,_('Find _duplicate recipes'),
             None,_('Find and remove duplicate recipes'),self.show_duplicate_merger)
            ]
                                      )
        self.action_groups.append(self.action_group)

    def show_duplicate_merger (self, *args):
        rmd = recipeMerger.RecipeMergerDialog(
            self.pluggable.rg.rd,
            on_close_callback=lambda *args: self.pluggable.rg.redo_search()
            )
        rmd.populate_tree_if_possible()
        rmd.show()
     

########NEW FILE########
__FILENAME__ = emailer
import urllib
from gourmet.gdebug import debug
import gourmet.gglobals as gglobals

class Emailer:
    def __init__ (self, emailaddress=None, subject=None, body=None, attachments=[]):
        self.emailaddress=None
        self.subject=subject
        self.body=body
        self.attachments=attachments
        self.connector_string = "?"

    def send_email (self):
        print 'send_email()'
        self.url = "mailto:"
        if self.emailaddress: self.url += self.emailaddress
        if self.subject:
            self.url_append('subject',self.subject)
        if self.body:
            self.url_append('body',self.body)
        for a in self.attachments:
            print 'Adding attachment',a
            self.url_append('attachment',a)              
        debug('launching URL %s'%self.url,0)
        gglobals.launch_url(self.url)

    def url_append (self, attr, value):
        self.url += "%s%s=%s"%(self.connector(),attr,urllib.quote(value.encode('utf-8','replace')))
                                                                   
    def connector (self):
        retval = self.connector_string
        self.connector_string = "&"
        return retval

if __name__ == '__main__':
    e = Emailer(emailaddress='tmhinkle@gmail.com',subject='Hello',body="<html><b>hello</b></html>")
    e.send_email()

########NEW FILE########
__FILENAME__ = emailer_plugin
import gtk
import gourmet.gtk_extras.dialog_extras as de
from gourmet.plugin import RecDisplayModule, UIPlugin, MainPlugin, ToolPlugin
from recipe_emailer import RecipeEmailer
from gettext import gettext as _

class EmailRecipePlugin (MainPlugin, UIPlugin):

    ui_string = '''
   <menubar name="RecipeIndexMenuBar">
         <menu name="Tools" action="Tools">
       <placeholder name="StandaloneTool">
           <menuitem action="EmailRecipes"/>
       </placeholder>
   </menu>
   </menubar>
    '''

    def setup_action_groups (self):
        self.actionGroup = gtk.ActionGroup('RecipeEmailerActionGroup')
        self.actionGroup.add_actions([
                ('EmailRecipes',None,_('Email recipes'),
                 None,_('Email all selected recipes (or all recipes if no recipes are selected'),self.email_selected),
                ])
        self.action_groups.append(self.actionGroup)
    
    def activate (self, pluggable):
        self.rg = self.pluggable = pluggable
        self.add_to_uimanager(pluggable.ui_manager)
    
    def get_selected_recs (self):
        recs = self.rg.get_selected_recs_from_rec_tree()
        if not recs:
            recs = self.rd.fetch_all(self.rd.recipe_table, deleted=False, sort_by=[('title',1)])
        return recs

    def email_selected (self, *args):
        recs = self.get_selected_recs()
        l = len(recs)
        if l > 20:
            if not de.getBoolean(
                title=_('Email recipes'),
                # only called for l>20, so fancy gettext methods
                # shouldn't be necessary if my knowledge of
                # linguistics serves me
                sublabel=_('Do you really want to email all %s selected recipes?')%l,
                custom_yes=_('Yes, e_mail them'),
                cancel=False,
                ):
                return
        re = RecipeEmailer(recs)
        re.send_email_with_attachments()
        

    

########NEW FILE########
__FILENAME__ = recipe_emailer
import gtk
import os.path, tempfile
from gourmet.GourmetRecipeManager import get_application
from emailer import Emailer
import StringIO
import gourmet.exporters.exportManager as exportManager
import gourmet.exporters.exporter as exporter

class StringIOfaker (StringIO.StringIO):
    def __init__ (self, *args, **kwargs):
        StringIO.StringIO.__init__(self, *args, **kwargs)

    def close (self, *args):
        pass

    def close_really (self):
        StringIO.StringIO.close(self)

class RecipeEmailer (Emailer):
    def __init__ (self, recipes, attachment_types=["pdf"], do_text=True):
        Emailer.__init__(self)
        self.attachments_left = self.attachment_types = list(attachment_types)
        self.attached = []
        self.recipes = recipes
        self.rg = get_application()
        self.rd = self.rg.rd
        self.change_units=self.rg.prefs.get('readableUnits',True)
        if len(recipes) > 1:
            self.subject = _("Recipes")
        elif recipes:
            self.subject = recipes[0].title

    def write_email_text (self):
        s = StringIOfaker()
        first = True
        e=exporter.ExporterMultirec(self.rd,
                                    self.recipes,
                                    s,
                                    padding="\n\n-----\n")
        e.run()
        if not self.body: self.body=""
        self.body += s.getvalue()
        s.close_really()

    def write_attachments (self):
        em = exportManager.get_export_manager()
        for typ in self.attachment_types:
            name = _('Recipes')
            if len(self.recipes)==1:
                name = self.recipes[0].title.replace(':','-').replace('\\','-').replace('/','-')
            fn = os.path.join(tempfile.gettempdir(),"%s.%s"%(name,typ))
            self.attachments.append(fn)
            instance = em.do_multiple_export(self.recipes, fn)
            instance.connect('completed',self.attachment_complete,typ)
            print 'Start thread to create ',typ,'!','->',fn
    
    def attachment_complete (self, thread, typ):
        self.attachments_left.remove(typ)
        if not self.attachments_left:
            print 'Attachments complete! Send email!'
            self.send_email()
    
    def send_email_with_attachments (self, emailaddress=None):
        if emailaddress: self.emailaddress=emailaddress
        self.write_email_text()
        self.write_attachments()
        
    #def send_email_html (self, emailaddress=None, include_plain_text=True):
    #    if include_plain_text: self.write_email_text()
    #   else: self.body = None
    #   if emailaddress: self.emailaddress=emailaddress
    #     self.write_email_html()
    #   self.send_email()

    def send_email_text (self, emailaddress=None):
        if emailaddress: self.emailaddress=emailaddress 
        self.write_email_text()
        self.send_email()
        

########NEW FILE########
__FILENAME__ = fieldEditor
import gtk, gobject, os.path
import gourmet.gglobals as gglobals
import gourmet.convert as convert
from gourmet.gtk_extras import cb_extras as cb
from gourmet.gtk_extras import dialog_extras as de
from gettext import ngettext
from gettext import gettext as _

class FieldEditor:
    """A generic "value" editor for mucking about with the database.
    """

    values = 'category','cuisine','source','link'

    def __init__ (self, rd, rg):
        self.field = None; self.other_field = None
        self.rd = rd; self.rg = rg
        self.ui = gtk.Builder()
        self.ui.add_from_file(os.path.join(gglobals.uibase,'valueEditor.ui'))
        self.__setup_widgets__()
        self.__setup_treeview__()
        self.ui.connect_signals({
            'on_changeValueButton_toggled':self.changeValueButtonToggledCB,
            'on_fieldToEditCombo_changed':self.fieldChangedCB,
            'on_otherChangeCheckButton_toggled':self.otherChangeToggleCB,
            'on_otherExpander_activate':self.otherChangeToggleCB,
            'on_otherFieldCombo_changed':self.otherFieldComboChangedCB,
            })
        
    def __setup_widgets__ (self):
        for w in [
            'valueDialog',
            'treeview',
            'fieldToEditCombo','newValueComboBoxEntry',
            'newValueEntry','changeValueButton',
            'deleteValueButton','forEachLabel',
            'otherExpander','otherFieldCombo',
            'otherNewValueEntry','otherNewValueComboBoxEntry',
            'otherValueBlurbLabel','otherChangeCheckButton',
            'leaveValueButton'
            ]:
            setattr(self,w,self.ui.get_object(w))
        self.act_on_selection_widgets = [
            self.deleteValueButton, self.changeValueButton,
            self.newValueEntry,self.otherChangeCheckButton,
            self.leaveValueButton
            ]
        # Set up the combo-widget at the top with the 
        self.fields = [gglobals.REC_ATTR_DIC[v] for v in self.values]
        cb.set_model_from_list(
            self.fieldToEditCombo,
            self.fields
            )
        cb.set_model_from_list(
            self.otherFieldCombo,
            self.fields
            )
        self.newValueComboBoxEntry.set_sensitive(False)
        self.otherValueBlurbLabel.hide()
        self.newValueEntryCompletion = gtk.EntryCompletion()
        self.newValueEntry.set_completion(self.newValueEntryCompletion)
        self.otherNewValueEntryCompletion = gtk.EntryCompletion()
        self.otherNewValueEntry.set_completion(
            self.otherNewValueEntryCompletion
            )
        self.valueDialog.connect('response',self.dialog_response_cb)
        self.valueDialog.set_response_sensitive(gtk.RESPONSE_APPLY,False)

    def __setup_treeview__ (self):
        renderer = gtk.CellRendererText()
        # If we have gtk > 2.8, set up text-wrapping
        try:
            renderer.get_property('wrap-width')
        except TypeError:
            pass
        else:
            renderer.set_property('wrap-mode',gtk.WRAP_WORD)
            renderer.set_property('wrap-width',400)
        col = gtk.TreeViewColumn('Value',
                           renderer,
                           text=0)
        self.treeview.append_column(col)
        self.treeview.get_selection().connect('changed',self.treeViewSelectionChanged)
        self.treeview.get_selection().set_mode(gtk.SELECTION_MULTIPLE)

    def changeValueButtonToggledCB (self, tb):
        if tb.get_active():
            self.newValueComboBoxEntry.set_sensitive(True)
        else:
            self.newValueComboBoxEntry.set_sensitive(False)

    def treeViewSelectionChanged (self, tvSelection):
        vals = self.get_selected_values(tvSelection)
        if len(vals) == 1: val_string = vals[0]
        elif len(vals) == 2: val_string = ' or '.join(vals)
        elif len(vals) > 0:
            val_string = ' or '.join([', '.join(vals[:-1]),vals[-1]])
        else: # len(vals)==0
            self.forEachLabel.set_text(_('For each selected value'))
        if vals:
            self.val_string = val_string
            self.forEachLabel.set_text(
                _('Where %(field)s is %(value)s')%{'value':val_string,
                                                      'field':self.field}
                )
        self.valueDialog.set_response_sensitive(gtk.RESPONSE_APPLY,(vals and True or False))
        
    def fieldChangedCB (self, combobox):
        name = cb.cb_get_active_text(combobox)
        self.field = gglobals.NAME_TO_ATTR.get(name,name)
        self.populate_treeview()
        other_fields = self.fields[:]
        if self.field != 'category':
            other_fields.remove(gglobals.REC_ATTR_DIC[self.field])
        cb.set_model_from_list(
            self.otherFieldCombo,
            other_fields
            )

    def otherFieldComboChangedCB (self, combobox):
        name = cb.cb_get_active_text(combobox)
        self.other_field = gglobals.NAME_TO_ATTR.get(name,name)
        if self.other_field == 'category':
            self.otherValueBlurbLabel.hide()
        else:
            self.otherValueBlurbLabel.show()
        mod = self.make_model_for_field(self.other_field)
        self.otherNewValueComboBoxEntry.set_model(mod)
        if self.otherNewValueComboBoxEntry.get_text_column()==-1:
            self.otherNewValueComboBoxEntry.set_text_column(0)
        self.otherNewValueEntryCompletion.set_model(mod)
        self.otherNewValueEntryCompletion.set_text_column(0)
        

    def populate_treeview (self):
        """Assume that self.field is set"""
        mod = self.make_model_for_field(self.field)
        self.treeview.set_model(mod)
        self.newValueComboBoxEntry.set_model(mod)
        if self.newValueComboBoxEntry.get_text_column()==-1:
            self.newValueComboBoxEntry.set_text_column(0)
        self.newValueEntryCompletion.set_model(mod)
        self.newValueEntryCompletion.set_text_column(0)

    def make_model_for_field (self, field):
        vals = self.rd.get_unique_values(field)
        mod = gtk.ListStore(str)
        for v in vals: mod.append((v,))
        return mod
        
    def run (self): return self.valueDialog.run()
    def show (self): return self.valueDialog.show()
    def hide (self): return self.valueDialog.hide()    

    def dialog_response_cb (self, dialog, response_id):
        if response_id == gtk.RESPONSE_CLOSE:
            self.valueDialog.hide()
        if response_id == gtk.RESPONSE_APPLY:
            criteria,table = self.get_criteria_and_table()
            count = self.rd.fetch_len(table,**criteria)
            count_text = ngettext('Change will affect %s recipe',
                                  'Change will affect %s recipes',
                                  count)%count
            if self.deleteValueButton.get_active():
                label = _('Delete %s where it is %s?')%(self.field,self.val_string)
                yes = gtk.STOCK_DELETE
            else:
                label = _('Change %s from %s to "%s"?')%(self.field,self.val_string,
                                                                                self.newValueEntry.get_text())
                yes = '_Change'
            if de.getBoolean(label=label,
                             sublabel='\n\n'.join([
                count_text,
                _('<i>This change is not reversable.</i>')
                ]),
                             custom_yes=yes,
                             custom_no=gtk.STOCK_CANCEL,
                             cancel=False):

                self.apply_changes(criteria,table)
                self.populate_treeview()

    def otherChangeToggleCB (self, widg):
        if widg!=self.otherChangeCheckButton:
            self.otherChangeCheckButton.activate()
        if self.otherChangeCheckButton.get_active():
            self.otherExpander.set_expanded(True)
        else:
            self.otherExpander.set_expanded(False)

    def get_changes (self):
        if self.deleteValueButton.get_active():
            value = None
        elif self.changeValueButton.get_active():
            value = self.newValueEntry.get_text()
        return {self.field:value}

    def get_other_changes (self):
        if self.otherChangeCheckButton.get_active():
            return {self.other_field:self.otherNewValueEntry.get_text()}
        else:
            return {}

    def get_selected_values (self, ts=None):
        if not ts:
            ts = self.treeview.get_selection()
        mod,paths = ts.get_selected_rows()
        values = []
        for p in paths:
            values.append(
                mod.get_value(mod.get_iter(p),0)
                )
        return values

    def get_criteria_and_table (self):
        values = self.get_selected_values()
        if len(values) > 1:
            criteria = {self.field:('==',('or',values))}
        elif len(values)==1:
            criteria = {self.field:values[0]}
        if self.field == 'category':
            table = self.rd.categories_table
        else:
            table = self.rd.recipe_table
        return criteria,table

    def apply_changes (self, criteria, table):
        changes = self.get_changes()
        other_changes = self.get_other_changes()
        if self.field != 'category' and self.other_field != 'category':
            changes.update(other_changes)
        elif other_changes:
            if self.other_field == 'category':
                # Inefficient, but works with our current backend
                # interface... and shouldn't be called often, so we'll
                # deal with the ugliness for now
                for r in self.rd.fetch_all(self.rd.recipe_table,**criteria):
                    if not self.rd.fetch_one(self.rd.categories_table,{'id':r.id}):
                        self.rd.do_add_cat({'id':r.id,'category':other_changes['category']})
            else:
                if self.field=='category':
                    IDs = [r.id for r in self.rd.fetch_all(self.rd.categories_table,**criteria)]
                    new_criteria = {'id':('==',('or',IDs))}
                    self.rd.update_by_criteria(
                        self.rd.recipe_table,
                        new_criteria,
                        other_changes
                        )
                else:
                    self.rd.update_by_criteria(
                        self.rd.recipe_table,
                        criteria,
                        other_changes
                        )
        if self.field=='category' and not changes['category']:
            self.rd.delete_by_criteria(table,criteria)
        else:
            if self.field=='category':
                table = self.rd.categories_table
            else:
                table = self.rd.recipe_table
            self.rd.update_by_criteria(table,criteria,changes)
        self.rg.reset_search()

if __name__ == '__main__':
    import recipeManager
    rm = recipeManager.default_rec_manager()
    class DummyRG:
        def reset_search (): pass
    w = gtk.Window()
    b = gtk.Button('edit me now')
    w.add(b); w.show_all()
    ve = FieldEditor(rm,DummyRG())
    b.connect('clicked',lambda *args: ve.run())
    w.connect('delete-event',gtk.main_quit)
    gtk.main()

########NEW FILE########
__FILENAME__ = zip_importer_plugin
from gourmet.plugin import ImporterPlugin
from gourmet.importers.importManager import ImportFileList
from zip_readers import archive_to_filelist
from gettext import gettext as _
import fnmatch

class ArchiveImporterPlugin (ImporterPlugin):

    get_source = False
    name = _('Archive (zip, tarball)')
    patterns = ['*.%s'%suffix for suffix in
                ['zip',
                 'tar','tar.gz','tgz','tar.bz2',
                 'gzip','gz']
                ]
    mimetypes = ['application/tar','application/zip','application/gzip']

    def test_file (self, filename):
        '''Given a filename, test whether the file is of this type.'''
        for p in self.patterns:
            if fnmatch.fnmatch(filename.lower(),p.lower()): return True

    def get_importer (self, filename):
        flist = archive_to_filelist(filename)
        print 'Filelist=',flist
        ifl = ImportFileList(flist)
        raise ifl

########NEW FILE########
__FILENAME__ = zip_readers
import zipfile, StringIO, tempfile, os, os.path
import tarfile, gzip
from gourmet.importers.webextras import read_socket_w_progress
from gourmet.importers.importer import add_to_fn
from gourmet.gdebug import debug

# This is simply a convenience. We read a zipfile, and then hand out a
# list of files which we can use to import from using our other
# importers.
#
# We will also conveniently handle tarballs

def archive_to_filelist (fi, progress=None, name='zipfile'):
    if tarfile.is_tarfile(fi):
        debug('tarball_to_filelist',0)
        return tarball_to_filelist(fi,progress,name)
    else:
        try:
            ifi = gzip.open(fi,'r')
            # we move forward a byte to trigger an error if this
            # is not a gzip file (hackish, I know)
            ifi.seek(1)
            ifi.seek(0)
            ifi.name = os.path.splitext(fi)[0]
            debug('returning ungzipped file %s'%ifi,0)
            return [ifi]
        except IOError:
            return zipfile_to_filelist(fi,progress,name)

def zipfile_to_filelist (fi, progress=None, name="zipfile"):
    """Take our zipfile and return a list of files.

    We're quite liberal in what we allow fi to be.  If fi is a string,
    we open it as a filename.  if fi is a file object, we handle it,
    even if it's an icky file object that needs some messy
    manipulation to work (i.e. a urllib.urlopen() object).
    """
    # handle filename
    if type(fi)==str: fi = open(fi,'rb')
    # handle unseekable
    elif not hasattr(fi,'seek'):
        # slurp up the file into a StringIO so we can seek within it
        debug('Slurping up file into StringIO',1)
        tmpfi=StringIO.StringIO(read_socket_w_progress(fi,progress,_('Loading zip archive')))
        fi.close()
        fi = tmpfi
    # and now we actually do our work...
    debug('ZipFile(fi)',1)
    zf=zipfile.ZipFile(fi)
    flist=[]
    fbase = os.path.join(tempfile.tempdir, name)
    while os.path.exists(fbase):
        fbase=add_to_fn(fbase)
    os.mkdir(fbase)
    nlist = zf.namelist()
    totlen=float(len(nlist))
    for i,n in enumerate(nlist):
        debug('Unzipping item %s'%i,1)
        if progress: progress(float(i)/totlen,_("Unzipping zip archive"))
        fn = os.path.join(fbase,n)
        ifi=open(fn,'wb')
        ifi.write(zf.read(n))
        ifi.close()
        flist.append(fn)
    zf.close()
    debug('zipfile returning filelist %s'%flist,1)
    return flist

def tarball_to_filelist (fi, progress=None, name="zipfile"):
    tb = tarfile.TarFile.open(fi,mode='r')
    fi_info = tb.next()
    filist = []
    while fi_info:
        fi = tb.extractfile(fi_info)
        if fi: filist.append(fi)
        fi_info = tb.next()
    debug('tarball_to_filelist returning %s'%filist,0)
    return filist
        

########NEW FILE########
__FILENAME__ = gxml2_exporter
import gourmet.exporters.exporter as exporter
import sys, xml.sax.saxutils, base64
from gourmet.exporters.xml_exporter import XmlExporter

class rec_to_xml (XmlExporter):
    """A vastly simplified recipe XML exporter.

    The previous XML format was written as a format designed for
    itself (its design predated gourmet). This one is really written
    as a simple way to save, load and exchange Gourmet recipes. As a
    result, the code is much simpler, and the format should be quicker
    to write and more convenient for exchanging single recipes.

    This implementation actually uses the DOM to ensure correctness.
    """

    doc_element = 'gourmetDoc'
    doctype_desc = ''
    dtd_path = ''
    ALLOW_PLUGINS_TO_WRITE_NEW_FIELDS = False
    
    def write_head (self):
        self.rec_el = self.create_element_with_attrs("recipe",{'id':self.r.id})
        self.top_element.appendChild(self.rec_el)

    def write_attr (self, attr, text):
        self.rec_el.appendChild(self.create_text_element(attr.replace(' ',''),text))
        
    def write_text (self, attr, text):
        self.rec_el.appendChild(
            self.create_text_element(attr.replace(' ',''),text)
            )

    def write_image (self, image):
        image_el = self.create_element_with_attrs('image',{'format':'jpeg'})
        image_el.appendChild(
            self.xmlDoc.createCDATASection(base64.b64encode(image))
            )
        self.rec_el.appendChild(image_el)
    
    def handle_italic (self, chunk): return '&lt;i&gt;'+chunk+'&lt;/i&gt;'
    def handle_bold (self, chunk): return '&lt;b&gt;'+chunk+'&lt;/b&gt;'    
    def handle_underline (self, chunk): return '&lt;u&gt;'+chunk+'&lt;/u&gt;'    
        
    def write_foot (self):
        if self.i_created_this_document:
            self.xmlDoc.writexml(self.ofi, newl = '\n', addindent = "\t", 
                                 encoding = "UTF-8")

    def write_inghead (self):
        self.inglist_el = self.xmlDoc.createElement('ingredient-list')
        self.top_inglist = self.inglist_el # because groups will let us nest...
        self.rec_el.appendChild(self.inglist_el)

    def write_ingref (self, amount=1, unit=None, item=None, refid=None, optional=False):
        self.inglist_el.appendChild(
            self.create_text_element('ingref',
                                     item,
                                     {'refid':str(refid),
                                      'amount':amount}
                                     )
            )
        
    def write_ing (self, amount=1, unit=None, item=None, key=None, optional=False):
        if optional:
            ing_el = self.create_element_with_attrs('ingredient',{'optional':'yes'})
        else:
            ing_el = self.create_element_with_attrs('ingredient',{})
        self.inglist_el.appendChild(ing_el)
        if amount:
            ing_el.appendChild(
                self.create_text_element('amount',amount)
                )
        if unit:
           ing_el.appendChild(
               self.create_text_element('unit',unit)
               )
        if item:
            ing_el.appendChild(
                self.create_text_element('item',item)
                )
        if key:
            ing_el.appendChild(
                self.create_text_element('key',key)
                )

    def write_grouphead (self, name):
        group_el = self.xmlDoc.createElement('inggroup')
        group_el.appendChild(
            self.create_text_element('groupname',name)
            )
        self.inglist_el = group_el
        
    def write_groupfoot (self):
        self.top_inglist.appendChild(self.inglist_el)
        self.inglist_el = self.top_inglist
    

class recipe_table_to_xml (exporter.ExporterMultirec, XmlExporter):
    doc_element = 'gourmetDoc'
    doctype_desc = ''
    dtd_path = ''
    
    def __init__ (self, rd, recipe_table, out, one_file=True, change_units=False,
                  mult=1):
        self.create_xmldoc()
        exporter.ExporterMultirec.__init__(
            self, rd, recipe_table, out, one_file=True, ext='xml', exporter=rec_to_xml,
            exporter_kwargs={'change_units':change_units,
                             'mult':mult,
                             'xmlDoc':self.xmlDoc,
                             # This order is now in our DTD so we'd
                             # better make it solid.
                             'attr_order':('title',
                                           'category','cuisine',
                                           'source','link',
                                           'rating',
                                           'preptime','cooktime',
                                           'yields',
                                           ),
                             'order':['attr','image','ings','text'],
                             }
            )
        

    def write_footer (self, *args):
        self.xmlDoc.writexml(self.ofi, newl = '\n', addindent = "\t", 
                             encoding = "UTF-8")
        
def quoteattr (str):
    return xml.sax.saxutils.quoteattr(xml.sax.saxutils.escape(str))

########NEW FILE########
__FILENAME__ = gxml2_importer
import xml.sax, re, sys, xml.sax.saxutils
from gourmet.importers import xml_importer
from gourmet.convert import NUMBER_FINDER
from gourmet.gglobals import REC_ATTRS, TEXT_ATTR_DIC
import base64
from gettext import gettext as _

class RecHandler (xml_importer.RecHandler):
    ING_ATTRS =  {
        # XML : DATABASE COLUMN
        "item":"item",
        "unit":"unit",
        "amount":"amount",
        "key":"ingkey",
        }

    def __init__ (self, total=None, conv=None, parent_thread=None):
        xml_importer.RecHandler.__init__(self,total,conv=conv, parent_thread=parent_thread)
        self.REC_ATTRS = [r[0] for r in REC_ATTRS]
        self.REC_ATTRS += [r for r in TEXT_ATTR_DIC.keys()]
        
    def startElement(self, name, attrs):
        self.elbuf = ""        
        if name=='recipe':
            id=attrs.get('id',None)
            if id:
                self.start_rec(dict={'id':id})
            else:
                self.start_rec()
            
        if name=='ingredient':
            self.start_ing(recipe_id=self.rec['id'])
            if attrs.get('optional',False):
                if attrs.get('optional',False) not in ['no','No','False','false','None']:
                    self.ing['optional']=True
        if name=='ingref':
            self.start_ing(id=self.rec['id'])
            self.add_ref(unquoteattr(attrs.get('refid')))
            self.add_amt(unquoteattr(attrs.get('amount')))
            
    def endElement (self, name):
        if name=='recipe':
            self.commit_rec()
        elif name=='groupname':
            self.group=xml.sax.saxutils.unescape(self.elbuf.strip())
        elif name=='inggroup':
            self.group=None
        elif name=='ingref':
            self.add_item(xml.sax.saxutils.unescape(self.elbuf.strip()))
            self.commit_ing()
        elif name=='ingredient':
            self.commit_ing()
        elif name=='image':
            self.rec['image']=base64.b64decode(self.elbuf.strip())
        elif name=='yields':
            txt = xml.sax.saxutils.unescape(self.elbuf.strip())
            match = NUMBER_FINDER.search(txt)
            if match:
                number = txt[match.start():match.end()]
                unit = txt[match.end():].strip()
                self.rec['yields'] = number
                self.rec['yield_unit'] = unit
            else:
                self.rec['yields'] = 1
                self.rec['yield_unit'] = unit
                print 'Warning, recorded',txt,'as 1 ',unit
        elif name in self.REC_ATTRS:
            self.rec[str(name)]=xml.sax.saxutils.unescape(self.elbuf.strip())
        elif name in self.ING_ATTRS.keys():
            self.ing[str(self.ING_ATTRS[name])]=xml.sax.saxutils.unescape(self.elbuf.strip())


class Converter (xml_importer.Converter):
    
    def __init__ (self, filename, conv=None):
        xml_importer.Converter.__init__(self,filename,RecHandler,
                                        recMarker="</recipe>",
                                        conv=conv,
                                        name='GXML2 Importer')
        

def unquoteattr (str):
    return xml.sax.saxutils.unescape(str).replace("_"," ")

########NEW FILE########
__FILENAME__ = gxml_exporter_plugin
import re

from gourmet.plugin import ExporterPlugin
from gourmet.convert import seconds_to_timestring, float_to_frac
import gxml2_exporter
from gettext import gettext as _

GXML = _('Gourmet XML File')

class GourmetExportChecker:

    def check_rec (self, rec, file):
        self.txt = file.read()
        self.rec = rec
        self.check_attrs()

    def check_attrs (self):
        self.txt = self.txt.decode('utf-8')
        for attr in ['title','cuisine',
                     'source','link']:
            if getattr(self.rec,attr):
                assert re.search('<%(attr)s>\s*%(val)s\s*</%(attr)s>'%{
                    'attr':attr,
                    'val':getattr(self.rec,attr)
                    },
                                 self.txt), \
                                 'Did not find %s value %s'%(attr,getattr(self.rec,attr))
        if self.rec.yields:
            assert re.search('<yields>\s*%s\s*%s\s*</yields>'%(
                    self.rec.yields,
                    self.rec.yield_unit),
                             self.txt) or \
                             re.search('<yields>\s*%s\s*%s\s*</yields>'%(
                                     float_to_frac(self.rec.yields),
                                     self.rec.yield_unit),
                                       self.txt), \
                                       'Did not find yields value %s %s'%(self.rec.yields,
                                                                self.rec.yield_unit)
        for att in ['preptime','cooktime']:
            if getattr(self.rec,att):
                tstr = seconds_to_timestring(getattr(self.rec,att))
                assert re.search('<%(att)s>\s*%(tstr)s\s*</%(att)s>'%locals(),self.txt),\
                       'Did not find %s value %s'%(att,tstr)

class GourmetExporterPlugin (ExporterPlugin):

    label = _('Gourmet XML Export')
    sublabel = _('Exporting recipes to Gourmet XML file %(file)s.')
    single_completed_string = _('Recipe saved in Gourmet XML file %(file)s.'),
    filetype_desc = GXML
    saveas_filters = [GXML,['text/xml'],['*.grmt','*.xml','*.XML']]
    saveas_single_filters =     saveas_filters

    def get_multiple_exporter (self, args):
        return gxml2_exporter.recipe_table_to_xml(
            args['rd'],
            args['rv'],
            args['file'],
            )

    def do_single_export (self, args)    :
        gxml2_exporter.recipe_table_to_xml(args['rd'],
                                           [args['rec']],
                                           args['out'],
                                           change_units=args['change_units'],
                                           mult=args['mult']
                                           ).run()

    def run_extra_prefs_dialog (self):
        pass

    def check_export (self, rec, file):
        gec = GourmetExportChecker()
        gec.check_rec(rec,file)

########NEW FILE########
__FILENAME__ = gxml_importer
import xml.sax, re, sys, xml.sax.saxutils
from gourmet.importers import xml_importer
from gourmet.gdebug import debug
import base64
from gettext import gettext as _

unquoteattr = xml_importer.unquoteattr

class RecHandler (xml_importer.RecHandler):
    def __init__ (self, total=None, conv=None, parent_thread=None):
        xml_importer.RecHandler.__init__(self,total,conv=conv,parent_thread=parent_thread)
        self.meta={}
        self.in_mixed = 0
        self.meta['cuisine']={}
        self.meta['source']={}
        self.meta['category']={}
        #self.start_rec()
        
    def startElement(self, name, attrs):
        self.elbuf = ""        
        if name=='category' or name=='cuisine' or name=='source':
            self.in_mixed=0
            self.metaid=unquoteattr(attrs.get('id',""))
        if name=='recipe':
            self.in_mixed=0
            self.start_rec()
            for att in ['cuisine','servings',
                        'rating','description','category','source']:
                self.rec[att]=unquoteattr(attrs.get(att,""))
            for att in ['cuisine','source','category']:
                raw = unquoteattr(attrs.get(att,''))
                if raw:
                    if self.meta[att].has_key(raw):
                        self.rec[att]=self.meta[att][raw]
                    else:
                        self.rec[att]=raw
                        print "Warning: can't translate ",raw
        if name=='image':
            self.in_mixed=0            
        if name=='inggroup':
            self.in_mixed=0
            self.group=unquoteattr(attrs.get('name'))
        if name=='ingredient':
            self.in_mixed=0
            self.start_ing(id=self.rec['id'])
            if attrs.get('optional',False):
                if attrs.get('optional',False) not in ['no','false','False','No','None']: #support for obsolete values
                    self.ing['optional']=True
        if name=='ingref':
            self.in_mixed=0
            self.start_ing(id=self.rec['id'])
            self.add_ref(unquoteattr(attrs.get('refid')))
            self.add_amt(unquoteattr(attrs.get('amount')))
        if name=='amount':
            self.in_mixed=0
            for att in ['unit']:
                self.ing[att]=unquoteattr(attrs.get(att,""))
        if name=='item':
            self.in_mixed=0
            for att in ['ingkey']:
                self.ing[att]=unquoteattr(attrs.get(att,""))
        if self.in_mixed:
            self.mixed += "<%s" % name
            for (n,v) in attrs.items():
                self.mixed += " %s='%s'" % (n,v)
            self.mixed += ">"
        if name=='instructions' or name=='modifications':
            self.in_mixed = 1
            self.mixed = ""
            
    def endElement (self, name):
        if name=='category' or name=='cuisine' or name=='source':
            self.meta[name][self.metaid]=xml.sax.saxutils.unescape(self.elbuf)
        if name=='title':
            self.rec['title']=xml.sax.saxutils.unescape(self.elbuf)
        if name=='image':
            self.rec['image']=base64.b64decode(self.elbuf)
        if name=='recipe':
            #self.rd.add_rec(self.rec)
            self.commit_rec()
        if name=='inggroup':
            self.group=None
        if name=='ingref':
            self.add_item(xml.sax.saxutils.unescape(self.elbuf))
            self.commit_ing()
        if name=='ingredient':
            self.commit_ing()
        if name=='item':
            self.add_item(xml.sax.saxutils.unescape(self.elbuf))
        if name=='amount':
            self.add_amt(self.elbuf)
        if name=='instructions' or name=='modifications':
            self.in_mixed = 0
            self.mixed += self.elbuf
            # special unescaping of our grand little tags
            for (eop,op,ecl,cl) in [('&lt;%s&gt;'%t,'<%s>'%t,'&lt;/%s&gt;'%t,'</%s>'%t)
                                    for t in 'b','i','u']:
                self.mixed=self.mixed.replace(eop,op)
                self.mixed=self.mixed.replace(ecl,cl)
            self.rec[name]=self.mixed
        if self.in_mixed:
            self.mixed += self.elbuf
            self.mixed += "</%s>" % name

class Converter (xml_importer.Converter):
    def __init__ (self, filename, conv=None):
        xml_importer.Converter.__init__(self,filename,RecHandler,
                                        recMarker="</recipe>",
                                        conv=conv,
                                        name='GXML Importer')

def unquoteattr (str):
    return xml.sax.saxutils.unescape(str).replace("_"," ")

########NEW FILE########
__FILENAME__ = gxml_importer_plugin
# -*- coding: utf-8 -*-

import os, os.path

from gourmet.plugin import ImporterPlugin
from gourmet.importers.importer import Tester
from gourmet.recipeManager import get_recipe_manager
from gourmet.threadManager import get_thread_manager
import gxml2_importer, gxml_importer
from gettext import gettext as _

test_dir = os.path.split(__file__)[0] # our directory src/lib/plugins/import_export/plugin/*/
test_dir = os.path.split(test_dir)[0] # one back... src/lib/plugins/import_export/plugin/
test_dir = os.path.split(test_dir)[0] # one back... src/lib/plugins/import_export/
test_dir = os.path.split(test_dir)[0] # one back... src/lib/plugins/
test_dir = os.path.split(test_dir)[0] # one back... src/lib/
test_dir = os.path.split(test_dir)[0] # one back... src/
test_dir = os.path.join(test_dir,'tests','recipe_files')

class GxmlImportTester:

    def __init__ (self):
        from gourmet.recipeManager import get_recipe_manager
        self.rm = get_recipe_manager()

    def run_test (self, recipe_objects, filename):
        if filename.endswith('test_set.grmt'):
            self.run_test_set_test(recipe_objects)

    def run_test_set_test (self, recs):
        assert u'Amazing rice' in [r.title for r in recs], "Titles were: %s"%([r.title for r in recs])
        rice = recs[0]
        if rice.title != u'Amazing rice':
            rice = recs[1]
            sauce = recs[0]
        else:
            sauce = recs[1]
        assert sauce.source == 'Tom\'s imagination','value was %s'%sauce.source
        assert sauce.link == 'http://slashdot.org', 'value was %s'%sauce.link
        ings = self.rm.get_ings(rice)
        assert ings[1].refid == sauce.id,'Ingredient reference did not export properly'
        sings = self.rm.get_ings(sauce)
        assert sings[1].inggroup == 'veggies','value was %s'%sings[0].inggroup
        assert sings[1].item == u'jalapeño peppers','value was "%s",%s'%(sings[1].item,
                                                                         type(sings[1].item)
                                                                         )
        self.is_markup_valid(sauce)
        self.is_markup_valid(rice)        
        assert '<i>well' in sauce.instructions, 'value was %s'%sauce.instructions
        assert sauce.image
        assert sauce.thumb

    def is_markup_valid (self, rec):
        import pango
        pango.parse_markup(rec.instructions or '')
        pango.parse_markup(rec.modifications or '')



class GourmetXML2Plugin (ImporterPlugin):

    name = _('Gourmet XML File')
    patterns = ['*.xml','*.grmt','*.gourmet']
    mimetypes = ['text/xml','application/xml','text/plain']

    def test_file (self, filename):
        return Tester('.*<gourmetDoc[> ]').test(filename)

    def get_importer (self, filename):
        return gxml2_importer.Converter(filename)


class GourmetXMLPlugin (ImporterPlugin):

    name = _('Gourmet XML File (Obsolete)')
    patterns = ['*.xml','*.grmt','*.gourmet']
    mimetypes = ['text/xml','application/xml','text/plain']

    def test_file (self, filename):
        return Tester('.*<recipeDoc[> ]').test(filename)

    def get_importer (self, filename):
        return gxml_importer.Converter(filename)

    def get_import_tests (self):
        '''Return an alist with files to check and tester functions
        that will be run to test the imported recipes. The function
        will be called with the following signature

        tester(recipe_objects, filename, rd)
        '''
        return [
            (os.path.join(test_dir,'test_set.grmt'),
             GxmlImportTester().run_test),
             ]

########NEW FILE########
__FILENAME__ = html_exporter
import re, os.path, os, xml.sax.saxutils, time, shutil, urllib, textwrap
from gettext import gettext as _
from gourmet import convert,gglobals
from gourmet.exporters.exporter import ExporterMultirec, exporter_mult

HTML_HEADER_START = """<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
  """
HTML_HEADER_CLOSE = """<meta http-equiv="Content-Style-Stype" content="text/css">
     <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
     </head>"""


class html_exporter (exporter_mult):
    def __init__ (self, rd, r, out, conv=None,
                  css=os.path.join(gglobals.style_dir,"default.css"),
                  embed_css=True, start_html=True, end_html=True, imagedir="pics/", imgcount=1,
                  link_generator=None,
                  # exporter_mult args
                  mult=1,
                  change_units=True,
                  ):
        """We export web pages. We have a number of possible options
        here. css is a css file which will be embedded if embed_css is
        true or referenced if not. start_html and end_html specify
        whether or not to write header info (so we can be called in
        the midst of another script writing a page). imgcount allows
        an outside function to keep number exported images, handing
        us the imgcount at the start of our export. link_generator
        will be handed the ID referenced by any recipes called for
        as ingredients. It should return a URL for that recipe
        or None if it can't reference the recipe based on the ID."""
        self.start_html=start_html
        self.end_html=end_html
        self.embed_css=embed_css
        self.css=css
        self.link_generator=link_generator
        if imagedir and imagedir[-1] != os.path.sep: imagedir += os.path.sep #make sure we end w/ slash
        if not imagedir: imagedir = "" #make sure it's a string
        self.imagedir_absolute = os.path.join(os.path.split(out.name)[0],imagedir)
        self.imagedir = imagedir
        exporter_mult.__init__(self, rd, r, out,
                               conv=conv,
                               imgcount=imgcount,
                               mult=mult,
                               change_units=change_units,
                               do_markup=True,
                               use_ml=True)
        
    def htmlify (self, text):
        t=text.strip()
        #t=xml.sax.saxutils.escape(t)
        t="<p>%s</p>"%t
        t=re.sub('\n\n+','</p><p>',t)
        t=re.sub('\n','<br>',t)
        return t

    def write_head (self):
        title = self._grab_attr_(self.r,'title')
        if not title: title = _('Recipe')
        title=xml.sax.saxutils.escape(title)
        if self.start_html:
            self.out.write(HTML_HEADER_START)
            self.out.write("<title>%s</title>"%title)
            if self.css:
                if self.embed_css:
                    self.out.write("<style type='text/css'><!--\n")
                    f=open(self.css,'r')
                    for l in f.readlines():
                        self.out.write(l)
                    f.close()
                    self.out.write("--></style>")
                else:
                    self.out.write("<link rel='stylesheet' href='%s' type='text/css'>"%self.make_relative_link(self.css))
            self.out.write(HTML_HEADER_CLOSE)
            self.out.write('<body>')
        self.out.write('<div class="recipe" itemscope itemtype="http://schema.org/Recipe">')
        
    def write_image (self, image):
        imgout = os.path.join(self.imagedir_absolute,"%s.jpg"%self.imgcount)
        while os.path.isfile(imgout):
            self.imgcount += 1
            imgout = os.path.join(self.imagedir_absolute,"%s.jpg"%self.imgcount)
        if not os.path.isdir(self.imagedir_absolute):
            os.mkdir(self.imagedir_absolute)
        o = open(imgout,'wb')
        o.write(image)
        o.close()
        # we use urllib here because os.path may fsck up slashes for urls.
        self.out.write('<img src="%s" itemprop="image">'%self.make_relative_link("%s%s.jpg"%(self.imagedir,
                                                                            self.imgcount)
                                                                )
                       )
        self.images.append(imgout)
        
    def write_inghead (self):
        self.out.write('<div class="ing"><h3>%s</h3><ul class="ing">'%_('Ingredients'))

    def write_text (self, label, text):
        attr = gglobals.NAME_TO_ATTR.get(label,label)
        if attr == 'instructions':
            self.out.write('<div class="%s"><h3 class="%s">%s</h3><div itemprop="recipeInstructions">%s</div></div>' % (attr,label,label,self.htmlify(text)))
        else:
            self.out.write('<div class="%s"><h3 class="%s">%s</h3>%s</div>' % (attr,label,label,self.htmlify(text)))

    def handle_italic (self, chunk): return "<em>" + chunk + "</em>"
    def handle_bold (self, chunk): return "<strong>" + chunk + "</strong>"
    def handle_underline (self, chunk): return "<u>" + chunk + "</u>"

    def write_attr_head (self):
        self.out.write("<div class='header'>")

    def write_attr (self, label, text):
        attr = gglobals.NAME_TO_ATTR.get(label,label)
        if attr=='link':
            webpage = text.strip('http://')
            webpage = webpage.split('/')[0]
            self.out.write('<a href="%s">'%text +
                           _('Original Page from %s')%webpage +
                           '</a>\n')
        elif attr == 'rating':
            rating, rest = text.split('/', 1)
            self.out.write('<p class="%s" itemprop="aggregateRating" itemscope itemtype="http://schema.org/AggregateRating"><span class="label">%s:</span> <span itemprop="ratingValue">%s</span><span>/%s</span></p>\n' % (attr, label.capitalize(), rating, rest))
        else:
            itemprop = None
            if attr == 'title':
                itemprop = 'name'
            elif attr == 'category':
                itemprop = 'recipeCategory'
            elif attr == 'cuisine':
                itemprop = 'recipeCuisine'
            elif attr == 'yields':
                itemprop = 'recipeYield'
            elif attr == 'preptime':
                itemprop = 'prepTime'
            elif attr == 'cooktime':
                itemprop = 'cookTime'
            elif attr == 'instructions':
                itemprop = 'recipeInstructions'
            if itemprop:
                self.out.write('<p class="%s"><span class="label">%s:</span> <span itemprop="%s">%s</span></p>\n' % (attr, label.capitalize(), itemprop, xml.sax.saxutils.escape(text)))
            else:
                self.out.write("<p class='%s'><span class='label'>%s:</span> %s</p>\n"%(attr, label.capitalize(), xml.sax.saxutils.escape(text)))
        
    def write_attr_foot (self):
        self.out.write("</div>")
    
    def write_grouphead (self, name):
        self.out.write("<li class='inggroup'>%s:<ul class='ing'>"%name)

    def write_groupfoot (self):
        self.out.write("</ul></li>")
                            
    def write_ingref (self, amount, unit, item, refid, optional):
        link=False
        if self.link_generator:
            link=self.link_generator(refid)
            if link:
                self.out.write("<a href='")
                self.out.write(
                    self.make_relative_link(link)
                    #xml.sax.saxutils.escape(link).replace(" ","%20")
                    #self.make_relative_link(link)
                    )
                self.out.write("'>")
        self.write_ing (amount, unit, item, optional=optional)
        if link: self.out.write("</a>")

    def write_ing (self, amount=1, unit=None,
                   item=None, key=None, optional=False):
        self.out.write('<li class="ing" itemprop="ingredients">')
        for o in [amount, unit, item]:
            if o: self.out.write(xml.sax.saxutils.escape("%s "%o))
        if optional:
            self.out.write("(%s)"%_('optional'))
        self.out.write("</li>\n")
    
    def write_ingfoot (self):
        self.out.write('</ul>\n</div>\n')

    def write_foot (self):
        self.out.write("</div>\n")
        if self.end_html:
            self.out.write('\n</body>\n</html>')

    def make_relative_link (self, filename):
        try:
            outdir = os.path.split(self.out.name)[0] + os.path.sep
            if filename.find(outdir)==0:
                filename=filename[len(outdir):]
        except:
            pass
        return linkify(filename)

class website_exporter (ExporterMultirec):
    def __init__ (self, rd, recipe_table, out, conv=None, ext='htm', copy_css=True,
                  css=os.path.join(gglobals.style_dir,'default.css'),
                  imagedir='pics' + os.path.sep,
                  index_rows=['title','category','cuisine','rating','yields'],
                  progress_func=None,
                  change_units=False,
                  mult=1):
        self.ext=ext
        self.css=css
        self.embed_css = False
        if copy_css:
            styleout = os.path.join(out,'style.css')
            if not os.path.isdir(out):
                os.makedirs(out)
            to_copy = open(self.css,'r')
            print 'writing css to ',styleout
            to_paste = open(styleout,'w')
            to_paste.write(to_copy.read())
            to_copy.close(); to_paste.close()
            self.css = styleout
        self.imagedir=imagedir
        self.index_rows=index_rows
        self.imgcount=1
        self.added_dict={}
        self.exportargs={'embed_css': False,
                          'css': self.css,
                          'imgcount': self.imgcount,
                         'imagedir':self.imagedir,
                         'link_generator': self.generate_link,
                         'change_units':change_units,
                         'mult':mult}
        if conv:
            self.exportargs['conv']=conv
        ExporterMultirec.__init__(self, rd, recipe_table, out,
                                  one_file=False,
                                  ext=self.ext,
                                  progress_func=progress_func,
                                  exporter=html_exporter,
                                  exporter_kwargs=self.exportargs)
        
    def write_header (self):
        self.indexfn = os.path.join(self.outdir,'index%s%s'%(os.path.extsep,self.ext))
        self.indexf = open(self.indexfn,'w')
        self.indexf.write(HTML_HEADER_START)
        self.indexf.write("<title>Recipe Index</title>")
        if self.embed_css:
            self.indexf.write("<style type='text/css'><!--\n")
            f=open(self.css,'r')
            for l in f.readlines():
                self.indexf.write(l)
            f.close()
            self.indexf.write("--></style>")
        else:
            self.indexf.write("<link rel='stylesheet' href='%s' type='text/css'>"%self.make_relative_link(self.css))
        self.indexf.write(HTML_HEADER_CLOSE)
        self.indexf.write('<body>')
        self.indexf.write('<div class="index"><table class="index">\n<tr>')
        for r in self.index_rows:
            self.indexf.write('<th class="%s">%s</th>'%(r,gglobals.REC_ATTR_DIC[r]))
        self.indexf.write('</tr>\n')    

    def recipe_hook (self, rec, filename, exporter):
        """Add index entry"""
        # we link from the first row
        
        self.indexf.write(
            """<tr><td class="%s">
                     <a href="%s">%s</a>
                   </td>"""%(self.index_rows[0],
                             #xml.sax.saxutils.escape(filename).replace(" ","%20"),
                             self.make_relative_link(filename),
                             xml.sax.saxutils.escape(self._grab_attr_(rec,self.index_rows[0]))
                             ))
        for r in self.index_rows[1:]:
            self.indexf.write('<td class="%s">%s</td>'%(r,self._grab_attr_(rec,r)))
        self.indexf.write('</tr>')
        self.imgcount=exporter.imgcount
        self.added_dict[rec.id]=filename

    def write_footer (self):
        self.indexf.write('</table></div></body></html>')
        self.indexf.close()

    def generate_link (self, id):
        if self.added_dict.has_key(id):
            return self.added_dict[id]
        else:
            rec = self.rd.get_rec(id)
            if rec:
                return self.generate_filename(rec,self.ext,add_id=True)
            else:
                return None

    def make_relative_link (self, filename):
        if self.outdir[-1] != os.path.sep:
            outdir = self.outdir + os.path.sep
        else: outdir = self.outdir
        if filename.find(outdir)==0:
            filename=filename[len(outdir):]
        return linkify(filename)

def linkify (filename):
    ret = filename.replace('\\','/')
    ret = filename.replace(' ','%20')
    return xml.sax.saxutils.escape(filename)
    

########NEW FILE########
__FILENAME__ = html_exporter_plugin
from gourmet.plugin import ExporterPlugin
import html_exporter
from gettext import gettext as _

WEBPAGE = _('HTML Web Page')

class HtmlExporterPlugin (ExporterPlugin):

    label = _('Exporting Webpage')
    sublabel = _('Exporting recipes to HTML files in directory %(file)s')
    single_completed_string = _('Recipe saved as HTML file %(file)s')
    filetype_desc = WEBPAGE
    saveas_filters = [WEBPAGE,['text/html'],['*.html']]
    saveas_single_filters =     [WEBPAGE,['text/html'],['*.html','*.htm','*.HTM','*.HTML']]

    def get_multiple_exporter (self, args):
        return html_exporter.website_exporter(
            args['rd'], 
            args['rv'],
            args['file'],
            #args['conv'],
            #progress_func=args['prog']
            )

    def do_single_export (self, args)    :
        he = html_exporter.html_exporter(
            args['rd'],
            args['rec'],
            args['out'],
            change_units=args['change_units'],
            mult=args['mult'],
            #conv=args['conv']
            )
        he.run()

    def run_extra_prefs_dialog (self):
        pass

########NEW FILE########
__FILENAME__ = krecipe_importer
import xml.sax, re, sys, xml.sax.saxutils
import base64
from gourmet.importers import xml_importer

class KrecHandler (xml_importer.RecHandler):
    ADD = 1
    IS = 2
    AND = 3
    BASE_64 = 4
    RECTAGS={'title':('title',IS),
             'author':('source',ADD),
             # FIX ME: IMAGE SUPPORT IS BROKEN!
             'pic':('image',BASE_64),
             'cat':('category',ADD),
             'serving':('servings',IS),
             'preparation-time':('preptime',IS),
             'krecipes-instructions':('instructions',ADD)
             }
    INGTAGS={'name':(('item','ingkey'),AND),
             'amount':('amount',IS),
             'unit':('unit',IS),
             'prep':('item',ADD),
             }
    RECIPE_TAG = 'krecipes-recipe'
    ING_TAG = 'ingredient'
    
    def __init__ (self, total=None, conv=None, parent_thread=None):
        self.in_mixed = 0
        self.rec={}
        self.ing={}
        xml_importer.RecHandler.__init__(self,total,conv=conv,parent_thread=parent_thread)

    def startElement (self, name, attrs):
        self.elbuf = ""
        if name==self.RECIPE_TAG:
            self.start_rec()
        if name==self.ING_TAG:
            self.start_ing()
        if name=='ingredient-group':
            self.group=attrs.get('name','')
            
    def endElement (self, name):
        key,method=None,None
        # krecipe-recipe marks a recipe end!
        if name==self.RECIPE_TAG:
            self.commit_rec()
            return
        if name=='ingredient-group':
            self.group=None
        if name==self.ING_TAG:
            self.commit_ing()
        elif self.RECTAGS.has_key(name):
            obj = self.rec
            key,method = self.RECTAGS[name]
        elif self.INGTAGS.has_key(name):
            obj = self.ing
            key,method = self.INGTAGS[name]
        if key:
            if method == self.ADD and obj.has_key(key):
                obj[key]=obj[key]+", "+self.elbuf
            elif method == self.AND:
                for k in key:
                    obj[k]=self.elbuf
            elif method == self.BASE_64:
                obj[key]=base64.b64decode(self.elbuf)
            else:
                obj[key]=self.elbuf

    
class Converter (xml_importer.Converter):
    def __init__ (self, filename):
        xml_importer.Converter.__init__(self,filename,KrecHandler,
                              recMarker="</krecipe-recipe>"
                              )
        

########NEW FILE########
__FILENAME__ = krecipe_importer_plugin
from gourmet.plugin import ImporterPlugin
from gourmet.importers.importer import Tester
from gourmet.threadManager import get_thread_manager
import krecipe_importer
from gettext import gettext as _

class KrecipeImporterPlugin (ImporterPlugin):

    name = _('KRecipe XML File')
    patterns = ['*.xml','*.kreml']
    mimetypes = ['text/xml','application/xml','text/plain']

    def test_file (self, filename):
        return Tester('.*<krecipes.*[> ]').test(filename)

    def get_importer (self, filename):
        return krecipe_importer.Converter(filename)

########NEW FILE########
__FILENAME__ = mastercook_importer
import gourmet.importers.importer as importer
import xml.sax, re, os.path
from gourmet.gdebug import debug
from gourmet.importers.xml_importer import unquoteattr
import gourmet.importers.xml_importer as xml_importer
from gettext import gettext as _

class Mx2Cleaner:
    def __init__ (self):
        self.regs_to_toss = ["<\?xml[^?]+\?>","<!DOCTYPE[^>]+>"]
        self.toss_regexp = "("
        for r in self.regs_to_toss:
            self.toss_regexp = self.toss_regexp + r + "|"
        self.toss_regexp = self.toss_regexp[0:-1] + ")"
        self.toss_regexp = re.compile(self.toss_regexp)
        self.attr_regexp = '(<[^>]+?)\"([^=]+[\"<>][^=]+)\"'
        self.attr_regexp = re.compile(self.attr_regexp)
        self.encodings = ['cp1252','iso8859','ascii','latin_1','cp850','utf-8']
        
    def cleanup (self, infile, outfile):
        infile = open(infile,'r')
        outfile = open(outfile,'w')
        for l in infile.readlines():
            l = self.toss_regs(l)
            l = self.fix_attrs(l)
            l = self.encode(l)
            outfile.write(l)
        infile.close()
        outfile.close()
            
    def toss_regs (self, instr):
        m = self.toss_regexp.search(instr)
        if m:
            outstr = instr[0:m.start()] + instr[m.end():]
            debug('Converted "%s" to "%s"'%(instr,outstr),1)
            return outstr
        else:
            return instr

    def fix_attrs (self, instr):
        match = self.attr_regexp.search(instr)
        outstr = ""
        while match:
            outstr = outstr + instr[0:match.start()]
            pre,badattr = match.groups()
            outstr = outstr + pre
            outstr = outstr + xml.sax.saxutils.quoteattr(badattr)
            debug('Fixed broken attribute: %s -> %s'%(instr,outstr),0)
            instr = instr[match.end():]
            match = self.attr_regexp.search(instr)
        outstr = outstr + instr
        return outstr

    def encode (self, l):
        for e in self.encodings:
            try:
                return l.decode(e)
            except:
                debug('Could not decode as %s'%e,2)
                pass
        raise Exception("Could not encode %s" % l)
        
class MastercookXMLHandler (xml_importer.RecHandler):
    """We handle MasterCook XML Files"""
    def __init__ (self, parent_thread=None,conv=None):
        debug('MastercookXMLHandler starting',0)
        xml_importer.RecHandler.__init__(self,parent_thread=parent_thread,conv=None)
        self.total = 0
        self.recs_done = 0
        self.elements = {
            'mx2':['source','date'],
            #'Summ':[],
            'Nam':[],
            'RcpE':['name'],
            'RTxt':[],
            'Serv':['qty'],
            'PropT':['elapsed'],
            'IngR':['name','unit','qty'],
            'IPrp':[],
            #'DirS':[],
            'DirT':[],
            'Desc':[],
            'Srce':[],
            'Note':[],
            'CatT':[],
            'Yield':['unit','qty'],
            }
        self.current_elements = []
        self.bufs = []
        xml.sax.ContentHandler.__init__(self)
        importer.Importer.__init__(self,conv=conv)

    def grabattr (self, attrs, name, default=''):
        return unquoteattr(attrs.get(name,default))

    def startElement (self, name, attrs):
        self.in_mixed=0
        if not self.elements.has_key(name):
            debug('Unhandled element: %s'%name,0)
            return
        else:
            self.current_elements = [name] + self.current_elements
            handler = self._get_handler(name)
            handler(start=True,attrs=attrs)

    def endElement (self, name):
        if not self.elements.has_key(name):
            return
        else:
            self.current_elements.remove(name)
            handler = self._get_handler(name)
            handler(end=True)


    def endDocument (self):
        self.emit('progress',1,_("Mastercook import finished."))
    
    def _get_handler (self, name):
        return getattr(self,'%s_handler'%name)

    def mx2_handler (self, start=False, end=False, attrs=None):
        if start:
            pass

    def characters (self, ch):
        debug('adding to %s bufs: %s'%(len(self.bufs),ch),0)
        for buf in self.bufs:
            setattr(self,buf,getattr(self,buf)+ch)
        
    def Nam_handler (self, start=False, end=False, attrs=None):
        if start:
            # we simply count recipes so that we can
            # indicate progress.
            self.total += 1
    
    def RcpE_handler (self, start=False, end=False, attrs=None):
        if start:
            self.start_rec()
            #if self.source:
            #    self.rec['source']=self.source
            if attrs:
                self.rec['title']=self.grabattr(attrs,'name')
        if end:
            if self.rec.has_key('yield'):
                self._add_to_instructions("\nYield: %s %s"%self.rec['yield'])
                del self.rec['yield']
            self.commit_rec()
        
    def RTxt_handler (self, start=False, end=False, attrs=None):
        if start:
            self.cdata_buf = ""
            self.bufs.append('cdata_buf')
        if end:
            self.bufs.remove('cdata_buf')

    def Serv_handler (self, start=False, end=False, attrs=None):
        if attrs:
            self.rec['servings']=self.grabattr(attrs,'qty')

    def Yield_handler (self, start=False, end=False, attrs=None):
        if attrs:
            self.rec['yield']=(self.grabattr(attrs,'qty'),self.grabattr(attrs,'unit'))

    def CatT_handler (self, start=False, end=False, attrs=None):
        if start:
            self.catbuf = ""
            self.bufs.append('catbuf')
        if end:
            self.bufs.remove('catbuf')
            self.catbuf = self.catbuf.strip()
            if self.rec.has_key('category'):
                self.rec['category']=self.rec['category']+" "+self.catbuf
            else:
                self.rec['category']=xml.sax.saxutils.unescape(self.catbuf)

    def IngR_handler (self, start=False, end=False, attrs=None):
        if attrs:
            self.start_ing()
            self.item = self.grabattr(attrs,'name')
            self.add_amt(self.grabattr(attrs,'qty'))
            self.ing['unit']=self.grabattr(attrs,'unit')
            
        if end:
            if self.item.find("===")==0:
                self.group = self.item[4:-4]
            else:
                self.add_item(self.item)
                debug(
                    "item=%s, unit=%s"%(self.item,self.ing['unit']),
                    0
                    )
                self.commit_ing()

    def _add_to_instructions (self, buf):
        debug('adding to instructions: %s'%buf,0)
        if self.rec.has_key('instructions'):
            self.rec['instructions'] = self.rec['instructions'] + "\n%s"%xml.sax.saxutils.unescape(buf)
        else:
            self.rec['instructions'] = xml.sax.saxutils.unescape(buf)

    def DirT_handler (self, start=False, end=False, attrs=None):
        if start:
            self.dbuf = ""
            self.bufs.append('dbuf')
        if end:
            self.bufs.remove('dbuf')
            self._add_to_instructions(self.dbuf.strip())

    # this also gets added to instructions
    Desc_handler = DirT_handler

    def Note_handler (self, start=False, end=False, attrs=None):
        if start:
            self.dbuf = ""
            self.bufs.append('dbuf')
        if end:
            self.bufs.remove('dbuf')
            buf = xml.sax.saxutils.unescape(self.dbuf.strip())
            if self.rec.has_key('modifications'):
                self.rec['modifications'] = self.rec['modifications'] + "\n%s"%buf
            else:
                self.rec['modifications'] = buf

    def IPrp_handler (self, start=False, end=False, attrs=None):
        if start:
            self.ipbuf = ""
            self.bufs.append('ipbuf')
        if end:
            self.item += "; %s"%xml.sax.saxutils.unescape(self.ipbuf.strip())
            self.bufs.remove('ipbuf')
        
    def Srce_handler (self, start=False, end=False, attrs=None):
        if start:
            self.srcbuf = ""
            self.bufs.append('srcbuf')
        if end:
            self.rec['source']=self.srcbuf.strip()
            self.bufs.remove('srcbuf')
    
class MastercookImporter (xml_importer.Converter):
    def __init__ (self, filename):
        xml_importer.Converter.__init__(self,
                                        recHandler=MastercookXMLHandler,
                                        recMarker='<RcpE',
                                        filename=filename,
                                        )

    def pre_run (self):
        self.emit('progress',0.03, _("Tidying up XML"))
        cleaner = Mx2Cleaner()
        base,ext=os.path.splitext(self.fn)
        cleanfn = base + ".gourmetcleaned" + ext
        cleaner.cleanup(self.fn,cleanfn)
        debug('Cleaned up file saved to %s'%cleanfn,1)
        self.orig_fn = self.fn
        self.fn = cleanfn



########NEW FILE########
__FILENAME__ = mastercook_importer_plugin
from gourmet.plugin import ImporterPlugin
import mastercook_plaintext_importer
import mastercook_importer
import gourmet.importers.importer as importer
from gettext import gettext as _

class MastercookImporterPlugin (ImporterPlugin):

    name = _('Mastercook XML File')
    patterns = ['*.mx2','*.xml','*.mxp']
    mimetypes = ['text/plain','text/xml','application/xml']

    def test_file (self, filename):
        return importer.Tester('.*<mx2[> ]').test(filename)

    def get_importer (self, filename):
        return mastercook_importer.MastercookImporter(filename)


class MastercookTextImporterPlugin (ImporterPlugin):

    name = _('Mastercook Text File')
    patterns = ['*.mxp','*.txt']
    mimetypes = ['text/plain','text/mastercook']

    def test_file (self, filename):
        return mastercook_plaintext_importer.Tester().test(filename)

    def get_importer (self, filename):
        return mastercook_plaintext_importer.MastercookPlaintextImporter(filename)

########NEW FILE########
__FILENAME__ = mastercook_plaintext_importer
from gourmet.importers import importer, plaintext_importer
import re, string
from gourmet import check_encodings
from gourmet.gdebug import debug
from gettext import gettext as _

MASTERCOOK_START_REGEXP='\s*\*\s*Exported\s*from\s*MasterCook.*\*\s*'

class MastercookPlaintextImporter (plaintext_importer.TextImporter):
    ATTR_DICT = {'Recipe By':'source',
                 'Serving Size':'servings',
                 'Preparation Time':'preptime',
                 'Categories':'category',
                 }
    def __init__ (self, filename):
        self.compile_regexps()
        self.instr = ""
        self.in_ings = False
        self.in_instructions = False
        self.in_or = False
        self.looking_for_title = False
        self.last_attr = ""
        self.in_attrs=False
        self.in_mods=False
        self.reccol_headers = False
        plaintext_importer.TextImporter.__init__(self,filename)
        
    def compile_regexps (self):
        plaintext_importer.TextImporter.compile_regexps(self)
        self.rec_start_matcher = re.compile(MASTERCOOK_START_REGEXP)
        self.blank_matcher = re.compile("^\s*$")
        # strange thing has happened -- some archives have the column
        # off by exactly 1 character, resulting in some fubar'ing of
        # our parsing.  to solve our problem, we first recognize
        # rec_col_matcher, then parse fields using the ------
        # underlining, which appears to line up even in fubared
        # archives.
        self.rec_col_matcher = re.compile("(\s*Amount\s*)(Measure\s*)(Ingredient.*)")
        self.rec_col_underline_matcher = re.compile("(\s*-+)(\s*-+)(\s*-+.*)")
        # match a string enclosed in a possibly repeated non-word character
        # such as *Group* or ---group--- or =======GROUP======
        # grabbing groups()[1] will get you the enclosed string
        self.dash_matcher = re.compile("^[ -]*[-][- ]*$")
        self.ing_or_matcher = re.compile("\W*[Oo][Rr]\W*")
        self.ing_group_matcher = re.compile("\s*(\W)\\1*(.+?)(\\1+)")
        self.mods_matcher = re.compile("^\s*NOTES\.*")
        attr_matcher = "\s*(" + string.join(self.ATTR_DICT.keys(),"|") + ")\s*:(.*)"
        self.attr_matcher = re.compile(attr_matcher)
        
    def handle_line (self, line):
        if self.rec_start_matcher.match(line):
            debug('rec_start! %s'%line,0)
            self.looking_for_title = True
            if self.rec: self.commit_rec()
            self.instr = ""
            self.mods = ""
            self.in_instructions=False
            self.in_mods = False
            self.in_ings = False
            self.in_attrs = False
            self.start_rec()
            return
        if self.reccol_headers:
            # we try to parse underlining after our standard ing headers.
            rcm = self.rec_col_underline_matcher.match(line)
            # if there is no underlining, use our headers themselves for fields
            if not rcm: rcm = self.reccol_headers
            debug('Found ing columns',0)            
            self.get_ing_cols(rcm)
            self.in_ings = True
            self.reccol_headers=False
        
        if self.dash_matcher.match(line): return
        
        rcm=self.rec_col_matcher.match(line)
        if rcm:
            self.reccol_headers = rcm
            self.looking_for_title=False
            self.in_attrs=False
            self.last_attr = ""
            return
        if self.blank_matcher.match(line):            
            # blank line ends ingredients
            if self.in_ings:
                debug('blank line, end of ings',0)
                self.in_ings = False
                self.in_instructions = True
                if self.ing: self.commit_ing()
            if self.in_instructions:
                debug('blank line added to instructions: %s'%line,0)
                if self.in_mods: self.mods += "\n"
                else: self.instr+="\n"
            return
        if self.looking_for_title:
            debug('found my title! %s'%line.strip(),0)
            self.rec['title']=line.strip()
            self.looking_for_title = False
            self.in_attrs=True
            return
        if self.in_ings:
            debug('handling ingredient line %s'%line,0)
            self.handle_ingline (line)
            return        
        if self.in_attrs:
            debug('handing attrline %s'%line,0)
            self.handle_attribute(line)
            return
        else:
            self.in_instructions = True
            if self.mods_matcher.match(line):
                self.in_mods = True
            if self.in_mods:
                debug('handling modifications line %s'%line,0)
                self.add_to_attr('mods',line)
            else:
                debug('handling instructions line %s'%line,0)
                self.add_to_attr('instr',line)

    def add_to_attr (self, attr, txt):
        orig = getattr(self,attr)
        if orig:
            if len(txt.strip()) < 50:
                setattr(self,attr,orig+"%s\n"%txt.strip())
            elif not self.blank_matcher.match(orig[-1]):
                setattr(self,attr,orig+" %s"%txt.strip())
            else:
                setattr(self,attr,orig+txt.strip())
        else:
            setattr(self,attr,txt)

    def get_ing_cols (self,rcm):
        amt,unit,itm=rcm.groups()
        lamt,lunit,litm = len(amt),len(unit),len(itm)
        self.amt_col = 0,lamt
        self.unit_col = lamt,lamt+lunit
        self.itm_col = lamt+lunit,None

    def handle_attribute (self,line):
        m=self.attr_matcher.match(line)
        if m:            
            attr,val = m.groups()
            SecndColMatch = self.attr_matcher.search(val)
            if SecndColMatch:
                s=SecndColMatch.start()
                self.handle_attribute(val[s:])
                val = val[:s]
            val = self.join_multiple_attvals(val.strip())
            attr = attr.strip()
            self.last_attr = self.ATTR_DICT[attr]
            self.rec[self.ATTR_DICT[attr]]=val
        else:            
            if self.last_attr:
                # attribute values can run over one line...
                self.rec[self.last_attr]=', '.join([self.rec[self.last_attr],
                                                    self.join_multiple_attvals(line.strip())
                                                    ])
            else:
                # otherwise, we add this to instructions, like we do with all junk
                self.instr += line

    def join_multiple_attvals (self, txt):
        """We take replace more than one space with a comma."""
        return ', '.join(re.split('  +',txt))

    def handle_ingline (self,line):
        if self.ing_or_matcher.match(line):
            self.in_or = True
            return
        amt = line.__getslice__(*self.amt_col).strip()
        unit = line.__getslice__(*self.unit_col).strip()
        itm = line[self.itm_col[0]:].strip()
        gm=self.ing_group_matcher.match(itm)
        if gm:
            if self.ing: self.commit_ing()
            self.group = gm.groups()[1]
            # undo grouping if it has no letters...
            if re.match('^[^A-Za-z]*$',self.group): self.group=None
            return
        if amt or unit:
            if self.in_or: self.ing['optional']=True
            if self.ing: self.commit_ing()
            self.start_ing()
            if self.in_or:
                self.ing['optional']=True
                self.in_or = False
            self.add_amt(amt)
            self.add_unit(unit)
            self.add_item(itm)
            return
        elif self.ing and self.ing.has_key('item'):
            # otherwise, we assume we are a continuation and
            # add onto the previous item
            self.ing['item']=self.ing['item']+' '+itm.strip()
        else:
            debug('"%s" in the midst of ingredients looks like instructions!'%itm.strip(),2)
            self.instr += "\n"+itm.strip()

    def commit_ing (self):
        if not self.ing.has_key('item'):
            return
        key_base = self.ing['item'].split('--')[0]
        self.ing['ingkey']=self.km.get_key_fast(key_base)
        importer.Importer.commit_ing(self)
        self.ing = {}

    def commit_rec (self):
        ll=self.instr.split('\n')        
        self.rec['instructions']=self.unwrap_lines(self.instr)
        self.rec['modifications']=self.unwrap_lines(self.mods)
        importer.Importer.commit_rec(self)
        
class Tester (importer.Tester):
    def __init__ (self):
        importer.Tester.__init__(self,regexp=MASTERCOOK_START_REGEXP)
        self.not_me = "<[?]?(xml|mx2|RcpE|RTxt)[^>]*>"

    def test (self, filename):
        if not hasattr(self,'matcher'):
            self.matcher=re.compile(self.regexp)
            self.not_matcher = re.compile(self.not_me)
        if type(filename)==str:
            self.ofi = open(filename,'r')
            CLOSE = True
        else:
            self.ofi = filename
            CLOSE = False
        l = self.ofi.readline()
        while l:
            if self.not_matcher.match(l):
                self.ofi.close()
                return False
            if self.matcher.match(l):
                self.ofi.close()
                return True
            l = self.ofi.readline()
        if CLOSE: self.ofi.close()
        else: self.ofi.seek(0)

########NEW FILE########
__FILENAME__ = mealmaster_exporter
import re, os.path, os, xml.sax.saxutils, time, shutil, urllib, textwrap
from gourmet import gglobals,  convert
from gourmet.exporters.exporter import exporter_mult
from gourmet.gdebug import debug
from gettext import gettext as _

class mealmaster_exporter (exporter_mult):
    def __init__ (self, rd, r, out, conv=None, change_units=True, mult=1):
        import mealmaster_importer
        self.add_to_instructions=""
        self.conv = conv
        mmf2mk = mealmaster_importer.mmf_constants()
        self.uc=mmf2mk.unit_convr
        recattrs_orig=mmf2mk.recattrs
        self.recattrs={}
        for k,v in recattrs_orig.items():
            self.recattrs[v]=k
        self.categories = ""
        exporter_mult.__init__(self, rd, r, out,
                               conv=conv,
                               order=['attr','ings','text'],
                               attr_order=['title',
                                           'cuisine',
                                           'category',
                                           'yields',
                                           'cooktime',
                                           'preptime',
                                           'rating',
                                           'source',
                                           'link'],
                               convert_attnames=False,
                               change_units=change_units,
                               mult=mult)

    def write_head (self):
        self.out.write("MMMMM----- Recipe via Meal-Master (tm)\n\n")

    def write_attr (self, label, text):
        #We must be getting the label already capitalized from an the exporter class
	#this line is just to correct that without making a mess of the exporter class
	if label=='category' or label=='cuisine':
            if self.categories:
                self.categories="%s, %s"%(self.categories,text)
            else:
                self.categories=text
            return
        if label=='yields' and self.categories:
            # categories go before servings
            self.write_categories()
	#Mealmaster pukes at the preptime line so this removes it    
	elif label=='preparation time' or label=='rating' or label=='source':
	    self.add_to_instructions += "\n\n%s: %s"%(gglobals.REC_ATTR_DIC[label],text)
	else:
            if label and text:
                if self.recattrs.has_key(label):
                    label=self.recattrs[label]
                else:
                    label=label.capitalize()
                label=self.pad(label,8)
		self.out.write("%s: %s\n"%(label, text))

    def write_categories (self):
        self.out.write("%s: %s\n"%(self.pad("Categories",8),self.categories))
        self.categories = ""

    def write_attr_foot (self):
        if self.categories: self.write_categories() # if these haven't been written yet...

    def pad (self, text, chars):
        text=text.strip()
        fill = chars - len(text)
        return "%s%s"%(" "*fill,text)
    
    def write_text (self, label, text):
        if label=='instructions' and self.add_to_instructions:
            text = text + self.add_to_instructions
            self.add_to_instructions = ""
        ll=text.split("\n")
        for l in ll:
            for wrapped_line in textwrap.wrap(l):
                self.out.write("\n  %s"%wrapped_line)
            self.out.write("\n  ")
            
    def write_inghead (self):
        self.master_ings=[] # our big list
        # self.ings is what we add to
        # this can change when we add groups
        self.ings = self.master_ings
        self.ulen=1
        # since the specs we found suggest it takes 7 blanks
        # to define an ingredient, our amtlen needs to be at
        # least 6 (there will be an extra space added
        self.amtlen=6
        self.out.write("\n")

    def write_grouphead (self, name):
        debug('write_grouphead called with %s'%name,0)
        group = (name, [])
        self.ings.append(group) # add to our master
        self.ings = group[1] # change current list to group list

    def write_groupfoot (self):
        self.ings = self.master_ings # back to master level

    def write_ing (self, amount="1", unit=None, item=None, key=None, optional=False):
        if type(amount)==type(1.0) or type(amount)==type(1):
  	    amount = convert.float_to_frac(amount)
  	if not amount: amount = ""
        if not unit: unit = ""
        unit_bad = False
        if len(unit) > 2 or '.' in unit:
            unit_bad = True
            # Try to fix the unit
            if self.conv.unit_dict.has_key(unit):
                new_u = self.conv.unit_dict[unit]
                if len(new_u) <= 2 and not '.' in new_u:
                    unit = new_u; unit_bad = False
                else:
                    if self.uc.has_key(new_u):
                        unit = self.uc[new_u]; unit_bad = False
        if unit_bad: # If we couldn't fix the unit...  we add it to
            # the item
            if unit: item="%s %s"%(unit,item)
            unit=""
        if len(unit)>self.ulen:
            self.ulen=len(unit)
        if len(amount)>self.amtlen:
            self.amtlen=len(amount)
            #print "DEBUG: %s length %s"%(amount,self.amtlen)
        # we hold off writing ings until we know the lengths
        # of strings since we need to write out neat columns
        if optional: item="%s (optional)"%item
        self.ings.append([amount,unit,item])

    def write_ingfoot (self):
        """Write all of the ingredients"""
        ## where we actually write the ingredients...
        for i in self.master_ings:
            # if we're a tuple, this is a group...
            if type(i)==type(()):
                # write the group title first...
                group = i[0]
                width = 70
                dashes = width - len(group)
                left_side = dashes/2 - 5
                right_side = dashes/2
                self.out.write("-----%s%s%s\n"%(left_side * "-",
                                           group.upper(),
                                           right_side * "-")
                          )
                map(self._write_ingredient,i[1])
                self.out.write("\n") # extra newline at end of groups
            else:
                self._write_ingredient(i)
        # we finish with an extra newline
        self.out.write("\n")
                        
    def _write_ingredient (self, ing):
        a,u,i = ing
        self.out.write("%s %s %s\n"%(self.pad(a,self.amtlen),
                                     self.pad(u,self.ulen),
                                     i))

    def write_foot (self):
        self.out.write("\n\n")
	self.out.write("MMMMM")
	self.out.write("\n\n")

########NEW FILE########
__FILENAME__ = mealmaster_exporter_plugin
from gourmet.plugin import ExporterPlugin
import gourmet.exporters.exporter as exporter
import mealmaster_exporter
from gettext import gettext as _

MMF = _('MealMaster file')

class MealmasterExporterPlugin (ExporterPlugin):

    label = _('MealMaster Export')
    sublabel = _('Exporting recipes to MealMaster file %(file)s.')
    single_completed_string = _('Recipe saved as MealMaster file %(file)s')
    filetype_desc = MMF
    saveas_filters = [MMF,['text/mmf','text/plain'],['*.mmf','*.MMF']]
    saveas_single_filters = saveas_filters

    def get_multiple_exporter (self, args):
        return exporter.ExporterMultirec(
            args['rd'],
            args['rv'],
            args['file'],
            one_file=True,
            ext='mmf',
            exporter=mealmaster_exporter.mealmaster_exporter)

    def do_single_export (self, args)    :
        e = mealmaster_exporter.mealmaster_exporter(args['rd'],
                                                       args['rec'],
                                                       args['out'],
                                                       mult=args['mult'],
                                                       change_units=args['change_units'],
                                                       conv=args['conv'])
        e.run()

    def run_extra_prefs_dialog (self):
        pass

########NEW FILE########
__FILENAME__ = mealmaster_importer
from gourmet.importers import importer, plaintext_importer
import re, os.path, string, array
from gourmet import convert, check_encodings
from gourmet.gdebug import debug,TimeAction
#from gourmet.gglobals import gt
from gettext import gettext as _

class mmf_constants:
    def __init__ (self):
        self.committed = False
        self.recattrs={'Title':'title',
                       'Name':'title',
                       'Categories':'category',
                       'Category':'category',
                       'Serves':'servings',
                       'Servings':'servings',
                       'Source':'source',
                       'Recipe by':'source',
                       'Yield':'yields',
                       'Preparation Time':'preptime',
                       }
        
        self.unit_conv = {'ts':'tsp',
                          'tb':'Tbs',
                          'sm':'small',
                          'md':'medium',
                          'ea':'',
                          'lg':'large',
                          'c':'c',
                          'pn':'pinch',
                          'ds':'dash',
                          'T' : 'tbs',
                          't' : 'tsp',
                          'pk' : 'package',
                          'x' : '',
                          'ea' : '',
                          't' : 'tsp',
                          'pt' : 'pt',
                          'qt' : 'qt',
                          'oz' : 'oz'
                          }
        self.unit_convr = {}
        for k,v in self.unit_conv.items():
            self.unit_convr[v]=k

mmf=mmf_constants()
mm_start_pattern=r"^(?i)([m-][m-][m-][m-][m-])-*.*(recipe|meal-?master).*"

class mmf_importer (plaintext_importer.TextImporter):

    """Mealmaster(tm) importer class.

    We read in a text file a line at a time and parse
    attributes/ingredients/instructions as best we can.

    We're following, more or less, the specs laid out here
    <http://phprecipebook.sourceforge.net/docs/MM_SPEC.DOC>

    The problem with Mealmaster(tm) files is that they rarely conform
    to the above spec.  So, we are a bit more flexible -- we can
    handle one or two columns of ingredients for example. However,
    it's hard to handle all cases. Also, mealmaster (as described in
    the above spec) allows for essentially a continuous flow of text
    with ingredient and text blocks interspersed. Gourmet separates
    out the ingredients from the instructions, which means that we
    have to change the presentation of mealmaster files when they
    intersperse instructions and ingredients.

    To allow for this flexibility also means we are less flexible
    about both instructions and ingredients: instructions that look
    like ingredients or ingredients that look like instructions will
    be parsed the wrong way, regardless of their position in the file,
    since the spec above does not specify that mealmaster files must
    follow the normal pattern.

    The result is that anyone importing large numbers of mealmaster
    files from various internet sources should expect to tweak files
    by hand with some frequency.
    """

    committed = False
    
    def __init__ (self,filename='Data/mealmaster.mmf',
                  prog=None, source=None,threaded=True,
                  two_col_minimum=38,conv=None):
        """filename is the file to parse (or filename). rd is the recData instance
        to start with.  prog is a function we tell about our
        prog to (we hand it a single arg)."""

        testtimer = TimeAction('mealmaster_importer.__init__',10)
        debug("mmf_importer start  __init__ ",5)
        self.source=source
        self.header=False
        self.instr=""
        self.ingrs=[]
        self.ing_added=False
        self.in_variation=False
        self.fn = filename
        self.prog = prog
        self.unit_length = 2
        self.two_col_minimum = two_col_minimum
        self.last_line_was = None
        plaintext_importer.TextImporter.__init__(self,filename)#prog=prog,
        #threaded=threaded,conv=conv)
        testtimer.end()
        
    def compile_regexps (self):
        testtimer = TimeAction('mealmaster_importer.compile_regexps',10)
        debug("start compile_regexps",5)
        plaintext_importer.TextImporter.compile_regexps(self)
        self.start_matcher = re.compile(mm_start_pattern)
        self.end_matcher = re.compile("^[M-][M-][M-][M-][M-]\s*$")
        self.group_matcher = re.compile("^\s*([M-][M-][M-][M-][M-])-*\s*([^-]+)\s*-*|^\s*---\s*([^-]+)\s*---\s*$",re.IGNORECASE)
        self.ing_cont_matcher = re.compile("^\s*[-;]")
        self.ing_opt_matcher = re.compile("(.+?)\s*\(?\s*optional\)?\s*$",re.IGNORECASE)
        self.ing_or_matcher = re.compile("^[- ]*[Oo][Rr][- ]*$",re.IGNORECASE)
        self.variation_matcher = re.compile("^\s*(VARIATION|HINT|NOTES?)(:.*)?",re.IGNORECASE)
        # a crude ingredient matcher -- we look for two numbers,
        # intermingled with spaces followed by a space or more,
        # followed by a two digit unit (or spaces)
        c = convert.get_converter()
        self.ing_num_matcher = re.compile(
            "^\s*%s+\s+([a-z ]{1,2}|%s)\s+.*\w+.*"%(
                convert.NUMBER_REGEXP,
                '('+'|'.join(filter(lambda x: x, c.unit_dict.keys()))+')'
                ),
            re.IGNORECASE)
        self.amt_field_matcher = re.compile("^(\s*%s\s*)$"%convert.NUMBER_REGEXP)
        # we build a regexp to match anything that looks like
        # this: ^\s*ATTRIBUTE: Some entry of some kind...$
        self.mmf = mmf
        attrmatch="^\s*("
        for k in self.mmf.recattrs.keys():
            attrmatch += "%s|"%re.escape(k)
        attrmatch="%s):\s*(.*)\s*$"%attrmatch[0:-1]
        self.attr_matcher = re.compile(attrmatch)
        testtimer.end()
        
    def handle_line (self,l):

        """Handle an individual line of a mealmaster file.

        We're quite loose at handling mealmaster files. We look at
        each line and determine what it is most likely to be:
        ingredients and instructions can be intermingled: instructions
        will simply be added to the instructions and ingredients to
        the ingredient list.  This may result in loss of information
        (for instructions that specifically follow ingredients) or in
        mis-parsing (for instructions that look like ingredients). But
        we're following, more or less, the specs laid out here
        <http://phprecipebook.sourceforge.net/docs/MM_SPEC.DOC>"""
        
        testtimer =TimeAction('mealmaster_importer.handle_line',10)
        debug("start handle_line",10)
        #gt.gtk_update()
        if self.start_matcher.match(l):
            debug("recipe start %s"%l,4)
            if 'Windows Gourmet' in l:
                self.unit_length = 15
            self.new_rec()
            self.last_line_was = 'new_rec'
            self.in_variation = False
            return
        if self.end_matcher.match(l):
            debug("recipe end %s"%l,4)
            self.commit_rec()
            self.last_line_was = 'end_rec'
            return
        groupm = self.group_matcher.match(l)
        if groupm:
            debug("new group %s"%l,4)
            self.handle_group(groupm)
            self.last_line_was = 'group'
            return
        attrm = self.attr_matcher.match(l)
        if attrm:
            debug('Found attribute in %s'%l,4)
            attr,val = attrm.groups()
            debug("Writing attribute, %s=%s"%(attr,val),4)
            self.rec[self.mmf.recattrs[attr]]=val.strip()
            self.last_line_was = 'attr'
            return
        if not self.instr and self.blank_matcher.match(l):
            debug('ignoring blank line before instructions',4)
            self.last_line_was = 'blank'
            return
        if self.variation_matcher.match(l):
            debug('in variation',4)
            self.in_variation = True
        if self.is_ingredient(l) and not self.in_variation:
            debug('in ingredient',4)
            contm = self.ing_cont_matcher.match(l)
            if contm:
                # only continuations after ingredients are ingredients
                if self.ingrs and self.last_line_was == 'ingr':
                    debug('continuing %s'%self.ingrs[-1][0],4)
                    continuation = " %s"%l[contm.end():].strip()
                    self.ingrs[-1][0] += continuation
                    self.last_line_was = 'ingr'
                else:
                    self.instr += l
                    self.last_line_was = 'instr'
            else:
                self.last_line_was = 'ingr'
                self.ingrs.append([l,self.group])
        else:
            ## otherwise, we assume a line of instructions
            if self.last_line_was == 'blank': add_blank=True
            else: add_blank = False
            if self.in_variation:
                debug('Adding to instructions: %s'%l,4)
                self.last_line_was = 'mod'
                add_to = 'mod'
            else:
                debug('Adding to modifications: %s'%l,4)
                self.last_line_was = 'instr'
                add_to = 'instr'
            if getattr(self,add_to):
                if add_blank: setattr(self,add_to,
                                      getattr(self,add_to)+"\n")
                setattr(self,add_to,
                        getattr(self,add_to) + l.strip() + "\n")
            else:
                setattr(self,add_to,
                        l.strip() + "\n")
        testtimer.end()
                
    def is_ingredient (self, l):
        """Return true if the line looks like an ingredient.

        We're going to go with a somewhat hackish approach
        here. Once we have the ingredient list, we can determine
        columns more appropriately.  For now, we'll assume that a
        field that starts with at least 5 blanks (the specs suggest 7)
        or a field that begins with a numeric value is an ingredient"""
        testtimer = TimeAction('mealmaster_importer.is_ingredient',10)
        if self.ing_num_matcher.match(l):
            testtimer.end()
            return True
        if len(l) >= 7 and self.blank_matcher.match(l[0:5]):
            testtimer.end()
            return True
        
    def new_rec (self):
        """Start a new recipe."""
        testtimer = TimeAction('mealmaster_importer.new_rec',10)
        debug("start new_rec",5)
        if self.rec:
            # this shouldn't happen if recipes are ended properly
            # but we'll be graceful if a recipe starts before another
            # has ended... 
            self.commit_rec()
        self.committed=False
        self.start_rec()
        debug('resetting instructions',5)
        self.instr=""
        self.mod = ""
        self.ingrs=[]
        self.header=False
        testtimer.end()

    def commit_rec (self):
        """Commit our recipe to our database."""
        testtimer = TimeAction('mealmaster_importer.commit_rec',10)
        if self.committed: return
        debug("start _commit_rec",5)
        self.instr = self.unwrap_lines(self.instr)
        self.mod = self.unwrap_lines(self.mod)
        self.rec['instructions']=self.instr
        if self.mod:
            self.rec['modifications']=self.mod
        self.parse_inglist()
        if self.source:
            self.rec['source']=self.source
        importer.Importer.commit_rec(self)
        # blank rec
        self.committed = True
        self.in_variation=False
        testtimer.end()
        
    def handle_group (self, groupm):
        """Start a new ingredient group."""
        testtimer = TimeAction('mealmaster_importer.handle_group',10)
        debug("start handle_group",10)
        # the only group of the match will contain
        # the name of the group. We'll put it into
        # a more sane title case (MealMaster defaults
        # to all caps
        name = groupm.groups()[1]
        if not name:
            name = groupm.groups()[2]
        if not name:
            return
        name = name.strip().title()
        self.group=name
        #if re.match('^[^A-Za-z]*$',self.group): self.group=None #WTF was this for?
        testtimer.end()
        # a blank line before a group could fool us into thinking
        # we were in instructions. If we see a group heading,
        # we know that's not the case!

    def find_ing_fields (self):
        """Find fields in an ingredient line."""
        testtimer = TimeAction('mealmaster_importer.find_ing_fields',10)
        all_ings = [i[0] for i in self.ingrs]
        fields = find_fields(all_ings)
        fields_is_numfield = fields_match(all_ings,fields,self.amt_field_matcher)
        #fields = [[r,field_match(all_ings,r,self.amt_field_matcher)] for r in find_fields(all_ings)]
        aindex,afield = self.find_amt_field(fields,fields_is_numfield)
        if aindex != None:
            fields = fields[aindex+1:]
            fields_is_numfield = fields_is_numfield[aindex+1:]
        ufield = fields and self.find_unit_field(fields,fields_is_numfield)
        if ufield:
            fields = fields[1:]
            fields_is_numfield = fields_is_numfield[1:]
        if fields:
            ifield = [fields[0][0],None]
        else:
            ifield = 0,None
        retval = [[afield,ufield,ifield]]
        sec_col_fields = filter(lambda x: x[0]>self.two_col_minimum,fields)        
        if sec_col_fields:
            ibase = fields.index(sec_col_fields[0])
            while sec_col_fields and not fields_is_numfield[ibase]:
                ibase += 1
                sec_col_fields = sec_col_fields[1:]
                # if we might have a 2nd column...
        if sec_col_fields and len(sec_col_fields) > 2:            
            fields_is_numfield = fields_is_numfield[ibase:]
            aindex2,afield2 = self.find_amt_field(sec_col_fields,fields_is_numfield)
            if aindex2 != None and len(sec_col_fields[aindex2+1:]) >= 1:
                # then it's a go! Shift our first ifield
                retval[0][2]=[ifield[0],fields[ibase-1][1]]
                sec_col_fields = sec_col_fields[aindex2 + 1:]
                fields_is_numfield = fields_is_numfield[aindex2+1:]
                ufield2 = self.find_unit_field(sec_col_fields,fields_is_numfield)
                if ufield2:
                    sec_col_fields=sec_col_fields[1:]
                    fields_is_numfield = fields_is_numfield[1:]
                ifield2 = sec_col_fields[0][0],None
                retval.append([afield2,ufield2,ifield2])
        testtimer.end()
        return retval
        
    def find_unit_field (self, fields, fields_is_numfield):
        testtimer = TimeAction('mealmaster_importer.find_unit_field',10)
        if 0 < fields[0][1]-fields[0][0] <= self.unit_length and len(fields)>1:
            testtimer.end()
            return fields[0]
        testtimer.end()
        
    def find_amt_field (self, fields, fields_is_numfield):
        """Return amount field and field index for the last amount field.

        In other words, if we the following fields...

        0 1   2  3     4      5       6  7
        1 1/2 ts green onions chopped in 1/2

        ...we will return the index for our first two fields [1] and
        we will return the field corresponding to the first two fields
        (0,5)
        """
        afield = None
        aindex = None
        for i,f in enumerate(fields):
            # if our field is a numeric field...
            if fields_is_numfield[i]:
                if not afield:
                    afield = f
                    aindex = i
                # if we our contiguous
                elif i == aindex + 1:
                    afield = [afield[0],f[1]] # give it a new end
                    aindex = i
                else:
                    return aindex,afield
        return aindex, afield

    def add_item (self, item):
        testtimer = TimeAction('mealmaster_importer.add_item',10)
        self.ing['item']=item.strip()
        # fixing bug 1061363, potatoes; cut and mashed should become just potatoes
        # for keying purposes
        key_base = self.ing['item'].split(";")[0]
        self.ing['ingkey']=self.km.get_key_fast(key_base)
        testtimer.end()
        
    def parse_inglist(self):
        testtimer = TimeAction('mealmaster_importer.parse_inglis',10)
        debug("start parse_inglist",5)
        """We handle our ingredients after the fact."""
        ingfields =self.find_ing_fields()
        debug("ingredient fields are: %s"%ingfields,10)
        for s,g in self.ingrs:
            for afield,ufield,ifield in ingfields:
                self.group = g
                amt,u,i = get_fields(s,(afield,ufield,ifield))
                debug("""amt:%(amt)s
                u:%(u)s
                i:%(i)s"""%locals(),0)
                # sanity check...
                if not amt.strip() and not u.strip():
                    if not i: continue
                    # if we have not amt or unit, let's do the right
                    # thing if this just looks misaligned -- in other words
                    # if the "item" column has 2 c. parsley, let's just parse
                    # the damned thing as 2 c. parsley
                    parsed = self.rd.parse_ingredient(i,conv=self.conv,get_key=False)
                    if parsed and parsed.get('amount','') and parsed.get('item',''):
                        amt = "%s"%parsed['amount']
                        u = parsed.get('unit','')
                        i = parsed['item']
                        debug("""After sanity check
                        amt:%(amt)s
                        u:%(u)s
                        i:%(i)s"""%locals(),0)
                if amt.strip() or u.strip() or i.strip():
                    self.start_ing()
                    if amt:
                        self.add_amt(amt)
                    if u:
                        self.add_unit(u)
                    optm=self.ing_opt_matcher.match(i)
                    if optm:
                        item=optm.groups()[0]
                        self.ing['optional']=True
                    else:
                        item = i
                    self.add_item(item)
                    debug("committing ing: %s"%self.ing,6)
                    self.commit_ing()
        testtimer.end()
                    
    def add_unit (self, unit):
        testtimer = TimeAction('mealmaster_importer.add_unit',10)
        unit = unit.strip()
        if self.mmf.unit_conv.has_key(unit):
            unit = self.mmf.unit_conv[unit]
        importer.Importer.add_unit(self,unit)
        testtimer.end()

def split_fields (strings, char=" "):
    testtimer = TimeAction('mealmaster_importer.split_fields',10)
    debug("start split_fields",10)
    fields=find_fields(strings,char)
    testtimer.end()
    
def fields_match (strings, fields, matcher):
    testtimer = TimeAction('mealmaster_importer.fields_match',10)
    """Return an array of True or False values representing
    whether matcher is a match for each of fields in string."""
    #retarray = array.array('H',[1]*len(fields))
    ret = []
    for f in fields:
        strs = [s[f[0]:f[1]] for s in strings]
        matches = [matcher.match(s) and True or False for s in strs]
        if True in matches: ret.append(1)
        else: ret.append(0)
    return ret
    #return array.array('H',[True in [matcher.match(s[f[0]:f[1]]) and 1 or 0 for s in strings] for f in fields])
    
    # cycle through each string broken into our fields
    #for ff in [[s[f[0]:f[1]] for f in fields] for s in strings]:
    #    for i,fld in enumerate(ff):
    #        if fld and retarray[i] and not matcher.match(fld):
    #            retarray[i]=False
    #            if not True in retarray: return retarray
    #testtimer.end()
    #return retarray


def field_match (strings, tup, matcher):
    testtimer = TimeAction('mealmaster_importer.field_match',10)
    debug("start field_match",10)
    if type(matcher)==type(""):
        matcher=re.compile(matcher)
    for f in [s[tup[0]:tup[1]] for s in strings]:
        #f=s[tup[0]:tup[1]]
        if f and not matcher.match(f):
            testtimer.end()
            return False
    testtimer.end()
    return True


def get_fields (string, tuples):
    testtimer = TimeAction('mealmaster_importer.get_fields',10)
    debug("start get_fields",10)
    lst = []
    for t in tuples:
        if t:
            lst.append(string[t[0]:t[1]])
        else:
            lst.append("")
    testtimer.end()
    return lst


def field_width (tuple):
    testtimer = TimeAction('mealmaster_importer.field_width',10)
    debug("start field_width",10)
    if tuple[1]:
        testtimer.end()
        return tuple[1]-tuple[0]
    else:
        testtimer.end()
        return None
    
    
def find_fields (strings, char=" "):
    testtimer = TimeAction('mealmaster_importer.find_fields',10)
    cols = find_columns(strings, char)
    if not cols: return []
    cols.reverse()
    fields = []
    lens = map(len,strings)
    lens.sort()
    end = lens[-1]
    last_col = end
    for col in cols:
        if col == last_col - 1:
            end = col
        else:
            fields.append([col+1,end])
            end = col
        last_col = col
    if end != 0: fields.append([0,end])
    fields.reverse()
    testtimer.end()
    return fields


def find_columns (strings, char=" "):
    testtimer = TimeAction('mealmaster_importer.find_columns',10)
    """Return a list of character indices that match char for each string in strings."""
    debug("start find_columns",10)
    # we start with the columns in the first string
    if not strings:
        return None
    strings=strings[0:]
    strings.sort(lambda x,y: len(x)>len(y))
    columns = [match.start() for match in re.finditer(re.escape(char),strings[0])]
    if len(strings)==1:
        return columns
    # we eliminate all columns that aren't blank for every string
    for s in strings:
        for c in columns[0:]: # we'll be modifying columns
            if c < len(s) and s[c]!=char:
                columns.remove(c)
    columns.sort()
    testtimer.end()
    return columns


        
if __name__ == '__main__':
    import gourmet.recipeManager as recipeManager
    import tempfile, sys, profile, os.path
    print 'Testing MealMaster import'
    tmpfile = tempfile.mktemp()
    import backends.db
    rd = backends.db.RecipeManager(tmpfile)
    if not args: args = ['/home/tom/Projects/recipe/Data/200_Recipes.mmf']
    for a in args:
        profi = os.path.join(tempfile.tempdir,'MMI_PROFILE')
        profile.run("mmf_importer(rd,a,prog=lambda *args: sys.stdout.write('|'),threaded=False)",
                    profi)
        import pstats
        p = pstats.Stats(profi)
        p.strip_dirs().sort_stats('cumulative').print_stats()
        
    

########NEW FILE########
__FILENAME__ = mealmaster_importer_plugin
import os.path

import mealmaster_importer
from gourmet.plugin import ImporterPlugin
from gourmet.importers.importer import Tester
from gourmet.threadManager import get_thread_manager

from gourmet.recipeManager import get_recipe_manager
from gettext import gettext as _
    
test_dir = os.path.split(__file__)[0] # our directory src/lib/plugins/import_export/plugin/*/
test_dir = os.path.split(test_dir)[0] # one back... src/lib/plugins/import_export/plugin/
test_dir = os.path.split(test_dir)[0] # one back... src/lib/plugins/import_export/
test_dir = os.path.split(test_dir)[0] # one back... src/lib/plugins/
test_dir = os.path.split(test_dir)[0] # one back... src/lib/
test_dir = os.path.split(test_dir)[0] # one back... src/
test_dir = os.path.join(test_dir,'tests','recipe_files')

class MealmasterImporterPlugin (ImporterPlugin):

    get_source = 'source'
    name = _('MealMaster file')
    patterns = ['*.mmf','*.txt']
    mimetypes = ['text/mealmaster','text/plain']

    def test_file (self, filename):
        '''Given a filename, test whether the file is of this type.'''
        return Tester(mealmaster_importer.mm_start_pattern).test(filename)

    def get_importer (self, filename):
        return mealmaster_importer.mmf_importer(filename=filename)
                                                   
    def get_import_tests (self):
        return [
            (os.path.join(test_dir,
                          'mealmaster_2_col.mmf'),
             test_2_col),
            (os.path.join(test_dir,
                          'mealmaster.mmf'),
             test_mmf)
            ]

def assert_equal (val1,val2):
    assert val1==val2, 'Value expected: %s, Actual value: %s'%(val2,val1)

def assert_equal_ignorecase (val1, val2): return assert_equal(val1.lower(),val2.lower())

def test_mmf (recs, filename):
    rd = get_recipe_manager()
    assert_equal(recs[0].title,'Almond Mushroom Pate')
    assert_equal(recs[0].yields, 6)
    assert_equal(recs[0].yield_unit,'servings')
    assert_equal(recs[3].title,'Anchovy Olive Dip')
    ings = rd.get_ings(recs[3])
    assert_equal(ings[1].item,'Finely chopped stuffed green olives') # test line-wrap

def test_2_col (recs, filename):
    rd = get_recipe_manager()    
    assert len(recs) == 1,'Expected 1 recipes; got %s (%s)'%(len(recs),recs)
    chile_ings = rd.get_ings(recs[0])
    print 'chile_ings=',chile_ings
    assert_equal(chile_ings[0].amount, 2)
    assert_equal(chile_ings[1].amount, 1) # second column
    assert_equal_ignorecase(chile_ings[1].ingkey, 'eggs')
    assert_equal(chile_ings[1].item, 'Eggs; separated')
    assert_equal_ignorecase(chile_ings[0].ingkey, u'Chiles, calif.')
    assert_equal(recs[0].yields, 2)
    assert_equal(recs[0].yield_unit, 'servings')
    assert_equal(recs[0].title, u'Chiles Rellenos de Queso')
    assert_equal(chile_ings[5].item, 'Tomatoes; peeled')
    assert_equal_ignorecase(chile_ings[5].inggroup, 'Tomato Sauce')

########NEW FILE########
__FILENAME__ = mycookbook_exporter
import gourmet.exporters.exporter as exporter
import xml.sax.saxutils
from gourmet.exporters.xml_exporter import XmlExporter
import os
import tempfile
import zipfile
from gourmet import convert
import gourmet.ImageExtras
import shutil
import unicodedata

class rec_to_mcb (XmlExporter):

    doc_element = 'cookbook'
    doctype_desc = ''
    dtd_path = ''
    ALLOW_PLUGINS_TO_WRITE_NEW_FIELDS = True
    current_title = ''
    
    def write_head (self):
        self.rec_el = self.create_element_with_attrs("recipe",{'id':self.r.id})
        self.top_element.appendChild(self.rec_el)
        
    def write_attr (self, attr, text):
        #attr mapping
        if (attr == 'link'):
            attr = 'url'
        if (attr == 'category'):
            attr = 'category'
        if (attr == 'servings'):
            attr = 'quantity'
        if (attr == 'cooktime'):
            attr = 'cooktime'
        if (attr == 'preptime'):
            attr = 'preptime'
        if (attr == 'yields'):
            attr = 'quantity'
            text = text.split(' ')[0] # Remove units if present
        if (attr == 'rating'):
            from gourmet.importers.importer import string_to_rating
            val = string_to_rating(text)
            if val:
                # MyCookbook's rating range is integers from 1 to 5, while
                # ours is from 1 to 10, so we have to floor divide by 2 when
                # exporting.
                self.rec_el.appendChild(self.create_text_element('rating', str(val//2)))
                return
        if (attr == 'title'):
            self.current_title = text.replace(' ','_')

        self.rec_el.appendChild(self.create_text_element(attr.replace(' ',''),text))
        
    def write_text (self, attr, text):
        #attr mapping with li
        if (attr == 'instructions'):
            attr = 'recipetext'
        if (attr == 'modifications'):
            attr = 'comments'
        
        if (attr == 'recipetext' or attr == 'comments'):
            linelist = text.split('\n')
            self.attrlist_el = self.xmlDoc.createElement(attr.replace(' ',''))
            self.rec_el.appendChild(self.attrlist_el)
            for l in linelist:
                attr_el = self.create_text_element('li',l)
                self.attrlist_el.appendChild(attr_el)
            

    def write_image (self, image):
        # write image file to the temp directory
        imageFilename = unicodedata.normalize('NFKD', unicode(self.current_title + '.png')).encode('ascii', 'ignore')
        pic_fullpath = os.path.join(tempfile.gettempdir(),'images',imageFilename)
        result = gourmet.ImageExtras.get_image_from_string(image)
        result.save(pic_fullpath)
        
        # write imagepath in the xml
        self.rec_el.appendChild(self.create_text_element('imagepath','images/' + imageFilename))
    
    def handle_italic (self, chunk): return chunk
    def handle_bold (self, chunk): return chunk    
    def handle_underline (self, chunk): return chunk    
        
    def write_foot (self):
        if self.i_created_this_document:
            self.xmlDoc.writexml(self.ofi, newl = '\n', addindent = "\t", 
                                 encoding = "UTF-8")

    def write_inghead (self):
        self.inglist_el = self.xmlDoc.createElement('ingredient')
        self.top_inglist = self.inglist_el # because groups will let us nest...
        self.rec_el.appendChild(self.inglist_el)

    def write_ingref (self, amount=1, unit=None, item=None, refid=None, optional=False):
        pass
        
    def write_ing (self, amount=1, unit=None, item=None, key=None, optional=False):
        ing_txt=''
        if type(amount)==type(1.0) or type(amount)==type(1):
            amount = convert.float_to_frac(amount)
        ing_txt = ing_txt + amount
        if unit:
            ing_txt = ing_txt + ' ' + unit
        if item:
            ing_txt = ing_txt + ' ' + item
        
        ing_el = self.create_text_element('li',ing_txt)
        self.inglist_el.appendChild(ing_el)
        
    def write_grouphead (self, name):
        self.write_ing(item=name)
        
    def write_groupfoot (self):
        pass
    

class recipe_table_to_xml (exporter.ExporterMultirec, XmlExporter):
    doc_element = 'cookbook'
    doctype_desc = ''
    dtd_path = ''
    dirname = ''
    
    def __init__ (self, rd, recipe_table, out, one_file=True, change_units=False,
                  mult=1):
        
        self.outputfilename = ''
        
        if type(out) is file:
            self.out=out
            self.outputfilename=str(out.name)
        else:
            self.outputfilename=out
            self.out=open(out,'w')
        
        #prepare temp directory for images
        self.ostempdir_bck = tempfile.tempdir
        dirname = tempfile.mkdtemp()
        tempfile.tempdir = dirname
        picdirname = os.path.join(dirname,'images')
        if os.path.isdir(picdirname):
            shutil.rmtree(picdirname)
        os.mkdir(picdirname, 0777 );
        
        self.create_xmldoc()
        exporter.ExporterMultirec.__init__(
            self, rd, recipe_table, out, one_file=True, ext='mcb', exporter=rec_to_mcb,
            exporter_kwargs={'change_units':change_units,
                             'mult':mult,
                             'xmlDoc':self.xmlDoc,
                             'attr_order':('title',
                                           'category','cuisine',
                                           'source','link',
                                           'rating',
                                           'preptime','cooktime',
                                           'yields',
                                           ),
                             'order':['attr','image','ings','text'],
                             }
            )
        

    def write_footer (self, *args):
        # The exporter has opened a file for us, which we're not going to use.
        self.ofi.close()

        # We save our correctly named XML to the temp dir so it won't collide
        # with any files present in the user's selected export dir.
        basename = os.path.basename(self.outputfilename)
        xml_basename = os.path.splitext(basename)[0] +'.xml'
        xml_path = os.path.join(tempfile.gettempdir(), xml_basename)
        self.xml_ofi = open(xml_path,'wb')
        self.xmlDoc.writexml(self.xml_ofi, newl = '\n', addindent = "\t", encoding = "UTF-8")
        # flush to the disk
        self.xml_ofi.close()
        
        # add xml and images to the zip (mcb)
        myfile = zipfile.ZipFile(self.outputfilename, mode='w')
        try:
            myfile.write(xml_path, xml_basename, zipfile.ZIP_DEFLATED)
            picdirname = os.path.join(tempfile.gettempdir(),'images')
            for images in os.listdir(picdirname):
                full_image_path = os.path.join(picdirname, images)
                if os.path.isfile(full_image_path):
                    myfile.write(full_image_path, os.path.join('images',os.path.basename(full_image_path)), zipfile.ZIP_DEFLATED)
        finally:
            # close zipfile
            myfile.close()
        
        # cleanup temp dir
        shutil.rmtree(tempfile.gettempdir())
        tempfile.tempdir = self.ostempdir_bck
        
        
def quoteattr (str):
    return xml.sax.saxutils.quoteattr(xml.sax.saxutils.escape(str))

########NEW FILE########
__FILENAME__ = mycookbook_exporter_plugin
from gourmet.plugin import ExporterPlugin
import gourmet.exporters.exporter as exporter
import mycookbook_exporter
from gettext import gettext as _

MCB = _('My CookBook MCB File')

class MCBExporterPlugin (ExporterPlugin):

    label = _('MCB Export')
    sublabel = _('Exporting recipes to My CookBook MCB file %(file)s.')
    single_completed_string = _('Recipe saved in My CookBook MCB file %(file)s.'),
    filetype_desc = MCB
    saveas_filters = [MCB,['application/zip'],['*.mcb','*.MCB']]
    saveas_single_filters = saveas_filters

    def get_multiple_exporter (self, args):
        
        return mycookbook_exporter.recipe_table_to_xml(
            args['rd'],
            args['rv'],
            args['file'],
            )

    def do_single_export (self, args):
        e = mycookbook_exporter.recipe_table_to_xml(
            args['rd'],
            [args['rec']],
            args['out'],
            change_units=args['change_units'],
            mult=args['mult']
            )
        e.run()

    def run_extra_prefs_dialog (self):
        pass
                
        

########NEW FILE########
__FILENAME__ = mycookbook_importer
import re
from gourmet.importers import xml_importer
from gourmet.gdebug import *
from gourmet.gglobals import *
try:
    from PIL import Image
except ImportError:
    import Image
import gourmet.ImageExtras

class RecHandler (xml_importer.RecHandler):
    ADD = 1
    IS = 2
    #mapping: 'mcb tag':('gourmet tag',method import),
    RECTAGS={'title':('title',IS),
             'url':('link',ADD),
             'category':('category',ADD),
             'serving':('servings',IS),
             'cooktime':('cooktime',IS),
             'preptime':('preptime',IS),
             'quantity':('yields',IS),
             'rating':('rating',IS),
             'source':('source',IS),
             }
    RECIPE_TAG = 'recipe'
    ING_TAG = 'ingredient'
    INSTR_TAG = 'recipetext'
    COMMENT_TAG = 'comments'
    
    current_section = ''
    
    def __init__ (self, total=None, conv=None, parent_thread=None):
        self.in_mixed = 0
        self.rec={}
        self.ing={}
        xml_importer.RecHandler.__init__(self,total,conv=conv,parent_thread=parent_thread)

    def startElement (self, name, attrs):
        self.elbuf = ""
        if name==self.RECIPE_TAG:
            self.start_rec()
        if name==self.ING_TAG:
            self.current_section = 'ingredient'
        if name==self.INSTR_TAG:
            self.current_section = 'instruction'
        if name==self.COMMENT_TAG:
            self.current_section = 'comments'
            
    def endElement (self, name):
        key,method=None,None
        if name==self.RECIPE_TAG:
            self.commit_rec()
            return
        if name=='li' and self.current_section=='ingredient':
            if not hasattr(self,'db'):
                import gourmet.backends.db as db
                self.db = db.get_database()
            ingdic = self.db.parse_ingredient(self.elbuf.strip())
            self.start_ing(**ingdic)
            self.commit_ing()
        if name=='li' and self.current_section=='instruction':
            key = 'instructions'
            method = self.ADD
            obj = self.rec
        if name=='li' and self.current_section=='comments':
            key = 'modifications'
            method = self.ADD
            obj = self.rec
        if name == 'imagepath':
            obj = self.rec
            #get the temp directory and build the image path
            (dirname, filename) = os.path.split(self.parent_thread.fn)
            (pic_dirname, pic_filename) = os.path.split(self.elbuf.strip())
            pic_fullpath = os.path.join(dirname,'images',pic_filename)
            
            #try to import the image
            if os.path.isfile(pic_fullpath):
                try:
                    im = Image.open(pic_fullpath)
                    obj['image'] = gourmet.ImageExtras.get_string_from_image(im)
                    #obj['image'] = gourmet.ImageExtras.get_string_from_image(gourmet.ImageExtras.resize_image(im,60,60))
                except Exception, e:
                    print 'Issue loading: '+pic_fullpath
                    print str(e)
                    #dont stop if corrupted image file
                    pass
        
        # times fixing
        if name == 'cooktime' or name == 'preptime':
            self.elbuf = self.elbuf.replace('mn','min')
            if re.match('([0-9]*)min', self.elbuf):
                self.elbuf = self.elbuf.replace('min',' min')

        #other tags
        if name==self.ING_TAG:
            self.current_section = ''
        elif name==self.INSTR_TAG:
            self.current_section = ''
        elif name==self.COMMENT_TAG:
            self.current_section = ''
        elif self.RECTAGS.has_key(name):
            obj = self.rec
            key,method = self.RECTAGS[name]

        if key:
            if key == 'rating':
                # MyCookbook's rating range is integers from 1 to 5, while
                # ours is from 1 to 10, so we have to multiply by 2 when
                # importing.
                obj['rating']=int(self.elbuf.strip()) * 2
            elif method == self.ADD and obj.has_key(key):
                obj[key]=obj[key]+"\n "+self.elbuf
            else:
                obj[key]=self.elbuf

class Converter (xml_importer.Converter):
    def __init__ (self, filename, conv=None):
        xml_importer.Converter.__init__(self,filename,RecHandler,
                                        recMarker="</recipe>",
                                        conv=conv,
                                        name='MCB Importer')


########NEW FILE########
__FILENAME__ = mycookbook_importer_plugin
import os, os.path
from gourmet.plugin import ImporterPlugin
import mycookbook_importer
import tempfile
import zipfile
from gettext import gettext as _
from lxml import etree

class MCBPlugin (ImporterPlugin):

    name = _('MCB File')
    patterns = ['*.mcb']
    mimetypes = ['application/zip','application/x-gzip','multipart/x-zip','multipart/x-gzip']

    def test_file (self, filename):
        return True

    def get_importer (self, filename):
        xmlfilename=''
        
        #Unzip in a temporary directory
        try:
            zf = zipfile.ZipFile(filename)
        except zipfile.BadZipfile:
            raise
        tempdir = tempfile.mkdtemp('mcb_zip')
        for name in zf.namelist():
            (dirname, filename) = os.path.split(name)
            fulldirpath = os.path.join(tempdir,dirname)
            #Create the images dir if not exists yet
            if not os.path.exists(fulldirpath):
                os.mkdir(fulldirpath, 0775)
            outfile = open(os.path.join(tempdir, name), 'wb')
            outfile.write(zf.read(name))
            outfile.close()
            #Get the path to the xml file to import it
            if filename.endswith(".xml"):
                xmlfilename = os.path.join(tempdir, filename)
                
                #fix the xml file
                parser = etree.XMLParser(recover=True)
                tree = etree.parse(xmlfilename, parser)
                fixedxmlfilename = xmlfilename+'fixed'
                outFile = open(fixedxmlfilename, 'w')
                tree.write(outFile, xml_declaration=True, encoding='utf-8', pretty_print=True)
                outFile.close()
                
        zf.close()
        
        return mycookbook_importer.Converter(fixedxmlfilename)



########NEW FILE########
__FILENAME__ = page_drawer
import gtk

class PageDrawer (gtk.DrawingArea):

    def __init__(self, page_width=None, page_height=None,
                 sub_areas=[],xalign=0.5,yalign=0.5
                 ):
        """Draw a page based on page areas given to us.

        The areas can be given in any scale they like.

        sub_areas are each (X1,Y1,WIDTH,HEIGHT) where the point defines
        the upper-left corner of the rectangle.
        
        """
        self.xalign = xalign
        self.yalign = yalign
        gtk.DrawingArea.__init__(self)
        self.gc = None  # initialized in realize-event handler
        self.width  = 0 # updated in size-allocate handler
        self.height = 0 # idem
        if page_width and page_height:
            self.set_page_area(page_width,page_height,sub_areas)
        self.connect('size-allocate', self.on_size_allocate)
        self.connect('expose-event',  self.on_expose_event)
        self.connect('realize',       self.on_realize)

    def set_page_area (self, page_width, page_height, sub_areas=[]):
        self.xy_ratio = page_width/page_height
        self.areas = []
        for x1,y1,w,h in sub_areas:
            width = float(w)/page_width
            height = float(h)/page_height
            x = float(x1)/page_width
            y = float(y1)/page_height
            self.areas.append(
                (x,y,width,height)
                )

    def on_realize(self, widget):
        self.gc = widget.window.new_gc()
        #self.gc.set_line_attributes(3, gtk.gdk.LINE_ON_OFF_DASH,
        #                            gtk.gdk.CAP_ROUND, gtk.gdk.JOIN_ROUND)

    def on_size_allocate(self, widget, allocation):
        self.width = allocation.width
        self.height = allocation.height
        
    def on_expose_event(self, widget, event):
        if not hasattr(self,'xy_ratio'): return
        # This is where the drawing takes place
        if self.xy_ratio * self.height > self.width:
            width = int(self.width * 0.9)
            height = int((self.width / self.xy_ratio) * 0.9)
        else:
            width = int(self.xy_ratio*self.height*0.9)
            height = int(self.height*0.9)
        xpadding = int((self.width - width)*self.xalign)
        ypadding = int((self.height - height)*self.yalign)
        self.gc.set_line_attributes(3,
                               gtk.gdk.LINE_SOLID,
                               gtk.gdk.CAP_BUTT,
                               gtk.gdk.JOIN_MITER)
        widget.window.draw_rectangle(self.gc, False,
                                     xpadding, ypadding, width, height)
        self.gc.set_line_attributes(1,
                                    gtk.gdk.LINE_ON_OFF_DASH,
                                    gtk.gdk.CAP_BUTT,gtk.gdk.JOIN_MITER)
        for sub_area in self.areas:
            x,y,w,h = sub_area
            self.window.draw_rectangle(
                self.gc, False,
                int(xpadding+(x*width)),int(ypadding+(y*height)),int(w*width),int(h*height)
                )
        #widget.window.draw_line(self.gc,
        #                        0, 0, self.width - 1, self.height - 1)
        #widget.window.draw_line(self.gc,
        #                        self.width - 1, 0, 0, self.height - 1)


if __name__ == '__main__':
    w = gtk.Window()
    w.add(PageDrawer(8.5,11,[(1,1,3,9.5),
                             (4.5,1,3,9.5),
                             ]))
    w.show_all()
    w.connect('delete-event',lambda *args: gtk.main_quit())
    gtk.main()

########NEW FILE########
__FILENAME__ = pdf_exporter
import gtk, gobject
import reportlab
from reportlab.pdfbase import pdfmetrics
from reportlab.lib.units import inch,mm
from reportlab.pdfgen import canvas
import reportlab.platypus as platypus
from reportlab.platypus.flowables import ParagraphAndImage
import reportlab.lib.pagesizes as pagesizes
import reportlab.lib.fonts as fonts
import reportlab.lib.units as units
import reportlab.lib.styles as styles
from gettext import gettext as _
from gettext import ngettext
from gourmet import convert
from gourmet import gglobals
from gourmet.gtk_extras import dialog_extras as de
from gourmet.gtk_extras import optionTable
from gourmet.gtk_extras import cb_extras
from gourmet import ImageExtras
from gourmet.prefs import get_prefs
import xml.sax.saxutils
import gourmet.exporters.exporter as exporter
import types, re
import tempfile, os.path
import math
from page_drawer import PageDrawer

DEFAULT_PDF_ARGS = {'bottom_margin': 72, 'pagesize': 'letter', 'right_margin': 72, 'top_margin': 72, 'left_margin': 72, 'pagemode': 'portrait', 'base_font_size': 10, 'mode': ('column', 1)}

# Code for MCLine from:
# http://two.pairlist.net/pipermail/reportlab-users/2005-February/003695.html
class MCLine(platypus.Flowable):
    """Line flowable --- draws a line in a flowable"""
    
    def __init__(self,width):
        platypus.Flowable.__init__(self)
        self.width = width
        
    def __repr__(self):
        return "Line(w=%s)" % self.width
    
    def draw(self):
        self.canv.line(0,0,self.width,0)

import reportlab.lib.colors as colors
class Star (platypus.Flowable):
    '''A hand flowable.'''
    def __init__(self, size=None, fillcolor=colors.tan, strokecolor=colors.green):
        from reportlab.lib.units import inch
        if size is None: size=12 # 12 point
        self.fillcolor, self.strokecolor = fillcolor, strokecolor
        self.size = size
        # normal size is 4 inches
        
    def getSpaceBefore (self):
        return 6 # 6 points

    def getSpaceAfter (self):
        return 6 # 6 points
        
    def wrap(self, availW, availH):
        if self.size > availW or self.size > availH:
            if availW > availH:
                self.size = availH
            else:
                self.size = availW
        return (self.size,self.size)

    def draw (self):
        size = self.size # * 0.8
        self.draw_star(inner_length=size/4,
                       outer_length=size/2)

    def draw_circle (self, x, y, r):
        # Test...
        canvas = self.canv
        canvas.setLineWidth(0)        
        canvas.setStrokeColor(colors.grey)
        canvas.setFillColor(colors.grey)        
        p = canvas.beginPath()
        p.circle(x,y,r)
        p.close()
        canvas.drawPath(p,fill=1)

    def draw_half_star (self, inner_length=1*inch, outer_length=2*inch, points=5, origin=None):
        canvas = self.canv
        canvas.setLineWidth(0)
        if not origin: canvas.translate(self.size*0.5,self.size*0.5)
        else: canvas.translate(*origin)
        canvas.setFillColor(self.fillcolor)
        canvas.setStrokeColor(self.strokecolor)
        p = canvas.beginPath()
        inner = False # Start on top
        is_origin = True
        #print 'Drawing star with radius',outer_length,'(moving origin ',origin,')'
        for theta in range(0,360,360/(points*2)):
            if 0 < theta < 180: continue
            if inner: r = inner_length
            else: r = outer_length
            x = (math.sin(math.radians(theta)) * r)
            y = (math.cos(math.radians(theta)) * r)
            #print 'POINT:',x,y
            if is_origin:
                p.moveTo(x,y)
                is_origin = False
            else:
                p.lineTo(x,y)
            inner = not inner
        p.close()
        canvas.drawPath(p,fill=1)

    def draw_star (self, inner_length=1*inch, outer_length=2*inch, points=5, origin=None):
        canvas = self.canv
        canvas.setLineWidth(0)
        if not origin: canvas.translate(self.size*0.5,self.size*0.5)
        else: canvas.translate(*origin)
        canvas.setFillColor(self.fillcolor)
        canvas.setStrokeColor(self.strokecolor)
        p = canvas.beginPath()
        inner = False # Start on top
        is_origin = True
        #print 'Drawing star with radius',outer_length,'(moving origin ',origin,')'
        for theta in range(0,360,360/(points*2)):
            if inner: r = inner_length
            else: r = outer_length
            x = (math.sin(math.radians(theta)) * r)
            y = (math.cos(math.radians(theta)) * r)
            #print 'POINT:',x,y
            if is_origin:
                p.moveTo(x,y)
                is_origin = False
            else:
                p.lineTo(x,y)
            inner = not inner
        p.close()
        canvas.drawPath(p,fill=1)


class FiveStars (Star):

    def __init__ (self, height, filled=5, out_of=5,
                  filled_color=colors.black,
                  unfilled_color=colors.lightgrey
                  ):
        self.height = self.size = height
        self.filled = filled
        self.out_of = out_of
        self.filled_color = filled_color; self.unfilled_color = unfilled_color
        self.width = self.height * self.out_of + (self.height * 0.2 * (self.out_of-1)) # 20% padding
        self.ratio = self.height / 12 # 12 point is standard
        

    def wrap (self, *args):
        return self.width,self.height

    def draw (self):
        #self.canv.scale(self.ratio,self.ratio)
        self.draw_stars()

    def draw_stars (self):
        #if self.height
        for n in range(self.out_of):
            if self.filled - n >= 1:
                # Then we draw a gold star
                self.fillcolor,self.strokecolor = self.filled_color,self.filled_color
                r = self.height * 0.5
            else:
                self.fillcolor,self.strokecolor = self.unfilled_color,self.unfilled_color
                r = self.height * 0.75 * 0.5
            origin = (
                # X coordinate
                ((n >= 1 and (self.height * 1.2)) or self.height*0.5),
                # Y coordinate
                ((n < 1 and self.height* 0.5) or 0)
                )
            #print 'origin = ',#origin,'or',
            #print origin[0]/self.height,origin[1]/self.height
            #self.draw_circle(origin[0],origin[1],r)
            self.draw_star(points=5,origin=origin,inner_length=r/2,outer_length=r)
            if self.filled - n == 0.5:
                # If we're a half star...
                self.fillcolor,self.strokecolor = self.filled_color,self.filled_color                
                self.draw_half_star(points=5,
                                    inner_length=self.height*0.25,
                                    outer_length=self.height*0.5,
                                    origin=(0,0)
                                    )
            
# Copied from http://two.pairlist.net/pipermail/reportlab-users/2004-April/002917.html
# A convenience class for bookmarking
class Bookmark(platypus.Flowable):
    """ Utility class to display PDF bookmark. """

    def __init__(self, title, key):
        self.title = title
        self.key = key
        platypus.Flowable.__init__(self)

    def wrap(self, availWidth, availHeight):
        """ Doesn't take up any space. """
        return (0, 0)

    def draw(self):
        # set the bookmark outline to show when the file's opened
        self.canv.showOutline()
        # step 1: put a bookmark on the
        self.canv.bookmarkPage(str(self.key))
        # step 2: put an entry in the bookmark outline
        self.canv.addOutlineEntry(self.title,
                                  self.key, 0, 0)


class PdfWriter:

    def __init__ (self, allrecs=[]):
        pass

    def setup_document (self, file, mode=('column',1), size='default', pagesize='letter',
                        pagemode='portrait',left_margin=inch,right_margin=inch,
                        top_margin=inch,
                        bottom_margin=inch,
                        base_font_size=10
                        ):
        frames = self.setup_frames(mode,size,pagesize,pagemode,
                                   left_margin,right_margin,top_margin,
                                   bottom_margin,base_font_size)
        pt = platypus.PageTemplate(frames=frames)
        self.doc = platypus.BaseDocTemplate(file,pagesize=self.pagesize,
                                            pageTemplates=[pt],)
        self.doc.frame_width = frames[0].width
        self.doc.frame_height = frames[0].height
        self.styleSheet = styles.getSampleStyleSheet()
        perc_scale = float(base_font_size)/self.styleSheet['Normal'].fontSize
        if perc_scale!=1.0:
            self.scale_stylesheet(perc_scale)
        self.txt = []

    def setup_frames (self,mode=('column',1), size='default', pagesize='letter',
                        pagemode='portrait',left_margin=inch,right_margin=inch,
                        top_margin=inch,
                        bottom_margin=inch,
                        base_font_size=10):
        if type(mode)!=tuple:
            raise Exception("What is this mode! %s" % str(mode))
        if type(pagesize) in types.StringTypes:
            self.pagesize = getattr(pagesizes,pagemode)(getattr(pagesizes,pagesize))
        else:
            self.pagesize = getattr(pagesizes,pagemode)(pagesize)
        self.margins = (left_margin,right_margin,top_margin,bottom_margin)
        if mode[0] == 'column':
            frames = self.setup_column_frames(mode[1])
        elif mode[0] == 'index_cards':
            frames = self.setup_multiple_index_cards(mode[1])
        else:
            raise Exception("WTF - mode = %s" % str(mode))
        return frames

    def scale_stylesheet (self, perc):
        for name,sty in self.styleSheet.byName.items():
            for attr in ['firstLineIndent',
                         'fontSize',
                         'leftIndent',
                         'rightIndent',
                         'leading']:
                setattr(sty,attr,int(perc*getattr(sty,attr)))
        
    def setup_column_frames (self, n):
        COLUMN_SEPARATOR = 0.5 * inch
        x = self.pagesize[0]
        y = self.pagesize[1]
        leftM,rightM,topM,bottomM = self.margins
        FRAME_Y = bottomM
        FRAME_HEIGHT = y - topM - bottomM
        FRAME_WIDTH = (x - (COLUMN_SEPARATOR*(n-1)) - leftM - rightM)/n
        frames = []
        for i in range(n):
            left_start = leftM + (FRAME_WIDTH + COLUMN_SEPARATOR)*i
            frames.append(
                platypus.Frame(
                left_start,FRAME_Y,width=FRAME_WIDTH,height=FRAME_HEIGHT
                )
                )
        return frames

    def setup_multiple_index_cards (self,card_size):
        leftM,rightM,topM,bottomM = self.margins
        MINIMUM_SPACING = 0.1*inch
        drawable_x = self.pagesize[0] - leftM - rightM
        drawable_y = self.pagesize[1] - topM - bottomM
        fittable_x = int(drawable_x / (card_size[0]+MINIMUM_SPACING))
        fittable_y = int(drawable_y / (card_size[1]+MINIMUM_SPACING))
        # Raise a ValueError if we can't actually fit multiple index cards on this page.
        if (not fittable_x) or (not fittable_y):
            raise ValueError("Card size %s does not fit on page %s with margins %s"%(
                card_size,self.pagesize,self.margins
                )
                             )
        x_spacer = (
            # Extra space = 
            fittable_x * # Number of cards times
            ((drawable_x/fittable_x) # space per card
             - card_size[0] ) # - space occupied by card
            / # Divide extra space by n+1, so we get [   CARD    ], [  CARD  CARD  ], etc.
            (fittable_x+1)
            )
        y_spacer = (
            fittable_y *
            ((drawable_y/fittable_y)
              - (card_size[1]))
             /
            (fittable_y+1)
            )
        frames = []
        for x in range(fittable_x):
            x_start = leftM + (x_spacer*(x+1)) + (card_size[0]*x)
            for y in range(fittable_y-1,-1,-1):
                # Count down for the y, since we start from the bottom
                # and move up
                y_start = bottomM + (y_spacer*(y+1)) +  (card_size[1]*y)
                frames.append(
                    platypus.Frame(x_start,y_start,
                                   width=card_size[0],
                                   height=card_size[1],
                                   showBoundary=1)
                    )
        return frames
    
    def make_paragraph (self, txt, style=None, attributes="",keep_with_next=False):
        if attributes:
            xmltxt = '<para %s>%s</para>'%(attributes,txt)
        else:
            xmltxt = '<para>%s</para>'%txt
        if not style: style = self.styleSheet['Normal']
        try:
            return platypus.Paragraph(unicode(xmltxt),style)
        except UnicodeDecodeError:
            try:
                #print 'WORK AROUND UNICODE ERROR WITH ',txt[:20]
                # This seems to be the standard on windows.
                platypus.Paragraph(xmltxt,style)
            except:
                print 'Trouble with ',xmltxt
                raise
        except:
            # Try escaping text...
            print 'TROUBLE WITH',txt[:20],'TRYING IT ESCAPED...'
            return self.make_paragraph(xml.sax.saxutils.escape(txt),
                                style,
                                attributes,
                                keep_with_next)

    def write_paragraph (self, txt, style=None, keep_with_next=False, attributes=""):
        p = self.make_paragraph(txt,style,attributes,keep_with_next=keep_with_next)
        if keep_with_next:
            # Keep with next isn't working, so we use a conditional
            # page break, on the assumption that no header should have
            # less than 3/4 inch of stuff after it on the page.
            self.txt.append(platypus.CondPageBreak(0.75*inch))
        self.txt.append(p)


    def write_header (self, txt):
        """Write a header.

        WARNING: If this is not followed by a call to our write_paragraph(...keep_with_next=False),
        the header won't necessarily be written.
        """
        self.write_paragraph(
            txt,
            style=self.styleSheet['Heading1'],
            keep_with_next = True
            )

    def write_subheader (self, txt):
        """Write a subheader.

        WARNING: If this is not followed by a call to our write_paragraph(...keep_with_next=False),
        the header won't necessarily be written.
        """        
        self.write_paragraph(
            txt,
            style=self.styleSheet['Heading2'],
            keep_with_next=True
            )

    def close (self):
        t = self.txt[:]
        try: self.doc.build(self.txt)
        except:
            print 'Trouble building',t[:20]
            raise
        
class PdfExporter (exporter.exporter_mult, PdfWriter):

    def __init__ (self, rd, r, out,
                  doc=None,
                  styleSheet=None,
                  txt=[],
                  pdf_args=DEFAULT_PDF_ARGS,
                  all_recipes=[], # For learning about references...
                  **kwargs):
        self.all_recipes = all_recipes
        PdfWriter.__init__(self)
        if type(out) in types.StringTypes:
            self.out = file(out,'wb')
        else:
            self.out = out
        if not doc:
            self.setup_document(self.out,**pdf_args)
            self.multidoc = False
        else:
            self.doc = doc; self.styleSheet = styleSheet; self.txt = []
            self.master_txt = txt
            self.multidoc = True
            # Put nice lines to separate multiple recipes out...
            #if pdf_args.get('mode',('columns',1))[0]=='columns':
            #    self.txt.append(MCLine(self.doc.frame_width*0.8))
        exporter.exporter_mult.__init__(
            self,
            rd,r,
            None, # exporter_mult has no business touching a file
            use_ml=True,
            order=['image','attr','ings','text'],
            do_markup=True,
            fractions=convert.FRACTIONS_NORMAL,
            **kwargs
            )

    def write_foot (self):
        if not self.multidoc:
            self.close() # Finish the document if this is all-in-one
            #self.out.close()
        else:
            #self.txt.append(platypus.PageBreak()) # Otherwise, a new page
            # Append to the txt list we were handed ourselves in a KeepTogether block
            #self.txt.append(platypus.Spacer(0,inch*0.5))
            #if pdf_args.get('mode',('column',1))[0]=='column':
            #    self.master_txt.append(platypus.KeepTogether(self.txt))
            #else:
            if self.master_txt:
                self.master_txt.append(platypus.FrameBreak())            
            self.master_txt.extend(self.txt)
            #self.master_txt.extend(self.txt)

    def handle_italic (self, chunk):
        return '<i>' + chunk + '</i>'
    
    def handle_bold (self, chunk):
        return '<b>' + chunk + '</b>'
    
    def handle_underline (self, chunk):
        return '<u>' + chunk + '</u>'

    def scale_image (self, image, proportion=None):
        # Platypus assumes image size is in points -- this appears to
        # be off by the amount below.
        if not proportion: proportion = inch/100 # we want 100 dots per image
        image.drawHeight = image.drawHeight*proportion        
        image.drawWidth = image.drawWidth*proportion

    def write_image (self, data):
        fn = ImageExtras.write_image_tempfile(data)
        i = platypus.Image(fn)
        self.scale_image(i)
        factor = 1
        MAX_WIDTH = self.doc.frame_width * 0.35
        MAX_HEIGHT = self.doc.frame_height * 0.5
        if i.drawWidth > MAX_WIDTH:
            factor = MAX_WIDTH/i.drawWidth
        if i.drawHeight > MAX_HEIGHT:
            f = MAX_HEIGHT/i.drawHeight
            if f < factor: factor = f
        if factor < 1.0:
            self.scale_image(i,factor)
        self.image = i

    def write_attr_head (self):
        # just move .txt aside through the attrs -- this way we can
        # use our regular methods to keep adding attribute elements 
        self.attributes = []
        
    def write_attr_foot (self):
        # If we have 3 or fewer attributes and no images, we don't
        # need a table
        if len(self.attributes)<=3 and not hasattr(self,'image'):
            self.txt.extend(self.attributes)
            return
        if not self.attributes and hasattr(self,'image'):
            # If we only have an image...
            self.txt.append(self.image)
            return
        elif hasattr(self,'image') and self.image.drawWidth > (self.doc.frame_width / 2.25):
            self.txt.append(self.image)
            self.txt.extend(self.attributes)
            return
        # Otherwise, we're going to make a table...
        if hasattr(self,'image'):
            # If we have an image, we put attributes on the
            # left, image on the right
            table_data = [
                [# 1 row
                # column 1 = attributes
                self.attributes,
                # column 2 = image
                self.image
                ],
                # End of "table"
                ]
        else:
            nattributes = len(self.attributes)
            first_col_size = nattributes/2 + nattributes % 2
            first = self.attributes[:first_col_size]
            second = self.attributes[first_col_size:]
            table_data = []
            for n,left in enumerate(first):
                right = len(second)>n and second[n] or ''
                table_data.append([left,right])
        t = platypus.Table(table_data)
        t.setStyle(
            platypus.TableStyle([
            ('VALIGN',(0,0),(0,-1),'TOP'),
            ('LEFTPADDING',(0,0),(0,-1),0),
            # for debugging
            #('INNERGRID',(0,0),(-1,-1),.25,colors.red),
            #('BOX',(0,0),(-1,-1),.25,colors.red),            
            ]
                                )
            )
        self.txt.append(t)
        #self.txt = [platypus.KeepTogether(self.txt)]

    def make_rating (self, label, val):
        """Make a pretty representation of our rating.
        """
        try:
            assert(type(val)==int)
        except:
            raise TypeError("Rating %s is not an integer"%val)
        i = FiveStars(10, filled=(val/2.0)) # 12 point
        lwidth = len(label+': ')*4 # A very cheap approximation of width
        t = platypus.Table(
            [[label+': ',i]],
            colWidths=[lwidth,inch],
            )
        t.hAlign = 'LEFT'
        t.setStyle(
            platypus.TableStyle([
            ('LEFTPADDING',(0,0),(-1,0),0),
            ('LEFTPADDING',(1,0),(1,0),6),
            ('TOPPADDING',(0,0),(-1,-1),0),
            ('ALIGNMENT',(1,0),(1,0),'LEFT'),
            ('VALIGN',(0,0),(0,0),'TOP'),
            # for debugging
            #('INNERGRID',(0,0),(-1,-1),.25,colors.black),
            #('BOX',(0,0),(-1,-1),.25,colors.black),            
             ]
                                )
            )
        return t
    
    def write_attr (self, label, text):
        attr = gglobals.NAME_TO_ATTR.get(label,label)
        if attr=='title':
            self.txt.append(Bookmark(self.r.title,'r'+str(self.r.id)))
            self.write_paragraph(text,style=self.styleSheet['Heading1'])
            return
        if attr=='rating':
            from gourmet.importers.importer import string_to_rating
            val = string_to_rating(text)
            if val:
                self.attributes.append(self.make_rating(label,val))
                return
        if attr=='link':
            trimmed = text.strip()
            if len(trimmed)>32:
                trimmed=trimmed[:29]+'&#8230;' # ellipsis dots
            self.attributes.append(self.make_paragraph('%s: <link href="%s">%s</link>'%(label,text,trimmed)))
            return
        if attr=='source':
            trimmed = text.strip()
            if len(trimmed)>32:
                trimmed=trimmed[:29]+'&#8230;' # ellipsis dots
            self.attributes.append(self.make_paragraph('%s: %s'%(label,trimmed)))
            return
        # If nothing else has returned...
        self.attributes.append(self.make_paragraph("%s: %s"%(label,text)))

    def write_text (self, label, text):
        self.write_subheader(label)
        first_para = True
        for t in text.split('\n'):
            # HARDCODING paragraph style to space
            if first_para:
                first_para = False
            self.write_paragraph(t,attributes="spacebefore='6'")

    def write_inghead (self):
        self.save_txt = self.txt[:]
        self.txt = []
        self.write_subheader(xml.sax.saxutils.escape(_('Ingredients')))

    def write_grouphead (self, name):
        self.write_paragraph(name,self.styleSheet['Heading3'])

    def write_ingfoot (self):
        # Ugly -- we know that heads comprise two elements -- a
        # condbreak and a head...
        ings = self.txt[2:]
        if len(ings) > 4:
            half = (len(ings) / 2)
            first_half = ings[:-half]
            second_half = ings[-half:]
            t = platypus.Table(
                [[first_half,second_half]]
                )
            t.hAlign = 'LEFT'
            t.setStyle(
                platypus.TableStyle([
                ('VALIGN',(0,0),(1,0),'TOP'),
                ]
                                    )
                )
            self.txt = self.txt[:2] + [t]
        self.txt = self.save_txt + [platypus.KeepTogether(self.txt)]

    def write_ing (self, amount=1, unit=None, item=None, key=None, optional=False):
        txt = ""
        for blob in [amount,unit,item,(optional and _('optional') or '')]:
            if not blob: continue
            if txt: txt += " %s"%blob
            else: txt = blob
        hanging = inch*0.25
        self.write_paragraph(
            txt,
            attributes=' firstLineIndent="-%(hanging)s" leftIndent="%(hanging)s"'%locals()
            )

    def write_ingref (self, amount, unit, item, refid, optional):
        if refid in [r.id for r in self.all_recipes]:
            txt = ""
            for blob in [amount,unit,item,(optional and _('optional') or '')]:
                if blob == item:
                    blob = '<link href="r%s">'%refid + blob + '</link>'  
                elif not blob:
                    continue
                if txt: txt += " %s"%blob
                else: txt = blob
            hanging = inch*0.25
            self.write_paragraph(
                txt,
                attributes=' firstLineIndent="-%(hanging)s" leftIndent="%(hanging)s"'%locals()
                )
        else:
            return self.write_ing(amount,unit,item,optional=optional)

class PdfExporterMultiDoc (exporter.ExporterMultirec, PdfWriter):
    def __init__ (self, rd, recipes, out, progress_func=None, conv=None,
                  pdf_args=DEFAULT_PDF_ARGS,
                  **kwargs):
        PdfWriter.__init__(self)
        if type(out) in types.StringTypes:
            out = file(out,'wb')
        self.setup_document(out,**pdf_args)
        self.output_file = out
        kwargs['doc'] = self.doc
        kwargs['styleSheet'] = self.styleSheet
        kwargs['txt'] = self.txt
        kwargs['pdf_args'] = pdf_args
        kwargs['all_recipes']=recipes
        exporter.ExporterMultirec.__init__(
            self,
            rd, recipes, out,
            one_file=True, ext='pdf',
            exporter=PdfExporter,
            conv=conv,
            progress_func=progress_func,
            exporter_kwargs=kwargs,
            )

    def write_footer (self):
        self.close()
        self.output_file.close()

class Sizer (PdfWriter):

    def get_size (self, *args, **kwargs):
        frames = self.setup_frames(*args,**kwargs)
        return self.pagesize,frames

    def get_pagesize_and_frames_for_widget (self, *args, **kwargs):
        ps,ff = self.get_size(*args,**kwargs)
        frames = [
            (f.x1, # X (top corner)
             ps[1]-f._y2, #Y (top corner)
             f.width,f.height) for f in ff]
        return ps,frames

class PdfPageDrawer (PageDrawer):

    def __init__ (self,*args,**kwargs):
        PageDrawer.__init__(self,*args,**kwargs)
        self.sizer = Sizer()
        self.set_page()

    def set_page (self, *args, **kwargs):
        self.last_kwargs = kwargs
        size,areas = self.sizer.get_pagesize_and_frames_for_widget(*args,**kwargs)
        self.set_page_area(size[0],size[1],areas)

PDF_PREF_DEFAULT={
    'page_size':_('Letter'),
    'orientation':_('Portrait'),
    'font_size':10,
    'page_layout':_('Plain'),
    'left_margin':1.0*inch,
    'right_margin':1.0*inch,
    'top_margin':1.0*inch,
    'bottom_margin':1.0*inch,    
    }

class CustomUnitOption (optionTable.CustomOption):

    '''An option for optionTable with adjustable units -- used for margins.
    '''

    units = {
        '"':inch,
        _('cm'):10*mm,
        _('points'):1,
        }

    min_val = 0.125*inch
    max_val = 8*inch

    adjustments = {
        inch:(0.125,0.5),
        10*mm:(0.5,1),
        1:(5,25),
        }

    def __init__ (self, default_value = inch):
        gobject.GObject.__init__(self)
        gtk.HBox.__init__(self)
        self.__quiet__ = False
        self.unit_combo = gtk.combo_box_new_text()
        for key in self.units:
            self.unit_combo.append_text(key)
        unit = get_prefs().get('default_margin_unit',_('cm'))
        if unit not in self.units: unit = _('cm')
        self.last_unit = self.units[unit]
        cb_extras.setup_typeahead(self.unit_combo)
        cb_extras.cb_set_active_text(self.unit_combo,unit)
        self.unit_combo.connect('changed',self.unit_changed_cb)
        self.value_adjustment = gtk.Adjustment(
            value=self.adjust_to_unit(default_value),
            lower= self.min_val / self.last_unit,
            upper = self.max_val / self.last_unit,
            step_incr = self.adjustments[self.last_unit][0],
            page_incr = self.adjustments[self.last_unit][1],
            )
        def emit_changed (*args):
            self.emit('changed')
        self.value_adjustment.connect('changed',emit_changed)
        self.value_widget = gtk.SpinButton(self.value_adjustment,digits=2)
        self.value_widget.connect('changed',emit_changed)
        self.value_widget.show(); self.unit_combo.show()
        self.pack_start(self.value_widget)
        self.pack_start(self.unit_combo)

    def set_unit (self, unit):
        cb_extras.cb_set_active_text(self.unit_combo,unit)
        
    def unit_changed_cb (self, widget):
        new_unit = self.units[self.unit_combo.get_active_text()]
        get_prefs()['default_margin_unit'] = self.unit_combo.get_active_text()
        old_val = self.value_adjustment.get_value() * self.last_unit
        self.last_unit = self.units[self.unit_combo.get_active_text()]
        new_val = self.adjust_to_unit(old_val)
        self.value_adjustment.set_upper(self.max_val / self.last_unit)
        self.value_adjustment.set_lower(self.min_val / self.last_unit)
        self.value_adjustment.set_step_increment(self.adjustments[self.last_unit][0])
        self.value_adjustment.set_page_increment(self.adjustments[self.last_unit][1])
        self.value_adjustment.set_value(new_val)
        if not self.__quiet__:
            self.emit('changed')

    def adjust_to_unit (self, raw_val):
        '''Round the value to an appropriate number for our current
        unit
        '''
        val = raw_val / self.last_unit
        adj = self.adjustments[self.last_unit][0]
        # "Round" to the increment adjustment specified for our unit
        floor =  int(val/adj) * adj
        ceiling = (int(val/adj)+1) * adj
        # Pick whatever is closest...
        if abs(floor - val) > abs(ceiling - val):
            return ceiling
        else:
            return floor
        
    def get_value (self):
        return self.last_unit * self.value_adjustment.get_value()
        
    def set_value (self, value):
        self.value_adjustment.set_value(value/self.last_unit)
        if not self.__quiet__:
            self.emit('changed')

    def sync_to_other_cuo (self, cuo):
        def change_cb (other_cuo):
            self.__quiet__ = True
            self.set_unit(other_cuo.unit_combo.get_active_text())
            self.__quiet__ = False
        cuo.connect('changed',change_cb)

class PdfPrefGetter:
    page_sizes = {
        _('11x17"'):'elevenSeventeen',
        _('Index Card (3.5x5")'):(3.5*inch,5*inch),
        _('Index Card (4x6")'):(4*inch,6*inch),
        _('Index Card (5x8")'):(5*inch,8*inch),
        _('Index Card (A7)'):(74*mm,105*mm),
        _('Letter'):'letter',
        _('Legal'):'legal',
        'A0':'A0','A1':'A1','A2':'A2','A3':'A3','A4':'A4','A5':'A5','A6':'A6',
        'B0':'B0','B1':'B1','B2':'B2','B3':'B3','B4':'B4','B5':'B5','B6':'B6',
        }

    INDEX_CARDS = [(3.5*inch,5*inch),(4*inch,6*inch),(5*inch,8*inch),(74*mm,105*mm)]
    INDEX_CARD_LAYOUTS = [_('Index Cards (3.5x5)'),
                          _('Index Cards (4x6)'),
                          _('Index Cards (A7)'),
                          ]
    layouts = {
        _('Plain'):('column',1),
        _('Index Cards (3.5x5)'):('index_cards',(5*inch,3.5*inch)),
        _('Index Cards (4x6)'):('index_cards',(6*inch,4*inch)),
        _('Index Cards (A7)'):('index_cards',(105*mm,74*mm)),
        }
    
    page_modes = {
        _('Portrait'):'portrait',
        _('Landscape'):'landscape',      
        }

    OPT_PS,OPT_PO,OPT_FS,OPT_PL,OPT_LM,OPT_RM,OPT_TM,OPT_BM = range(8)

    def __init__ (self,):
        self.prefs = get_prefs()
        defaults = self.prefs.get('PDF_EXP',PDF_PREF_DEFAULT)
        self.size_strings = self.page_sizes.keys()
        self.size_strings.sort()
        for n in range(2,5):
            self.layouts[ngettext('%s Column','%s Columns',n)%n]=('column',n)
        self.make_reverse_dicts()        
        self.layout_strings = self.layouts.keys()
        self.layout_strings.sort()
        margin_widgets = [
            CustomUnitOption(defaults.get(pref,PDF_PREF_DEFAULT[pref]))
            for pref in ['left_margin','right_margin','top_margin','bottom_margin']
            ]
        # Make unit changes to one widget affect all the others!
        for m in margin_widgets:
            for mm in margin_widgets:
                if mm is not m:
                    m.sync_to_other_cuo(mm)
            
        self.opts = [
            [_('Paper _Size')+':',(defaults.get('page_size',PDF_PREF_DEFAULT['page_size']),
                                  self.size_strings)],
            [_('_Orientation')+':',(defaults.get('orientation',PDF_PREF_DEFAULT['orientation']),
                                    self.page_modes.keys())],
            [_('_Font Size')+':',int(defaults.get('font_size',PDF_PREF_DEFAULT['font_size']))],
            [_('Page _Layout'),(defaults.get('page_layout',PDF_PREF_DEFAULT['page_layout']),
                                self.layout_strings)],
            [_('Left Margin')+':',margin_widgets[0]],
            [_('Right Margin')+':',margin_widgets[1]],
            [_('Top Margin')+':',margin_widgets[2]],
            [_('Bottom Margin')+':',margin_widgets[3]],
            ]
        
        self.page_drawer = PdfPageDrawer(yalign=0.0)    
        self.in_ccb = False
        self.setup_widgets()
        self.table.connect('changed',self.change_cb)
        self.table.emit('changed')
        self.page_drawer.set_size_request(200,100)
        self.page_drawer.show()

    def make_reverse_dicts (self):
        self.page_sizes_r = {}; self.layouts_r = {}; self.page_modes_r = {}
        for dict,dict_r in [
            (self.page_sizes,self.page_sizes_r),
            (self.layouts,self.layouts_r),
            (self.page_modes,self.page_modes_r)]:
            for k,v in dict.items(): dict_r[v]=k

    def setup_widgets (self):
        self.pd = de.PreferencesDialog(self.opts,option_label=None,value_label=None,
                                  label=_('PDF Options'),
                                  )
        self.pd.hbox.pack_start(self.page_drawer,fill=True,expand=True)
        self.table = self.pd.table

    def run (self):
        self.pd.run()
        return self.get_args_from_opts(self.opts)

    def get_args_from_opts (self, opts):
        args = {}
        if not get_prefs().has_key('PDF_EXP'):
            get_prefs()['PDF_EXP'] = {}
        prefs = get_prefs()['PDF_EXP']
        args['pagesize'] = self.page_sizes[opts[self.OPT_PS][1]] # PAGE SIZE
        prefs['page_size'] = self.page_sizes_r[args['pagesize']]
        args['pagemode'] = self.page_modes[opts[self.OPT_PO][1]] # PAGE MODE
        prefs['orientation'] = self.page_modes_r[args['pagemode']]
        prefs['font_size'] = args['base_font_size'] = opts[self.OPT_FS][1] # FONT SIZE
        args['mode'] = self.layouts[opts[self.OPT_PL][1]] # LAYOUT/MODE
        prefs['page_layout'] = self.layouts_r[args['mode']]
        prefs['left_margin'] = args['left_margin'] = opts[self.OPT_LM][1]
        prefs['right_margin'] = args['right_margin'] = opts[self.OPT_RM][1]
        prefs['top_margin'] = args['top_margin'] = opts[self.OPT_TM][1]
        prefs['bottom_margin'] = args['bottom_margin'] = opts[self.OPT_BM][1]
        return args

    def change_cb (self, option_table, *args,**kwargs):
        if self.in_ccb: return
        self.in_ccb = True
        option_table.apply()
        args = self.get_args_from_opts(self.opts)
        changed = False
        if args['pagesize']!=self.page_drawer.last_kwargs.get('pagesize','letter'):
            last_pagesize = self.page_drawer.last_kwargs.get('pagesize','letter')
            pagesize = args['pagesize']
            # If pagesize has changed from index to non-index card,
            # toggle orientation and margins by default for our user's
            # convenience...
            if pagesize in self.INDEX_CARDS and last_pagesize not in self.INDEX_CARDS:
                changed = True
                option_table.set_option(self.OPT_PO,_('Landscape'))
                for o in [self.OPT_LM,self.OPT_RM,self.OPT_BM,self.OPT_TM]:
                    option_table.set_option(o,0.25)
                option_table.set_option(self.OPT_FS,8)
                # Also -- make sure we don't allow index card layout in this...
                cb = option_table.widgets[self.OPT_PL][0]
                if not hasattr(self,'index_card_layouts_to_put_back'):
                    self.index_card_layouts_to_put_back = []
                    for i in self.INDEX_CARD_LAYOUTS:
                        pos=self.layout_strings.index(i)
                        self.index_card_layouts_to_put_back.append((pos,i))
                    self.index_card_layouts_to_put_back.sort()
                n = cb.get_active()
                if n in [i[0] for i in self.index_card_layouts_to_put_back]:
                    default_pos = self.layout_strings.index(_('Plain'))
                    cb.set_active(default_pos)
                self.index_card_layouts_to_put_back.reverse()
                for pos,txt in self.index_card_layouts_to_put_back:
                    cb.remove_text(pos)
                self.index_card_layouts_to_put_back.reverse()
            elif pagesize not in self.INDEX_CARDS and last_pagesize in self.INDEX_CARDS:
                changed = True                
                option_table.set_option(self.OPT_PO,_('Portrait'))
                for o in [self.OPT_LM,self.OPT_RM,self.OPT_BM,self.OPT_TM]:
                    option_table.set_option(o,1)
                option_table.set_option(self.OPT_FS,10)
                # Also -- we allow index card layout in this...
                cb = option_table.widgets[self.OPT_PL][0]
                if hasattr(self,'index_card_layouts_to_put_back'):
                    for pos,txt in self.index_card_layouts_to_put_back:
                        cb.insert_text(pos,txt)
    
        if (args['mode'][0] != self.page_drawer.last_kwargs.get('mode',('column',1))[0]
            or
            (args['mode'][0]=='index_cards'
             and (args['mode'] != self.page_drawer.last_kwargs['mode']
                  or
                  (args['pagesize'] != self.page_drawer.last_kwargs['pagesize']
                   and
                   'elevenSeventeen' in [args['pagesize'],self.page_drawer.last_kwargs['pagesize']]
                   )
                  )
             )
            ):
            # If our mode has changed...
            changed = True
            if args['mode'][0]=='index_cards':
                option_table.set_option(self.OPT_FS,8)
                for o in [self.OPT_LM,self.OPT_RM,self.OPT_BM,self.OPT_TM]:
                    option_table.set_option(o,0.35)
                if (args['mode'][1][0] <= 5.2*inch) ^ (args['pagesize']=='elevenSeventeen'):
                    option_table.set_option(self.OPT_PO,_('Landscape'))
                else:
                    option_table.set_option(self.OPT_PO,_('Portrait'))
            else:
                # Otherwise it's columns...
                option_table.set_option(self.OPT_FS,10) 
                for o in [self.OPT_LM,self.OPT_RM,self.OPT_BM,self.OPT_TM]:
                    option_table.set_option(o,1)
        if changed:
            option_table.apply()
            args = self.get_args_from_opts(self.opts)
        #backup_args = page_drawer.last_kwargs
        self.page_drawer.set_page(**args)
        self.page_drawer.queue_draw()
        self.in_ccb = False

class PdfPrefTable (PdfPrefGetter):

    # Like the dialog, but without the window -- lets it be embedded
    # in a print preferences widget.

    def setup_widgets (self):
        self.widg = gtk.HBox()
        self.table = optionTable.OptionTable(options=self.opts,
                                             option_label=None,
                                             value_label=None,
                                             changedcb=None)
        self.widg.pack_start(self.table)
        self.widg.pack_start(self.page_drawer,fill=True,expand=True)
        self.widg.show_all()

def get_pdf_prefs (defaults=None):
    if defaults: print 'WARNING: ignoring provided defaults and using prefs system instead'
    pdf_pref_getter = PdfPrefGetter()
    return pdf_pref_getter.run()
            
if __name__ == '__main__':
    w = gtk.Window()
    cuo = CustomUnitOption(44)
    cuo2 = CustomUnitOption(98)
    cuo.sync_to_other_cuo(cuo2)
    cuo2.sync_to_other_cuo(cuo)
    vb = gtk.VBox()
    l = gtk.Label('Hello World')
    vb.add(l)
    vb.pack_start(cuo)
    vb.pack_start(cuo2)
    w.add(vb)
    vb.show(); cuo.show(); cuo2.show()
    w.show()
    w.connect('delete_event',gtk.main_quit)
    gtk.main()
    raise Exception("Hell")
    
    from tempfile import tempdir
    import os.path
    #opts = get_pdf_prefs(); print opts
    test_3_x_5()
    
    #star_file = file(os.path.join(tempdir,'star.pdf'),'wb')
    #sw = PdfWriter()
    #sw.setup_document(star_file,mode='two_column')
    #for n in range(6,72,2):
    #    sw.write_paragraph("This is some text with a %s pt star"%n)
    #    sw.txt.append(FiveStars(n,filled=3.5))
    #    
    #sw.close()
    #star_file.close()
    #import gnome
    #gnome.program_init('1.0','Gourmet PDF Exporter Test')
    #gglobals.launch_url('file:/os.path.join(tempdir,/star.pdf')
    #raise Exception("I don')t want to go any further")
    
    if os.name == 'nt':
        base = 'C:\\grm\grm'
    else:
        base = '/home/tom/Projects/grm'

    #import gourmet.recipeManager as rm
    #rd = rm.RecipeManager(file=os.path.join(base,'src','tests','reference_setup','recipes.db'))
    #rd = rm.RecipeManager()
    #ofi = file(os.path.join(tempdir,'test_rec.pdf'),'w')
    #rr = []
    #for n,rec in enumerate(rd.fetch_all(rd.recipe_table,deleted=False)):
    #    if rec.image:
    #        rr.append(rec)
    #pe = PdfExporterMultiDoc(rd,rd.fetch_all(rd.recipe_table),os.path.join(tempdir,'fooby.pdf'))
    #pe = PdfExporterMultiDoc(rd,rd.fetch_all(rd.recipe_table,deleted=False)[:10],os.path.join(tempdir,'fooby.pdf'))
    #pe = PdfExporterMultiDoc(rd,rr,os.path.join(tempdir,'fooby.pdf'))
    #pe.run()

    def test_formatting ():
        sw = PdfWriter()
        f = file(os.path.join(tempdir,'format.pdf'),'wb')
        sw.setup_document(f)
        sw.write_header('This is a header & isn\'t it nifty')
        sw.write_paragraph('<i>This</i> is a <b>paragraph</b> with <u>formatting</u>!')
        sw.write_header('<u>This is a formatted header &amp; it is also nifty &amp; cool</u>')
        sw.write_paragraph('<i>This is another formatted paragraph</i>')
        sw.write_paragraph('<span fg="\#f00">This is color</span>')
        sw.close()
        f.close()
        return os.path.join(tempdir,'format.pdf')

    def test_3_x_5 ():
        print 'Test 3x5 layout'
        sw = PdfWriter()
        f = file(os.path.join(tempdir,'foo.pdf'),'wb')
        sw.setup_document(f,
                          mode=('index_cards',(5*inch,3.5*inch)),
                          #pagesize=(5*inch,3.5*inch),
                          pagesize='letter',
                          pagemode='landscape',
                          left_margin=0.25*inch,right_margin=0.25*inch,
                          top_margin=0.25*inch,bottom_margin=0.25*inch,
                          base_font_size=8,
                          )
        #sw.write_header('Heading')
        #sw.write_subheader('This is a subheading')
        for n in range(5):
            sw.write_header(
                u"This is a header"
                )
            #sw.write_subheader(
            #    u"This is a subheader"
            #    )
            sw.write_paragraph(
                u"%s: These are some sentences.  Hopefully some of these will be quite long sentences.  Some of this text includes unicode -- 45\u00b0F, for example... \u00bfHow's that?"%n*10
                )
        #sw.write_paragraph('This is a <i>paragraph</i> with <b>some</b> <u>markup</u>.')
        #sw.write_paragraph(u"This is some text with unicode - 45\u00b0, \u00bfHow's that?".encode('iso-8859-1'))
        #sw.write_paragraph(u"This is some text with a unicode object - 45\u00b0, \u00bfHow's that?")
        sw.close()
        f.close()
        return os.path.join(tempdir,'foo.pdf')

    def test_grm_export (pdf_args=DEFAULT_PDF_ARGS):
        fname = tempfile.mktemp('.pdf')
        #if os.name == 'nt':
        #    base = 'C:\\grm\grm'
        #else:
        #    base = '/home/tom/Projects/grm'
        import gourmet.recipeManager as rm
        rd = rm.get_recipe_manager(file=os.path.join(base,'src','tests','reference_setup','recipes.db'))
        #rd = rm.RecipeManager()
        rr = []
        #for n,rec in enumerate(rd.fetch_all(rd.recipe_table,deleted=False)):
        #    if rec.image:
        #        rr.append(rec)
        pe = PdfExporterMultiDoc(rd,rd.fetch_all(rd.recipe_table,deleted=False),fname,pdf_args=pdf_args)
        pe.run()
        return fname

    import gourmet.gglobals as gglobals
    #try:
    #    import gnome
    #    gnome.program_init('1.0','Gourmet PDF Exporter Test')
    #except ImportError:
    #    print 'We must be on windows...'

    #print 'TEST 3x5'
    gglobals.launch_url('file://'+test_3_x_5())
    gglobals.launch_url('file://'+test_formatting())
    #print 'END TEST'
    #print 'TEST GRM'
    gglobals.launch_url('file://'+test_grm_export())
    #print 'TEST CUSTOM GRM'
    #gglobals.launch_url('file://'+test_grm_export(get_pdf_prefs({'page_size':_('A4'),'page_layout':'2 Columns'})))
    #ppg = PdfPrefGetter()
    #print ppg.run()
    #print 'END TEST'
    

########NEW FILE########
__FILENAME__ = pdf_exporter_plugin
from gourmet.plugin import ExporterPlugin
import pdf_exporter
from gettext import gettext as _

PDF = _('PDF (Portable Document Format)')

class PdfExporterPlugin (ExporterPlugin):

    label = _('PDF Export')
    sublabel = _('Exporting recipes to PDF %(file)s.')
    single_completed_string = _('Recipe saved as PDF %(file)s')
    filetype_desc = PDF
    saveas_filters = [PDF,['application/pdf'],['*.pdf']]
    saveas_single_filters = [PDF,['application/pdf'],['*.pdf']]
    mode = 'wb'

    def get_multiple_exporter (self, args):
        return pdf_exporter.PdfExporterMultiDoc(args['rd'],
                                                args['rv'],
                                                args['file'],
                                                pdf_args=args['extra_prefs'],
                                                )
    def do_single_export (self, args):
        exp = pdf_exporter.PdfExporter(args['rd'],
                                       args['rec'],
                                       args['out'],
                                       change_units=args['change_units'],
                                       mult=args['mult'],
                                       pdf_args=args['extra_prefs'],
                                 )
        exp.run()

    def run_extra_prefs_dialog (self):
        return pdf_exporter.get_pdf_prefs()

    def get_default_prefs (self):
        return pdf_exporter.DEFAULT_PDF_ARGS

########NEW FILE########
__FILENAME__ = print_plugin
import gtk
import sys
if sys.platform != "win32":
    import poppler
import os.path
import pdf_exporter
import tempfile
import reportlab.lib.pagesizes as pagesizes
from gourmet.plugin import PrinterPlugin
from gettext import gettext as _

rl2gtk_papersizes = {
    tuple([int(round(s)) for s in pagesizes.letter]) : gtk.PAPER_NAME_LETTER,
    tuple([int(round(s)) for s in pagesizes.legal]) : gtk.PAPER_NAME_LEGAL,    
    tuple([int(round(s)) for s in pagesizes.B5]):gtk.PAPER_NAME_B5,
    tuple([int(round(s)) for s in pagesizes.A5]):gtk.PAPER_NAME_A5,
    tuple([int(round(s)) for s in pagesizes.A4]):gtk.PAPER_NAME_A4,
    tuple([int(round(s)) for s in pagesizes.A3]):gtk.PAPER_NAME_A3,
    }

class WindowsPDFPrinter:

    def setup_printer (self, parent=None):
        self.args = pdf_exporter.get_pdf_prefs()
        self.begin_print(None, None)

    def set_document (self, filename, operation,context):
        try:
            from subprocess import Popen
            import _winreg
            regPathKey = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,
                                         "Software\Microsoft\Windows\CurrentVersion\App Paths\AcroRd32.exe")
            regPathValue, regPathType = _winreg.QueryValueEx(regPathKey, "")
            if regPathType != _winreg.REG_SZ:
                raise TypeError
        except:
            from gourmet.gtk_extras.dialog_extras import show_message
            show_message(label=_("Could not find Adobe Reader on your system."),
                         sublabel=_("This version of Gourmet Recipe Manager "
                         "requires Adobe Reader "
                         "to be able to print; other PDF viewers will not work.\n"
                         "Please install Adobe Reader from http://get.adobe.com/reader/. \n"
                         "Alternatively, export your recipe(s) to PDF "
                         "and print it with another PDF viewer."))
        else:
            # Launch a new instance (/n) of Adobe Reader with our temporary
            # PDF to display the print dialog (/p).
            Popen(regPathValue + " /n /p " + os.path.realpath(filename))

class PDFPrinter:

    def setup_printer (self, parent=None):
        po = gtk.PrintOperation()
        #po.set_n_pages(self.d.get_n_pages())
        po.connect('draw_page',self.draw_page)
        po.connect('begin-print',self.begin_print)
        po.connect('create-custom-widget',self.create_custom_widget)
        po.props.custom_tab_label = _('Page Layout')
        po.connect('custom-widget-apply',self.custom_widget_apply)
        po.run(gtk.PRINT_OPERATION_ACTION_PRINT_DIALOG, parent=parent)

    def set_document (self, filename, operation,context):
        if not filename.startswith('file'):
            filename = 'file://' + os.path.realpath(filename)
        self.d = poppler.document_new_from_file(filename,None)
        operation.set_n_pages(self.d.get_n_pages())
        # Assume all pages are same
        page = self.d.get_page(0)
        w,h = page.get_size()
        if w > h:
            w,h = h,w
            ori = gtk.PAGE_ORIENTATION_LANDSCAPE
        else:
            ori = gtk.PAGE_ORIENTATION_PORTRAIT
        page_setup = gtk.PageSetup()
        page_setup.set_orientation(ori)
        size = int(round(w)),int(round(h))
        gtk_size = rl2gtk_papersizes.get(size,None)
        if gtk_size:
            ps = gtk.PaperSize(gtk_size)
        else:
            ps = gtk.paper_size_new_custom('','',w,h,gtk.UNIT_POINTS)
        page_setup.set_paper_size(ps)
        operation.set_default_page_setup(page_setup)
        
    def draw_page (self,operation, context, page_num):
        page = self.d.get_page(page_num)
        w,h = page.get_size()
        #page_setup = context.get_page_setup()
        #ps = gtk.paper_size_new_custom('','',w,h,gtk.UNIT_POINTS)
        #page_setup.set_paper_size(ps)
        page.render_for_printing(context.get_cairo_context())

    def create_custom_widget (self, operation):
        self.ppt = pdf_exporter.PdfPrefTable()
        self.opts = self.ppt.opts
        self.args = self.ppt.get_args_from_opts(self.opts)
        return self.ppt.widg
        
    def custom_widget_apply (self, operation, widget):
        self.args = self.ppt.get_args_from_opts(self.opts)

if sys.platform == "win32":
    PDFPrinter = WindowsPDFPrinter

def record_args (func):
    
    def _ (self, *args, **kwargs):
        self.export_commands.append(
            (func.__name__,args,kwargs)
            )
    return _

class PDFSimpleWriter (PDFPrinter):

    def __init__ (self, dialog_parent=None):
        self.parent = dialog_parent
        self.export_commands = []

    @record_args
    def write_header (self, *args, **kwargs): pass

    @record_args
    def write_subheader (self, *args, **kwargs): pass

    @record_args
    def write_paragraph (self, *args, **kwargs): pass

    def close (self, *args, **kwargs):
        self.export_commands.append(('close',[],{}))
        self.setup_printer(self.parent)
    
    def begin_print (self, operation, context):
        fn = tempfile.mktemp()
        writer = pdf_exporter.PdfWriter()
        writer.setup_document(fn,**self.args)
        # Playback all the commands we recorded
        for commandname,args,kwargs in self.export_commands:
            func = getattr(writer,commandname)
            func(*args,**kwargs)
        # And now we trust the documents been written...
        self.set_document(fn,operation,context)

        
class PDFRecipePrinter (PDFPrinter):

    def __init__ (self, rd, recs,
                  mult=1, dialog_title=_('Print Recipes'),
                  dialog_parent=None, change_units=True):
        self.printing_error = False
        self.change_units = change_units
        self.mult = mult
        self.parent = dialog_parent
        self.rd = rd
        self.recs = recs
        self.setup_printer(self.parent)
        
    def begin_print (self, operation, context):
        fn = tempfile.mktemp()
        pe = pdf_exporter.PdfExporterMultiDoc(self.rd,self.recs,fn,pdf_args=self.args,
                                              change_units=self.change_units, mult=self.mult)
        pe.connect('error',self.handle_error)
        pe.run()
        if self.printing_error:
            print 'PRINTING ERROR!'
            raise Exception("There was an error generating PDF")
        self.set_document(fn, operation,context)

    def handle_error (self,obj,errno, summary, traceback):
        print 'There was an error generating a PDF to print.'
        print summary
        print traceback
        self.printing_error = True
        raise Exception('There was an error generating a PDF to print')

def setup_printer (pp):
    po = gtk.PrintOperation()
    po.set_n_pages(pp.d.get_n_pages())
    po.connect('draw_page',pp.draw_page)
    po.connect('begin-print',pp.begin_print)
    po.connect('create-custom-widget',pp.create_custom_widget)
    po.connect('custom-widget-apply',pp.custom_widget_apply)
    po.run(gtk.PRINT_OPERATION_ACTION_PRINT_DIALOG)
    
def print_pdf (pdf_filename):
    if not pdf_filename.startswith('file'):
        pdf_filename = 'file://' + os.path.realpath(pdf_filename)
        setup_printer(PDFPrinter(pdf_filename))

def test_simplewriter ():
    pwriter = PDFSimpleWriter()
    pwriter.write_header("TEST HEADER")
    pwriter.write_subheader('Test subheading')
    pwriter.write_paragraph('This is a test  ' * 10)
    pwriter.write_paragraph('This is a test  ' * 15)
    for n in range(3):
        pwriter.write_subheader('Test subheading for time number %s'%(n+2))
        for i in range(5,(5*(n+1))):
            pwriter.write_paragraph('So is this a test? Or is it. '*i)
    pwriter.close()

class PDFPrintPlugin (PrinterPlugin):
    SimpleWriter = PDFSimpleWriter
    simpleWriterPriority = 1
    RecWriter = PDFRecipePrinter
    recWriterPriority = 1
    
if __name__ == '__main__':
    test_simplewriter()

########NEW FILE########
__FILENAME__ = plaintext_exporter_plugin
from gourmet.plugin import ExporterPlugin
import gourmet.exporters.exporter as exporter
from gettext import gettext as _

TXT = _('Plain Text file')

class PlainTextExporterPlugin (ExporterPlugin):

    label = _('Text Export')
    sublabel = _('Exporting recipes to text file %(file)s.')
    single_completed_string = _('Recipe saved as plain text file %(file)s')
    filetype_desc = TXT
    saveas_filters = [TXT,['text/plain'],['*.txt','*.TXT']]
    saveas_single_filters = [TXT,['text/plain'],['*.txt','*.TXT','']]

    def get_multiple_exporter (self, args):
        return exporter.ExporterMultirec(
            args['rd'],
            args['rv'],
            args['file'],
            one_file=True,
            ext='txt',
            )

    def do_single_export (self, args)    :
        e = exporter.exporter_mult(args['rd'],
                                   args['rec'],
                                   args['out'],
                                   mult=args['mult'],
                                   change_units=args['change_units'],
                                   )
        e.run()

    def run_extra_prefs_dialog (self):
        pass

########NEW FILE########
__FILENAME__ = plaintext_importer_plugin
from gourmet.plugin import ImporterPlugin
from gourmet.importers.importer import Tester
from gourmet.threadManager import get_thread_manager
from gourmet.importers.interactive_importer import InteractiveImporter
from gourmet import check_encodings
import os.path
import fnmatch
from gettext import gettext as _

MAX_PLAINTEXT_LENGTH = 100000

class PlainTextImporter (InteractiveImporter):

    name = 'Plain Text Importer'

    def __init__ (self, filename):
        self.filename = filename
        InteractiveImporter.__init__(self)
        
    def do_run (self):
        if os.path.getsize(self.filename) > MAX_PLAINTEXT_LENGTH*16:
            del data
            ifi.close()
            import gourmet.gtk_extras.dialog_extras as de
            de.show_message(title=_('Big File'),
                            label=_('File %s is too big to import'%self.filename),
                            sublabel=_('Your file exceeds the maximum length of %s characters. You probably didn\'t mean to import it anyway. If you really do want to import this file, use a text editor to split it into smaller files and try importing again.')%MAX_PLAINTEXT_LENGTH,
                            message_type=gtk.MESSAGE_ERROR)
            return
        ifi = file(self.filename,'r')
        data = '\n'.join(check_encodings.get_file(ifi))
        ifi.close()
        self.set_text(data)
        return InteractiveImporter.do_run(self)

class PlainTextImporterPlugin (ImporterPlugin):

    name = _('Plain Text file')
    patterns = ['*.txt','[^.]*','*']
    mimetypes = ['text/plain']

    antipatterns = ['*.html','*.htm','*.xml','*.doc','*.rtf']

    def test_file (self, filename):
        '''Given a filename, test whether the file is of this type.'''
        if filename.endswith('.txt'):
            return 1
        elif not True in [fnmatch.fnmatch(filename,p) for p in self.antipatterns]:
            return -1 # we are a fallback option

    def get_importer (self, filename):
        return PlainTextImporter(filename=filename)
                                                   


    

########NEW FILE########
__FILENAME__ = about_dot_com_plugin
from gourmet.plugin import PluginPlugin
import re

class AboutDotComPlugin (PluginPlugin):

    target_pluggable = 'webimport_plugin'

    def do_activate (self, pluggable):
        #print 'Activating ',self,'for',pluggable
        pass

    def test_url (self, url, data):
        if 'about.com' in url:
            return 5

    def get_importer (self, webpage_importer):

        class AboutDotComWebParser (webpage_importer.MenuAndAdStrippingWebParser):

            def preparse (self):
                includes = [('rInt','instructions'),
                            ('rIng','ingredients'),
                            ('rPrp','instructions'),
                            ('articlebody','recipe'),]
                self.preparsed_elements = []
                for i,t in includes:
                    for el in self.soup(id=i):
                        self.preparsed_elements.append((el,t))
                if self.preparsed_elements:
                    self.ignore_unparsed = True
                    self.preparsed_elements.append((self.soup('title')[0],'title'))
                    # Now get rid of the annoying "More... recipes..."
                    for wrapper in ['rPrp','articlebody']:
                        try:
                            boldyLinks = self.soup(id=wrapper)[0]('b')
                            boldyLinks.extend(self.soup(id=wrapper)[0]('a'))
                        except IndexError:
                            pass
                        else:
                            regexp = re.compile('More.*|.*Recipes.*')
                            for bold in boldyLinks:
                                if bold(text=regexp):
                                    self.preparsed_elements.append((bold,'ignore'))
                else:
                    webpage_importer.MenuAndAdStrippingWebParser.preparse(self)

            def cut_sponsored_links (self):
                for sl in self.soup(text=re.compile('.*(Sponsored Links|Advertisement|Cooking Ads).*')):
                    addiv = sl.findParent('div')
                    self.preparsed_elements.append((addiv,'ignore'))
                webpage_importer.MenuAndAdStrippingWebParser.cut_sponsored_links(self)

            def cut_menus (self):
                for mi in self.soup(text=re.compile('.*(Most Popular|Must Reads|By Category|iGoogle|More from About.com).*')):
                    mendiv = mi.findParent('div')
                    self.preparsed_elements.append((mendiv,'ignore'))        
                for mi in self.soup(text='Email'):
                    mendiv = mi.findParent('div')
                    self.preparsed_elements.append((mendiv,'ignore'))
                for div in self.soup('div',attrs={'class':'hlist'}):
                    self.preparsed_elements.append((div,'ignore'))
                webpage_importer.MenuAndAdStrippingWebParser.cut_menus(self)

        return AboutDotComWebParser
        

########NEW FILE########
__FILENAME__ = allrecipes_plugin
from gourmet.plugin import PluginPlugin
import schema_org_parser
from schema_org_parser import Excluder

class AllRecipesPlugin (PluginPlugin):
    target_pluggable = 'webimport_plugin'

    def do_activate (self, pluggable):
        pass
    
    def test_url (self, url, data):
        if 'allrecipes.com' in url: 
            return 5
        return 0

    def get_importer (self, webpage_importer):
        AllRecipesParserBase = schema_org_parser.generate(webpage_importer.WebParser)

        class AllRecipesParser(AllRecipesParserBase):
            def preparse (self):
                AllRecipesParserBase.preparse(self)
                instructions = self.soup.find(attrs={"class": "directLeft"}).find('ol')
                self.preparsed_elements.append((instructions,'instructions'))
                #for li in instructions.findAll('li'):
                #    self.preparsed_elements.append((li,'instructions'))
                preptime = self.soup.find(id='liPrep').find('span')
                self.preparsed_elements.append((preptime,'preptime'))
                cooktime = self.soup.find(id='liCook').find('span')
                self.preparsed_elements.append((cooktime,'cooktime'))

        return AllRecipesParser


########NEW FILE########
__FILENAME__ = foodnetwork_plugin
from gourmet.plugin import PluginPlugin
import re

class FoodNetworkPlugin (PluginPlugin):

    target_pluggable = 'webimport_plugin'

    def test_url (self, url, data):
        if 'foodnetwork.com' in url:
            return 5
        return 0

    def get_importer (self, webpage_importer):

        class FoodNetworkParser (webpage_importer.MenuAndAdStrippingWebParser):

            imageexcluders = [re.compile('foodnetworkstore|googlead|ft-|banner')]

            def preparse (self):
                headm = re.compile('rcp-head.*')
                textm = re.compile('body-text.*')
                infom = re.compile('rcp-info.*')
                self.preparsed_elements = []
                for el in self.soup('div',{'class':textm}):
                    self.preparsed_elements.append((el,'recipe'))
                for el in self.soup('div',{'class':headm}):
                    self.preparsed_elements.append((el,'recipe'))
                    self.preparsed_elements.append((el('h1'),'title'))
                for el in self.soup('ul',{'class':infom}):
                    self.preparsed_elements.append((el,'recipe'))
                preptime = self.soup('dt',text='Prep')
                if preptime:
                    self.preparsed_elements.append((preptime[0].next,'preptime'))
                cooktime = self.soup('dt',text='Cook')
                if cooktime:
                    self.preparsed_elements.append((cooktime[0].next,'cooktime'))
                servings = self.soup(text='Yield')
                if servings:
                    self.preparsed_elements.append((servings[0].next,'servings'))
                ingredients = self.soup(text='Ingredients')
                if ingredients:
                    if ingredients[0].parent:
                        if ingredients[0].parent.findNextSiblings('ul'):
                            self.preparsed_elements.append((ingredients[0].parent.findNextSiblings('ul')[0],'ingredients'))
                #import sys; sys.argv = []
                #from IPython.Shell import IPShellEmbed
                #ipshell = IPShellEmbed()
                #Ipshell()
                if self.preparsed_elements:
                    self.ignore_unparsed = True
                else:
                    webpage_importer.MenuAndAdStrippingWebParser.preparse(self)

        return FoodNetworkParser

########NEW FILE########
__FILENAME__ = ica_se_plugin
"""
A plugin that tries to import recipes from the ica.se site
"""
from gourmet.plugin import PluginPlugin
import schema_org_parser
from schema_org_parser import Excluder

class IcaSePlugin (PluginPlugin):

    target_pluggable = 'webimport_plugin'

    def test_url (self, url, data):
        "Is this url from ica.se"
        if 'ica.se' in url:
            return 5
        return 0

    def get_importer (self, webpage_importer):
        IcaSeParserBase = schema_org_parser.generate(webpage_importer.WebParser)
        #ica.se doesn't specify cookTime, so we use totalTime instead
        IcaSeParserBase.schema_org_mappings['totalTime'] = 'cooktime'

        class IcaSeParser(IcaSeParserBase):
            def preparse (self):
                IcaSeParserBase.preparse(self)
                yields = self.soup.find(id='servings')
                self.preparsed_elements.append((yields,'yields'))

        return IcaSeParser


########NEW FILE########
__FILENAME__ = schema_org_parser
"""
Parser for web pages that use the http://schema.org/Recipe microformat
"""

class Excluder(object):
    def __init__(self, url):
        self.url = url
    def search(self, other_url):
        return not (other_url.endswith(self.url))

def generate(BaseParser):
    class SchemaOrgParser (BaseParser):
    
        schema_org_mappings = {# Properties from Thing (not all given)
                               'name': 'recipe',
                               'description': 'modifications',
                               # Properties from CreativeWork (none)
                               # Properties from Recipe
                               #'cookingMethod'
                               'ingredients': 'ingredients',
                               #'nutrition'
                               'recipeCategory': 'category',
                               'recipeCuisine': 'cuisine',
                               'recipeInstructions': 'instructions',
                               'recipeYield': 'yields',
                               #'totalTime'
                               }
        #FIXME: Currently not evaluated
        schema_org_duration_mappings = {# Properties from Recipe
                                        'cookTime': 'cooktime',
                                        'prepTime': 'preptime'
                                        }
    
        imageexcluders = []
    
        def preparse (self):
            self.preparsed_elements = []
            self.recipe_schema_scope = self.soup.find(itemscope = True,
                                                      itemtype =
                                                      'http://schema.org/Recipe')
            for tag in self.recipe_schema_scope.findAll(itemprop=True):
                itemprop = tag["itemprop"]
                for k, v in self.schema_org_mappings.iteritems():
                    if itemprop == k:
                        self.preparsed_elements.append((tag,v))
    
                if itemprop == "image":
                    self.imageexcluders.append(Excluder(tag["src"]))
    
            if self.preparsed_elements:
                self.ignore_unparsed = True
            else:
                BaseParser.preparse(self)

    return SchemaOrgParser


########NEW FILE########
__FILENAME__ = generic_web_importer_plugin
from gourmet.plugin import ImporterPlugin, PluginPlugin
from gourmet.plugin_loader import Pluggable
import webpage_importer
from gettext import gettext as _

class GenericWebImporter (ImporterPlugin, Pluggable):

    name = _('Webpage')
    patterns = ['*.htm','*.html','*.xhtml']
    mimetypes = ['text/html','text/xhtml','application/xhtml+xml','application/xhtml','application/html']
    targets = ['webimport_plugin']

    def __init__ (self, *args, **kwargs):
        Pluggable.__init__(self, [PluginPlugin])

    #def activate (self, pluggable):
    #    print 'activate GenericWebImporter for pluggable',pluggable
    #    return ImporterPlugin.activate(self,pluggable)

    def test_file (self, filename):
        '''Given a file name, test whether the file is of this type.'''
        #if filename.endswith('.htm') or filename.endswith('.xhtml') or filename.endswith('.html'):
        return -1 # We are a fallback option

    def test_url (self, url, data, content_type):
        for p in self.plugins:
            if p.test_url(url, data):
                return 1
        try:
            iter(content_type)
        except:
            # In this case, content_type cannot be html...
            return None
        else:
            if 'html' in content_type:
                return -1 # We are the fallback option

    def get_web_importer (self, url, data, content_type):
        highest = 0
        importer = webpage_importer.MenuAndAdStrippingWebParser
        for p in self.plugins:
            test_val = p.test_url(url, data)
            if test_val and test_val > highest:
                # pass the module as an arg... very awkward inheritance
                importer = p.get_importer(webpage_importer) 
                highest = test_val
        return importer(url,data,content_type)

    def get_importer (self, filename):
        url = 'file://'+filename
        data = file(filename).read()
        content_type = 'text/html'
        return self.get_web_importer(url,data,content_type)


########NEW FILE########
__FILENAME__ = webpage_importer
# This is a basic
import BeautifulSoup
from gourmet.importers.generic_recipe_parser import RecipeParser
from gourmet.importers.interactive_importer import InteractiveImporter
import gourmet.importers.importer
import re, urllib
#import gourmet.plugin_loader

class WebParser (InteractiveImporter):

    BREAK_AROUND = ['p','title','h1','h2','h3','h4','h5','h6',
                    'table','p','blockquote','title','div']
    IS_BREAK = ['br']
    NESTED = {'tr':['table'],
              'li':['ol','ul'],
              'dd':['dl'],
              }
    TAB_BEFORE = ['td','dt']
    IGNORE = ['script','meta','select','link','img','style']
    TAB = '  '
    JOINABLE = ['instructions','notes','recipe','ignore','ingredients','include',None]
    INVISIBLE_TYPES = [
        BeautifulSoup.CData,
        BeautifulSoup.Comment,
        BeautifulSoup.Declaration,
        BeautifulSoup.ProcessingInstruction]

    do_postparse = True
    imageexcluders = None # This could be a list of compiled regexps which would
                         # be used to search image URL strings for
                         # potential ads, etc.
    def __init__ (self, url, data, content_type):
        self.ignore_unparsed = False
        self.url = url
        #self.name = 'Web Parser'
        print "HERE's the data we got:", data
        print "END DATA"
        self.soup = BeautifulSoup.BeautifulSoup(data,
                                                convertEntities=BeautifulSoup.BeautifulStoneSoup.XHTML_ENTITIES,
                                                )
        InteractiveImporter.__init__(self)
        #self.generic_parser = RecipeParser()
        self.preparse()
        self.get_images()
        self.text_parser = RecipeParser()

    def commit_rec (self):
        if not self.rec.get('link',''): self.rec['link'] = self.url
        gourmet.importers.importer.Importer.commit_rec(self)

    def preparse (self):
        self.preparsed_elements = []

    def identify_match (self, tag):
        for t,label in self.preparsed_elements:
            if tag==t:
                return label

    def get_images (self):
        self.images = []
        for i in self.soup('img'):
            try:
                src = i['src']
            except KeyError:
                continue
            img_url = urllib.basejoin(self.url,src)
            if self.imageexcluders:
                exclude = False
                for exc in  self.imageexcluders:
                    if exc.search(img_url):
                        exclude = True
                        break
                if exclude: continue
            self.images.append(img_url)
        
    def parse (self, tag=None):
        if not tag: tag = self.soup
        self.parsed = []
        self.buffer = ''
        self.last_label = None
        self.crawl(tag)
        if self.buffer:
            self.add_buffer_to_parsed()
        return self.parsed
    
    def crawl (self, tag, parent_label=None):
        formatting = self.format_tag_whitespace(tag)
        if formatting == -1:
            return # special case allows formatting method to
                   # auto-skip scripts and what-not
        else:
            start_ws,end_ws = formatting
            self.buffer += start_ws
        label = self.identify_match(tag)        
        if not label and parent_label:
            # inherit...
            label = parent_label
        elif self.ignore_unparsed and not label:
            label = 'ignore'
        #elif not label:
        #    print 'DONT IGNORE'
        #print 'ID TAG',tag,'with',label            
        if hasattr(tag,'contents') and tag.contents:
            for child in tag.contents:
                self.crawl(child,label)
        else:
            if label != self.last_label or self.last_label not in self.JOINABLE:
                if self.buffer:
                    self.add_buffer_to_parsed()
                self.last_label = label
            #print 'ADD TO BUFFER:',tag.string
            if hasattr(tag,'string'):
                self.buffer += self.reduce_whitespace(tag.string or '')
            #else:
            #    print 'Ignoring tag',tag
        if end_ws: self.buffer += end_ws
        return label

    def reduce_whitespace (self, s):
        if not hasattr(self,'__whitespace_regexp'):
            self.__whitespace_regexp = re.compile('\s+')
        return self.__whitespace_regexp.sub(' ',s)

    def cut_extra_whitespace (self, s):
        if s.count('\n')>2:
                s = s.replace(
                    '\n','',
                    s.count('\n')-2)
        return s
    
    def add_buffer_to_parsed (self):
        if not self.buffer.strip(): return
        tws = 0 #tws = # of trailing whitespace characters
        while tws+1 < len(self.buffer) and self.buffer[-(tws+1)].isspace():
            tws += 1
        if not tws:
            to_add = self.buffer
            self.buffer = ''
        else:
            to_add = self.buffer[:-tws]
            self.buffer = self.buffer[-tws:]
            self.buffer = self.cut_extra_whitespace(self.buffer)
        lws = 0
        while lws+1 < len(to_add) and to_add[lws].isspace():
            lws += 1
        if lws:
            # In this case, we're going to add the white space separately with no label...
            pre_add = to_add[:lws]
            pre_add = self.cut_extra_whitespace(pre_add)
            to_add = to_add[lws:]
            self.parsed.append((pre_add,None))
        # Do extra substitution of MS Characters -- shouldn't be necessary...
        for char,tup in BeautifulSoup.UnicodeDammit.MS_CHARS.items():
            char = char.decode('iso-8859-1').encode('utf-8')
            if to_add.find(char) >= 0:
                to_add = to_add.replace(char,unichr(long(tup[1],16)))
        self.parsed.append((to_add,self.last_label))

    def format_tag_whitespace (self, tag):
        '''Return any whitespace required by tag, or -1 if tag should
        not be considered for text
        '''
        for klass in self.INVISIBLE_TYPES:
            if isinstance(tag,klass):
                return -1
        if not hasattr(tag,'name'):
            return '',''
        elif tag.name in self.IGNORE:
            return -1
        if tag.name in self.IS_BREAK:
            return '\n',''
        elif tag.name in self.NESTED:
            parent_types = self.NESTED[tag.name]; parents = 0
            for typ in parent_types:
                parents += len(tag.fetchParents(typ))
            return '\n'+self.TAB*parents,''
        elif tag.name in self.TAB_BEFORE:
            return self.TAB,''
        elif tag.name in self.BREAK_AROUND:
            return '\n','\n'
        else:
            return '',''

    def postparse (self, parsed):
        '''Do purely text-based parsing of content.
        '''
        new_parse = []
        for p,attr in parsed:
            p = re.sub('(\n\s*\n)+','\n\n',p) # Take out extra newlines
            if attr == None or attr == 'recipe':
                new_parse.extend(
                    self.text_parser.parse(p)
                    )
            else:
                new_parse.append((p,attr))
        return new_parse

    def parse_webpage (self):
        self.preparse()
        tags = [pp[1] for pp in self.preparsed_elements]
        if 'include' in tags:
            self.ignore_unparsed = True
        parsed = self.parse()
        if self.do_postparse:
            return self.postparse(parsed)
        else:
            return parsed

    def do_run (self):
        parsed = self.parse_webpage()
        self.set_parsed(parsed)
        return InteractiveImporter.do_run(self)

class MenuAndAdStrippingWebParser (WebParser):

    def preparse (self):
        self.preparsed_elements = []
        tit = self.soup('title')
        if tit:
            self.preparsed_elements.append((tit,'title'))
        self.cut_sponsored_links()
        self.cut_menus()

    def cut_menus (self):
        menu_regexp = re.compile('.*(menu|nav|search|crumb|sitemap|footer|header).*',re.IGNORECASE)
        els = self.soup(id=menu_regexp)
        els.extend(self.soup(attrs={'class':menu_regexp}))
        for menu in els:
            if hasattr(menu,'name') and menu.name=='body':
                continue
            self.preparsed_elements.append((menu,'ignore'))
        menu_text_regexp = re.compile(
            '.*sitemap.*|^\s-*about\s-*',re.IGNORECASE
            )
        for menu in self.soup(text=menu_text_regexp):
            if hasattr(menu,'name') and menu.name == 'body': continue
            self.preparsed_elements.append((menu,'ignore'))

    def cut_sponsored_links (self):
        ad_re = re.compile('ad.*|.*advert.*|.*newsletter.*',re.IGNORECASE)
        spons = self.soup(id=ad_re)
        spons.extend(self.soup(attrs={'class':ad_re}))
        for spon in spons:
            if hasattr(spon,'name') and spon.name=='body': continue
            self.preparsed_elements.append((spon,'ignore'))
        
class WebParserTester (WebParser):

    def preparse (self):
        self.preparsed_elements = []
        head = self.soup('h1')
        if head:
            self.preparsed_elements.append((head[0],'title'))
        ings = self.soup('li')
        if ings:
            for i in ings: self.preparsed_elements.append((i,'ingredient'))
        author = self.soup('i')
        self.preparsed_elements.append((author[0],'source'))

def test_parser ():
    txt = '''<html><h1>Recipe</h1><p>This is my recipe<p><i>by Joe Shmoe</i></p><ul><li>1 cup sugar</li><li>2 cups flour</li><li>1 cup water</li>'''
    parser = WebParserTester('http://www.foo.bar',txt,None)
    parsed = parser.parse_webpage()
    for p,lab in parsed:
        print 'LABEL:',lab
        print 'TEXT:',p
    return parser

def test_webpage ():
    ifi = file('/tmp/test_recipe.htm','r')
    test = ifi.read(); ifi.close()
    from gourmet.plugins.import_export.website_import_plugins.about_dot_com_plugin import AboutDotComPlugin
    import sys
    aboutdotcom_plugin = AboutDotComPlugin()
    parser_type = aboutdotcom_plugin.get_importer(sys.modules[__name__])
    parser =  parser_type('http://www.foo.bar',test,None)
    parsed = parser.parse_webpage()
    for p,lab in parsed:
        if lab=='ignore': continue
        print 'LABEL:',lab
        print 'TEXT:',p
    return parser

if __name__ == '__main__':
    parser = test_parser()
    p = test_webpage()
    p.do_run()

########NEW FILE########
__FILENAME__ = keyEditor
import gtk, gtk.gdk, gobject, re, os, os.path, time
from gourmet import gglobals, convert
from gourmet.gtk_extras import WidgetSaver, mnemonic_manager, pageable_store
from gourmet.gtk_extras import cb_extras as cb
from gourmet.gtk_extras import dialog_extras as de
from gettext import gettext as _
from gettext import ngettext
import keyEditorPluggable
#import nutrition.nutritionDruid as nutritionDruid

try:
    current_path = os.path.split(os.path.join(os.getcwd(),__file__))[0]
except:
    current_path = ''

class KeyEditor:

    """KeyEditor sets up a GUI to allow editing which keys correspond to which items throughout
    the recipe database. It is useful for corrections or changes to keys en masse.
    """
    
    def __init__ (self, rd=None, rg=None):
        self.ui = gtk.Builder()
        self.ui.add_from_file(os.path.join(current_path,'keyeditor.ui'))
        self.rd = rd
        self.rg = rg
        self.widget_names = ['treeview', 'searchByBox', 'searchEntry', 'searchButton', 'window',
                             'searchAsYouTypeToggle', 'regexpTog',
                             'changeKeyEntry',
                             'changeItemEntry',
                             'changeUnitEntry',
                             'changeAmountEntry',
                             'applyEntriesButton',
                             'clearEntriesButton']
        for w in self.widget_names:
            setattr(self,w,self.ui.get_object(w))
        self.entries = {'ingkey':self.changeKeyEntry,
                        'item':self.changeItemEntry,
                        'unit':self.changeUnitEntry,
                        'amount':self.changeAmountEntry,
                        }
        # setup entry callback to sensitize/desensitize apply
        self.applyEntriesButton.set_sensitive(False)
        self.clearEntriesButton.set_sensitive(False)
        for e in self.entries.values():
            e.connect('changed',self.entryChangedCB)
        # Make our lovely model
        self.makeTreeModel()
        # setup completion in entry
        model = gtk.ListStore(str)
        for k in self.rd.get_unique_values('ingkey',table=self.rd.ingredients_table): model.append([k])
        cb.make_completion(self.changeKeyEntry,model)
        # Setup next/prev/first/last buttons for view
        self.prev_button = self.ui.get_object('prevButton')
        self.next_button = self.ui.get_object('nextButton')
        self.first_button = self.ui.get_object('firstButton')
        self.last_button = self.ui.get_object('lastButton')
        self.showing_label = self.ui.get_object('showingLabel')
        self.prev_button.connect('clicked',lambda *args: self.treeModel.prev_page())
        self.next_button.connect('clicked',lambda *args: self.treeModel.next_page())
        self.first_button.connect('clicked',lambda *args: self.treeModel.goto_first_page())
        self.last_button.connect('clicked',lambda *args: self.treeModel.goto_last_page())
        # Setup search stuff
        self.search_string=""
        self.search_by = _('key')
        self.use_regexp=True
        self.setupTreeView()
        self.treeview.set_model(self.treeModel)
        self.treeview.get_selection().set_mode(gtk.SELECTION_MULTIPLE)
        #self.treeview.set_model(self.treeModel)
        self.ui.connect_signals({
            'iSearch':self.isearchCB,
            'search':self.searchCB,
            'search_as_you_type_toggle':self.search_as_you_typeCB,
            'applyEntries':self.applyEntriesCB,
            'clearEntries':self.clearEntriesCB,
            'close_window': lambda *args: self.window.hide(),
            #'editNutritionalInfo':self.editNutritionalInfoCB,
            })
        # setup mnemonic manager
        self.mm = mnemonic_manager.MnemonicManager()
        self.mm.sacred_cows.append('search for')
        self.mm.add_builder(self.ui)
        self.mm.add_treeview(self.treeview)
        self.mm.fix_conflicts_peacefully()
        # to set our regexp_toggled variable
        cb.set_model_from_list(self.searchByBox, [_('key'),_('item'),_('unit')])
        self.searchByBox.set_active(0)
        self.dont_ask = self.rg.prefs.get('dontAskDeleteKey',False)
        # setup WidgetSavers
        self.rg.conf.append(WidgetSaver.WidgetSaver(
            self.searchAsYouTypeToggle,
            self.rg.prefs.get('sautTog',
                           {'active':self.searchAsYouTypeToggle.get_active()}),
            ['toggled']))
        self.rg.conf.append(WidgetSaver.WidgetSaver(
            self.regexpTog,
            self.rg.prefs.get('regexpTog',
                           {'active':self.regexpTog.get_active()}),
            ['toggled']))
                
    def dont_ask_cb (self, widget, *args):
        self.dont_ask=widget.get_active()
        self.rg.prefs['dontAskDeleteKey']=self.dont_ask
    
    def setupTreeView (self):
        self.FIELD_COL = 1
        self.VALUE_COL = 2
        self.COUNT_COL = 3
        self.REC_COL = 4
        self.NUT_COL = 5
        for n,head in [[self.FIELD_COL,_('Field')],
                       [self.VALUE_COL,_('Value')],
                       [self.COUNT_COL,_('Count')],
                       [self.REC_COL, _('Recipes')],
                       #[self.NUT_COL, _('Nutritional Info')],
                       ]:
            if n == self.NUT_COL:
                renderer = gtk.CellRendererToggle()
            else:
                renderer = gtk.CellRendererText()
            # If we have gtk > 2.8, set up text-wrapping
            try:
                renderer.get_property('wrap-width')
            except TypeError:
                pass
            else:
                renderer.set_property('wrap-mode',gtk.WRAP_WORD)
                if n == self.FIELD_COL:
                    renderer.set_property('wrap-width',60)
                elif n in [self.VALUE_COL,self.REC_COL]: renderer.set_property('wrap-width',250)
                else: renderer.set_property('wrap-width',100)
            if n==self.VALUE_COL:
                renderer.set_property('editable',True)
                renderer.connect('edited',self.tree_edited,n,head)
            if n == self.NUT_COL:
                col = gtk.TreeViewColumn(head, renderer, active=n, visible=n)
            else:
                col = gtk.TreeViewColumn(head, renderer, text=n)
            if n == self.VALUE_COL:
                col.set_property('expand',True)
            col.set_resizable(True)
            self.treeview.append_column(col)
        plugin_manager = keyEditorPluggable.get_key_editor_plugin_manager()
        for tvc in plugin_manager.get_treeview_columns(None,
                                                       key_col=2,
                                                       instant_apply=True):
            self.treeview.append_column(tvc)

    def tree_edited (self, renderer, path_string, text, n, head):
        indices = path_string.split(':')
        path = tuple( map(int, indices))
        itr = self.treeModel.get_iter(path)
        curdic,field = self.get_dic_describing_iter(itr)
        value = curdic[field]
        if value == text: return
        if field=='ingkey':
            key = curdic['ingkey']
            if de.getBoolean(label=_('Change all keys "%s" to "%s"?')%(key,text),
                             sublabel=_("You won't be able to undo this action. If there are already ingredients with the key \"%s\", you won't be able to distinguish between those items and the items you are changing now."%text)
                             ):
                self.rd.update_by_criteria(
                    self.rd.ingredients_table,
                    curdic,
                    {'ingkey':text}
                    )
                self.rd.delete_by_criteria(
                    self.rd.keylookup_table,
                    {'ingkey':key}
                    )
        elif field=='item':
            if de.getBoolean(label=_('Change all items "%s" to "%s"?')%(curdic['item'],text),
                             sublabel=_("You won't be able to undo this action. If there are already ingredients with the item \"%s\", you won't be able to distinguish between those items and the items you are changing now.")%text
                             ):
                self.rd.update_by_criteria(
                    self.rd.ingredients_table,
                    curdic,
                    {'item':text}
                    ) 
        elif field=='unit':
            unit = curdic['unit']; key = curdic['ingkey']; item = curdic['item']
            val = de.getRadio(label='Change unit',
                                options=[
                [_('Change _all instances of "%(unit)s" to "%(text)s"')%locals(),1],
                [_('Change "%(unit)s" to "%(text)s" only for _ingredients "%(item)s" with key "%(key)s"')%locals(),2],
                ],
                              default = 2,
                              )
            if val==1:
                self.rd.update_by_criteria(
                    self.rd.ingredients_table,
                    {'unit':unit},
                    {'unit':text},
                    )
            elif val==2:
                self.rd.update_by_criteria(
                    self.rd.ingredients_table,
                    curdic,
                    {'unit':text}
                    )
        elif field=='amount':
            amount = curdic['amount']; unit = curdic['unit']; key = curdic['ingkey']; item = curdic['item']
            try:
                new_amount = convert.frac_to_float(text)
            except:
                de.show_amount_error(text)
                return
            val = de.getRadio(label='Change amount',
                        options=[
                [_('Change _all instances of "%(amount)s" %(unit)s to %(text)s %(unit)s')%locals(),1],
                [_('Change "%(amount)s" %(unit)s to "%(text)s" %(unit)s only _where the ingredient key is %(key)s')%locals(),2],
                [_('Change "%(amount)s" %(unit)s to "%(text)s" %(unit)s only where the ingredient key is %(key)s _and where the item is %(item)s')%locals(),3],
                ],
                default=3,
                              )
            if val == 1:
                cond = {'unit':unit,'amount':amount}
            elif val == 2:
                cond = {'unit':unit,'amount':amount,'ingkey':key}
            elif val == 3:
                cond = curdic
            self.rd.update_by_criteria(
                self.rd.ingredients_table,
                {'unit':unit,'amount':convert.frac_to_float(amount)},
                {'unit':unit,'amount':new_amount}
                )
        else:
            return
        self.treeModel.set_value(itr, n, text)
        return

    def makeTreeModel (self):
        self.treeModel = KeyStore(self.rd,per_page=self.rg.prefs.get('recipes_per_page',12))
        #self.orig_view = self.treeModel.view
        self.treeModel.connect('page-changed',self.model_changed_cb)
        self.treeModel.connect('view-changed',self.model_changed_cb)
        
    def resetTree (self):
        self.search_string = 'NO ONE WOULD EVER SEARCH FOR THIS HACKISH STRING'
        curpage = self.treeModel.page
        self.doSearch()
        self.treeModel.set_page(curpage)

    def doSearch (self):
        """Do the actual searching."""
        last_search = self.search_string
        self.search_string = self.searchEntry.get_text()
        last_by = self.search_by
        self.treeModel.search_by = self.search_by = cb.cb_get_active_text(self.searchByBox)
        last_regexp = self.use_regexp
        self.use_regexp = self.regexpTog.get_active()
        if (self.search_by==last_by and
            self.search_string==last_search and
            self.use_regexp==last_regexp):
            # Don't do anything...
            return
        # RESET THE VIEW IF NEED BE
        if (self.search_string.find(last_search)!=0 or
            self.search_by != last_by or
            self.use_regexp != last_regexp):
            self.treeModel.reset_views()
        if self.search_by == _('item'):
            self.treeModel.limit_on_ingkey(self.search_string,
                                           search_options={'use_regexp':self.use_regexp,}
                                           )
        elif self.search_by == _('key'):
            self.treeModel.limit_on_item(self.search_string,
                                         search_options={'use_regexp':self.use_regexp})
        else: # self.search_by == _('unit'):
            self.treeModel.limit(self.search_string,
                                 'unit',
                                 search_options={'use_regexp':self.use_regexp}
                                 )

    def isearchCB (self, *args):
        if self.searchAsYouTypeToggle.get_active():
            self.window.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.WATCH))
            gobject.idle_add(lambda *args: (self.doSearch() or self.window.window.set_cursor(None)))

    def searchCB (self, *args):
        self.doSearch()

    def search_as_you_typeCB (self, *args):
        if self.searchAsYouTypeToggle.get_active():
            self.searchButton.hide()
        else: self.searchButton.show()

    
    def clearEntriesCB (self, *args):
        for e in self.entries.values(): e.set_text('')

    def get_dic_describing_iter (self, itr):
        """Handed an itr in our tree, return a dictionary describing
        that row and the field described.

        For example, if we get the row

        KEY: Foo

        We return {'ingkey':'Foo'},'ingkey'

        If we get the row

        KEY: Foo
         |=> ITEM: Bar

        We return {'ingkey':'Foo','item':'Bar'},'item'
        """
        field = self.treeModel.get_value(itr, self.FIELD_COL)
        value = self.treeModel.get_value(itr, self.VALUE_COL)
        if field==self.treeModel.KEY:
            return {'ingkey':value},'ingkey'
        elif field==self.treeModel.ITEM:
            key = self.treeModel.get_value(
                self.treeModel.iter_parent(itr),
                self.VALUE_COL
                )
            return {'ingkey':key,'item':value},'item'
        elif field==self.treeModel.UNIT:
            item_itr = self.treeModel.iter_parent(itr)
            key_itr = self.treeModel.iter_parent(item_itr)
            item = self.treeModel.get_value(item_itr,self.VALUE_COL)
            key = self.treeModel.get_value(key_itr,self.VALUE_COL)
            unit = value
            return {'ingkey':key,'item':item,'unit':unit},'unit'
        elif field==self.treeModel.AMOUNT:
            unit_itr = self.treeModel.iter_parent(itr)
            item_itr = self.treeModel.iter_parent(unit_itr)
            key_itr = self.treeModel.iter_parent(item_itr)
            unit = self.treeModel.get_value(unit_itr,self.VALUE_COL)
            item = self.treeModel.get_value(item_itr,self.VALUE_COL)
            key = self.treeModel.get_value(key_itr,self.VALUE_COL)
            amount = value
            return {'ingkey':key,'item':item,'unit':unit,'amount':amount},'amount'
        else:
            print 'WTF! WE SHOULD NEVER LAND HERE!',field,value
            raise Exception("WTF ERROR")
            
    def applyEntriesCB (self, *args):
        newdic = {}
        for k,e in self.entries.items():
            txt = e.get_text()
            if txt:
                if k=='amount':
                    try:
                        newdic[k]=convert.frac_to_float(txt)
                    except:
                        de.show_amount_error(txt)
                        return
                else:
                    newdic[k]=txt
        if not newdic:
            print 'We called applyEntriesCB with no text -- that shouldn\'t be possible'
            return
        mod,rows = self.treeview.get_selection().get_selected_rows()
        if not de.getBoolean(
        label=_("Change all selected rows?"),
        sublabel=(_('This action will not be undoable. Are you that for all %s selected rows, you want to set the following values:')%len(rows)
        + (newdic.has_key('ingkey') and _('\nKey to %s')%newdic['ingkey'] or '')
        + (newdic.has_key('item') and _('\nItem to %s')%newdic['item'] or '')
        + (newdic.has_key('unit') and _('\nUnit to %s')%newdic['unit'] or '')
        + (newdic.has_key('amount') and _('\nAmount to %s')%newdic['amount'] or ''))):
            return
        # Now actually apply our lovely new logic...
        changed_iters = True
        updated_iters = []
        for path in rows:
            itr=self.treeModel.get_iter(path)
            # We check to see if we've updated the parent of our iter,
            # in which case the changes would already be inherited by
            # the current row (i.e. if the tree has been expanded and
            # all rows have been selected).
            parent = mod.iter_parent(itr); already_updated = False
            while parent:
                if parent in updated_iters:
                    already_updated = True
                else:
                    parent = mod.iter_parent(parent)
            if already_updated: continue
            # Now that we're sure we really need to update...
            curdic,field = self.get_dic_describing_iter(itr)
            curkey = self.treeModel.get_value(itr,self.VALUE_COL)
            if not already_updated:
                self.rd.update_by_criteria(
                    self.rd.ingredients_table,
                    curdic,
                    newdic,
                    )
                if curdic.has_key('ingkey') and newdic.has_key('ingkey'):
                    self.rd.delete_by_criteria(
                        self.rd.keylookup_table,
                        {'ingkey':curdic['ingkey']}
                        )
        self.resetTree()
            #self.update_iter(itr,newdic) # A recursive method that
            #                             # will set values for us and
            #                             # our children as necessary
            #updated_iters.append(itr) 

    def editNutritionalInfoCB (self, *args):
        nid = nutritionDruid.NutritionInfoDruid(self.rg.nd, self.rg.prefs)
        mod,rows = self.treeview.get_selection().get_selected_rows()
        keys_to_update = {}
        for path in rows:
            itr = mod.get_iter(path)
            # Climb to the key-level for each selection -- we don't
            # care about anything else.
            parent = mod.iter_parent(itr)
            while parent:
                itr = parent
                parent = mod.iter_parent(itr)
            curkey = mod.get_value(itr,self.VALUE_COL)
            #if mod.get_value(itr,self.NUT_COL):
            #    print "We can't yet edit nutritional information..."
            #else:
            if True:
                keys_to_update[curkey]=[]
                child = mod.iter_children(itr)
                while child:
                    grandchild = mod.iter_children(child)
                    while grandchild:
                        # Grand children are units...
                        unit = mod.get_value(grandchild,self.VALUE_COL)
                        amounts = []
                        greatgrandchild = mod.iter_children(grandchild)
                        while greatgrandchild:
                            amount = mod.get_value(
                                greatgrandchild,
                                self.VALUE_COL
                                )
                            keys_to_update[curkey].append((convert.frac_to_float(amount),unit))
                            greatgrandchild = mod.iter_next(greatgrandchild)
                        grandchild = mod.iter_next(grandchild)
                    child = mod.iter_next(child)
                nid.add_ingredients(keys_to_update.items())
                nid.connect('finish',self.update_nutinfo)
                nid.show()
            
    def update_nutinfo (self, *args):
        self.treeModel.reset_views()

    def update_iter (self, itr, newdic):
        """Update iter and its children based on values in newdic"""
        field = self.treeModel.get_value(itr,self.FIELD_COL)
        if newdic.has_key('item') and field==self.treeModel.ITEM:
            self.treeModel.set_value(itr,self.VALUE_COL,newdic['item'])
        elif newdic.has_key('ingkey') and field==self.treeModel.KEY:
            self.treeModel.set_value(itr,self.VALUE_COL,newdic['ingkey'])
        elif newdic.has_key('unit') and field==self.treeModel.UNIT:
            self.treeModel.set_value(itr,self.VALUE_COL,newdic['unit'])
        elif newdic.has_key('amount') and field==self.treeModel.AMOUNT:
            self.treeModel.set_value(itr,self.VALUE_COL,newdic['amount'])
        c = self.treeModel.iter_children(itr)
        while c:
            self.update_iter(c,newdic)
            c = self.treeModel.iter_next(c)
        
    def entryChangedCB (self, *args):
        """Set sensitivity of apply and clear buttons.

        We are sensitive if we have text to apply or clear"""
        for e in self.entries.values():
            if e.get_text():
                self.applyEntriesButton.set_sensitive(True)
                self.clearEntriesButton.set_sensitive(True)
                return
        self.applyEntriesButton.set_sensitive(False)
        self.clearEntriesButton.set_sensitive(False)

    def reset_tree (self):
        self.treeModel.reset_views()
        self.search_by = None
        self.search_string = ''
        self.doSearch()

    # Paging handlers
    def model_changed_cb (self, model):
        if model.page==0:
            self.prev_button.set_sensitive(False)
            self.first_button.set_sensitive(False)
        else:
            self.prev_button.set_sensitive(True)
            self.first_button.set_sensitive(True)
        if model.get_last_page()==model.page:
            self.next_button.set_sensitive(False)
            self.last_button.set_sensitive(False)
        else:
            self.next_button.set_sensitive(True)
            self.last_button.set_sensitive(True)
        self.update_showing_label()
        
    def update_showing_label (self):
        bottom,top,total = self.treeModel.showing()
        if top >= total and bottom==1:
            lab = ngettext('%s ingredient','%s ingredients',top)%top
        else:
            # Do not translate bottom, top and total -- I use these fancy formatting
            # strings in case your language needs the order changed!
            lab = _('Showing ingredients %(bottom)s to %(top)s of %(total)s'%locals())
        self.showing_label.set_markup('<i>' + lab + '</i>')


class KeyStore (pageable_store.PageableTreeStore,pageable_store.PageableViewStore):
    """A ListStore to show our beautiful keys.
    """
    __gsignals__ = {
        'view-changed':(gobject.SIGNAL_RUN_LAST,
                        gobject.TYPE_NONE,
                        ()),
        }

    KEY = _('Key')+':'
    ITEM = _('Item')+':'
    UNIT = _('Unit')+':'
    AMOUNT = _('Amount')+':'    
    
    columns = ['obj','ingkey','item','count','recipe']#,'ndbno']
    def __init__ (self, rd, per_page=15):
        self.__last_limit_text = ''
        self.rd = rd
        pageable_store.PageableTreeStore.__init__(self,
                                                  [gobject.TYPE_PYOBJECT, # row ref
                                                   str, # column
                                                   str, # value
                                                   int, # count
                                                   str, # recipe
                                                   #int, # nutritional information equivalent
                                                   ],
                                                  per_page=per_page)

    def reset_views (self):
        if self.__last_limit_text:
            txt = self.__last_limit_text
            if hasattr(self,'use_regexp') and self.use_regexp:
                s = {'search':txt,'operator':'REGEXP'}
            else:
                s = {'search':'%'+txt.replace('%','%%')+'%','operator':'LIKE'}
            if self.search_by == _('item'):
                s['column']='item'
            else:
                s['column']='ingkey'
            self.view = self.rd.get_ingkeys_with_count(s)
        else:
            self.view = self.rd.get_ingkeys_with_count()
        for n in range(self._get_length_()):
            parent = (n,)
            path = parent
            try:
                itr = self.get_iter(path)
            except ValueError:
                return
            self.emit('row-changed',path,itr)
            child = self.iter_children(itr)
            while child:
                path = self.get_path(child)
                self.emit('row-changed',path,child)
                child = self.iter_next(child)
        #self.keylookup_table = self.rd.filter(self.rd.keylookup_table,lambda row: row.item)
        # Limit ingredients_table to ingkeys only, then select the unique values of that, then
        # filter ourselves to values that have keys
        #self.view = self.rd.filter(self.rd.ingredients_table.project(self.rd.ingredients_table.ingkey).unique(),
        #                           lambda foo: foo.ingkey)

    def _setup_parent_ (self, *args, **kwargs):
        self.reset_views()

    def limit_on_ingkey (self, txt, search_options={}):
        self.limit(txt,self.rd.ingredients_table+'.ingkey',search_options)

    def limit_on_item (self, txt, search_options={}):
        self.limit(txt,'item',search_options)

    def limit (self, txt, column='ingkey', search_options={}):
        if txt == self.__last_limit_text:
            return
        else:
            self.__last_limit_text = txt
        if not txt: self.reset_views()
        if search_options['use_regexp']:
            s = {'search':txt,'operator':'REGEXP'}
        else:
            s = {'search':'%'+txt.replace('%','%%')+'%','operator':'LIKE'}
        s['column']=column
        self.change_view(self.rd.get_ingkeys_with_count(s))
      
    def _get_length_ (self):
        return len(self.view)

    get_last_page = pageable_store.PageableViewStore.get_last_page

    def _get_slice_ (self, bottom, top):
        return [self.get_row(i) for i in self.view[bottom:top]]

    def _get_item_ (self, path):
        return self.get_row(self.view[indx])
        
    def get_row (self, row):
        return [row,
                self.KEY,
                row.ingkey,
                # avoidable slowdown (look here if code seems sluggish)
                row.count,
                None,
                #row.ndbno or 0,
                ]

    def _get_children_ (self,itr):
        ret = []
        field = self.get_value(itr,1)
        value = self.get_value(itr,2)
        if field==self.KEY:
            ingkey = value
            for item in self.rd.get_unique_values('item',self.rd.ingredients_table,ingkey=ingkey):
                ret.append([None,
                            self.ITEM,
                            item,
                            self.rd.fetch_len(self.rd.ingredients_table,ingkey=ingkey,item=item),
                            self.get_recs(ingkey,item),
                            #0
                            ])
        elif field==self.ITEM:
            ingkey = self.get_value(self.iter_parent(itr),2)
            item = value
            for unit in self.rd.get_unique_values('unit',self.rd.ingredients_table,ingkey=ingkey,item=item):
                ret.append([None,
                            self.UNIT,
                            unit,
                            self.rd.fetch_len(self.rd.ingredients_table,ingkey=ingkey,item=item,unit=unit),
                            None,
                            ])
            if not ret:
                ret.append([None,
                            self.UNIT,
                            '',
                            self.get_value(self.iter_parent(itr),3),
                            None,
                            ])                
        elif field==self.UNIT:
            item = self.get_value(self.iter_parent(itr),2)
            ingkey = self.get_value(self.iter_parent(
                self.iter_parent(itr)),2)
            unit = self.get_value(itr,2)
            amounts = []
            for i in self.rd.fetch_all(self.rd.ingredients_table,ingkey=ingkey,item=item,unit=unit):
                astring = self.rd.get_amount_as_string(i)
                if astring in amounts: continue
                ret.append([None,
                            self.AMOUNT,
                            astring,
                            (i.rangeamount
                             and self.rd.fetch_len(self.rd.ingredients_table,
                                                   ingkey=ingkey,item=item,
                                                   unit=unit,
                                                   amount=i.amount,rangeamount=i.rangeamount)
                             or  self.rd.fetch_len(self.rd.ingredients_table,
                                                   ingkey=ingkey,item=item,
                                                   unit=unit,
                                                   amount=i.amount)),
                            None,
                            ])
                amounts.append(astring)
            if not ret:
                ret.append([None,
                            self.AMOUNT,
                            '',
                            self.get_value(self.iter_parent(itr),3),
                            None,
                            ])
            
        return ret
        #row = row[0]
        #return [[subrow,
        #         row.ingkey,
        #         subrow.item,
        #         subrow.count,
        #         self.get_recs(row.ingkey,subrow.item)] for subrow in row.grouped]


    def get_recs (self, key, item):
        """Return a string with a list of recipes containing an ingredient with key and item"""
        recs = [i.recipe_id for i in self.rd.fetch_all(self.rd.ingredients_table,ingkey=key,item=item)]
        titles = []
        looked_at = []
        for r_id in recs:
            if r_id in looked_at: continue
            rec = self.rd.get_rec(r_id)
            if rec:
                titles.append(rec.title)
        return ", ".join(titles)

if __name__ == '__main__':
    import recipeManager
    rm = recipeManager.default_rec_manager()
    import sys
    sys.path.append(os.path.realpath('../tests'))
    import testExtras
    rg = testExtras.FakeRecGui(rm)
    ke=KeyEditor(rm,rg)
    ke.window.connect('delete-event',gtk.main_quit)
    gtk.main()

########NEW FILE########
__FILENAME__ = keyEditorPluggable
# This library provides a pluggable that lets plugins that *use* our
# key editor to provide extra information based on the ingredient
# key. This will be used to show info in both the key editor and
# recipe card view and possibly to allow editing etc.

from gourmet.plugin_loader import Pluggable
from gourmet.plugin import PluginPlugin
from gourmet import gdebug

# Here's our template -- those implementing will have to take this as
# boilerplate code rather than subclassing it, since it's not possible
# to reliably access one plugin's module from another.

# Begin boilerplate...
#
# For a fuller example, see shopping_associations
class KeyEditorPlugin (PluginPlugin):

    target_pluggable = 'KeyEditorPlugin'

    selected_ingkeys = []

    def setup_treeview_column (self, ike, key_col, instant_apply=False):
        '''Set up a treeview column to display your data.

        The key_col is the column in the treemodel which will contain
        your data in the model. It\'s your responsibility to get
        whatever other data you need yourself.

        If you make this editable, it\'s up to you to apply the
        changes as well to the database. If instant_apply is True,
        then apply them instantly; if False, apply them when this
        class\'s save method is called.
        '''
        raise NotImplementedError

    def save (self):
        '''Save any data the user has entered in your treeview column.
        '''
        pass

    def offers_edit_widget (self):
        '''Return True if this plugin provides an edit button for
        editing data (if you need more than an editable cellrenderer
        to let users edit your data, or would like to act on multiple
        rows.
        '''
        return False

    def setup_edit_widget (self):
        '''Return an edit button to let users edit your data.
        '''
        raise NotImplementedError

    def selection_changed (self, ingkeys):
        '''Selected ingkeys have changed -- currently ingkeys are
        selected (and should be acted on by our edit_widget
        '''
        self.selected_ingkeys = ingkeys

# End boilerplate

class KeyEditorPluginManager (Pluggable):

    '''Manage plugins that provide users the ability to edit extra
    associations, such as nutritional information, shopping list
    categories, etc.'''

    title = 'Title of Whatever we Do'
    targets = ['KeyEditorPlugin']

    __single = None

    def __init__ (self):
        if not KeyEditorPluginManager.__single:
            KeyEditorPluginManager.__single = self
        else:
            raise KeyEditorPluginManager.__single
        Pluggable.__init__(self,[PluginPlugin])

    def get_treeview_columns (self, ike, key_col, instant_apply=False):
        return [p.setup_treeview_column(ike, key_col,instant_apply) for p in self.plugins]

    def get_edit_buttons (self, ike):
        buttons = []
        for p in self.plugins:
            if p.offer_edit_button():
                try:
                    buttons.append(p.setup_edit_button())
                except:
                    'Trouble initializing edit button for plugin',p
                    import traceback; traceback.print_exc()
        return buttons

def get_key_editor_plugin_manager ():
    try:
        return KeyEditorPluginManager()
    except KeyEditorPluginManager, kepm:
        return kepm

########NEW FILE########
__FILENAME__ = keyEditorPlugin
import gtk
import gourmet.plugin
import gourmet.GourmetRecipeManager
import keyEditor
from gettext import gettext as _

class KeyEditorPlugin (gourmet.plugin.ToolPlugin):
    menu_items = '''
        <placeholder name="DataTool">
        <menuitem action="KeyEditor"/>
        </placeholder>
    '''

    def setup_action_groups (self):
        self.action_group = gtk.ActionGroup('KeyEditorActionGroup')        
        self.action_group.add_actions([
            ('KeyEditor',None,_('Ingredient _Key Editor'),
             None,_('Edit ingredient keys en masse'),self.show_key_editor)
            ])
        self.action_groups.append(self.action_group)

    def show_key_editor (self, *args):
        gourmet_app = gourmet.GourmetRecipeManager.get_application()
        ke = keyEditor.KeyEditor(rd=gourmet_app.rd,rg=gourmet_app)

########NEW FILE########
__FILENAME__ = recipeEditorPlugin
from gourmet.plugin import RecEditorModule, RecEditorPlugin, IngredientControllerPlugin
from gourmet.plugin_loader import PRE,POST
import gtk, gobject, pango
from gourmet.reccard import IngredientEditorModule, RecRef
import keyEditorPluggable
from gettext import gettext as _

ING = 0
ITM = 1
KEY = 2

class IngredientKeyEditor (RecEditorModule):

    name = 'keyeditor'
    label = _('Ingredient Keys')
    ui_string = '''
    <menubar name="RecipeEditorMenuBar">
      <menu name="Edit" action="Edit">
        <placeholder name="EditActions">
          <menuitem name="GuessKeys" action="GuessKeys"/>
          <menuitem name="EditAssociations" action="EditAssociations"/>          
        </placeholder>
      </menu>
    </menubar>
    <toolbar name="RecipeEditorEditToolBar">
      <toolitem name="GuessKeys" action="GuessKeys"/>
      <toolitem name="EditAssociations" action="EditAssociations"/>                
    </toolbar>
    '''

    def setup (self):
        pass

    def setup_main_interface (self):
        self.main = gtk.VBox()
        l = gtk.Label()
        l.set_markup('''<b>%s</b>\n<i>%s</i>'''%(
            _('Ingredient Keys'),
            _('Ingredient Keys are normalized ingredient names used for shopping lists and for calculations.')
            )
                     )
        self.main.pack_start(l,expand=False,fill=False)
        sw = gtk.ScrolledWindow(); sw.set_policy(gtk.POLICY_AUTOMATIC,gtk.POLICY_AUTOMATIC)
        self.main.pack_start(sw)
        self.extra_widget_table = gtk.Table()
        ew_index = 1
        self.main.pack_start(self.extra_widget_table,expand=False,fill=False)
        self.tv = gtk.TreeView()
        self.tv.get_selection().set_mode(gtk.SELECTION_MULTIPLE)
        self.tv.get_selection().connect('changed',
                                        self.treeselection_changed_cb)
        self.setup_model()
        self.setup_tree()
        self.tv.set_model(self.model)
        sw.add(self.tv)
        self.main.show_all()
        self.update_from_database()
        ingredientEditorModule = filter(lambda m: isinstance(m,IngredientEditorModule), self.re.modules)[0]
        ingredientEditorModule.connect('saved',lambda *args: self.update_from_database())
        ingredientEditorModule.connect('toggle-edited', self.update_from_ingredient_editor_cb)
        self.setup_action_groups()
        # Set up extra widgets
        plugin_manager = keyEditorPluggable.get_key_editor_plugin_manager()
        apply_button = gtk.Button(stock=gtk.STOCK_APPLY)
        for plugin in plugin_manager.plugins:
            if plugin.offers_edit_widget():
                title_label = gtk.Label(plugin.title)
                widget = plugin.setup_edit_widget()
                self.extra_widget_table.attach(title_label,0,1,ew_index,ew_index+1)
                self.extra_widget_table.attach(widget,1,2,ew_index,ew_index+1)
                title_label.show(); widget.show()
                apply_button.connect('clicked',lambda *args: plugin.apply_widget_val())
                ew_index += 1
        if ew_index > 1:
            self.extra_widget_table.attach(apply_button,1,2,ew_index,ew_index+1)
            apply_button.show()
            self.extra_widget_table.hide()
            self.edit_associations_action.set_visible(True)
            apply_button.connect('clicked',
                                 lambda *args: self.tv.queue_draw())
            
    def setup_action_groups(self):
        self.keyEditorActionGroup = gtk.ActionGroup('RecKeyEditorActionGroup')
        self.keyEditorActionGroup.add_actions([
            ('GuessKeys',None,_('Guess keys'),
             None,_('Guess best values for all ingredient keys based on values already in your database'),
             self.guess_keys_cb),
            ])
        self.keyEditorActionGroup.add_toggle_actions([
            ('EditAssociations',None,_('Edit Key Associations'),
             None,_('Edit associations with key and other attributes in database'),
             self.edit_associations_cb, False),
            ])
        self.edit_associations_action = self.keyEditorActionGroup.get_action('EditAssociations')
        self.edit_associations_action.set_visible(False)
        self.action_groups.append(self.keyEditorActionGroup)
        
    def setup_tree (self):
        item_renderer = gtk.CellRendererText();
        item_renderer.set_property('editable',True)
        item_col = gtk.TreeViewColumn(_('Item'),item_renderer,text=1)
        item_col.set_expand(True)
        key_renderer = gtk.CellRendererCombo()
        key_renderer.set_property('editable',True)
        key_renderer.connect('editing-started',self.start_keyedit_cb)
        key_renderer.connect('edited',self.key_edited_cb)
        key_renderer.set_property('mode',gtk.CELL_RENDERER_MODE_EDITABLE)
        key_renderer.set_property('sensitive',True)
        key_col = gtk.TreeViewColumn(_('Key'),key_renderer,text=2)
        key_col.set_expand(True)
        self.renderers = [key_renderer,item_renderer]
        self.tv.append_column(item_col)
        self.tv.append_column(key_col)
        for r in  key_renderer,item_renderer:
            r.set_property('wrap-mode',pango.WRAP_WORD)
            r.set_property('wrap-width',200)
        self.tv.connect('check-resize',self.resize_event_cb)
        self.tv.connect('size-allocate',self.tv_size_allocate_cb)
        plugin_manager = keyEditorPluggable.get_key_editor_plugin_manager()
        for tvc in plugin_manager.get_treeview_columns(self,
                                                       key_col=2,
                                                       instant_apply=False):
            self.tv.append_column(tvc)


    def auto_wrap_columns (self):
        for col in self.tv.get_columns():
            renderers = col.get_cell_renderers()
            for r in renderers:
                if isinstance(r,gtk.CellRendererText):
                    r.set_property('wrap-mode',pango.WRAP_WORD)
                    r.set_property('wrap-width',col.get_width())

    def resize_event_cb (self, widget, event):
        self.auto_wrap_columns()
        
    def tv_size_allocate_cb (self, widget, allocation):
        self.auto_wrap_columns()
        
    def start_keyedit_cb (self, renderer, cbe, path_string):
        indices = path_string.split(':')
        path = tuple( map(int, indices))
        item = self.model[path][ITM]
        mod = gtk.ListStore(str)
        for key in self.rg.rd.key_search(item):
            mod.append((key,))
        renderer.set_property('model',mod)
        renderer.set_property('text-column',0)
        if isinstance(cbe,gtk.ComboBoxEntry):
            entry = cbe.child
            completion = gtk.EntryCompletion()
            completion.set_model(mod); completion.set_text_column(0)
            entry.set_completion(completion)
        #mod = renderer.get_property

    def key_edited_cb (self,cell, path, new_text):
        oldkey = self.model[path][2]
        if oldkey != new_text:
            self.emit('toggle-edited',True)
        self.model[path][2] = new_text

    def get_key_for_object (self, obj):
        for row in self.model:
            if row[0] == obj:
                return row[2]
        return False

    def treeselection_changed_cb (self, ts):
        keys = []
        def do_foreach (tm, p, i):
            keys.append(tm[p][2])
        ts.selected_foreach(do_foreach)
        plugin_manager = keyEditorPluggable.get_key_editor_plugin_manager()
        for p in plugin_manager.plugins:
            p.selection_changed(keys)
        
    def setup_model (self):
        self.model = gtk.ListStore(gobject.TYPE_PYOBJECT,str,str)
            
    def update_from_database (self):
        ings = self.rg.rd.get_ings(self.current_rec)
        self.setup_model()
        for i in ings:
            if i.refid:
                continue
            self.model.append((i,i.item,i.ingkey))
        self.tv.set_model(self.model)
        self.edited = False

    # Callbacks
    def guess_keys_cb (self, *args):
        changed = False
        for row in self.model:
            item = row[1]
            row[2] = self.rg.rd.km.get_key(item,1)
            changed = True
        if changed: self.edited = True

    def edit_associations_cb (self, action, *args):
        if action.get_active():
            self.extra_widget_table.show()
        else:
            self.extra_widget_table.hide()
        
    def update_from_ingredient_editor_cb (self, ie, edited):
        #if not edited:
        #    self.update_from_database()
        if edited:
            # Update based on current ingredients...
            ITM = ie.ingtree_ui.ingController.ITEM_COL
            def process_row (row):
                obj = row[0]
                item = row[ITM]
                already_there = False
                if isinstance(obj,RecRef):
                    return
                if item == None: # if this is a group..
                    for child in row.iterchildren():
                        process_row(child)
                    return
                for myrow in self.model:
                    if obj==myrow[0]:
                        already_there = True
                        if item != myrow[1]:
                            myrow[1] = item
                if not already_there:
                    if hasattr(row[0],'ingkey'):
                        ingkey = row[0].ingkey
                    else:
                        ingkey = self.rg.rd.km.get_key(item.split(';')[0],1.0)
                    self.model.append((row[0],item,ingkey))
            for row in ie.ingtree_ui.ingController.imodel:
                process_row(row)
                
    def save (self, recdic):
        # save...
        plugin_manager = keyEditorPluggable.get_key_editor_plugin_manager()
        for p in plugin_manager.plugins:
            p.save()
        return recdic

class IngredientKeyEditorPlugin (RecEditorPlugin):

    moduleKlass = IngredientKeyEditor
    position = 2

class KeyEditorIngredientControllerPlugin (IngredientControllerPlugin):

    def activate (self, pluggable):
        pluggable.add_hook(POST,'get_extra_ingredient_attributes',
                           self.get_extra_ingattributes_post_hook)

    def get_extra_ingattributes_post_hook (self, retval, ic, ing_obj, ingdict):
        recipe_editor = ic.ingredient_editor_module.re
        key_editor = filter(lambda m: isinstance(m,IngredientKeyEditor), recipe_editor.modules)[0]
        ingkey = key_editor.get_key_for_object(ing_obj)
        if ingkey:
            ingdict['ingkey'] = ingkey
        return ingdict

########NEW FILE########
__FILENAME__ = shoppingSaverPlugin
from gourmet.plugin import ShoppingListPlugin
import gtk
import gourmet.recipeManager, gourmet.GourmetRecipeManager, time
from gettext import gettext as _

class ShoppingListSaver (ShoppingListPlugin):

    ui_string = '''<ui>
    <menubar name="ShoppingListMenuBar">
      <menu name="File" action="File">
        <placeholder name="ExtraFileStuff">
          <menuitem action="SaveAsRecipe"/>
        </placeholder>
      </menu>
    </menubar>
    <toolbar name="ShoppingListTopToolBar">
      <separator/>
      <toolitem action="SaveAsRecipe"/>
    </toolbar>
    </ui>
    '''
    name = 'shopping_list_saver'
    label = _('Shopping List Saver')

    def setup_action_groups (self):
        self.shoppingListSaverActionGroup = gtk.ActionGroup('ShoppingListSaverActionGroup')
        self.shoppingListSaverActionGroup.add_actions([
            ('SaveAsRecipe',# name
             gtk.STOCK_SAVE_AS,# stock
             _('Save List as Recipe'), # text
             _('<Ctrl><Shift>S'), # key-command
             _('Save current shopping list as a recipe for future use'), # tooltip
             self.save_as_recipe# callback
             ),
            ])
        self.action_groups.append(self.shoppingListSaverActionGroup)

    def save_as_recipe (self, *args):
        sg = self.pluggable
        rr = sg.recs
        rd = gourmet.recipeManager.get_recipe_manager()
        rg = gourmet.GourmetRecipeManager.get_application()
        #print rr
        rec = rd.add_rec(dict(title=_('Menu for %s')%time.strftime('%x'),
                         category=_('Menu')))
        for recipe,mult in rr.values():
            # Add all recipes...
            rd.add_ing({
                'amount':mult,
                'unit':'Recipe',
                'refid':recipe.id,
                'recipe_id':rec.id,
                'item':recipe.title,
                })
        for amt,unit,item in sg.extras:
            # Add all extras...
            rd.add_ing({
                'amount':amt,
                'unit':unit,
                'item':item,
                'ingkey':item,
                })
        rg.open_rec_card(rec)

            
            
                   
                   

########NEW FILE########
__FILENAME__ = databaseGrabber
import sys
import urllib, zipfile, tempfile, os.path, re, string
from gettext import gettext as _
from parser_data import ABBREVS, ABBREVS_STRT, FOOD_GROUPS, NUTRITION_FIELDS, WEIGHT_FIELDS
from gourmet.gdebug import TimeAction
expander_regexp = None

def compile_expander_regexp ():    
    regexp = "(?<!\w)("
    regexp += string.join(ABBREVS.keys(),"|")
    regexp += ")(?!\w)"
    return re.compile(regexp)

def expand_abbrevs ( line ):
    """Expand standard abbreviations."""
    global expander_regexp
    for k,v in ABBREVS_STRT.items():
        line = line.replace(k,v)
    if not expander_regexp:
        expander_regexp=compile_expander_regexp()
    ematch = expander_regexp.search(line)
    while ematch:
        matchstr=ematch.groups()[0]
        replace=ABBREVS[str(matchstr)]
        line = line[0:ematch.start()] + replace + line[ematch.end():]
        ematch = expander_regexp.search(line)
    return line

class DatabaseGrabber:
    USDA_ZIP_URL = "http://www.nal.usda.gov/fnic/foodcomp/Data/SR17/dnload/sr17abbr.zip"
    ABBREV_FILE_NAME = "ABBREV.txt"
    DESC_FILE_NAME = "FOOD_DES.txt"
    WEIGHT_FILE_NAME = "WEIGHT.txt"

    def __init__ (self,
                  db,
                  show_progress=None):
        self.show_progress=show_progress
        self.db = db
        
    def get_zip_file (self):
        if hasattr(self,'zipfile'):
            return self.zipfile
        else:
            ofi = urllib.urlopen(self.USDA_ZIP_URL)
            tofi = tempfile.TemporaryFile()
            tofi.write(ofi.read())
            tofi.seek(0)
            self.zipfile = zipfile.ZipFile(tofi,'r')
            return self.zipfile
        
    def get_file_from_url (self, filename):
        zf = self.get_zip_file()
        tofi2 = tempfile.TemporaryFile()
        tofi2.write(zf.read(filename))
        tofi2.seek(0)
        return tofi2

    def get_abbrev (self, filename=None):
        if filename:
            afi = open(filename,'r')
        else:
            afi = self.get_file_from_url(self.ABBREV_FILE_NAME)
        self.parse_abbrevfile(afi)
        afi.close()
        del self.foodgroups_by_ndbno

    def get_groups (self, filename=None):
        self.group_dict = {}
        if filename:
            afi = open(filename,'r')
        else:
            afi = self.get_file_from_url(self.DESC_FILE_NAME)
        self.foodgroups_by_ndbno = {}
        for l in afi.readlines():
            flds = l.split('^')
            ndbno = int(flds[0].strip('~'))
            grpno = int(flds[1].strip('~'))
            self.foodgroups_by_ndbno[ndbno] = grpno

    def get_weight (self, filename=None):
        if filename:
            wfi = open(filename,'r')
        else:
            wfi = self.get_file_from_url(self.WEIGHT_FILE_NAME)
        self.parse_weightfile(wfi)
        wfi.close()

    def grab_data (self, directory=None):
        self.db.changed = True
        self.get_groups((isinstance(directory,str)
                         and
                         os.path.join(directory,self.DESC_FILE_NAME)))
        self.get_abbrev((isinstance(directory,str)
                         and
                         os.path.join(directory,self.ABBREV_FILE_NAME)))
        self.get_weight((isinstance(directory,str)
                         and
                         os.path.join(directory,self.WEIGHT_FILE_NAME)))

    def parse_line (self, line, field_defs, split_on='^'):
        """Handed a line and field definitions, return a dictionary of
        the line parsed.

        The line is a line with fields split on '^'

        field_defs is a list of entries for each field in our data.
        [(long_name,short_name,type),(long_name,short_name,type),...]

        Our dictionary will be in the form:

        {short_name : value,
         short_name : value,
         ...}
        """
        d = {}
        fields = line.split("^")
        for n,fl in enumerate(fields):
            try:
                lname,sname,typ = field_defs[n]
            except IndexError:
                print n,fields[n],'has no definition in ',field_defs,len(field_defs)
                print 'Ignoring problem and forging ahead!'
                break
            if fl and fl[0]=='~' and fl[-1]=='~':
                d[sname]=fl[1:-1]
            if typ=='float':
                try:
                    d[sname]=float(d.get(sname,fl))
                except:
                    d[sname]=None
            elif typ=='int':
                try:
                    d[sname]=int(float(d.get(sname,fl)))
                except:
                    if d.get(sname,fl):
                        print d.get(sname,fl),'is not an integer'
                        raise
                    # If it's nothing, we don't bother...
                    if d.has_key(sname): del d[sname]                    
        return d

    def parse_abbrevfile (self, abbrevfile):
        if self.show_progress:
            self.show_progress(float(0.03),_('Parsing nutritional data...'))
        self.datafile = tempfile.TemporaryFile()
        ll=abbrevfile.readlines()
        tot=len(ll)
        n = 0
        for n,l in enumerate(ll):
            l = unicode(l.decode('latin_1'))
            tline=TimeAction('1 line iteration',2)
            t=TimeAction('split fields',2)
            d = self.parse_line(l,NUTRITION_FIELDS)
            fields = l.split("^")
            d['desc']=expand_abbrevs(d['desc'])
            d['foodgroup']=FOOD_GROUPS[
                self.foodgroups_by_ndbno[d['ndbno']]
                ]
            t.end()
            if self.show_progress and n % 50 == 0:
                self.show_progress(float(n)/tot,_('Reading nutritional data: imported %s of %s entries.')%(n,tot))
            t = TimeAction('append to db',3)
            try:
                self.db.do_add_fast(self.db.nutrition_table,d)
            except:
                try:
                    SQL = 'UPDATE ' + self.db.nutrition_table.name + ' SET '
                    args = d.copy(); del args['ndbno']
                    SQL += ', '.join('%s = ?'%k for k in args)
                    SQL += ' WHERE ndbno = %s'%d['ndbno']
                    #if d['ndbno']==1123:
                    #    print SQL,args.values()
                    self.db.extra_connection.execute(SQL,args.values())
                except:
                    print 'Error appending to nutrition_table',d
                    print 'Tried modifying table -- that failed too!'
                    raise
            t.end()                        
            tline.end()
        self.db.commit_fast_adds()

    def parse_weightfile (self, weightfile):
        if self.show_progress:
            self.show_progress(float(0.03),_('Parsing weight data...'))
        ll=weightfile.readlines()
        tot=len(ll)
        n=0
        for n,l in enumerate(ll):
            l = unicode(l.decode('latin_1'))
            if self.show_progress and n % 50 == 0:
                self.show_progress(
                    float(n)/tot,
                    _('Reading weight data for nutritional items: imported %s of %s entries')%(n,tot)
                    )
            d = self.parse_line(l,WEIGHT_FIELDS)
            if d.has_key('stdev'): del d['stdev']
            try:
                self.db.do_add_fast(self.db.usda_weights_table,d)
            except:
                print "Error appending ",d,"to usda_weights_table"
                raise
        self.db.commit_fast_adds()
            


if __name__ == '__main__':
    tot_prog = 0
    def show_prog (perc, msg):
        perc = perc * 100
        if perc - tot_prog: print "|" * int(perc - tot_prog)
    print 'getting our recipe database'
    import gourmet.recipeManager
    db = gourmet.recipeManager.RecipeManager(**gourmet.recipeManager.dbargs)
    print 'getting our grabber ready'
    grabber = DatabaseGrabber(db,show_prog)
    print 'grabbing recipes!'
    grabber.grab_data('/home/tom/Projects/grm/data/')
    #grabber.parse_weightfile(open('/home/tom/Projects/grm/data/WEIGHT.txt','r'))
    #grabber.get_weight('/home/tom/Projects/nutritional_data/WEIGHT.txt')    
    

########NEW FILE########
__FILENAME__ = data_plugin
import sqlalchemy, sqlalchemy.orm
from sqlalchemy import Integer, Binary, String, Float, Boolean, Numeric, Table, Column, ForeignKey, Text
from sqlalchemy.sql import and_, or_
import gourmet.backends.db
from gourmet.plugin import DatabasePlugin
import parser_data

class NutritionDataPlugin (DatabasePlugin):

    name = 'nutritondata'
    version = 4

    def setup_usda_weights_table (self):
        self.db.usda_weights_table = Table('usda_weights',self.db.metadata,
                                        Column('id',Integer(),primary_key=True),
                                        *[Column(name,gourmet.backends.db.map_type_to_sqlalchemy(typ),**{})
                                          for lname,name,typ in parser_data.WEIGHT_FIELDS]
                                        )
        class UsdaWeight (object):
            pass
        self.db._setup_object_for_table(self.db.usda_weights_table, UsdaWeight)
    
    def setup_nutritionconversions_table (self):
        self.db.nutritionconversions_table = Table('nutritionconversions',self.db.metadata,
                                                Column('id',Integer(),primary_key=True),
                                                Column('ingkey',String(length=255),**{}),
                                                Column('unit',String(length=255),**{}), 
                                                Column('factor',Float(),**{}), # Factor is the amount we multiply
                                                # from unit to get 100 grams
                                                ) # NUTRITION_CONVERSIONS
        class NutritionConversion (object): pass
        self.db._setup_object_for_table(self.db.nutritionconversions_table, NutritionConversion)

    def setup_nutritionaliases_table (self):
        self.db.nutritionaliases_table = Table('nutritionaliases',self.db.metadata,
                                            Column('id',Integer(),primary_key=True),
                                            Column('ingkey',Text()),
                                            Column('ndbno',Integer,ForeignKey('nutrition.ndbno')),
                                            Column('density_equivalent',Text(length=20)))
        class NutritionAlias (object): pass
        self.db._setup_object_for_table(self.db.nutritionaliases_table, NutritionAlias)

    def do_add_nutrition (self, d):
        return self.db.do_add_and_return_item(self.db.nutrition_table,d,id_prop='ndbno')

    def create_tables (self, *args):
        #print 'nutritional_information.data_plugin.create_tables()'
        cols = [Column(name,gourmet.backends.db.map_type_to_sqlalchemy(typ),**(name=='ndbno' and {'primary_key':True} or {}))
                 for lname,name,typ in parser_data.NUTRITION_FIELDS
                 ] + [Column('foodgroup',Text(),**{})]
        #print 'nutrition cols:',cols
        self.db.nutrition_table = Table('nutrition',self.db.metadata,
                                     *cols
                                     )
        class Nutrition (object):
            pass
        self.db._setup_object_for_table(self.db.nutrition_table, Nutrition)
        
        self.setup_usda_weights_table()
        self.setup_nutritionaliases_table()
        self.setup_nutritionconversions_table()
        self.db.do_add_nutrition = self.do_add_nutrition

    def update_version (self, gourmet_stored, plugin_stored, gourmet_current, plugin_current):
        if ((gourmet_stored[0] == 0 and gourmet_stored[1] < 14)
            or
            (plugin_stored < 1)):
            print 'RECREATE USDA WEIGHTS TABLE'
            self.db.alter_table('usda_weights',self.setup_usda_weights_table,{},
                             [name for lname,name,typ in parser_data.WEIGHT_FIELDS])
            self.db.alter_table('nutritionconversions',self.setup_nutritionconversions_table,{},
                             ['ingkey','unit','factor'])
        if plugin_stored == '1':
            # Add choline
            self.db.add_column_to_table(self.db.nutrition_table,
                                        ('choline',
                                         gourmet.backends.db.map_type_to_sqlalchemy('float'),
                                         {})
                                        )
        if plugin_stored in ['1','2']:
            # Add a primary key Integer column named id.
            self.db.alter_table('nutritionaliases',self.setup_nutritionaliases_table,
                 {},['ingkey','ndbno','density_equivalent'])

        if plugin_stored in ['1','2','3']:
            # Set the length parameter of the ingkey and unit Strings to 255.
            self.db.alter_table('nutritionconversions',self.setup_nutritionconversions_table,
                 {},['id','factor'])

########NEW FILE########
__FILENAME__ = enter_nutritional_defaults
from gourmet.defaults import lang as defaults
import gtk
ingredients_to_check = defaults.keydic.keys()
from nutritionDruid import NutritionInfoDruid
from nutrition import NutritionData
import gourmet.convert
from gourmet.recipeManager import RecipeManager,dbargs

# This is intended to be run as a simple script to get nutritional
# equivalents which can then be copied into DEFAULTS for your locale.

rd = RecipeManager(**dbargs)

import nutritionGrabberGui

try:
    nutritionGrabberGui.check_for_db(rd)
except nutritionGrabberGui.Terminated:
    pass

c = gourmet.convert.get_converter()
nd = NutritionData(rd,c)
nid = NutritionInfoDruid(nd,{})
nid.add_ingredients([(k,[(1,'')]) for k in ingredients_to_check])
def quit (*args):
        rd.save()
        nid.ui.get_object('window1').hide()
        gtk.main_quit()
nid.ui.get_object('window1').connect('delete-event',quit)
nid.connect('finish',quit)
nid.show()
gtk.main()

rd.changed=True
rd.save()

ofi = '/tmp/locale_specific_nutritional_info.txt'
print 'Writing data to ',ofi
outfi = file(ofi,'w')
outfi.write('{')
for k in ingredients_to_check:
    ndbno = nd.get_ndbno(k)
    if ndbno:
        outfi.write('"%s":(%s,['%(k,ndbno))
        for conv in nd.db.nutritionconversions_table.select(ingkey=k):
            outfi.write('("%s",%s),'%(conv.unit,conv.factor))
        outfi.write(']),\n')
    else:
        print 'No information for ',k
outfi.write('}')
outfi.close()


########NEW FILE########
__FILENAME__ = export_plugin
from gourmet.plugin import BaseExporterPlugin
from gourmet.recipeManager import default_rec_manager
import gourmet.defaults
from gourmet.prefs import get_prefs
from nutritionLabel import MAIN_NUT_LAYOUT, MAJOR, MINOR, TINY, SEP, SHOW_PERCENT, DONT_SHOW_PERCENT, SEP
from gettext import gettext as _
from xml.sax.saxutils import escape

class NutritionBaseExporterPlugin (BaseExporterPlugin):

    def __init__ (self):
        BaseExporterPlugin.__init__(self)
        if get_prefs().get('include_nutritional_info_in_export',True):
            self.add_field('Nutritional Information',
                           self.get_nutritional_info_as_text_blob,
                           self.TEXT)

    def get_nutritional_info_as_text_blob (self, rec):
        if not get_prefs().get('include_nutritional_info_in_export',True): return None
        txt = ''
        footnotes = ''
        rd = default_rec_manager()
        nd = rd.nd
        nutinfo = nd.get_nutinfo_for_inglist(rd.get_ings(rec),rd)
        ings = rd.get_ings(rec)
        vapor = nutinfo._get_vapor()
        if len(vapor)==len(ings): return None
        if len(vapor) >= 1 and not get_prefs().get('include_partial_nutritional_info',False):
            return None
        if rec.yields and rec.yield_unit:
            singular_unit = gourmet.defaults.get_pluralized_form(rec.yield_unit,1)
            txt += '<i>%s</i>'%((rec.yields and _('Nutritional information reflects amount per %s.'%singular_unit))
                                or
                                _('Nutritional information reflects amounts for entire recipe'))

        if vapor:
            txt = txt + '*'
            footnotes = '\n*' + _('Nutritional information is missing for %s ingredients: %s')%(
                len(vapor),
                ', '.join([escape(nv.__ingobject__.item) for nv in vapor])
                )
        for itm in MAIN_NUT_LAYOUT:
            if itm == SEP:
                # We don't have any nice way of outputting separator
                # lines in our export
                continue
            else:
                label,typ,name,properties,show_percent,unit = itm
                if typ==MAJOR:
                    itm_text = '<b>'+label+'</b>'
                else:
                    itm_text = label
                if unit:
                    itm_text += ' (%s)'%unit
                if type(properties) == list:
                    amts = [getattr(nutinfo,att) for att in properties]
                    amt = sum(amts)
                else:
                    amt = getattr(nutinfo,properties)
                if rec.yields:
                    amt = amt/rec.yields
                itm_text += ' %d'%round(amt)
            txt += '\n'+itm_text
        return '\n'.join([txt,footnotes])

########NEW FILE########
__FILENAME__ = main_plugin
from gourmet.plugin import MainPlugin
import nutritionGrabberGui, nutrition
from gourmet.gglobals import add_icon
import os.path, gtk
from gettext import gettext as _

class NutritionMainPlugin (MainPlugin):

    def activate (self, pluggable):
        """Setup nutritional database stuff."""
        add_icon(os.path.join(os.path.split(__file__)[0],'images','Nutrition.png'),
         'nutritional-info',
         _('Nutritional Information'))
        nutritionGrabberGui.check_for_db(pluggable.rd)
        pluggable.nd = nutrition.NutritionData(pluggable.rd,pluggable.conv)
        pluggable.rd.nd = pluggable.nd

########NEW FILE########
__FILENAME__ = nutPrefsPlugin
from gourmet.plugin import PrefsPlugin
from gourmet.prefs import get_prefs
import gtk
from gettext import gettext as _

partialp = 'include_partial_nutritional_info'
includep = 'include_nutritional_info_in_export'

class NutritionPrefs (PrefsPlugin):

    label = _("Nutritional Information")

    def __init__ (self, *args, **kwargs):
        # Create main widget
        self.widget = gtk.VBox()
        self.prefs = get_prefs()
        label = gtk.Label('Hello world')
        self.include_tb = gtk.CheckButton('Include nutritional information in print-outs and exports')
        self.partial_tb = gtk.CheckButton('Include partial nutritional information in print-outs and exports?')
        self.include_tb.set_active(self.prefs.get(includep,True))
        self.partial_tb.set_active(self.prefs.get(partialp,False))
        self.include_tb.connect('toggled',self.toggle_cb)
        self.partial_tb.connect('toggled',self.toggle_cb)        
        self.widget.pack_start(self.include_tb, expand=False, fill=False)
        self.widget.pack_start(self.partial_tb, expand=False, fill=False)
        self.widget.set_border_width(12)
        self.widget.set_spacing(6)
        self.widget.show_all()

    def toggle_cb (self, tb):
        if tb==self.include_tb:
            if tb.get_active():
                self.prefs[includep] = True
            else:
                self.prefs[includep] = False
                # Force false...
                self.partial_tb.set_active(False)
                self.prefs[partialp] = False
        if tb == self.partial_tb:
            self.prefs[partialp] = tb.get_active()

########NEW FILE########
__FILENAME__ = nutrition
import re, string
import sys
from parser_data import SUMMABLE_FIELDS

# Our basic module for interaction with our nutritional information DB

class NutritionData:

    """Handle all interactions with our nutrition database.

    We provide methods to set up equivalences between our
    ingredient-keys and our nutritional data.
    """
    
    def __init__ (self, db, conv):
        self.db = db
        self.conv = conv
        self.conv.density_table
        self.gramwght_regexp = re.compile("([0-9.]+)?( ?([^,]+))?(, (.*))?")
        self.wght_breaker = re.compile('([^ ,]+)([, ]+\(?(.*)\)?)?$')

    def set_key (self, key, row):
        """Create an automatic equivalence for ingredient key 'key' and nutritional DB row ROW
        """        
        if not row: row = self._get_key(key)
        #density=self.get_density(key,row)
        if row: self.row.ndbno=row.ndbno
        else:
            self.db.do_add(self.db.nutritionaliases_table,
                           {'ndbno':row.ndbno,
                            'ingkey':key})

    def set_density_for_key (self, key, density_equivalent):
        self.db.update_by_criteria(
            self.db.nutritionaliases_table,
            {'ingkey':key},
            {'density_equivalent':density_equivalent}
            )

    def set_key_from_ndbno (self, key, ndbno):
        """Create an automatic equivalence between ingredient key 'key' and ndbno
        ndbno is our nutritional database number."""
        if type(ndbno)!=int:
            ndbno = int(ndbno)
        prev_association = self.db.fetch_one(self.db.nutritionaliases_table,ingkey=key)
        if prev_association:
            self.db.do_modify(self.db.nutritionaliases_table,
                              prev_association,
                              {'ndbno':ndbno},
                              "ingkey")
        else:
            self.db.do_add(self.db.nutritionaliases_table,{'ndbno':ndbno,
                                                 'ingkey':key}
                           )

    def set_conversion (self, key, unit, factor):
        """Set conversion for ingredient key.

        factor is the amount we multiply by to get from unit to grams.
        """
        if self.conv.unit_dict.has_key(unit):
            unit = self.conv.unit_dict[unit]
        prev_entry = self.db.fetch_one(self.db.nutritionconversions_table,
                                       **{'ingkey':key,'unit':unit})
        if prev_entry:
            self.db.do_modify(self.db.nutritionconversions_table,
                               prev_entry,
                               {'factor':factor})
        else:
            self.db.do_add(self.db.nutritionconversions_table,{'ingkey':key,'unit':unit,'factor':factor})

    def get_matches (self, key, max=50):
        """Handed a string, get a list of likely USDA database matches.

        We return a list of lists:
        [[description, nutritional-database-number],...]

        If max is not none, we cut our list off at max items (and hope our
        sorting algorithm succeeded in picking out the good matches!).
        """
        words=re.split("\W",key)
        words = filter(lambda w: w and not w in ['in','or','and','with'], words)
        #words += ['raw']
        result =  self.db.search_nutrition(words)
        while not result and len(words)>1:
            words = words[:-1]
            result = self.db.search_nutrition(words)
        if result:
            return [(r.desc,r.ndbno) for r in result]
        else:
            return []
            
    def _get_key (self, key):
        """Handed an ingredient key, get our nutritional Database equivalent
        if one exists."""
        row=self.db.fetch_one(self.db.nutritionaliases_table,**{'ingkey':str(key)})
        return row

    def get_nutinfo_for_ing (self, ing, rd, multiplier=None):
        """A convenience function that grabs the requisite items from
        an ingredient."""
        if hasattr(ing,'refid') and ing.refid:
            subrec = rd.get_referenced_rec(ing)
            return self.get_nutinfo_for_inglist(rd.get_ings(subrec),rd,ingObject=ing,multiplier=ing.amount)
        if hasattr(ing,'rangeamount') and ing.rangeamount:
            # just average our amounts
            try:
                amount = (ing.rangeamount + ing.amount)/2
            except TypeError:
                print 'Failed trying to add',ing.rangeamount,ing.amount
                raise
        else:
            amount = ing.amount
        if not amount: amount=1
        if multiplier: amount = amount * multiplier
        return  self.get_nutinfo_for_item(ing.ingkey,amount,ing.unit,ingObject=ing)

    def get_nutinfo_for_inglist (self, inglist, rd, ingObject=None, multiplier=None):
        """A convenience function to get NutritionInfoList for a list of
        ingredients.
        """
        return NutritionInfoList([self.get_nutinfo_for_ing(i,rd, multiplier) for i in inglist],
                                 ingObject=ingObject)

    def get_nutinfo_for_item (self, key, amt, unit, ingObject=None):
        """Handed a key, amount and unit, get out nutritional Database object.
        """
        ni=self.get_nutinfo(key)
        if not amt:
            amt = 1
        if ni: # We *can* have conversions w/ no units!
            c=self.get_conversion_for_amt(amt,unit,key=key,row=ni.__rowref__)
            if c:
                return NutritionInfo(ni,mult=c,ingObject=ingObject)
        return NutritionVapor(self,key,
                              rowref=ni,
                              amount=amt,
                              unit=unit,
                              ingObject=ingObject)

    def get_nutinfo_from_desc (self, desc):
        nvrow = self.db.fetch_one(self.db.nutrition_table,**{'desc':desc})
        if nvrow:
            return NutritionInfo(nvrow)
        else:
            matches = self.get_matches(desc)
            if len(matches) == 1:
                ndbno = matches[0][1]
                nvrow = self.db.fetch_one(self.db.nutrition_table,ndbno=ndbno)
                return NutritionInfo(nvrow)
        return None
    
    def get_nutinfo (self, key):
        """Get our nutritional information for ingredient key 'key'
        We return an object interfacing with our DB whose attributes
        will be nutritional values.
        """
        aliasrow = self._get_key(key)
        if aliasrow:
            nvrow=self.db.fetch_one(self.db.nutrition_table,**{'ndbno':aliasrow.ndbno})
            if nvrow: return NutritionInfo(nvrow)
        else:
            # See if the key happens to match an existing description...
            ni = self.get_nutinfo_from_desc(key)
            # if we don't have a nutritional db row, return a
            # NutritionVapor instance which remembers our query and allows
            # us to redo it.  The idea here is that our callers will get
            # an object that can guarantee them the latest nutritional
            # information for a given item.
            if ni:
                return ni
            return NutritionVapor(self,key)

    def get_ndbno (self, key):
        aliasrow = self._get_key(key)
        if aliasrow: return aliasrow.ndbno
        else: return None

    def convert_to_grams (self, amt, unit, key, row=None):
        conv = self.get_conversion_for_amt(amt,unit,key,row)
        if conv: return conv*100
        else:
            return None

    def get_conversion_for_amt (self, amt, unit, key, row=None, fudge=True):
        """Get a conversion for amount amt of unit 'unit' to USDA standard.

        Multiplying our standard numbers (/100g) will get us the appropriate
        calories, etc.

        get_conversion_for_amt(amt,unit,key) * 100 will give us the
        number of grams this AMOUNT converts to.
        """
        if not unit: unit = ''
        densities,gramweights = self.get_conversions(key,row)
        if gramweights.has_key(unit):
            mass = gramweights[unit] * amt
            return mass * 0.01
        # Otherwise, we are trying to find our density...
        cnv = None
        if (',' in unit) or ('(' in unit): # Check for density in unit description...
            print 'Checking for density in unit...','densities=',densities
            if ',' in unit:
                unit,description = unit.split(',')
            if '(' in unit:
                unit,description = unit.split('(')
                description = description.strip(')')
            description = description.strip()
            unit = unit.strip()
            print 'description=',description
            if densities.has_key(description):
                print 'We got a density!','unit=',unit
                density = densities[description]
                print density,type(density),'(unit=',unit,')'
                cnv = self.conv.converter('g.',unit,density=density)
                print 'We got a conversion!',cnv
        # our default is 100g
        if not cnv:
            # Check for convertible mass...
            cnv=self.conv.converter('g',unit)
        if not cnv:
            # Check for density through key information...
            if not row: row=self.get_nutinfo(key)
            cnv = self.conv.converter('g',unit,
                                      density=self.get_density(key,row,fudge=fudge)
                                      )
        if not cnv:
            # lookup in our custom nutrition-related conversion table
            if self.conv.unit_dict.has_key(unit):
                unit = self.conv.unit_dict[unit]
            elif not unit:
                unit = ''
            lookup = self.db.fetch_one(self.db.nutritionconversions_table,ingkey=key,unit=unit)
            if lookup:
                cnv = lookup.factor
            else:
                # otherwise, cycle through any units we have and see
                # if we can get a conversion via those units...
                for conv in self.db.fetch_all(self.db.nutritionconversions_table,ingkey=key):
                    factor = self.conv.converter(unit,conv.unit)
                    if factor:
                        cnv = conv.factor*factor
        if cnv:
            return (0.01*amt)/cnv

    def get_conversions (self, key=None, row=None):
        """Handed an ingredient key or a row of the nutrition database,
        we return two dictionaries, one with Unit Conversions and the other
        with densities. Our return dictionaries look like this:
        ({'chopped':1.03, #density dic
          'melted':1.09},
         {'piece':27,
          'leg':48,} # unit : grams
          )"""
        if not row: row=self.get_nutinfo(key)
        if not row: return {},{}
        units = {}
        densities = {}
        for gd,gw in self.get_gramweights(row).items():
            a,u,e=gd
            if a:
                convfactor = self.conv.converter(u,'ml')
                if convfactor: #if we are a volume
                    # divide mass by volume converted to mililiters
                    # (since gramwts are in grams!)
                    density = float(gw) / (a * convfactor)
                    densities[e]=density
                    continue
            # if we can't get a density from this amount, we're going to treat it as a unit!
            if e: u = u + ", " + e
            if a: gw = float(gw)/a
            else:
                gw = float(gw)
            if u: units[u]=gw
        return densities,units
            
    def get_densities (self,key=None,row=None):
        """Handed key or nutrow, return dictionary with densities."""
        if not row: row = self._get_key(key)
        if not row: return {}
        if self.conv.density_table.has_key(key):
            return {'':self.conv.density_table[key]}
        else:
            densities = {}       
            for gd,gw in self.get_gramweights(row).items():
                a,u,e = gd
                if not a:
                    continue
                convfactor=self.conv.converter(u,'ml')
                if convfactor: # if we are a volume
                    # divide mass by volume converted to milileters
                    # (gramwts are in grams)
                    density = float(gw) / (a * convfactor)
                    densities[e]=density
            return densities

    def get_gramweights (self,row):
        """Return a dictionary with gram weights.
        """
        ret = {}
        nutweights = self.db.fetch_all(self.db.usda_weights_table,**{'ndbno':row.ndbno})
        for nw in nutweights:
            mtch = self.wght_breaker.match(nw.unit)
            if not mtch:
                unit = nw.unit
                extra = None
            else:
                unit = mtch.groups()[0]
                extra = mtch.groups()[2]
            ret[(nw.amount,unit,extra)]=nw.gramwt
        return ret
    
    def get_density (self,key=None,row=None, fudge=True):
        densities = self.get_densities(key,row)
        if densities.has_key(''): densities[None]=densities['']
        if key: keyrow=self._get_key(key)
        if densities:
            if key and keyrow and keyrow.density_equivalent and densities.has_key(keyrow.density_equivalent):
                return densities[keyrow.density_equivalent]
            elif densities.has_key(None):
                self.conv.density_table[key]=densities[None]
                return densities[None]
            elif len(densities)==1:
                return densities.values()[0]
            elif fudge:
                return sum(densities.values())/len(densities)
            else:
                return None

    def parse_gramweight_measure (self, txt):
        m=self.gramwght_regexp.match(txt)
        if m:
            groups=m.groups()
            amt = groups[0]
            if amt: amt = float(amt)
            unit = groups[2]
            extra = groups[4]
            return amt,unit,extra

    def add_custom_nutrition_info (self, nutrition_dictionary):
        """Add custom nutritional information."""
        #new_ndbno = self.db.increment_field(self.db.nutrition_table,'ndbno')
        #if new_ndbno: nutrition_dictionary['ndbno']=new_ndbno
        return self.db.do_add_nutrition(nutrition_dictionary).ndbno
        
                    
class NutritionInfo:
    """A multipliable way to reference an object.

    Any attribute of object that can be mutiplied, will be returned
    multiplied by mult.

    We can also support various mathematical operators
    n = NutritionInfo(obj, mult=2)
    n * 2 -> NutritionInfo(obj,mult=4)
    n2 = NutritionInfo(obj2, mult=3)
    n2 + n -> NutritionInfoList([n2,n])

    The result is that addition and multiplication 'makes sense' for
    properties. For example, if we have nutrition info for 1 carrot,
    we can multiply it or add it to the nutrition info for an
    eggplant. The resulting object will reflect the appropriate
    cumulative values.

    Carrot = NutritionInfo(CarrotNutritionRow)
    Eggplant = NutritionInfo(EggplantNutritionRow)

    Carrot.kcal => 41
    Eggplant.kcal => 24
    (Carrot + Eggplant).kcal => 65
    (Carrot * 3 + Eggplant).kcal => 147

    This will be true for all numeric properties.

    Non numeric properties return a somewhat not-useful string:
    
    (Carrot + Eggplant).desc => 'CARROTS,RAW, EGGPLANT,RAW'
    """
    def __init__ (self,rowref, mult=1, fudged=False, ingObject=None):
        self.__rowref__ = rowref
        self.__mult__ = mult
        self.__fudged__ = fudged
        self.__ingobject__ = ingObject

    def __getattr__ (self, attr):
        if attr[0]!='_':
            ret = getattr(self.__rowref__, attr)
            try:
                if attr in SUMMABLE_FIELDS:
                    return (ret or 0) * self.__mult__
                else:
                    return ret
            except:
                raise
        else:
            # somehow this magically gets us standard
            # attribute handling...
            raise AttributeError, attr

    def __add__ (self, obj):
        if isinstance(obj,NutritionInfo):
            return NutritionInfoList([self,obj])
        elif isinstance(obj,NutritionInfoList):
            return NutritionInfoList([self]+obj.__nutinfos__)

    def __mul__ (self, n):
        return NutritionInfo(self.__rowref__, mult=self.__mult__ * n,
                             fudged=self.__fudged__,ingObject=self.__ingobject__)

KEY_VAPOR = 0 # when we don't have a key
UNIT_VAPOR = 1 # when we can't interpret the unit
DENSITY_VAPOR = 2 # when we don't have a density
AMOUNT_VAPOR = 3 # when there is no amount, leaving us quite confused

class NutritionVapor (NutritionInfo):
    """An object to hold our nutritional information before we know it.

    Basically, we have to behave like a NutritionInfo class that doesn't
    actually return any data.

    We also can return information about why we're still vapor
    (whether we need density info, key info or what...).
    """
    def __init__ (self, nd, key,
                  rowref=None,
                  mult=None,
                  amount=None,
                  unit=None,
                  ingObject=None):
        self.__nd__ = nd
        self.__rowref__ = rowref
        self.__key__ = key
        self.__mult__ = mult
        self.__amt__ = amount
        self.__unit__ = unit
        self.__ingobject__ = ingObject

    def _reset (self):
        """Try to create matter from vapor and return it.

        If we fail we return more vapor."""
        if not self.__rowref__:
            if self.__mult__:
                ni = self.__nd__.get_nutinfo(self.__key__)
                if not isinstance(ni,NutritionVapor): return ni * self.__mult__
                else: return self
            else:
                return self.__nd__.get_nutinfo_for_item(self.__key__,
                                                        self.__amt__,
                                                        self.__unit__,
                                                        ingObject=self.__ingobject__
                                                        )
        elif self.__amt__:
            c=self.__nd__.get_conversion_for_amt(self.__amt__,self.__unit__,self.__key__,fudge=False)
            if c:
                self.__mult__ = c
                return NutritionInfo(self.__rowref__,
                                     self.__mult__)
            else:
                c=self.__nd__.get_conversion_for_amt(self.__amt__,self.__unit__,self.__key__,fudge=True)
                if c:
                    self.__mult__ = c
                    return NutritionInfo(self.__rowref__,
                                         self.__mult__,
                                         ingObject=self.__ingobject__
                                         )
                else:
                    return self
        else: return self.__nd__.get_nutinfo_for_item(self.__key__,self.__amt__,self.__unit__,ingObject=self.__ingobject__)

    def __getattr__ (self,attr):
        """Return 0 for any requests for a non _ prefixed attribute."""
        if attr[0]!='_':
            return 0
        else:
            raise AttributeError,attr

    def __repr__ (self):
        return '<NutritionVapor %s>'%self.__key__
    
    def __nonzero__ (self):
        """Vapor is always False."""
        return False

    def _wheres_the_vapor (self):
        """Return a key as to why we're vapor."""
        if not self.__rowref__: return KEY_VAPOR
        elif not self.__amt__: return AMOUNT_VAPOR
        else: return UNIT_VAPOR
    
class NutritionInfoList (list, NutritionInfo):
    """A summable list of objects.

    When we ask for numeric attributes of our members, we get the sum.
    """
    def __init__ (self,nutinfos, mult=1,ingObject=None):
        self.__nutinfos__ = nutinfos
        #self.__len__ = self.__nutinfos__.__len__
        #self.__getitem__ = self.__nutinfos__.__getitem__
        self.__mult__ = 1
        self.__ingobject__ = ingObject

    def __getattr__ (self, attr):
        if attr[0]!='_':
            alist = [getattr(ni,attr) for ni in self.__nutinfos__]
            if attr in SUMMABLE_FIELDS:
                if self.__mult__: alist = [n * self.__mult__ for n in alist]
                return sum(alist)
            else:
                return ", ".join(map(str,alist))
        else:
            # somehow this magically gets us standard
            # attribute handling...
            raise AttributeError, attr

    def _reset (self):
        """See if we can turn any of our vapor into matter."""
        for i in range(len(self.__nutinfos__)):
            obj = self.__nutinfos__[i]
            if isinstance(obj,NutritionVapor):
                # try resetting
                self.__nutinfos__[i]=obj._reset()

    def _get_vapor (self):
        """Return a list of nutritionVapor if there is any

        In other words, tell us whether we are missing any nutritional
        information."""
        ret = []
        for i in self.__nutinfos__:
            if isinstance(i,NutritionVapor): ret.append(i)
            if isinstance(i,NutritionInfoList):
                ret.extend(i._get_vapor())
        return ret

    def _get_fudge (self):
        """Return a list of fudged items
        """
        ret = []
        for i in self.__nutinfos__:
            if hasattr(i,'__fudged__') and i.__fudged__:
                ret.append(i)
        return ret
        
    def __add__ (self, obj):
        if isinstance(obj,NutritionInfo):
            return NutritionInfoList(self.__nutinfos__ + [obj])
        elif isinstance(obj,NutritionInfoList):
            return NutritionInfoList(self.__nutinfos__ + obj.__nutinfos__)

    def __sub__ (self, obj):
        copy = self.__nutinfos__[0:]
        copy.remove(obj)
        return NutritionInfoList(copy)

    def __getslice__ (self, a, b):
        return NutritionInfoList(self.__nutinfos__[a:b])

    def __len__ (self): return len(self.__nutinfos__)
    def __getitem__ (self,x): return self.__nutinfos__[x]

    def __repr__ (self):
        return '<NutritionInfoList>'

    def __iter__ (self):
        for i in self.__nutinfos__: yield i

    def recursive_length (self):
        """Return number of contained nutrition info objects, recursing any embedded lists.
        """
        n = 0
        for x in range(len(self)):
            obj = self[x]
            if isinstance(obj,NutritionInfoList):
                n += obj.recursive_length()
            else:
                n += 1
        return n
            
if __name__ == '__main__':
    import gourmet.recipeManager as rm
    db=rm.RecipeManager(**rm.dbargs)
    import gourmet.convert
    conv = gourmet.convert.converter()
    import nutritionGrabberGui
    nutritionGrabberGui.check_for_db(db)
    nd=NutritionData(db,conv)

def foo ():
    from gourmet import convert
    class SimpleInterface:
        
        def __init__ (self, nd):
            self.ACTIONS = {'Add ingredient':self.add_ingredient,
                       'Add key info':self.add_key,
                       'Print info':self.print_info,
                       'Exit' : self.exit
                       }
            self.nd = nd
            self.ings = []

        def run (self):
            choices = self.ACTIONS.keys()
            for n,a in enumerate(choices):
                print n,a
            choice = None
            while not choice:
                choice = raw_input('Enter number of choice: ')
                choice = int(choice)
                if choice < len(choices): choice = self.ACTIONS[choices[choice]]
                else: choice = None
            try:
                choice()
            except:
                raise
            else:
                self.run()
                

        def add_ingredient (self):
            key=raw_input('Enter ingredient key: ')
            amt = convert.frac_to_float(raw_input('Enter amount: '))
            unit = raw_input('Enter unit: ')
            if not self.ings:
                self.ings = NutritionInfoList([self.nd.get_nutinfo_for_item(key,amt,unit)])
            else:
                self.ings = self.ings + self.nd.get_nutinfo_for_item(key,amt,unit)

        def add_key (self):
            key=raw_input('Enter key for which we add info: ')
            matches = self.nd.get_matches(key,10)
            for n,m in enumerate(matches):
                print n,'. ',m[0]
            choice = None
            while not choice:
                choice = raw_input('Enter number of choice: ')
                choice = int(choice)
                if choice < len(matches): choice = matches[choice][1]
                else: choice = None
            self.nd.set_key_from_ndbno(key,choice)
            self.ings._reset()

        def print_info (self):
            att = raw_input('What information would you like (e.g. kcal): ')
            while not hasattr(self.ings,att):
                print "I'm sorry, there is no information about ",att
                att = raw_input('What information would you like (e.g. kcal): ')
            print att,":",getattr(self.ings,att)
            vv = self.ings._get_vapor()
            if vv:
                for v in vv:
                    explanation = v._wheres_the_vapor()
                    if explanation==KEY_VAPOR: print 'No key'
                    if explanation==UNIT_VAPOR: print "Can't handle unit ",v.__unit__
                    if explanation==AMOUNT_VAPOR: print "What am I to do with the amount ",v.__amt__
                

        def exit (self):
            import sys
            sys.exit()
    si = SimpleInterface(nd)
    si.run()
    #import random
    #fake_key = "0"
    #while raw_input('Get another density?'):
    #    row=random.choice(db.nutrition_table)
    #    print 'Information: ',row.desc, nd.get_conversions(row=row)
    #    #print 'Gramweights: ',nd.get_gramweights(row)
    #    #print 'Density of ',row.desc,' = ',nd.get_densities(row)

########NEW FILE########
__FILENAME__ = nutritionDisplay
import gtk, re
import parser_data
import gourmet.cb_extras as cb
import gourmet.dialog_extras as de
from gettext import gettext as _

class NutritionModel (gtk.TreeStore):
    TITLE_FIELD = 'desc'
    def __init__ (self, nvw):
        self.nvw = nvw
        gtk.TreeStore.__init__(self,str,str)
        self.populate_model()

    def connect_treeview_signals (self,tv):
        tv.connect('row-expanded',self.row_expanded_cb)

    def populate_model (self,nvw=None):
        for n in self.nvw:
            self.add_row_to_model(n)

    def add_row_to_model (self,row):
        papa=self.append(None,[getattr(row,self.TITLE_FIELD),None])
        #debug('adding row to model: %s'%getattr(row,self.TITLE_FIELD),0)
        # add an empty child to make expander show up
        # (we don't actually expand until we have to)
        self.append(papa,[None,None])

    def row_expanded_cb (self, view, itr, path):
        child = self.iter_children(itr)
        if self.get_value(child,0) is None:
            self.remove(child)
            self.add_children_to_row(itr)

    def add_children_to_row (self,papa):
        desc = self.get_value(papa,0)
        row = self.nvw.select(**{self.TITLE_FIELD:desc})[0]
        for lname,sname,typ in parser_data.NUTRITION_FIELDS:
            if sname != self.TITLE_FIELD:
                self.append(papa,[lname,"%s"%getattr(row,sname)])
        
        
class SimpleNutritionalDisplay:
    def __init__ (self,nutrition_data):
        self.w = gtk.Window()
        self.nd = nutrition_data
        self.nm = NutritionModel(ndObj.db.nutrition_table)
        self.sw = gtk.ScrolledWindow()
        self.tv = gtk.TreeView()
        rend = gtk.CellRendererText()
        # setup treeview columns
        for n,cname in enumerate(['Item','Value']):
            col = gtk.TreeViewColumn(cname,rend,text=n)
            self.tv.append_column(col)
        self.tv.set_model(self.nm)
        self.nm.connect_treeview_signals(self.tv)
        self.w.add(self.sw)
        self.sw.add(self.tv)
        self.w.set_size_request(400,400)
        self.w.show_all()

class SimpleIngredientCalculator (de.mDialog):
    """This will be a simple prototype -- type in an ingredient,
    select the USDA equivalent, type in an amount and we're off!"""
    def __init__ (self, nd, umodel,
                  fields = ['kcal',
                            'protein',
                            'carb',
                            'fiber',
                            'sugar',
                            'famono',
                            'fapoly',
                            'fasat',
                            'cholestrl',]):
        de.mDialog.__init__(self)
        self.fields = fields
        self.nd = nd
        self.db = self.nd.db
        self.umodel = umodel
        self.setup_boxes()

    def setup_boxes (self):
        self.hbb = gtk.HBox()
        self.vbox.add(self.hbb)
        self.amtBox = gtk.SpinButton()
        self.amtBox.set_range(0.075,5000)
        self.amtBox.set_increments(0.5,5)
        self.amtBox.set_sensitive(True)
        self.amtBox.set_value(1)
        self.amtBox.connect('changed',self.nutBoxCB)
        self.unitBox = gtk.ComboBox()
        self.unitBox.set_model(self.umodel)
        cell = gtk.CellRendererText()
        self.unitBox.pack_start(cell, True)
        self.unitBox.add_attribute(cell, 'text', 1)
        cb.setup_typeahead(self.unitBox)
        self.itmBox = gtk.Entry()
        self.nutBox = gtk.ComboBox()
        self.nutBox.pack_start(cell, True)
        self.nutBox.add_attribute(cell,'text',0)        
        self.nutBox.connect('changed',self.nutBoxCB)
        self.unitBox.connect('changed',self.nutBoxCB)        
        self.refreshButton = gtk.Button('Update Nutritional Items')
        self.refreshButton.connect('clicked',self.updateCombo)
        self.hbb.add(self.amtBox)
        self.hbb.add(self.unitBox)
        self.hbb.add(self.itmBox)
        self.hbb.add(self.refreshButton)
        self.vbox.add(self.nutBox)
        self.nutLabel=gtk.Label()
        self.vbox.add(self.nutLabel)
        self.vbox.show_all()

    def nutBoxCB (self, *args):
        txt=cb.cb_get_active_text(self.nutBox)
        row=self.db.nutrition_table[self.db.nutrition_table.find({'desc':txt})]        
        conversion =  self.nd.get_conversion_for_amt(
            float(self.amtBox.get_value()),
            cb.cb_get_active_text(self.unitBox),
            self.itmBox.get_text(),
            row)        
        myfields = filter(lambda x: x[1] in self.fields, parser_data.NUTRITION_FIELDS)
        lab = ""
        for ln,f,typ in myfields:
            amt = getattr(row,f)
            if f in parser_data.PER_100_GRAMS:
                if conversion:
                    amt = "%s"%(amt * conversion)
                else:
                    amt = "%s/%s"%(amt,_('100 grams'))
            lab += "\n%s: %s"%(ln,amt)
        self.nutLabel.set_text(lab)
        
    def updateCombo (self, *args):
        self.txt = self.itmBox.get_text()
        indexvw = self.db.nutrition_table.filter(self.search_func)
        nvw = self.db.nutrition_table.remapwith(indexvw)
        mod = gtk.ListStore(str)
        map(lambda r: mod.append([r.desc]), nvw)
        self.nutBox.set_model(mod)        

    def search_func (self, row):
        desc = row.desc.lower()
        txt=self.txt.lower()
        words = re.split('\W',txt)
        ret = True
        while ret and words:
            word=words.pop()
            if word:
                ret = desc.find(word)>=0
        return ret

if __name__ == '__main__':
    from gourmet.recipeManager import RecipeManager,dbargs
    dbargs['file']='/tmp/fdsa/recipes.mk'
    db=RecipeManager(**dbargs)
    from gourmet.GourmetRecipeManager import UnitModel
    import gourmet.convert
    #inginfo = gourmet.reccard.IngInfo(db)
    conv=gourmet.convert.converter()
    umod = UnitModel(conv)
    import nutritionGrabberGui
    try:
        nutritionGrabberGui.check_for_db(db)
    except nutritionGrabberGui.Terminated:
        print 'Nutrition import was cut short a bit'
    def quit (*args):
        db.save()
        gtk.mainquit()
    #snd=SimpleNutritionalDisplay(db.nutrition_table)
    #snd.w.connect('delete-event',quit)
    import nutrition.nutrition
    nd=nutrition.nutrition.NutritionData(db,conv)
    sic = SimpleIngredientCalculator(nd,umod)
    sic.run()
    gtk.main()

########NEW FILE########
__FILENAME__ = nutritionDruid
import gtk, gobject
import gourmet.convert as convert
import gourmet.gglobals as gglobals
from gourmet.gtk_extras.mnemonic_manager import MnemonicManager
from gourmet.defaults import lang as defaults
from gourmet.gtk_extras.pageable_store import PageableViewStore
from nutritionLabel import NUT_LAYOUT, SEP, RECOMMENDED_INTAKE
from nutritionInfoEditor import NutritionInfoIndex,MockObject
from gourmet.gtk_extras.numberEntry import NumberEntry
import gourmet.gtk_extras.cb_extras as cb
import gourmet.gtk_extras.dialog_extras as de
import gourmet.gtk_extras.WidgetSaver as WidgetSaver
import re
import os,os.path
from gettext import gettext as _

try:
    current_path = os.path.split(os.path.join(os.getcwd(),__file__))[0]
except:
    current_path = ''

class SpecialAction:

    """A convenience class for a UI element where suddenly we want to
    highlight one action for a user to do and desensitize other
    elements of the UI temporarily.
    """

    def __init__ (self,
                  highlight_widgets=[],
                  initially_hidden=True,
                  grabs_focus=True,
                  hide_on_highlight=[],
                  all_controls=[],):

        """Initialize a SpecialAction that can be highlighted/sensitized/hidden conveniently.

        highlight_widgets is a list of the widgets we want to highlight.

        initially_hidden is a boolean or a list.
        If it's a boolean, it tells us whether all highlighted widgets are normally hidden.
        If it's a list, it is a list of widgets to hide.

        If grabs_focus is True, we grab focus for the first of the highlight_widgets.
        If grabs_focus is a widget, we grab focus for that widget.
        If grabs_focus is False, we don't grab focus.
        """
        self.highlight_widgets = highlight_widgets
        self.initially_hidden = initially_hidden
        self.all_controls = all_controls
        self.hide_on_highlight = hide_on_highlight
        if self.initially_hidden:
            if isinstance(self.initially_hidden,list):
                for w in self.initially_hidden: w.hide()
            else:
                for w in self.highlight_widgets: w.hide()

    def highlight_action (self,*args):
        self.prev_states = []
        for c in self.all_controls:
            self.prev_states.append(c.get_property('sensitive'))
            c.set_sensitive(False)
        for c in self.hide_on_highlight:
            c.hide()
        for w in self.highlight_widgets:
            w.set_sensitive(True)
            w.show()
        self.highlight_widgets[0].grab_focus()

    def dehighlight_action (self,*args):
        for n,c in enumerate(self.all_controls):
            c.set_sensitive(self.prev_states[n])
        if self.initially_hidden==True:
            for w in self.highlight_widgets: w.hide()
        if type(self.initially_hidden)==list:
            for w in self.initially_hidden: w.hide()
        for c in self.hide_on_highlight:
            c.show()

class NutritionUSDAIndex:

    '''This class handles the view for searching the USDA database.
    '''

    __last_group__ = None
    group = None
    
    PACKAGED_FOODS = ['Soups, Sauces, and Gravies',
                      'Baked Products',
                      'Meals, Entrees, and Sidedishes',
                      'Fast Foods',
                      'Baby Foods']

    ALL_GROUPS = _('Any food group')

    def __init__ (self, rd, prefs, widgets):
        self.rd = rd; self.prefs = prefs
        for name,w in widgets: setattr(self,name,w)
        self._setup_nuttree_()
        self.__last_search__ = ''
        self.__override_search__ = False        
        WidgetSaver.WidgetSaver(
            self.usdaSearchAsYouTypeToggle,
            self.prefs.get('sautTog',
                           {'active':True}),
            ['toggled'])
        # search
        self.usdaSearchEntry.connect('changed',self.search_type_cb)
        self.usdaFindButton.connect('clicked',self.search_cb)
        self.usdaSearchAsYouTypeToggle.connect('toggled',self.toggle_saut)
        cb.set_model_from_list(self.foodGroupComboBox,
                               [self.ALL_GROUPS]+self.rd.get_unique_values('foodgroup',self.rd.nutrition_table)
                               )
        cb.cb_set_active_text(self.foodGroupComboBox,self.ALL_GROUPS)        
        
    def set_search (self, txt):
        """Set the search to txt, ensuring there are results.

        If there are no results for the search, we'll try a partial
        search for only some of the words in txt. If that fails, we'll
        set the search to blank.
        """
        words = re.split('\W+',txt)
        # always search raw if possible... (it gets us the real thing
        # vs. canned/frozen/soup/babyfood, etc.)
        if 'raw' not in words:
            words += ['raw'] 
        search_terms = []
        search_in = self.rd.nutrition_table
        srch = []
        searchvw = None
        for w in words:
            if w in [',',' ',';','.']: continue
            result = self.rd.search_nutrition(srch+[w])
            if result:
                srch += [w]
                searchvw = result
        groups = self.rd.fetch_food_groups_for_search(srch)
        cur_active = cb.cb_get_active_text(self.foodGroupComboBox)
        groups = [self.ALL_GROUPS] + groups
        cb.set_model_from_list(self.foodGroupComboBox,groups)
        cb.cb_set_active_text(self.foodGroupComboBox,cur_active)
        self.__override_search__ = True # turn off any handling of text insertion
        search_text = ' '.join(srch)
        self.usdaSearchEntry.set_text(search_text)
        self.searchvw = searchvw or self.rd.fetch_all(self.rd.nutrition_table)        
        self.nutrition_store.change_view(self.searchvw)
        self.__last_search__ = search_text
        self.__override_search__ = False # turn back on search handling!
        
    def get_selected_usda_item (self):
        if len(self.searchvw)==1:
            nut = self.searchvw[0].ndbno
        else:
            mod,itr = self.usdaTreeview.get_selection().get_selected()
            nut = mod.get_value(itr,0)
        return nut

    def _setup_nuttree_ (self):
        """Set up our treeview with USDA nutritional equivalents"""
        self.nutrition_store = PageableNutritionStore(self.rd.fetch_all(self.rd.nutrition_table))
        self.usdaFirstButton.connect('clicked', lambda *args: self.nutrition_store.goto_first_page())
        self.usdaLastButton.connect('clicked', lambda *args: self.nutrition_store.goto_last_page())
        self.usdaForwardButton.connect('clicked', lambda *args: self.nutrition_store.next_page())
        self.usdaBackButton.connect('clicked', lambda *args: self.nutrition_store.prev_page())
        self.nutrition_store.connect('page-changed',self.update_nuttree_showing)
        self.nutrition_store.connect('view-changed',self.update_nuttree_showing)        
        self.update_nuttree_showing()
        self.searchvw = self.rd.nutrition_table
        self.usdaTreeview.set_model(self.nutrition_store)
        renderer = gtk.CellRendererText()
        col = gtk.TreeViewColumn('Item',renderer,text=1)
        self.usdaTreeview.append_column(col)

    def update_nuttree_showing (self,*args):
        self.usdaShowingLabel.set_text('Showing results %s to %s of %s'%self.nutrition_store.showing())
        # update buttons too
        cp = self.nutrition_store.page
        lp = self.nutrition_store.get_last_page()
        if cp == 0:
            self.usdaFirstButton.set_sensitive(False)
            self.usdaBackButton.set_sensitive(False)
        else:
            self.usdaFirstButton.set_sensitive(True)
            self.usdaBackButton.set_sensitive(True)
        if cp == lp:
            self.usdaLastButton.set_sensitive(False)
            self.usdaForwardButton.set_sensitive(False)
        else:
            self.usdaLastButton.set_sensitive(True)
            self.usdaForwardButton.set_sensitive(True)

    # search callbacks &c.
    def toggle_saut (self, *args):
        if self.usdaSearchAsYouTypeToggle.get_active():
            self.usdaFindButton.hide()
        else:
            self.usdaFindButton.show()

    def search_type_cb (self, *args):
        if self.usdaSearchAsYouTypeToggle.get_active(): self.search_cb()

    def search_cb (self, *args):
        if self.__override_search__: return
        gobject.idle_add(self.search)

    def search (self):
        txt = self.usdaSearchEntry.get_text()
        if self.__last_search__ == txt and self.group == self.__last_group__:
            return
        words = re.split('\W+',txt)
        groups = self.rd.fetch_food_groups_for_search(words)
        cur_active = cb.cb_get_active_text(self.foodGroupComboBox)
        groups = [self.ALL_GROUPS] + groups
        if cur_active not in groups:
            groups += [cur_active]
        cb.set_model_from_list(self.foodGroupComboBox,groups)
        cb.cb_set_active_text(self.foodGroupComboBox,cur_active)        
        self.searchvw = self.rd.search_nutrition(words,group=self.group)
        self.__last_search__ = txt
        self.__last_group__ = self.group
        self.nutrition_store.change_view(self.searchvw)
        self.nutrition_store.set_page(0)

    def food_group_filter_changed_cb (self, fgcb):
        food_group = cb.cb_get_active_text(fgcb)
        if food_group==self.ALL_GROUPS:
            self.group = None
        else:
            self.group = food_group
        gobject.idle_add(self.search)    
    
class NutritionInfoDruid (gobject.GObject):

    """A druid (or "wizard") to guide a user through helping Gourmet
    calculate nutritional information for an ingredient.

    This consists in finding a USDA equivalent of the ingredient in
    question and possibly of converting a unit.
    """

    NUT_PAGE = 0
    UNIT_PAGE = 1
    CUSTOM_PAGE = 2
    DENSITY_PAGE = 3
    INFO_PAGE = 4
    INDEX_PAGE = 5

    DEFAULT_AMOUNT = 8
    DEFAULT_UNIT = 'oz.'

    __gsignals__ = {
        # The key callback will return a tuple (old_key,new_key)
        'key-changed':(gobject.SIGNAL_RUN_LAST,gobject.TYPE_PYOBJECT,(gobject.TYPE_PYOBJECT,)),
        # The unit callback will return a tuple ((old_unit,old_key),(new_unit,new_key))
        'unit-changed':(gobject.SIGNAL_RUN_LAST,gobject.TYPE_PYOBJECT,(gobject.TYPE_PYOBJECT,)),
        'finish':(gobject.SIGNAL_RUN_LAST,gobject.TYPE_NONE,())
        }

    def __init__ (self, nd, prefs, rec=None, in_string=''):
        self.ui = gtk.Builder()
        self.ui.add_from_file(os.path.join(current_path,'nutritionDruid.ui'))
        self.mm = MnemonicManager()
        self.mm.add_builder(self.ui)
        self.mm.fix_conflicts_peacefully()
        self.prefs = prefs
        self.nd = nd
        self.rec = rec
        self.in_string = in_string or (rec and _('recipe') or _('selection'))
        self.rd = self.nd.db
        self.def_ingredient_amounts = {} # For default amounts for nutritional label...
        self.amounts = {} # List amounts by ingredient
        self.ing_to_index = {} # A way to keep track of the order of our ingredients...
        self._setup_widgets_()
        # keep track of pages/setups we've been on         
        self.path = []
        self.curpage = 0
        self.prevDruidButton.set_sensitive(False) 
        # Initiate our gobject-ness so we can emit signals.
        gobject.GObject.__init__(self)                      
        # Save our position with our widget saver...
        WidgetSaver.WindowSaver(self.ui.get_object('window'),
                                self.prefs.get('nutritionDruid',{})
                                )


    def _setup_widgets_ (self):
        self.controls = []
        self.widgets =  ['notebook',
                         # ingKey Changing Stuff
                         'ingKeyLabel','ingKeyEntry','changeKeyButton','applyKeyButton',
                         'ingKeyLabel2',
                         # Search stuff
                         'usdaSearchEntry','usdaSearchAsYouTypeToggle','usdaFindButton',
                         'usdaFirstButton','usdaBackButton','usdaForwardButton',
                         'usdaLastButton','usdaShowingLabel',
                         'usdaTreeview','foodGroupComboBox',
                         'customBox','customButton',
                         # Unit adjusting stuff
                         'convertUnitLabel','fromUnitComboBoxEntry','fromUnitLabel',
                         'changeUnitButton','cancelUnitButton','saveUnitButton',
                         'fromAmountEntry','toUnitCombo','toAmountEntry',
                         # Wizard buttons
                         'prevDruidButton','ignoreButton','applyButton',
                         # Custom nutritional information screen
                         'massUnitComboBox','customNutritionAmountEntry',
                         # Density-Choosing page
                         'densityLabel','densityBox',
                         # Index page...
                         'editButton',
                         # INFO PAGE
                         'infoIngredientKeyLabel','infoUSDALabel','nutritionLabelBox',
                         'infoDensityLabel','infoOtherEquivalentsLabel',
                         'infoCustomEquivalentsTable',
                         ]
        for widget_name in self.widgets:
            setattr(self,widget_name,self.ui.get_object(widget_name))
            if not getattr(self,widget_name): print "WIDGET: ",widget_name,"NOT FOUND."
            # make a list of all core control widgets
            if widget_name!='notebook': self.controls.append(getattr(self,widget_name))
        self.usdaIndex = NutritionUSDAIndex(self.rd,
                                            prefs=self.prefs,
                                            widgets=[(w,getattr(self,w)) for w in self.widgets])
        self.ui.connect_signals(
            {'previousPage':self.previous_page_cb,
             'applyPage':self.apply_cb,
             'ignorePage':self.ignore_cb,
             'customPage':self.custom_cb,
             'usdaPage':self.usda_cb,
             'close':self.close,
             'on_foodGroupComboBox_changed':self.usdaIndex.food_group_filter_changed_cb,
             'edit':self.view_nutritional_info,
             'infoEditUSDAAssociation':self.info_edit_usda_association,
             }
            )
        # hide our tabs...
        self.notebook.set_show_tabs(False)
        # custom widgety stuff
        self.changeIngKeyAction = SpecialAction(highlight_widgets=[self.ingKeyEntry,self.applyKeyButton,
                                                                   ],
                                                initially_hidden=True,
                                                hide_on_highlight=[self.ingKeyLabel,self.changeKeyButton,
                                                                   ],
                                                all_controls=self.controls)
        self.changeKeyButton.connect('clicked',self.changeIngKeyAction.highlight_action)
        self.applyKeyButton.connect('clicked',self.apply_ingkey)
        self.changeUnitAction = SpecialAction(highlight_widgets=[self.fromUnitComboBoxEntry,
                                                                 self.saveUnitButton,
                                                                 self.cancelUnitButton,],
                                              initially_hidden=True,
                                              hide_on_highlight=[self.fromUnitLabel,self.changeUnitButton],
                                              all_controls=self.controls)
        self.changeUnitButton.connect('clicked',self.changeUnitAction.highlight_action)
        self.cancelUnitButton.connect('clicked',self.changeUnitAction.dehighlight_action)
        self.saveUnitButton.connect('clicked',self.save_unit_cb)
        # Nutrition box...
        self.custom_box=self.ui.get_object('customBox')
        self.customNutritionAmountEntry.connect('changed',self.custom_unit_changed)
        self.massUnitComboBox.connect('changed',self.custom_unit_changed)
        self._setup_custom_box()

    ### BEGIN METHODS FOR NUTRITIONAL INFORMATION INDEX

    def setup_nutrition_index (self):
        if not hasattr(self,'full_inglist'):
            self.add_ingredients([])
        if not hasattr(self,'nutInfoIndex'):
            self.nutInfoIndex = NutritionInfoIndex(
                self.rd, prefs=self.prefs, ui=self.ui,
                ingredients=self.full_inglist,
                in_string=self.in_string,
                )
        self.path.append((self.goto_page_index,[]))
        self.goto_page_index()

    ### END METHODS FOR NUTRITIONAL INFORMATION INDEX

    ### BEGIN METHODS FOR DISPLAYING CURRENT NUTRITIONAL INFO
    def view_nutritional_info (self, *args):
        nutalias = self.nutInfoIndex.get_selected_ingredient()
        if nutalias.ndbno == 0:
            # Then this is not really an item... we better edit it!
            self.add_ingredients(
                [(
                nutalias.ingkey,
                self.get_amounts_and_units_for_ingkey(nutalias.ingkey)
                  )]
                )
        else:
            self.show_info_page(nutalias)
            self.path.append(
                (self.show_info_page,[nutalias])
                )
            
    def show_info_page (self, nutalias):
        self.infoIngredientKeyLabel.set_text(nutalias.ingkey)
        self.infoUSDALabel.set_text(nutalias.desc)
        self.goto_page_info()
        self.prevDruidButton.set_sensitive(True)
        self.set_nutritional_label(nutalias)
        self.set_density_info(nutalias)
        self.info_nutalias = nutalias

    def set_density_info (self, nutalias):
        densities,extra_units = self.nd.get_conversions(nutalias.ingkey)
        density_texts = []
        for k,v in densities.items():
            if not k:
                density_texts = ['%.2f'%v] + density_texts
            else:
                density_texts.append('%s: %.2f'%(k,v))
        self.infoDensityLabel.set_text('\n'.join(density_texts) or 'None')
        eutexts = ['%s: %s g'%(k,v) for k,v in extra_units.items() ]
        eutexts.sort()
        extra_units_text = '\n'.join(eutexts)
        self.infoOtherEquivalentsLabel.set_text(
            extra_units_text or 'None'
            )
        others = self.rd.fetch_all(self.rd.nutritionconversions_table,ingkey=nutalias.ingkey)
        other_label = '\n'.join(['%s: %.1f g'%(
            conv.unit or '100 %s'%_('ml'),1.0/conv.factor
            ) for conv in others])
        if others:
            self.populate_custom_equivalents_table(others)
        else:
            self.infoCustomEquivalentsTable.hide()

    def populate_custom_equivalents_table (self, equivalents):
        # Remove previous children...
        for c in self.infoCustomEquivalentsTable.get_children():
            self.infoCustomEquivalentsTable.remove(c); c.unparent()
        for n,eq in enumerate(equivalents):
            lab = gtk.Label("%s: %.1f g"%(
                eq.unit or 'No unit', 1.0/eq.factor)
                            )
            rembut = gtk.Button('C_hange'); rembut.set_use_underline(True)
            rembut.connect('clicked',
                           self.info_edit_equivalent,
                           eq)
            self.infoCustomEquivalentsTable.attach(lab,
                                                   0,1,n,n+1)
            self.infoCustomEquivalentsTable.attach(rembut,
                                                   1,2,n,n+1)
        self.infoCustomEquivalentsTable.show_all()

    def set_nutritional_label (self, nutalias):
        if not hasattr(self,'nutritionLabel'):
            from nutritionLabel import NutritionLabel
            self.nutritionAmountLabel = gtk.Label()
            self.nutritionLabel = NutritionLabel(self.prefs, custom_label=' ')
            self.nutritionLabelBox.pack_start(self.nutritionAmountLabel,
                                              fill=0,
                                              expand=0)
            self.nutritionLabelBox.pack_start(self.nutritionLabel,
                                              fill=0,
                                              expand=0,
                                              )
            self.nutritionAmountLabel.set_alignment(0.0,0.0)
            self.nutritionAmountLabel.show()
            self.nutritionLabel.show()
        amount,unit = self.def_ingredient_amounts.get(nutalias.ingkey,
                                                  (self.DEFAULT_AMOUNT,
                                                   self.DEFAULT_UNIT)
                                                  )
        nutinfo = self.nd.get_nutinfo_for_inglist([
            MockObject(amount=amount,
                       unit=unit,
                       ingkey=nutalias.ingkey)
            ],
                                                  self.rd
                                                  )
        if nutinfo._get_vapor():
            amount = self.DEFAULT_AMOUNT; unit = self.DEFAULT_UNIT
            nutinfo = self.nd.get_nutinfo_for_inglist([
            MockObject(amount=amount,
                       unit=unit,
                       ingkey=nutalias.ingkey)
            ],
                                                      self.rd
                                                      )

        self.nutritionLabel.set_nutinfo(
            nutinfo
            )
        self.nutritionAmountLabel.set_markup(
            '<i>Nutritional information for %(amount)s %(unit)s</i>'%{
            'amount':amount,
            'unit':unit,
            })
    
    def get_amounts_and_units_for_ingkey (self, ingkey):
        """Return a list of amounts and units present in database for ingkey"""
        amounts_and_units = []
        ings = self.rd.fetch_all(self.rd.ingredients_table,ingkey=ingkey)        
        for i in ings:
            a,u = i.amount,i.unit
            if (a,u) not in amounts_and_units:
                amounts_and_units.append((a,u))
        return amounts_and_units

    # start nutritional-info callbacks
    def info_edit_usda_association (self, *args):
        """Edit the USDA association for the item on the information page."""
        self.edit_nutinfo(ingkey=self.info_nutalias.ingkey,
                          desc=self.info_nutalias.desc)
        self.path.append(
            (self.edit_nutinfo,
             [self.info_nutalias.ingkey,
              self.info_nutalias.desc])
            )

    def info_edit_equivalent (self, button, eq):
        """Edit equivalents callback. eq is a nutalias DB object.
        """
        self.amounts[self.ingkey] = {}
        self.amount = 1
        self.ingkey = self.info_nutalias.ingkey
        self.set_from_unit(eq.unit)
        self.fromAmountEntry.set_text('1')
        conv = self.nd.get_conversion_for_amt(1,eq.unit,self.info_nutalias.ingkey)
        amt_in_grams = conv * 100
        self.setup_to_units()
        to_unit = cb.cb_set_active_text(self.toUnitCombo,'g')
        self.toAmountEntry.set_text(convert.float_to_frac(amt_in_grams,
                                                          fractions=convert.FRACTIONS_ASCII
                                                          ))
        
        # Hack to avoid adding ourselves to the path on a "back" event
        # -- if button is None, then we know we were called
        # artificially from previous_page_cb (not from a button press
        # event)
        if button:
            self.path.append(
                (self.info_edit_equivalent,
                 [None,eq])
                )
        self.goto_page_unit_convert()

    # end nutritional-info callbacks

    ### END METHODS FOR DISPLAYING CURRENT NUTRITIONAL INFO

    ### BEGIN  METHODS FOR CUSTOM NUTRITIONAL INTERFACE
    def _setup_custom_box (self):
        """Setup the interface for entering custom nutritional information.
        """
        t = gtk.Table()
        masses = [i[0] for i in defaults.UNIT_GROUPS['metric mass']\
                  + defaults.UNIT_GROUPS['imperial weight']]
        cb.set_model_from_list(
            self.massUnitComboBox,
            masses)
        cb.cb_set_active_text(self.massUnitComboBox,'g')
        self.customNutritionAmountEntry.set_value(100)
        self.nutrition_info = {}
        self.custom_box.add(t)
        self.changing_percent_internally = False
        self.changing_number_internally = False
        l=gtk.Label('%RDA'); l.show()
        t.attach(l,2,3,0,1)
        for n,nutstuff in enumerate(NUT_LAYOUT):
            if nutstuff == SEP:
                hs = gtk.HSeparator()
                t.attach(hs,0,2,n+1,n+2,xoptions=gtk.FILL)
                hs.show()
                continue
            label_txt,typ,name,properties,show_percent,unit = nutstuff
            if unit: label_txt += " (" + unit + ")"
            label = gtk.Label(label_txt); label.show()
            label.set_alignment(0,0.5)
            t.attach(label,0,1,n+1,n+2,xoptions=gtk.FILL)
            entry = NumberEntry(default_to_fractions=False)
            entry.show()
            t.attach(entry,1,2,n+1,n+2,xoptions=gtk.FILL)
            if show_percent:
                percent_entry = NumberEntry(default_to_fractions=False,
                                            decimals=0)
                percent_entry.entry.set_width_chars(4)
                percent_entry.show()
                percent_label = gtk.Label('%'); percent_label.show()
                t.attach(percent_entry,2,3,n+1,n+2)
                t.attach(percent_label,3,4,n+1,n+2)
                percent_label.set_alignment(0,0.5)
                percent_entry.connect('changed',self.percent_changed_cb,name,entry)
                percent_entry.entry.set_width_chars(5)
            else: percent_entry = None
            entry.connect('changed',self.number_changed_cb,name,percent_entry)
        t.set_row_spacings(6)
        t.set_col_spacings(12)
        t.show()

    def number_changed_cb (self, widget, name, percent_widget):
        v = widget.get_value()
        self.nutrition_info[name]=v
        if not v: return
        if self.changing_number_internally: return
        if percent_widget:
            rda = RECOMMENDED_INTAKE.get(name,None)*2000
            if rda:
                self.changing_percent_internally = True
                percent_widget.set_value((float(v)/rda)*100)
                self.changing_percent_internally = False
        
    def percent_changed_cb (self, widget, name, number_widget):
        if self.changing_percent_internally: return
        v = widget.get_value()
        if not v: return
        if number_widget:
            rda = RECOMMENDED_INTAKE.get(name,None)*2000
            if rda:
                self.changing_number_internally = True
                number_widget.set_value(
                    v*0.01*rda
                    )
                self.changing_number_internally = False

    def custom_unit_changed (self, *args):
        amount = self.customNutritionAmountEntry.get_value()
        unit = cb.cb_get_active_text(self.massUnitComboBox)
        if amount and unit:
            base_convert = self.nd.conv.converter(unit,'g')/float(100)
            self.custom_factor = 1/(base_convert * amount)

    def apply_custom (self, *args):
        nutinfo = self.nutrition_info.copy()
        for k,v in nutinfo.items():
            if type(v)==int or type(v)==float: nutinfo[k]=v*self.custom_factor
            # Special case fat, which is listed as one item but is in
            # fact a combination of 3. We'll have to fudge the info
            # about mono- v. poly- unsaturated fats.
            if k=='fat':
                totfat = v * self.custom_factor
                unsatfat = totfat - nutinfo.get('fasat',0)
                del nutinfo['fat']
                nutinfo['fapoly']=unsatfat # Fudge
        nutinfo['desc']=self.ingkey
        ndbno = self.nd.add_custom_nutrition_info(nutinfo)

    ### END METHODS FOR CUSTOM NUTRITIONAL INTERFACE 

    ### METHODS TO SET CURRENT ITEM AND UNIT INFO
    def set_ingkey (self, txt):
        self.ingKeyEntry.set_text(txt)
        self.ingKeyLabel.set_markup('<i><b>'+txt+'</b></i>') # USDA Page
        self.ingKeyLabel2.set_markup('<i><b>'+txt+'</b></i>') # Custom Page
        self.nutrition_info['desc']=txt
        self.ingkey = txt

    ### BEGIN METHODS FOR SETTING UNIT EQUIVALENTS
        
    def set_from_unit (self, txt):
        if not self.ingkey:
            return
        if txt:
            self.fromUnitLabel.set_text(txt)
            self.fromUnitComboBoxEntry.get_children()[0].set_text(txt)
            self.fromUnit = txt
            curamt = ' '.join([convert.float_to_frac(self.amount,
                                                     fractions=convert.FRACTIONS_ASCII),
                               self.fromUnit,self.ingkey])
        else:
            self.fromUnitLabel.set_text(self.ingkey+' (no unit)')
            self.fromUnit = ''
            curamt = convert.float_to_frac(
                self.amount,
                fractions=convert.FRACTIONS_ASCII)+' '+self.ingkey
        self.convertUnitLabel.set_markup(
            '<span weight="bold" size="larger">' + \
            _('Convert unit for %s')%self.ingkey + \
            '</span>' + \
            '\n<i>' + \
            _('In order to calculate nutritional information, Gourmet needs you to help it convert "%s" into a unit it understands.')%curamt + \
            '</i>')

    def setup_to_units (self):
        """Setup list of units we need to convert to.

        Usually, this will be a list of mass units.
        """
        masses = [i[0] for i in defaults.UNIT_GROUPS['metric mass'] + defaults.UNIT_GROUPS['imperial weight']]
        volumes = [i[0] for i in  defaults.UNIT_GROUPS['metric volume'] + defaults.UNIT_GROUPS['imperial volume']]
        to_units = masses
        self.densities,self.extra_units = self.nd.get_conversions(self.ingkey)
        for d in self.densities.keys():
            if d:
                to_units.extend(["%s (%s)"%(u,d) for u in volumes])
            else:
                to_units.extend(volumes)
        to_units.sort()
        for u in self.extra_units:
            to_units = [u]+to_units
        cb.set_model_from_list(self.toUnitCombo,
                               to_units)
        self.toUnitCombo.set_active(0)
        self.toUnitCombo.set_wrap_width(3)

    def apply_amt_convert (self,*args):
        to_unit = cb.cb_get_active_text(self.toUnitCombo)
        base_convert = self.nd.conv.converter('g',to_unit)
        if not base_convert:
            self.densities,self.extra_units = self.nd.get_conversions(self.ingkey)
            if self.extra_units.has_key(to_unit):
                base_convert = 1/self.extra_units[to_unit]
            else:
                # this is a density, we hope...
                if to_unit.find(' (')>0:
                    to_unit,describer = to_unit.split(' (')
                    describer = describer[0:-1]
                    density = self.densities[describer]
                else:
                    if not self.densities.has_key(None):
                        raise RuntimeError("Unable to make sense of conversion from %s %s"%(to_unit,self.ingkey))
                    density = self.densities[None]
                base_convert = self.nd.conv.converter('g',to_unit,density=density)
        to_amount = convert.frac_to_float(self.toAmountEntry.get_text())
        from_amount = convert.frac_to_float(self.fromAmountEntry.get_text())
        ratio = from_amount / to_amount
        factor = base_convert * ratio
        from_unit = self.fromUnit
        self.nd.set_conversion(self.ingkey,from_unit,factor)

    ### END METHODS FOR SETTING UNIT EQUIVALENTS

    ### BEGIN METHODS FOR SEARCHING USDA INDEX
    
    def autosearch_ingkey (self):
        """Automatically do a search for our current ingkey.

        We're pretty smart about this: in other words, we won't do a
        search that doesn't have results.
        """
        self.usdaIndex.set_search(self.ingkey)

    def apply_nut_equivalent (self,*args):
        nut = self.usdaIndex.get_selected_usda_item()
        self.nd.set_key_from_ndbno(self.ingkey,nut)
        # Now see if we need to do any conversion or not
        self.setup_to_units()

    ### END METHODS FOR SEARCHING USDA INDEX

    ### BEGIN CALLBACKS FOR QUICK-CHANGES OF INGREDIENT KEY / UNIT
        
    def apply_ingkey (self,*args):
        key = self.ingKeyEntry.get_text()
        if key==self.ingkey:
            self.changeIngKeyAction.dehighlight_action()            
            return
        #ings = self.rd.fetch_all(self.rd.ingredients_table,ingkey=self.ingkey)
        #self.rd.modify_ings(ings,{'ingkey':key})
        if self.rec:
            try:
                user_says_yes = de.getBoolean(
                    label=_('Change ingredient key'),
                    sublabel=_(
                    'Change ingredient key from %(old_key)s to %(new_key)s everywhere or just in the recipe %(title)s?'
                    )%{'old_key':self.ingkey,
                       'new_key':key,
                       'title':self.rec.title
                       },
                    custom_no=_('Change _everywhere'),
                    custom_yes=_('_Just in recipe %s')%self.rec.title
                    )
            except de.UserCancelledError:
                self.changeIngKeyAction.dehighlight_action()
                return
        else:
            if not de.getBoolean(label=_('Change ingredient key'),
                                 sublabel=_('Change ingredient key from %(old_key)s to %(new_key)s everywhere?'
                                            )%{'old_key':self.ingkey,
                                               'new_key':key,
                                               },
                                 cancel=False,
                                 ):
                self.changeIngKeyAction.dehighlight_action()
                return
        if self.rec and user_says_yes:
            self.rd.update_by_criteria(self.rd.ingredients_table,
                           {'ingkey':self.ingkey,
                            'recipe_id':self.rec.id},
                           {'ingkey':key}
                           )
        else:
            self.rd.update_by_criteria(self.rd.ingredients_table,
                          {'ingkey':self.ingkey},
                          {'ingkey':key}
                          )
        old_key = self.ingkey
        self.set_ingkey(key)
        # Update amounts dictionary...
        self.amounts[key] = self.amounts[old_key]
        del self.amounts[old_key]
        self.autosearch_ingkey()
        self.changeIngKeyAction.dehighlight_action()
        if self.nd.get_nutinfo(key):
            self.setup_to_units()
            self.check_next_amount()
        self.emit('key-changed',(old_key,key))
    
    def save_unit_cb (self,*args):
        from_unit = self.fromUnitComboBoxEntry.get_children()[0].get_text()
        old_from_unit = self.fromUnit
        #ings = self.rd.fetch_all(self.rd.ingredients_table,ingkey=self.ingkey,unit=old_from_unit)
        #self.rd.modify_ings(ings,{'unit':from_unit})
        if self.rec and de.getBoolean(
            label=_('Change unit'),
            sublabel=_(
            'Change unit from %(old_unit)s to %(new_unit)s for all ingredients %(ingkey)s or just in the recipe %(title)s?'
            )%{'old_unit':old_from_unit,
               'new_unit':from_unit,
               'ingkey':self.ingkey,
               'title':self.rec.title
               },
            custom_no=_('Change _everywhere'),
            custom_yes=_('_Just in recipe %s')%self.rec.title
            ):
            self.rd.update_by_criteria(self.rd.ingredients_table,
                           {'ingkey':self.ingkey,
                            'unit':old_from_unit,
                            'recipe_id':self.rec.id},
                           {'unit':from_unit}
                           )
        else:
            self.rd.update_by_criteria(self.rd.ingredients_table,
                          {'ingkey':self.ingkey,
                           'unit':old_from_unit},
                          {'unit':from_unit}
                          )
        self.set_from_unit(self.fromUnitComboBoxEntry.get_children()[0].get_text())
        self.changeUnitAction.dehighlight_action()
        self.emit('unit-changed',((old_from_unit,self.ingkey),(from_unit,self.ingkey)))
        
    ### END CALLBACKS FOR QUICK-CHANGES OF INGREDIENT KEY / UNIT

    ### BEGIN METHODS FOR DENSITY-CHOOSING INTERFACE
        
    def get_density (self,amount,unit):
        self.densityLabel.set_text(
            _("""In order to calculate nutritional information for "%(amount)s %(unit)s %(ingkey)s", Gourmet needs to know its density. Our nutritional database has several descriptions of this food with different densities. Please select the correct one below.""")%({'amount':amount,'unit':unit,'ingkey':self.ingkey})
            )
        for c in self.densityBox.get_children():
            self.densityBox.remove(c)
            c.unparent()
        group = None
        def density_callback (rb, name):
            self.custom_density = name
        for d in self.densities.keys():
            group = gtk.RadioButton(group,str(d)+' '+'(%.2f)'%self.densities[d])
            group.connect('toggled',density_callback,d)
            self.densityBox.pack_start(group,expand=False,fill=False)
            group.show()
        group.set_active(True)
        self.custom_density = d
        self.goto_page_density()

    def apply_density (self):
        self.nd.set_density_for_key(
            self.ingkey,
            self.custom_density
            )
        for c in self.densityBox.get_children(): c.hide()

    ### END METHODS FOR DENSITY CHANGING INTERFACE

    ### BEGIN CALLBACKS TO WALK THROUGH INGREDIENTS

    def add_ingredients (self, inglist, full_inglist=[]):
        """Add a list of ingredients for our druid to guide the user through.

        Our ingredient list is in the following form for, believe it
        or not, good reason:

        [(ingkey, [(amount,unit),(amount,unit),(amount,unit)]),
         (ingkey, [(amount,unit),(amount,unit),(amount,unit)]),
         ...
         ]

        The ingkey is a string, of course.
        amount can be a float or None
        unit can be a string or None

        For each item in the list, we will ask the user to select a
        USDA equivalent.

        Once we've done that, we'll check if the user needs to convert
        the unit as well.
        """
        # to start, we take our first ing
        self.inglist = inglist
        if not full_inglist:
            if self.rec:
                self.full_inglist = []
                for i in self.rd.get_ings(self.rec):
                    self.full_inglist.append(i.ingkey)
                    self.def_ingredient_amounts[i.ingkey] = (i.amount,i.unit)
            else:
                self.full_inglist = []
                for ingkey,amounts_and_units in self.inglist:
                    self.full_inglist.append(ingkey)
                    if amounts_and_units:
                        self.def_ingredient_amounts[ingkey] = amounts_and_units[0]
        self.ing_index = 0
        self.setup_next_ing()

    def setup_next_ing (self):
        """Move to next ingredient."""
        if self.ing_index >= len(self.inglist):
            self.finish()
            return
        ing = self.inglist[self.ing_index]
        self.ing_index+=1    
        if not ing:
            return
        ingkey,amounts = ing
        self.ing_to_index[ingkey] = self.ing_index
        self.amounts[ingkey] = amounts
        self.amount_index = 0
        self.set_ingkey(ingkey)
        if not self.nd.get_nutinfo(ingkey):
            self.edit_nutinfo()
            self.path.append((self.edit_nutinfo,[ingkey]))
        else:
            self.setup_to_units()
            self.check_next_amount()

    def edit_nutinfo (self, ingkey=None, desc=None):
        self.amounts[ingkey or desc] = self.get_amounts_and_units_for_ingkey(ingkey)
        self.amount_index = 0
        if ingkey:
            self.set_ingkey(ingkey)
        if desc:
            self.usdaIndex.set_search(desc)
        else:
            self.autosearch_ingkey()        
        self.goto_page_key_to_nut()
        ing_index = self.ing_to_index.get(ingkey,None)
        if ing_index: self.ing_index = ing_index

    def check_next_amount (self):
        """Check the next amount on our amounts list.

        If the amount is already convertible, we don't do anything.
        If the amount is not convertible, we ask our user for help!
        """
        if self.amount_index >= len(self.amounts[self.ingkey]):
            self.setup_next_ing()
            return
        amount,unit = self.amounts[self.ingkey][self.amount_index]
        if not amount: amount=1
        self.amount = amount
        self.amount_index += 1
        existing_conversion = self.nd.get_conversion_for_amt(amount,unit,self.ingkey,fudge=True)
        existing_conversion_fudged = (existing_conversion
                                      and
                                      (not self.nd.get_conversion_for_amt(amount,unit,self.ingkey,fudge=False)
                                       ))
        if existing_conversion_fudged:
            self.get_density(amount,unit)
        elif existing_conversion:
            self.check_next_amount()
        else:
            self.edit_units(amount, unit, self.ingkey)
            self.path.append((self.edit_units,
                              [amount,unit,self.ingkey,self.amount_index])
                             )
    
    def edit_units (self, amount, unit, ingkey, indx=None):
        self.set_ingkey(ingkey)
        self.set_from_unit(unit)
        if indx is not None: self.amount_index = indx
        self.fromAmountEntry.set_text(convert.float_to_frac(amount,
                                                            fractions=convert.FRACTIONS_ASCII)
                                      )
        self.toAmountEntry.set_text(convert.float_to_frac(amount,
                                                          fractions=convert.FRACTIONS_ASCII)
                                    )
        self.goto_page_unit_convert()

    def previous_page_cb (self, *args):
        """Move to the previous item in self.path


        PATH ITEMS are in the form:

        (CUSTOM_METHOD,ARGS)

        We'll call CUSTOM_METHOD(ARGS)
        """
        self.path.pop() # pop off current page...
        method,args = self.path[-1]
        if callable(method):
            method(*args)
        else:
            # for convenience, if the method isn't callable, we take
            # it to be a page
            self.notebook.set_current_page(method)
        if len(self.path) <= 1:
            self.prevDruidButton.set_sensitive(False)
        return

    def apply_cb (self, *args):
        page = self.notebook.get_current_page()
        if page == self.NUT_PAGE:
            self.apply_nut_equivalent()
            self.check_next_amount()
        elif page == self.UNIT_PAGE:
            self.apply_amt_convert()
            # if out of amounts, this will move to the next ingredient
            self.check_next_amount()
        elif page == self.CUSTOM_PAGE:
            if not self.custom_factor:
                de.show_message(_("To apply nutritional information, Gourmet needs a valid amount and unit."))
                return
            self.apply_custom()
            self.check_next_amount()
        elif page == self.DENSITY_PAGE:
            self.apply_density()
            self.check_next_amount()
        self.curpage += 1
        self.prevDruidButton.set_sensitive(True)
    
    def ignore_cb (self, *args):
        page = self.notebook.get_current_page()
        self.curpage += 1
        self.prevDruidButton.set_sensitive(True)
        if page == self.NUT_PAGE:
            self.setup_next_ing()
        else:
            self.check_next_amount()

    ### END CALLBACKS TO WALK THROUGH INGREDIENTS

    ### BEGIN CONVENIENCE METHODS FOR SWITCHING PAGES
    def goto_page_key_to_nut (self):
        for b in [self.applyButton,self.ignoreButton]: b.show()
        for b in [self.editButton]: b.hide()        
        self.notebook.set_current_page(self.NUT_PAGE)

    def goto_page_unit_convert(self):
        for b in [self.applyButton,self.ignoreButton]: b.show()
        for b in [self.editButton]: b.hide()        
        self.notebook.set_current_page(self.UNIT_PAGE)

    def goto_page_custom (self):
        for b in [self.applyButton,self.ignoreButton]: b.show()
        for b in [self.editButton]: b.hide()        
        self.notebook.set_current_page(self.CUSTOM_PAGE)

    def goto_page_density (self):
        for b in [self.applyButton,self.ignoreButton]: b.show()
        for b in [self.editButton]: b.hide()
        self.notebook.set_current_page(self.DENSITY_PAGE)

    def goto_page_index (self):
        for b in [self.editButton]: b.show()
        for b in [self.applyButton,self.ignoreButton]: b.hide()
        self.notebook.set_current_page(self.INDEX_PAGE)

    def goto_page_info (self):
        for b in [self.editButton,self.applyButton,self.ignoreButton]: b.hide()
        self.notebook.set_current_page(self.INFO_PAGE)

    ### END CONVENIENCE METHODS FOR SWITCHING PAGES

    def custom_cb (self, *args): self.goto_page_custom()

    def usda_cb (self, *args): self.goto_page_key_to_nut()
    
    ### BEGIN METHODS FOR STARTING AND FINISHING
    
    def show (self):
        self.ui.get_object('window').show()

    def finish (self):
        # When done -- goto nutritional index page...
        if not hasattr(self,'nutInfoIndex'):
            self.setup_nutrition_index()
        else:
            self.nutInfoIndex.reset()
            self.goto_page_index()

    def close (self, *args):
        self.ui.get_object('window').hide()
        self.emit('finish')
        #self.ui.get_object('window').hide()
        
    ### END METHODS FOR STARTING AND FINISHING

    ### END NutritionInfoDruid
    
class PageableNutritionStore (PageableViewStore):
    def __init__ (self, view, columns=['ndbno','desc',],column_types=[int,str]):
        PageableViewStore.__init__(self,view,columns,column_types)
    
                   
if __name__ == '__main__':
    import nutrition
    from gourmet.recipeManager import RecipeManager,dbargs
    dbargs['file']='/tmp/boofoo.db'
    rd=RecipeManager(**dbargs)
    rd.add_ing(dict(ingkey='1% milk',
               amount=1.0,
               unit='c.'))
    rd.add_ing(dict(ingkey='1% milk',
               amount=10,
               unit='oz.'))
    rd.add_ing(dict(ingkey='1% milk',
               amount=1,
               unit='splash'))
    import nutritionGrabberGui
    try:
        nutritionGrabberGui.check_for_db(rd)
    except nutritionGrabberGui.Terminated:
        pass
    rd.save()
    import gourmet.convert
    c=gourmet.convert.converter()
    nd=nutrition.NutritionData(rd,c)
    nid = NutritionInfoDruid(nd,{})
    def unit_handler (*args):
        print 'CHANGE UNIT CALLBACK:',args
    def key_handler (*args):
        print 'CHANGE KEY CALLBACK:',args
    nid.connect('unit-changed',unit_handler)
    nid.connect('key-changed',key_handler)
    #nid.set_ingkey('black pepper')
    #nid.autosearch_ingkey()
    #nid.set_from_unit('tsp.')
    nid.add_ingredients([
        ('white sugar',[(1,'c.')]),
        ('black pepper',[(1,'tsp.'),(2,'pinch')]),
        ('tomato',[(1,''),(2,'cups'),(0.5,'lb.')]),
        ('kiwi',[(1,''),(0.5,'c.')]),
        ('raw onion',[(1,'c.')]),
        ('sugar, powdered',[(1,'c.')]),
        ('garlic',[(1,'clove')]),
        ('cauliflower',[(1,'head'),(3,'chunks')]),
        ('salt',[(3,'tsp'),]),
        ('1% milk',[(1,'c.')])
        
        ])
                         
    def quit (*args):
        rd.save()
        nid.ui.get_object('window').hide()
        gtk.main_quit()
    nid.ui.get_object('window').connect('delete-event',quit)
    nid.connect('finish',quit)
    gtk.main()
    del rd
    del nid

########NEW FILE########
__FILENAME__ = nutritionGrabberGui
import gtk
import databaseGrabber
import os, os.path, time
import gourmet.gtk_extras.dialog_extras as de
from gourmet.gglobals import data_dir
from gettext import gettext as _

class DatabaseGrabberGui (databaseGrabber.DatabaseGrabber):
    def __init__ (self, db):
        databaseGrabber.DatabaseGrabber.__init__(self,db,self.show_progress)
        self.paused=False
        self.terminated=False

    def pausecb (self,button,*args):
        if button.get_active():
            self.paused=True
        else:
            self.paused=False

    def stopcb (self,*args):
        self.terminated=True
        
    def load_db (self):
        #filename=None
        #if de.getBoolean(
        #    label=_('Load nutritional database.'),
        #    sublabel=_("It looks like you haven\'t yet initialized your nutritional database. To do so, you'll need to download the USDA nutritional database for use with your program. If you are not currently online, but have already downloaded the USDA sr17 database, you can point Gourmet to the ABBREV.txt file now. If you are online, Gourmet can download the file automatically."),
        #    custom_yes=_('Browse for ABBREV.txt file'),
        #    custom_no=_('Download file automatically')):
        #    filename=de.select_file(
        #        'Find ABBREV.txt file',
        #        filters=[['Plain Text',['text/plain'],['*txt']]]
        #        )
        self.progdialog = de.ProgressDialog(label=_('Loading Nutritional Data'),
                                            pause=self.pausecb,
                                            stop=self.stopcb)
        self.progdialog.show()
        self.grab_data(data_dir)
        self.show_progress(1,_('Nutritonal database import complete!'))
        self.progdialog.set_response_sensitive(gtk.RESPONSE_OK,True)
        self.progdialog.hide()

    def show_progress (self,fract,msg):
        self.progdialog.progress_bar.set_fraction(fract)
        self.progdialog.progress_bar.set_text(msg)
        while self.paused:
            time.sleep(0.1)
            self.gui_update()
        self.gui_update()
        
    def gui_update (self):
        if self.terminated:
            raise Exception("Terminated!")
        while gtk.events_pending():
            gtk.main_iteration()

    def get_zip_file (self):
        self.show_progress(0.01,_('Fetching nutritional database from zip archive %s')%self.USDA_ZIP_URL)
        return databaseGrabber.DatabaseGrabber.get_zip_file(self)

    def get_abbrev_from_url (self):
        self.show_progress(0.05,_('Extracting %s from zip archive.')%self.ABBREV_FILE_NAME)
        return databaseGrabber.DatabaseGrabber.get_abbrev_from_url(self)
    
def check_for_db (db):
    if db.fetch_len(db.nutrition_table) < 10:
        print 'Grabbing nutrition database!'
        dgg = DatabaseGrabberGui(db)        
        dgg.load_db()
    # Check if we have choline in our DB... butter (1123) has choline...
    elif not db.fetch_one(db.nutrition_table,ndbno=1123).choline:
        dgg = DatabaseGrabberGui(db)
        dgg.load_db()
        
if __name__=='__main__':
    import gourmet.recipeManager
    print 'loading db'
    db = gourmet.recipeManager.RecipeManager(**gourmet.recipeManager.dbargs)
    print 'checking for nutrition_table'
    check_for_db(db)

########NEW FILE########
__FILENAME__ = nutritionInfoEditor
import gtk, gobject, pango
import gourmet.gtk_extras.pageable_store as pageable_store
import gourmet.gglobals as gglobals
import os, re
import gourmet.gtk_extras.cb_extras as cb
from gettext import gettext as _
from gettext import ngettext
import sqlalchemy
import gourmet.backends.db

class NutritionInfoIndex:

    def __init__ (self, rd, prefs=None, ui=None,
                  ingredients=None,
                  in_string = _('recipe'),
                  ):
        if ui:
            self.ui = ui
        else:
            self.ui = gtk.Builder()
            self.ui.add_from_file(os.path.join(gglobals.uibase,'nutritionDruid.ui'))
        self.rd = rd
        self.prefs = prefs
        # Initialize variables used for search
        self.search_string = ''
        self.use_regexp = None
        #self.search_by = 
        self.widget_names = ['treeview', 'searchByBox', 'searchEntry',
                             'searchButton', 'window',
                             'searchAsYouTypeToggle', 'regexpTog',
                             'nutritionFilterInLabel','nutritionFilterComboBox',
                             ]
        for w in self.widget_names:
            setattr(self,w,self.ui.get_object(w))
        self.prev_button = self.ui.get_object('prevButton')
        self.next_button = self.ui.get_object('nextButton')
        self.first_button = self.ui.get_object('firstButton')
        self.last_button = self.ui.get_object('lastButton')
        self.showing_label = self.ui.get_object('showingLabel')
        self.prev_button.connect('clicked',lambda *args: self.treeModel.prev_page())
        self.next_button.connect('clicked',lambda *args: self.treeModel.next_page())
        self.first_button.connect('clicked',lambda *args: self.treeModel.goto_first_page())
        self.last_button.connect('clicked',lambda *args: self.treeModel.goto_last_page())
        self.set_limit(ingredients,in_string)                
        self.ui.connect_signals({
            'iSearch':self.isearchCB,
            'search':self.searchCB,
            'search_as_you_type_toggle':self.search_as_you_typeCB,
            'filter_changed':self.filter_changed_cb,
            })
        self.makeTreeModel()
        self.setupTreeView()
        self.treeview.set_model(self.treeModel)
        self.update_showing_label()

    def set_limit (self, ingredients, in_string=_('recipe')):
        """Set ingredients to show in index.

        in_string is a string describing what these ingredients
        represent. For example, recipe.
        """
        self.ingredients = ingredients
        self.in_string = in_string
        cb.set_model_from_list(
            self.nutritionFilterComboBox,
            [self.in_string,_('entire database')]
            )
        cb.cb_set_active_text(self.nutritionFilterComboBox,self.in_string)

    def filter_changed_cb (self, *args):
        if self.nutritionFilterComboBox.get_active()==0:
            self.treeModel.search_kwargs = self.treeModel.limited_args
        else:
            self.treeModel.search_kwargs = {}
        self.reset()
        
    def setupTreeView (self):
        cssu = pageable_store.ColumnSortSetterUpper(self.treeModel)
        sortable = [1,2]
        for n,head in [[1,_('Ingredient Key')],
                       [2,_('USDA ID Number')],
                       [3,_('USDA Item Description')],
                       [4,_('Density Equivalent')],]:
            renderer = gtk.CellRendererText()
            # If we have gtk > 2.8, set up text-wrapping
            try:
                renderer.get_property('wrap-width')
            except TypeError:
                pass
            else:
                renderer.set_property('wrap-mode',pango.WRAP_WORD)
                renderer.set_property('wrap-width',200)
            #if n==self.VALUE_COL:
            #    renderer.set_property('editable',True)
            #    renderer.connect('edited',self.tree_edited,n,head)
            col = gtk.TreeViewColumn(head, renderer, text=n)
            col.set_resizable(True)
            self.treeview.append_column(col)
            if n in sortable: cssu.set_sort_column_id(col,n)
        
    def makeTreeModel (self):
        self.treeModel = NutStore(self.rd,per_page=12,ingredients=self.ingredients)
        self.treeModel.connect('page-changed',self.model_changed_cb)
        self.treeModel.connect('view-changed',self.model_changed_cb)

    def reset (self):
        """Rebuild our model, regardless."""
        self.search_string = 'NO ONE WOULD EVER SEARCH FOR THIS'
        self.doSearch()

    # Set up searching...
    def doSearch (self):
        """Do the actual searching."""
        last_search = self.search_string
        self.search_string = self.searchEntry.get_text()
        #last_by = self.search_by
        #self.search_by = cb.cb_get_active_text(self.searchByBox)
        last_regexp = self.use_regexp
        self.use_regexp = self.regexpTog.get_active()
        if (#self.search_by==last_by and
            self.search_string==last_search and
            self.use_regexp==last_regexp):
            # Don't do anything...
            return
        # RESET THE VIEW IF NEED BE
        #if (self.search_string.find(last_search)!=0 or
        #    #self.search_by != last_by or
        #    self.use_regexp != last_regexp):
        #    self.treeModel.reset_view()
        self.treeModel.limit(self.search_string,column='ingkey',
                             search_options={'use_regexp':self.use_regexp,}
                             )

    def isearchCB (self, *args):
        if self.searchAsYouTypeToggle.get_active():
            self.doSearch()

    def searchCB (self, *args):
        self.doSearch()

    def search_as_you_typeCB (self, *args):
        if self.searchAsYouTypeToggle.get_active():
            self.searchButton.hide()
        else: self.searchButton.show()

    def model_changed_cb (self, model):
        if model.page==0:
            self.prev_button.set_sensitive(False)
            self.first_button.set_sensitive(False)
        else:
            self.prev_button.set_sensitive(True)
            self.first_button.set_sensitive(True)
        if model.get_last_page()==model.page:
            self.next_button.set_sensitive(False)
            self.last_button.set_sensitive(False)
        else:
            self.next_button.set_sensitive(True)
            self.last_button.set_sensitive(True)
        self.update_showing_label()
        
    def update_showing_label (self):
        bottom,top,total = self.treeModel.showing()
        if top >= total and bottom==1:
            lab = ngettext('%s ingredient','%s ingredients',top)%top
        else:
            # Do not translate bottom, top and total -- I use these fancy formatting
            # strings in case your language needs the order changed!
            lab = _('Showing ingredients %(bottom)s to %(top)s of %(total)s'%locals())
        self.showing_label.set_markup('<i>' + lab + '</i>')

    def get_selected_ingredient (self, *args):
        mod,itr = self.treeview.get_selection().get_selected()
        return mod.get_value(itr,0)
        

class MockObject:
    def __init__ (self, **kwargs):
        for k,v in kwargs.items(): setattr(self,k,v)

class NutStore (pageable_store.PageableViewStore):

    #__gsignals__ = {
    #    'view-changed':(gobject.SIGNAL_RUN_LAST,
    #                    gobject.TYPE_NONE,
    #                    ()),
    #    }

    KEY = _('Key')+':'
    USDA_ID = _('Item')+':'
    USDA_ITEM_NUMBER = _('USDA ID#')+':'
    USDA_DESC = _('USDA Item Description')+':'
    DENSITY_EQUIVALENT = _('Density Equivalent')
    columns=['obj','ingkey','ndbno','desc','density_equivalent']
    column_types=[gobject.TYPE_PYOBJECT, #row ref
                  str, # key
                  int, # ID
                  str, # description
                  str, # Density equivalent
                  #float, # Density
                  ]

    def __init__ (self,
                  rd,
                  per_page=15,
                  ingredients=None
                  ):
        self.rd = rd
        if ingredients:
            self.limited_args = self.search_kwargs = {'ingkey':('in',ingredients)}
        else:
            self.limited_args = self.search_kwargs = {}
        self.ingredients = ingredients
        vw = self.get_vw(self.search_kwargs)
        pageable_store.PageableViewStore.__init__(self,
                                                  vw,
                                                  columns=self.columns,
                                                  column_types=self.column_types,
                                                  per_page=per_page
                                                  )

    def get_vw (self, search_kwargs, search_extras_regexp=None):
        """Get a view for our model.

        Our model will consist of items found in our database + any
        ingredients specified when we were created. In other words,
        we'll list all ingredients that we're told about, whether
        they're in the nutrition aliases table or not.

        search_kwargs are the arguments handed to our database search.
        search_extras_text is a regexp used to filter our "extras."
        """
        select = sqlalchemy.select([self.rd.nutritionaliases_table.c.ingkey,self.rd.nutritionaliases_table.c.density_equivalent,
                                    self.rd.nutrition_table.c.desc,self.rd.nutrition_table.c.ndbno],
                                   *gourmet.backends.db.make_simple_select_arg(search_kwargs,
                                                                               self.rd.nutrition_table,
                                                                               self.rd.nutritionaliases_table),
                                   **{'from_obj':[sqlalchemy.join(self.rd.nutrition_table,
                                                                  self.rd.nutritionaliases_table)]
                                      }
                                   )
        vw = select.execute().fetchall()
        #vw = self.rd.fetch_join(self.rd.nutritionaliases_table,self.rd.nutrition_table,
        #                        'ndbno','ndbno',sort_by=[('ingkey',1)],
        #                        **search_kwargs)
        # We must show ingredients whether we have them or not...
        extras = []
        if self.ingredients:
            ings_to_add = self.ingredients[:]
            if search_extras_regexp:
                ings_to_add = filter(lambda i: re.match(search_extras_regexp,
                                                        i),
                                     ings_to_add)
            for row in vw:
                while row.ingkey in ings_to_add:
                    ings_to_add.remove(row.ingkey)
            for extra_ing in ings_to_add:
                if extra_ing:
                    extras.append(MockObject(ingkey=extra_ing,
                                             ndbno=0,desc='Not in database',density_equivalent=None)
                                  )
        return vw + extras
        

    def limit  (self, txt, column='ingkey', search_options={}):
        if not txt:
            vw = self.get_vw(self.search_kwargs)
        else:
            if search_options ['use_regexp']:
                s = ('REGEXP',txt)
                extras_search = '.*'+txt+'.*'
            else:
                s = ('LIKE','%'+txt.replace('%','%%')+'%')
                extras_search = '.*'+re.escape(txt)+'.*'
            kwargs = self.search_kwargs.copy()
            if kwargs.has_key(column):
                kwargs[column] = ('and',[kwargs[column],s])
            else:
                kwargs[column]=s
            vw = self.get_vw(kwargs,extras_search)
        self.change_view(vw)

    def _get_value_ (self, row, attr): return getattr(row,attr)

    def _get_slice_ (self, bottom, top):
        try:
            return [[r] + [self._get_value_(r,col) for col in self.columns[1:]] for r in self.view[bottom:top]]
        except:
            print '_get_slice_ failed with',bottom,top
            raise
        
        
if __name__ == '__main__':
    import gourmet.recipeManager as rm
    rd = rm.RecipeManager()
    nie = NutritionInfoIndex(rd,ingredients=['cilantro','tomato','basil','water','onion, red','onion, white','scallion','hare'])
    nie.window.show()
    nie.window.connect('delete-event',gtk.main_quit)
    #nie.show_index_page()
    gtk.main()

########NEW FILE########
__FILENAME__ = nutritionLabel
import gtk, pango, gobject
from gettext import gettext as _
import gourmet.defaults

MAJOR = 0
MINOR = 1
TINY = 2
SEP = 3
SHOW_PERCENT = True
DONT_SHOW_PERCENT = False    
MAIN_NUT_LAYOUT = [(_('Calories'),MAJOR,'kcal',
                'kcal',DONT_SHOW_PERCENT,''),
               SEP,
               (_('Total Fat'),MAJOR,'fat',
                ['fasat','famono','fapoly'],SHOW_PERCENT,'g'),
               (_('Saturated Fat'),MINOR,'fasat',
                'fasat',SHOW_PERCENT,'g'),
               (_('Cholesterol'),MAJOR,'cholestrl',
                'cholestrl',SHOW_PERCENT,'mg'),
               (_('Sodium'),MAJOR,'sodium',
                'sodium',SHOW_PERCENT,'mg'),
               (_('Total Carbohydrate'),MAJOR,'carb',
                'carb',SHOW_PERCENT,'g'),
               (_('Dietary Fiber'),MINOR,
                'fiber','fiber',SHOW_PERCENT,'g'),
               (_('Sugars'),MINOR,'sugar',
                'sugar',DONT_SHOW_PERCENT,'g'),
               (_('Protein'),MAJOR,'protein',
                'protein',SHOW_PERCENT,'g'),
                   ]

DETAIL_NUT_LAYOUT = [
               (_('Alpha-carotene'),TINY,'alphac',
                'alphac',DONT_SHOW_PERCENT,u'\u00B5g'),
               (_('Ash'),TINY,'ash',
                'ash',DONT_SHOW_PERCENT,'g'),
               (_('Beta-carotene'),TINY,'betac',
                'betac',DONT_SHOW_PERCENT,u'\u00B5g'),
               (_('Beta Cryptoxanthin'),TINY,'betacrypt',
                'betacrypt',DONT_SHOW_PERCENT,u'\u00B5g'),               
               (_('Calcium'),TINY,'calcium',
                'calcium',SHOW_PERCENT,'mg'),
               (_('Copper'),TINY,'copper',
                'copper',SHOW_PERCENT,'mg'),
               (_('Folate Total'),TINY,'folatetotal',
                'folatetotal',SHOW_PERCENT,u'\u00B5g'),
               (_('Folic acid'),TINY,'folateacid',
                'folateacid',DONT_SHOW_PERCENT,u'\u00B5g'),
               (_('Food Folate'),TINY,'foodfolate',
                'foodfolate',DONT_SHOW_PERCENT,u'\u00B5g'),
               (_('Dietary folate equivalents'),TINY,'folatedfe',
                'folatedfe',DONT_SHOW_PERCENT,u'\u00B5g'),               
               (_('Iron'),TINY,'iron',
                'iron',SHOW_PERCENT,'mg'),
               (_('Lycopene'),TINY,'lypocene',
                'lypocene',DONT_SHOW_PERCENT,u'\u00B5g'),
               (_('Lutein+Zeazanthin'),TINY,'lutzea',
                'lutzea',DONT_SHOW_PERCENT,u'\u00B5g'),
               (_('Magnesium'),TINY,'magnesium',
                'magnesium',SHOW_PERCENT,'mg'),
               (_('Manganese'),TINY,'manganese',
                'manganese',SHOW_PERCENT,'mg'),
               (_('Niacin'),TINY,'niacin',
                'niacin',SHOW_PERCENT,'mg'),
               (_('Pantothenic Acid'),TINY,'pantoacid',
                'pantoacid',SHOW_PERCENT,'mg'),               
               (_('Phosphorus'),TINY,'phosphorus',
                'phosphorus',SHOW_PERCENT,'mg'),
               (_('Potassium'),TINY,'potassium',
                'potassium',SHOW_PERCENT,'mg'),
               (_('Vitamin A'),TINY,'vitarae',
                'vitarae',SHOW_PERCENT,u'\u00B5g'),
               (_('Retinol'),TINY,'retinol',
                'retinol',SHOW_PERCENT,u'\u00B5g'),
               (_('Riboflavin'),TINY,'riboflavin',
                'riboflavin',SHOW_PERCENT,'mg'),
               (_('Selenium'),TINY,'selenium',
                'selenium',SHOW_PERCENT,u'\u00B5g'),
               (_('Thiamin'),TINY,'thiamin',
                'thiamin',SHOW_PERCENT,'mg'),
               (_('Vitamin A (IU)'),TINY,'vitaiu',
                'vitaiu',SHOW_PERCENT,'IU'),
               (_('Vitamin A (RAE)'),TINY,'vitarae',
                'vitarae',DONT_SHOW_PERCENT,u'\u00B5g'),
               (_('Vitamin B6'),TINY,'vitaminb6',
                'vitaminb6',SHOW_PERCENT,'mg'),
               (_('Vitamin B12'),TINY,'vitb12',
                'vitb12',SHOW_PERCENT,u'\u00B5g'),
               (_('Vitamin C'),TINY,'vitaminc',
                'vitaminc',SHOW_PERCENT,'mg'),               
               (_('Vitamin E'),TINY,'vite',
                'vite',SHOW_PERCENT,'mg'),
               (_('Vitamin K'),TINY,'vitk',
                'vitk',SHOW_PERCENT,'mg'),
               (_('Zinc'),TINY,'zinc',
                'zinc',SHOW_PERCENT,'mg'),
               ]

NUT_LAYOUT = MAIN_NUT_LAYOUT + DETAIL_NUT_LAYOUT

RECOMMENDED_INTAKE = {
        'fat':0.30 / 9, # 30% of calories * 9 cal / g.
        'fasat':0.10 / 9, #10% of calories * 9 cal /g.
        'carb':0.6 / 4, #60% of calories * 4 cal / g.
        'protein':0.10 / 4, #10% of calories * 4 cal/g.
        'fiber':11.5/1000, #11.5 grams / 1000calories
        'sodium':2400.0/2000, # 2400 mg per typical 2000 c diet
        'potassium':3500.0/2000,
        'iron':18.0/2000,
        'calcium':1000.0/2000,
        'cholestrl':300.0/2000,
        'vitarae':900.0/2000,
        'magnesium':420.0/2000,
        'vitaminc':60.0/2000,
        'vitaiu':5000.0/2000,
        'vite':30.0/2000,
        'vitk':80.0/2000,
        'thiamin':1.5/2000,
        'riboflavin':1.7/2000,
        'niacin':20.0/2000,
        'vitaminb6':2.0/2000,
        'folatetotal':400.0/2000,
        'vitb12':6.0/2000,
        'pantoacid':10.0/2000,
        'phosphorus':1000.0/2000,
        'magnesium':400.0/2000,
        'zinc':15.0/2000,
        'selenium':70.0/2000,
        'copper':2.0/2000,
        'manganese':2.0/2000,
        'chromium':120.0/2000,
        'molybdenum':75.0/2000,
        'chloride':3400.0/2000,
        }


class NutritionLabel (gtk.VBox, gobject.GObject):
    """Provide a nutritional label that looks like standard FDA
    labels."""

    __gtype_name__ = 'NutritionLabel'

    bold_font = pango.FontDescription()
    bold_font.set_weight(pango.WEIGHT_BOLD)
    tiny_font = pango.FontDescription()
    tiny_font.set_size(pango.SCALE*9)
    background = gtk.gdk.Color(255,0,0)
    foreground = gtk.gdk.Color(255,255,255)    

    calories_per_day = 2000

    __gsignals__ = {
        'calories-changed':(gobject.SIGNAL_RUN_LAST,gobject.TYPE_NONE,()),
        'ingredients-changed':(gobject.SIGNAL_RUN_LAST,gobject.TYPE_NONE,()),
        'label-changed':(gobject.SIGNAL_RUN_LAST,gobject.TYPE_NONE,()),
        }

    def __init__ (self, prefs=None,
                  rec=None,
                  custom_label=None,
                  pressable=True
                  ):
        self.pressable = pressable
        self.toggles = {}; self.__toggling__ = False
        self.active_name = None
        self.active_unit = None
        self.active_label = None
        self.active_properties = None
        self.active_button_markup = ('<span background="#ffff00">','</span>')
        self.custom_label = custom_label
        self.prefs = prefs
        self.rec = rec
        start_at = 4
        gobject.GObject.__init__(self)
        gtk.VBox.__init__(self)
        #,2,len(NUT_LAYOUT)+start_at)
        self.show()
        self.tt = gtk.Tooltips()
        self.yieldLabel = gtk.Label()
        self.set_yields(0)
        self.nutrition_display_info = []
        #self.attach(self.yieldLabel,
        #            0,2,0,1)
        self.yieldLabel.show()
        self.yieldLabel.set_alignment(0,0.5)
        self.missingLabel = self.make_missing_label()
        #self.attach(self.missingLabel,0,2,1,2)
        self.pack_start(self.missingLabel,fill=False,expand=False)
        self.pack_start(self.yieldLabel,fill=False,expand=False)
        # setup daily value button to display calories/day assumption
        # and to allow changing it via a nifty little button
        dvb,eb = self.make_dv_boxes()
        dvb.show()
        self.cal_per_day_box = gtk.HBox();
        self.cal_per_day_box.show()
        vb = gtk.VBox(); vb.show()
        vb.pack_start(dvb,fill=False,expand=False)
        vb.pack_start(eb,fill=False,expand=False)
        self.cal_per_day_box.pack_end(vb)
        self.pack_start(self.cal_per_day_box)
        self.tt.enable()
        self.main_table = gtk.Table(); self.main_table.show()
        self.main_table.set_col_spacings(18)
        self.pack_start(self.main_table)
        self.sub_table = gtk.Table(); self.sub_table.show()
        self.sub_table.set_col_spacings(18)
        self.nutexpander = gtk.Expander(_('Vitamins and minerals'))
        self.nutexpander.show()
        self.nutexpander.add(self.sub_table)
        self.pack_start(self.nutexpander)
        for table,layout in [(self.main_table,MAIN_NUT_LAYOUT),
                             (self.sub_table,DETAIL_NUT_LAYOUT),
                             ]:
            for n,nutstuff in enumerate(layout):
                if nutstuff == SEP:
                    hs = gtk.HSeparator()
                    table.attach(hs,0,2,n+start_at,n+start_at+1,xoptions=gtk.FILL)
                    hs.show()
                    continue
                label,typ,name,properties,show_percent,unit = nutstuff
                hb = gtk.HBox()
                permanentl = gtk.Label()
                permanentl.set_alignment(0,0.5)
                if typ==MAJOR:
                    permanentl.set_markup('<b>'+label+'</b>')
                elif typ==MINOR:
                    permanentl.set_markup('  '+label)
                elif typ==TINY:
                    permanentl.set_markup('  <span size="smaller">'+label+'</span>')
                if self.pressable:
                    b = gtk.Button(); b.add(permanentl)
                    b.set_relief(gtk.RELIEF_NONE)
                    b.connect('clicked',self.toggle_label,label,name,properties,unit)
                    hb.pack_start(b,expand=False)
                    self.toggles[name] = b
                else:
                    hb.pack_start(permanentl)
                unit_label = gtk.Label()
                unit_label.set_alignment(0,0.5)
                if name != 'kcal':
                    hb.pack_start(unit_label)
                else:
                    #print 'pack end'
                    #hb.pack_end(unit_label,expand=True)
                    table.attach(unit_label,1,2,n+start_at,n+start_at+1,xoptions=gtk.FILL)
                    unit_label.set_alignment(1,0.5)
                    unit_label.show()
                hb.show_all()
                table.attach(hb,0,1,n+start_at,n+start_at+1,xoptions=gtk.FILL)
                if show_percent==SHOW_PERCENT:
                    percent_label = gtk.Label()
                    percent_label.modify_font(self.bold_font)
                    percent_label.set_alignment(1,0.5)
                    percent_label.show()
                    table.attach(percent_label,1,2,n+start_at,n+start_at+1,xoptions=gtk.FILL)
                self.nutrition_display_info.append({
                    'props':properties,
                    'percent_label':(show_percent==SHOW_PERCENT
                                     and
                                     percent_label),
                    'unit_label': unit_label,
                    'unit':unit,
                    'usda_rec_per_cal':(RECOMMENDED_INTAKE.has_key(name) and
                                        RECOMMENDED_INTAKE[name]),
                    'box':hb,
                    'type':typ,
                    })

    def set_prefs (self, prefs):
        self.prefs = prefs

    def toggle_label (self, button, label, name,properties, unit):
        if self.__toggling__: return
        self.__toggling__ = True
        if name != self.active_name:
            for b in self.toggles.values():
                lab = b.get_children()[0]
                if b != button:
                    orig = lab.get_label()
                    if orig.find(self.active_button_markup[0])==0:
                        lab.set_label(orig[len(self.active_button_markup[0]):(- len(self.active_button_markup[1]))])
                else:
                    lab.set_label(self.active_button_markup[0]+lab.get_label()+self.active_button_markup[1])
            self.active_name = name
            self.active_unit = unit
            self.active_label = label
            self.active_properties = properties
        else:
            self.active_name = None
            self.active_unit = None
            self.active_label = None
            lab = button.get_children()[0]
            orig = lab.get_label()
            if orig.find(self.active_button_markup[0])==0:
                lab.set_label(orig[len(self.active_button_markup[0]):(- len(self.active_button_markup[1]))])
        self.emit('label-changed')
        self.__toggling__ = False

    def make_missing_label (self):
        hb = gtk.HBox()
        l=gtk.Label()
        self.missingLabelLabel = l        
        l.set_alignment(0,0.5)
        b = gtk.Button(stock=gtk.STOCK_EDIT)
        hb.pack_start(l)
        hb.pack_start(b)
        b.connect('clicked',self.solidify_vapor_cb)
        b.show(),l.show(),hb.show()
        self.edit_missing_button = b
        return hb

    def set_missing_label_text (self,missing,total):
        self.missingLabelLabel.set_markup(
            '<span color="red" style="italic">' +\
            _('''Missing nutritional information\nfor %(missing)s of %(total)s ingredients.''')%locals()+\
            '</span>')
        if missing==0:
            self.missingLabelLabel.hide()
        else:
            self.missingLabelLabel.show()
        if missing==total: method = 'hide'
        else: method = 'show'
        getattr(self.main_table,method)()
        getattr(self.nutexpander,method)()        
        getattr(self.yieldLabel,method)()
        getattr(self.cal_per_day_box,method)()                
            
    def make_dv_boxes (self):
        dvLabel = gtk.Label()
        dvLabel.set_markup('<span weight="bold" size="small">' + \
                           _('% _Daily Value') + \
                           '</span>')
        dvLabel.set_use_underline(True)
        dvLabel.set_alignment(1,0.5)
        vb = gtk.VBox()
        hb = gtk.HBox()
        self.edit_button = gtk.ToggleButton()
        dvLabel.set_mnemonic_widget(self.edit_button)
        i = gtk.Image()
        i.set_from_stock(gtk.STOCK_EDIT,gtk.ICON_SIZE_MENU)
        self.edit_button.add(i)
        hb.pack_end(dvLabel,fill=False,expand=False)
        self.edit_button.set_alignment(1,0.5)
        hb.pack_end(self.edit_button,fill=False,expand=False,padding=6)
        self.edit_button.show_all()
        self.set_edit_tip()        
        self.edit_button.connect('clicked',self.toggle_edit_calories_per_day)
        hb.show_all()
        self.cpd_editor = gtk.HBox()
        cpd_ed_label = gtk.Label('<i>_'+'Calories per day:' + '</i>')
        cpd_ed_label.set_use_underline(True)
        cpd_ed_label.set_use_markup(True)
        self.cpd_editor.pack_start(cpd_ed_label,padding=12)
        cpd_ed_label.set_alignment(1,0.5)
        self.cpd_sb = gtk.SpinButton()
        self.cpd_sb.set_numeric(True)
        self.cpd_sb.connect('activate',
                            lambda *args: self.edit_button.set_active(False))
        self.cpd_sb.connect('value-changed',self.edit_calories_per_day)
        cpd_ed_label.set_mnemonic_widget(self.cpd_sb)
        adj = self.cpd_sb.get_adjustment()
        adj.lower,adj.upper=0,4000
        adj.step_increment,adj.page_increment = 50,500
        self.cpd_editor.pack_start(self.cpd_sb)
        cancelb = gtk.Button(stock=gtk.STOCK_CANCEL)
        #okb = gtk.Button(stock=gtk.STOCK_OK)
        #self.cpd_editor.pack_start(cancelb,padding=12)
        #self.cpd_editor.pack_start(okb,)
        #okb.connect('clicked',self.edit_calories_per_day)
        #cancelb.connect('clicked',lambda *args: self.cpd_editor.hide())
        return hb,self.cpd_editor

    def set_edit_tip (self):
        self.tt.set_tip(
            self.edit_button,
            _("Percentage of recommended daily value based on %i calories per day. Click to edit number of calories per day.")%self.calories_per_day
            )

    def toggle_edit_calories_per_day (self, b):        
        if b.get_active():
            self.cpd_sb.set_value(self.calories_per_day)
            self.cpd_editor.show_all()
            self.cpd_sb.grab_focus()
        else:
            self.edit_calories_per_day()
            self.cpd_editor.hide()

    def edit_calories_per_day (self, *args):
        self.cpd_sb.update()
        self.calories_per_day = self.cpd_sb.get_value()        
        self.update_display()
        self.set_edit_tip()
        self.emit('calories-changed')

    def set_yields (self, n, unit='servings'):
        self.yields = n
        self.yield_unit = unit
        self.setup_yield_label()
        #self.update_display()

    def set_nutinfo (self, nutinfo):
        """Set nutrition info from a nutrition info object.

        A nutinfo object has attributes with our relevant data.
        """
        self.nutinfo = nutinfo
        if len(self.nutinfo)==0:
            self.main_table.hide()
            self.nutexpander.hide()
            self.yieldLabel.hide()
            self.cal_per_day_box.hide()
            self.missingLabel.hide()
        else:
            self.update_display()
            vapor = self.nutinfo._get_vapor()
            if vapor:
                len(vapor)
                self.nutinfo.recursive_length()
                self.set_missing_label_text(
                    len(vapor),
                    self.nutinfo.recursive_length()
                    )
                self.missingLabel.show()
            else:
                self.main_table.show()
                self.nutexpander.show()
                self.yieldLabel.show()
                self.cal_per_day_box.show()
                self.missingLabel.hide()
                
    def update_display (self):
        """Update the display of labels based on values in nutinfo,
        adjusted by yields and calories_per_day.
        """
        for itm in self.nutrition_display_info:
            props = itm['props']
            if type(props)==str:
                rawval = getattr(self.nutinfo,props) or 0
            else:
                # sum a list of properties
                rawval = sum([getattr(self.nutinfo,p) or 0 for p in props])
            if self.yields:
                rawval = float(rawval) / self.yields
            if itm['type'] != MAJOR:
                # If the item is not "MAJOR", then we hide it if the
                # rawval is 0
                if rawval == 0:
                    itm['box'].hide()
                    if itm['percent_label']: itm['percent_label'].hide()
                else:
                    itm['box'].show()
                    if itm['percent_label']: itm['percent_label'].show()                
            if itm['unit_label']:
                itm['unit_label'].set_text('%i%s'%(rawval,itm['unit']))
            if itm['usda_rec_per_cal'] and itm['percent_label']:
                totrec = itm['usda_rec_per_cal']*self.calories_per_day
                if totrec:
                    percent = 100 * (float(rawval) / totrec)
                    itm['percent_label'].set_text("%i%%"%percent)

    def setup_yield_label (self):
        if self.custom_label:
            self.yieldLabel.set_markup('<b>'+self.custom_label+'</b>')
        elif self.yields:
            singular_unit = gourmet.defaults.get_pluralized_form(self.yield_unit,1)
            self.yieldLabel.set_markup('<b>'+_('Amount per %s'%singular_unit)+'</b>')
        else:
            self.yieldLabel.set_markup('<b>'+_('Amount per recipe')+'</b>')
        
    def set_nutritional_info (self, info):
        """Set nutrition from a NutritionInfo or NutritionInfoList object."""
        self.nutinfo = info
        self.update_display()
        
    def solidify_vapor_cb (self,*args):
        self.show_druid(fix_vapor=True)

    def show_druid (self, nd=None, fix_vapor=False):
        vapor = fix_vapor and self.nutinfo._get_vapor()
        if not nd:
            if vapor: nd=vapor[0].__nd__
            else:
                raise Exception("No nutritional database handed to us!")
        import nutritionDruid
        self.ndruid = nutritionDruid.NutritionInfoDruid(nd,
                                                        prefs=self.prefs,rec=self.rec)
        self.ndruid.connect('key-changed',lambda w,tpl: self.emit('ingredients-changed'))
        self.ndruid.connect('unit-changed',lambda w,tpl: self.emit('ingredients-changed'))
        if vapor:
            ings = [(v.__key__,[(v.__amt__,
                                 v.__unit__)]
                     ) for v in vapor]
            self.ndruid.add_ingredients(
                ings,
                )
        else:
            self.ndruid.setup_nutrition_index()
        self.ndruid.connect('finish',
                            self.update_nutinfo)
        self.ndruid.show()
        
    def update_nutinfo (self,*args):
        self.nutinfo._reset()
        self.update_display()
        vapor = self.nutinfo._get_vapor()
        if vapor:
            self.set_missing_label_text(len(vapor),len(self.nutinfo))
            self.missingLabel.show()
        else:
            self.missingLabel.hide()
        self.emit('ingredients-changed')

if __name__ == '__main__':
    import random
    class fakenut:

        __attdict__ = {}
        
        def __len__ (self): return 7
        
        def __getattr__ (self,n):
            if n=='has_vapor':
                return self.has_vapor
            if n=='_get_vapor':
                return self._get_vapor_
            if self.__attdict__.has_key(n):
                return self.__attdict__[n]
            elif n=='kcal':
                self.__attdict__[n]=self.carb*4+self.sugar*4+self.protein*4+self.famono*9+self.fasat*9
                return self.__attdict__[n]
            else:
                #n = random.randint(0,100)
                self.__attdict__[n]=random.randint(0,100)
                return self.__attdict__[n]

        def has_vapor (self): True

        def recursive_length (self): return self.__len__()

        def _get_vapor_ (self):
            return [('black pepper',[(1,'tsp.')]),
                    ('red pepper',[(1,''),
                                   (2,'c.')])]
        
    
    ni = fakenut()
    w = gtk.Window()
    nl = NutritionLabel({})
    vb=gtk.VBox()
    w.add(vb)
    hb = gtk.HBox()
    vb.pack_start(hb,expand=False,fill=False)
    hb.pack_start(nl,expand=False,fill=False)
    vb.show()
    b = gtk.Button('Test me')
    vb.add(b)
    nl.tt.set_tip(b,'What about this?')
    b.show()
    hb.show()
    #nl.set_yields(2)
    nl.set_nutinfo(ni)
    def display_info (w):
        print w.active_name,w.active_unit,w.active_label
    nl.connect('label-changed',display_info)
    nl.show()
    w.show()
    w.connect('delete-event',lambda *args: gtk.main_quit())
    gtk.main()
    
    

########NEW FILE########
__FILENAME__ = nutritionModel
import gtk, gobject
from gettext import gettext as _

class NutritionModel (gtk.TreeStore):
    """Handed ingredients and a nutritional database, display
    our nutritional information thus far."""
    AMOUNT_COL_HEAD = _("Amount")
    UNIT_COL_HEAD = _("Unit")
    ING_COL_HEAD = _("Ingredient")
    USDA_COL_HEAD = _("USDA Database Equivalent")
    UNKNOWN = _("Unknown")
    AMT_COL = 1
    UNIT_COL = 2
    ING_COL = 3
    USDA_COL = 4
    def __init__ (self, ings, nd):
        gtk.TreeStore.__init__(self,gobject.TYPE_PYOBJECT,str,str,str,str)
        self.nd = nd
        self.ings = ings
        map(self.add_ingredient,self.ings)
        
    def add_ingredient (self, ing):
        r=self.nd.get_key(ing.ingkey)
        if r: desc=r.desc
        else: desc = self.UNKNOWN
        self.append(None,[ing,str(ing.amount),ing.unit,str(ing.item),desc])        

########NEW FILE########
__FILENAME__ = nutritionView
import gtk, gobject
import re, string
from nutritionModel import NutritionModel
import parser_data
import gourmet.cb_extras as cb
import gourmet.dialog_extras as de
import gourmet.gglobals as gglobals
import gourmet.convert as convert
from gourmet.defaults import lang as defaults

class NutritionTable:
    """Handed a table (so we can steal it from glade), we pack it full
    of nutritional information."""
    def __init__ (self, table, prefs, default_editable=True):
        self.prefs = prefs
        self.table = table
        self.fields = prefs.get('nutritionFields',
                                # default nutritional fields
                                ['kcal','protein','carb','fiber',
                                 'calcium','iron','sodium',
                                 'fasat','famono','fapoly','cholestrl'])
        self.mnemonics=[]
        self.cells = {}
        self.pack_table()
        self.set_editable(default_editable)
        self.table.show_all()

    def set_nutrition_object (self, obj, multiply_by=None):
        # we want an object that has nutritionFields as attributes.
        # In our metakit-ish world, that means we really are going to
        # be getting a row of our nutrition database as an object, whose
        # attributes represent fields.
        for attr,widgets in self.cells.items():
            val=getattr(obj,attr)
            # if we're multiplying and this is an attribute that needs to be multiplied...
            if multiply_by and attr in parser_data.PER_100_GRAMS:
                val = val * multiply_by
            for w in widgets: w.set_text("%s"%val)

    def set_editable (self, value):
        if value:
            for widgets in self.cells.values():
                widgets[0].show()
                widgets[1].hide()
        else:
            for widgets in self.cells.values():
                widgets[1].show()
                widgets[0].hide()

    def pack_table (self):        
        for n,f in enumerate(self.fields):
            lname = parser_data.NUT_FIELDNAME_DICT[f]
            label = gtk.Label()
            # we somewhat hackishly attempt to create a mnemonic
            lab = self.create_mnemonic(lname)
            label.set_text_with_mnemonic(lab+":")
            # We might eventually want to make this into SpinButtons, since they
            # are numbers, but I find too many SpinButtons annoying :)
            entr = gtk.Entry()
            label.set_mnemonic_widget(entr)
            lab2 = gtk.Label()
            self.cells[f]=(entr,lab2) # so we can get back at this widget
            self.table.attach(label,0,1,n,n+1)
            self.table.attach(entr,1,2,n,n+1)
            self.table.attach(lab2,2,3,n,n+1)

    def create_mnemonic (self, txt):
        """Create a mnemonic for txt, trying not to use the same
        mnemonic twice."""
        for n,char in enumerate(txt):
            if char.strip() and not char in self.mnemonics:
                self.mnemonics.append(char)
                return txt[0:n]+"_"+txt[n:]
        else:
            # if we must, go ahead and use the same mnemonic twice
            return "_" + txt
                

class NutritionItemView:
    def __init__ (self,
                  nd,
                  usdaChoiceWidget,
                  ingredientWidget,
                  amountWidget,
                  unitChoiceWidget,
                  descChoiceWidget,
                  currentAmountWidget,
                  infoTable,
                  amountLabel=None,
                  unitChoiceLabel=None,
                  descChoiceLabel=None,
                  ):
        self.nd = nd
        self.choices = {}
        self.usdaChoiceWidget=usdaChoiceWidget
        self.ingredientWidget=ingredientWidget
        self.amountWidget = amountWidget
        self.amountLabel = amountLabel
        self.unitChoiceWidget=unitChoiceWidget
        self.descChoiceWidget=descChoiceWidget
        self.currentAmountWidget = currentAmountWidget
        self.unitChoiceLabel=unitChoiceLabel
        self.descChoiceLabel=descChoiceLabel
        #self.ingredientWidget.connect('changed',self.set_ingredient_from_keybox)
        self.usdaChoiceWidget.connect('changed',self.usdaChangedCB)
        self.unitChoiceWidget.connect('changed',self.amountChangedCB)
        self.amountWidget.connect('changed',self.amountChangedCB)
        self.descChoiceWidget.connect('changed',self.amountChangedCB)
        self.infoTable = infoTable
        self.amount=100
        self.unit = 'g.'

    def set_unit_visibility (self, visible):
        if visible:
            self.amountWidget.show()
            self.unitChoiceWidget.show()
            if self.unitChoiceLabel: self.unitChoiceLabel.show()
            if self.amountLabel: self.amountLabel.show()
        else:
            self.unitChoiceWidget.hide()
            self.amountWidget.hide()
            if self.unitChoiceLabel: self.unitChoiceLabel.hide()
            if self.amountLabel: self.amountLabel.hide()
            self.set_desc_visibility(False)
        
    def set_desc_visibility (self, visible):
        if visible:
            self.descChoiceWidget.show()
            if self.descChoiceLabel: self.descChoiceLabel.show()
        else:
            self.descChoiceWidget.hide()
            if self.descChoiceLabel: self.descChoiceLabel.hide()
            
    #def set_ingredient_from_keybox (self,*args):
    #    ing = self.ingredientWidget.get_text()
    #    self.set_ingredient(ing)

    def set_nutref (self, nutrow):
        nutchoices = self.choices.get(self.usdaChoiceWidget) or []
        if nutrow.desc in nutchoices:
            self.set_choice(self.usdaChoiceWidget,nutrow.desc)
        else:
            self.setup_chocies([nutrow.desc]+nutchoices, self.usdaChoiceWidget)
            self.set_choice(nutrow.desc)

    def set_ingredient (self, ing):
        """Handed an ingredient object, we set up our other widgets
        to let the user choose nutritional information."""
        self.ingkey=ing
        self.currentAmountWidget.set_text("%s %s"%(self.amount,self.unit))
        self.setup_usda_choices(ing)
        self.setup_unit_boxes(ing)

    def setup_unit_boxes (self, ing=None, nutrow=None):
        self.densities,self.extra_units = self.nd.get_conversions(row=nutrow,key=ing)
        self.setup_choices(self.densities.keys(),self.descChoiceWidget)
        units = defaults.WEIGHTS[0:]
        if self.densities: units += defaults.VOLUMES[0:]
        if self.extra_units: units = self.extra_units.keys() + units
        self.setup_choices(units,self.unitChoiceWidget)
        for k in self.densities.keys():
            if k:
                # if we have a key that's not none, then we actually need a descChoiceWidget
                self.setup_choices(self.densities.keys(),self.descChoiceWidget)
                if self.densities.has_key(None):
                    self.set_choice(self.descChoiceWidget,None)
                else:
                    self.set_choice(self.descChoiceWidget,k)
                self.set_desc_visibility(True)
                return
        # if we didn't find any density choices, then we don't need our description widget
        self.set_desc_visibility(False)
        self.setup_choices(None,self.descChoiceWidget)

    def setup_usda_choices (self, ing):
        self.ingkey=ing
        nutrow = self.nd.get_nutinfo(self.ingkey)
        if nutrow:
            self.choices[self.usdaChoiceWidget]=[nutrow]
            self.setup_choices([nutrow],self.usdaChoiceWidget)
            self.set_choice(self.usdaChoiceWidget,nutrow)
            return
        lst = self.nd.get_usda_list_for_string(ing)
        self.usdaDict={}
        for l in lst: self.usdaDict[l[0]]=l[1]
        self.choices[self.usdaChoiceWidget]=[x[0] for x in lst]
        self.setup_choices(self.choices[self.usdaChoiceWidget],self.usdaChoiceWidget)
        
    def get_active_usda (self):
        return cb.cb_get_active_text(self.usdaChoiceWidget)

    def get_multiplier (self, *args):
        d=None
        # Grab our density (either the default density for the food, or the density for the
        # user-selected description, such as chopped, sliced, etc).
        if self.densities.has_key(None) or self.densities and self.get_choice(self.descChoiceWidget):
            d=self.densities[self.get_choice(self.descChoiceWidget) or None]
        multiplier=self.nut and self.nd.convert_amount(self.amount,
                                                       self.unit,
                                                       d)
        if multiplier:
            self.set_unit_visibility(False) # if we don't need unit info, don't show it
            return multiplier
        elif self.nut: #if we just need the right unit, see if the user has entered an equivalent...
            # otherwise, we do need unit info, keep it visible
            self.set_unit_visibility(True)
            try:
                amt = convert.frac_to_float(self.amountWidget.get_text())
            except:
                # if there's not a number in Amt, we want to grab it
                self.amountWidget.grab_focus()
                return
            else:
                unit = self.get_choice(self.unitChoiceWidget)
                if self.extra_units.has_key(unit):
                    return self.nd.convert_amount(amt*self.extra_units[unit],'g.')
                else:
                    return self.nd.convert_amount(amt,unit,d)

    def usdaChangedCB (self, *args):
        usda_choice = self.get_active_usda()
        ndbno = self.usdaDict[usda_choice]
        self.nut = self.nd.db.nutrition_table.select({'ndbno':ndbno})[0]
        self.setup_unit_boxes(nutrow=self.nut)
        self.set_amount()

    def amountChangedCB (self, *args):
        self.set_amount()

    def set_amount (self):
        multiplier = self.get_multiplier()
        if not multiplier:
            #self.unitLabel="%s %s = "%(self.amount,self.unit)
            #self.unitEntry="?"
            self.currentAmountWidget.set_text("%s %s (? grams)"%(self.amount,self.unit))
        else:
            self.currentAmountWidget.set_text("%s %s (%s grams)"%(self.amount,self.unit,
                                                                  multiplier*100))            
        self.infoTable.set_nutrition_object(self.nut,multiplier)

    def get_new_conversion (self, *args):
        unit=self.get_choice(self.unitChoiceWidget)
        amt = self.amountWidget.get_text()
        try:
            amt = float(amt)
        except:
            de.show_message(label='Invalid Amount',sublabel='Amount %s is not a number.'%amt)
            self.amountWidget.grab_focus()
        self.amount=amt
        self.unit = unit
        self.usdaChangedCB()

    def setup_choices (self, choices, choiceWidget):
        """Given a list of choices, we setup widget choiceWidget
        to offer those choices to user. By subclassing and overriding
        this method, we can let subclasses use any method they like
        to offer choices

        This function can also be handed None instead of choices, in which
        case there is no meaningful choice for the user to make"""
        # make sure there's no current model
        self.choices[choiceWidget]=choices
        choiceWidget.set_model(None)
        if choices:
            cb.set_model_from_list(choiceWidget,choices,expand=False)
        else:
            cb.set_model_from_list(choiceWidget,[None])
        
    def get_choice (self, choiceWidget):
        """Return the user's current choice from choiceWidget"""
        return cb.cb_get_active_text(choiceWidget)

    def set_choice (self, choiceWidget, choice):
        return cb.cb_set_active_text(choiceWidget,choice)


class NutritionCardView:
    def __init__ (self, recCard):
        self.rc = recCard
        import nutritionGrabberGui        
        nutritionGrabberGui.check_for_db(self.rc.rg.rd)
        self.nmodel = NutritionTreeModel(
            self.get_nd(),
            nutrition_fields=self.rc.prefs.get('nutritionFields',
                                               # default nutritional fields
                                               ['kcal','protein','carb','fiber',
                                                'calcium','iron','sodium',
                                                'fasat','famono','fapoly','cholestrl'])
            )
        self.nmodel.attach_treeview(self.rc.ui.get_object('nutTreeView'))
        self.ings = self.rc.rg.rd.get_ings(self.rc.current_rec)
        for i in self.ings: self.nmodel.add_ingredient(i)
        NutritionCardViewOld(recCard) # initialize our old interface as well...
        
    def get_nd (self):
        if hasattr(self.rc.rg,'nutritionData'): return self.rc.rg.nutritionData
        else:
            import nutrition
            self.rc.rg.nutritionData = nutrition.NutritionData(self.rc.rg.rd,self.rc.rg.conv)
            return self.rc.rg.nutritionData

class NutritionCardViewOld:

    """We handle the nutritional portion of our recipe card interface."""

    ING_COL = 0
    NUT_COL = 1
    STR_COL = 2
    
    def __init__ (self, recCard):
        import nutritionGrabberGui        
        self.rc = recCard
        self.ings = self.rc.rg.rd.get_ings(self.rc.current_rec)
        nutritionGrabberGui.check_for_db(self.rc.rg.rd)
        # grab our widgets
        self.treeview = self.rc.ui.get_object('nutritionTreeView')
        self.treeview.set_property('headers-visible',False)
        self.treeview.set_property('search-column',self.STR_COL)
        #self.expander = self.rc.ui.get_object('nutritionExpander')
        nutTable = self.rc.ui.get_object('nutritionTable')
        self.usdaExpander = self.rc.ui.get_object('usdaExpander')
        self.nutTable = NutritionTable(nutTable,self.rc.prefs)
        self.keyBox = self.rc.ui.get_object('nutritionKeyBox')
        self.keyBox.entry = self.keyBox.get_children()[0]
        self.usdaCombo = self.rc.ui.get_object('nutritionUSDACombo')
        self.UnitLabel = self.rc.ui.get_object('nutUnitLabel')
        self.UnitEntry = self.rc.ui.get_object('nutUnitEntry')
        self.UnitCombo = self.rc.ui.get_object('nutUnitCombo')
        self.applyButton = self.rc.ui.get_object('nutritionApplyButton')
        self.applyButton.connect('clicked',self.applyCB)
        self.customizeButton = self.rc.ui.get_object('nutritionCustomizeButton')
        self.radioManual = self.rc.ui.get_object('nutMethod')
        self.radioCalc = self.rc.ui.get_object('nutMethodCalcButton')
        self.radioUSDA = self.rc.ui.get_object('nutMethodLookupButton')
        self.radioManual.connect('toggled',self.nutMethodCB)
        self.niv = NutritionItemView(
            self.get_nd(),
            self.usdaCombo,
            self.keyBox.entry,
            self.rc.ui.get_object('nutAmountEntry'),
            self.UnitCombo,
            self.rc.ui.get_object('nutDescBox'),
            self.rc.ui.get_object('nutCurrentUnitLabel'),
            self.nutTable,
            amountLabel=self.rc.ui.get_object('nutAmountLabel'),
            unitChoiceLabel=self.rc.ui.get_object('nutUnitLabel'),
            descChoiceLabel=self.rc.ui.get_object('nutDescLabel'),
            )
        # self.nmodel = NutritionModel(self.rc.ings,self.get_nd()) # no longer use this
        # build our ingredient/nutrition model for our treeview
        self.setup_nmodel()
        self.setup_treeview_columns()
        self.treeview.set_model(self.nmodel)
        # setup treeview callback for selection change
        self.treeviewsel = self.treeview.get_selection()
        self.treeviewsel.set_mode(gtk.SELECTION_SINGLE)
        self.treeviewsel.connect('changed',self.selectionChangedCB)
        self.multiplier = None
        self.nutcombo_set = None

    def setup_nmodel (self):
        # make sure we have an ingredient list
        if not hasattr(self.rc,'ings'):
            self.rc.create_ing_alist()        
        self.nmodel = gtk.ListStore(gobject.TYPE_PYOBJECT,
                                    gobject.TYPE_PYOBJECT,
                                    str)
        self.nmodel.append([None,None,"Recipe"])
        for i in self.rc.ings:
            aliasrow=self.get_nd().get_key(i.ingkey)
            if aliasrow:
                nut_row = self.rc.rg.rd.nutrition_table.select({'ndbno':aliasrow.ndbno})
            else:
                nut_row = None
            self.nmodel.append([i,nut_row,i.ingkey])
        

    def setup_treeview_columns (self):
        for n in [self.STR_COL]:
            rend = gtk.CellRendererText()
            col = gtk.TreeViewColumn("",rend,text=n)
            col.set_reorderable(True)
            col.set_resizable(True)
            self.treeview.append_column(col)
        
    def get_nd (self):
        if hasattr(self.rc.rg,'nutritionData'): return self.rc.rg.nutritionData
        else:
            import nutrition
            self.rc.rg.nutritionData = nutrition.NutritionData(self.rc.rg.rd,self.rc.rg.conv)
            return self.rc.rg.nutritionData

    def selectionChangedCB (self, *args):
        mod,itr = self.treeviewsel.get_selected()        
        self.ing=mod.get_value(itr,self.ING_COL)
        self.nut = mod.get_value(itr,self.NUT_COL)        
        if not self.ing or self.nut:
            # then this is the recipe that's been selected!
            self.radioCalc.show()
            self.radioUSDA.hide()
            self.usdaExpander.hide()
            return
        else:
            self.radioCalc.hide()
            self.radioUSDA.show()            
            #if not self.nutcombo_set==self.ing:
            #    self.niv.setup_usda_choices(self.ing.ingkey)
            #    self.nutcombo_set=self.ing
            self.usdaExpander.set_expanded(True)
        if self.nut:
            self.setup_usda_box()            
            self.radioUSDA.set_active(True)
        else:
            self.radioManual.set_active(True)
        self.keyBox.entry.set_text(self.ing.ingkey)        
            
    def setup_usda_box (self):          
        self.niv.amount=self.ing.amount
        self.niv.unit=self.ing.unit
        self.niv.set_ingredient(self.ing.ingkey)
        if self.nut:
            self.niv.set_nutref(nutrow)

    def setup_keybox (self, ing):
        self.keyBox.set_model(self.rc.rg.inginfo.key_model.filter_new())
        self.keyBox.set_text_column(0)        
        curkey = self.keyBox.entry.get_text()
        keys = self.rc.rg.rd.key_search(ing.item)
        mod=self.keyBox.get_model()
        if keys:
            def vis (m, iter):
                x = m.get_value(iter,0)
                if x and x in keys: return True
            mod.set_visible_func(vis)
        else:
            mod=set_visible_func(lambda *args: True)
        mod.refilter()
        if len(self.keyBox.get_model()) > 6:
            self.keyBox.set_wrap_width(2)
            if len(self.keyBox.get_model()) > 10:
                self.keyBox.set_wrap_width(3)
        cb.setup_completion(self.keyBox)


    def nutMethodCB (self, widget, *args):
        # our widget is the "manual" widget
        if widget.get_active():
            self.usdaExpander.set_expanded(False)
            self.usdaExpander.set_sensitive(False)
            self.nutTable.set_editable(True)            
        else:
            self.usdaExpander.set_sensitive(True)
            self.setup_usda_box()
            self.usdaExpander.set_expanded(True)
            self.nutTable.set_editable(False)
            
            
    def applyCB (self,*args):
        # ADD SOMETHING HERE TO CALL A "SAVE" type method on our NIV
        # now update our model
        # grab our new conversion
        self.niv.get_new_conversion()
        nmod,itr = self.treeviewsel.get_selected()
        # set our new key
        ing=nmod.get_value(itr,self.ING_COL)
        # (make undoable!)
        #self.rc.rg.rd.undoable_modify_ing(ing,{'ingkey':key},self.rc.history)
        row = self.rc.rg.rd.nutrition_table.select({'ndbno':ndbno})[0]
        nmod.set_value(itr,self.NUT_COL,row)
        #nmod.set_value(itr,self.STR_COL,key)

class NutritionTreeModel (gtk.TreeStore):
    """Display our nutritional information in a simple tree model.

    > Ingredient-Name | Ingredient-Key | USDA-NAME | AMT | UNIT | Grams |
       > NUTINFO | VALUE
       > NUTINFO | VALUE
       > ...

       """

    ING_OBJECT_COLUMN = 0

    def __init__ (self,
                  nutritionData,
                  ingredient_info=['ingkey','amount','unit'],
                  nutrition_fields=['kcal','protein','carb','fasat','famono','fapoly','cholestrl'],
                  ):
        self.nd = nutritionData
        self.columns = ingredient_info + ['USDA','grams']
        self.numerics = ['amount','grams']
        self.build_store()
        self.nutrition_fields = nutrition_fields
        
    def build_store (self):
        n = self.ING_OBJECT_COLUMN
        self.ts_col_dic = {}
        self.coltypes = [gobject.TYPE_PYOBJECT] # for our ingobject
        for c in self.columns:
            n += 1
            if c in self.numerics: self.coltypes += [str] # everything's a string
            else: self.coltypes += [str]
            self.ts_col_dic[c]=n
        self.ts = gtk.TreeStore.__init__(self,*self.coltypes)

    def attach_treeview (self, treeview):
        self.tv = treeview
        self.tv.set_model(self)
        text_renderer = gtk.CellRendererText()
        text_renderer.set_property('editable',True)
        for col in self.columns:
            # not yet i18n'd
            if col=='USDA':                
                rend = gtk.CellRendererCombo()
                self.usda_model = gtk.ListStore(str,str)
                rend.set_property('model',self.usda_model)
                rend.set_property('text-column',0)
                rend.set_property('editable',True)
                rend.connect('editing-started',self.usda_editing_started_cb)
                rend.connect('edited',self.usda_edited_cb)
                col=gtk.TreeViewColumn(col,rend,text=self.ts_col_dic[col])
            else:
                col=gtk.TreeViewColumn(col,text_renderer,text=self.ts_col_dic[col])
            col.set_reorderable(True)
            col.set_resizable(True)
            self.tv.append_column(col)
        self.tv.connect('row-expanded',self.populateChild)
        
    def add_ingredient (self, ing):
        base_list = [self.grab_attr(ing,name) for name in self.columns]
        itr=self.append(None,[ing]+base_list)
        self.append(itr)

    def populateChild (self, tv, iter, path):
        child = self.iter_children(iter)
        if self.get_value(child, 0)==None:
            self.remove(child) # remove the blank...
            self.append_nutritional_info(iter)

    def append_nutritional_info (self,iter):
        """Handed an treestore iter, append nutritional information."""
        ing = self.get_value(iter,self.ING_OBJECT_COLUMN)
        nut = self.nd.get_nutinfo(ing.ingkey)
        for fld in self.nutrition_fields:
            append_vals = [None] * (len(self.columns) + 1)
            append_vals[1]=fld
            if nut: append_vals[2]=getattr(nut,fld)
            self.append(iter,append_vals)

    def grab_attr (self, ing, name):
        if name in gglobals.ING_ATTRS.keys():
            attval =  getattr(ing,name)
            if name in self.numerics:
                return convert.float_to_frac(attval)
            else:
                return attval
        elif name=='USDA':
            nutrow=self.nd.get_nutinfo(ing.ingkey)
            if nutrow: return nutrow.desc
            else: return None
        elif name=='grams':
            #nutrow=self.nd.get_nutinfo(ing.ingkey)
            #densities,extra_units=self.nd.get_conversions(nutrow)
            amt = self.nd.get_conversion_for_amt(ing.amount,
                                                 ing.unit,
                                                 ing.ingkey
                                                 
                                                 )
            if amt: return 100 * amt
            else:
                return 0

    def usda_editing_started_cb (self,renderer,editable,path_string):
        indices = path_string.split(':')
        path = tuple( map(int, indices))
        itr = self.get_iter(path)
        ing = self.get_value(itr,self.ING_OBJECT_COLUMN)        
        if isinstance(editable,gtk.ComboBoxEntry):            
            while len(self.usda_model)>0: del self.usda_model[0] # empty our liststore...
            usda_list=self.nd.get_usda_list_for_string(ing.ingkey)
            self.usdaDict={}
            for l in usda_list:
                self.usdaDict[l[0]]=l[1]
                self.usda_model.append(l)

    def usda_edited_cb (self,renderer,path_string,text):
        indices = path_string.split(':')
        path = tuple( map(int, indices))
        itr = self.get_iter(path)
        ing = self.get_value(itr,self.ING_OBJECT_COLUMN)
        self.nd.set_key_from_ndbno(ing.ingkey,self.usdaDict[text])
        self.set_value(itr,self.ts_col_dic['USDA'],text)



if __name__ == '__main__':
    w = gtk.Window()
    f = gtk.Entry()
    b = gtk.Button(stock=gtk.STOCK_ADD)
    hb = gtk.HBox()
    hb.add(f)
    hb.add(b)
    vb = gtk.VBox()
    vb.add(hb)
    t = gtk.Table()
    nt = gtk.NutritionTable(t, {}, True)
    

########NEW FILE########
__FILENAME__ = parser_data
# Copyright Thomas M. Hinkle - 2005,2006 GNU GPL V.2

from gettext import gettext as _

PER_100_GRAMS = ["kcal","protein","lipid","ash","carb","fiber","sugar","calcium","iron","magnesium","phosphorus","potassium","sodium","zinc","copper","manganese","selenium","vitaminc","thiamin","riboflavin","niacin","pantoacid","vitaminb6","folatetotal","folateacid","foodfolate","folatedfe","vitb12","vitaiu","vitarae","retinol","vite","vitk","alphac","betac","betacrypt","lypocene","famono","fapoly","lutzea","fasat","cholestrl"]

# For the ABBREV FILE
NUTRITION_FIELDS = [
    #[description abbrev type]
    ["Nutrient Databank Number","ndbno","int"],
    ["Short Description","desc","char(100)"],
    [_("Water"),"water","float"],    
    [_("Kilocalories"),"kcal","float"],
    [_("g protein"),"protein","float"],
    [_("g lipid"),"lipid","float"],
    [_("g ash"),"ash","float"],
    [_("g carbohydrates"),"carb","float"],
    [_("g fiber"),"fiber","float"],
    [_("g sugar"),"sugar","float"],
    [_("mg calcium"),"calcium","float"],
    [_("mg iron"),"iron","float"],
    [_("mg magnesium"),"magnesium","float"],
    [_("mg phosphorus"),"phosphorus","float"],
    [_("mg potassium"),"potassium","float"],
    [_("mg sodium"),"sodium","float"],
    [_("mg zinc"),"zinc","float"],
    [_("mg copper"),"copper","float"],
    [_("mg manganese"),"manganese","float"],
    [_("microgram selenium"),"selenium","float"],
    [_("mg vitamin c"),"vitaminc","float"],
    [_("mg thiamin"),"thiamin","float"],
    [_("mg riboflavin"),"riboflavin","float"],
    [_("mg niacin"),"niacin","float"],
    [_("mg pantothenic acid"),"pantoacid","float"],
    [_("mg vitamin B6"),"vitaminb6","float"],
    [_("microgram Folate Total"),"folatetotal","float"],
    [_("microgram Folic acid"),"folateacid","float"],
    [_("microgram Food Folate"),"foodfolate","float"],
    [_("microgram dietary folate equivalents"),"folatedfe","float"],
    [_("Choline, total"),'choline','float'],
    [_("microgram Vitamin B12"),"vitb12","float"],
    [_("Vitamin A IU"),"vitaiu","float"],
    [_("Vitamin A (microgram Retinal Activity Equivalents"),"vitarae","float"],
    [_("microgram Retinol"),"retinol","float"],
    [_("microgram Alpha-carotene"),"alphac","float"],
    [_("microgram Beta-carotene"),"betac","float"],
    [_("microgram Beta Cryptoxanthin"),"betacrypt","float"],
    [_("microgram Lycopene"),"lypocene","float"],
    [_("microgram Lutein+Zeazanthin"),"lutzea","float"],
    [_("mg Vitamin E"),"vite","float"],
    [_("mg Vitamin K"),"vitk","float"],    
    [_("g Saturated Fatty Acid"),"fasat","float"],
    [_("g Monounsaturated Fatty Acids"),"famono","float"],
    [_("g Polyunsaturated Fatty Acids"),"fapoly","float"],
    [_("mg Cholesterol"),"cholestrl","float"],
    ["Gram Weight 1","gramwt1","float"],
    ["Gram Weight Description 1","gramdsc1","char(100)"],
    ["Gram Weight 2","gramwt2","float"],
    ["Gram Weight Description 2","gramdsc2","char(100)"],
    [_("Percent refuse"),"refusepct","float"],
    ]

# List of fields that can be sensibly added, multiplied, etc.
SUMMABLE_FIELDS = ['kcal',
                   'protein',
                   'lipid',
                   'ash',
                   'carb',
                   'cholestrl',
                   'fiber',
                   'calcium',
                   'iron',
                   'magnesium',
                   'phosphorus',
                   'potassium',
                   'sodium',
                   'zinc',
                   'manganese',
                   'selenium',
                   'copper',
                   'vitaminc',
                   'thiamin',
                   'riboflavin','pantoacid','niacin','folatetotal','foodfolate',
                   'vitb12',
                   'vitaminb6','folateacid','folatedfe','vitaiu','vitk','retinol',
                   'betac','lypocene',
                   'vitarae','vite','alphac','betacrypt','lutzea','famono',
                   'fapoly','fasat','sugar']

# a convenient dictionary to move from shortname to longname,
# for user interface.
NUT_FIELDNAME_DICT = {}
for longname,sname,field in NUTRITION_FIELDS:
    NUT_FIELDNAME_DICT[sname]=longname
    NUT_FIELDNAME_DICT[longname]=sname

ABBREVS = {'ALLPURP':'All Purpose',
           'AL':'Aluminum',
           '&':'And',
           'APPL':'Apple',
           'APPLS':'Apples',
           'APPLSAUC':'Applesauce',
           'APPROX':'Approximate',
           'APPROX':'Approximately',
           'ARM&BLD':'Arm and Blade',
           'ARM And BLD':'Arm and Blade',
           'ART':'Artificial',
           'VIT C':'Ascorbic Acid',
           'ASPRT':'Aspartame',
           'ASPRT-SWTND':'Aspartame-sweetened',
           'BABYFD':'Babyfood',
           'BKD':'Baked',
           'BBQ':'Barbequed',
           'BSD':'Based',
           'BNS':'Beans',
           'BF':'Beef',
           'BEV':'Beverage',
           'BLD':'Boiled',
           'BNLESS':'Boneless',
           'BTLD':'Bottled',
           'BTTM':'Bottom',
           'BRSD':'Braised',
           'BRKFST':'Breakfast',
           'BRLD':'Broiled',
           'BTTRMLK':'Buttermilk',
           'CA':'Calcium',
           'CAL':'Calorie, calories',
           'CND':'Canned',
           'CARB':'Carbonated',
           'CNTR':'Center',
           'CRL':'Cereal',
           'CHS':'Cheese',
           'CHICK':'Chicken',
           'CHOC':'Chocolate',
           'CHOIC':'Choice',
           'CHOL':'Cholesterol',
           'CHOL-FREE':'Cholesterol-free',
           'CHOPD':'Chopped',
           'CINN':'Cinnamon',
           'COATD':'Coated',
           'COCNT':'Coconut',
           'COMM':'Commercial',
           'COMMLY':'Commercially',
           'CMDTY':'Commodity',
           'COMP':'Composite',
           'CONC':'Concentrate',
           'CONCD':'Concentrated',
           'COND':'Condensed',
           'CONDMNT':'Condiment, condiments',
           'CKD':'Cooked',
           'CTTNSD':'Cottonseed',
           'CRM':'Cream',
           'CRMD':'Creamed',
           'DK':'Dark',
           'DECORT':'Decorticated',
           'DEHYD':'Dehydrated',
           'DSSRT':'Dessert, desserts',
           'DIL':'Diluted',
           'DOM':'Domestic',
           'DRND':'Drained',
           'DRSNG':'Dressing',
           'DRK':'Drink',
           'DRUMSTK':'Drumstick',
           'ENG':'English',
           'ENR':'Enriched',
           'EQ':'Equal',
           'EVAP':'Evaporated',
           'XCPT':'Except',
           'EX':'Extra',
           'FLANKSTK':'Flank steak',
           'FLAV':'Flavored',
           'FLR':'Flour',
           'FD':'Food',
           'FORT':'Fortified',
           'FRENCH FR':'French fried',
           'FRENCH FR':'French fries',
           'FRSH':'Fresh',
           'FRSTD':'Frosted',
           'FRSTNG':'Frosting',
           'FRZ':'Frozen',
           'GRDS':'Grades',
           'GM':'Gram',
           'GRN':'Green',
           'GRNS':'Greens',
           'HTD':'Heated',
           'HVY':'Heavy',
           'HI-MT':'Hi-meat',
           'HI':'High',
           'HR':'Hour',
           'HYDR':'Hydrogenated',
           'IMITN':'Imitation',
           'IMMAT':'Immature',
           'IMP':'Imported',
           'INCL':'Include, includes',
           'INCL':'Including',
           'INF FORMULA':'Infant formula',
           'ING':'Ingredient',
           'INST':'Instant',
           'JUC':'Juice',
           'JR':'Junior',
           'KRNLS':'Kernels',
           'LRG':'Large',
           'LN':'Lean',
           'LN':'Lean only',
           'LVND':'Leavened',
           'LT':'Light',
           'LIQ':'Liquid',
           'LO':'Low',
           'LOFAT':'Low Fat',
           'MARSHMLLW':'Marshmallow',
           'MSHD':'Mashed',
           'MAYO':'Mayonnaise',
           'MED':'Medium',
           'MESQ':'Mesquite',
           'MIN':'Minutes',
           'MXD':'Mixed',
           'MOIST':'Moisture',
           'NAT':'Natural',
           'NZ':'New Zealand',
           'NFDM':'Nonfat Dry Milk',
           'NFDMS':'Nonfat Dry Milk Solids',
           'NFMS':'Nonfat Milk Solids',
           'NONCARB':'Noncarbonated',
           'NFS':'Not Further Specified',
           'NUTR':'Nutrients',
           'NUTR':'Nutrition',
           'OZ':'Ounce',
           'PK':'Pack',
           'PAR FR':'Par fried',
           'PARBLD':'Parboiled',
           'PART':'Partial',
           'PART':'Partially',
           'PAR FR':'Partially fried',
           'PAST':'Pasteurized',
           'PNUT':'Peanut',
           'PNUTS':'Peanuts',
           'PO4':'Phosphate',
           'P':'Phosphorus',
           'PNAPPL':'Pineapple',
           'PLN':'Plain',
           'PRTRHS':'Porterhouse',
           'K':'Potassium',
           'PDR':'Powder',
           'PDR':'Powdered',
           'PRECKD':'Precooked',
           'PREHTD':'Preheated',
           'PREP':'Prepared',
           'PROC':'Processed',
           'PROD CD':'Product code',
           'PROP':'Propionate',
           'PROT':'Protein',
           'PUDD':'Pudding, puddings',
           'RTB':'Ready-to-bake',
           'RTC':'Ready-to-cook',
           'RTD':'Ready-to-drink',
           'RTE':'Ready-to-eat',
           'RTF':'Ready-to-feed',
           'RTH':'Ready-to-heat',
           'RTS':'Ready-to-serve',
           'RTU':'Ready-to-use',
           'RECON':'Reconstituted',
           'RED NA':'Reduced salt',
           'RED FAT':'Reduced fat',
           'RED CAL':'Reduced fat',           
           'RED-CAL':'Reduced-calorie',
           'REFR':'Refrigerated',
           'REG':'Regular',
           'REHTD':'Reheated',
           'REPLCMNT':'Replacement',
           'REST-PREP':'Restaurant-prepared',
           'RTL':'Retail',
           'RST':'Roast',
           'RSTD':'Roasted',
           'RND':'Round',
           'SNDWCH':'Sandwich',
           'SAU':'Sauce',
           'SCALLPD':'Scalloped',
           'SCRMBLD':'Scrambled',
           'SD':'Seed',
           'SEL':'Select',
           'SHK&SIRL':'Shank and sirloin',
           'SHK And SIRL':'Shank and sirloin',           
           'SHRT':'Short',
           'SHLDR':'Shoulder',
           'SIMMRD':'Simmered',
           'SKN':'Skin',
           'SML':'Small',
           'NA':'Sodium',
           'SOL':'Solids',
           'SOLN':'Solution',
           'SOYBN':'Soybean',
           'SPL':'Special',
           'SP':'Species',
           'SPRD':'Spread',
           'STD':'Standard',
           'STMD':'Steamed',
           'STWD':'Stewed',
           'STK':'Stick',
           'STKS':'Sticks',
           'STR':'Strained',
           'SUB':'Substitute',
           'SMMR':'Summer',
           'SUPP':'Supplement',
           'SWT':'Sweet',
           'SWTND':'Sweetened',
           'SWTNR':'Sweetener',
           'TSP':'Teaspoon',
           '1000':'Thousand',
           'TSTD':'Toasted',
           'TODD':'Toddler',
           'UNCKD':'Uncooked',
           'UNCRMD':'Uncreamed',
           'UNDIL':'Undiluted',
           'UNENR':'Unenriched',
           'UNHTD':'Unheated',
           'UNPREP':'Unprepared',
           'UNSPEC':'Unspecified',
           'UNSWTND':'Unsweetened',
           'VAR':'Variety, varieties',
           'VEG':'Vegetable, vegetables',
           'VIT A':'Vitamin A',
           'VIT C':'Vitamin C',
           'H20':'Water',
           'WHTNR':'Whitener',
           'WHL':'Whole',
           'WNTR':'Winter',
           'YEL':'Yellow',}

ABBREVS_STRT = {'W/':'with ',
                'WO/':'without ',
                '&':' and ',
                }

FOOD_GROUPS = {
    # the DB Food Group Numbers seem to be inline with the group IDs
    # (numbers > 1000 are in group 100, etc.)
    # Since that's true, we can use the following table to properly add groups.
    100:_('Dairy & Egg Products'),
    200:_('Spices & Herbs'),
    300:_('Baby Foods'),
    400:_('Fats and Oils'),
    500:_('Poultry'),
    600:_('Soups & Sauces'),
    700:_('Sausages & Lunch Meats'),
    800:_('Breakfast Cereals'),
    900:_('Fruits & Fruit Juices'),
    1000:_('Pork'),
    1100:_('Vegetables'),
    1200:_('Nuts & Seeds'),
    1300:_('Beef'),
    1400:_('Beverages'),
    1500:_('Fish & Shellfish'),
    1600:_('Legumes'),
    1700:_('Lamb, Veal & Game'),
    1800:_('Baked Products'),
    1900:_('Sweets'),
    2000:_('Grains and Pasta'),
    2100:_('Fast Foods'),
    2200:_('Meals, Entrees, and Sidedishes'),
    2500:_('Snacks'),
    3500:_('Ethnic Foods'),
    }

# A ranking of groups for use in sorting out categories...
RANKED_GROUPS = [
    'Dairy and Egg Products',
    'Spices and Herbs',
    'Fats and Oils',
    'Vegetables and Vegetable Products',
    'Legumes and Legume Products',
    'Nut and Seed Products',
    'Poultry Products',
    'Finfish and Shellfish Products',
    'Sausages and Luncheon Meats',
    'Fruits and Fruit Juices',
    'Pork Products',
    'Beef Products',
    'Soups, Sauces, and Gravies'
    'Beverages',
    'Baked Products',    
    'Meals, Entrees, and Sidedishes',
    'Fast Foods',
    'Baby Foods',]

# We're going to have to ditch the ABBREV file -- it's not as useful
# as we could be... we actually need to parse all the data files...

FOOD_DESC_FIELDS = [["Nutrient Databank Number","ndbno","int"],
                    ['Food Group Number','groupno','int'],
                    ['Long Description','long_description','char(200)'],
                    ['Short Description','short_description','char(60)'],
                    ['Common Name','common_name','char(100)'],
                    ['Manufacturer Name','manufacturer_name','char(50)'],
                    ['Survey','survey','bool'],
                    ['Refuse Description','ref_desc','char(60)'],
                    ['Percent refuse','refusepct','float'],
                    ['N_Factor','nfactor','float'],
                    ['Pro_Factor','pfactor','float'],
                    ['Fat_Factor','ffactor','float'],
                    ['CHO_Factor','cfactor','float']
                    ]

WEIGHT_FIELDS = [
    ["Nutrient Databank Number","ndbno","int"],
    ["Sequence Number",'seq','float'],
    ["Amount",'amount','float'],
    ['Measure Description','unit','char(80)'],
    ['Gram Weight','gramwt','float'],
    ['Data points','ndata','int'],
    ['Standard Deviation','stdev','float'],
    ]

########NEW FILE########
__FILENAME__ = reccard_plugin
from nutritionLabel import NutritionLabel
from nutrition import NutritionInfoList, NutritionVapor
#from gourmet.gglobals import gladeCustomHandlers
from gourmet.plugin import RecDisplayModule, RecDisplayPlugin
import gtk, pango
import os.path
from gettext import gettext as _

try:
    current_path = os.path.split(os.path.join(os.getcwd(),__file__))[0]
except:
    current_path = ''

class NutritionDisplayModule (RecDisplayModule):
    label = _('Nutrition')
    name = 'nutrition_display'
    #_custom_handlers_setup = False

    def __init__ (self, recipe_display):
        self.recipe_display = recipe_display
        self.nutritional_highlighting = True
        self.prefs = self.recipe_display.rg.prefs
        self.setup_ui()
        self.setup_ingredient_display_hooks()
        self.update_from_database()
        
    def update_from_database (self):
        self.nutinfo = self.recipe_display.rg.rd.nd.get_nutinfo_for_inglist(self.recipe_display.rg.rd.get_ings(self.recipe_display.current_rec),
                                                                            self.recipe_display.rg.rd)
        #print 'Set servings',self.recipe_display.current_rec.servings,type(self.recipe_display.current_rec.servings)
        self.nutritionLabel.set_yields(
            self.recipe_display.current_rec.yields,
            self.recipe_display.current_rec.yield_unit
                                       )
        self.nutritionLabel.set_nutinfo(self.nutinfo)
        self.nutritionLabel.rec = self.recipe_display.current_rec
        
    def setup_ui (self):
        #if not NutritionDisplayModule._custom_handlers_setup:
        #    gladeCustomHandlers.add_custom_handler('makeNutritionLabel',
        #                                           lambda *args: NutritionLabel(self.prefs)
        #                                           )
        #    NutritionDisplayModule._custom_handlers_setup = True
        self.ui = gtk.Builder()
        self.ui.add_from_file(os.path.join(current_path,'nut_recipe_card_display.ui'))
        self.ui.connect_signals(
            {'edit_nutrition': lambda *args: self.nutritionLabel.show_druid(nd=self.recipe_display.rg.rd.nd)}
            )
        self.nutritionLabel = self.ui.get_object('nutritionLabel')
        self.nutritionLabel.set_prefs(self.prefs)
        self.nutritionLabel.connect('ingredients-changed', self.ingredients_changed_cb)
        self.nutritionLabel.connect('label-changed',self.nutrition_highlighting_label_changed)
        self.main = self.ui.get_object('nutritionDisplay')
        self.main.unparent()

    def ingredients_changed_cb (self, *args):
        self.recipe_display.reccard.update_recipe(self.recipe_display.current_rec)
        
    def nutrition_highlighting_label_changed (self, *args):
        self.nutritional_highlighting = True
        self.recipe_display.prefs['nutrition_to_highlight'] = self.nutritionLabel.active_name
        self.recipe_display.ingredientDisplay.display_ingredients()
        
    def leave_page (self):
        self.nutritional_highlighting = False
        self.recipe_display.mult = self.mult_orig
        self.recipe_display.ingredientDisplay.display_ingredients()

    def enter_page (self):
        self.nutritional_highlighting = True
        if not self.nutritionLabel.active_name:
            if self.prefs.get('nutrition_to_highlight','kcal') in self.nutritionLabel.toggles:
                self.nutritionLabel.toggles[
                    self.prefs.get(
                        'nutrition_to_highlight','kcal')
                    ].activate()
        # Save what servings were and set them to "1" so that the
        # ingredient amounts display how much goes into each servings
        # (assuming there is a yield value)
        self.mult_orig = self.recipe_display.mult
        if self.recipe_display.current_rec.yields:
            self.recipe_display.mult = 1.0/self.recipe_display.current_rec.yields
        self.recipe_display.ingredientDisplay.display_ingredients()

    def setup_ingredient_display_hooks (self):
        self.ingredientDisplay = self.recipe_display.ingredientDisplay
        self.ingredientDisplay.markup_ingredient_hooks.append(self.nutritional_markup_hook)

    def nutritional_markup_hook (self, istr, ing, ing_index, group_index):
        if self.nutritional_highlighting and self.nutritionLabel.active_name:
            props = self.nutritionLabel.active_properties
            nutinfo_for_ing = None
            for ni in self.nutinfo:
                if ni.__ingobject__.id==ing.id:
                    nutinfo_for_ing = ni
                    break
            if nutinfo_for_ing is None: # if something is wrong...
                print 'Did not find nutritional info object for ingredient',ing
                print 'We did have...'
                for ni in self.nutinfo:
                    print ni.__ingobject__
                return istr
            if type(props)==str:
                nut_amt = getattr(nutinfo_for_ing,props)
                tot_amt = getattr(self.nutinfo,props)
            else:
                nut_amt = sum([getattr(nutinfo_for_ing,p) or 0 for p in props])
                tot_amt = sum([getattr(self.nutinfo,p) or 0 for p in props])
            if nut_amt:
                perc = float(nut_amt)/tot_amt
                if self.recipe_display.yields_orig: nut_amt = nut_amt/self.recipe_display.yields_orig
                label = self.nutritionLabel.active_unit
                if not self.nutritionLabel.active_unit:
                    label = self.nutritionLabel.active_label.lower()
                if int(nut_amt) or (nut_amt==int(nut_amt)):
                    nut_amt = "%i"%nut_amt
                else:
                    nut_amt = "%.2f"%nut_amt
                istr = istr + ' (%s %s)'%(nut_amt,label)
                faintest_yellow = 200
                color = "#%02x%02x%02x"%(255,255,
                                         faintest_yellow-int(faintest_yellow*(perc**2))
                                        )
                nut_highlighted = True
                weight = int(pango.WEIGHT_NORMAL + ((pango.WEIGHT_HEAVY - pango.WEIGHT_NORMAL) * perc))
                if color:
                    istr = '<span background="%s" foreground="black">'%color + istr + '</span>'
                if weight:
                    istr = '<span weight="%i">'%weight + istr + '</span>'
            if isinstance(nutinfo_for_ing,
                          NutritionVapor):
                istr = '<span foreground="red">'+istr+'</span>'
        return istr
        

class NutritionDisplayPlugin (RecDisplayPlugin):

    moduleKlass = NutritionDisplayModule




########NEW FILE########
__FILENAME__ = shopping_plugin
from gourmet.plugin import ShoppingListPlugin
import gtk
import gourmet.recipeManager, gourmet.GourmetRecipeManager
from gourmet.prefs import get_prefs
from nutritionLabel import NutritionLabel
import os.path
from gettext import gettext as _

class ShoppingNutritionalInfoPlugin (ShoppingListPlugin):

    ui_string = '''<ui>
    <menubar name="ShoppingListMenuBar">
      <menu name="Tools" action="Tools">
          <menuitem action="ShoppingNutritionalInfo"/>
      </menu>
    </menubar>
    <toolbar name="ShoppingListTopToolBar">
      <separator/>
      <toolitem action="ShoppingNutritionalInfo"/>
    </toolbar>
    </ui>
    '''
    name = 'shopping_nutritional_info'

    def setup_action_groups (self):
        self.nutritionShoppingActionGroup = gtk.ActionGroup('NutritionShoppingActionGroup')
        self.nutritionShoppingActionGroup.add_actions([
            ('Tools',None,_('Tools')),
            ('ShoppingNutritionalInfo', # name
             'nutritional-info', # stock
             _('Nutritional Information'), # label
             '<Ctrl><Shift>N', #key-command
             _('Get nutritional information for current list'),
             self.show_nutinfo # callback
             )
            ])
        self.action_groups.append(self.nutritionShoppingActionGroup)

    def show_nutinfo (self, *args):
        sg = self.pluggable
        rr = sg.recs
        rd = gourmet.recipeManager.get_recipe_manager()
        rg = gourmet.GourmetRecipeManager.get_application()
        if not hasattr(self,'nutrition_window'):
            self.create_nutrition_window()
        nutinfo = None
        # Add recipes...
        for rec in rr:
            ings = rd.get_ings(rec)
            ni = rd.nd.get_nutinfo_for_inglist(rd.get_ings(rec),
                                               rd)
            if nutinfo:
                nutinfo = nutinfo + ni
            else:
                nutinfo = ni
        # Add extras...
        for amt,unit,item in sg.extras:
            ni = rd.nd.get_nutinfo_for_item(item,amt,unit)
            if nutinfo:
                nutinfo = nutinfo + ni
            else:
                nutinfo = ni
        self.nl.set_nutinfo(nutinfo)
        self.nutrition_window.present()

    def create_nutrition_window (self):
        self.nutrition_window = gtk.Dialog(_('Nutritional Information'),
                            self.pluggable.w,
                            buttons=(gtk.STOCK_CLOSE,gtk.RESPONSE_CLOSE)
                            )
        self.nutrition_window.set_default_size(400,550)
        self.nutrition_window.set_icon(
            self.nutrition_window.render_icon('nutritional-info',
                                              gtk.ICON_SIZE_MENU)
            )
        self.nl = NutritionLabel(get_prefs())
        self.sw = gtk.ScrolledWindow(); self.sw.set_policy(gtk.POLICY_NEVER,gtk.POLICY_AUTOMATIC)
        self.sw.add_with_viewport(self.nl); self.sw.show()
        self.nutrition_window.vbox.pack_start(self.sw)
        self.nutrition_window.connect('response',self.response_cb)
        self.nutrition_window.connect('close',self.response_cb)
        self.nl.yieldLabel.set_markup('<b>'+_('Amount for Shopping List')+'</b>')
        self.nl.show()

    def response_cb (self, *args):
        # We only allow one response -- closing the window!
        self.nutrition_window.hide()
        
        

        
             

########NEW FILE########
__FILENAME__ = ipython_view
#!/usr/bin/python
'''
Provides IPython console widget.

@author: Eitan Isaacson
@organization: IBM Corporation
@copyright: Copyright (c) 2007 IBM Corporation
@license: BSD

All rights reserved. This program and the accompanying materials are made 
available under the terms of the BSD which accompanies this distribution, and 
is available at U{http://www.opensource.org/licenses/bsd-license.php}
'''

import gtk, gobject
import re
import sys
import os
import pango
from StringIO import StringIO

try:
  import IPython
except ImportError:
  IPython = None

class IterableIPShell:
  '''
  Create an IPython instance. Does not start a blocking event loop,
  instead allow single iterations. This allows embedding in GTK+ 
  without blockage.

  @ivar IP: IPython instance.
  @type IP: IPython.iplib.InteractiveShell
  @ivar iter_more: Indicates if the line executed was a complete command,
  or we should wait for more.
  @type iter_more: integer
  @ivar history_level: The place in history where we currently are 
  when pressing up/down.
  @type history_level: integer
  @ivar complete_sep: Seperation delimeters for completion function.
  @type complete_sep: _sre.SRE_Pattern
  '''
  def __init__(self,argv=[],user_ns=None,user_global_ns=None, 
               cin=None, cout=None,cerr=None, input_func=None):
    '''
    
    
    @param argv: Command line options for IPython
    @type argv: list
    @param user_ns: User namespace.
    @type user_ns: dictionary
    @param user_global_ns: User global namespace.
    @type user_global_ns: dictionary.
    @param cin: Console standard input.
    @type cin: IO stream
    @param cout: Console standard output.
    @type cout: IO stream 
    @param cerr: Console standard error.
    @type cerr: IO stream
    @param input_func: Replacement for builtin raw_input()
    @type input_func: function
    '''
    io = IPython.utils.io
    if input_func:
      IPython.frontend.terminal.interactiveshell.raw_input_original = input_func
    if cin:
      io.stdin = io.IOStream(cin)
    if cout:
      io.stdout = io.IOStream(cout)
    if cerr:
      io.stderr = io.IOStream(cerr)

    # This is to get rid of the blockage that accurs during 
    # IPython.Shell.InteractiveShell.user_setup()

    io.raw_input = lambda x: None

    os.environ['TERM'] = 'dumb'
    excepthook = sys.excepthook 

    from IPython.config.loader import Config
    cfg = Config()
    cfg.InteractiveShell.colors = "Linux"

    # InteractiveShell's __init__ overwrites io.stdout,io.stderr with
    # sys.stdout, sys.stderr, this makes sure they are right
    #
    old_stdout, old_stderr = sys.stdout, sys.stderr
    sys.stdout, sys.stderr = io.stdout.stream, io.stderr.stream

    # InteractiveShell inherits from SingletonConfigurable, so use instance()
    #
    self.IP = IPython.frontend.terminal.embed.InteractiveShellEmbed.instance(\
            config=cfg, user_ns=user_ns)

    sys.stdout, sys.stderr = old_stdout, old_stderr

    self.IP.system = lambda cmd: self.shell(self.IP.var_expand(cmd),
                                            header='IPython system call: ')
#                                            local_ns=user_ns)
                                            #global_ns=user_global_ns)
                                            #verbose=self.IP.rc.system_verbose)

    self.IP.raw_input = input_func
    sys.excepthook = excepthook
    self.iter_more = 0
    self.history_level = 0
    self.complete_sep =  re.compile('[\s\{\}\[\]\(\)]')
    self.updateNamespace({'exit':lambda:None})
    self.updateNamespace({'quit':lambda:None})
    self.IP.readline_startup_hook(self.IP.pre_readline)
    # Workaround for updating namespace with sys.modules
    #
    self.__update_namespace()

  def __update_namespace(self):
    '''
    Update self.IP namespace for autocompletion with sys.modules
    '''
    for k,v in sys.modules.items():
        if not '.' in k:
          self.IP.user_ns.update({k:v})

  def execute(self):
    '''
    Executes the current line provided by the shell object.
    '''
    self.history_level = 0

    # this is needed because some functions in IPython use 'print' to print
    # output (like 'who')
    #
    orig_stdout = sys.stdout
    sys.stdout = IPython.utils.io.stdout

    orig_stdin = sys.stdin
    sys.stdin = IPython.utils.io.stdin;
    self.prompt = self.generatePrompt(self.iter_more)

    self.IP.hooks.pre_prompt_hook()
    if self.iter_more:
        try:
            self.prompt = self.generatePrompt(True)
        except:
            self.IP.showtraceback()
        if self.IP.autoindent:
            self.IP.rl_do_indent = True

    try:
      line = self.IP.raw_input(self.prompt)
    except KeyboardInterrupt:
      self.IP.write('\nKeyboardInterrupt\n')
      self.IP.input_splitter.reset()
    except:
      self.IP.showtraceback()
    else:
      self.IP.input_splitter.push(line)
      self.iter_more = self.IP.input_splitter.push_accepts_more()
      self.prompt = self.generatePrompt(self.iter_more)
      if (self.IP.SyntaxTB.last_syntax_error and
          self.IP.autoedit_syntax):
          self.IP.edit_syntax_error()
      if not self.iter_more:
          source_raw = self.IP.input_splitter.source_raw_reset()[1]
          self.IP.run_cell(source_raw, store_history=True)
      else:
          # TODO: Auto-indent
          #
          pass

    sys.stdout = orig_stdout
    sys.stdin = orig_stdin

  def generatePrompt(self, is_continuation):
    '''
    Generate prompt depending on is_continuation value

    @param is_continuation
    @type is_continuation: boolean 

    @return: The prompt string representation
    @rtype: string

    '''

    # Backwards compatibility with ipyton-0.11
    #
    ver = IPython.__version__
    if '0.11' in ver:
        prompt = self.IP.hooks.generate_prompt(is_continuation)
    else:
        if is_continuation:
            prompt = self.IP.prompt_manager.render('in2')
        else:
            prompt = self.IP.prompt_manager.render('in')

    return prompt


  def historyBack(self):
    '''
    Provides one history command back.
    
    @return: The command string.
    @rtype: string
    '''
    self.history_level -= 1
    if not self._getHistory():
      self.history_level +=1
    return self._getHistory()
  
  def historyForward(self):
    '''
    Provides one history command forward.
    
    @return: The command string.
    @rtype: string
    '''
    if self.history_level < 0:
      self.history_level += 1
    return self._getHistory()
  
  def _getHistory(self):
    '''
    Get's the command string of the current history level.
    
    @return: Historic command string.
    @rtype: string
    '''
    try:
      rv = self.IP.user_ns['In'][self.history_level].strip('\n')
    except IndexError:
      rv = ''
    return rv

  def updateNamespace(self, ns_dict):
    '''
    Add the current dictionary to the shell namespace.
    
    @param ns_dict: A dictionary of symbol-values.
    @type ns_dict: dictionary
    '''
    self.IP.user_ns.update(ns_dict)

  def complete(self, line):
    '''
    Returns an auto completed line and/or posibilities for completion.
    
    @param line: Given line so far.
    @type line: string
    
    @return: Line completed as for as possible, 
    and possible further completions.
    @rtype: tuple
    '''
    split_line = self.complete_sep.split(line)
    if split_line[-1]:
      possibilities = self.IP.complete(split_line[-1])
    else:
      completed = line
      possibilities = ['',[]]
    if possibilities:
      def _commonPrefix(str1, str2):
        '''
        Reduction function. returns common prefix of two given strings.
        
        @param str1: First string.
        @type str1: string
        @param str2: Second string
        @type str2: string
        
        @return: Common prefix to both strings.
        @rtype: string
        '''
        for i in range(len(str1)):
          if not str2.startswith(str1[:i+1]):
            return str1[:i]
        return str1
      if possibilities[1]:
        common_prefix = reduce(_commonPrefix, possibilities[1]) or line[-1]
        completed = line[:-len(split_line[-1])]+common_prefix
      else:
        completed = line
    else:
      completed = line
    return completed, possibilities[1]
  

  def shell(self, cmd,verbose=0,debug=0,header=''):
    '''
    Replacement method to allow shell commands without them blocking.
    
    @param cmd: Shell command to execute.
    @type cmd: string
    @param verbose: Verbosity
    @type verbose: integer
    @param debug: Debug level
    @type debug: integer
    @param header: Header to be printed before output
    @type header: string
    '''
    stat = 0
    if verbose or debug: print header+cmd
    # flush stdout so we don't mangle python's buffering
    if not debug:
      input, output = os.popen4(cmd)
      print output.read()
      output.close()
      input.close()

class ConsoleView(gtk.TextView):
  '''
  Specialized text view for console-like workflow.

  @cvar ANSI_COLORS: Mapping of terminal colors to X11 names.
  @type ANSI_COLORS: dictionary

  @ivar text_buffer: Widget's text buffer.
  @type text_buffer: gtk.TextBuffer
  @ivar color_pat: Regex of terminal color pattern
  @type color_pat: _sre.SRE_Pattern
  @ivar mark: Scroll mark for automatic scrolling on input.
  @type mark: gtk.TextMark
  @ivar line_start: Start of command line mark.
  @type line_start: gtk.TextMark
  '''
  ANSI_COLORS =  {'0;30': 'Black',     '0;31': 'Red',
                  '0;32': 'Green',     '0;33': 'Brown',
                  '0;34': 'Blue',      '0;35': 'Purple',
                  '0;36': 'Cyan',      '0;37': 'LightGray',
                  '1;30': 'DarkGray',  '1;31': 'DarkRed',
                  '1;32': 'SeaGreen',  '1;33': 'Yellow',
                  '1;34': 'LightBlue', '1;35': 'MediumPurple',
                  '1;36': 'LightCyan', '1;37': 'White'}

  def __init__(self):
    '''
    Initialize console view.
    '''
    gtk.TextView.__init__(self)
    self.modify_font(pango.FontDescription('Mono'))
    self.set_cursor_visible(True)
    self.text_buffer = self.get_buffer()
    self.mark = self.text_buffer.create_mark('scroll_mark', 
                                             self.text_buffer.get_end_iter(),
                                             False)
    for code in self.ANSI_COLORS:
      self.text_buffer.create_tag(code, 
                                  foreground=self.ANSI_COLORS[code], 
                                  weight=700)
    self.text_buffer.create_tag('0')
    self.text_buffer.create_tag('notouch', editable=False)
    self.color_pat = re.compile('\x01?\x1b\[(.*?)m\x02?')
    self.line_start = \
        self.text_buffer.create_mark('line_start', 
                                     self.text_buffer.get_end_iter(), True)
    self.connect('key-press-event', self.onKeyPress)
    
  def write(self, text, editable=False):
    gobject.idle_add(self._write, text, editable)

  def _write(self, text, editable=False):
    '''
    Write given text to buffer.
    
    @param text: Text to append.
    @type text: string
    @param editable: If true, added text is editable.
    @type editable: boolean
    '''
    segments = self.color_pat.split(text)
    segment = segments.pop(0)
    start_mark = self.text_buffer.create_mark(None, 
                                              self.text_buffer.get_end_iter(), 
                                              True)
    self.text_buffer.insert(self.text_buffer.get_end_iter(), segment)

    if segments:
      ansi_tags = self.color_pat.findall(text)
      for tag in ansi_tags:
        i = segments.index(tag)
        self.text_buffer.insert_with_tags_by_name(self.text_buffer.get_end_iter(),
                                             segments[i+1], str(tag))
        segments.pop(i)
    if not editable:
      self.text_buffer.apply_tag_by_name('notouch',
                                         self.text_buffer.get_iter_at_mark(start_mark),
                                         self.text_buffer.get_end_iter())
    self.text_buffer.delete_mark(start_mark)
    self.scroll_mark_onscreen(self.mark)


  def showPrompt(self, prompt):
    gobject.idle_add(self._showPrompt, prompt)

  def _showPrompt(self, prompt):
    '''
    Prints prompt at start of line.
    
    @param prompt: Prompt to print.
    @type prompt: string
    '''
    self._write(prompt)
    self.text_buffer.move_mark(self.line_start,
                               self.text_buffer.get_end_iter())

  def changeLine(self, text):
    gobject.idle_add(self._changeLine, text)

  def _changeLine(self, text):
    '''
    Replace currently entered command line with given text.
    
    @param text: Text to use as replacement.
    @type text: string
    '''
    iter = self.text_buffer.get_iter_at_mark(self.line_start)
    iter.forward_to_line_end()
    self.text_buffer.delete(self.text_buffer.get_iter_at_mark(self.line_start), iter)
    self._write(text, True)

  def getCurrentLine(self):
    '''
    Get text in current command line.
    
    @return: Text of current command line.
    @rtype: string
    '''
    rv = self.text_buffer.get_slice(
      self.text_buffer.get_iter_at_mark(self.line_start),
      self.text_buffer.get_end_iter(), False)
    return rv

  def showReturned(self, text):
    gobject.idle_add(self._showReturned, text)

  def _showReturned(self, text):
    '''
    Show returned text from last command and print new prompt.
    
    @param text: Text to show.
    @type text: string
    '''
    iter = self.text_buffer.get_iter_at_mark(self.line_start)
    iter.forward_to_line_end()
    self.text_buffer.apply_tag_by_name(
      'notouch', 
      self.text_buffer.get_iter_at_mark(self.line_start),
      iter)
    self._write('\n'+text)
    if text:
      self._write('\n')
    self._showPrompt(self.prompt)
    self.text_buffer.move_mark(self.line_start,self.text_buffer.get_end_iter())
    self.text_buffer.place_cursor(self.text_buffer.get_end_iter())

  def onKeyPress(self, widget, event):
    '''
    Key press callback used for correcting behavior for console-like 
    interfaces. For example 'home' should go to prompt, not to begining of
    line.
    
    @param widget: Widget that key press accored in.
    @type widget: gtk.Widget
    @param event: Event object
    @type event: gtk.gdk.Event
    
    @return: Return True if event should not trickle.
    @rtype: boolean
    '''
    insert_mark = self.text_buffer.get_insert()
    insert_iter = self.text_buffer.get_iter_at_mark(insert_mark)
    selection_mark = self.text_buffer.get_selection_bound()
    selection_iter = self.text_buffer.get_iter_at_mark(selection_mark)
    start_iter = self.text_buffer.get_iter_at_mark(self.line_start)
    if event.keyval == gtk.keysyms.Home:
      if event.state & gtk.gdk.CONTROL_MASK or event.state & gtk.gdk.MOD1_MASK:
        pass
      elif event.state & gtk.gdk.SHIFT_MASK:
        self.text_buffer.move_mark(insert_mark, start_iter)
        return True
      else:
        self.text_buffer.place_cursor(start_iter)
        return True
    elif event.keyval == gtk.keysyms.Left:
      insert_iter.backward_cursor_position()
      if not insert_iter.editable(True):
        return True
    elif not event.string:
      pass
    elif start_iter.compare(insert_iter) <= 0 and \
          start_iter.compare(selection_iter) <= 0:
      pass
    elif start_iter.compare(insert_iter) > 0 and \
          start_iter.compare(selection_iter) > 0:
      self.text_buffer.place_cursor(start_iter)
    elif insert_iter.compare(selection_iter) < 0:
      self.text_buffer.move_mark(insert_mark, start_iter)
    elif insert_iter.compare(selection_iter) > 0:
      self.text_buffer.move_mark(selection_mark, start_iter)             

    return self.onKeyPressExtend(event)

  def onKeyPressExtend(self, event):
    '''
    For some reason we can't extend onKeyPress directly (bug #500900).
    '''
    pass

class IPythonView(ConsoleView, IterableIPShell):
  '''
  Sub-class of both modified IPython shell and L{ConsoleView} this makes
  a GTK+ IPython console.
  '''
  def __init__(self):
    '''
    Initialize. Redirect I/O to console.
    '''
    ConsoleView.__init__(self)
    self.cout = StringIO()
    IterableIPShell.__init__(self, cout=self.cout,cerr=self.cout, 
                             input_func=self.raw_input)
#    self.connect('key_press_event', self.keyPress)
    self.interrupt = False
    self.execute()
    self.prompt = self.generatePrompt(False)
    self.cout.truncate(0)
    self.showPrompt(self.prompt)

  def raw_input(self, prompt=''):
    '''
    Custom raw_input() replacement. Get's current line from console buffer.
    
    @param prompt: Prompt to print. Here for compatability as replacement.
    @type prompt: string
    
    @return: The current command line text.
    @rtype: string
    '''
    if self.interrupt:
      self.interrupt = False
      raise KeyboardInterrupt
    return self.getCurrentLine()

  def onKeyPressExtend(self, event):
    '''
    Key press callback with plenty of shell goodness, like history, 
    autocompletions, etc.
    
    @param widget: Widget that key press occured in.
    @type widget: gtk.Widget
    @param event: Event object.
    @type event: gtk.gdk.Event
    
    @return: True if event should not trickle.
    @rtype: boolean
    '''

    if event.state & gtk.gdk.CONTROL_MASK and event.keyval == 99:
      self.interrupt = True
      self._processLine()
      return True
    elif event.keyval == gtk.keysyms.Return:
      self._processLine()
      return True
    elif event.keyval == gtk.keysyms.Up:
      self.changeLine(self.historyBack())
      return True
    elif event.keyval == gtk.keysyms.Down:
      self.changeLine(self.historyForward())
      return True
    elif event.keyval == gtk.keysyms.Tab:
      if not self.getCurrentLine().strip():
        return False
      completed, possibilities = self.complete(self.getCurrentLine())
      if len(possibilities) > 1:
        slice = self.getCurrentLine()
        self.write('\n')
        for symbol in possibilities:
          self.write(symbol+'\n')
        self.showPrompt(self.prompt)
      self.changeLine(completed or slice)
      return True

  def _processLine(self):
    '''
    Process current command line.
    '''
    self.history_pos = 0
    self.execute()
    rv = self.cout.getvalue()
    if rv: rv = rv.strip('\n')
    self.showReturned(rv)
    self.cout.truncate(0)
    
if __name__ == "__main__":
  window = gtk.Window()
  window.set_default_size(640, 320)
  window.connect('delete-event', lambda x, y: gtk.main_quit())
  window.add(IPythonView())
  window.show_all()
  gtk.main()
    

########NEW FILE########
__FILENAME__ = shopping_key_editor_plugin
from gourmet.plugin import PluginPlugin
from gourmet.recipeManager import get_recipe_manager
import gtk
from gettext import gettext as _

class KeyEditorPlugin (PluginPlugin):

    target_pluggable = 'KeyEditorPlugin'
    title = _('Shopping Category')
    tvcs = {}
    ingkeys_to_change = {}
    
    selected_ingkeys = []
    
    def setup_treeview_column (self, ike, key_col, instant_apply=False):
        '''Set up a treeview column to display your data.

        The key_col is the column in the treemodel which will contain
        your data in the model. It\'s your responsibility to get
        whatever other data you need yourself.

        If you make this editable, it\'s up to you to apply the
        changes as well to the database. If instant_apply is True,
        then apply them instantly; if False, apply them when this
        class\'s save method is called.
        '''
        renderer = gtk.CellRendererCombo()
        renderer.connect('editing-started',self.start_edit_cb)
        renderer.connect('edited',self.key_edited_cb,(ike,key_col,instant_apply))
        # Build shopcat model...
        self.rd = get_recipe_manager()
        self.shopcat_model = gtk.ListStore(str)
        for val in self.rd.get_unique_values('shopcategory',table=self.rd.shopcats_table):
            if val: self.shopcat_model.append([val])
        renderer.set_property('model',self.shopcat_model)
        renderer.set_property('text-column',0)        
        renderer.set_property('editable',True)
        renderer.set_property('mode',gtk.CELL_RENDERER_MODE_EDITABLE)
        renderer.set_property('sensitive',True)        
        tvc = gtk.TreeViewColumn(self.title,renderer)
        tvc.set_cell_data_func(renderer,self.cell_data_func,key_col)
        self.tvcs[renderer] = tvc
        return tvc
        
    def cell_data_func (self, col, renderer, model, itr, key_col):
        if self.ingkeys_to_change.has_key(model[itr][key_col]):
            cat = self.ingkeys_to_change[model[itr][key_col]]
        else:
            shopcat_row = self.rd.fetch_one(self.rd.shopcats_table,
                                            ingkey=model[itr][key_col])
            if shopcat_row:
                cat = shopcat_row.shopcategory
            else:
                cat = ''
        renderer.set_property('text',cat)
        
    def start_edit_cb (self, renderer, cbe, path_string):
        if isinstance(cbe,gtk.ComboBoxEntry):
            entry = cbe.child
            completion = gtk.EntryCompletion()
            completion.set_model(self.shopcat_model)
            completion.set_text_column(0)
            entry.set_completion(completion)

    def key_edited_cb (self, renderer, path_string, new_text, extra_params):
        ike,ingkey_row,instant_apply = extra_params
        indices = path_string.split(':')
        path = tuple( map(int, indices))
        tvc = self.tvcs[renderer]
        tv = tvc.get_tree_view()
        model = tv.get_model()
        row = model[path]
        ingkey = row[ingkey_row].decode('utf-8')
        renderer.set_property('text',new_text)
        self.ingkeys_to_change[ingkey]=new_text
        if instant_apply:
            self.save()
        elif ike:
            ike.emit('toggle-edited',True)

    def apply_association (self, ingkey,val):
        row = self.rd.shopcats_table.select(self.rd.shopcats_table.c.ingkey==ingkey).execute().fetchone()
        if row:
            origval = row.shopcategory
            self.rd.do_modify(self.rd.shopcats_table,
                              row,
                              {'ingkey':ingkey,
                               'shopcategory':val},
                              id_col='ingkey')
            return ingkey,origval
        else:
            self.rd.do_add(self.rd.shopcats_table,
                           {'ingkey':ingkey,
                            'shopcategory':val}
                           )
            return ingkey,None
        
    def save (self):
        '''Save any data the user has entered in your treeview column.
        '''
        for ingkey,val in self.ingkeys_to_change.items():
            self.apply_association(ingkey,val)
        self.ingkeys_to_change = {}

    def offers_edit_widget (self):
        '''Return True if this plugin provides an edit button for
        editing data in some other window (if you need more than an
        editable cellrenderer to let users edit your data. 
        '''
        return True

    def setup_edit_widget (self):
        '''Return an edit widget to let users edit your data.
        '''
        self.cb = cb = gtk.ComboBoxEntry()
        cb.set_model(self.shopcat_model)
        cb.set_text_column(0)
        entry = cb.child
        completion = gtk.EntryCompletion()
        completion.set_model(self.shopcat_model)
        completion.set_text_column(0)
        entry.set_completion(completion)
        return cb

    def get_widget_val (self):
        return self.cb.child.get_text()

    def apply_widget_val (self):
        val = self.get_widget_val()
        if val:
            for ingkey in self.selected_ingkeys:
                self.apply_association(ingkey,val)
                
                
    def selection_changed (self, ingkeys):
        '''Selected ingkeys have changed -- currently ingkeys are
        selected (and should be acted on by our edit_widget
        '''
        self.selected_ingkeys = ingkeys

########NEW FILE########
__FILENAME__ = reccard_spellcheck_plugin
import gtk, gtkspell

from gourmet.plugin import RecEditorPlugin, UIPlugin

class SpellPlugin (RecEditorPlugin, UIPlugin):

    main = None

    ui_string = '''
    '''

    def activate (self, recEditor):
        UIPlugin.activate(self,recEditor)
        for module in self.pluggable.modules:
            tvs = harvest_textviews(module.main)
            for tv in tvs:
                gtkspell.Spell(tv)

def harvest_textviews (widget):
    if isinstance(widget,gtk.TextView):
        return [widget]
    else:
        tvs = []
        if hasattr(widget,'get_children'):
            for child in widget.get_children():
                tvs.extend(harvest_textviews(child))
        elif hasattr(widget,'get_child'):
            tvs.extend(harvest_textviews(widget.get_child()))
        return tvs


        

########NEW FILE########
__FILENAME__ = convertGui
import gourmet.convert as convert
import gtk
from gourmet.gdebug import debug
from gourmet.gtk_extras.cb_extras import cb_get_active_text, cb_set_active_text, setup_typeahead
import gourmet.GourmetRecipeManager
from gettext import gettext as _
import os

try:
    current_path = os.path.split(os.path.join(os.getcwd(),__file__))[0]
except:
    current_path = ''

class ConvGui:
    """This is a simple interface for the converter."""
    def __init__ (self, converter=convert.get_converter(),
                  unitModel=None,
                  amt1=None, unit1=None, item=None,
                  okcb=None
                  ):
        self.possible_conversions = None
        self.ui = gtk.Builder()
        self.ui.add_from_file(os.path.join(current_path,'converter.ui'))
        self.conv = converter
        self.changing_item = False
        self.okcb = okcb
        self.widget_names = ['window','amt1Entry', 'amt2Label', 'unit1ComboBox', 'unit2ComboBox',
                   'itemComboBox', 'densitySpinButton', 'useDensityCheckButton', 'statusbar','expander1','messageLabel']
        # grab all our widgets
        for w in self.widget_names:
            setattr(self,w,self.ui.get_object(w))
        # HACK FOR READABILITY w/o glade change
        self.resultLabel = self.amt2Label
        self.resultLabel.set_use_markup(True)
        self.resultLabel.set_line_wrap(True)
        if unitModel: self.unitModel=unitModel
        else: self.unitModel=gourmet.GourmetRecipeManager.UnitModel(self.conv)
        #self.unit2Model = self.unitModel.filter_new()
        self.unit1ComboBox.set_model(self.unitModel)
        self.unit1ComboBox.set_wrap_width(3)
        self.unit2ComboBox.set_wrap_width(3)        
        #self.unit2Model.set_visible_func(self.unit_filter)
        #self.unit2ComboBox.set_model(self.unit2Model)
        self.unit2ComboBox.set_model(self.unitModel)
        for combobox in [self.unit1ComboBox, self.unit2ComboBox]:
            cell = gtk.CellRendererText()            
            combobox.pack_start(cell, True)
            combobox.add_attribute(cell, 'text', 1)
            setup_typeahead(combobox)
        #self.itemComboBox.append_text('None')
        ikeys = self.conv.density_table.keys()
        ikeys.sort()
        for itm in ikeys:
            self.itemComboBox.append_text(itm)
        if len(self.conv.density_table.keys()) > 8:
            self.itemComboBox.set_wrap_width(3)
        setup_typeahead(self.itemComboBox)
        if amt1:
            self.amt1Entry=self.conv.float_to_frac(amt1)
        self.ui.connect_signals({
            'amt1changed':self.changed,
            'unit1changed':self.changed,
            'unit2changed':self.changed,
            'itemChanged':self.density_itm_changed,
            'densitySpinChanged':self.density_spin_changed,
            'densityChecked':self.density_toggled,
            'close':self.close,
            })
        self.last_amt1 = None
        self.last_amt2 = None
        self.last_unit1 = None
        self.last_unit2 = None
        if unit1 and self.conv.unit_dict.has_key[unit1]:
            u = self.conv.unit_dict[unit1]
            cb_set_active_text(self.unit1ComboBox,u)
        if amt1: self.amt1Entry.set_text("%s"%amt1)
        if item: cb_set_active_text(self.itemComboBox,item)

    def changed (self, *args):
        amt1 = convert.frac_to_float(self.amt1Entry.get_text())
        #amt2 = convert.frac_to_float(self.resultLabel.get_text())
        #amt2 = self.amt2
        unit1 = cb_get_active_text(self.unit1ComboBox)
        unit2 = cb_get_active_text(self.unit2ComboBox)
        if unit1 != self.last_unit1:
            self.get_possible_conversions()
        #self.unit2Model.refilter()
        if amt1 and unit2:
            self.convert(amt1, unit1, unit2)
        self.last_amt1 = amt1
        #self.last_amt2 = amt2
        self.last_unit1 = unit1
        self.last_unit2 = unit2

    def convert (self, amt1, unit1, unit2):
        density=None
        #if self.useDensityCheckButton.get_active():
        density=self.densitySpinButton.get_value()
        if density <= 0 or not self.expander1.get_expanded(): density = None
        conversion = self.conv.convert_fancy(unit1, unit2, density=density)
        message = ""
        if conversion:
            amt2 = amt1 * conversion
            if amt2 < (0.05):
                retAmt = "%1.3e"%amt2
            else:
                retAmt = convert.float_to_frac(amt2)
            result = "%s %s = <b>%s</b> %s"%(convert.float_to_frac(amt1),
                                             unit1,
                                             retAmt,
                                             unit2)
        else:
            result = _("Cannot convert %s to %s")%(unit1,unit2)
            if not density:
                message=  _("Need density information.")
                if not self.expander1.get_expanded():
                    self.expander1.set_expanded(True)
                    self.changed()
                    self.itemComboBox.activate()
        self.resultLabel.set_text(result)
        self.resultLabel.set_use_markup(True)
        self.resultLabel.set_line_wrap(True)
        self.messageLabel.set_text("<i>%s</i>"%message)
        self.messageLabel.set_use_markup(True)
        
        

    def message (self, msg):
        id=self.statusbar.get_context_id('main')
        self.statusbar.push(id,msg)
        
    def unit_filter (self, mod, iter):
        u = mod.get_value(iter,0)
        if not self.possible_conversions:
            self.get_possible_conversions()
        if u in self.possible_conversions:
            return True
        else:
            return False

    def get_possible_conversions (self):
        density=self.densitySpinButton.get_value()
        #if self.useDensityCheckButton.get_active():
        #    density=self.densitySpinButton.get_value()
        if density <= 0 or not self.expander1.get_expanded(): density = None
        u1 = cb_get_active_text(self.unit1ComboBox)
        self.possible_conversions = self.conv.get_all_conversions(u1,density=density)
        
    def density_toggled (self, *args):
        sens =  self.useDensityCheckButton.get_active()
        self.densitySpinButton.set_sensitive(sens)
        self.itemComboBox.set_sensitive(sens)
        self.changed()

    def density_itm_changed (self, *args):
        debug('density_itm_changed',5)
        self.changing_item=True
        itm=cb_get_active_text(self.itemComboBox)
        if itm != _('None'):
            self.densitySpinButton.set_value(self.conv.density_table[itm])
        else:
            self.densitySpinButton.set_value(0)
        self.changed()
        self.changing_item=False

    def density_spin_changed (self, *args):
        debug('density_spin_changed',5)
        if not self.changing_item:
            self.itemComboBox.set_active(0)
            self.changed()

    def close (self, *args):
        self.window.hide()
        if self.okcb:
            self.okcb(cb_get_active_text(self.unit2ComboBox),resultLabel.get_text())
        if __name__ == '__main__':
            gtk.main_quit()

if __name__ == '__main__':
    uibase="/home/tom/Projects/gourmet/glade/"
    cg=ConvGui()
    gtk.main()
    

########NEW FILE########
__FILENAME__ = unit_prefs_dialog
from gourmet.prefs import get_prefs
from gourmet.gtk_extras import dialog_extras as de
from gettext import gettext as _

class UnitPrefsDialog:

    options = [
        (_("Display units as written for each recipe (no change)"),[]),
        (_('Always display U.S. units'),['imperial volume','imperial weight']),
        (_('Always display metric units'),['metric volume','metric mass']),
        ]

    def __init__ (self, reccards):
        self.reccards = reccards
        self.prefs = get_prefs()
        
    def run (self):
        option = de.getRadio(label=_("Automatically adjust units"),
                             sublabel="Choose how you would like to adjust units for display and printing. The underlying ingredient data stored in the database will not be affected.",
                             options=self.options,
                             default=self.prefs['preferred_unit_groups'])
        old_pref = self.prefs.get('preferred_unit_groups',[])
        self.prefs['preferred_unit_groups'] = option
        if option != old_pref:
            for rc in self.reccards:
                rc.ingredientDisplay.display_ingredients()

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates two different styles of tests (one doctest and one
unittest). These will both pass when you run "manage.py test".

Replace these with more appropriate tests for your application.
"""

from django.test import TestCase

class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.failUnlessEqual(1 + 1, 2)

__test__ = {"doctest": """
Another way to test that 1 + 1 is equal to 2.

>>> 1 + 1 == 2
True
"""}


########NEW FILE########
__FILENAME__ = views
from gettext import gettext as _
from django.http import HttpResponse, HttpResponseRedirect
from django import forms
from django.shortcuts import render_to_response
from django.template import Context, loader
import sys
import re
import gourmet.backends.db
import gourmet.shopping
import gourmet.recipeManager
from django.utils import simplejson


class MultiplierForm (forms.Form):
    yields = forms.FloatField(label='New Yield',min_value=0,required=False)
    multiplier = None
    #multiplier = forms.FloatField(label='x',min_value=0,required=False)

class NoYieldsMultiplierForm (forms.Form):
    multiplier = forms.FloatField(label='x',min_value=0,required=False)
    yields = None
    
class SearchForm (forms.Form):
    choices = {unicode(_('anywhere')):'anywhere',
               unicode(_('title')):'title',
               unicode(_('ingredient')):'ingredient',
               unicode(_('instructions')):'instructions',
               unicode(_('notes')):'modifications',
               unicode(_('category')):'category',
               unicode(_('cuisine')):'cuisine',
               unicode(_('source')):'source',}
    search_field = forms.CharField(max_length=100)
    regexp_field = forms.BooleanField(label='Use regexp')
    choice_field = forms.ChoiceField(label='Search in...',
                                     initial='anywhere',
                                     choices=choices.items()
                                     )

rd = gourmet.backends.db.get_database()

class MyShoppingList (gourmet.shopping.ShoppingList):

    def get_shopper (self, lst):
        return gourmet.recipeManager.DatabaseShopper(lst, rd)
    
slist = MyShoppingList()

def list_recs (view, default_search_values={},
               template='index.html'):
    sf = SearchForm()
    for k,v in default_search_values.items():
        print 'Set',k,'to',v
        sf.fields[k].initial = v
    return render_to_response(
        template,
        {'recs':[(rec,rd.get_cats(rec)) for rec in view],
         'form':sf
        }
        )

def index (request):
    return list_recs(rd.fetch_all(rd.recipe_table,deleted=False))

def sort (request, field):
    return list_recs(rd.fetch_all(rd.recipe_table,deleted=False,sort_by=[(field,1)]))

def do_search_xhr (request):
    if request.method == 'POST':
        form = SearchForm(request.POST)
        print 'Searching ',form.data['search_field']
        return search(request,form.data['search_field'],template='list.html')
    else:
        print 'Not a post!'


def do_search (request):
    if request.method == 'POST':
        form = SearchForm(request.POST)
        print 'Searching ',form.data['search_field']
        return search(request,form.data['search_field'])
    else:
        print 'Not a post!'

def search (request, term, template='index.html'):
    vw = rd.search_recipes(
        [{'column':'deleted','operator':'=','search':False},
         {'column':'anywhere',
          'operator':'LIKE',
          'search':'%'+term.replace('%','%%'+'%')+'%',
          }
         ]
        )
    print 'We got ',len(vw),'for "%s"'%term
    return list_recs(vw, default_search_values={
        'search_field':term,
        'regexp_field':False,
        'choice_field':'anywhere',
        },
                     template=template
                     )


def get_ings (rec_id, mult):
    ings = rd.order_ings(rd.get_ings(rec_id))
    formatted_ings = []
    for g,items in ings:
        formatted_items = []
        for item in items:
            strings = []
            amt,unit = rd.get_amount_and_unit(item,mult=mult)
            if amt: strings.append(amt)
            if unit: strings.append(unit)
            strings.append(item.item)
            if item.optional: strings.append(' (optional)')
            formatted_items.append(' '.join(strings))
        formatted_ings.append((g,formatted_items))
    return formatted_ings

def rec (request, rec_id, mult=1):
    mult = float(mult)
    rec = rd.get_rec(rec_id)
    formatted_ings = get_ings(rec_id,mult)
    def textify (t):
        if not t: return ''
        print 'textifying "%s"'%t
        return re.sub('\n','<br>',
                      re.sub('\n\n+','</p><p>','<p>%s</p>'%t.strip()))
    if rec.yields:
        print 'WITH YIELDS'
        mf = MultiplierForm()
    else:
        print 'WITHOUT YIELDS'
        mf = NoYieldsMultiplierForm()
    return render_to_response(
        'rec.html',
        {'rd':rd,
         'r':rec,
         'ings':formatted_ings,
         'cats':', '.join(rd.get_cats(rec)),
         'instructions':textify(rec.instructions),
         'notes':textify(rec.modifications),
         'mult':mult,
         'yields':(rec.yields and rec.yields * mult or None),
         'is_adjusted': (mult!=1),
         'multiplier_form':mf,
         }
        )

def multiply_rec_xhr (request):
    return multiply_rec(request,xhr=True)


def multiply_rec (request, xhr=None):
    # We can't do yields and multiplier in the same place!
    print 'MULTIPLY!'
    if request.method == 'POST':
        form = MultiplierForm(request.POST)
        if form.is_valid():
            recid = request.POST.get('rid',None)
            try:
                multiplier = form.cleaned_data['multiplier']
            except:
                yields = form.cleaned_data['yields']
                orig_yields = rd.get_rec(recid).yields
                multiplier = (yields / float(orig_yields))
            if xhr:
                rec = rd.get_rec(recid)
                d = {'yields':rec.yields * multiplier,
                     'ingredients':get_ings(recid,multiplier),
                     'multiplier':multiplier}
                return HttpResponse(
                    simplejson.dumps(d),
                    mimetype='application/javascript'
                    )
            else:
                return HttpResponseRedirect('/rec/%s/%s'%(recid,multiplier))
        
def shop (request, rec_id=None, mult=1):
    mult = float(mult)
    if rec_id is not None:
        slist.addRec(rd.get_rec(rec_id),mult)
    recs = slist.recs.values()
    data,pantry = slist.organize_list(slist.lst)
    #recs = [('foo',4),]
    #data = [('sugar','3 cups'),]
    #pantry = [('sugar','3 cups'),]    
    return render_to_response('shop.html',{'data':data,'pantry':pantry,
                                           'recs':recs})

def shop_remove (request, rec_id=None):
    try:
        rec_id = int(rec_id)
        if slist.recs.has_key(rec_id):
            del slist.recs[int(rec_id)]
        else:
            print 'Odd, there is no ',rec_id,'on the shopping list'
    except TypeError:
        print 'Odd, rec_id',rec_id,'is the wrong type'
        raise
    return shop(request)

def shop_to_pantry (request):
    if request.method == 'POST':
        for item in request.POST:
            if item != 'submit':
                slist.sh.add_to_pantry(item)
        return HttpResponseRedirect('/shop/')
    
def shop_to_list (request):
    if request.method == 'POST':
        for item in request.POST:
            if item != 'submit':
                slist.sh.remove_from_pantry(item)
        return HttpResponseRedirect('/shop/')


def thumb (request, rec_id):
    return HttpResponse(rd.get_rec(rec_id).thumb,
                        mimetype='image/jpeg'
                        )

def img (request, rec_id):
    return HttpResponse(rd.get_rec(rec_id).image,
                        mimetype='image/jpeg'
                        )

########NEW FILE########
__FILENAME__ = settings
# Django settings for gourmetweb project.

import os.path

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

MANAGERS = ADMINS

DATABASE_ENGINE = ''           # 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
DATABASE_NAME = ''             # Or path to database file if using sqlite3.
DATABASE_USER = ''             # Not used with sqlite3.
DATABASE_PASSWORD = ''         # Not used with sqlite3.
DATABASE_HOST = ''             # Set to empty string for localhost. Not used with sqlite3.
DATABASE_PORT = ''             # Set to empty string for default. Not used with sqlite3.

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = ''

# URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a
# trailing slash.
# Examples: "http://foo.com/media/", "/media/".
ADMIN_MEDIA_PREFIX = '/media/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = '79ko3mh^6v!kgn_*!@d8f5yk=v@v-^3(b4+&3-ihcpj1)pxfaw'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.load_template_source',
    'django.template.loaders.app_directories.load_template_source',
#     'django.template.loaders.eggs.load_template_source',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
)

ROOT_URLCONF = 'gourmetweb.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    os.path.join(os.path.realpath(os.path.split(__file__)[0]),'templates'),
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns(
    '',
    (r'^$','gourmetweb.recview.views.index'),
    (r'^sort/(?P<field>.*)/','gourmetweb.recview.views.sort'),
    (r'^search/(?P<term>.*)','gourmetweb.recview.views.search'),
    (r'^rec/do_search/','gourmetweb.recview.views.do_search'),
    (r'^rec/do_search_xhr/','gourmetweb.recview.views.do_search_xhr'),
    (r'^regexp/(?P<term>.*)','gourmetweb.recview.views.regexp'),
    (r'^rec/$','gourmetweb.recview.views.index'),    
    (r'^rec/(?P<rec_id>\d*)/$','gourmetweb.recview.views.rec'),
    (r'^rec/(?P<rec_id>\d*)/(?P<mult>[\d.]*)$','gourmetweb.recview.views.rec'),
    (r'^shop/$','gourmetweb.recview.views.shop'),    
    (r'^shop/(?P<rec_id>\d*)/$','gourmetweb.recview.views.shop'),
    (r'^shop/(?P<rec_id>\d*)/(?P<mult>[\d.]*)$','gourmetweb.recview.views.shop'),
    (r'^shop/remove/(?P<rec_id>\d*)/$','gourmetweb.recview.views.shop_remove'),
    (r'^shop/to_pantry/','gourmetweb.recview.views.shop_to_pantry'),
    (r'^shop/to_list/','gourmetweb.recview.views.shop_to_list'),    
    (r'^rec/multiply/','gourmetweb.recview.views.multiply_rec'),
    (r'^img/(?P<rec_id>\d*)/$','gourmetweb.recview.views.img'),
    (r'^thumb/(?P<rec_id>\d*)/$','gourmetweb.recview.views.thumb'),    
    (r'^rec/multiply_xhr/','gourmetweb.recview.views.multiply_rec_xhr'),
    (r'^js/(?P<path>.*)$','django.views.static.serve',{'document_root':'/home/tom/Projects/grecipe-manager/src/lib/plugins/web_plugin/gourmetweb/templates/'}),
    #(r'^shop/(?P<rec_id>\d*)/(?P<mult>\d)/$','gourmetweb.recview.views.shop'),
    # Example:
    # (r'^gourmet/', include('gourmet.foo.urls')),
                       
    # Uncomment the admin/doc line below and add 'django.contrib.admindocs' 
    # to INSTALLED_APPS to enable admin documentation:
    # (r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # (r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os, sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "gourmetweb.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = plugin_gui
import plugin_loader
import gtk, gobject
import gtk_extras.dialog_extras as de
from xml.sax.saxutils import escape
from gettext import gettext as _

class PluginChooser:

    def __init__ (self):
        self.loader = plugin_loader.get_master_loader()
        self.window = gtk.Dialog()
        self.notebook = gtk.Notebook()
        for cat,plugins in self.categorize_plugins().items():
            #self.make_treeview(self.loader.active_plugin_sets)
            plugin_view = self.make_treeview(plugins)
            lab = gtk.Label(cat); lab.show()
            self.notebook.append_page(plugin_view,lab)
            plugin_view.show_all()
        self.add_labels()
        self.window.vbox.add(self.notebook); self.notebook.show()
        self.window.add_buttons(
            #gtk.STOCK_ABOUT,1
            gtk.STOCK_CLOSE,gtk.RESPONSE_CLOSE
            )
        self.window.set_default_size(375,400)
        self.window.connect('response',self.response_cb)
        
    def add_labels (self):
        head = gtk.Label()
        head.set_markup(
            '<b><span size="large">'+_('Plugins')+'</span></b>'
            )
        desc = gtk.Label()
        desc.set_markup('<i>'+_('Plugins add extra functionality to Gourmet.')+'</i>')
        head.set_alignment(0.0,0.0); desc.set_alignment(0.0,0.0)
        self.window.vbox.pack_start(head,expand=False)
        self.window.vbox.pack_start(desc,expand=False)
        self.window.vbox.set_border_width(12)
        head.show(); desc.show()        

    def categorize_plugins (self):
        categorized = {}
        for module_name,plugin_set in self.loader.available_plugin_sets.items():
            try:
                cat = plugin_set.category
            except AttributeError:
                cat = 'Main'
            if not categorized.has_key(cat): categorized[cat]=[]
            categorized[cat].append((module_name,plugin_set))
        return categorized
    
    def make_list_store (self, plugin_list):
        ls = gtk.ListStore(bool, # activated
                           gobject.TYPE_PYOBJECT, # the plugin-set object with all other info
                           )
        for module_name,plugin_set in plugin_list: #self.loader.available_plugin_sets.items():
            ls.append(
                (module_name in self.loader.active_plugin_sets,
                 plugin_set)
                )
        return ls

    def make_treeview (self, plugin_list):
        tv = gtk.TreeView()        
        toggle_renderer = gtk.CellRendererToggle()
        toggle_renderer.set_property('activatable',True)
        toggle_renderer.set_property('sensitive',True)        
        toggle_renderer.connect('toggled',self.toggled_cb,tv)
        active_col = gtk.TreeViewColumn('Active',toggle_renderer,active=0)
        text_renderer = gtk.CellRendererText()
        text_renderer.set_property('wrap-width',350)
        plugin_col = gtk.TreeViewColumn('Plugin',text_renderer)
        def data_fun (col,renderer,mod,itr):
            plugin_set = mod[itr][1]
            renderer.set_property('markup',
                                  ('<b>'+escape(plugin_set.name)+ '</b>' +
                                   '\n<span size="smaller"><i>' + escape(plugin_set.comment) + '</i></span>')
                                  )
        plugin_col.set_cell_data_func(text_renderer,data_fun)
        plugin_col.set_property('expand',True)
        plugin_col.set_property('min-width',250)
        tv.append_column(plugin_col)
        tv.append_column(active_col)
        ls = self.make_list_store(plugin_list)
        tv.set_model(ls)
        sw = gtk.ScrolledWindow(); sw.set_policy(gtk.POLICY_NEVER,gtk.POLICY_AUTOMATIC)
        sw.add(tv)
        return sw

    def toggled_cb (self, renderer, path, tv):
        ls = tv.get_model()
        plugin_set = ls[path][1]
        prev_state = ls[path][0]
        state = not prev_state
        self.do_change_plugin(plugin_set, state, ls)
        ls[path][0] = state

    def do_change_plugin (self, plugin_set, state, ls):
        try:
            if state:
                try:
                    self.loader.check_dependencies(plugin_set)
                except plugin_loader.DependencyError, dep_error:
                    print 'Missing dependencies:',dep_error.dependencies
                    for row in ls:
                        ps = row[1]
                        if ps.module in dep_error.dependencies and not row[0]:
                            print 'Activate dependency ',ps.module
                            self.do_change_plugin(ps,True, ls)
                            row[0] = True
                self.loader.activate_plugin_set(plugin_set)
            else:
                dependers = self.loader.check_if_depended_upon(plugin_set)
                if dependers:
                    if de.getBoolean(
                        label=_("Plugin is needed for other plugins. Deactivate plugin anyway?"),
                        sublabel=(_('The following plugins require %s:'%plugin_set.name) + '\n' +
                                  '\n'.join(plugin_set.name for plugin_set in dependers)
                                  ),
                        custom_yes=_('Deactivate anyway'),
                        custom_no=_('Keep plugin active')
                        ):
                        self.loader.deactivate_plugin_set(plugin_set)
                        for row in ls:
                            if row[1] in dependers:
                                row[0] = False
                    else:
                        raise Exception("Cancelled")
                else:
                    self.loader.deactivate_plugin_set(plugin_set)
        except:
            details = self.loader.errors.get(plugin_set,'')
            if 'ImportError' in details:
                modname = details.split()[-1]; n = modname.lower()
                modpossibilities = '"python-%s" '%n+_('or')+' "%s"'%n
                details += '\n\nYou may need to install additional python packages for this module to work properly. If you have a package management system on your computer, use it to search for a package containing "%s", such as %s'%(modname,modpossibilities)
            if state:
                de.show_message(message_type=gtk.MESSAGE_ERROR,
                                label=_('An error occurred activating plugin.'),
                                sublabel=details)
            else:
                de.show_message(message_type=gtk.MESSAGE_ERROR,
                                label=_('An error occurred deactivating plugin.'),
                                sublabel=details
                                )
                
            raise

    def response_cb (self, window, response):
        if response==gtk.RESPONSE_CLOSE: self.window.hide()
            
def show_plugin_chooser ():
    pc = PluginChooser()
    pc.window.show()
    return pc
    
if __name__ == '__main__':
    pc = show_plugin_chooser()
    pc.window.connect('delete-event',gtk.main_quit)
    gtk.main()

########NEW FILE########
__FILENAME__ = plugin_loader
PRE = 0
POST = 1
import gglobals, os.path, glob, sys
import gobject
import plugin
from gdebug import debug
from defaults.defaults import loc

try:
    current_path = os.path.split(os.path.join(os.getcwd(),__file__))[0]
except:
    current_path = ''

# This module provides a base class for loading plugins. Everything
# that is plug-in-able in Gourmet should subclass the plugin loader.

# Everything that is a plugin needs to provide a python module with a
# plugins attribute containing the plugin classes that make up the
# plugin. In addition, we need a .gourmet-plugin configuration file
# pointing to the module (with the module parameter) and giving the
# name and comment for the plugin.

class MasterLoader:

    # Singleton design pattern lifted from:
    # http://www.python.org/workshops/1997-10/proceedings/savikko.html
    # to get an instance, use the convenience function
    # get_master_loader()
    __single = None
    default_active_plugin_sets = [
        # tools
        'unit_converter',
        'duplicate_finder',
        'spellcheck',
        # import/export
        'gxml_plugin',
        'html_plugin',
        'mastercook_import_plugin',
        'mealmaster_plugin',
        'archive_plugin',
        'pdf_plugin',
        'plaintext_plugin',
        'web_import_plugin',
        'website_import_plugins',
        'krecipe_plugin',
        'mycookbook_plugin',
        ]
    active_plugin_filename = os.path.join(gglobals.gourmetdir,'active_plugins')

    def __init__ (self):
        if MasterLoader.__single:
            raise MasterLoader.__single
        MasterLoader.__single = self
        self.plugin_directories = [os.path.join(gglobals.gourmetdir,'plugins'), # user plug-ins
                                   os.path.join(current_path,'plugins'), # pre-installed plugins
                                   os.path.join(current_path,'plugins','import_export'), # pre-installed exporter plugins
                                   os.path.join(gglobals.plugin_base,'plugins'), # system-wide plug-ins (required for running from source)
                                   os.path.join(gglobals.plugin_base,'plugins','import_export'), # exporter plug-ins (required for running from source)
                                   ]
        self.errors = {}
        self.pluggables_by_class = {}
        self.load_plugin_directories()
        self.load_active_plugins()

    def load_plugin_directories (self):
        """Look through plugin directories for plugins.
        """
        self.available_plugin_sets = {}
        for d in self.plugin_directories:
            debug('Loading plugins from %s'%os.path.realpath(d),1)
            plugins = glob.glob(os.path.join(d,'*.gourmet-plugin'))
            for ppath in plugins:
                debug('Found %s'%ppath,1)
                plugin_set = PluginSet(ppath)
                if self.available_plugin_sets.has_key(plugin_set.module):
                    print 'Ignoring duplicate plugin ',plugin_set.module,'found in ',ppath
                else:
                    self.available_plugin_sets[plugin_set.module] = plugin_set

    def load_active_plugins (self):
        """Activate plugins that have been activated on startup
        """
        if os.path.exists(self.active_plugin_filename):
            infi = file(self.active_plugin_filename,'r')
            self.active_plugin_sets = [l.strip() for l in infi.readlines()]
        else:
            self.active_plugin_sets = self.default_active_plugin_sets[:]
        self.active_plugins = []
        self.instantiated_plugins = {}
        for p in self.active_plugin_sets:
            if self.available_plugin_sets.has_key(p):
                try:
                    self.active_plugins.extend(self.available_plugin_sets[p].plugins)
                except:
                    import logging
                    import traceback
                    print 'WARNING: Failed to load plugin %s'%p
                    self.errors[p] = traceback.format_exc()
                    logging.exception('')
            else:
                print 'Plugin ',p,'not found'
    

    def save_active_plugins (self):
        # If we have not changed from the defaults and no
        # configuration file exists, don't bother saving one.
        if ((self.active_plugin_sets != self.default_active_plugin_sets)
            or
            os.path.exists(self.active_plugin_filename)):
            ofi = file(self.active_plugin_filename,'w')
            saved = [] # keep track of what we've written to avoid
                       # saving a plugin twice
            for plugin_set in self.active_plugin_sets:
                if not plugin_set in saved:
                    ofi.write(plugin_set+'\n')
                saved.append(plugin_set)
            ofi.close()
        #elif self.active_plugin_sets == self.default_active_plugin_sets:
        #    print 'No change to plugins, nothing to save.'

    def check_dependencies (self, plugin_set):
        if plugin_set.dependencies:
            missing = []
            depends = plugin_set.dependencies or []
            for dep in depends:
                if not dep in self.active_plugin_sets:
                    missing.append(dep)
            if missing:
                raise DependencyError(plugin_set,missing)

    def check_if_depended_upon (self, plugin_set):
        """Return a list of active plugin set objects that depend on
        plugin_set.
        """
        depending_on_me = []
        for module in self.active_plugin_sets:
            if module in self.available_plugin_sets:
                ps = self.available_plugin_sets[module]
                if ps.dependencies:
                    try:
                        if plugin_set.module in ps.dependencies:
                            depending_on_me.append(ps)
                    except:
                        print 'Problem checking dependencies of ',ps,ps.Dependencies
                        raise
        return depending_on_me

    def activate_plugin_set (self, plugin_set):
        """Activate a set of plugins.
        """
        if plugin_set in self.active_plugin_sets:
            return
        self.check_dependencies(plugin_set)
        # plugin_set.get_module() returns None if there's been a
        # problem -- we want to raise that problem now.
        if plugin_set.get_module() is None:
            self.errors[plugin_set]=plugin_set.error.__class__.__name__+': '+plugin_set.error.message
            raise plugin_set.error
        self.active_plugin_sets.append(plugin_set.module)
        self.active_plugins.extend(plugin_set.plugins)
        for plugin in plugin_set.plugins:
            for klass in self.pluggables_by_class.keys():
                if issubclass(plugin,klass):
                    for pluggable in self.pluggables_by_class[klass]:
                        pluggable.plugin_plugin(self.get_instantiated_plugin(plugin))

    def deactivate_plugin_set (self, plugin_set):
        # Deactivate any plugin sets that depend upon us...
        for ps in self.check_if_depended_upon(plugin_set):
            self.deactivate_plugin_set(ps)
        if plugin_set.module in self.active_plugin_sets:
            self.active_plugin_sets.remove(plugin_set.module)
        else:
            print 'Odd',plugin_set.module,'is not listed as active.'
        if plugin_set.get_module():
            for plugin in plugin_set.plugins:
                for klass in self.pluggables_by_class.keys():
                    if issubclass(plugin,klass):
                        for pluggable in self.pluggables_by_class[klass]:
                            plugin().deactivate(pluggable)

                if self.instantiated_plugins.has_key(plugin):
                    self.instantiated_plugins[plugin].remove()
                self.active_plugins.remove(plugin)

    def get_instantiated_plugin (self, plugin):
        if self.instantiated_plugins.has_key(plugin):
            return self.instantiated_plugins[plugin]
        else:
            debug('Instantiate %s from %s'%(plugin,
                                            plugin.__module__),
                  1)
            self.instantiated_plugins[plugin] = plugin()
            return self.instantiated_plugins[plugin]
            
    def register_pluggable (self, pluggable, klass):
        if not self.pluggables_by_class.has_key(klass):
            self.pluggables_by_class[klass] = []
        self.pluggables_by_class[klass].append(pluggable)
        for p in self.active_plugins:
            if issubclass(p,klass):
                try:
                    plugin_instance = self.get_instantiated_plugin(p)
                except:
                    import traceback
                    print 'WARNING: Failed to instantiate plugin %s of type %s'%(p,klass)
                    self.errors[p] = traceback.format_exc()                    
                    traceback.print_exc()
                else:
                    #print 'Instantiating plugin',p,plugin_instance,'of',klass
                    pluggable.plugin_plugin(plugin_instance)

    def unregister_pluggable (self, pluggable, klass):
        self.pluggables_by_class[klass].remove(pluggable)

def get_master_loader ():
    # Singleton design pattern lifted from:
    # http://www.python.org/workshops/1997-10/proceedings/savikko.html    
    try:
        return MasterLoader()
    except MasterLoader, ml:
        return ml                

class PluginSet:
    """A lazy-loading set of plugins.

    This class encapsulates what to the end-user is a plugin.

    From our perspective, plugins can really be a bundle of plugins --
    for example, your plugin might require a DatabasePlugin, a
    RecCardDisplayPlugin and a MainPlugin to function.
    """

    _loaded = False
    
    def __init__ (self, plugin_info_path):
        f = file(plugin_info_path,'r')
        self.load_plugin_file_data(f)
        f.close()
        self.curdir, plugin_info_file = os.path.split(plugin_info_path)
        plugin_modules_dir = os.path.join(gglobals.lib_dir,"plugins")
        self.plugin_modules_dir = plugin_modules_dir
        self.import_export_modules_dir = os.path.join(plugin_modules_dir,
                                                      "import_export")
        self.module = self.props['Module']

    def get_module (self):
        if self._loaded:
            return self._loaded
        else:
            if not self.curdir in sys.path:
                sys.path.append(self.curdir)
            if not self.plugin_modules_dir in sys.path:
                sys.path.append(self.plugin_modules_dir)
            if not self.import_export_modules_dir in sys.path:
                sys.path.append(self.import_export_modules_dir)

            try:
                self._loaded = __import__(self.module)
                #print 'Loaded plugin set',self._loaded
                #print 'plugins=',self._loaded.plugins
            except ImportError,ie:
                print 'WARNING: Plugin module import failed'
                print 'PATH:',sys.path
                import traceback; traceback.print_exc()
                self.error = ie
                return None
            else:
                return self._loaded

    def __getattr__ (self, attr):
        if attr == 'plugins': return self.get_plugins()
        elif self.props.has_key(attr): return self.props[attr]
        elif self.props.has_key(attr.capitalize()): return self.props[attr.capitalize()]
        else: raise AttributeError

    def get_plugins (self):
        return self.get_module().plugins

    def load_plugin_file_data (self,plugin_info_file):        
        # This should really use GKeyFile but there are no python
        # bindings that I can find atm. One possibility would be to
        # use this:
        # http://svn.async.com.br/cgi-bin/viewvc.cgi/kiwi/trunk/kiwi/desktopparser.py?revision=7336&view=markup
        self.props = dict([(k,None) for k in ['Name','Comment','Authors','Version','API_Version','Website','Copyright','Dependencies']])

        for line in plugin_info_file.readlines():
            if line=='[Gourmet Plugin]\n': pass
            elif line.find('=')>0:
                key,val = line.split('=')
                key = key.strip(); val = val.strip()
                key = key.strip('_')
                if (loc is not None) and ('[' in key):
                    key,locale = key.strip(']').split('[')
                    if locale==loc:
                        self.props[key] = val
                    elif locale[:2]==loc[:2]:
                        self.props[key] = val
                else:
                    self.props[key]=val
            else:
                print 'Ignoring line',line
        if self.dependencies:
            self.props['Dependencies'] = [d.strip() for d in self.dependencies.split(',')]

class Pluggable:
    """A plugin-able class."""
    
    def __init__ (self, plugin_klasses):
        """plugin_klasses is the list class of which each of our
        plugins should be a sub-class.

        A pluggable can take multiple types of sub-classes if it
        likes.
        """
        #print 'Pluggable.__init__([',plugin_klasses,'])'
        self.pre_hooks = {} # stores hooks to be run before methods by
                            # method name
        self.post_hooks = {} # stores hooks to be run after methods by
                             # method name
        self.loader = get_master_loader()
        self.klasses = plugin_klasses
        self.plugins = []
        for klass in self.klasses:
            #print 'register self ',self,'as pluggable for ',klass
            self.loader.register_pluggable(self,klass)

    def plugin_plugin (self, plugin_instance):
        try:
            self.plugins.append(plugin_instance)
            plugin_instance.activate(self)
        except:
            print 'WARNING: PLUGIN FAILED TO LOAD',plugin_instance
            import traceback; traceback.print_exc()

    def destroy (self):
        self.loader.unregister_pluggable(self,self.klass)
        for pi in self.plugins:
            pi.deactivate(self)

    def run_pre_hook (self, fname, *args, **kwargs):
        for hook in self.pre_hooks.get(fname,[]):
            try:
                new_args,new_kwargs = hook(self,*args,**kwargs)
                assert(isinstance(args,tuple))
                assert(isinstance(kwargs,dict))
            except:
                print 'WARNING',hook,'did not return args,kwargs'
            else:
                args,kwargs = new_args,new_kwargs
        return args,kwargs

    def run_post_hook (self, fname, retval, *args, **kwargs):
        for hook in self.post_hooks.get(fname,[]):
            retval = hook(retval,self,*args,**kwargs)
        return retval

    def add_hook (self, type, name, hook):
        if type==PRE: hookdic = self.pre_hooks
        else: hookdic = self.post_hooks
        if not hookdic.has_key(name):
            hookdic[name] = []
        hookdic[name].append(hook)

    def remove_hook (self, type, name, hook):
        if type==PRE: hookdic = self.pre_hooks
        else: hookdic = self.post_hooks
        del hookdic[name]

    def get_plugin_by_module (self, module):
        for p in self.plugins:
            if p.__module__ == module:
                return p


class DependencyError (Exception):

    def __init__ (self, pluginset, missing_dependencies):
        self.plugin_set = pluginset
        self.dependencies = missing_dependencies
        print self.plugin_set,'requires but did not find',self.dependencies
        
    def __repr__ (self):
        return ('<DependencyError '
                + repr(self.plugin_set)
                + ' missing required dependencies '
                + repr(self.dependencies)
                )
    
def pluggable_method (f):
    def _ (self, *args, **kwargs):
        '''Run hooks around method'''
        args,kwargs = self.run_pre_hook(f.__name__,*args,**kwargs)
        retval = f(self,*args,**kwargs)
        retval = self.run_post_hook(f.__name__,retval,*args,**kwargs)
        return retval
    return _

if __name__ == '__main__':
    class TestPlugin (plugin.Plugin):
        def activate ():
            print 'Activate!'
        def deactivate ():
            print 'Deactivate!'
    
    class UniversalPluggable (Pluggable):
        def __init__ (self):
            Pluggable.__init__(self,[plugin.Plugin])

    up = UniversalPluggable()
    #up.loader.activate_plugin(
    print up.plugins

########NEW FILE########
__FILENAME__ = prefs
#!/usr/bin/env python
import os, os.path, pickle, gglobals

class Prefs:

    __single = None

    def __init__ (self, file=os.path.join(gglobals.gourmetdir,'guiprefs')):
        """A basic class for handling preferences.

        subclasses could save our preferences in any number of
        ways. We use a rather primitive solution here and simply use
        pickle.

        set_hooks allow us to watch our settings from elsewhere --
        they will be called each time a preference is changed and
        handed the key and value as arguments: hook(key,value).
        """
        if Prefs.__single:
            raise Prefs.__single
        else:
            Prefs.__single = self
        self.file=file
        self.config = {}
        self.load()
        self.set_hooks = []

    def get (self, key, default=None):
        """Return a key's value, or default if the key isn't set.
        """
        # note: we no longer set the key to the default value as a side effect,
        # since this behavior was, well, stupid. 5/7/05
        if not self.config.has_key(key):
            # Except for dictionaries, because, well, we rely on some
            # of the stupid behavior. If our preference is a
            # modifiable object -- i.e. a dictionary or a list -- it
            # is likely the program relies on a modified default being
            # saved... 12/13/06
            if type(default) in [ dict, list ] :
                self.config[key]=default
            return default
        else: return self.config[key]

    def has_key (self, k):
        return self.config.has_key(k)

    def __setitem__ (self, k, v):
        self.config[k]=v
        for hook in self.set_hooks: hook(k,v)

    def __getitem__ (self, k):
        return self.config[k]

    def keys (self): return self.config.keys()
    def values (self): return self.config.values()
    def items (self): return self.config.items()

    def save (self):
        if not os.path.exists(os.path.split(self.file)[0]):
            os.makedirs(os.path.split(self.file)[0])
        ofi=open(self.file,'w')
        pickle.dump(self.config,ofi)

    def load (self):
        if os.path.isfile(self.file):
            ifi=open(self.file,'r')
            try:
                self.config=pickle.load(ifi)
            except:
                import traceback
                print 'ERROR LOADING CONFIGURATION FILE'
                print 'Saving a copy of broken configuration file saved as'
                print '%s.broken'%self.file
                ifi.seek(0)
                ofi = file(self.file+'.broken','w')
                ofi.write(ifi.read())
                ofi.close()
                print traceback.print_exc()
            else:
                return True
        return False

def get_prefs ():
    try:
        return Prefs()
    except Prefs, p:
        return p

if __name__ == '__main__':
    p = Prefs()

########NEW FILE########
__FILENAME__ = prefsGui
import gtk, os.path
import gglobals
from gtk_extras import optionTable
import plugin_loader, plugin

class PreferencesGui (plugin_loader.Pluggable):
    """The glue between our preferences dialog UI and our prefs modules.

    Instead of "connecting", as would be normal with pygtk objects, we set up handlers in the
    apply_prefs_dic which contains preference-handlers for each preference we wish.

    {'preference_name':lambda foo (name,val): bar(name,val)}
    """
    
    INDEX_PAGE = 0
    CARD_PAGE = 1
    SHOP_PAGE = 2

    def __init__ (
        self,
        prefs,
        uifile=os.path.join(gglobals.uibase,
                            'preferenceDialog.ui'),
        radio_options={'shop_handle_optional':{'optional_ask':0,
                                               'optional_add':1,
                                               'optional_dont_add':-1
                                               }
                       },
        toggle_options={'remember_optionals_by_default':'remember_optionals_by_default',
                        'readableUnits':'toggle_readable_units',
                        'useFractions':'useFractions',
                        'showToolbar':'show_toolbar',
                        #'email_include_body':'email_body_checkbutton',
                        #'email_include_html':'email_html_checkbutton',
                        #'emailer_dont_ask':'remember_email_checkbutton',
                        },

        number_options = {'recipes_per_page':'recipesPerPageSpinButton'},
        
        buttons = {}
        #buttons = {'clear_remembered_optional_button':
        ):
        """Set up our PreferencesGui

        uifile points us to our UI file
        
        radio_options is a dictionary of preferences controlled by radio buttons.
                      {preference_name: {radio_widget: value,
                                         radio_widget: value, ...}
                                         }

        toggle_options is a dictionary of preferences controlled by toggle buttons.
                      {preference_name: toggle_widget_name}
        buttons = {button_name : callback}
                      
        """

        self.prefs = prefs
        self.ui = gtk.Builder()
        self.ui.add_from_file(uifile)
        self.notebook = self.ui.get_object('notebook')
        # pref name: {'buttonName':VALUE,...}
        self.radio_options = radio_options
        self.connect_radio_buttons()
        self.toggle_options = toggle_options
        self.apply_prefs_dic = {}
        self.widget_sensitivity_dic = {
            # pref : {'value':('widget':True,'widget':False,'widget':True...)}
            'shop_handle_optional':{0:{'remember_optionals_by_default':True,
                                       'clear_remembered_optional_button':True},
                                    1:{'remember_optionals_by_default':False,
                                       'clear_remembered_optional_button':False},
                                    -1:{'remember_optionals_by_default':False,
                                       'clear_remembered_optional_button':False}
                                    }
            }
        self.connect_toggle_buttons()
        self.buttons=buttons
        self.connect_buttons()
        self.number_options = number_options
        self.connect_number_options()
        self.build_pref_dictionary()
        self.set_widgets_from_prefs()
        self.prefs.set_hooks.append(self.update_pref)
        self.pref_tables={}
        self.ui.get_object('close_button').connect('clicked',lambda *args: self.hide_dialog())
        plugin_loader.Pluggable.__init__(self,[plugin.PrefsPlugin])

    def build_pref_dictionary (self):
        """Build our preferences dictionary pref_dic

        preference: BOOLEAN_WIDGET|{VALUE:RADIO_WIDGET,VALUE:RADIO_WIDGET...}
                    METHOD_TO_BE_HANDED_PREF_VALUE

        pref_dic will be used to e.g. set default values and watch
        changing preferences.
        """
        self.pref_dic = {}
        for pref,widget in self.toggle_options.items():
            self.pref_dic[pref]=('TOGGLE',widget)
        for pref,widgdic in self.radio_options.items():
            self.pref_dic[pref]={}
            # create a dictionary by value (reversed dictionary)...
            for widg,val in widgdic.items(): self.pref_dic[pref][val]=widg
        self.d=self.ui.get_object('dialog')
        self.d.connect('delete-event',self.hide_dialog)


    def set_widgets_from_prefs (self):
        for k in self.pref_dic.keys():
            if self.prefs.has_key(k): self.update_pref(k,self.prefs[k])

    def update_pref (self, pref, value):
        """Update GUI to reflect value 'value' of preference 'pref'."""
        if self.pref_dic.has_key(pref):
            action=self.pref_dic[pref]
            if type(action)== dict :
                # we fail if action is no
                widg=action[value]
                act,act_args=('set_active',True)
            elif action[0]=='TOGGLE':
                act,act_args=('set_active',value)
                widg=action[1]
            # in the future, we can handle Entries, etc...
            if type(widg)==str:
                widg=self.ui.get_object(widg)
            getattr(widg,act)(act_args)
            self.update_sensitivity_for_pref(pref,value)
            
    def show_dialog (self, page=None):
        """present our dialog."""        
        self.d.present()
        if page:
            self.notebook.set_current_page(page)

    def hide_dialog (self,*args):
        self.d.hide()
        return True

    def connect_buttons (self):
        for b,cb in self.buttons.items():
            self.ui.get_object(b).connect('clicked',cb)

    def connect_toggle_buttons (self):
        """Connect signals for toggle buttons in self.toggle_options."""
        for pref,widget in self.toggle_options.items():
            self.ui.get_object(widget).connect('toggled',self.toggle_callback,pref)

    def toggle_callback (self, button, pref_name):
        """Set preference 'pref_name' in response to toggle event on button."""
        self.set_pref(pref_name, button.get_active())
        
    def connect_radio_buttons (self):
        """Connect radio button signals to properly set preferences on toggle."""
        for pref_name,pref_dic in self.radio_options.items():
            for button,val in pref_dic.items():
                self.ui.get_object(button).connect(
                    'toggled',
                    self.radio_callback,
                    pref_name,
                    val)

    def radio_callback (self, button, pref_name, true_val=True):
        """Call back for radio button: if we are on, we set the pref to true_val."""
        if button.get_active():
            self.set_pref(pref_name,true_val)

    def connect_number_options (self):
        for pref_name,widgetname in self.number_options.items():
            widget = self.ui.get_object(widgetname)
            if hasattr(widget,'get_value'):
                get_method='get_value'
            elif hasattr(widget,'get_text'):
                get_method=lambda *args: float(widget.get_text())
            else:
                print 'widget',widgetname,widget,'is not very numberlike!'
                return
            curval = self.prefs.get(pref_name,None)
            if curval:
                try:
                    widget.set_value(curval)
                except:
                    widget.set_text(str(curval))
            if isinstance(widget,gtk.SpinButton):
                widget.get_adjustment().connect('value-changed',self.number_callback,pref_name,get_method)
            else:
                widget.connect('changed',self.number_callback,pref_name,get_method)

    def number_callback (self, widget, pref_name, get_method='get_value'):
        self.set_pref(pref_name,getattr(widget,get_method)())

    def set_pref (self, name, value):
        """Set preference 'name' to value 'value'

        Possibly apply the preference using callback looked up in
        apply_prefs_dic (callback must take name and value of pref as
        arguments.
        """
        self.prefs[name]=value
        if self.apply_prefs_dic.has_key(name):
            self.apply_prefs_dic[name](name,value)

    def update_sensitivity_for_pref (self, name, value):
        try:
            for k,v in self.widget_sensitivity_dic[name][value].items():
                self.ui.get_object(k).set_sensitive(v)
        except KeyError: pass
            

    def add_widget (self, target_widget, child_widget):
        """Add child_widget to target_widget"""
        if type(target_widget)==str: target_widget=self.ui.get_object(target_widget)
        if type(child_widget)==str: child_widget=self.ui.get_object(child_widget)
        target_widget.add(child_widget)
        target_widget.show_all()

    def add_pref_table (self, options, target_widget, callback=None):
        """Add a preference table based on an option list 'options' to the
        target_widget 'target_widget' (either a widget or a glade-reference)

        The options need to be appropriate for an OptionTable.

        The callback will be handed the options (as returned by
        OptionTable) each time OptionTable is changed.
        """
        table=optionTable.OptionTable(options=options, changedcb=self.preftable_callback)
        self.pref_tables[table]=callback
        self.add_widget(target_widget,table)

    def preftable_callback (self, widget):
        for table,cb in self.pref_tables.items():
            if widget in table.get_children():
                # then we know who's preferences we care about...
                table.apply()
                if cb: cb(table.options)
                return
        print "Oops: we couldn't handle widget %s"%widget
        
if __name__ == '__main__':
    class FauxPrefs (dict):
        def __init__ (self,*args,**kwargs):
            self.set_hooks = []
            dict.__init__(self,*args,**kwargs)

        def __setitem__ (self,k,v):
            print 'k:',k
            print 'v:',v
            dict.__setitem__(self,k,v)
            for h in self.set_hooks:
                print 'runnnig hook'
                h(k,v)
            
    gf='/home/tom/Projects/grm-db-experiments/glade/preferenceDialog.ui'
    import sys
    p=PreferencesGui(FauxPrefs(),gf)
    def printstuff (*args): print args
    p.add_pref_table([["Toggle Option",True],
                      ["String Option","Hello"],
                      ["Integer Option",1],
                      ["Float Option",float(3)]],
                     'cardViewVBox',
                     printstuff
                     )
    p.show_dialog()
    gtk.main()

########NEW FILE########
__FILENAME__ = profileImport
from testImporters import ImportTest
import unittest
import profile, tempfile, os.path

#class profileTest (ImportTestCase):
#    #def run (self,*args,**kwargs):
#    #    profile.run('ImportTestCase.run(self,*args,**kwargs)')

it = ImportTest()
print 'Setting up DB'
it.setup_db()
print 'Profiling gourmet importer'
profi = os.path.join(tempfile.tempdir,'GOURMET_PROFILE')
profile.run("""it.run_test({'filename':'/home/tom/Desktop/Junk/recipes.grmt'})""",profi)
#profile.run("""it.run_test({'filename':'/home/tom/Projects/recipe/Data/mealmaster.mmf'})""",profi)
import pstats
p = pstats.Stats(profi)
p.strip_dirs().sort_stats('cumulative').print_stats()


########NEW FILE########
__FILENAME__ = reccard
#!/usr/bin/env python
import gc
import gobject, gtk, gtk.gdk
import os.path, string
try:
    from PIL import Image
except ImportError:
    import Image
import types
import xml.sax.saxutils, pango
import exporters.exportManager
import convert
from recindex import RecIndex
import prefs
import Undo
from gtk_extras import WidgetSaver, timeEntry, ratingWidget, TextBufferMarkup
from gtk_extras import dialog_extras as de
from gtk_extras.dialog_extras import show_amount_error
from gtk_extras import treeview_extras as te
from gtk_extras import cb_extras as cb
from exporters.printer import get_print_manager
from gdebug import debug
from gglobals import FLOAT_REC_ATTRS, INT_REC_ATTRS, REC_ATTR_DIC, REC_ATTRS, doc_base, uibase, imagedir, launch_url
from gettext import gettext as _
import ImageExtras as ie
from importers.importer import parse_range
from gtk_extras import mnemonic_manager
from gtk_extras import fix_action_group_importance
from gtk_extras.dialog_extras import UserCancelledError
from plugin import RecEditorModule, ToolPlugin, RecDisplayPlugin, RecEditorPlugin, IngredientControllerPlugin
import plugin_loader
import timeScanner
import defaults

# TODO
#
# Redo white-coloring of widgets
# Redo autowrapping of text fields

def find_entry (w):
    if isinstance(w,gtk.Entry):
        return w
    else:
        if not hasattr(w,'get_children'):
            return None
        for child in w.get_children():
            e = find_entry(child)
            if e: return e

class RecRef:
    def __init__ (self, refid, title):
        self.refid = refid
        self.item = title
        self.amount = 1

# OVERARCHING RECIPE CARD CLASS - PROVIDES GLUE BETWEEN EDITING AND DISPLAY

class RecCard (object):
    
    def __init__ (self, rg=None, recipe=None, manual_show=False):
        if not rg:
            from GourmetRecipeManager import get_application
            rg = get_application()
        self.rg = rg
        self.conf = []
        self.new = False
        if not recipe:
            recipe = self.rg.rd.new_rec()
            self.new = True
        self.current_rec = recipe
        if not manual_show:
            self.show()

    def set_current_rec (self, rec):
        self.__current_rec = rec
        if hasattr(self,'recipe_editor'):
            self.recipe_editor.current_rec = rec
        if hasattr(self,'recipe_display'):
            self.recipe_display.current_rec = rec

    def get_current_rec (self):
        return self.__current_rec
    
    current_rec = property(get_current_rec,
                           set_current_rec,
                           None,
                           "Recipe in the recipe card")
    def get_edited (self):
        if hasattr(self,'recipe_editor') and self.recipe_editor.edited: return True
        else: return False

    def set_edited (self, val):
        if hasattr(self,'recipe_editor') and self.recipe_editor.edited:
            self.recipe_editor.edited = bool(val)
    edited = property(get_edited,set_edited)

    def show_display (self):
        if not hasattr(self,'recipe_display'):
            self.recipe_display = RecCardDisplay(self, self.rg,self.current_rec)
        self.recipe_display.window.present()

    def show_edit (self, module=None):
        if not hasattr(self,'recipe_editor'):
            self.recipe_editor = RecEditor(self, self.rg,self.current_rec,new=self.new)
        if module:
            self.recipe_editor.show_module(module)
        self.recipe_editor.present()
        

    def delete (self, *args):
        self.rg.rec_tree_delete_recs([self.current_rec])

    def update_recipe (self, recipe):
        self.current_rec = recipe
        if hasattr(self,'recipe_display'):
            self.recipe_display.update_from_database()
        if hasattr(self,'recipe_editor') and not self.recipe_editor.window.get_property('visible'):
            delattr(self,'recipe_editor')

    def show (self):
        if self.new:
            self.show_edit()
        else:
            self.show_display()

    def hide (self):
        if ((not (hasattr(self,'recipe_display') and self.recipe_display.window.get_property('visible')))
             and
            (not (hasattr(self,'recipe_editor') and self.recipe_editor.window.get_property('visible')))):
            self.rg.del_rc(self.current_rec.id)

    # end RecCard

# RECIPE CARD DISPLAY

class RecCardDisplay (plugin_loader.Pluggable):

    ui_string = '''
    <ui>
       <menubar name="RecipeDisplayMenuBar">
          <menu name="Recipe" action="Recipe">
            <menuitem action="Export"/>
            <menuitem action="ShopRec"/>
            <!-- <menuitem action="Email"/> -->
            <menuitem action="Print"/>
            <separator/>
            <menuitem action="Delete"/>
            <separator/>
            <menuitem action="Close"/>
          </menu>
          <menu name="Edit" action="Edit">
            <menuitem action="Preferences"/>
            <menuitem action="AllowUnitsToChange"/>
          </menu>
          <menu name="Go" action="Go"/>
          <menu name="Tools" action="Tools">
            <placeholder name="StandaloneTool">
            <menuitem action="Timer"/></placeholder>
            <separator/>
            <placeholder name="DataTool">
            </placeholder>
            <separator/>
            <menuitem action="ForgetRememberedOptionals"/>    
          </menu>
          <menu name="HelpMenu" action="HelpMenu">
            <menuitem name="Help" action="Help"/>
          </menu>
        </menubar>
    </ui>
    '''

    def __init__ (self, reccard, recGui, recipe=None):
        self.reccard = reccard; self.rg = recGui; self.current_rec = recipe
        self.mult = 1 # parameter
        self.conf = reccard.conf
        self.prefs = prefs.get_prefs()
        self.setup_ui()
        self.setup_uimanager()
        self.setup_main_window()
        self.setup_notebook()
        self.ingredientDisplay = IngredientDisplay(self)
        self.modules = [self.ingredientDisplay]
        self.update_from_database()
        plugin_loader.Pluggable.__init__(self,
                                         [ToolPlugin,RecDisplayPlugin])
        self.mm = mnemonic_manager.MnemonicManager()
        self.mm.add_toplevel_widget(self.window)
        self.mm.fix_conflicts_peacefully()
        self.setup_style()

    def setup_uimanager (self):
        self.ui_manager = gtk.UIManager()
        self.ui_manager.add_ui_from_string(self.ui_string)
        self.setup_actions()
        for group in [
            self.recipeDisplayActionGroup,
            self.rg.toolActionGroup,
            self.rg.toolActionGroup
            ]:
            fix_action_group_importance(group)
        self.ui_manager.insert_action_group(self.recipeDisplayActionGroup,0)
        self.ui_manager.insert_action_group(self.recipeDisplayFuturePluginActionGroup,0)
        self.ui_manager.insert_action_group(self.rg.toolActionGroup,0)
        self.rg.add_uimanager_to_manage(self.current_rec.id,self.ui_manager,'RecipeDisplayMenuBar')

    def setup_actions (self):
        self.recipeDisplayActionGroup = gtk.ActionGroup('RecipeDisplayActions')
        self.recipeDisplayActionGroup.add_actions([
            ('Recipe',None,_('_Recipe')),
            ('Edit',None,_('_Edit')),
            ('Go',None,_('_Go')),
            ('HelpMenu',None,_('_Help')),
            ('Export',gtk.STOCK_SAVE,_('Export recipe'),
             None,_('Export selected recipe (save to file)'),
             self.export_cb),
            ('Delete',gtk.STOCK_DELETE,_('_Delete recipe'),
             None,_('Delete this recipe'),self.reccard.delete
             ),
            ('Close',gtk.STOCK_CLOSE,None,
             None,None,self.hide),
            ('Preferences',gtk.STOCK_PREFERENCES,None,
             None,None,self.preferences_cb),
            ('Help',gtk.STOCK_HELP,_('_Help'),
             None,None,lambda *args: de.show_faq(os.path.join(doc_base,'FAQ'),jump_to='Entering and Editing recipes')),
            ]
                                                )
        self.recipeDisplayActionGroup.add_toggle_actions([
            ('AllowUnitsToChange',None,_('Adjust units when multiplying'),
             None,
             _('Change units to make them more readable where possible when multiplying.'),
             self.toggle_readable_units_cb),
            ]
                                                       )
        self.recipeDisplayFuturePluginActionGroup = gtk.ActionGroup('RecipeDisplayFuturePluginActions')
        self.recipeDisplayFuturePluginActionGroup.add_actions([
            #('Email',None,_('E-_mail recipe'),
            # None,None,self.email_cb),
            ('Print',gtk.STOCK_PRINT,_('Print recipe'),
             '<Control>P',None,self.print_cb),
            ('ShopRec','add-to-shopping-list',None,None,None,self.shop_for_recipe_cb),
            ('ForgetRememberedOptionals',None,_('Forget remembered optional ingredients'),
             None,_('Before adding to shopping list, ask about all optional ingredients, even ones you previously wanted remembered'),self.forget_remembered_optional_ingredients), 
            ])
        ('Export',None,_('Export Recipe'),
         None,None,self.export_cb)

    def setup_ui (self):
        self.ui = gtk.Builder()
        self.ui.add_from_file(os.path.join(uibase,'recCardDisplay.ui'))

        self.ui.connect_signals({
            'shop_for_recipe':self.shop_for_recipe_cb,
            'edit_details': lambda *args: self.reccard.show_edit(module='description'),
            'edit_ingredients': lambda *args: self.reccard.show_edit(module='ingredients'),
            'edit_instructions': lambda *args: self.reccard.show_edit(module='instructions'),
            'edit_modifications': lambda *args: self.reccard.show_edit(module='notes'),
            })
        self.setup_widgets_from_ui()

    def setup_widgets_from_ui (self):
        self.display_info = ['title','rating','preptime','link',
                             'yields','yield_unit','cooktime','source',
                             'cuisine','category','instructions',
                             'modifications',]
        for attr in self.display_info:
            setattr(self,'%sDisplay'%attr,self.ui.get_object('%sDisplay'%attr))
            setattr(self,'%sDisplayLabel'%attr,self.ui.get_object('%sDisplayLabel'%attr))
            try:
                assert(getattr(self,'%sDisplay'%attr))
                if attr not in ['title','yield_unit']: 
                    assert(getattr(self,'%sDisplayLabel'%attr))
            except:
                print 'Failed to load all widgets for ',attr
                print '%sDisplay'%attr,'->',getattr(self,'%sDisplay'%attr)
                print '%sDisplayLabel'%attr,'->',getattr(self,'%sDisplayLabel'%attr)
                raise
        # instructions & notes display
        for d in ['instructionsDisplay','modificationsDisplay']:
            disp = getattr(self,d)
            disp.set_wrap_mode(gtk.WRAP_WORD)
            disp.set_editable(False)
            disp.connect('time-link-activated',
                         timeScanner.show_timer_cb,
                         self.rg.conv
                         )
        # link button
        self.linkDisplayButton = self.ui.get_object('linkDisplayButton')
        self.linkDisplayButton.connect('clicked',self.link_cb)
        # multiplication spinners
        self.yieldsDisplaySpin = self.ui.get_object('yieldsDisplaySpin')
        self.yieldsDisplaySpin.connect('changed',self.yields_change_cb)
        self.yieldsMultiplyByLabel = self.ui.get_object('multiplyByLabel')
        self.multiplyDisplaySpin = self.ui.get_object('multiplyByDisplaySpin')
        self.multiplyDisplaySpin.connect('changed',self.multiplication_change_cb)
        self.multiplyDisplayLabel = self.ui.get_object('multiplyByDisplayLabel')
        # Image display widget
        self.imageDisplay = self.ui.get_object('imageDisplay')
        # end setup_widgets_from_ui
        self.reflow_on_resize = [(getattr(self,'%sDisplay'%s[0]),s[1]) for s in [
            ('title',0.9), # label and percentage of screen it can take up...
            ('cuisine',0.5),
            ('category',0.5),
            ('source',0.5),
            ]]
        sw = self.ui.get_object('recipeBodyDisplay')
        sw.connect('size-allocate',self.reflow_on_allocate_cb)
        sw.set_redraw_on_allocate(True)                
        
    def reflow_on_allocate_cb (self, sw, allocation):
        hadj = sw.get_hadjustment()
        xsize = hadj.page_size
        width = allocation.width
        for widget,perc in self.reflow_on_resize:
            widg_width = int(xsize * perc)
            widget.set_size_request(widg_width,-1)
            t = widget.get_label()
            widget.set_label(t)
        # Flow our image...
        image_width = int(xsize * 0.75)
        if not hasattr(self,'orig_pixbuf') or not self.orig_pixbuf: return
        pb = self.imageDisplay.get_pixbuf()
        iwidth = pb.get_width()
        origwidth = self.orig_pixbuf.get_width()
        new_pb = None
        if iwidth > image_width:
            scale = float(image_width)/iwidth
            width = iwidth * scale
            height = pb.get_height() * scale
            new_pb = self.orig_pixbuf.scale_simple(
                int(width),
                int(height),
                gtk.gdk.INTERP_BILINEAR
                )
        elif (origwidth > iwidth) and (image_width > iwidth):
            if image_width < origwidth:
                scale = float(image_width)/origwidth
                width = image_width
                height = self.orig_pixbuf.get_height() * scale
                new_pb = self.orig_pixbuf.scale_simple(
                    int(width),
                    int(height),
                    gtk.gdk.INTERP_BILINEAR
                    )
            else:
                new_pb = self.orig_pixbuf
        if new_pb:
            del pb
            self.imageDisplay.set_from_pixbuf(new_pb)
        gc.collect()
        
    def setup_style (self,main=None):
        """Modify style of widgets so we have a white background"""
        if not main: main = self.main
        new_style = main.get_style().copy()
        cmap = main.get_colormap()
        new_style.bg[gtk.STATE_NORMAL]= cmap.alloc_color('white')
        new_style.bg[gtk.STATE_INSENSITIVE] = cmap.alloc_color('white')
        new_style.fg[gtk.STATE_NORMAL]= cmap.alloc_color('black')
        new_style.fg[gtk.STATE_INSENSITIVE] = cmap.alloc_color('black')
        # define a function to walk our widgets recursively 
        def set_style (widg, styl):
            if (not isinstance(widg,gtk.Button) and
                not isinstance(widg,gtk.Entry) and
                not isinstance(widg,gtk.Notebook) and
                not isinstance(widg,gtk.Separator)
                ): widg.set_style(styl)
            if hasattr(widg,'get_children'):
                for c in widg.get_children():
                    set_style(c,styl)
        set_style(main,new_style)
    
    # Main GUI setup
    def setup_main_window (self):
        self.window = gtk.Window();
        self.window.set_icon_from_file(os.path.join(imagedir,'reccard.png'))        
        self.window.connect('delete-event',self.hide)
        self.conf.append(WidgetSaver.WindowSaver(self.window,
                                                 self.prefs.get('reccard_window_%s'%self.current_rec.id,
                                                                {'window_size':(700,600)})
                                                 )
                         )
        self.window.set_default_size(*self.prefs.get('reccard_window_%s'%self.current_rec.id)['window_size'])
        main_vb = gtk.VBox()
        menu = self.ui_manager.get_widget('/RecipeDisplayMenuBar')
        main_vb.pack_start(menu,fill=False,expand=False); menu.show()
        self.messagebox = gtk.HBox()
        main_vb.pack_start(self.messagebox,fill=False,expand=False)
        self.main = self.ui.get_object('recipeDisplayMain')
        self.main.unparent()
        main_vb.pack_start(self.main); self.main.show()
        self.window.add(main_vb); main_vb.show()
        # Main has a series of important boxes which we will add our interfaces to...
        self.left_notebook = self.ui.get_object('recipeDisplayLeftNotebook')
        self.window.add_accel_group(self.ui_manager.get_accel_group())
        self.window.show()

    def setup_notebook (self):
        def hackish_notebook_switcher_handler (*args):
            # because the switch page signal happens before switching...
            # we'll need to look for the switch with an idle call
            gobject.idle_add(self.left_notebook_change_cb)
        self._last_module = None
        self.left_notebook.connect('switch-page',hackish_notebook_switcher_handler)
        self.left_notebook_pages = {}
        self.left_notebook_pages[0] = self

    def shop_for_recipe_cb (self, *args):
        print self,'shop_for_recipe_cb'
        import shopgui
        try:
            d = self.rg.sl.getOptionalIngDic(self.rg.rd.get_ings(self.current_rec),
                                             self.mult,
                                             self.prefs)
        except UserCancelledError:
            return
        self.rg.sl.addRec(self.current_rec,self.mult,d)
        self.rg.sl.show()

    def add_plugin_to_left_notebook (self, klass):
        instance = klass(self)
        tab_label = gtk.Label(instance.label)
        n = self.left_notebook.append_page(instance.main,tab_label=tab_label)
        self.left_notebook_pages[n] = instance
        instance.main.show(); tab_label.show()
        self.modules.append(instance)
        self.left_notebook.set_show_tabs(
            self.left_notebook.get_n_pages() > 1
            )

    def remove_plugin_from_left_notebook (self, klass):
        for mod in self.modules[:]:
            if isinstance(mod,klass):
                self.modules.remove(mod)
                page_num = self.left_notebook.page_num(mod.main)
                self.left_notebook.remove_page(
                    page_num
                    )
                del self.left_notebook_pages[page_num]
                del mod.main; del mod
        self.left_notebook.set_show_tabs(
            self.left_notebook.get_n_pages() > 1
            )

    def left_notebook_change_cb (self):
        page = self.left_notebook.get_current_page()
        module = self.left_notebook_pages.get(page,None)
        if (self._last_module and self._last_module != module
            and hasattr(self._last_module,'leave_page')
            ):
            self._last_module.leave_page()
        if module:
            if hasattr(module,'enter_page'): module.enter_page()
            self._last_module = module

    def update_from_database (self):
        # FIXME: remember to set sensitivity of remembered-optionals -
        # below is the old code to do so.  as long as we have the list
        # here, this is a good place to update the activity of our
        # menuitem for forgetting remembered optionals
        #remembered=False
        #for i in ings:
        #    if i.shopoptional==1 or i.shopoptional==2:
        #        remembered=True
        #        break
        #self.forget_remembered_optionals_menuitem = self.ui.get_object('forget_remembered_optionals_menuitem')
        #self.forget_remembered_optionals_menuitem.set_sensitive(remembered)
        for module in self.modules:
            # Protect ourselves from bad modules, since these could be
            # plugins
            try:
                module.update_from_database()
            except:
                print 'WARNING: Exception raised by %(module)s.update_from_database()'%locals()
                import traceback; traceback.print_exc()
        self.special_display_functions = {
            'yields':self.update_yields_display,
            'yield_unit':self.update_yield_unit_display,
            'title':self.update_title_display,
            'link':self.update_link_display,
            }
        self.update_image()
        for attr in self.display_info:
            if self.special_display_functions.has_key(attr):
                self.special_display_functions[attr]()
            else:
                widg=getattr(self,'%sDisplay'%attr)
                widgLab=getattr(self,'%sDisplayLabel'%attr)
                if not widg or not widgLab:
                    raise Exception("There is no widget or label for  %s=%s, %s=%s" % (attr, widg, "label", widgLab))
                if attr=='category':
                    attval = ', '.join(self.rg.rd.get_cats(self.current_rec))
                else:
                    attval = getattr(self.current_rec,attr)
                if attval:
                    debug('showing attribute %s = %s'%(attr,attval),0)
                    if attr=='rating':
                        widg.set_value(attval)
                    elif attr in ['preptime','cooktime']:
                        widg.set_text(convert.seconds_to_timestring(attval))
                    else:
                        widg.set_text(attval)
                        #if attr in ['modifications',#'instructions'
                        #            ]:
                        #    widg.set_use_markup(True)
                        #    widg.set_size_request(600,-1)
                    widg.show()
                    widgLab.show()
                else:
                    debug('hiding attribute %s'%attr,0)
                    widg.hide()
                    widgLab.hide()

    def update_image (self):
        imagestring = self.current_rec.image
        if not imagestring:
            self.orig_pixbuf = None
            self.imageDisplay.hide()
        else:
            self.orig_pixbuf = ie.get_pixbuf_from_jpg(imagestring)
            self.imageDisplay.set_from_pixbuf(
                self.orig_pixbuf
                )
            self.imageDisplay.show()

    def update_yield_unit_display (self):
        self.yield_unitDisplay.set_text(self.current_rec.yield_unit or '')
            
    def update_yields_display (self):
        self.yields_orig=self.current_rec.yields
        try:
            self.yields_orig = float(self.yields_orig)
        except:
            self.yields_orig = None
        if self.yields_orig:
            # in this case, display yields spinbutton and update multiplier label as necessary
            self.yieldsDisplay.show()
            self.yieldsDisplayLabel.show()
            self.multiplyDisplaySpin.hide()
            self.multiplyDisplayLabel.hide()
            #if yields:
            #    self.mult = float(yields)/float(self.yields_orig)
            #else:
            self.mult = 1
            yields=float(self.yields_orig)
            self.yieldsDisplaySpin.set_value(yields)
        else:
            #otherwise, display multiplier label and checkbutton
            self.yieldsDisplay.hide()
            self.yieldsDisplayLabel.hide()
            self.multiplyDisplayLabel.show()
            self.multiplyDisplaySpin.show()

    def update_title_display (self):
        titl = self.current_rec.title
        if not titl: titl="Unitled"
        self.window.set_title(titl)
        titl = "<b><big>" + xml.sax.saxutils.escape(titl) + "</big></b>"
        self.titleDisplay.set_label(titl)

    def update_link_display (self):
        if self.current_rec.link:
            self.linkDisplayButton.show()
            self.linkDisplay.set_markup(
                '<span underline="single" color="blue">%s</span>'%self.current_rec.link
                )
            self.link = self.current_rec.link
        else:
            self.link = ''
            self.linkDisplayButton.hide()
            self.linkDisplayLabel.hide()

    def export_cb (self, *args):
        opt = self.prefs.get('save_recipe_as','html')
        fn = exporters.exportManager.get_export_manager().offer_single_export(self.current_rec,self.prefs,parent=self.window,
                                                                              mult=self.mult)
        

    def toggle_readable_units_cb (self, widget):
        if widget.get_active():
            self.prefs['readableUnits']=True
            self.ingredientDisplay.display_ingredients()
        else:
            self.prefs['readableUnits']=False
            self.ingredientDisplay.display_ingredients()

    def preferences_cb (self, *args):
        self.rg.prefsGui.show_dialog(page=self.rg.prefsGui.CARD_PAGE)

    def hide (self, *args):
        self.window.hide()
        self.reccard.hide()
        return True

    # Future plugin callbacks
    # def email_cb (self, *args):
#         if self.reccard.edited:
#             if de.getBoolean(label=_("You have unsaved changes."),
#                              sublabel=_("Apply changes before e-mailing?")):
#                 self.saveEditsCB()
#         from exporters import recipe_emailer
#         d=recipe_emailer.EmailerDialog([self.current_rec],
#                                        self.rg.rd, self.prefs, self.rg.conv)
#         d.setup_dialog()
#         d.email()        

    def print_cb (self, *args):
        if self.reccard.edited:
            if de.getBoolean(label=_("You have unsaved changes."),
                             sublabel=_("Apply changes before printing?")):
                self.saveEditsCB()
        printManager = get_print_manager()
        printManager.print_recipes(
            self.rg.rd, [self.current_rec], mult=self.mult,
            parent=self.window,
            change_units=self.prefs.get('readableUnits',True)
           )

    def link_cb (self, *args): launch_url(self.link)

    def yields_change_cb (self, widg):
        self.update_yields_multiplier(widg.get_value())
        self.ingredientDisplay.display_ingredients() # re-update

    def multiplication_change_cb (self, widg):
        self.mult = widg.get_value()
        self.ingredientDisplay.display_ingredients() # re-update

    def update_yields_multiplier (self, val):
        yields = self.yieldsDisplaySpin.get_value()
        if yields == self.current_rec.yields:
            self.yield_unitDisplay.set_text(self.current_rec.yield_unit)
        if yields != self.current_rec.yields:
            # Consider pluralizing...
            plur_form = defaults.defaults.get_pluralized_form(self.current_rec.yield_unit,yields)
            if plur_form != self.yield_unitDisplay.get_text():
                # Change text!
                self.yield_unitDisplay.set_text(plur_form)
        if float(yields) != self.yields_orig:
            self.mult = float(yields)/self.yields_orig
        else:
            self.mult = 1
        if self.mult != 1:
            self.yieldsMultiplyByLabel.set_text("x %s"%convert.float_to_frac(self.mult))
        else:
            self.yieldsMultiplyByLabel.set_label('')

    def forget_remembered_optional_ingredients (self):
        pass


class IngredientDisplay:

    """The ingredient portion of our recipe display card.
    """
    
    def __init__ (self, recipe_display):
        self.recipe_display = recipe_display
        self.prefs = prefs.get_prefs()
        self.setup_widgets()
        self.recipe_display = recipe_display; self.rg = self.recipe_display.rg
        self.markup_ingredient_hooks = []

    def setup_widgets (self):
        self.ui = self.recipe_display.ui
        self.ingredientsDisplay = self.ui.get_object('ingredientsDisplay1')
        self.ingredientsDisplayLabel = self.ui.get_object('ingredientsDisplayLabel')
        self.ingredientsDisplay.connect('link-activated',
                                        self.show_recipe_link_cb)
        self.ingredientsDisplay.set_wrap_mode(gtk.WRAP_WORD)
        
    def update_from_database (self):
        self.ing_alist = self.rg.rd.order_ings(
            self.rg.rd.get_ings(self.recipe_display.current_rec)
            )
        self.display_ingredients()

    def display_ingredients (self):
        group_strings = []
        group_index = 0
        nut_highlighted = False
        for g,ings in self.ing_alist:
            labels = []
            if g: labels.append("<u>%s</u>"%xml.sax.saxutils.escape(g))
            ing_index = 0
            for i in ings:
                ing_strs = []
                amt,unit = self.rg.rd.get_amount_and_unit(i,
                                                          mult=self.recipe_display.mult,
                                                          conv=(self.prefs.get('readableUnits',True) and self.rg.conv or None)
                                                          )
                #if self.nutritional_highlighting and self.yields_orig:
                #    amt,unit = self.rg.rd.get_amount_and_unit(i,
                #                                              mult = 1.0/self.yields_orig,
                #                                              conv=(self.prefs.get('readableUnits',True) and self.rg.conv or None)
                #                                              )
                if amt: ing_strs.append(amt)
                if unit: ing_strs.append(unit)
                if i.item: ing_strs.append(i.item)
                if i.optional:
                    ing_strs.append(_('(Optional)'))
                istr = xml.sax.saxutils.escape(' '.join(ing_strs))                
                if i.refid:
                    istr = ('<a href="%s:%s">'%(i.refid,
                                                xml.sax.saxutils.escape(i.item))
                             + istr
                            + '</a>')
                istr = self.run_markup_ingredient_hooks(istr,i,
                                                        ing_index,
                                                        group_index)
                labels.append(
                    istr
                    )                
                ing_index += 1
            group_strings.append('\n'.join(labels))
            group_index += 1
        label = '\n\n'.join(group_strings)
        if nut_highlighted:
            label = '<i>Highlighting amount of %s in each ingredient.</i>\n'%self.nutritionLabel.active_label+label
        if label:
            self.ingredientsDisplay.set_text(label)
            self.ingredientsDisplay.set_editable(False)
            self.ingredientsDisplay.show()
            self.ingredientsDisplayLabel.show()
        else:
            self.ingredientsDisplay.hide()
            self.ingredientsDisplayLabel.hide()        

    def run_markup_ingredient_hooks (self, ing_string, ing_obj, ing_index, group_index):
        for hook in self.markup_ingredient_hooks:
            # each hook gets the following args:
            # ingredient string, ingredient object, ingredient index, group index
            ing_string = hook(ing_string, ing_obj, ing_index, group_index)
        return ing_string

    def create_ing_alist (self):
        """Create alist ing_alist based on ingredients in DB for current_rec"""
        ings=self.rg.rd.get_ings(self.get_current_rec())
        self.ing_alist = self.rg.rd.order_ings(ings)
        debug('self.ing_alist updated: %s'%self.ing_alist,1)

    # Callbacks

    def show_recipe_link_cb (self, widg, link):
        rid,rname = link.split(':',1)
        rec = self.rg.rd.get_rec(int(rid))
        if not rec:
            rec = self.rg.rd.fetch_one(
                self.rg.rd.recipe_table,
                title=rname
                )
        if rec:
            self.rg.open_rec_card(rec)
        else:
            de.show_message(parent=self.display_window,
                            label=_('Unable to find recipe %s in database.')%rname
                            )

# RECIPE EDITOR MODULES

class RecEditor (WidgetSaver.WidgetPrefs, plugin_loader.Pluggable):

    ui_string = '''
    <ui>
      <menubar name="RecipeEditorMenuBar">
        <menu name="Recipe" action="Recipe">
          <menuitem action="ShowRecipeCard"/>
          <separator/>
          <menuitem action="DeleteRecipe"/>
          <menuitem action="Revert"/>
          <menuitem action="Save"/>
          <separator/>
          <menuitem action="Close"/>
        </menu>
        <menu name="Edit" action="Edit">
          <placeholder name="EditActions"/>
          <separator/>
          <menuitem action="Preferences"/>
        </menu>
        <!--<menu name="Go" action="Go"/>-->
        <menu name="Tools" action="Tools">
        <placeholder name="StandaloneTool">
          <menuitem action="UnitConverter"/>
          </placeholder>
          <separator/>
          <placeholder name="DataTool">          
          </placeholder>
        </menu>
        <menu name="HelpMenu" action="HelpMenu">
          <menuitem action="Help"/>
        </menu>
      </menubar>
      <toolbar name="RecipeEditorToolBar">
        <toolitem action="Save"/>
        <toolitem action="Revert"/>
        <separator/>
        <toolitem action="Undo"/>
        <toolitem action="Redo"/>
        <separator/>
        <toolitem action="ShowRecipeCard"/>
      </toolbar>
      <toolbar name="RecipeEditorEditToolBar"/>
    </ui>
    '''    

    def __init__ (self, reccard, rg, recipe=None, recipe_display=None, new=False):
        self.edited = False
        self.editor_module_classes = [
            DescriptionEditorModule,
            IngredientEditorModule,
            InstructionsEditorModule,
            NotesEditorModule,
            ]
        self.reccard= reccard; self.rg = rg; self.recipe_display = recipe_display
        if self.recipe_display and not recipe:
            recipe = self.recipe_display.current_rec
        self.current_rec = recipe
        self.setup_defaults()
        self.conf = reccard.conf
        self.setup_ui_manager()
        #self.setup_undo()        
        self.setup_main_interface()
        self.setup_modules()
        self.setup_notebook()
        self.page_specific_handlers = []
        #self.setEdited(False)
        # parameters for tracking what has changed
        self.widgets_changed_since_save = {}
        self.new = True
        if recipe and not new:
            #self.updateRecipe(recipe,show=False)
            self.new = False
        elif not recipe:
            recipe=self.rg.rd.new_rec()
        self.set_edited(False)
        plugin_loader.Pluggable.__init__(self,[ToolPlugin,RecEditorPlugin])
        self.mm = mnemonic_manager.MnemonicManager()
        self.mm.add_toplevel_widget(self.window)
        self.mm.fix_conflicts_peacefully()        
        self.show()
        self.modules[0].grab_focus()

    def present (self):
        self.window.present()
        self.modules[0].grab_focus()
        
    def setup_defaults (self):
        self.edit_title = _('Edit Recipe:')

    def setup_ui_manager (self):
        self.ui_manager = gtk.UIManager()
        self.ui_manager.add_ui_from_string(self.ui_string)
        self.setup_action_groups()
        fix_action_group_importance(self.mainRecEditActionGroup)
        self.ui_manager.insert_action_group(self.mainRecEditActionGroup,0)
        fix_action_group_importance(self.rg.toolActionGroup)
        self.ui_manager.insert_action_group(self.rg.toolActionGroup,1)

    def setup_action_groups (self):
        self.mainRecEditActionGroup = gtk.ActionGroup('RecEditMain')

        self.mainRecEditActionGroup.add_actions([
            # menus
            ('Recipe',None,_('_Recipe')), 
            ('Edit',None,_('_Edit')),
            ('Help',gtk.STOCK_HELP,None),
            ('HelpMenu',None,_('_Help')),
            ('Save',gtk.STOCK_SAVE,None,
             '<Control>s',_('Save edits to database'),self.save_cb), #saveEdits
            ('DeleteRecipe',gtk.STOCK_DELETE,_('_Delete Recipe'),
             None,None,self.delete_cb),
            ('Revert',gtk.STOCK_REVERT_TO_SAVED,None,
             None,None,self.revert_cb), # revertCB
            ('Close',gtk.STOCK_CLOSE,None,
             None,None,self.close_cb), 
            ('Preferences',gtk.STOCK_PREFERENCES,None,
             None,None,self.preferences_cb), # show_pref_dialog
            ('ShowRecipeCard','recipe-card',_('View Recipe Card'),
             None,None,self.show_recipe_display_cb), #view_recipe_card
            ])

    def setup_modules (self):
        self.modules = []
        self.module_tab_by_name = {}
        for klass in self.editor_module_classes:
            instance = klass(self)
            tab_label = gtk.Label(instance.label)
            n = self.notebook.append_page(
                instance.main,
                tab_label=tab_label)
            self.module_tab_by_name[instance.name] = n
            instance.main.show(); tab_label.show()
            instance.connect('toggle-edited',self.module_edited_cb)
            self.modules.append(instance)

    def add_plugin (self, klass, position=None):
        """Register any external plugins"""
        instance = klass(self)
        if instance.__class__ in self.editor_module_classes: return # these are handled in setup_modules...
        tab_label = gtk.Label(instance.label)
        if not position:
            n = self.notebook.append_page(instance.main,tab_label=tab_label)
        else:
            n = self.notebook.insert_page(instance.main,tab_label=tab_label,position=position)
            # We'll need to reset the other plugin's positions if we shoved one in the middle
            for mod in self.modules[position:]:
                self.module_tab_by_name[mod.name] = self.notebook.page_num(mod.main)
        self.module_tab_by_name[instance.name] = n
        #self.plugins.append(instance)
        if not position:
            self.modules.append(instance)
        else:
            self.modules = self.modules[:position] + [instance] + self.modules[position:]
        instance.main.show(); tab_label.show()
        instance.connect('toggle-edited',self.module_edited_cb)

    def module_edited_cb (self, module, val):
        if val:
            self.set_edited(True)
        else:
            for m in self.modules:
                if m.edited:
                    #print 'Strange,',module,'told us we are not edited, but ',m,'tells us we are...'
                    self.set_edited(True)
                    return
            self.set_edited(False)

    def show_module (self, module_name):
        """Show the part of our interface corresponding with module
        named module_name."""
        if not self.module_tab_by_name.has_key(module_name):
            raise ValueError('RecEditor has no module named %s'%module_name)
        self.notebook.set_current_page(
            self.module_tab_by_name[module_name]
            )

    def setup_main_interface (self):
        self.window = gtk.Window()
        self.window.set_icon_from_file(os.path.join(imagedir,'reccard_edit.png'))
        title = ((self.current_rec and self.current_rec.title) or _('New Recipe')) + ' (%s)'%_('Edit')
        self.window.set_title(title)
        self.window.connect('delete-event',
                            self.close_cb)
        self.conf.append(WidgetSaver.WindowSaver(self.window,
                                                 self.rg.prefs.get('rec_editor_window',
                                                                   {'window_size':(700,600)})
                                                 )
                         )
        self.window.set_default_size(*prefs.get_prefs().get('rec_editor_window')['window_size'])
        main_vb = gtk.VBox()
        main_vb.pack_start(self.ui_manager.get_widget('/RecipeEditorMenuBar'),expand=False,fill=False)
        main_vb.pack_start(self.ui_manager.get_widget('/RecipeEditorToolBar'),expand=False,fill=False)
        main_vb.pack_start(self.ui_manager.get_widget('/RecipeEditorEditToolBar'),expand=False,fill=False)
        self.notebook = gtk.Notebook(); self.notebook.show()
        main_vb.pack_start(self.notebook)
        self.window.add(main_vb)
        self.window.add_accel_group(self.ui_manager.get_accel_group())
        main_vb.show()

    def show (self):
        self.window.present()

    def setup_notebook (self):
        def hackish_notebook_switcher_handler (*args):
            # because the switch page signal happens before switching...
            # we'll need to look for the switch with an idle call
            gobject.idle_add(self.notebook_change_cb)
        self.notebook.connect('switch-page',hackish_notebook_switcher_handler)
        ## The following workaround was necessary on Windows as long as
        ## https://bugzilla.gnome.org/show_bug.cgi?id=552681
        ## was not fixed, which it is with versions of Gtk+ that ship
        ## with PyGTK 2.24.8
        #if os.name == 'nt' or os.name == 'dos':
        #    self.notebook.set_tab_pos(gtk.POS_TOP)
        #else:
        self.notebook.set_tab_pos(gtk.POS_LEFT)
        self._last_module = None
        self.last_merged_ui = None
        self.last_merged_action_groups = None
        self.notebook_change_cb()

    def set_edited (self, edited):
        self.edited = edited
        if edited:
            self.mainRecEditActionGroup.get_action('Save').set_sensitive(True)
            self.mainRecEditActionGroup.get_action('Revert').set_sensitive(True)            
        else:
            self.mainRecEditActionGroup.get_action('Save').set_sensitive(False)
            self.mainRecEditActionGroup.get_action('Revert').set_sensitive(False)

    def update_from_database (self):
        for mod in self.modules:
            mod.update_from_database()
            mod.__edited = False
            
    def notebook_change_cb (self, *args):
        """Update menus and toolbars"""
        page=self.notebook.get_current_page()
        #self.history.switch_context(page)
        if self.last_merged_ui is not None:
            self.ui_manager.remove_ui(self.last_merged_ui)
            for ag in self.last_merged_action_groups:
                self.ui_manager.remove_action_group(ag)
        self.last_merged_ui = self.ui_manager.add_ui_from_string(self.modules[page].ui_string)
        for ag in self.modules[page].action_groups:
            fix_action_group_importance(ag)
            self.ui_manager.insert_action_group(ag,0)
        self.last_merged_action_groups = self.modules[page].action_groups
        module = self.modules[page]
        if (self._last_module and self._last_module!=module
            and hasattr(self._last_module,'leave_page')
            ):
            self._last_module.leave_page()
        if module:
            if hasattr(module,'enter_page'): module.enter_page()
            self._last_module = module

    def save_cb (self, *args):
        self.widgets_changed_since_save = {}
        self.mainRecEditActionGroup.get_action('ShowRecipeCard').set_sensitive(True)
        self.new = False
        newdict = {'id': self.current_rec.id}
        for m in self.modules:
            newdict = m.save(newdict)
        self.current_rec = self.rg.rd.modify_rec(self.current_rec,newdict)
        self.rg.rd.update_hashes(self.current_rec)
        self.rg.rmodel.update_recipe(self.current_rec)
        if newdict.has_key('title'):
            self.window.set_title("%s %s"%(self.edit_title,self.current_rec.title.strip()))
        self.set_edited(False)
        self.reccard.new = False
        self.reccard.update_recipe(self.current_rec) # update display (if any)
        self.rg.update_go_menu()
        self.rg.rd.save()        

    def revert_cb (self, *args):
        self.update_from_database()
        self.set_edited(False)

    def delete_cb (self, *args):
        self.rg.rec_tree_delete_recs([self.current_rec])

    def close_cb (self, *args):
        if self.edited:
            try:
                save_me = de.getBoolean(
                    title=_("Save changes to %s")%self.current_rec.title,                    
                    label=_("Save changes to %s")%self.current_rec.title,
                    custom_yes=gtk.STOCK_SAVE,
                    )
            except de.UserCancelledError:
                return
            if save_me:
                self.save_cb()
        self.window.hide()
        self.reccard.hide()
        if self.new:
            # If we are new and unedited, delete...
            self.rg.rd.delete_rec(self.current_rec)
            self.rg.redo_search()
        return True

    def preferences_cb (self, *args):
        """Show our preference dialog for the recipe card."""
        self.rg.prefsGui.show_dialog(page=self.rg.prefsGui.CARD_PAGE)        

    def show_recipe_display_cb (self, *args):
        """Show recipe card display (not editor)."""
        self.reccard.show_display()


class IngredientEditorModule (RecEditorModule):

    name = 'ingredients'
    label = _('Ingredients')
    ui_string = '''
      <menubar name="RecipeEditorMenuBar">
        <menu name="Edit" action="Edit">
          <placeholder name="EditActions">
          <menuitem action="AddIngredient"/>
          <menuitem action="DeleteIngredient"/>
          <menuitem action="AddIngredientGroup"/>
          <menuitem action="PasteIngredient"/>
          <separator/>
          <menuitem action="MoveIngredientUp"/>
          <menuitem action="MoveIngredientDown"/>
          <separator/>
          <menuitem action="AddRecipeAsIngredient"/>
          <menuitem action="ImportIngredients"/>
          </placeholder>
        </menu>
      </menubar>
      <toolbar name="RecipeEditorEditToolBar">
        <toolitem action="MoveIngredientUp"/>
        <toolitem action="MoveIngredientDown"/>
        <toolitem action="DeleteIngredient"/>
        <separator/>
        <toolitem  action="AddIngredientGroup"/>
        <toolitem action="AddRecipeAsIngredient"/>
        <separator/>
        <toolitem action="ImportIngredients"/>
        <toolitem action="PasteIngredient"/>
        <separator/>
      </toolbar>
    '''

    def setup (self):
        pass

    def setup_main_interface (self):
        self.ui = gtk.Builder()
        self.ui.add_from_file(os.path.join(uibase,'recCardIngredientsEditor.ui'))
        self.main = self.ui.get_object('ingredientsNotebook')
        self.main.unparent()
        self.ingtree_ui = IngredientTreeUI(self, self.ui.get_object('ingTree'))
        self.setup_action_groups()
        self.update_from_database()
        self.quickEntry = self.ui.get_object('quickIngredientEntry')
        self.ui.connect_signals({'addQuickIngredient':self.quick_add})

    def quick_add (self, *args):
        txt = unicode(self.quickEntry.get_text())
        prev_iter,group_iter = self.ingtree_ui.get_previous_iter_and_group_iter()
        add_with_undo(self,
                      lambda *args: self.add_ingredient_from_line(txt,
                                                                  prev_iter=prev_iter,
                                                                  group_iter=group_iter)
                      )
        self.quickEntry.set_text('')

    def update_from_database (self):
        self.ingtree_ui.set_tree_for_rec(self.current_rec)

    def setup_action_groups (self):
        self.ingredientEditorActionGroup = gtk.ActionGroup('IngredientEditorActionGroup')
        self.ingredientEditorOnRowActionGroup = gtk.ActionGroup('IngredientEditorOnRowActionGroup')        
        self.ingredientEditorActionGroup.add_actions([
            ('AddIngredient',gtk.STOCK_ADD,_('Add ingredient'),
             None,None),
            ('AddIngredientGroup',None,_('Add group'),
             '<Control>G',None,self.ingtree_ui.ingNewGroupCB),
            ('PasteIngredient',gtk.STOCK_PASTE,_('Paste ingredients'),
             '<Control>V',None,self.paste_ingredients_cb),
            ('ImportIngredients',None,_('Import from file'),
             '<Control>O',None,self.import_ingredients_cb),
            ('AddRecipeAsIngredient',None,_('Add _recipe'),
             '<Control>R',_('Add another recipe as an ingredient in this recipe'),
             lambda *args: RecSelector(self.rg, self)),
            ])
        self.ingredientEditorOnRowActionGroup.add_actions([
            ('DeleteIngredient',gtk.STOCK_DELETE,_('Delete'),
             #'Delete', # Binding to the delete key meant delete
             #pressed anywhere would do this, icnluding in a text
             #field
             None, 
             None,self.delete_cb),            
            ('MoveIngredientUp',gtk.STOCK_GO_UP,_('Up'),
             '<Control>Up',None,self.ingtree_ui.ingUpCB),
            ('MoveIngredientDown',gtk.STOCK_GO_DOWN,_('Down'),
             '<Control>Down',None,self.ingtree_ui.ingDownCB),
            ])
        for group in [self.ingredientEditorActionGroup,
                      self.ingredientEditorOnRowActionGroup,
                      ]:
            fix_action_group_importance(group)
        self.action_groups.append(self.ingredientEditorActionGroup)
        self.action_groups.append(self.ingredientEditorOnRowActionGroup)

    def add_ingredient_from_line (self, line, group_iter=None, prev_iter=None):
        """Add an ingredient to our list from a line of plain text"""
        d=self.rg.rd.parse_ingredient(line, conv=self.rg.conv)
        if d:
            if d.has_key('rangeamount'):
                d['amount'] = self.rg.rd._format_amount_string_from_amount(
                    (d['amount'],d['rangeamount'])
                    )    
                del d['rangeamount']
            elif d.has_key('amount'):
                d['amount'] = convert.float_to_frac(d['amount'])
        else:
            d = {}
            d['item'] = line
            d['amount'] = None
            d['unit'] = None
        itr = self.ingtree_ui.ingController.add_new_ingredient(prev_iter=prev_iter,group_iter=group_iter,**d)
        # If there is just one row selected...
        sel = self.ingtree_ui.ingTree.get_selection()
        if sel.count_selected_rows()==1:
            # Then we move our selection down to our current ingredient...
            sel.unselect_all()
            sel.select_iter(itr)
        # Make sure our newly added ingredient is visible...
        self.ingtree_ui.ingTree.scroll_to_cell(
            self.ingtree_ui.ingController.imodel.get_path(itr)
            )
        return itr

    def importIngredients (self, file):
        ifi=file(file,'r')
        for line in ifi:
            self.ingtree_ui.add_ingredient_from_line(line)

    def import_ingredients_cb (self, *args):
        debug('importIngredientsCB',5) #FIXME
        f=de.select_file(_("Choose a file containing your ingredient list."),action=gtk.FILE_CHOOSER_ACTION_OPEN)
        add_with_undo(self, lambda *args: self.importIngredients(f))

    def paste_ingredients_cb (self, *args):
        self.cb = gtk.clipboard_get()
        def add_ings_from_clippy (cb,txt,data):
            if txt:
                def do_add ():
                    for l in txt.split('\n'):
                        if l.strip(): self.add_ingredient_from_line(l)
                add_with_undo(self, lambda *args: do_add())
        self.cb.request_text(add_ings_from_clippy)

    def delete_cb (self, *args):
        debug("delete_cb (self, *args):",5)
        mod,rows = self.ingtree_ui.ingTree.get_selection().get_selected_rows()
        rows.reverse()
        self.ingtree_ui.ingController.delete_iters(*[mod.get_iter(p) for p in rows])


    def save (self, recdic):
        # Save ingredients...
        self.ingtree_ui.ingController.commit_ingredients()
        self.emit('saved')
        return recdic

class TextEditor:

    def setup (self):
        self.edit_widgets = [] # for keeping track of editable widgets
        self.edit_textviews = [] # for keeping track of editable
                                 # textviews

    def setup_action_groups (self):
        self.copyPasteActionGroup = gtk.ActionGroup('CopyPasteActionGroup')
        self.copyPasteActionGroup.add_actions([
            ('Copy',gtk.STOCK_COPY,None,None,None,self.do_copy),
            ('Paste',gtk.STOCK_PASTE,None,None,None,self.do_paste),
            ('Cut',gtk.STOCK_CUT,None,None,None,self.do_cut),            
            ])
        self.cb = gtk.Clipboard()
        gobject.timeout_add(500,self.do_sensitize)
        self.action_groups.append(self.copyPasteActionGroup)

    def do_sensitize (self):
        for w in self.edit_widgets:
            if w.has_focus():
                self.copyPasteActionGroup.get_action('Copy').set_sensitive(
                    w.get_selection_bounds() and True or False
                    )
                self.copyPasteActionGroup.get_action('Cut').set_sensitive(
                    w.get_selection_bounds() and True or False
                    )
                self.copyPasteActionGroup.get_action('Paste').set_sensitive(
                    self.cb.wait_is_text_available() or False
                    )
                return True
        for tv in self.edit_textviews:
            tb = tv.get_buffer()
            self.copyPasteActionGroup.get_action('Copy').set_sensitive(
                tb.get_selection_bounds() and True or False
                )
            self.copyPasteActionGroup.get_action('Cut').set_sensitive(
                tb.get_selection_bounds() and True or False
                )
            self.copyPasteActionGroup.get_action('Paste').set_sensitive(
                self.cb.wait_is_text_available() or False
                )
        return True
        
    def do_copy (self, *args):
        for w in self.edit_widgets:        
            if w.has_focus():
                w.copy_clipboard()
                return
        for tv in self.edit_textviews:
            tv.get_buffer().copy_clipboard(self.cb)

    def do_cut (self, *args):
        for w in self.edit_widgets:        
            if w.has_focus():
                w.cut_clipboard()
        for tv in self.edit_textviews:
            buf  = tv.get_buffer()
            buf.cut_clipboard(self.cb,tv.get_editable())

    def do_paste (self, *args):
        text = self.cb.wait_for_text()
        if self.edit_widgets:
            widget = self.edit_widgets[0]
        else:
            widget = self.edit_textviews[0]
        parent = widget.parent
        while parent and not hasattr(parent,'focus_widget') :
            parent = parent.parent
        widget = parent.focus_widget
        if isinstance(widget,gtk.TextView):
            buf = widget.get_buffer()
            buf.paste_clipboard(self.cb,None,widget.get_editable())
        elif isinstance(widget,gtk.Editable):
            widget.paste_clipboard()
        else:
            print 'What has focus?',widget
        
class DescriptionEditorModule (TextEditor, RecEditorModule):
    name = 'description'
    label = _('Description')
    ui_string = '''
      <menubar name="RecipeEditorMenuBar">
        <menu name="Edit" action="Edit">
          <placeholder name="EditActions">
            <menuitem action="Undo"/>
            <menuitem action="Redo"/>
            <separator/>
            <menuitem action="Cut"/>
            <menuitem action="Copy"/>
            <menuitem action="Paste"/>
          </placeholder>
        </menu>
      </menubar>
      <toolbar name="RecipeEditorToolBar">
        <toolitem action="Cut"/>
        <toolitem action="Copy"/>
        <toolitem action="Paste"/>
      </toolbar>
    '''

    def __init__ (self, *args):
        RecEditorModule.__init__(self, *args)

    def setup_main_interface (self):
        self.ui = gtk.Builder()
        self.ui.add_from_file(os.path.join(uibase,'recCardDescriptionEditor.ui'))
        self.imageBox = ImageBox(self)
        self.init_recipe_widgets()
        # Set up wrapping callbacks...
        self.ui.connect_signals({
            'setRecImage' : self.imageBox.set_from_fileCB,
            'delRecImage' : self.imageBox.removeCB,            
            })
        self.main = self.ui.get_object('descriptionMainWidget')
        self.main.unparent()

    def init_recipe_widgets (self):
        self.rw = {}
        self.recent = []
        self.reccom = []        
        for a,l,w in REC_ATTRS:
            if w=='Entry': self.recent.append(a)
            elif w=='Combo': self.reccom.append(a)
            else: raise Exception("REC_ATTRS widget type %s not recognized" % w)
        for a in self.reccom:
            self.rw[a]=self.ui.get_object("%sBox"%a)
            try:
                assert(self.rw[a])
            except:
                print 'No recipe editing widget for',a
                raise
            self.edit_widgets.append(self.rw[a])
            self.rw[a].db_prop = a
            # Set up accessibility
            atk = (find_entry(self.rw[a]) or self.rw[a]).get_accessible()
            atk.set_name(REC_ATTR_DIC[a]+' Entry')
            #self.rw[a].get_children()[0].connect('changed',self.changed_cb)
        for a in self.recent:            
            self.rw[a]=self.ui.get_object("%sBox"%a)
            try:
                assert(self.rw[a])
            except:
                print 'No recipe editing widget for',a
                raise
            self.edit_widgets.append(self.rw[a])            
            self.rw[a].db_prop = a
            # Set up accessibility
            atk = (find_entry(self.rw[a]) or self.rw[a]).get_accessible()
            atk.set_name(REC_ATTR_DIC[a]+' Entry')
            #self.rw[a].connect('changed',self.changed_cb)
        self.update_from_database()

    def update_from_database (self):
        try:
            self.yields = float(self.current_rec.yields)
        except:
            self.yields = None
            if hasattr(self.current_rec,'yields'):
                debug(_("Couldn't make sense of %s as number of yields")%self.current_rec.yields,0)
        for c in self.reccom:
            debug("Widget for %s"%c,5)
            model = self.rg.get_attribute_model(c)
            self.rw[c].set_model(model)
            self.rw[c].set_text_column(0)
            cb.setup_completion(self.rw[c])
            if c=='category':
                val = ', '.join(self.rg.rd.get_cats(self.current_rec))
            else:
                val = getattr(self.current_rec,c)
            self.rw[c].entry.set_text(val or "")
            if isinstance(self.rw[c],gtk.ComboBoxEntry):
                Undo.UndoableEntry(self.rw[c].get_child(),self.history)
                cb.FocusFixer(self.rw[c])
            else:
                # we still have to implement undo for regular old comboBoxen!
                1
        for e in self.recent:
            if isinstance(self.rw[e],gtk.SpinButton):
                try:
                    self.rw[e].set_value(float(getattr(self.current_rec,e)))
                except:
                    debug('%s Value %s is not floatable!'%(e,getattr(self.current_rec,e)))
                    self.rw[e].set_text("")
                Undo.UndoableGenericWidget(self.rw[e],self.history, signal='value-changed')
            elif e in INT_REC_ATTRS:
                self.rw[e].set_value(int(getattr(self.current_rec,e) or 0))
                Undo.UndoableGenericWidget(self.rw[e],
                                           self.history)
            else:
                self.rw[e].set_text(getattr(self.current_rec,e) or "")
                Undo.UndoableEntry(self.rw[e],self.history)
        self.imageBox.get_image()

    def grab_focus (self):
        self.ui.get_object('titleBox').grab_focus()
        
    def save (self, recdic):
        for c in self.reccom:
            recdic[c]=unicode(self.rw[c].entry.get_text())
        for e in self.recent:
            if e in INT_REC_ATTRS +  FLOAT_REC_ATTRS:
                recdic[e]=self.rw[e].get_value()
            else:
                recdic[e]=unicode(self.rw[e].get_text())
        if self.imageBox.edited:
            recdic['image'],recdic['thumb']=self.imageBox.commit()
            self.imageBox.edited=False
        self.emit('saved')
        return recdic

class ImageBox: # used in DescriptionEditor for recipe image.
    def __init__ (self, RecCard):
        debug("__init__ (self, RecCard):",5)
        self.edited = False
        self.rg = RecCard.rg
        self.rc = RecCard
        self.ui = self.rc.ui
        self.imageW = self.ui.get_object('recImage')
        self.addW = self.ui.get_object('addImage')
        self.delW = self.ui.get_object('delImageButton')
        self.image = None

    def get_image (self, rec=None):
        """Set image based on current recipe."""
        debug("get_image (self, rec=None):",5)
        if not rec:
            rec=self.rc.current_rec
        if rec.image:
            try:
                self.set_from_string(rec.image)
            except:
                print 'Problem with image from recipe.'
                print 'Moving ahead anyway.'
                print 'Here is the traceback'
                import traceback; traceback.print_exc()
                print "And for your debugging convenience, I'm dumping"
                print "a copy of the faulty image in /tmp/bad_image.jpg"
                import tempfile
                try:
                    dumpto = os.path.join(tempfile.tempdir,'bad_image.jpg')
                    ofi = file(dumpto,'w')
                    ofi.write(rec.image)
                    ofi.close()
                except:
                    print 'Nevermind -- I had a problem dumping the file.'
                    traceback.print_exc()
                    print '(Ignoring this traceback...)'
        else:
            self.image=None
            self.hide()

    def hide (self):
        debug("hide (self):",5)
        self.imageW.hide()
        self.delW.hide()
        self.addW.show()
        return True

    def commit (self):
        debug("commit (self):",5)
        """Return image and thumbnail data suitable for storage in the database"""
        if self.image:
            self.imageW.show()
            return ie.get_string_from_image(self.image),ie.get_string_from_image(self.thumb)
        else:
            self.imageW.hide()
            return '',''
    
    def draw_image (self):
        debug("draw_image (self):",5)
        """Put image onto widget"""
        if self.image:
            self.win = self.imageW.get_parent_window()
            if self.win:
                wwidth,wheight=self.win.get_size()
                wwidth=int(float(wwidth)/3)
                wheight=int(float(wheight)/3)
            else:
                wwidth,wheight=100,100
            self.image=ie.resize_image(self.image,wwidth,wheight)
            self.thumb=ie.resize_image(self.image,40,40)
            self.set_from_string(ie.get_string_from_image(self.image))
        else:
            self.hide()

    def show_image (self):
        debug("show_image (self):",5)
        """Show widget and switch around buttons sensibly"""
        self.addW.hide()
        self.imageW.show()
        self.delW.show()

    def set_from_string (self, string):
        debug("set_from_string (self, string):",5)
        pb=ie.get_pixbuf_from_jpg(string)
        self.imageW.set_from_pixbuf(pb)
        self.orig_pixbuf = pb
        self.show_image()

    def set_from_file (self, file):
        debug("set_from_file (self, file):",5)
        self.image = Image.open(file)
        self.draw_image()
        
    def set_from_fileCB (self, *args):
        debug("set_from_fileCB (self, *args):",5)
        f=de.select_image("Select Image",action=gtk.FILE_CHOOSER_ACTION_OPEN)
        if f:
            Undo.UndoableObject(
                lambda *args: self.set_from_file(f),
                lambda *args: self.remove_image(),
                self.rc.history,
                widget=self.imageW).perform()
            self.edited=True

    def removeCB (self, *args):
        debug("removeCB (self, *args):",5)
        #if de.getBoolean(label="Are you sure you want to remove this image?",
        #                 parent=self.rc.widget):
        if self.image:
            current_image = ie.get_string_from_image(self.image)
        else:
            current_image = ie.get_string_from_pixbuf(self.orig_pixbuf)
        Undo.UndoableObject(
            lambda *args: self.remove_image(),
            lambda *args: self.set_from_string(current_image),
            self.rc.history,
            widget=self.imageW).perform()

    def remove_image (self):
        self.image=None
        self.orig_pixbuf = None
        self.draw_image()
        self.edited=True


class TextFieldEditor (TextEditor):
    ui_string = '''
      <menubar name="RecipeEditorMenuBar">
        <menu name="Edit" action="Edit">
          <placeholder name="EditActions">
            <menuitem action="Undo"/>
            <menuitem action="Redo"/>
            <separator/>
            <menuitem action="Cut"/>            
            <menuitem action="Copy"/>
            <menuitem action="Paste"/>
            <separator/>
            <menuitem action="Underline"/>
            <menuitem action="Bold"/>
            <menuitem action="Italic"/>
          </placeholder>
        </menu>
      </menubar>
      <toolbar name="RecipeEditorEditToolBar">
        <toolitem action="Underline"/>
        <toolitem action="Bold"/>
        <toolitem action="Italic"/>
        <separator/>
        <toolitem action="Cut"/>        
        <toolitem action="Copy"/>
        <toolitem action="Paste"/>
        <separator/>
      </toolbar>
    '''
    prop = None

    def setup (self): # Text Field Editor
        self.images = [] # For inline images in text fields (future)
        TextEditor.setup(self)

    def setup_action_groups (self):
        TextEditor.setup_action_groups(self)
        self.richTextActionGroup = gtk.ActionGroup('RichTextActionGroup')
        self.richTextActionGroup.add_toggle_actions([
            ('Bold',gtk.STOCK_BOLD,None,'<Control>B',None,None),
            ('Italic',gtk.STOCK_ITALIC,None,'<Control>I',None,None),
            ('Underline',gtk.STOCK_UNDERLINE,None,'<Control>U',None,None),            
            ])
        for action,markup in [('Bold','<b>b</b>'),
                              ('Italic','<i>i</i>'),
                              ('Underline','<u>u</u>')]:
            self.tv.get_buffer().setup_widget_from_pango(
                self.richTextActionGroup.get_action(action),
                markup
                )
        self.action_groups.append(self.richTextActionGroup)

    def setup_main_interface (self):
        self.main = gtk.ScrolledWindow()
        self.main.set_policy(gtk.POLICY_AUTOMATIC,gtk.POLICY_AUTOMATIC)
        self.tv = gtk.TextView()
        self.main.add(self.tv)
        buf = TextBufferMarkup.InteractivePangoBuffer()
        self.tv.set_wrap_mode(gtk.WRAP_WORD)
        self.tv.set_buffer(buf)
        self.tv.show()
        self.tv.db_prop = self.prop
        if not self.label:
            print 'Odd,',self,'has no label'
        else:
            atk = self.tv.get_accessible()
            atk.set_name(self.label + ' Text')
        self.update_from_database()
        Undo.UndoableTextView(self.tv,self.history)
        self.setup_action_groups()
        self.edit_textviews = [self.tv]

    def update_from_database (self):
        txt = getattr(self.re.current_rec,self.prop)
        if txt:
            txt = txt.encode('utf8','ignore')
        else:
            txt = "".encode('utf8')
        self.tv.get_buffer().set_text(txt)

    def save (self, recdic):
        recdic[self.prop] = self.tv.get_buffer().get_text()
        self.emit('saved')
        return recdic

class InstructionsEditorModule (TextFieldEditor,RecEditorModule):
    name = 'instructions'
    label = _('Instructions')
    prop = 'instructions'

class NotesEditorModule (TextFieldEditor,RecEditorModule):
    name = 'notes'
    prop = 'modifications'
    label = _('Notes')

# Various sub-classes to handle our ingredient treeview

class IngredientController (plugin_loader.Pluggable):

    """Handle updates to our ingredient model.

    Changes are not reported as they happen; rather, we use the
    commit_ingredients method to do sync up our database with what
    we're showing as our database.
    """

    ING_COL = 0
    AMT_COL = 1
    UNIT_COL = 2
    ITEM_COL = 3
    OPTIONAL_COL = 4

    def __init__ (self, ingredient_editor_module):
        self.ingredient_editor_module = ingredient_editor_module;
        self.rg = self.ingredient_editor_module.rg
        self.re = self.ingredient_editor_module.re
        self.new_item_count = 0
        self.commited_items_converter = {}
        plugin_loader.Pluggable.__init__(self,
                                         [IngredientControllerPlugin])

    # Setup methods
    def create_imodel (self, rec):
        self.ingredient_objects = []        
        self.current_rec=rec
        ings=self.rg.rd.get_ings(rec)
        ## now we continue with our regular business...
        debug("%s ings"%len(ings),3)
        self.ing_alist=self.rg.rd.order_ings(ings)
        self.imodel = gtk.TreeStore(gobject.TYPE_PYOBJECT,
                              gobject.TYPE_STRING,
                              gobject.TYPE_STRING,
                              gobject.TYPE_STRING,
                              gobject.TYPE_BOOLEAN,
                                    #gobject.TYPE_STRING,
                                    #gobject.TYPE_STRING
                                    )
        for g,ings in self.ing_alist:
            if g:
                g=self.add_group(g)
            for i in ings:
                debug('adding ingredient %s'%i.item,0)
                self.add_ingredient(i, group_iter=g)
        return self.imodel

    def _new_iter_ (self,
                    group_iter=None,
                    prev_iter=None,
                    fallback_on_append=True):
        iter = None
        if group_iter and not prev_iter:
            if type(self.imodel.get_value(group_iter, 0)) not in types.StringTypes:
                prev_iter = group_iter
                print 'fix this old code!'
                import traceback; traceback.print_stack()
                print '(not a real traceback, just a hint for fixing the old code)'
            else:
                iter = self.imodel.append(group_iter)
        if prev_iter:
            iter = self.imodel.insert_after(None, prev_iter, None)
        if not iter:
            if fallback_on_append: iter = self.imodel.append(None)
            else: iter = self.imodel.prepend(None)
        return iter
    
    # Add recipe info...
    def add_ingredient_from_kwargs (self, group_iter=None, prev_iter=None,
                                    fallback_on_append=True, undoable=False,
                                    placeholder=None, # An ingredient
                                                      # object count
                                                      # (number)
                                    **ingdict):
        iter = self._new_iter_(group_iter=group_iter,prev_iter=prev_iter,
                               fallback_on_append=fallback_on_append)
        if ingdict.has_key('refid') and ingdict['refid']:
            self.imodel.set_value(iter,0,
                                  RecRef(ingdict['refid'],ingdict.get('item',''))
                                  )
        elif placeholder is not None:
            self.imodel.set_value(iter,0,placeholder)
        else:
            self.imodel.set_value(iter,0,self.new_item_count)
            self.new_item_count+=1
        self.update_ingredient_row(
            iter,**ingdict
            )
        return iter

    def add_new_ingredient (self,                            
                            *args,
                            **kwargs
                            ):
        ret = self.add_ingredient_from_kwargs(*args,**kwargs)
        return ret

    def undoable_update_ingredient_row (self, ref, d):
        itr = self.ingredient_editor_module.ingtree_ui.ingController.get_iter_from_persistent_ref(ref)
        orig = self.ingredient_editor_module.ingtree_ui.ingController.get_rowdict(itr)
        Undo.UndoableObject(
            lambda *args: self.update_ingredient_row(itr,**d),
            lambda *args: self.update_ingredient_row(itr,**orig),
            self.ingredient_editor_module.history,
            widget=self.imodel,
            ).perform()

    def update_ingredient_row (self,iter,
                               amount=None,
                               unit=None,
                               item=None,
                               optional=None,
                               ingkey=None,
                               shop_cat=None,
                               refid=None,
                               undoable=False
                               ):
        if amount is not None: self.imodel.set_value(iter,1,amount)
        if unit is not None: self.imodel.set_value(iter,2,unit)
        if item is not None: self.imodel.set_value(iter,3,item)
        if optional is not None: self.imodel.set_value(iter,4,optional)
        #if ingkey is not None: self.imodel.set_value(iter,5,ingkey)
        #if shop_cat:
        #    self.imodel.set_value(iter,6,shop_cat)
        #elif ingkey and self.re.rg.sl.orgdic.has_key(ingkey):
        #    self.imodel.set_value(iter,6,self.re.rg.sl.orgdic[ingkey])
                
    def add_ingredient (self, ing, prev_iter=None, group_iter=None,
                        fallback_on_append=True, shop_cat=None,
                        is_undo=False):
        """add an ingredient to our model based on an ingredient
        object.

        group_iter is an iter to put our ingredient inside of.

        prev_iter is an ingredient after which we insert our ingredient

        fallback_on_append tells us whether to append or (if False)
        prepend when we have no group_iter.

        is_undo asks if this is part of an UNDO action. If it is, we
        don't add the object to our list of ingredient_objects (which
        is designed to reflect the current state of the database).
        """
        i = ing
        # Append our ingredient object to a list so that we will be able to notice if it has been deleted...
        if not is_undo: self.ingredient_objects.append(ing)
        iter = self._new_iter_(prev_iter=prev_iter,group_iter=group_iter,fallback_on_append=fallback_on_append)
        amt = self.rg.rd.get_amount_as_string(i)
        unit = i.unit
        self.imodel.set_value(iter, 0, i)
        self.imodel.set_value(iter, 1, amt)
        self.imodel.set_value(iter, 2, unit)
        self.imodel.set_value(iter, 3, i.item)
        if i.optional:
            opt=True
        else:
            opt=False
        self.imodel.set_value(iter, 4, opt)
        #self.imodel.set_value(iter, 5, i.ingkey)
        #if shop_cat:
        #    self.imodel.set_value(iter, 6, shop_cat)
        #elif self.rg.sl.orgdic.has_key(i.ingkey):
        #    debug("Key %s has category %s"%(i.ingkey,self.rg.sl.orgdic[i.ingkey]),5)
        #    self.imodel.set_value(iter, 6, self.rg.sl.orgdic[i.ingkey])
        #else:
        #    self.imodel.set_value(iter, 6, None)
        return iter

    def add_group (self, name, prev_iter=None, children_iters=[], fallback_on_append=True):
        if not prev_iter:
            if fallback_on_append: groupiter = self.imodel.append(None)
            else: groupiter = self.imodel.prepend(None)
        else:
            # ALLOW NO NESTING!
            while self.imodel.iter_parent(prev_iter):
                prev_iter = self.imodel.iter_parent(prev_iter)
            groupiter = self.imodel.insert_after(None,prev_iter,None)
        self.imodel.set_value(groupiter, 0, "GROUP %s"%name)
        self.imodel.set_value(groupiter, 1, name)
        children_iters.reverse()
        for c in children_iters:
            te.move_iter(self.imodel,c,None,parent=groupiter,direction='after')
            #self.rg.rd.undoable_modify_ing(self.imodel.get_value(c,0),
            #                               {'inggroup':name},
            #                               self.history)
        debug('add_group returning %s'%groupiter,5)
        return groupiter

    #def change_group (self, name,
    def delete_iters (self, *iters, **kwargs):
        """kwargs can have is_undo"""
        is_undo = kwargs.get('is_undo',False)
        refs = []
        undo_info = []
        try:
            paths = [self.imodel.get_path(i) for i in iters]
        except TypeError:
            print 'Odd we are failing to get_paths for ',iters
            print 'Our undo stack looks like this...'
            print self.ingredient_editor_module.history
            raise
        for itr in iters:
            orig_ref = self.get_persistent_ref_from_iter(itr)
            # We don't want to add children twice, once as a
            # consequent of their parents and once because they've
            # been selected in their own right.
            parent = self.imodel.iter_parent(itr)
            parent_path =  parent and self.imodel.get_path(parent)
            if parent_path in paths:
                # If our parent is in the iters to be deleted -- we
                # don't need to delete it individual
                continue
            refs.append(orig_ref)
            deleted_dic,prev_ref,ing_obj = self._get_undo_info_for_iter_(itr)
            child = self.imodel.iter_children(itr)
            children = []
            if child:
                expanded = self.ingredient_editor_module.ingtree_ui.ingTree.row_expanded(
                    self.imodel.get_path(itr)
                    )
            else:
                expanded = False
            while child:
                children.append(self._get_undo_info_for_iter_(child))
                child = self.imodel.iter_next(child)
            undo_info.append((deleted_dic,prev_ref,ing_obj,children,expanded))
    
        u = Undo.UndoableObject(
            lambda *args: self.do_delete_iters(refs),
            lambda *args: self.do_undelete_iters(undo_info),
            self.ingredient_editor_module.history,
            widget=self.imodel,
            is_undo=is_undo
            )
        debug('IngredientController.delete_iters Performing deletion of %s'%refs,2)
        u.perform()

    def _get_prev_path_ (self, path):
        if path[-1]==0:
            if len(path)==1:
                prev_path = None
            else:
                prev_path = tuple(path[:-1])
        else:
            prev_path = te.path_next(path,-1)
        return prev_path

    def _get_undo_info_for_iter_ (self, iter):
        deleted_dic = self.get_rowdict(iter)
        path = self.imodel.get_path(iter)
        prev_path = self._get_prev_path_(path)
        if prev_path:
            prev_ref = self.get_persistent_ref_from_path(prev_path)
        else:
            prev_ref = None
        ing_obj = self.imodel.get_value(iter,0)
        return deleted_dic,prev_ref,ing_obj

    def do_delete_iters (self, iters):
        for ref in iters:
            i = self.get_iter_from_persistent_ref(ref)
            if not i: print 'Failed to get reference from',i
            else: self.imodel.remove(i)

    def do_undelete_iters (self, rowdicts_and_iters):
        for rowdic,prev_iter,ing_obj,children,expanded in rowdicts_and_iters:
            prev_iter = self.get_iter_from_persistent_ref(prev_iter)
            # If ing_obj is a string, then we are a group
            if ing_obj and type(ing_obj) in types.StringTypes:
                itr = self.add_group(rowdic['amount'],prev_iter,fallback_on_append=False)
            elif type(ing_obj) == int or not ing_obj:        
                itr = self.add_ingredient_from_kwargs(prev_iter=prev_iter,
                                                      fallback_on_append=False,
                                                      placeholder=ing_obj,
                                                      **rowdic)
            #elif ing_obj not in self.ingredient_objects:
            #    # If we have an ingredient object, but it's not one we
            #    # recall, then we must be recalling the object from
            #    # before a deletion -- we'll 
            else:
                # Otherwise, we must have an ingredient object
                itr = iter = self.add_ingredient(ing_obj,prev_iter,
                                                 fallback_on_append=False,
                                                 is_undo=True)
                self.update_ingredient_row(iter,**rowdic)
            if children:
                first = True
                for rd,pi,io in children:
                    pi = self.get_iter_from_persistent_ref(pi)
                    if first:
                        gi = itr
                        pi = None
                        first = False
                    else:
                        gi = None    
                    if io and type(io) not in [str,unicode,int] and not isinstance(io,RecRef):
                        itr = self.add_ingredient(io,
                                                  group_iter=gi,
                                                  prev_iter=pi,
                                                  fallback_on_append=False,
                                                  is_undo = True)
                        self.update_ingredient_row(itr,**rd)
                    else:
                        itr = self.add_ingredient_from_kwargs(group_iter=gi,
                                                              prev_iter=pi,
                                                              fallback_on_append=False,
                                                              **rd)
                        self.imodel.set_value(itr,0,io)
            if expanded:
                self.ingredient_editor_module.ingtree_ui.ingTree.expand_row(self.imodel.get_path(itr),True)

    # Get a dictionary describing our current row
    def get_rowdict (self, iter):
        d = {}
        for k,n in [('amount',1),
                    ('unit',2),
                    ('item',3),
                    ('optional',4),
                    ]:
            d[k] = self.imodel.get_value(iter,n)
        ing_obj = self.imodel.get_value(iter,0)
        self.get_extra_ingredient_attributes(
            ing_obj,
            d)
        return d

    @plugin_loader.pluggable_method
    def get_extra_ingredient_attributes (self, ing_obj, ingdict):
        if not hasattr(ing_obj,'ingkey') or not ing_obj.ingkey:
            if ingdict['item']:
                ingdict['ingkey'] = ingdict['item'].split(';')[0]
        else:
            ingdict['ingkey'] = ing_obj.ingkey

    # Get persistent references to items easily

    def get_persistent_ref_from_path (self, path):
        return self.get_persistent_ref_from_iter(
            self.imodel.get_iter(path)
            )

    def get_persistent_ref_from_iter (self, iter):
        uid = self.imodel.get_value(iter,0)
        return uid

    def get_path_from_persistent_ref (self, ref):
        itr = self.get_iter_from_persistent_ref(ref)
        if itr:
            return self.imodel.get_path(
                itr
                )
    
    #@debug_decorator
    def get_iter_from_persistent_ref (self, ref):
        try:
            if self.commited_items_converter.has_key(ref):
                ref = self.commited_items_converter[ref]
        except TypeError:
            # If ref is unhashable, we don't care
            pass
        itr = self.imodel.get_iter_first()
        while itr:
            v = self.imodel.get_value(itr,0)
            if v == ref or self.rg.rd.row_equal(v,ref):
                return itr
            child = self.imodel.iter_children(itr)
            if child:
                itr = child
            else:
                next = self.imodel.iter_next(itr)
                if next:
                    itr = next
                else:
                    parent = self.imodel.iter_parent(itr)
                    if parent:
                        itr = self.imodel.iter_next(parent)
                    else:
                        itr = None

    def commit_ingredients (self):
        """Commit ingredients as they appear in tree to database."""
        iter = self.imodel.get_iter_first()
        n = 0
        # Start with a list of all ingredient object - we'll eliminate
        # each object as we come to it in our tree -- any items not
        # eliminated have been deleted.
        deleted = self.ingredient_objects[:]
        
        # We use an embedded function rather than a simple loop so we
        # can recursively crawl our tree -- so think of commit_iter as
        # the inside of the loop, only better

        def commit_iter (iter, pos, group=None):
            ing = self.imodel.get_value(iter,0)
            # If ingredient is a string, than this is a group
            if type(ing) in [str,unicode]:
                group = self.imodel.get_value(iter,1)
                i = self.imodel.iter_children(iter)
                while i:
                    pos = commit_iter(i,pos,group)
                    i = self.imodel.iter_next(i)
                return pos
            # Otherwise, this is an ingredient...
            else:
                d = self.get_rowdict(iter)
                # Get the amount as amount and rangeamount
                if d['amount']:
                    amt,rangeamount = parse_range(d['amount'])
                    d['amount']=amt
                    if rangeamount: d['rangeamount']=rangeamount
                else:
                    d['amount']=None
                # Get category info as necessary
                if d.has_key('shop_cat'):
                    self.rg.sl.orgdic[d['ingkey']] = d['shop_cat']
                    del d['shop_cat']
                d['position']=pos
                d['inggroup']=group
                # If we are a recref...
                if isinstance(ing,RecRef):
                    d['refid'] = ing.refid
                # If we are a real, old ingredient
                if type(ing) != int and not isinstance(ing,RecRef):
                    for att in ['amount','unit','item','ingkey','position','inggroup','optional']:
                        # Remove all unchanged attrs from dict...
                        if hasattr(d,att):
                            if getattr(ing,att)==d[att]:
                                del d[att]
                    if ing in deleted:
                        # We have not been deleted...
                        deleted.remove(ing)
                    else:
                        # In this case, we have an ingredient object
                        # that is not reflected in our
                        # ingredient_object list. This means the user
                        # Deleted us, saved, and then clicked undo,
                        # resulting in the trace object. In this case,
                        # we need to set ing.deleted to False
                        d['deleted'] = False
                    if ing.deleted: # If somehow our object is
                                    # deleted... (shouldn't be
                                    # possible, but why not check!)
                        d['deleted']=False
                    if d:
                        self.ingredient_editor_module.rg.rd.modify_ing_and_update_keydic(ing,d)
                else:
                    d['recipe_id'] = self.ingredient_editor_module.current_rec.id
                    self.commited_items_converter[ing] = self.rg.rd.add_ing_and_update_keydic(d)
                    self.imodel.set_value(iter,0,self.commited_items_converter[ing])
                    # Add ourself to the list of ingredient objects so
                    # we will notice subsequent deletions.
                    self.ingredient_objects.append(self.commited_items_converter[ing])
                return pos+1
        # end commit iter

        while iter:
            n = commit_iter(iter,n)
            iter = self.imodel.iter_next(iter)
        # Now delete all deleted ings...  (We're not *really* deleting
        # them -- we're just setting a handy flag to delete=True. This
        # makes Undo faster. It also would allow us to allow users to
        # go back through their "ingredient Trash" if we wanted to put
        # in a user interface for them to do so.
        for i in deleted: self.ingredient_objects.remove(i)
        self.rg.rd.modify_ings(deleted,{'deleted':True})

class IngredientTreeUI:

    """Handle our ingredient treeview display, drag-n-drop, etc.
    """

    head_to_att = {_('Amt'):'amount',
                   _('Unit'):'unit',
                   _('Item'):'item',
                   _('Key'):'ingkey',
                   _('Optional'):'optional',
                   #_('Shopping Category'):'shop_cat',
                   }

    def __init__ (self, ie, tree):
        self.ingredient_editor_module =ie; self.rg = self.ingredient_editor_module.rg
        self.ingController = IngredientController(self.ingredient_editor_module)
        self.ingTree = tree
        self.ingTree.get_selection().set_mode(gtk.SELECTION_MULTIPLE)                
        self.setup_columns()
        self.ingTree.connect("row-activated",self.ingtree_row_activated_cb)
        self.ingTree.connect("key-press-event",self.ingtree_keypress_cb)
        self.selected=True
        #self.selection_changed()
        self.ingTree.get_selection().connect("changed",self.selection_changed_cb)
        self.setup_drag_and_drop()
        self.ingTree.show()
        
    # Basic setup methods

    def setup_columns (self):
        self.ingColsByName = {}
        self.ingColsByAttr = {}
        for n,head,tog,model,style,expand in [[1,_('Amt'),False,None,None,False],
                                 [2,_('Unit'),False,self.rg.umodel,None,False],
                                 [3,_('Item'),False,None,None,True],
                                 [4,_('Optional'),True,None,None,False],
                                 #[5,_('Key'),False,self.rg.inginfo.key_model,pango.STYLE_ITALIC],
                                 #[6,_('Shopping Category'),False,self.shopmodel,pango.STYLE_ITALIC],
                                 ]:        
            # Toggle setup
            if tog:
                renderer = gtk.CellRendererToggle()
                renderer.set_property('activatable',True)
                renderer.connect('toggled',self.ingtree_toggled_cb,n,'Optional')
                col=gtk.TreeViewColumn(head, renderer, active=n)
            # Non-Toggle setup
            else:
                if model:
                    debug('Using CellRendererCombo, n=%s'%n,0)
                    renderer = gtk.CellRendererCombo()
                    renderer.set_property('model',model)
                    renderer.set_property('text-column',0)
                else:
                    debug('Using CellRendererText, n=%s'%n,0)
                    renderer = gtk.CellRendererText()
                renderer.set_property('editable',True)
                renderer.connect('edited',self.ingtree_edited_cb,n,head)
                # If we have gtk > 2.8, set up text-wrapping
                try:
                    renderer.get_property('wrap-width')
                except TypeError:
                    pass
                else:
                    renderer.set_property('wrap-mode',pango.WRAP_WORD)
                    renderer.set_property('wrap-width',150)
                if head==_('Key'):
                    try:
                        renderer.connect('editing-started',
                                         self.ingtree_start_keyedit_cb)
                    except:
                        debug('Editing-started connect failed. Upgrade GTK for this functionality.',0)
                if style:
                    renderer.set_property('style',style)
                # Create Column
                col=gtk.TreeViewColumn(head, renderer, text=n)
            if expand: col.set_expand(expand)
            # Register ourselves...
            self.ingColsByName[head]=col
            if self.head_to_att.has_key(head):
                self.ingColsByAttr[self.head_to_att[head]]=n
            # All columns are reorderable and resizeable
            col.set_reorderable(True)
            col.set_resizable(True)
            col.set_alignment(0)
            col.set_min_width(45) 
            #if n==2:     #unit
            #    col.set_min_width(80) 
            if n==3:     #item
                col.set_min_width(130) 
            if n==5:     #key
                col.set_min_width(130)
            self.ingTree.append_column(col)

    def setup_drag_and_drop (self):
        ## add drag and drop support
        targets=[('GOURMET_INTERNAL', gtk.TARGET_SAME_WIDGET, 0),
                 ('text/plain',0,1),
                 ('STRING',0,2),
                 ('STRING',0,3),
                 ('COMPOUND_TEXT',0,4),
                 ('text/unicode',0,5),]
        self.ingTree.enable_model_drag_source(gtk.gdk.BUTTON1_MASK,
                                              targets,
                                              gtk.gdk.ACTION_DEFAULT |
                                              gtk.gdk.ACTION_COPY |
                                              gtk.gdk.ACTION_MOVE)
        self.ingTree.enable_model_drag_dest(targets,
                                            gtk.gdk.ACTION_DEFAULT | gtk.gdk.ACTION_COPY | gtk.gdk.ACTION_MOVE)
        self.ingTree.connect("drag_data_received",self.dragIngsRecCB)
        self.ingTree.connect("drag_data_get",self.dragIngsGetCB)
        self.ingTree.connect('drag-begin',
                             lambda *args: setattr(self,'ss',te.selectionSaver(self.ingTree,0))
                             )
        self.ingTree.connect('drag-end',
                             lambda *args: self.ss.restore_selections()
                             )
    # End of setup methods

    # Callbacks and the like

    def my_isearch (self, mod, col, key, iter, data=None):
        # we ignore column info and search by item
        val = mod.get_value(iter,3)
        # and by key
        if val:
            val += mod.get_value(iter,5)
            if val.lower().find(key.lower()) != -1:
                return False
            else:
                return True
        else:
            val = mod.get_value(iter,1)
            if val and val.lower().find(key.lower())!=-1:
                return False
            else:
                return True
        
    def ingtree_row_activated_cb (self, tv, path, col, p=None):
        debug("ingtree_row_activated_cb (self, tv, path, col, p=None):",5)
        itr=self.get_selected_ing()
        i = self.ingController.imodel.get_value(itr,0)
        if isinstance(i,RecRef) or (hasattr(i,'refid') and i.refid):
            rec=self.rg.rd.get_referenced_rec(i)
            if rec:
                self.rg.open_rec_card(rec)
            else:
                de.show_message(parent=self.edit_window,
                                label=_("The recipe %s (ID %s) is not in our database.")%(i.item,
                                                                                          i.refid)
                                )
        else:
            d = self.ingController.get_rowdict(itr)
            #self.re.ie.show(i,d)
            #self.re.ie.ieExpander.set_expanded(True)

    def ingtree_keypress_cb (self, widget, event):
        keyname = gtk.gdk.keyval_name(event.keyval)
        if keyname == 'Delete' or keyname == 'BackSpace':
            self.ingredient_editor_module.delete_cb()
            return True
                             

    def selection_changed_cb (self, *args):
        model,rows=self.ingTree.get_selection().get_selected_rows()
        self.selection_changed(rows and True)
        #if self.re.ie.ieExpander.get_expanded():
        #    itr = self.get_selected_ing()
        #    if itr:
        #        i = self.ingController.imodel.get_value(itr,0)
        #        d = self.ingController.get_rowdict(itr)
        #        if i: self.re.ie.show(i,d)
        #        else: self.re.ie.new()
        return True
    
    def selection_changed (self, selected=False):
        if selected != self.selected:
            if selected: self.selected=True
            else: self.selected=False
            if hasattr(self.ingredient_editor_module,'ingredientEditorOnRowActionGroup'):
                self.ingredient_editor_module.ingredientEditorOnRowActionGroup.set_sensitive(self.selected)

    def ingtree_toggled_cb (self, cellrenderer, path, colnum, head):
        debug("ingtree_toggled_cb (self, cellrenderer, path, colnum, head):",5)
        store=self.ingTree.get_model()
        iter=store.get_iter(path)
        val = store.get_value(iter,colnum)
        obj = store.get_value(iter,0)
        if type(obj) in types.StringTypes and obj.find('GROUP')==0:
            print 'Sorry, whole groups cannot be toggled to "optional"'
            return
        newval = not val
        ref = self.ingController.get_persistent_ref_from_iter(iter)
        u = Undo.UndoableObject(
            lambda *args: store.set_value(self.ingController.get_iter_from_persistent_ref(ref),
                                          colnum,newval),
            lambda *args: store.set_value(self.ingController.get_iter_from_persistent_ref(ref),
                                          colnum,val),
            self.ingredient_editor_module.history,
            widget=self.ingController.imodel
            )
        u.perform()
        
    def ingtree_start_keyedit_cb (self, renderer, cbe, path_string):
        debug('ingtree_start_keyedit_cb',0)
        indices = path_string.split(':')
        path = tuple( map(int, indices))
        store = self.ingTree.get_model()
        iter = store.get_iter(path)
        itm=store.get_value(iter,self.ingColsByAttr['item'])
        mod = renderer.get_property('model')
        myfilter=mod.filter_new()
        cbe.set_model(myfilter)
        myKeys = self.rg.rd.key_search(itm)
        vis = lambda m, iter: m.get_value(iter,0) and (m.get_value(iter,0) in myKeys or m.get_value(iter,0).find(itm) > -1)
        myfilter.set_visible_func(vis)
        myfilter.refilter()

    def ingtree_edited_cb (self, renderer, path_string, text, colnum, head):
        indices = path_string.split(':')
        path = tuple( map(int, indices))
        store = self.ingTree.get_model()
        iter = store.get_iter(path)
        ing=store.get_value(iter,0)
        d = {}
        if type(ing) in [str,unicode]:
            debug('Changing group to %s'%text,2)
            self.change_group(iter, text)
            return
        else:       
            attr=self.head_to_att[head]
            d[attr]=text
            if attr=='amount':
                try:
                    parse_range(text)
                except:
                    show_amount_error(text)
                    raise
            elif attr=='unit':
                amt,msg=self.changeUnit(text,self.ingController.get_rowdict(iter))
                if amt:
                    d['amount']=amt
                #if msg:
                #    self.re.message(msg)
            elif attr=='item':
                d['ingkey']=self.rg.rd.km.get_key(text)
            ref = self.ingController.get_persistent_ref_from_iter(iter)
            self.ingController.undoable_update_ingredient_row(ref,d)

    # Drag-n-Drop Callbacks
    
    def dragIngsRecCB (self, widget, context, x, y, selection, targetType,
                         time):
        debug("dragIngsRecCB (self=%s, widget=%s, context=%s, x=%s, y=%s, selection=%s, targetType=%s, time=%s)"%(self, widget, context, x, y, selection, targetType, time),3)
        drop_info=self.ingTree.get_dest_row_at_pos(x,y)
        mod=self.ingTree.get_model()
        if drop_info:
            path, position = drop_info
            dref = self.ingController.get_persistent_ref_from_path(path)
            dest_ing=mod.get_value(mod.get_iter(path),0)
            if type(dest_ing) in [str,unicode]: group=True
            else: group=False
        else:
            dref = None
            group = False
            position = None
        if str(selection.target) == 'GOURMET_INTERNAL':
            # if this is ours, we move it
            uts = UndoableTreeStuff(self.ingController)
            selected_iter_refs = [
                self.ingController.get_persistent_ref_from_iter(i) for i in self.selected_iter
                ]
            def do_move ():
                debug('do_move - inside dragIngsRecCB ',3)
                debug('do_move - get selected_iters from - %s '%selected_iter_refs,3)
                if dref:
                    diter = self.ingController.get_iter_from_persistent_ref(dref)
                else:
                    diter = None
                selected_iters = [
                    self.ingController.get_iter_from_persistent_ref(r) for r in selected_iter_refs
                    ]
                uts.record_positions(selected_iters)                
                debug('do_move - we have selected_iters - %s '%selected_iters,3)
                selected_iters.reverse()
                if (group and
                    (position==gtk.TREE_VIEW_DROP_INTO_OR_BEFORE
                     or
                     position==gtk.TREE_VIEW_DROP_INTO_OR_AFTER)
                    ):
                    for i in selected_iters:
                        te.move_iter(mod,i,direction="before",parent=diter)
                elif (position==gtk.TREE_VIEW_DROP_INTO_OR_BEFORE
                      or
                      position==gtk.TREE_VIEW_DROP_BEFORE):
                    for i in selected_iters:
                        te.move_iter(mod,i,sibling=diter,direction="before")
                else:
                    for i in selected_iters:
                        te.move_iter(mod,i,sibling=diter,direction="after")
                debug('do_move - inside dragIngsRecCB - move selections',3)
                self.ingTree.get_selection().unselect_all()
                for r in selected_iter_refs:
                    i = self.ingController.get_iter_from_persistent_ref(r)
                    if not i:
                        print 'Odd - I get no iter for ref',r
                        import traceback; traceback.print_stack()
                        print 'Strange indeed! carry on...'                        
                    else:
                        self.ingTree.get_selection().select_iter(i)
                debug('do_move - inside dragIngsRecCB - DONE',3)
            Undo.UndoableObject(
                do_move,
                uts.restore_positions,
                self.ingredient_editor_module.history,
                widget=self.ingController.imodel).perform()
               #self.ingTree.get_selection().select_iter(new_iter)
        else:
            # if this is external, we copy
            debug('external drag!',2)
            lines = selection.data.split("\n")
            lines.reverse()
            if (position==gtk.TREE_VIEW_DROP_BEFORE or
                position==gtk.TREE_VIEW_DROP_INTO_OR_BEFORE and not group):
                pre_path = te.path_next(self.ingController.get_path_from_persistent_ref(dref),-1)
                if pre_path:
                    itr_ref = self.ingController.get_persistent_ref_from_path(pre_path)
                else:
                    itr_ref = None
            else:
                itr_ref = dref
            def do_add ():
                for l in lines:
                    if group: 
                        self.ingredient_editor_module.add_ingredient_from_line(
                            l,
                            group_iter=self.ingController.get_iter_from_persistent_ref(itr_ref)
                            )
                    else:
                        self.ingredient_editor_module.add_ingredient_from_line(
                            l,
                            prev_iter=self.ingController.get_iter_from_persistent_ref(itr_ref)
                            )
            add_with_undo(self.ingredient_editor_module,do_add)
        #self.commit_positions()
        debug("restoring selections.")
        debug("done restoring selections.")        

    def dragIngsGetCB (self, tv, context, selection, info, timestamp):
        def grab_selection (model, path, iter, args):
            strings, iters = args            
            str = ""
            amt = model.get_value(iter,1)
            if amt:
                str="%s "%amt
            unit = model.get_value(iter,2)
            if unit:
                str="%s%s "%(str,unit)
            item = model.get_value(iter,3)
            if item:
                str="%s%s"%(str,item)
            debug("Dragged string: %s, iter: %s"%(str,iter),3)
            iters.append(iter)
            strings.append(str)
        strings=[]
        iters=[]
        tv.get_selection().selected_foreach(grab_selection,(strings,iters))
        str=string.join(strings,"\n")
        selection.set('text/plain',0,str)
        selection.set('STRING',0,str)
        selection.set('GOURMET_INTERNAL',8,'blarg')
        self.selected_iter=iters

    # Move-item callbacks

    def get_selected_refs (self):
        ts,paths = self.ingTree.get_selection().get_selected_rows()
        return [self.ingController.get_persistent_ref_from_path(p) for p in paths]
    
    def ingUpCB (self, *args):
        refs = self.get_selected_refs()
        u=Undo.UndoableObject(lambda *args: self.ingUpMover(
            [self.ingController.get_path_from_persistent_ref(r) for r in refs]
            ),
                              lambda *args: self.ingDownMover(
            [self.ingController.get_path_from_persistent_ref(r) for r in refs]
            ),
                              self.ingredient_editor_module.history,
                              widget=self.ingController.imodel,
                              )
        u.perform()

    def ingDownCB (self, *args):
        refs = self.get_selected_refs()
        u=Undo.UndoableObject(lambda *args: self.ingDownMover(
            [self.ingController.get_path_from_persistent_ref(r) for r in refs]
            ),
                              lambda *args: self.ingUpMover(
            [self.ingController.get_path_from_persistent_ref(r) for r in refs]
            ),
                              self.ingredient_editor_module.history)
        u.perform()

    def ingUpMover (self, paths):
        ts = self.ingController.imodel
        def moveup (ts, path, itera):
            if itera:
                prev=te.path_next(path,-1)
                prev_iter=ts.get_iter(prev)
                te.move_iter(ts,itera,sibling=prev_iter,direction="before")
                #self.ingTree.get_selection().unselect_path(path)
                #self.ingTree.get_selection().select_path(prev)
        paths.reverse()
        tt = te.selectionSaver(self.ingTree)        
        for p in paths:
            itera = ts.get_iter(p)
            moveup(ts,p,itera)
        tt.restore_selections()
        
    def ingDownMover (self, paths):
        ts = self.ingController.imodel
        def movedown (ts, path, itera):
            if itera:
                next = ts.iter_next(itera)
                te.move_iter(ts,itera,sibling=next,direction="after")
                #if next:
                #    next_path=ts.get_path(next)
                #else:
                #    next_path=path
        paths.reverse()
        tt = te.selectionSaver(self.ingTree)
        for p in paths:
            itera = ts.get_iter(p)
            movedown(ts,p,itera)
        tt.restore_selections()

    def get_previous_iter_and_group_iter (self):
        """Return prev_iter,group_iter"""
        # If there is a selected iter, we treat it as a group to put
        # our entry into or after
        selected_iter = self.getSelectedIter()
        if not selected_iter:
            # default behavior (put last)
            group_iter = None
            prev_iter = None
        elif type(self.ingController.imodel.get_value(selected_iter,0)) in types.StringTypes:
            # if we are a group
            group_iter = selected_iter
            prev_iter = None
        else:
            # then we are a previous iter...
            group_iter = None
            prev_iter = selected_iter
        return prev_iter,group_iter

    # Edit Callbacks
    def changeUnit (self, new_unit, ingdict):
        """Handed a new unit and an ingredient, we decide whether to convert and return:
        None (don't convert) or Amount (new amount)
        Message (message for our user) or None (no message for our user)"""
        key=ingdict['ingkey']
        old_unit=ingdict['unit']
        old_amt=ingdict['amount']
        if type(old_amt)==str:
            old_amt = convert.frac_to_float(old_amt)
        density=None
        conversion = self.rg.conv.converter(old_unit,new_unit,key)
        if conversion and conversion != 1:
            new_amt = old_amt*conversion
            opt1 = _("Converted: %(amt)s %(unit)s")%{'amt':convert.float_to_frac(new_amt),
                                                     'unit':new_unit}
            opt2 = _("Not Converted: %(amt)s %(unit)s")%{'amt':convert.float_to_frac(old_amt),
                                                         'unit':new_unit}
            CONVERT = 1
            DONT_CONVERT = 2
            choice = de.getRadio(label=_('Changed unit.'),
                                 sublabel=_('You have changed the unit for %(item)s from %(old)s to %(new)s. Would you like the amount converted or not?')%{
                'item':ingdict['item'],
                'old':old_unit,
                'new':new_unit},
                                 options=[(opt1,CONVERT),
                                          (opt2,DONT_CONVERT),]
                                 )
            if not choice:
                raise Exception("User cancelled")
            if choice==CONVERT:
                return (new_amt,
                        _("Converted %(old_amt)s %(old_unit)s to %(new_amt)s %(new_unit)s"%{
                    'old_amt':old_amt,
                    'old_unit':old_unit,
                    'new_amt':new_amt,
                    'new_unit':new_unit,})
                        )
            else:
                return (None,
                        None)
        if conversion:
            return (None,None)
        return (None,
                _("Unable to convert from %(old_unit)s to %(new_unit)s"%{'old_unit':old_unit,
                                                                         'new_unit':new_unit}
                  ))


    # End Callbacks

    # Convenience methods / Access to the Tree

    # Accessing the selection

    def getSelectedIters (self):
        if len(self.ingController.imodel)==0:
            return None
        ts,paths = self.ingTree.get_selection().get_selected_rows()
        return [ts.get_iter(p) for p in paths]

    def getSelectedIter (self):
        debug("getSelectedIter",4)
        if len(self.ingController.imodel)==0:
            return None
        try:
            ts,paths=self.ingTree.get_selection().get_selected_rows()
            lpath=paths[-1]
            group=ts.get_iter(lpath)
        except:
            debug("getSelectedIter: there was an exception",0)            
            group=None
        return group

    def get_selected_ing (self):
        """get selected ingredient"""
        debug("get_selected_ing (self):",5)
        path, col = self.ingTree.get_cursor()
        if path:
            itera = self.ingTree.get_model().get_iter(path)
        else:
            tv,rows = self.ingTree.get_selection().get_selected_rows()
            if len(rows) > 0:
                itera = rows[0]
            else:
                itera=None
        return itera
        #if itera:
        #    return self.ingTree.get_model().get_value(itera,0)
        #else: return None

    def set_tree_for_rec (self, rec):
        self.ingTree.set_model(
            self.ingController.create_imodel(rec)
            )
        self.selection_changed()
        self.ingTree.expand_all()

    def ingNewGroupCB (self, *args):
        group_name = de.getEntry(label=_('Adding Ingredient Group'),
                                 sublabel=_('Enter a name for new subgroup of ingredients'),
                                 entryLabel=_('Name of group:'),
                                 )
        selected_iters=self.getSelectedIters() or []
        undo_info = []
        for i in selected_iters:
            deleted_dic,prev_ref,ing_obj = self.ingController._get_undo_info_for_iter_(i)
            undo_info.append((deleted_dic,prev_ref,ing_obj,[],False))
        selected_iter_refs = [self.ingController.get_persistent_ref_from_iter(i)\
                              for i in selected_iters]
        pitr=self.getSelectedIter()
        if pitr:
            prev_iter_ref = self.ingController.get_persistent_ref_from_iter(pitr)
        else:
            prev_iter_ref = None
        def do_add_group ():
            itr = self.ingController.add_group(
                group_name,
                children_iters=[
                self.ingController.get_iter_from_persistent_ref(r) for r in selected_iter_refs
                ],
                prev_iter=(prev_iter_ref and self.ingController.get_iter_from_persistent_ref(prev_iter_ref))
                )
            gi = self.ingController.get_persistent_ref_from_iter(itr)
            self.ingTree.expand_row(self.ingController.imodel.get_path(itr),True)
        def do_unadd_group ():
            gi = 'GROUP '+group_name  #HACK HACK HACK
            self.ingController.imodel.remove(
                self.ingController.get_iter_from_persistent_ref(gi)
                )
            self.ingController.do_undelete_iters(undo_info)
        u = Undo.UndoableObject(do_add_group,
                           do_unadd_group,
                           self.ingredient_editor_module.history)
        u.perform()

    def change_group (self, itr, text):
        debug('Undoable group change: %s %s'%(itr,text),3)
        model = self.ingController.imodel
        oldgroup0 = model.get_value(itr,0)
        oldgroup1 = model.get_value(itr,1)
        def get_group_iter (old_value):
            # Somewhat hacky -- our persistent references are stored in
            # the "0" column, which is simply "GROUP text". This means
            # that we can't properly "persist" groups since this chunk of
            # text changes when the group's name changes. In order to
            # remedy, we're relying on the hackish "GROUP name" value +
            # knowing what the previous group value was to make the
            # "persistent" reference work.
            return self.ingController.get_iter_from_persistent_ref("GROUP %s"%old_value)
        def change_my_group ():
            itr = get_group_iter(oldgroup1)
            self.ingController.imodel.set_value(itr,0,"GROUP %s"%text)
            self.ingController.imodel.set_value(itr,1,text)
        def unchange_my_group ():
            itr = get_group_iter(text)
            self.ingController.imodel.set_value(itr,0,oldgroup0)
            self.ingController.imodel.set_value(itr,1,oldgroup1)
        obj = Undo.UndoableObject(change_my_group,unchange_my_group,self.ingredient_editor_module.history)
        obj.perform()


class UndoableTreeStuff:
    def __init__ (self, ic):
        self.ic = ic

    def start_recording_additions (self):
        debug('UndoableTreeStuff.start_recording_additiong',3)        
        self.added = []
        self.pre_ss = te.selectionSaver(self.ic.ingredient_editor_module.ingtree_ui.ingTree)
        self.connection = self.ic.imodel.connect('row-inserted',
                                                 self.row_inserted_cb)
        debug('UndoableTreeStuff.start_recording_additiong DONE',3)        
        
    def stop_recording_additions (self):
        debug('UndoableTreeStuff.stop_recording_additiong',3)                
        self.added = [
            # i.get_model().get_iter(i.get_path()) is how we get an
            # iter from a TreeRowReference
            self.ic.get_persistent_ref_from_iter(i.get_model().get_iter(i.get_path()))
            for i in self.added
            ]
        self.ic.imodel.disconnect(self.connection)
        debug('UndoableTreeStuff.stop_recording_additions DONE',3)        
        
    def undo_recorded_additions (self):
        debug('UndoableTreeStuff.undo_recorded_additions',3)
        self.ic.delete_iters(
            *[self.ic.get_iter_from_persistent_ref(a) for a in self.added],
            **{'is_undo':True}
            )
        debug('UndoableTreeStuff.undo_recorded_additions DONE',3)                

    def row_inserted_cb (self, tm, path, itr):
        self.added.append(gtk.TreeRowReference(tm,tm.get_path(itr)))

    def record_positions (self, iters):
        debug('UndoableTreeStuff.record_positions',3)
        self.pre_ss = te.selectionSaver(self.ic.ingredient_editor_module.ingtree_ui.ingTree)        
        self.positions = []
        for i in iters:
            path = self.ic.imodel.get_path(i)
            if path[-1]==0:
                parent = path[:-1] or None
                sibling = None
            else:
                parent = None
                sibling = path[:-1] + (path[-1]-1,)
            sib_ref = sibling and self.ic.get_persistent_ref_from_path(sibling)
            parent_ref = parent and self.ic.get_persistent_ref_from_path(parent)
            ref = self.ic.get_persistent_ref_from_iter(i)
            self.positions.append((ref,sib_ref,parent_ref))
        debug('UndoableTreeStuff.record_positions DONE',3)                

    def restore_positions (self):
        debug('UndoableTreeStuff.restore_positions',3)                        
        for ref,sib_ref,parent_ref in self.positions:
            te.move_iter(self.ic.imodel,
                         self.ic.get_iter_from_persistent_ref(ref),
                         sibling=sib_ref and self.ic.get_iter_from_persistent_ref(sib_ref),
                         parent=parent_ref and self.ic.get_iter_from_persistent_ref(parent_ref),
                         direction='after'
                         )
            self.pre_ss.restore_selections()
        debug('UndoableTreeStuff.restore_positions DONE',3)

class UndoableObjectWithInverseThatHandlesItsOwnUndo (Undo.UndoableObject):

    """A class for an UndoableObject whose Undo method already makes
    its own undo magic happen without need for our intervention.
    """
    # This is useful for making Undo's of "add"s -- we use the delete
    # methods for our Undoing nwhich already do a good job handling all
    # the Undo magic properly

    def inverse (self):
        self.history.remove(self)
        self.inverse_action()

def add_with_undo (rc,method):
    uts = UndoableTreeStuff(rc.ingtree_ui.ingController)
    def do_it ():
        uts.start_recording_additions()
        method()
        uts.stop_recording_additions()
    UndoableObjectWithInverseThatHandlesItsOwnUndo(
        do_it,
        uts.undo_recorded_additions,
        rc.history,
        widget=rc.ingtree_ui.ingController.imodel
        ).perform()
                                      
class IngInfo:
    """Keep models for autocompletion, comboboxes, and other
    functions that might want to access a complete list of keys,
    items and the like"""

    def __init__ (self, rd):
        self.rd = rd
        self.make_item_model()
        self.make_key_model('')
        # this is a little bit silly... but, because of recent bugginess...
        # we'll have to do it. disable and enable calls are methods that
        # get called to disable and enable our models while adding to them
        # en masse. disable calls get no arguments passed, enable get args.
        self.disconnect_calls = []
        self.key_connect_calls = []
        self.item_connect_calls = []
        self.manually = False
        self.rd.add_ing_hooks.append(self.add_ing)

    def make_item_model(self):
        #unique_item_vw = self.rd.ingredients_table_not_deleted.counts(self.rd.ingredients_table_not_deleted.item, 'count')
        self.item_model = gtk.ListStore(str)
        for i in self.rd.get_unique_values('item',table=self.rd.ingredients_table,deleted=False):
            self.item_model.append([i])
        if len(self.item_model)==0:
            import defaults.defaults
            for i,k,c in defaults.lang.INGREDIENT_DATA:
                self.item_model.append([i])
        
    def make_key_model (self, myShopCategory):
        # make up the model for the combo box for the ingredient keys
        if myShopCategory:
            unique_key_vw = self.rd.get_unique_values('ingkey',table=self.rd.shopcats_table, shopcategory=myShopCategory)
        else:
            #unique_key_vw = self.rd.get_unique_values('ingkey',table=self.rd.keylookup_table)
            unique_key_vw = self.rd.get_unique_values('ingkey',table=self.rd.ingredients_table)
        # the key model by default stores a string and a list.
        self.key_model = gtk.ListStore(str)
        keys=[]
        for k in unique_key_vw:
            keys.append(k)

        keys.sort()
        for k in keys:
            self.key_model.append([k])

    def change_key (self, old_key, new_key):
        """One of our keys has changed."""
        keys = map(lambda x: x[0], self.key_model)
        index = keys.index(old_key)
        if old_key in keys:
            if new_key in keys:
                del self.key_model[index]
            else:
                self.key_model[index]=[new_key]
        modindx = self.rd.normalizations['ingkey'].find(old_key)
        if modindx>=0:
            self.rd.normalizations['ingkey'][modindx].ingkey=new_key

    def disconnect_models (self):
        for c in self.disconnect_calls:
            if c: c()

    def connect_models (self):
        for c in self.key_connect_calls: c(self.key_model)
        for c in self.item_connect_calls: c(self.item_model)

    def disconnect_manually (self):
        self.manually = True
        self.disconnect_models()

    def reconnect_manually (self):
        self.manually=False
        self.connect_models()

    def add_ing (self, ing):
        # This is really inefficient... we're going to disable temporarily
        pass
        # if not self.manually: self.disconnect_models()
#         if hasattr(ing,'item'):
#             debug('checking for item',3)
#             if not [ing.item] in self.item_model:
#                 debug('adding item',3)                
#                 self.item_model.append([ing.item])
#                 debug('appended %s to item model'%ing.item,3)
#         if hasattr(ing,'ingkey'):
#             debug('checking for key',3)
#             if not [ing.ingkey] in self.key_model:
#                 debug('adding key',3)
#                 self.key_model.append([ing.ingkey])
#                 debug('appended %s to key model'%ing.ingkey,3)
#         debug('add ing completed',3)
#         if not self.manually: self.connect_models()

# Dialog for adding a recipe as an ingredient
class RecSelector (RecIndex):
    """Select a recipe and add it to RecCard's ingredient list"""
    def __init__(self, recGui, ingEditor):
        self.prefs = prefs.get_prefs()
        self.ui=gtk.Builder()
        self.ui.add_from_file(os.path.join(uibase,'recipe_index.ui'))
        self.rg=recGui
        self.ingEditor = ingEditor
        self.re = self.ingEditor.re
        self.setup_main_window()        
        RecIndex.__init__(self,
                          self.ui,
                          self.rg.rd,
                          self.rg,
                          editable=False
                          )
        self.dialog.run()
        

    def setup_main_window (self):
        d = gtk.Dialog(_("Choose recipe"),
                       self.re.window,
                       gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                       (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                        gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))
        self.re.conf.append(
            WidgetSaver.WindowSaver(d,
                                    self.prefs.get('recselector',
                                                   {'window_size':(800,600)})
                                    )
            )
        d.set_default_size(*self.prefs.get('recselector')['window_size'])
        self.recipe_index_interface = self.ui.get_object('recipeIndexBox')
        self.recipe_index_interface.unparent()
        d.vbox.add(self.recipe_index_interface)
        d.connect('response',self.response_cb)
        self.recipe_index_interface.show()
        self.dialog = d
        
    def response_cb (self, dialog, resp):
        if resp==gtk.RESPONSE_ACCEPT:
            self.ok()
        else:
            self.quit()
 
    def quit (self):
        self.dialog.destroy()
 
    def rec_tree_select_rec (self, *args):
        self.ok()

    def ok (self,*args):
        debug('ok',0)
        pre_iter=self.ingEditor.ingtree_ui.get_selected_ing()
        try:
            for rec in self.get_selected_recs_from_rec_tree():
                if rec.id == self.re.current_rec.id:
                    de.show_message(label=_("Recipe cannot call itself as an ingredient!"),
                                    sublabel=_('Infinite recursion is not allowed in recipes!')
                                    )
                    continue
                if rec.yields:
                    amount = getYieldSelection(rec,self.re.window)
                else:
                    amount = 1
                ingdic={'amount':amount,
                        'unit':'recipe',
                        'item':rec.title,
                        'refid':rec.id,
                        }
                debug('adding ing: %s'%ingdic,5)
                iter=self.ingEditor.ingtree_ui.ingController.add_ingredient_from_kwargs(
                    group_iter=pre_iter,
                    **ingdic
                    )
                #path=self.reccard.imodel.get_path(iter)
                #self.reccard.ss.add_selection(iter)
            self.quit()
        except:
            de.show_message(label=_("You haven't selected any recipes!"))
            raise

class YieldSelector (de.ModalDialog):

    def __init__ (self, rec, parent=None):
        self.__in_update_from_yield = False
        self.__in_update_from_rec = False
        de.ModalDialog.__init__(
            self,
            okay=True,
            default=1,parent=parent,
            label=_('How much of %(title)s does your recipe call for?')%{'title':rec.title},
            cancel=False
                  )
        self.rec = rec
        table = gtk.Table()
        self.vbox.add(table);
        self.recButton,self.recAdj = self.make_spinny(val=1,lower=0,
                                                      step_incr=0.5,page_incr=5)
        recLabel = gtk.Label(_('Recipes') + ': ')
        self.recAdj.connect('value_changed',self.update_from_rec)
        self.recAdj.connect('changed',self.update_from_rec)                    
        table.attach(recLabel,0,1,0,1); recLabel.show()
        table.attach(self.recButton,1,2,0,1); self.recButton.show()
        if rec.yields:
            self.yieldsButton,self.yieldsAdj = self.make_spinny(val=self.rec.yields)
            self.yieldsAdj.connect('value_changed',self.update_from_yield)
            self.yieldsAdj.connect('changed',self.update_from_yield)            
            yieldsLabel = gtk.Label(rec.yield_unit.title() + ': ')
            table.attach(yieldsLabel,0,1,1,2); yieldsLabel.show()
            table.attach(self.yieldsButton,1,2,1,2);  self.yieldsButton.show()
        table.show()
    
    def make_spinny (self, val=1, lower=0, upper=10000, step_incr=1, page_incr=10,
                     digits=2):
        '''return adjustment, spinner widget
        '''
        adj = gtk.Adjustment(val,
                             lower=lower,upper=upper,
                             step_incr=step_incr,page_incr=page_incr,
                             )
        sb = gtk.SpinButton(adj)
        sb.set_digits(digits)
        return sb,adj

    def update_from_yield (self, *args):
        if self.__in_update_from_rec: return
        self._in_update_from_yield = True
        yield_val = self.yieldsAdj.get_value()
        factor = yield_val / float(self.rec.yields)
        self.recAdj.set_value(factor)
        self.ret = factor
        self._in_update_from_yield = False

    def update_from_rec (self, *args):
        if self.__in_update_from_yield: return
        self.__in_update_from_rec = True
        factor = self.recAdj.get_value()
        if hasattr(self,'yieldsAdj'):
            self.yieldsAdj.set_value(self.rec.yields * factor)
        self.ret = factor
        self.__in_update_from_rec = False        

def getYieldSelection (rec, parent=None):
    '''Given a recipe, return how much of that recipe we want.

    We offer the user the choice to multiply the recipe or change the
    yield amount. We return the factor to multiply the recipe by.
    
    '''
    yd = YieldSelector(rec,parent)
    try:
        return yd.run()
    except:
        return 1
        
if __name__ == '__main__':
    import GourmetRecipeManager
    rg = GourmetRecipeManager.RecGui()
    import pdb
    rc = RecCard(rg,recipe=rg.rd.fetch_one(rg.rd.recipe_table,title='Asparagus Custard Tart'))
    #import pdb
    #pdb.runcall(rc.show_edit)
    #rc.show()
    #rc.show_display()
    #re = RecEditor(rg,recipe=rg.rd.fetch_one(rg.rd.recipe_table))
    #re.show()
    gtk.main()

if __name__ == '__main__' and False:

    def test_ing_editing (rc):
        rc.show_edit(module=rc.NOTEBOOK_ING_PAGE)        
        g = rc.ingtree_ui.ingController.add_group('Foo bar')
        for l in ('''1 c. sugar
        1 c. silly; chopped and sorted
        1 lb. very silly
        1 tbs. extraordinarily silly'''.split('\n')):
            rc.add_ingredient_from_line(l,group_iter=g)
        rc.ingtree_ui.ingController.delete_iters(g)
        rc.undo.emit('activate')

    import GourmetRecipeManager
    rg = GourmetRecipeManager.RecGui()
    gtk.main()
    rg.app.hide()
    try:
        rc = RecCard(rg,rg.rd.fetch_one(rg.rd.recipe_table,title='Black and White Cookies'))
        rc.display_window.connect('delete-event',
                                  lambda *args: gtk.main_quit()
                                  )
        rc.edit_window.connect('delete-event',lambda *args: gtk.main_quit())
        #rc.show_edit()
        #rc.rw['title'].set_text('Foo')
        
        test_ing_editing(rc)
    except:
        rg.app.hide()
        raise
    else:
        gtk.main()

########NEW FILE########
__FILENAME__ = recindex
#!/usr/bin/env python
from ImageExtras import get_pixbuf_from_jpg
from gdebug import debug
from gettext import gettext as _, ngettext
from gglobals import REC_ATTRS, INT_REC_ATTRS, DEFAULT_HIDDEN_COLUMNS
from gtk_extras import WidgetSaver, ratingWidget, cb_extras as cb, \
    mnemonic_manager, pageable_store, treeview_extras as te
import convert
import Undo
import gobject
import gtk
import gtk.gdk
import pango

class RecIndex:
    """We handle the 'index view' of recipes, which puts
    a recipe model into a tree and allows it to be searched
    and sorted. We're a separate class from the main recipe
    program so that we can be created again (e.g. in the recSelector
    dialog called from a recipe card."""

    default_searches = [{'column':'deleted','operator':'=','search':False}]
    
    def __init__ (self, ui, rd, rg, editable=False):
        #self.visible = 1 # can equal 1 or 2
        self.editable=editable
        self.selected = True        
        self.rtcols=rg.rtcols
        self.rtcolsdic=rg.rtcolsdic
        self.rtwidgdic=rg.rtwidgdic
        self.prefs=rg.prefs
        self.ui = ui
        self.rd = rd
        self.rg = rg
        self.searchByDic = {
            unicode(_('anywhere')):'anywhere',
            unicode(_('title')):'title',
            unicode(_('ingredient')):'ingredient',
            unicode(_('instructions')):'instructions',
            unicode(_('notes')):'modifications',
            unicode(_('category')):'category',
            unicode(_('cuisine')):'cuisine',
            #_('rating'):'rating',
            unicode(_('source')):'source',
            }
        self.searchByList = [_('anywhere'),
                             _('title'),
                             _('ingredient'),
                             _('category'),
                             _('cuisine'),
                             #_('rating'),
                             _('source'),
                             _('instructions'),
                             _('notes'),
                             ]
        # ACK, this breaks internationalization!
        #self.SEARCH_KEY_DICT = {
        #    "t":_("title"),
        #    "i":_("ingredient"),
        #    "c":_("category"),
        #    "u":_("cuisine"),
        #    's':_("source"),
        #    }        
        self.setup_search_actions()
        self.setup_widgets()

    def setup_widgets (self):
        self.srchentry=self.ui.get_object('rlistSearchbox')
        self.limitButton = self.ui.get_object('rlAddButton')
        # Don't # allow for special keybindings
        #self.srchentry.connect('key_press_event',self.srchentry_keypressCB)        
        self.SEARCH_MENU_KEY = "b"
        self.srchLimitBar = self.ui.get_object('srchLimitBar')
        assert(self.srchLimitBar)
        self.srchLimitBar.hide()
        self.srchLimitLabel=self.ui.get_object('srchLimitLabel')
        self.srchLimitClearButton = self.ui.get_object('srchLimitClear')
        self.srchLimitText=self.srchLimitLabel.get_text()
        self.srchLimitDefaultText=self.srchLimitText
        self.searchButton = self.ui.get_object('searchButton')
        self.rSearchByMenu = self.ui.get_object('rlistSearchByMenu')
        cb.set_model_from_list(self.rSearchByMenu, self.searchByList, expand=False)
        cb.setup_typeahead(self.rSearchByMenu)
        self.rSearchByMenu.set_active(0)
        self.rSearchByMenu.connect('changed',self.search_as_you_type)
        self.sautTog = self.ui.get_object('searchAsYouTypeToggle')
        self.search_actions.get_action('toggleSearchAsYouType').connect_proxy(self.sautTog)
        self.regexpTog = self.ui.get_object('regexpTog')
        self.searchOptionsBox = self.ui.get_object('searchOptionsBox')
        self.search_actions.get_action('toggleShowSearchOptions').connect_proxy(
            self.ui.get_object('searchOptionsToggle')
            )
        self.search_actions.get_action('toggleRegexp').connect_proxy(self.regexpTog)
        self.rectree = self.ui.get_object('recTree')
        self.sw = self.ui.get_object('scrolledwindow')
        self.rectree.connect('start-interactive-search',lambda *args: self.srchentry.grab_focus())
        self.prev_button = self.ui.get_object('prevButton')
        self.next_button = self.ui.get_object('nextButton')
        self.first_button = self.ui.get_object('firstButton')
        self.last_button = self.ui.get_object('lastButton')        
        self.showing_label = self.ui.get_object('showingLabel')
        self.stat = self.ui.get_object('statusbar')
        self.contid = self.stat.get_context_id('main')
        self.setup_search_views()
        self.setup_rectree()
        self.prev_button.connect('clicked',lambda *args: self.rmodel.prev_page())
        self.next_button.connect('clicked',lambda *args: self.rmodel.next_page())
        self.first_button.connect('clicked',lambda *args: self.rmodel.goto_first_page())
        self.last_button.connect('clicked',lambda *args: self.rmodel.goto_last_page())
        self.ui.connect_signals({
            'rlistSearch': self.search_as_you_type,
            'ingredientSearch' : lambda *args: self.set_search_by('ingredient'),
            'titleSearch' : lambda *args: self.set_search_by('title'),
            'ratingSearch' : lambda *args: self.set_search_by('rating'),
            'categorySearch' : lambda *args: self.set_search_by('category'),
            'cuisineSearch' : lambda *args: self.set_search_by('cuisine'),
            'search' : self.search,
            'searchBoxActivatedCB':self.search_entry_activate_cb,
            'rlistReset' : self.reset_search,
            'rlistLimit' : self.limit_search,
            'search_as_you_type_toggle' : self.toggleTypeSearchCB,})
        self.toggleTypeSearchCB(self.sautTog)
        # this has to come after the type toggle is connected!
        self.rg.conf.append(WidgetSaver.WidgetSaver(
            self.sautTog,
            self.prefs.get('sautTog',
                           {'active':self.sautTog.get_active()}),
            ['toggled']))
        self.rg.conf.append(WidgetSaver.WidgetSaver(
            self.regexpTog,
            self.prefs.get('regexpTog',
                           {'active':self.regexpTog.get_active()}),
            ['toggled']))        
        # and we update our count with each deletion.
        self.rd.delete_hooks.append(self.set_reccount)
        # setup a history
        self.uim=self.ui.get_object('undo_menu_item')
        self.rim=self.ui.get_object('redo_menu_item')
        self.raim=self.ui.get_object('reapply_menu_item')
        self.history = Undo.UndoHistoryList(self.uim,self.rim,self.raim)
        # Fix up our mnemonics with some heavenly magic
        self.mm = mnemonic_manager.MnemonicManager()
        self.mm.sacred_cows.append("search for") # Don't touch _Search for:
        self.mm.add_builder(self.ui)
        self.mm.add_treeview(self.rectree)
        self.mm.fix_conflicts_peacefully()

    def setup_search_actions (self):
        self.search_actions = gtk.ActionGroup('SearchActions')
        self.search_actions.add_toggle_actions([
            ('toggleRegexp',None,_('Use regular expressions in search'),
             None,_('Use regular expressions (an advanced search language) in text search'),
             self.toggleRegexpCB,False),
            ('toggleSearchAsYouType',None,_('Search as you type'),None,
             _('Search as you type (turn off if search is too slow).'),
             self.toggleTypeSearchCB, True
             ),
            ('toggleShowSearchOptions',
             None,
             _('Show Search _Options'),
             None,
             _('Show advanced searching options'),
             self.toggleShowSearchOptions),
            ])

    def setup_search_views (self):
        """Setup our views of the database."""
        self.last_search = {}
        #self.rvw = self.rd.fetch_all(self.rd.recipe_table,deleted=False)
        self.searches = self.default_searches[0:]
        self.sort_by = []
        self.rvw = self.rd.search_recipes(self.searches,sort_by=self.sort_by)

    def make_rec_visible (self, *args):
        """Make sure recipe REC shows up in our index."""
        #if not self.rg.wait_to_filter:
        #self.setup_search_views()
        self.redo_search()
        #debug('make_rec_visible',0)
        #self.visible.append(rec.id)
        #if not self.rg.wait_to_filter:
        #    self.rmodel_filter.refilter()

    def search_entry_activate_cb (self, *args):
        if self.rmodel._get_length_()==1:
            self.rec_tree_select_rec()
        elif self.srchentry.get_text():
            if not self.search_as_you_type:
                self.search()
                gobject.idle_add(lambda *args: self.limit_search())
            else:
                self.limit_search()
    
    def rmodel_page_changed_cb (self, rmodel):
        if rmodel.page==0:
            self.prev_button.set_sensitive(False)
            self.first_button.set_sensitive(False)
        else:
            self.prev_button.set_sensitive(True)
            self.first_button.set_sensitive(True)
        if rmodel.get_last_page()==rmodel.page:
            self.next_button.set_sensitive(False)
            self.last_button.set_sensitive(False)
        else:
            self.next_button.set_sensitive(True)
            self.last_button.set_sensitive(True)
        self.set_reccount()

    def rmodel_sort_cb (self, rmodel, sorts):
        self.sort_by = sorts
        self.last_search = {}
        self.search()
        #self.do_search(None,None)

    def create_rmodel (self, vw):
        self.rmodel = RecipeModel(vw,self.rd,per_page=self.prefs.get('recipes_per_page',12))
        #self.set_reccount() # This will be called by the rmodel_page_changed_cb
    
    def setup_rectree (self):
        """Create our recipe treemodel."""
        self.create_rmodel(self.rvw)
        self.rmodel.connect('page-changed',self.rmodel_page_changed_cb)
        self.rmodel.connect('view-changed',self.rmodel_page_changed_cb)
        self.rmodel.connect('view-sort',self.rmodel_sort_cb)
        # and call our handler once to update our prev/next buttons + label
        self.rmodel_page_changed_cb(self.rmodel)
        # and hook up our model
        self.rectree.set_model(self.rmodel)
        self.rectree.get_selection().set_mode(gtk.SELECTION_MULTIPLE)
        self.selection_changed()
        self.setup_reccolumns()
        # this has to come after columns are added or else adding columns resets out column order!
        self.rectree_conf=te.TreeViewConf(self.rectree,
                                          hidden=self.prefs.get('rectree_hidden_columns',DEFAULT_HIDDEN_COLUMNS),
                                          order=self.prefs.get('rectree_column_order',{}))
        self.rectree_conf.apply_column_order()
        self.rectree_conf.apply_visibility()
        self.rectree.connect("row-activated",self.rec_tree_select_rec)
        self.rectree.connect('key-press-event',self.tree_keypress_cb)        
        self.rectree.get_selection().connect("changed",self.selection_changedCB)
        self.rectree.set_property('rules-hint',True) # stripes!
        self.rectree.expand_all()
        self.rectree.show()

    def set_reccount (self, *args):
        """Display the count of currently visible recipes."""
        debug("set_reccount (self, *args):",5)
        self.count = self.rmodel._get_length_()
        bottom,top,total = self.rmodel.showing()
        if top >= total and bottom==1:
            lab = ngettext('%s recipe','%s recipes',top)%top
            for b in self.first_button,self.prev_button,self.next_button,self.last_button:
                b.hide()
        else:
            for b in self.first_button,self.prev_button,self.next_button,self.last_button:
                b.show()
            # Do not translate bottom, top and total -- I use these fancy formatting
            # strings in case your language needs the order changed!
            lab = _('Showing recipes %(bottom)s to %(top)s of %(total)s')%locals()
        self.showing_label.set_markup('<i>' + lab + '</i>')
        if self.count == 1:
            sel = self.rectree.get_selection()
            if sel: sel.select_path((0,))

    def setup_reccolumns (self):
        """Setup the columns of our recipe index TreeView"""
        renderer = gtk.CellRendererPixbuf()
        cssu=pageable_store.ColumnSortSetterUpper(self.rmodel)
        col = gtk.TreeViewColumn("",renderer,pixbuf=1)
        col.set_min_width(-1)
        self.rectree.append_column(col)
        n = 2
        _title_to_num_ = {}
        for c in self.rtcols:
            if c=='rating':
                # special case -- for ratings we set up our lovely
                # star widget
                twsm = ratingWidget.TreeWithStarMaker(
                    self.rectree,
                    self.rg.star_generator,
                    data_col=n,
                    col_title='_%s'%self.rtcolsdic[c],
                    handlers=[self.star_change_cb],
                    properties={'reorderable':True,
                                'resizable':True},
                    )
                cssu.set_sort_column_id(twsm.col,twsm.data_col)
                n += 1
                twsm.col.set_min_width(110)
                continue
            # And we also special case our time column
            elif c in ['preptime','cooktime']:
                _title_to_num_[self.rtcolsdic[c]]=n
                renderer=gtk.CellRendererText()
                renderer.set_property('editable',True)
                renderer.connect('edited',self.rtree_time_edited_cb,n,c)
                def get_colnum (tc):
                    try:
                        t = tc.get_title()
                        if t:
                            return _title_to_num_[t.replace('_','')]
                        else:
                            print 'wtf, no title for ',tc
                            return -1
                    except:
                        print 'problem with ',tc
                        raise
                    
                ncols = self.rectree.insert_column_with_data_func(
                    -1,
                    '_%s'%self.rtcolsdic[c],
                    renderer,
                    lambda tc,cell,mod,titr: \
                    cell.set_property(
                    'text',
                    convert.seconds_to_timestring(mod.get_value(
                    titr,
                    get_colnum(tc),
                    #_title_to_num_[tc.get_title().replace('_','')],
                    ))
                    )
                    )
                col=self.rectree.get_column(ncols-1)
                cssu.set_sort_column_id(col,n)
                col.set_property('reorderable',True)
                col.set_property('resizable',True)
                n+=1
                continue
            elif self.editable and self.rtwidgdic[c]=='Combo':
                renderer = gtk.CellRendererCombo()
                model = gtk.ListStore(str)
                if c=='category':
                    map(lambda i: model.append([i]),self.rg.rd.get_unique_values(c,self.rg.rd.categories_table)
                        )
                else:
                    map(lambda i: model.append([i]),self.rg.rd.get_unique_values(c))
                renderer.set_property('model',model)
                renderer.set_property('text-column',0)
            else:
                renderer = gtk.CellRendererText()
                if c=='link':
                    renderer.set_property('ellipsize',pango.ELLIPSIZE_END)
                else:
                    renderer.get_property('wrap-width')
                    renderer.set_property('wrap-mode',pango.WRAP_WORD)
                    if c == 'title': renderer.set_property('wrap-width',200)
                    else: renderer.set_property('wrap-width',150)
            renderer.set_property('editable',self.editable)
            renderer.connect('edited',self.rtree_edited_cb,n, c)
            titl = self.rtcolsdic[c]
            col = gtk.TreeViewColumn('_%s'%titl,renderer, text=n)
            # Ensure that the columns aren't really narrow on initialising.
            #if c=='title':            # Adjust these two to be even bigger
            #    col.set_min_width(200)
            #else:
            #    col.set_min_width(60)
            if c=='title':
                col.set_property('expand',True)
            col.set_reorderable(True)
            col.set_resizable(True)
            col.set_clickable(True)
            #col.connect('clicked', self.column_sort)
            self.rectree.append_column(col)
            cssu.set_sort_column_id(col,n)
            debug("Column %s is %s->%s"%(n,c,self.rtcolsdic[c]),5)
            n += 1

    def toggleTypeSearchCB (self, widget):
        """Toggle search-as-you-type option."""
        if widget.get_active():
            self.search_as_you_type=True
            self.searchButton.hide()
        else:
            self.search_as_you_type=False
            self.searchButton.show()

    def toggleRegexpCB (self, widget):
        """Toggle search-with-regexp option."""
        #if widget.get_active():
        #    self.message('Advanced searching (regular expressions) turned on')
        #else:
        #    self.message('Advanced searching off')
        pass

    def toggleShowSearchOptions (self, widget):
        if widget.get_active():
            self.searchOptionsBox.show()
        else:
            self.searchOptionsBox.hide()

    def regexpp (self):
        """Return True if we're using regexps"""
        if self.regexpTog.get_active():
            return True
        else:
            return False

    def search_as_you_type (self, *args):
        """If we're searching-as-we-type, search."""
        if self.search_as_you_type:
            self.search()

    def set_search_by (self, str):
        """Manually set the search by label to str"""
        debug('set_search_by',1)
        #self.rSearchByMenu.get_children()[0].set_text(str)
        cb.cb_set_active_text(self.rSearchByMenu, str)
        self.search()

    def redo_search (self, *args):
        self.last_search = {}
        self.search()
    
    def search (self, *args):
        debug("search (self, *args):",5)
        txt = self.srchentry.get_text()
        searchBy = cb.cb_get_active_text(self.rSearchByMenu)
        searchBy = self.searchByDic[unicode(searchBy)]
	if self.limitButton: self.limitButton.set_sensitive(txt!='')
        if self.make_search_dic(txt,searchBy) == self.last_search:
            debug("Same search!",1)
            return
        # Get window
        if self.srchentry:
            parent = self.srchentry.parent
            while parent and not (isinstance(parent,gtk.Window)):
                parent = parent.parent
            parent.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.WATCH))
            debug('Doing new search for %s, last search was %s'%(self.make_search_dic(txt,searchBy),self.last_search),1)
            gobject.idle_add(lambda *args: (self.do_search(txt, searchBy) or parent.window.set_cursor(None)))
        else:
            gobject.idle_add(lambda *args: self.do_search(txt, searchBy))

    def make_search_dic (self, txt, searchBy):
        srch = {'column':searchBy}
        if self.regexpp():
            srch['operator'] = 'REGEXP'
            srch['search'] = txt.replace(' %s '%_('or'), # or operator for searches
                                         '|')
        else:
            srch['operator']='LIKE'
            srch['search'] = '%' + txt.replace('%','%%')+'%'
        return srch

    def do_search (self, txt, searchBy):
        if txt and searchBy:
            srch = self.make_search_dic(txt,searchBy)
            self.last_search = srch.copy()
            self.update_rmodel(self.rd.search_recipes(
                self.searches + [srch],
                sort_by=self.sort_by)
                               )
        elif self.searches:
            self.update_rmodel(self.rd.search_recipes(
                self.searches,
                sort_by=self.sort_by)
                               )
        else:
            self.update_rmodel(self.rd.fetch_all(self.recipe_table,deleted=False,sort_by=self.sort_by))
    
    def limit_search (self, *args):
        debug("limit_search (self, *args):",5)
        self.search() # make sure we've done the search...
        self.searches.append(self.last_search)
        last_col = self.last_search['column']
        self.srchLimitBar.show()
        if last_col != _('anywhere'):
            newtext = ' ' + _('%s in %s')%(self.srchentry.get_text(),last_col)
        else:
            newtext = ' ' + self.srchentry.get_text()
        if self.srchLimitDefaultText!=self.srchLimitLabel.get_text():
            newtext = ',' + newtext
        self.srchLimitText="%s%s"%(self.srchLimitLabel.get_text(),newtext)
        self.srchLimitLabel.set_markup("<i>%s</i>"%self.srchLimitText)
        self.srchentry.set_text("")

    def reset_search (self, *args):
        debug("reset_search (self, *args):",5)
        self.srchLimitLabel.set_text(self.srchLimitDefaultText)
        self.srchLimitText=self.srchLimitDefaultText
        self.srchLimitBar.hide()
        self.searches = self.default_searches[0:]
        self.last_search={} # reset search so we redo it
        self.search()

    def get_rec_from_iter (self, iter):
        debug("get_rec_from_iter (self, iter): %s"%iter,5)
        obj=self.rectree.get_model().get_value(iter,0)
        retval=self.rd.get_rec(obj.id)
        return retval

    def rtree_time_edited_cb (self, renderer, path_string, text, colnum, attribute):
        if not text: secs = 0
        else:
            secs = self.rg.conv.timestring_to_seconds(text)
            if not secs:
                #self.message(_("Unable to recognize %s as a time."%text))
                return
        indices = path_string.split(':')
        path = tuple( map(int, indices))
        store = self.rectree.get_model()
        iter = store.get_iter(path)
        #self.rmodel.set_value(iter,colnum,secs)
        rec = self.get_rec_from_iter(iter)
        if convert.seconds_to_timestring(getattr(rec,attribute))!=text:
            self.rd.undoable_modify_rec(rec,
                                        {attribute:secs},
                                        self.history,
                                        get_current_rec_method=lambda *args: self.get_selected_recs_from_rec_tree()[0],
                                        )
            self.update_modified_recipe(rec,attribute,secs)
        # Is this really stupid? I don't know, but I did it before so
        # perhaps I had a reason.
        #self.rmodel.row_changed(path,iter)
        self.rmodel.update_iter(iter)
        self.rd.save()

    def rtree_edited_cb (self, renderer, path_string, text, colnum, attribute):
        debug("rtree_edited_cb (self, renderer, path_string, text, colnum, attribute):",5)
        indices = path_string.split(':')
        path = tuple( map(int, indices))
        store = self.rectree.get_model()
        iter = store.get_iter(path)
        if not iter: return
        #self.rmodel.set_value(iter, colnum, text)
        rec=self.get_rec_from_iter(iter)
        if attribute=='category':
            val = ", ".join(self.rd.get_cats(rec))
        else:
            val = "%s"%getattr(rec,attribute)
        if val!=text:
            # only bother with this if the value has actually changed!
            self.rd.undoable_modify_rec(rec,
                                        {attribute:text},
                                        self.history,
                                        get_current_rec_method=lambda *args: self.get_selected_recs_from_rec_tree()[0],
                                        )
            self.update_modified_recipe(rec,attribute,text)
        self.rmodel.update_iter(iter)
        self.rd.save()

    def tree_keypress_cb (self, widget, event):
        keyname = gtk.gdk.keyval_name(event.keyval)
        if keyname in ['Page_Up','Page_Down']:
            sb = self.sw.get_vscrollbar()
            adj =  self.sw.get_vscrollbar().get_adjustment() 
            val = adj.get_value(); upper = adj.get_upper()
            if keyname == 'Page_Up':
                if val > 0:
                    return None
                self.rmodel.prev_page()
                sb.set_value(upper)
                return True
            if keyname == 'Page_Down':
                if val < (upper - adj.page_size):
                    return None
                self.rmodel.next_page()
                sb.set_value(0)
                return True
        if keyname == 'Home':
            self.rmodel.goto_first_page()
            self.sw.get_vscrollbar().set_value(0)
            return True            
        if keyname == 'End':
            self.rmodel.goto_last_page()
            sb = self.sw.get_vscrollbar()
            sb.set_value(sb.get_adjustment().get_upper())
            return True            
        
    def star_change_cb (self, value, model, treeiter, column_number):
        #itr = model.convert_iter_to_child_iter(None,treeiter)
        #self.rmodel.set_value(treeiter,column_number,value)
        rec = self.get_rec_from_iter(treeiter)
        if getattr(rec,'rating')!=value:
            self.rd.undoable_modify_rec(
                rec,
                {'rating':value},
                self.history,
                get_current_rec_method = lambda *args: self.get_selected_recs_from_rec_tree()[0],
                )
            #self.rmodel.row_changed(self.rmodel.get_path(treeiter),treeiter)
            self.rmodel.update_iter(treeiter)

    def update_modified_recipe(self,rec,attribute,text):
        """Update a modified recipe.

        Subclasses can use this to update other widgets duplicating
        the information in the index view."""
        pass

    def rec_tree_select_rec (self, *args):
        raise NotImplementedError

    def get_selected_recs_from_rec_tree (self):
        debug("get_selected_recs_from_rec_tree (self):",5)
        def foreach(model,path,iter,recs):
            debug("foreach(model,path,iter,recs):",5)
            try:
                recs.append(model[path][0])
                #recs.append(self.get_rec_from_iter(iter))
            except:
                debug("DEBUG: There was a problem with iter: %s path: %s"%(iter,path),1)
        recs=[]
        sel = self.rectree.get_selection()
        if sel:
            sel.selected_foreach(foreach,recs)
            return recs
        else:
            return []

    def selection_changedCB (self, *args):
        """We pass along true or false to selection_changed
        to say whether there is a selection or not."""
        debug("selection_changed (self, *args):",5)
        v=self.rectree.get_selection().get_selected_rows()[1]
        if v: selected=True
        else: selected=False
        self.selection_changed(v)

    def selection_changed (self, selected=False):
        """This is a way to act whenever the selection changes."""
        pass

    def visibility_fun (self, model, iter):
        try:
            if (model.get_value(iter,0) and
                not model.get_value(iter,0).deleted and
                model.get_value(iter, 0).id in self.visible):
                return True
            else: return False
        except:
            debug('something bizaare just happened in visibility_fun',1)
            return False

    def update_rmodel (self, recipe_table):
        self.rmodel.change_view(recipe_table)
        self.set_reccount()

class RecipeModel (pageable_store.PageableViewStore):
    """A ListStore to hold our recipes in 'pages' so we don't load our
    whole database at a time.
    """
    per_page = 12
    page = 0

    columns_and_types = [('rec',gobject.TYPE_PYOBJECT,),
                         ('thumb',gtk.gdk.Pixbuf),
                         ]
    for n in [r[0] for r in REC_ATTRS]:
        if n in INT_REC_ATTRS: columns_and_types.append((n,int))
        else: columns_and_types.append((n,str))
    
    columns = [c[0] for c in columns_and_types]
    column_types = [c[1] for c in columns_and_types]

    def __init__ (self, vw, rd, per_page=None):
        self.rd = rd
        pageable_store.PageableViewStore.__init__(self,
                                                  vw,
                                                  columns=self.columns,
                                                  column_types=self.column_types,
                                                  per_page=per_page)
        self.made_categories = False

    def _get_slice_ (self,bottom,top):
        try:
            return [[self._get_value_(r,col) for col in self.columns] for r in self.view[bottom:top]]
        except:
            print '_get_slice_ failed with',bottom,top
            raise

    def _get_value_ (self, row, attr):
        if attr=='category':
            cats = self.rd.get_cats(row)
            if cats: return ", ".join(cats)
            else: return ""
        elif attr=='rec':
            return row
        elif attr=='thumb':
            if row.thumb: return get_pixbuf_from_jpg(row.thumb)
            else: return None        
        elif attr in INT_REC_ATTRS:
            return getattr(row,attr) or 0
        else:
            val = getattr(row,attr)
            if val: return str(val)
            else: return None
        #else:
        #    
        #    return str(getattr(row,attr))

    def update_recipe (self, recipe):
        """Handed a recipe (or a recipe ID), we update its display if visible."""
        debug('Updating recipe %s'%recipe.title,3)
        if type(recipe)!=int: recipe=recipe.id # make recipe == id
        for n,row in enumerate(self):
            debug('Looking at row',3)
            if row[0].id==recipe:
                indx = int(n + (self.page * self.per_page))
                # update parent
                self.parent_list[indx] = self.rd.fetch_one(self.rd.recipe_table,
                                                           id=recipe)
                # update self
                self.update_iter(row.iter)
                debug('updated row -- breaking',3)
                break


########NEW FILE########
__FILENAME__ = recipeIdentifier
"""recipeIdentifier.py

This module contains code for creating hashes to identify recipes
based on title & instructions (recipe hash) or based on ingredients (ingredient hash).

The hash_recipe function is a convenience function that provide both a
recipe hash and an ingredient hash.

For individual hashes, use the get_recipe_hash and get_ingredient_hash
functions.

"""

import convert, xml.sax.saxutils
import hashlib, difflib, types, re
from gettext import gettext as _
from gglobals import REC_ATTRS,TEXT_ATTR_DIC,INT_REC_ATTRS

IMAGE_ATTRS = ['image','thumb']
ALL_ATTRS = [r[0] for r in REC_ATTRS] + TEXT_ATTR_DIC.keys() + IMAGE_ATTRS
REC_FIELDS = ['title',
              'instructions',
              ]
ING_FIELDS = ['amount','unit']

STANDARD_UNITS = ['g.','ml.']

# Hash stuff.

def standardize_ingredient (ing_object, converter):
    if ing_object.item:
        ing = ing_object.item
    else:
        ing = ing_object.ingkey
    unit,amount = ing_object.unit,ing_object.amount
    gconv = converter.converter(unit,'g.')
    vconv = converter.converter(unit,'ml.')
    if not (gconv or vconv):
        gconv = converter.converter(unit,'g.',ing)
        vconv = converter.converter(unit,'ml.',ing)
    if gconv:
        unit = 'g.'
        if amount: amount = amount*gconv
    elif vconv:
        unit = 'ml.'
        if amount: amount = amount*vconv
    if unit in ['g.','ml.']:
        # Round to the 10s place...
        if amount:
            amount = round(amount,-1)
    istring = "%s %s %s"%(amount,unit,ing)
    return istring.lower()

def get_ingredient_hash (ings, conv):
    ings = [standardize_ingredient(i,conv) for i in ings]
    ings.sort()
    ings = '\n'.join(ings)
    m = hashlib.md5(ings)
    #print 'Hash',ings,m.hexdigest()
    return m.hexdigest()

def get_recipe_hash (recipe_object):
    recstrings = []
    for field in REC_FIELDS:
        if getattr(recipe_object,field): recstrings.append(getattr(recipe_object,field))
    recstring = '\n'.join(recstrings)
    recstring = recstring.strip()
    recstring = recstring.lower()
    #print 'hash',recstring
    m = hashlib.md5(recstring)
    return m.hexdigest()

def hash_recipe (rec, rd, conv=None):
    if not conv: conv = convert.get_converter()
    rechash = get_recipe_hash(rec)
    inghash = get_ingredient_hash(rd.get_ings(rec),conv)
    return rechash,inghash

# Diff stuff

# Convenience methods
def format_ing_text (ing_alist,rd,conv=None):
    strings = []
    for g,ings in ing_alist:
        if g: strings.append('\n<u>'+g+'</u>')
        for i in ings:
            istring = []
            a,u = rd.get_amount_and_unit(i,conv=conv)
            if a: istring.append(a)
            if u: istring.append(u)
            if i.item: istring.append(i.item)
            if (type(i.optional)!=str and i.optional) or i.optional=='yes': 
                    istring.append(_('(Optional)'))
            if i.refid: istring.append('=>%s'%i.refid)
            if i.ingkey: istring.append('key=%s'%i.ingkey)
            strings.append(xml.sax.saxutils.escape(' '.join(istring)))
    return '\n'.join(strings).strip()
            

def format_ings (rec, rd):
    ings = rd.get_ings(rec)
    alist = rd.order_ings(ings)
    return format_ing_text(alist,rd)

def apply_line_markup (line, markup):
    out = ''
    current_tag = ''
    if len(markup) < len(line):
        markup += ' '*(len(line)-len(markup))
    for n in range(len(line)):
        if markup[n]==' ' or markup[n]=='\n':
            tag = None
        elif markup[n]=='+':
            tag = 'add'
        elif markup[n]=='-':
            tag = 'del'
        else:
            #print "WARNING: don't recognize diff tag \"%s\""%markup[n]
            tag = None
        if tag != current_tag:
            if current_tag:
                out += '</%s>'%current_tag
            if tag:
                out += '<%s>'%tag
            current_tag = tag
        out += line[n]
    if current_tag:
        out += '</%s>'%current_tag
    return out

def get_diff_markup (s1,s2):
    diffs = []
    for line in difflib.ndiff(s1,s2):
        code = line[:2]
        line = line[2:]
        if code!='? ':
            diffs.append([code,line])
        else:
            diffs[-1][1] = apply_line_markup(diffs[-1][1],line)
    return diffs

def get_two_columns (s1,s2):
    """Get two columns with diff markup on them."""
    diffs = get_diff_markup(s1,s2)
    left = []
    right = []
    for code,line in diffs:
        if code=='- ':
            left.append('<diff>'+line+'</diff>')
        elif code=='+ ':
            right.append('<diff>'+line+'</diff>')
        elif code=='  ':
            while len(left) < len(right):
                left.append('<diff/>')
            while len(right) < len(left):
                right.append('<diff/>')
            left.append(line)
            right.append(line)
    return left,right
        
def diff_ings (rd,rec1,rec2):
    ings1 = format_ings(rec1,rd)
    ings2 = format_ings(rec2,rd)
    if ings1 != ings2:
        return get_two_columns(ings1.splitlines(),ings2.splitlines())

def diff_recipes (rd,recs):
    diffs = {}
    for attr in ALL_ATTRS:
        if attr == 'category':
            vals = [', '.join(rd.get_cats(r)) for r in recs]
        else:
            vals = [getattr(r,attr) for r in recs]
        # If all our values are identical, there is no
        # difference. Also, if all of our values are bool->False, we
        # don't care (i.e. we don't care about the difference between
        # None and "" or between None and 0).
        if vals != [vals[0]] * len(vals) and True in [bool(v) for v in vals]:
            #if TEXT_ATTR_DIC.has_key(attr):
            #    val1,val2 = 
            diffs[attr]=vals
    return diffs

def merge_recipes (rd, recs):
    """Return two dictionaries representing the differences between recs.

    The first dictionary contains items that are blank in one recipe
    but not the other. The second dictionary contains conflicts."""
    diffs = diff_recipes(rd,recs)
    my_recipe = {} 
    # Now we loop through the recipe and remove any attributes that
    # are blank in one recipe from diffs and put them instead into
    # my_recipe.
    for attr,vals in diffs.items():
        value = None
        conflict = False
        for v in vals:
            if not v:
                continue
            elif not value:
                value = v
            elif (v != value):
                if ((type(v) in types.StringTypes
                     and
                     type(value) in types.StringTypes)
                    and v.lower()==value.lower()):
                    continue
                else:
                    conflict = True
                    break
        if conflict: continue
        else:
            if value: my_recipe[attr]=value
            del diffs[attr]
    return my_recipe,diffs

def format_ingdiff_line (s):
    if re.search('key=(.*)(?=</diff>)',s):
        s = re.sub('key=(.*)(?=</diff>)','<i>(\\1)</i>',s)
    else:
        s = re.sub('key=(.*)','<i>(\\1)</i>',s)
    s = s.replace('<diff>','<span background="#ffff80" foreground="#000">')
    s = s.replace('</diff>','</span>')
    s = s.replace('<diff/>','')
    #s = s.replace('<del>','<span color="red" strikethrough="true">')
    s = s.replace('<del>','<span weight="bold" color="red">')
    s = s.replace('</del>','</span>')
    s = s.replace('<add>','<span weight="bold" color="red">')
    s = s.replace('</add>','</span>')
    return s

def show_ing_diff (idiff):
    import gtk
    left, right = idiff
    ls = gtk.ListStore(str,str)
    for n in range(len(left)):
        ls.append([format_ingdiff_line(left[n]),
                  format_ingdiff_line(right[n])]
                  )
    tv = gtk.TreeView()
    r = gtk.CellRendererText()
    tc = gtk.TreeViewColumn('Left',r,markup=0)
    tc2 = gtk.TreeViewColumn('Right',r,markup=1)
    tv.append_column(tc)
    tv.append_column(tc2)
    tv.set_model(ls)
    return tv



if __name__ == '__main__':
    import recipeManager, gtk
    rd = recipeManager.default_rec_manager()
    r1 = 33
    r2 = 241
    
    #empty_hash = get_ingredient_hash([],None)
    #rr = {}; ii = {}; ir = {}; count = 0
#     for rec in rd.fetch_all(rd.recipe_table,deleted=False):
#         count += 1
#         rh,ih = hash_recipe(rec,rd)
#         ch = rh+ih
#         if count % 10 == 0: print count,rec.id,ch
#         #print ch,rec.id
#         if ir.has_key(ch):
#             print rec.id,rec.title,'is a complete duplicate of',ir[ch].id,ir[ch].title
#             print 'Merge would be: ',merge_recipes(rd,[rec,ir[ch]])
#         else:
#             ir[ch]=rec
#         if rr.has_key(rh):
#             print rec.id,rec.title,'duplicates',rr[rh].id,rr[rh].title
#             rdiff = diff_recipes(rd,[rec,rr[rh]])
#             idiff =  diff_ings(rd,rec,rr[rh])
#             if (not rdiff) and (not idiff):
#                 print 'PERFECT DUPS!'
#             if rdiff:
#                 print 'Rec Diff'
#                 for k,v in rdiff.items(): print '%s: %s\t%s'%(k,v[0],v[1])
#             if idiff:
#                 tv = show_ing_diff(idiff)
#                 w = gtk.Window()
#                 w.add(tv)
#                 w.show_all()
#                 w.connect('delete-event',gtk.main_quit)
#                 gtk.main()
#                 left,right = idiff
#                 print 'ING DIFF\n----------\n'
#                 for n in range(len(left)):
#                     print left[n],right[n]
                
#         else:
#             rr[rh]=rec
#         if ii.has_key(ih) and ih != empty_hash:
#             print rec.id,rec.title,'duplicates ings',ii[ih].id,ii[ih].title
#         else:
#             ii[ih]=rec

########NEW FILE########
__FILENAME__ = recipeManager
from gettext import gettext as _
import convert, shopping, os.path
from OptionParser import args
import gglobals
from gtk_extras import dialog_extras as de

# Follow commandline db specification if given
dbargs = {}

if not dbargs.has_key('file'):
    dbargs['file']=os.path.join(gglobals.gourmetdir,'recipes.db')
if args.db_url:
    print 'We have a db_url and it is,',args.db_url
    dbargs['custom_url'] = args.db_url
    

from backends.db import RecData, RecipeManager, dbDic

class DatabaseShopper (shopping.Shopper):
    """We are a Shopper class that conveniently saves our key dictionaries
    in our database"""
    def __init__ (self, lst, db, conv=None):
        self.db = db
        self.cnv = conv
        shopping.Shopper.__init__(self,lst)

    def init_converter (self):
        #self.cnv = DatabaseConverter(self.db)
        if not self.cnv:
            self.cnv = convert.get_converter()
    
    def init_orgdic (self):
        self.orgdic = dbDic('ingkey','shopcategory',self.db.shopcats_table,db=self.db)
        if len(self.orgdic.items())==0:
            dic = shopping.setup_default_orgdic()
            self.orgdic.initialize(dic)

    def init_ingorder_dic (self):
        self.ingorder_dic = dbDic('ingkey','position',self.db.shopcats_table,db=self.db)

    def init_catorder_dic (self):
        self.catorder_dic = dbDic('shopcategory',
                                  'position',
                                  self.db.shopcatsorder_table,
                                  db=self.db)

    def init_pantry (self):
        self.pantry = dbDic('ingkey','pantry',self.db.pantry_table,db=self.db)
        if len(self.pantry.items())==0:
            self.pantry.initialize(dict([(i,True) for i in self.default_pantry]))

# A simple CLI for mucking about our DB without firing up gourmet proper
class SimpleCLI:
    def __init__  (self, rmclass=None, rmargs=None):
        if not rmclass: self.rmclass=RecipeManager
        else: self.rmclass = rmclass
        if not rmargs: self.args=dbargs
        else: self.args=rmargs
        self.rm = self.rmclass(**self.args)

    def __call__ (self):
        print """Welcome to GRM's handy debugging interface straight to our database.
        You are now in the midst of our caller class. You can access your recipeManager
        class through self.rm.

        One major limitation: You can only execute a single expression
        at a time (i.e. what you you could put in a lambda expression).
        """
        while True:
            inp = raw_input('GRM>')
            if inp == 'quit' or inp == '' or inp == '
########NEW FILE########
__FILENAME__ = settings
import os.path
import sys

# The following lines are modified at installation time by setup.py so they
# point to the actual data files installation paths.

lib_dir = '../gourmet'
base_dir = '..'
data_dir = os.path.join(base_dir, "gourmet", "data")
ui_base = os.path.join(base_dir, 'gourmet', 'ui')
doc_base = os.path.join(base_dir, "gourmet")
locale_base = os.path.join(base_dir, "gourmet", "build", "mo")
plugin_base = os.path.join(base_dir, "gourmet", "build", "share", "gourmet")

# Apologies for the formatting -- something in the build process is
# getting rid of indentations in this file which throws a syntax error
# on install
if getattr(sys, 'frozen', False): base_dir = os.path.dirname(sys.executable); data_dir = base_dir; ui_base = os.path.join(base_dir, 'ui'); doc_base = os.path.join(base_dir, 'doc');locale_base = os.path.join(base_dir, "locale"); plugin_base = os.path.join(base_dir)
    
icon_base = os.path.join(data_dir, "icons")

########NEW FILE########
__FILENAME__ = shopEditor
import gtk, gobject, backends.db, re, pickle
from gglobals import uibase
from gtk_extras import WidgetSaver
from gtk_extras import cb_extras as cb
from gtk_extras import dialog_extras as de

class ShopEditor:

    """ShopEditor sets up a GUI to allow editing which shopping
    categories correspond to which items throughout the recipe
    database. It is useful for corrections or changes to category info
    en masse and for reordering shopping categories."""
    
    def __init__ (self, rd=backends.db.recipeManager(), rg=None):
        self.ui = gtk.Builder()
        self.ui.add_from_file(os.path.join(uibase,'shopCatEditor.ui'))
        self.rd = rd
        self.rg = rg
        self.prefs = self.rg.prefs        
        self.widget_names = ['treeview', 'searchByBox', 'searchEntry', 'searchButton', 'window',
                             'searchAsYouTypeToggle', 'regexpTog', 'deleteCatButton', 'addCatEntry',
                             'addCatButton']
        for w in self.widget_names:
            setattr(self,w,self.ui.get_object(w))
        # setup entry callback to sensitize/desensitize apply
        self.addCatButton.set_sensitive(False)
        self.addCatEntry.connect('changed',self.addCatEntryChangedCB)
        self.makeTreeModel()
        self.search_string=""
        self.treeModel.set_default_sort_func(self.sort_model_fun)
        self.treeModel.set_sort_column_id(-1,gtk.SORT_ASCENDING)
        self.filteredModel = self.treeModel.filter_new()
        self.filteredModel.set_visible_func(self.filter_visibility_fun)
        self.setupTreeView()
        self.treeview.set_model(self.filteredModel)
        self.treeview.get_selection().set_mode(gtk.SELECTION_MULTIPLE)
        #self.treeview.set_model(self.treeModel)
        self.ui.connect_signals({
            'iSearch':self.isearchCB,
            'search':self.searchCB,
            'search_as_you_type_toggle':self.search_as_you_typeCB,
            'close_window': lambda *args: self.window.hide() and self.window.destroy(),
            'catUp':self.catUpCB,
            'catDown':self.catDownCB,
            'catTop':self.catTopCB,
            'catBottom':self.catTopCB,
            })
        # to set our regexp_toggled variable
        self.searchByBox.set_active(0)
        self.dont_ask = False
        # setup WidgetSavers
        self.rg.conf.append(WidgetSaver.WidgetSaver(
            self.searchAsYouTypeToggle,
            self.prefs.get('sautTog',
                           {'active':self.searchAsYouTypeToggle.get_active()}),
            ['toggled']))
        self.rg.conf.append(WidgetSaver.WidgetSaver(
            self.regexpTog,
            self.prefs.get('regexpTog',
                           {'active':self.regexpTog.get_active()}),
            ['toggled']))
                
    def dont_ask_cb (self, widget, *args):
        self.dont_ask=widget.get_active()

    def sort_model_fun (model, iter1, iter2, data):
        c1 = model.get_value(iter1, self.CAT_COL)
        if self.rg.sl.sh.catorder_dic.has_key(c1):
            c1_order = self.rg.sl.sh.catorder_dic[c1]
        else:
            c1_order = None
        c2 = model.get_value(iter2, self.CAT_COL)
        if self.rg.sl.sh.catorder_dic.has_key(c1):
            c2_order = self.rg.sl.sh.catorder_dic[c2]
        else:
            c2_order = None
        if c1_order and c2_order:
            compare = c1_order > c2_order
        elif c1 and c2:
            compare = c1 > c2
        else:
            k1 = model.get_value(iter1, self.KEY_COL)
            k2 = model.get_value(iter2, self.KEY_COL)
            if k1 and k2:
                compare = k1 > k2
            else:
                compare = 0
        # iter1 and iter2 are equal
        if compare==0: return 0
        # iter1 precedes iter2
        if compare: return 1
        # iter2 precedes iter1
        else: return 1
    
    def filter_visibility_fun (self, mod, iter):
        if not self.search_string:
            return True
        str = mod.get_value(iter,self.search_by)
        if not str and self.search_by==self.KEY_COL:
            # then we need to make sure we show key header rows
            # whose items include an item w/ the proper title...
            cat = mod.get_value(iter,self.CAT_COL)
            if self.cat_to_key.has_key(cat):
                for itm in self.cat_to_key[cat]:
                    if self.use_regexp:
                        if re.search(self.search_string, itm): return True
                    elif itm.find(self.search_string) >= 0: return True
        if self.use_regexp:
            if re.search(self.search_string, str): return True
        else:
            if str.find(self.search_string) >= 0:
                return True
        
    def setupTreeView (self):
        self.CAT_COL = 1
        self.KEY_COL = 2
        for n,head in [[self.CAT_COL,'Category'],
                       [self.KEY_COL,'Key'],
                       ]:
            renderer = gtk.CellRendererText()
            renderer.set_property('editable',True)
            renderer.connect('edited',self.tree_edited,n,head)
            col = gtk.TreeViewColumn(head, renderer, text=n)
            col.set_resizable(True)
            self.treeview.append_column(col)
            self.treeview.connect('row-expanded',self.populateChild)

    def tree_edited (self, renderer, path_string, text, n, head):
        indices = path_string.split(':')
        path = tuple( map(int, indices))
        iter = self.filteredModel.convert_iter_to_child_iter(self.filteredModel.get_iter(path))
        key = self.treeModel.get_value(iter, self.KEY_COL)
        item = self.treeModel.get_value(iter, self.ITEM_COL)
        children = self.treeModel.iter_children(iter)
        if n==self.KEY_COL and key==text: return
        if n==self.ITEM_COL and item==text: return
        ## make sure they want to make this change
        if not self.dont_ask:
            msg = "Are you sure you want to change the "
            if n==self.KEY_COL: msg += 'key'
            if n==self.ITEM_COL: msg += 'item'
            if item:
                msg += "for \"%s from \"%s\""%(item,key)
            else:
                msg += " from \"%s\" "%key
            msg += " to \"%s\""%text
            if not de.getBoolean(label=msg,
                                 dont_ask_cb=self.dont_ask_cb,
                                 dont_ask_custom_text="Don't ask me before changing keys and items."):
                return
        if children and n==self.KEY_COL:
            self.change_children(key, text, iter)
        else:
            if n==self.KEY_COL:
                self.changeItem(key, item, new_key=text)
            elif n==self.ITEM_COL:
                self.changeItem(key, item, new_item=text)
        self.treeModel.set_value(iter, n, text)

    def change_children (self, key, new_key, iter):
        # if it's children, it means we're changing a key for
        # all cases... and then we just have to change the model
        # so our user knows it worked
        self.changeItem(key, new_key=new_key)
        nn = 0
        child = self.treeModel.iter_nth_child(iter,nn)
        while child:
            self.treeModel.set_value(child, self.KEY_COL, new_key)
            nn += 1
            child = self.treeModel.iter_nth_child(iter,nn)        
        
    def changeItem (self, key, item=None, new_key=None, new_item=None):
        if item:
            vw=self.rd.ingredients_table.select(key=key,item=item)
        else:
            vw=self.rd.ingredients_table.select(key=key)
        for i in vw:
            if new_key:
                i.ingkey=new_key
                self.rd.changed=True                
            if new_item:
                i.item=new_item
                self.rd.changed=True                
        
    def makeTreeModel (self):
        self.treeModel = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str)
        unique_cat_vw = self.rd.shopcats_table.groupby(self.rd.shopcats_table.category, 'groupvw')
        self.cat_to_key={}
        for c in unique_cat_vw:
            iter=self.treeModel.append(None,[c, pickle.loads(c.category), ""])
            self.cat_to_key[pickle.loads(c.category)]=[]
            for i in c.groupvw:
                #self.treeModel.append(iter,[i,pickle.loads(c.category),i.ingkey])
                self.treeModel.append(iter,[i,pickle.loads(c.category),i.ingkey])
                self.cat_to_key[pickle.loads(c.category)].append(i.ingkey)

    def populateChild (self, tv, iter, path):
        iter = self.filteredModel.convert_iter_to_child_iter(iter)
        n = 0
        child = self.treeModel.iter_nth_child(iter,n)
        while child:
            i = self.treeModel.get_value(child,0)
            recipes = ""
            for ii in i.itemgroup:
                id = ii.id
                r = self.rd.get_rec(ii.id)
                if r: recipes += ", %s"%r.title
            recipes = recipes[2:] # strip the first space
            self.treeModel.set_value(child, 4, recipes)
            n += 1
            child = self.treeModel.iter_nth_child(iter,n)

    def doSearch (self):
        """Do the actual searching."""
        self.search_string = self.searchEntry.get_text()
        search_by_str = cb.cb_get_active_text(self.searchByBox)
        self.use_regexp = self.regexpTog.get_active()
        if search_by_str == 'Key':
            self.search_by = self.KEY_COL
        else:
            #print self.treeModel[-1][self.ITEM_COL]
            self.search_by = self.CAT_COL
        self.filteredModel.refilter()

    def isearchCB (self, *args):
        if self.searchAsYouTypeToggle.get_active():
            self.doSearch()

    def searchCB (self, *args):
        self.doSearch()

    def search_as_you_typeCB (self, *args):
        if self.searchAsYouTypeToggle.get_active():
            self.searchButton.hide()
        else: self.searchButton.show()
            
    def addCatEntryChangedCB (self, *args):
        if self.addCatEntry.get_text():
            self.addCatButton.set_sensitive(True)
        else: self.addCatButton.set_sensitive(False)


    def catUpCB (self, *args):
        pass
    
    def catDownCB (self, *args):
        pass
    
    def catTopCB (self, *args):
        pass
    
    def catBottomCB (self, *args):
        pass

            
if __name__ == '__main__':
    ke=ShopEditor()
    gtk.main()

########NEW FILE########
__FILENAME__ = shopgui
#!/usr/bin/env python
import gtk, gobject, pango, sys, os.path, time, os, string
import recipeManager, convert, reccard, prefs
from gtk_extras import WidgetSaver, mnemonic_manager
from gtk_extras import dialog_extras as de
from gtk_extras import treeview_extras as te
from gtk_extras import fix_action_group_importance
from exporters.printer import get_print_manager
from gdebug import debug
from gettext import gettext as _
from gglobals import doc_base
#from nutrition.nutritionLabel import NutritionLabel
#from nutrition.nutrition import NutritionInfoList
import plugin_loader, plugin
from shopping import ShoppingList

ui_string = '''
<ui>
  <menubar name="ShoppingListMenuBar">
    <menu name="File" action="File">
      <menuitem action="Save"/>
      <menuitem action="Print"/>
      <separator/>
      <placeholder name="ExtraFileStuff"/>
      <separator/>
      <menuitem action="Close"/>	
    </menu>
    <menu name="Edit" action="Edit">
      <menuitem action="AddNewItems"/>      
      <menuitem action="RemoveRecipes"/>
      <separator/>
      <menuitem action="ItemToPantry"/>
      <menuitem action="ItemToShoppingList"/>
      <menuitem action="ChangeCategory"/>
    </menu>
    <menu name="HelpMenu" action="HelpMenu">
      <menuitem action="Help"/>
    </menu>
  </menubar>
  <popup name="ShopPop">
    <menuitem action="ItemToPantry"/>
    <menu action="ChangeCategoryPop">
      <placeholder name="categories"/>
      <menuitem action="newCategory"/>
    </menu>
  </popup>
  <popup name="PanPop">
    <menuitem name="ItemToShoppingList" action="ItemToShoppingList"/>
    <menu name="ChangeCategoryPop" action="ChangeCategoryPop">
      <placeholder name="categories"/>
      <menuitem name="newCategory" action="newCategory"/>
    </menu>
  </popup>
  <popup action="ChangeCategoryPopup">
     <placeholder name="categories"/>
     <menuitem name="newCategory" action="newCategory"/>
  </popup>
  <toolbar name="ShoppingListTopToolBar">
    <toolitem action="Save"/>
    <toolitem action="Print"/>
    <separator/>
    <toolitem action="RemoveRecipes"/>
  </toolbar>
  <toolbar name="ShoppingListActionToolBar">
    <toolitem action="AddNewItems"/>
    <separator/>
    <toolitem action="ChangeCategory"/>
    <separator/>
    <toolitem action="ItemToShoppingList"/>
    <toolitem action="ItemToPantry"/>
  </toolbar>
</ui>
'''

# Convenience functions
def setup_frame_w_accel_label (txt, target_widget=None):
    '''Return a frame with a mnemonic label'''
    l =  gtk.Label(txt)
    l.set_use_underline(True)
    f = gtk.Frame()
    f.set_label_widget(l); l.show()
    if target_widget:
	l.set_mnemonic_widget(target_widget)
    return f

def setup_sw (child):
    sw = gtk.ScrolledWindow()
    sw.set_policy(gtk.POLICY_NEVER,gtk.POLICY_AUTOMATIC)
    sw.add(child)
    child.show(); sw.show()
    return sw
# end convenience functions

class IngredientAndPantryList:
    '''A subclass to handle all TreeView code for moving items between
    shopping and pantry list
    '''

    def __init__ (self):
	if hasattr(self,'rg'):
	    self.rd = self.rg.rd
	else:
	    self.rd = recipeManager.get_recipe_manager()
        # We need to keep track of including/excluding options...
        # Here's our solution: we have a dictionary where we can lookg
        # up ingredients by recipe by key
        # {'recipe_id' : {'key1' : False
        #                 'key2  : True}} ... where true and false mean include/exclude
        self.setup_ui_manager()
	self.setup_actions()

    def setup_ui_manager (self):
	self.ui_manager = gtk.UIManager()
	self.ui_manager.add_ui_from_string(ui_string)

    def setup_actions (self):
	self.pantryActions = gtk.ActionGroup('PantryActions')
        self.shoppingActions = gtk.ActionGroup('ShoppingActions')
	self.pantryOrShoppingActions = gtk.ActionGroup('PantryOrShoppingActions')
	self.pantryOrShoppingActions.add_actions([
	    ('ChangeCategoryPop',None,_('Change _Category')),
	    ('newCategory',None,_('Create new category'),None,None,
	     lambda *args: self.pantryOrShoppingActions.get_action('ChangeCategory').set_active(True)),
	    ])
	self.pantryOrShoppingActions.add_toggle_actions([
	    ('ChangeCategory',
             None,
             _('Change _Category'),
             None,
	     _('Change the category of the currently selected item'),
	     self.change_category
	     ),
	    ]
							)
	self.pantryActions.add_actions([
	    ('PantryPopup',None,_('Pantry')),
	    ('ItemToShoppingList',# name
	     'add-to-shopping-list',# stock
	     _('Move to _Shopping List'), # text
	     _('<Ctrl>B'), # key-command
	     None, # tooltip
	     lambda *args: self.rem_selection_from_pantry() # callback
	     ),
	    ])
	self.shoppingActions.add_actions([
	    ('ShopPopup',None,_('Shopping List')),
	    ('ItemToPantry',# name
	     gtk.STOCK_UNDO,# stock
	     _('Move to _pantry'), # text
	     _('<Ctrl>D'), # key-command
	     _('Remove from shopping list'), # tooltip
	     lambda *args: self.add_selection_to_pantry() # callback
	     ),
	    ])
        fix_action_group_importance(self.pantryActions)
	self.ui_manager.insert_action_group(self.pantryActions,0)
        fix_action_group_importance(self.shoppingActions)
	self.ui_manager.insert_action_group(self.shoppingActions,0)
        fix_action_group_importance(self.pantryOrShoppingActions)
	self.ui_manager.insert_action_group(self.pantryOrShoppingActions,0)	

    def setup_category_ui (self):
	self.cats_setup = True
	catUI = '''<placeholder name="categories">'''
	def my_cb (widget, cat):
	    self.change_to_category(cat)
	for n,category in enumerate(self.sh.get_orgcats()):
	    actionName = 'category'+str(n)
	    catUI += '<menuitem action="%s"/>'%actionName
	    self.pantryOrShoppingActions.add_actions([
		(actionName,None,category,
		 None,_('Move selected items into %s')%category,
		 None)
		]
		)
	    self.pantryOrShoppingActions.get_action(actionName).connect('activate',my_cb,category)
	    self.get_catmodel().append([category])
	catUI += '</placeholder>'
	catUI = '''<ui>
	<menubar action="ShoppingListMenu">
	  <menu action="Edit">
	    <menu action="ChangeCategoryPop">
	      %(ph)s
	    </menu>
	  </menu>
	</menubar>
	<popup action="ShopPop">
	    <menu action="ChangeCategoryPop">
	    %(ph)s
	    </menu>
	</popup>
	<popup name="PanPop">
	  <menu name="ChangeCategoryPop" action="ChangeCategoryPop">
	  %(ph)s
	  </menu>
	</popup>
	<popup name="ChangeCategoryPopup">
	  %(ph)s
	</popup>	
	</ui>'''%{'ph':catUI}
	self.last_category_merge = self.ui_manager.add_ui_from_string(catUI)
	self.ui_manager.ensure_update()

    # Base GUI Setup
    def setup_paned_view (self):
	self.create_pTree()
	self.create_slTree()
	hp =  gtk.HPaned(); hp.set_position(400)
        f1 = setup_frame_w_accel_label(_('_Shopping List'),self.slTree)
        f2 = setup_frame_w_accel_label(_('Already Have (_Pantry Items)'),self.pTree)
	f1.add(setup_sw(self.slTree)); f1.show_all()
	f2.add(setup_sw(self.pTree)); f2.show_all()
        hp.add1(f1)
        hp.add2(f2)
	return hp

    # TreeView and TreeModel setup
    def create_pTree (self):
        debug("create_pTree (self, data):",5)
        self.pMod = self.createIngModel(self.pantry)
	self.pTree = self.create_ingTree(gtk.TreeView(),
					  self.pMod)
        #self.pTree.connect('popup-menu',self.popup_pan_menu)
        self.pTree.get_selection().connect('changed',self.pTree_sel_changed_cb)
        # reset the first time...
        self.pTree_sel_changed_cb(self.pTree.get_selection())
        def pTree_popup_cb (tv, event):
            debug("pTree_popup_cb (tv, event):",5)
            if event.button==3 or event.type == gtk.gdk._2BUTTON_PRESS:
                self.popup_pan_menu(tv,event)
                return True
            
        self.pTree.connect('button-press-event',pTree_popup_cb)

    def create_slTree (self):
        debug("create_slTree (self, data):",5)
        self.slMod = self.createIngModel(self.data)
	self.slTree = self.create_ingTree(gtk.TreeView(),
					  self.slMod)
	self.slTree.show()
        self.slTree.connect('popup-menu',self.popup_ing_menu)
        def slTree_popup_cb (tv, event):
            debug("slTree_popup_cb (tv, event):",5)
            if event.button==3 or event.type == gtk.gdk._2BUTTON_PRESS:
                self.popup_ing_menu(tv,event)
                return True
        self.slTree.connect('button-press-event',slTree_popup_cb)
        self.slTree.get_selection().connect('changed',self.slTree_sel_changed_cb)
        # reset the first time
        self.slTree_sel_changed_cb(self.slTree.get_selection())

    def create_ingTree (self, widget, model):
        debug("create_ingTree (self, widget, model):",5)
        #self.slTree = gtk.TreeView(self.slMod)
        tree=widget
        tree.set_model(model)
        ## add multiple selections
        tree.get_selection().set_mode(gtk.SELECTION_MULTIPLE)
        ## adding drag and drop functionality
        targets = [('GOURMET_SHOPPER_SW', gtk.TARGET_SAME_WIDGET, 0),
                   ('GOURMET_SHOPPER', gtk.TARGET_SAME_APP, 1),
                   ('text/plain',0,2),
                   ('STRING',0,3),
                   ('STRING',0,4),
                   ('COMPOUND_TEXT',0,5),
                   ('text/unicode',0,6),]
        tree.drag_source_set(gtk.gdk.BUTTON1_MASK, targets,
                             gtk.gdk.ACTION_COPY | gtk.gdk.ACTION_MOVE)
        tree.enable_model_drag_dest(targets,
                                    gtk.gdk.ACTION_COPY | gtk.gdk.ACTION_MOVE)
        tree.connect('drag_begin', self.on_drag_begin)
        tree.connect('drag_data_get', self.on_drag_data_get)
        tree.connect('drag_data_received', self.on_drag_data_received)
        tree.connect('drag_motion', self.on_drag_motion)
        tree.connect('drag_drop', self.on_drag_drop)
        renderer = gtk.CellRendererText()
        for n,t in [[0,'Item'],[1,'Amount']]:
            col = gtk.TreeViewColumn(t,renderer,text=n)
            col.set_resizable(True)
            tree.append_column(col)
        tree.expand_all()
        tree.show()
        return tree

    def createIngModel (self, data):
        debug("createIngModel (self, data):",5)
        """Data is a list of lists, where each item is [ing amt]"""
        mod = gtk.TreeStore(gobject.TYPE_STRING, gobject.TYPE_STRING)
        for c,lst in data:
            catiter = mod.append(None)
            mod.set_value(catiter, 0, c)
            for i in lst:
                ing = i[0]
                amt = i[1]
                iter = mod.append(catiter)
                mod.set_value(iter, 0, ing)
                mod.set_value(iter, 1, amt)
        return mod

    # ---- TreeView callbacks...
    def slTree_sel_changed_cb (self, selection):
        """Callback handler for selection change on shopping treeview."""
        if selection.count_selected_rows()>0:
            self.shoppingActions.set_sensitive(True)
            # if we have items selected, the pantry tree should not
            # this makes these feel more like one control/list divided
            # into two sections.
	    self.tv = self.slTree
            self.pTree.get_selection().unselect_all()
        else:
            self.shoppingActions.set_sensitive(False)

    def pTree_sel_changed_cb (self, selection):
        """Callback handler for selection change on pantry treeview"""
        if selection.count_selected_rows()>0:
            self.pantryActions.set_sensitive(True)
            # if we have items selected, the shopping tree should not.
            # this makes these feel more like one control/list divided
            # into two sections.
	    self.tv = self.pTree
            self.slTree.get_selection().unselect_all()
        else:
            self.pantryActions.set_sensitive(False)

    # Popup menu setup
    def create_popups (self):
	self.shoppop = self.ui_manager.get_widget('/ShopPop')
	self.panpop = self.ui_manager.get_widget('/PanPop')

    # Drag-and-drop
    def on_drag_begin(self, tv, context):
        debug("on_drag_begin(self, tv, context):",5)
        self.tv=tv
        self.ssave=te.selectionSaver(self.slTree,1)
        self.pssave=te.selectionSaver(self.pTree,1)

    def on_drag_motion (self, tv, context, x, y, time):
        pass

    def on_drag_data_get (self, tv, context, selection, info, time):
        self.drag_selection=selection
        
    def on_drag_data_received(self, tv, context,x,y,selection,info,time):
        debug("on_drag_data_received(self, tv,context,x,y,selection,info,time):",5)
        if str(selection.target) == 'GOURMET_SHOPPER_SW':
            ## in this case, we're recategorizing
            #try:
            dest = tv.get_dest_row_at_pos(x,y)
            if dest:
                path,drop_where = dest
                iter=tv.get_model().get_iter((path[0])) #grab the category (outside of tree)
                cat=tv.get_model().get_value(iter,0)
                for sel,iter in self.get_selected_ingredients(return_iters=True):
                    path=tv.get_model().get_path(iter)
                    if len(path) == 1:
                        # if we're moving an entire category, then we
                        # need to reorder categories.
                        debug("Saving new category orders",0)
                        self.commit_category_orders(tv)
                        # and now we need to move our new category into place...
                        if drop_where==gtk.TREE_VIEW_DROP_AFTER or drop_where==gtk.TREE_VIEW_DROP_INTO_OR_AFTER:
                            new_pos=self.sh.catorder_dic[cat]+0.5
                        else:
                            new_pos=self.sh.catorder_dic[cat]-0.5
                        self.sh.catorder_dic[sel] = new_pos
                        debug("%s moved to position %s"%(sel,self.sh.catorder_dic[sel]),0)
                        debug("The current order is: %s"%self.sh.catorder_dic)
                    else:
                        self.sh.orgdic[sel]=cat
                self.resetSL()
                self.ssave.restore_selections(tv=self.slTree)
                self.pssave.restore_selections(tv=self.pTree)        
            #except TypeError:
            else:
                debug("Out of range!",0)
        elif str(selection.target) == 'GOURMET_SHOPPER':
            ## in this case, we're moving
            if tv == self.pTree:
                self.add_selection_to_pantry()
            else:
                self.rem_selection_from_pantry()
        
    def on_drag_drop (self, tv, context, x, y, time):
        debug("on_drag_drop (self, tv, context, x, y, time):",5)        
        #model = tv.get_model()
        otv,oselection=self.dragged
        if otv==self.pTree and tv==self.slTree:
            self.rem_selection_from_pantry()
        elif otv==self.slTree and tv==self.pTree:
            self.add_selection_to_pantry()
        else:
            try:
                path,drop_where = tv.get_dest_row_at_pos(x,y)
                iter=tv.get_model().get_iter((path[0])) #grab the category (outside of tree)
                cat=tv.get_model().get_value(iter,0)
                for sel in oselection:
                    self.sh.orgdic[sel]=cat
                self.resetSL()
            except TypeError, e:
                self.message("Out of range! %s")
        return False
    # end drag-n-drop methods

    # ---- end TreeView callbacks
    
    # -- End TreeView and TreeModel setup

    # Callbacks for moving data back and forth
    def resetSL (self):
        debug("resetSL (self):",5)
	if not hasattr(self,'cats_setup') or not self.cats_setup:
	    self.setup_category_ui()
        self.data,self.pantry = self.organize_list(self.lst)
        self.slMod = self.createIngModel(self.data)
        self.pMod = self.createIngModel(self.pantry)
        self.slTree.set_model(self.slMod)
        self.pTree.set_model(self.pMod)
        #self.rectree.set_model(self.create_rmodel())
        self.slTree.expand_all()
        self.pTree.expand_all()
        #self.pTree_sel_changed_cb(self.pTree.get_selection())
        #self.slTree_sel_changed_cb(self.slTree.get_selection())

    def add_selection_to_pantry (self, *args):
        """Add selected items to pantry."""
        debug("add_selection_to_pantry (self, *args):",5)
        self.tv = self.slTree
        self.ssave=te.selectionSaver(self.slTree,1)
        self.pssave=te.selectionSaver(self.pTree,1)
        kk = self.get_selected_ingredients()
        for k in kk:
            self.sh.add_to_pantry(k)
        self.resetSL()
        self.ssave.restore_selections(tv=self.pTree)
        
    def rem_selection_from_pantry (self, *args):
        """Add selected items to shopping list."""
        debug("rem_selection_from_pantry (self, *args):",5)
        self.tv = self.pTree
        self.ssave=te.selectionSaver(self.slTree,1)
        self.pssave=te.selectionSaver(self.pTree,1)
        for k in self.get_selected_ingredients():
            self.sh.remove_from_pantry(k)
        self.resetSL()
        self.pssave.restore_selections(tv=self.slTree)

    def change_to_category (self, category):
	'''Change selected recipes to category category'''
	do_reset = category not in self.sh.get_orgcats()
	kk=self.get_selected_ingredients()
	for k in kk:
	    self.sh.orgdic[k]=category
	ssave=te.selectionSaver(self.slTree,1)
	pssave=te.selectionSaver(self.pTree,1)
	self.resetSL()
	ssave.restore_selections(tv=self.slTree)
	pssave.restore_selections(tv=self.slTree)
	if do_reset:
	    self.reset_categories()

    def reset_categories (self):
	self.ui_manager.remove_ui(self.last_category_merge)
	self.get_catmodel().clear()
	self.setup_category_ui()
	self.create_popups()

    def add_sel_to_newcat (self, menuitem, *args):
        debug("add_sel_to_newcat (self, menuitem, *args):",5)
        kk=self.get_selected_ingredients()
        sublab = ', '.join(kk)
        cat = de.getEntry(label=_('Enter Category'),
                          sublabel=_("Category to add %s to") %sublab,
                          entryLabel=_('Category:'),
                          parent=self.widget)
        if cat:
            for k in kk:
                self.sh.orgdic[k]=cat
            self.shoppop.get_children()[-1].hide()
            self.panpop.get_children()[-1].hide()
            self.setup_popup()
            ssave=te.selectionSaver(self.slTree,1)
            pssave=te.selectionSaver(self.pTree,1)
            self.resetSL()
            ssave.restore_selections(tv=self.slTree)
            pssave.restore_selections(tv=self.slTree)        
    
    # Popup methods...
    def popup_ing_menu (self, tv, event=None, *args):
        debug("popup_ing_menu (self, tv, *args):",5)
        self.tv = tv
        if not event:
            event = gtk.get_current_event()
        t = (event and hasattr(event,'time') and getattr(event,'time')
                or 0)
        btn = (event and hasattr(event,'button') and getattr(event,'button')
               or 0)
        self.shoppop.popup(None,None,None,btn,t)
        return True

    def popup_pan_menu (self, tv, event=None, *args):
        debug("popup_pan_menu (self, tv, *args):",5)
        self.tv = tv
        if not event:
            event = gtk.get_current_event()
        t = (event and hasattr(event,'time') and getattr(event,'time')
                or 0)
        btn = (event and hasattr(event,'button') and getattr(event,'button')
               or 0)
        self.panpop.popup(None,None,None,btn,t)
        return True

    # Data convenience methods
    def get_selected_ingredients (self,return_iters=False):
        """A way to find out what's selected. By default, we simply return
        the list of ingredient keys. If return_iters is True, we return the selected
        iters themselves as well (returning a list of [key,iter]s)"""
        debug("get_selected_ingredients (self):",5)
        def foreach(model,path,iter,selected):
            debug("foreach(model,path,iter,selected):",5)
            selected.append(iter)
        selected=[]
        self.tv.get_selection().selected_foreach(foreach,selected)
        debug("multiple selections = %s"%selected,3)
        #ts,itera=self.tv.get_selection().get_selected()
        selected_keys=[]
        for itera in selected:
            key=self.tv.get_model().get_value(itera, 0)
            if return_iters:
                selected_keys.append((key,itera))
            else:
                selected_keys.append(key)
        debug("get_selected_ingredients returns: %s"%selected_keys,3)
        return selected_keys

class ShopGui (ShoppingList, plugin_loader.Pluggable, IngredientAndPantryList):

    def __init__ (self):
	IngredientAndPantryList.__init__(self)
        ShoppingList.__init__(self)
	self.prefs = prefs.get_prefs()
	self.conf = []	
        self.w = gtk.Window(); self.main = gtk.VBox()
	self.w.set_title(_('Shopping List'))
	self.w.set_default_size(800,600)
        self.w.connect('delete-event',self.hide)
	from GourmetRecipeManager import get_application
        self.setup_ui_manager()
        self.setup_actions()
        self.setup_main()
	self.conf.append(WidgetSaver.WindowSaver(self.w,
						 self.prefs.get('shopGuiWin',{}),
						 show=False)
			 )
	self.conf.append(
	    WidgetSaver.WidgetSaver(self.vp,
				    self.prefs.get('shopvpaned1',{'position':self.vp.get_position()})
				    )
	    )
	self.conf.append(
	    WidgetSaver.WidgetSaver(self.hp,
				    self.prefs.get('shophpaned1',{'position':self.hp.get_position()})
				    )
	    )
	plugin_loader.Pluggable.__init__(self,
					 [plugin.ShoppingListPlugin])
        self.sh = self.get_shopper([])
        self.setup_category_ui()
	self.create_popups()

    def get_shopper (self, lst):
        return recipeManager.DatabaseShopper(lst, self.rd)

    # Create interface...
    
    def setup_ui_manager (self):
        self.ui_manager = gtk.UIManager()
        self.ui_manager.add_ui_from_string(ui_string)

    def setup_main (self):
        mb = self.ui_manager.get_widget('/ShoppingListMenuBar')
        self.main.pack_start(mb,fill=False,expand=False)
        ttb = self.ui_manager.get_widget('/ShoppingListTopToolBar')
        self.main.pack_start(ttb,fill=False,expand=False)
        self.vp = gtk.VPaned(); self.vp.show(); self.vp.set_position(150)
	self.create_rtree()
        self.top_frame = setup_frame_w_accel_label(_('_Recipes'),self.rectree)
	self.top_frame.add(setup_sw(self.rectree)); self.top_frame.show()
        self.vp.add1(self.top_frame)
        vb = gtk.VBox(); vb.show()
        self.vp.add2(vb)
        slatb = self.ui_manager.get_widget('/ShoppingListActionToolBar'); slatb.show()
        vb.pack_start(slatb,expand=False,fill=False)
	self.setup_add_box()
	vb.pack_start(self.add_box,expand=False,fill=False)
	self.setup_cat_box()
	vb.pack_start(self.cat_box,expand=False,fill=False)
	self.hp = self.setup_paned_view(); self.hp.show()
	vb.pack_start(self.hp)
	self.main.pack_start(self.vp); self.vp.show()
	vb.show()
	self.w.add(self.main)
	self.main.show()
	self.w.add_accel_group(self.ui_manager.get_accel_group())

    def setup_add_box (self):
	# Setup add-ingredient widget
	self.add_box = gtk.HBox()
	self.add_entry = gtk.Entry()
	add_label = gtk.Label(_('_Add items:')); add_label.set_use_underline(True)
	add_label.set_mnemonic_widget(self.add_entry)
	self.add_box.pack_start(add_label,expand=False,fill=False); add_label.show()	
	self.add_box.pack_start(self.add_entry); self.add_entry.show()
	self.add_button = gtk.Button(stock=gtk.STOCK_ADD)
	self.add_box.pack_start(self.add_button,expand=False,fill=False); self.add_button.show()
	self.add_entry.connect('activate',self.item_added)
	self.add_button.connect('clicked',self.item_added)

    def get_catmodel (self):
	if hasattr(self,'catmodel'): return self.catmodel
	else:
	    self.catmodel = gtk.ListStore(str)
	    return self.catmodel

    def setup_cat_box (self):
	# Setup change-category widget
	self.cat_box = gtk.HBox(); #self.cat_box.set_spacing(6)
	self.cat_cbe = gtk.ComboBoxEntry()
	self.cat_cbe.set_model(self.get_catmodel())
	self.cat_cbe.set_text_column(0)
	self.cat_entry = self.cat_cbe.child	
	self.cat_button = gtk.Button(stock=gtk.STOCK_APPLY)
	self.cat_label = gtk.Label('_Category: '); self.cat_label.set_use_underline(True)
	self.cat_label.set_mnemonic_widget(self.cat_entry)
	comp = gtk.EntryCompletion()
	comp.set_model(self.get_catmodel()); comp.set_text_column(0)
	self.cat_entry.set_completion(comp)
	self.cat_box.pack_start(self.cat_label,expand=False,fill=False); self.cat_label.show()
	self.cat_box.pack_start(self.cat_cbe); self.cat_cbe.show()	
	self.cat_box.pack_start(self.cat_button,expand=False,fill=False); self.cat_button.show()
	self.cat_entry.connect('activate',self.category_changed)
	self.cat_button.connect('clicked',self.category_changed)
        
    def setup_actions (self):
        self.mainActionGroup = gtk.ActionGroup('MainActions')
        self.recipeListActions = gtk.ActionGroup('RecipeListActions')
	self.recipeListActions.add_actions([
	    ('RemoveRecipes',gtk.STOCK_REMOVE,_('Remove Recipes'),
	     '<Control>Delete',_('Remove recipes from shopping list'),
	     self.clear_recipes,
	    )])
        self.mainActionGroup.add_actions([
	    ('Edit',None,_('_Edit')),
            ('Save',# name
             gtk.STOCK_SAVE,# stock
             None, # text
             None, # key-command
             None, # tooltip
             self.save# callback
             ),
            ('Print'   ,# name
             gtk.STOCK_PRINT,# stock
             None, # text
             '<Ctrl>P', # key-command
             None, # tooltip
             self.printList # callback
             ),
            ('Close'   ,# name
             gtk.STOCK_CLOSE,# stock
             None, # text
             None, # key-command
             None, # tooltip
             self.hide# callback
             ),
            ('File',None,_('_File')),
            ('Help',gtk.STOCK_HELP,_('_Help'),None,None,
             lambda *args: de.show_faq(os.path.join(doc_base,'FAQ'),jump_to='Shopping')),
            ('HelpMenu',None,_('_Help')),
		])
	self.mainActionGroup.add_toggle_actions([
		('AddNewItems',
		 gtk.STOCK_ADD,
		 _('Add items'),
		 '<Ctrl>plus',
		 _('Add arbitrary items to shopping list'),
		 self.add_item
		 ),
		#(   ,# name
                #    ,# stock
                #    , # text
                #    , # key-command
                #    , # tooltip
                #     # callback
                #    ),
                ])

        fix_action_group_importance(self.mainActionGroup)
	self.ui_manager.insert_action_group(self.mainActionGroup,0)
        fix_action_group_importance(self.recipeListActions)
	self.ui_manager.insert_action_group(self.recipeListActions,0)
	IngredientAndPantryList.setup_actions(self)

    def getOptionalIngDic (self, ivw, mult, prefs):
        """Return a dictionary of optional ingredients with a TRUE|FALSE value

        Alternatively, we return a boolean value, in which case that is
        the value for all ingredients.
        
        The dictionary will tell us which ingredients to add to our shopping list.
        We look at prefs to see if 'shop_always_add_optional' is set, in which case
        we don't ask our user."""    
        debug("getOptionalIngDic (ivw):",5)
        #vw = ivw.select(optional=True)
        vw = filter(lambda r: r.optional==True, ivw)
        # optional_mode: 0==ask, 1==add, -1==dont add
        optional_mode=prefs.get('shop_handle_optional',0)
        if optional_mode:
            if optional_mode==1:
                return True
            elif optional_mode==-1:
                return False
        elif len(vw) > 0:
            if not None in [i.shopoptional for i in vw]:
                # in this case, we have a simple job -- load our saved
                # defaults
                dic = {}
                for i in vw:
                    if i.shopoptional==2: dic[i.ingkey]=True
                    else: dic[i.ingkey]=False
                return dic
            # otherwise, we ask our user
            oid=OptionalIngDialog(vw, prefs, mult)
            retval = oid.run()
            if retval:
                return retval
            else:
                raise de.UserCancelError("Option Dialog cancelled!")

    # -- TreeView and TreeModel setup
    def create_rtree (self):
        debug("create_rtree (self):",5)
        self.rmodel = self.create_rmodel()
        self.rectree = gtk.TreeView(self.rmodel)
        #self.glade.signal_connect('ingmen_pantry',self.add_selection_to_pantry)
        #self.glade.signal_connect('panmen_remove',self.rem_selection_from_pantry)        
        self.rectree.set_model(self.rmodel)
        renderer = gtk.CellRendererText()
        #renderer.set_property('editable',True)
        #renderer.connect('edited',tst)
        titl = gtk.TreeViewColumn(_("Title"),renderer,text=1)
        mult = gtk.TreeViewColumn(_("x"),renderer,text=2)
        self.rectree.append_column(titl)
        self.rectree.append_column(mult)
        titl.set_resizable(True)
        titl.set_clickable(True)
        titl.set_reorderable(True)
        mult.set_resizable(True)
        mult.set_clickable(True)
        mult.set_reorderable(True)
        self.rectree.get_selection().set_mode(gtk.SELECTION_MULTIPLE)
	self.rectree.connect('row-activated',self.rectree_activated_cb)	
        self.rectree.show()

    def create_rmodel (self):
        debug("create_rmodel (self):",5)
        mod = gtk.TreeStore(gobject.TYPE_PYOBJECT, gobject.TYPE_STRING, gobject.TYPE_STRING)
        for r,mult in self.recs.values():
            iter = mod.append(None)
            mod.set_value(iter,0,r)
            mod.set_value(iter,1,r.title)
            mod.set_value(iter,2,convert.float_to_frac(mult))
        return mod

    def rectree_activated_cb (self, tv, path, vc):
	rec = tv.get_model()[path][0]
	from GourmetRecipeManager import get_application
	get_application().open_rec_card(rec)

    # End UI Set-up

    # Convenience methods for handling our data
    def getSelectedRecs (self):
        """Return each recipe in list"""
        def foreach(model,path,iter,recs):
            debug("foreach(model,path,iter,recs):",5)
            try:
                rec=model.get_value(iter,0)
                recs.append(rec)
            except:
                debug("DEBUG: There was a problem with iter: %s path: %s"%(iter,path),1)
        recs=[]
        self.rectree.get_selection().selected_foreach(foreach,recs)
        debug("%s selected recs: %s"%(len(recs),recs),3)
        return recs

    def commit_category_orders (self, tv, space_before=None, space_after=None):
        """Commit the order of categories to memory.
        We allow for making room before or after a given
        iter, in which case"""
	mod = tv.get_model()
	iter = mod.get_iter_first()
	last_val = -100
	while iter:
	    cat = mod.get_value(iter,0)
	    if self.sh.catorder_dic.has_key(cat):
		val = self.sh.catorder_dic[cat]
	    else:
		val = 0
	    if val <= last_val:
		val = last_val + 10
		self.sh.catorder_dic[cat] = val
	    last_val = val
	    iter = mod.iter_next(iter)

    def reset (self):
	self.grabIngsFromRecs(self.recs.values(),self.extras)
        self.resetSL()
	self.rectree.set_model(self.create_rmodel())

    # Callbacks
    def hide (self, *args):
	self.w.hide()
        return True
        
    def show (self, *args):
	self.w.present()

    def clear_recipes (self, *args):
        debug("clear_recipes (self, *args):",5)
        selectedRecs=self.getSelectedRecs()
        if selectedRecs:
            for t in selectedRecs:
                self.recs.__delitem__(t.id)
                debug("clear removed %s"%t,3)
            self.reset()
        elif de.getBoolean(label=_("No recipes selected. Do you want to clear the entire list?")):
            self.recs = {}
            self.extras = []
            self.reset()            
        else:
            debug("clear cancelled",2)
	
    
    def save (self, *args):
        debug("save (self, *args):",5)
        self.doSave(de.select_file(_("Save Shopping List As..."),
                                   filename=os.path.join(os.path.expanduser("~"),
                                                         "%s %s"%(_('Shopping List'),
                                                                  time.strftime("%x").replace("/","-"),
                                                                  )),
                                   action=gtk.FILE_CHOOSER_ACTION_SAVE,
                                   ))

    def printList (self, *args):
        debug("printList (self, *args):",0)
        self._printList(get_print_manager().get_simple_writer(),dialog_parent=self.w)

    def add_item (self, toggleWidget):
	if toggleWidget.get_active():
	    self.add_box.show()
	    self.add_entry.grab_focus()
	    if self.pantryOrShoppingActions.get_action('ChangeCategory').get_active():
		self.pantryOrShoppingActions.get_action('ChangeCategory').set_active(False)
	else:
	    self.add_box.hide()

    def change_category (self, toggleWidget):
	if toggleWidget.get_active():
	    self.cat_box.show()
	    self.cat_entry.grab_focus()
	    if self.mainActionGroup.get_action('AddNewItems').get_active():
		self.mainActionGroup.get_action('AddNewItems').set_active(False)
	else:
	    self.cat_box.hide()

    def item_added (self, *args):
	txt = self.add_entry.get_text()
	dct = self.rd.parse_ingredient(txt)
	if not dct: dct = {'amount':None,'unit':None,'item':txt}
	self.extras.append([dct.get('amount'),dct.get('unit'),dct.get('item')])
        # Make sure it doesn't end up in the pantry...        
        self.sh.remove_from_pantry(dct.get('item')) 
	self.grabIngsFromRecs(self.recs.values(),self.extras)
	self.resetSL()
	self.add_entry.set_text('')

    def category_changed (self, *args):
	cat = self.cat_entry.get_text()
	self.change_to_category(cat)
	self.cat_entry.set_text('')
    
class OptionalIngDialog (de.ModalDialog):
    """A dialog to query the user about whether to use optional ingredients."""
    def __init__ (self,vw,prefs,mult=1,default=False):
        debug("__init__ (self,vw,default=False):",5)
	self.rd = recipeManager.get_recipe_manager()
        de.ModalDialog.__init__(
            self, default,
            label=_("Select optional ingredients"),
            sublabel=_("Please specify which of the following optional ingredients you'd like to include on your shopping list."))
        self.mult = mult
        self.vw=vw
        self.ret = {}
        self.create_tree()
        self.cb = gtk.CheckButton("Always use these settings")
        self.cb.set_active(prefs.get('remember_optionals_by_default',False))
        alignment = gtk.Alignment()
        alignment.set_property('xalign',1.0)
        alignment.add(self.cb)
        self.vbox.add(alignment)
        alignment.show()
        self.cb.show()

        
    def create_model (self):
        """Create the TreeModel to show optional ingredients."""
        debug("create_model (self):",5)
        self.mod = gtk.TreeStore(gobject.TYPE_PYOBJECT, #the ingredient obj
                                 gobject.TYPE_STRING, #amount
                                 gobject.TYPE_STRING, #unit
                                 gobject.TYPE_STRING, #item
                                 gobject.TYPE_BOOLEAN) #include
        for i in self.vw:
            iter=self.mod.append(None)
            self.mod.set_value(iter,0,i)
            if self.mult==1:
                self.mod.set_value(iter,1,
                                   self.rd.get_amount_as_string(i)
                                   )
            else:
                self.mod.set_value(iter,1,
                                   self.rd.get_amount_as_string(i,float(self.mult))
                                   )
            self.mod.set_value(iter,2,i.unit)
            self.mod.set_value(iter,3,i.item)
            self.mod.set_value(iter,4,self.default)
            self.ret[i.ingkey]=self.default

    def create_tree (self):
        """Create our TreeView and populate it with columns."""
        debug("create_tree (self):",5)
        self.create_model()
        self.tree = gtk.TreeView(self.mod)
        txtr = gtk.CellRendererText()
        togr = gtk.CellRendererToggle()
        togr.set_property('activatable',True)
        togr.connect('toggled',self.toggle_ing_cb)
        #togr.start_editing()
        for n,t in [[1,'Amount'],[2,'Unit'],[3,'Item']]:
            col = gtk.TreeViewColumn(t,txtr,text=n)
            col.set_resizable(True)
            self.tree.append_column(col)
        bcol = gtk.TreeViewColumn('Add to Shopping List',
                                  togr, active=4)
        self.tree.append_column(bcol)
        self.vbox.add(self.tree)
        self.tree.show()

    def toggle_ing_cb (self, cellrenderertoggle, path, *args):
        debug("toggle_ing_cb (self, cellrenderertoggle, path, *args):",5)
        crt=cellrenderertoggle
        iter=self.mod.get_iter(path)
        val = self.mod.get_value(iter,4)
        newval = not val
        self.ret[self.mod.get_value(iter,0).ingkey]=newval
        self.mod.set_value(iter,4,newval)

    def run (self):
        self.show()
        if self.modal: gtk.main()
        if self.cb.get_active() and self.ret:
            # if we are saving our settings permanently...
            # we add ourselves to the shopoptional attribute
            for row in self.mod:
                ing = row[0]
                ing_include = row[4]
                if ing_include: self.rd.modify_ing(ing,{'shopoptional':2})
                else: self.rd.modify_ing(ing,{'shopoptional':1})
        return self.ret


if __name__ == '__main__':
    class TestIngredientAndPantryList (IngredientAndPantryList):

	def __init__ (self):
	    IngredientAndPantryList.__init__(self)
	    #self.data = [('Dairy',[('milk','1 gal'),('cheese, cheddar','1 lb'),
	    #('cottage cheese','8 oz'),
	    #('yogurt','8 oz')]),
	    #('Pastas',[('rotini','1 lb')]),]
	    #self.pantry = [('Dairy',[('eggs','1/2 doz')]),
	    #('Frozen',[('ice cream','1 gal')]),
	    #]
	    rm = recipeManager.get_recipe_manager()
	    recs = [(r,1) for r in rm.fetch_all(rm.recipe_table)[:2]]
	    self.data,self.pantry =  self.grabIngsFromRecs(recs)
	    self.w = gtk.Window(); self.w.set_title(_('Shopping List'))
	    self.w.add(self.setup_paned_view())
	    self.w.show_all()
	    self.w.connect('delete-event',gtk.main_quit)
    #tst = TestIngredientAndPantryList()
    sg = ShopGui()
    rm = recipeManager.get_recipe_manager()
    recs = [(r,1) for r in rm.fetch_all(rm.recipe_table)[:2]]
    for r,mult in recs:
	sg.addRec(r,mult)
    gtk.main()
	    


    #sg = ShopGui()
    #sg.show()
    sg.w.connect('delete-event',gtk.main_quit)
    gtk.main()

########NEW FILE########
__FILENAME__ = shopping
import convert, sys
from gettext import gettext as _
from gdebug import debug
import unittest, time

class Shopper:
    def __init__ (self, inglist):
        """We expect a list of tuples/lists, each of which contains
        amount, unit, key [[amt,un,key],[amt,un,key],...]

        amount can be either a single number or a tuple
        2,3, etc., in which case it is a range.
        """
        ## First, we create a dictionary from our list (keyed by ingredient)
        ## each value in the dict. is a list of values. We'll try to add these
        ## as best as we can.
        self.dic = {}        
        self.default_pantry=[_('flour, all purpose'),_('sugar'),_('salt'),
                             _('black pepper, ground'),
                             _('ice'), _('water'),
                             _('oil, vegetable'),
                             _('oil, olive')]
        self.init_pantry()
        self.mypantry = {}
        for a,u,k in inglist:
            if self.pantry.has_key(k) and self.pantry[k]:
                #print "%s is in pantry" %k
                dic=self.mypantry
            else:
                dic=self.dic
            try:
                a = float(a)
            except:
                if type(a) != tuple:
                    debug("Warning, can't make sense of amount %s; reading as None"%a,0)
                    a = None
            if dic.has_key(k):
                dic[k].append([a,u])
            else:
                dic[k]=[[a,u]]
        self.init_converter()
        for ing,amts in self.dic.items():
            self.dic[ing]=self.combine_ingredient(ing,amts)
        for ing,amts in self.mypantry.items():
            self.mypantry[ing]=self.combine_ingredient(ing,amts)        
        self.init_orgdic()
        self.init_ingorder_dic()
        self.init_catorder_dic()

    def init_converter (self):
        self.cnv = convert.get_converter()

    def combine_ingredient (self, ing, amts):
        """We take an ingredient and a list of amounts. We return a
        list of amounts (ideally shortened, if combinifying is
        possible)."""
        itms = []
        for a,u in amts:
            if not itms:
                ## if this is our first...
                itms.append([a,u])
            else:
                flag = 0
                ind = 0
                while not flag and len(itms) > ind:
                    amt,unit = itms[ind]
                    if type(amt) == tuple or type(a)== tuple :
                        # we're adding ranges -- we'll force both
                        # our amounts to look like ranges to simplify the addition
                        if type(amt) != tuple :
                            amt=(amt,amt) 
                        if type(a) != tuple :
                            a=(a,a)
                        #print 'amt:',amt,' unit:',unit,'a:',a,'u:',u
                        add_low = self.cnv.add_reasonably(amt[0],unit,a[0],u,ing)
                        add_high = self.cnv.add_reasonably(amt[1],unit,a[1],u,ing)
                        if (not add_low) or (not add_high):
                            add = False
                        else:
                            # Adjust units
                            add_low = self.cnv.adjust_unit(
                                *add_low, #lowest+lowest
                                **{'favor_current_unit':False}
                                )
                            add_high = self.cnv.adjust_unit(
                                *add_high, # highest+highest
                                **{'favor_current_unit':False}
                                )
                            if add_low:
                                add_low = self.cnv.adjust_unit(*add_low,**{'favor_current_unit':False})
                            if add_high:
                                add_high = self.cnv.adjust_unit(*add_high,**{'favor_current_unit':False})
                            if add_low[1]==add_high[1]: #same unit...
                                add=((add_low[0],add_high[0]),add_low[1])
                            else:
                                # otherwise, let's use our unit for add_high...
                                u1_to_u2=self.cnv.converter(add_low[1],add_high[1])
                                add=( (add_low[0]*u1_to_u2,add_high[0]), #amount tuple
                                      add_high[1] #unit from add_high
                                      )
                    else:
                        add = self.cnv.add_reasonably(amt,unit,a,u,ing)
                        if add:
                            # adjust unit to make readable
                            add=self.cnv.adjust_unit(*add,**{'favor_current_unit':False})
                    # add_reasonably returns a nice a,u pair if successful
                    # Otherwise, it return False/None
                    if add: 
                        itms.pop(ind) # out with the old...
                        itms.append(add) # in with the new
                        flag = 1
                    else:
                        ind += 1
                if not flag:
                    itms.append([a,u])
        return itms

    def ing_to_string (self, ing, amts):
        return "%s %s" %(self.amt_to_string(amts),ing)

    def amt_to_string (self, amts):
        retstr = self.cnv.amt_string(amts[0])
        if len(amts) > 1:
            for a in amts[1:]:
                retstr = "%s + %s" %(self.cnv.amt_string(a), retstr)
        return retstr

    def pretty_print (self, out=sys.stdout):
        self.list_writer(
            write_category= lambda c: out.write("\n---\n%s\n---\n"%c),
            write_item = lambda a,i: out.write("%s %s\n"%(a,i))
            )

    def list_writer (self,
                      write_category,
                      write_item,):
        org = self.organize(self.dic)
        for c,d in org:
            if not c: c = _('Unknown')
            write_category(c.title())
            for i,a in d:
                write_item(a,i)

    def organize (self, dic=None):
        """We organize our ingredients into lists in the form.
           [Category, [[ingredient, amt],
                       [ingredient, amt]...
                      ]
           ]"""
        ## first we build a dictionary, since it gives us an
        ## easy way to sort by category
        cats = {}
        if not dic:
            pass
        for i,a in dic.items():
            if self.orgdic.has_key(i) and self.orgdic[i]:
                c = self.orgdic[i]
            else:
                c = _("Unknown")
            if cats.has_key(c):
                cats[c][i]=a
            else:
                cats[c]={i:a}
        ## next we turn our nested dictionaries into nested lists
        lst = []
        for c,d in cats.items():
            itms = []
            for i,amts in d.items():
                itms.append([i,self.amt_to_string(amts)])
            lst.append([c,itms])
        ## now that we have lists, we can sort them
        lst.sort(self._cat_compare)
        for l in lst:
            l[1].sort(self._ing_compare)
        return lst

    def _cat_compare (self,cata,catb):
        """Put two categories in order"""
        cata = cata[0]
        catb = catb[0]
        if not cata and not catb: return 0
        elif not cata: return 1
        elif not catb: return -1
        if self.catorder_dic.has_key(cata) and self.catorder_dic.has_key(catb):
            # if both categories have known positions, we use them to compare
            cata = self.catorder_dic[cata]
            catb = self.catorder_dic[catb]
        else:
            # otherwise, we just use > to sort alphabetically
            cata = cata.lower()
            catb = catb.lower()
        if cata > catb: return 1
        if cata == catb: return 0
        else: return -1

    def _ing_compare (self,inga,ingb):
        """Put two ingredients in order"""
        inga = inga[0]
        ingb = ingb[0]
        if False and self.ingorder_dic.has_key(inga) and self.ingorder_dic.has_key(ingb):
            # if both ings have known positions, we use them to compare
            inga = self.ingorder_dic[inga]
            ingb = self.ingorder_dic[ingb]
        else:
            # otherwise, we just use > to sort alphabetically
            inga = inga.lower()
            ingb = ingb.lower()
        if inga > ingb: return 1
        if inga == ingb: return 0
        else: return -1


    def get_porg_categories (self):
        """Return a list of categories used for sorting."""
        tmp = {}
        for v in self.orgdic.values():
            tmp[v]=1
        return tmp.keys()

    def add_org_itm (self, itm, cat):
        self.orgdic[itm]=cat
        #for k,v in self.orgdic.items():
            #print "%s:%s, "%(k,v)
            
    def add_to_pantry (self, key):
        self.pantry[key]=True

    def remove_from_pantry (self, key):
        self.pantry[key]=False
    
    def init_orgdic (self):
        """This allows those subclassing us to do something fancy... 
        as is, we just use a default dictionary."""
        self.default_orgdic = setup_default_orgdic()
        self.orgdic = self.default_orgdic

    def init_ingorder_dic (self):
        self.ingorder_dic = {}
    def init_catorder_dic (self):
        debug("Initializing empty catorder_dic",5)
        self.catorder_dic = {}

    def init_pantry (self):
        self.pantry={}
        for i in self.default_pantry:
            self.pantry[i]=True
            
    def get_orgcats (self):
        """Return a list of categories being used for our Shopper"""
        self.orgcats=[]
        for v in self.orgdic.values():
            if v and (v not in  self.orgcats):
                self.orgcats.append(v)
        self.orgcats.sort()
        return self.orgcats

def setup_default_orgdic ():
    from defaults.defaults import lang as defaults
    return defaults.shopdic

class ShoppingList:

    def __init__ (self):
        self.recs = {}; self.extras = []
	self.includes = {}
        self.data,self.pantry=self.grabIngsFromRecs([])
        import backends.db
        self.rd = backends.db.get_database()
        import prefs
        self.prefs = prefs.get_prefs()

    def get_shopper (self, lst):
        return Shopper(lst) 

    def grabIngsFromRecs (self, recs, start=[]):
        debug("grabIngsFromRecs (self, recs):",5)
        """Handed an array of (rec . mult)s, we combine their ingredients.
        recs may be IDs or objects."""
        self.lst = start[0:]
        for rec,mult in recs:
            self.lst.extend(self.grabIngFromRec(rec,mult=mult))
	return self.organize_list(self.lst)

    def organize_list (self, lst):
        self.sh = self.get_shopper(lst)
        data = self.sh.organize(self.sh.dic)
        pantry = self.sh.organize(self.sh.mypantry)
        debug("returning: data=%s pantry=%s"%(data,pantry),5)
        return data,pantry

    def grabIngFromRec (self, rec, mult=1):
        """Get an ingredient from a recipe and return a list with our amt,unit,key"""
        """We will need [[amt,un,key],[amt,un,key]]"""
        debug("grabIngFromRec (self, rec=%s, mult=%s):"%(rec,mult),5)
        # Grab all of our ingredients
	ings = self.rd.get_ings(rec)
        lst = []
        include_dic = self.includes.get(rec.id) or {}
        for i in ings:
            if hasattr(i,'refid'): refid=i.refid
            else: refid=None
            debug("adding ing %s, %s"%(i.item,refid),4)
            if i.optional:
                # handle boolean includes value which applies to ALL ingredients
                if not include_dic:
                    continue
                if type(include_dic) == dict :
                    # Then we have to look at the dictionary itself...
                    if ((not include_dic.has_key(i.ingkey))
                        or
                        not include_dic[i.ingkey]):
                        # we ignore our ingredient (don't add it)
                        continue
            if self.rd.get_amount(i):
                amount=self.rd.get_amount(i,mult=mult)                
            else: amount=None            
            if refid:
                ## a reference tells us to get another recipe
                ## entirely.  it has two parts: i.item (regular name),
                ## i.refid, i.refmult (amount we multiply recipe by)
                ## if we don't have the reference (i.refid), we just
                ## output the recipe name
                debug("Grabbing recipe as ingredient!",2)
                # disallow recursion
                subrec = self.rd.get_referenced_rec(i)
                if subrec.id == rec.id:
                    de.show_message(
                        label=_('Recipe calls for itself as an ingredient.'),
                        sublabel=_('Ingredient %s will be ignored.')%rec.title + _('Infinite recursion is not allowed in recipes!'))
                    continue
                if subrec:
                    # recipe refs need an amount. We'll
                    # assume if need be.
                    amt = self.rd.get_amount_as_float(i)
                    if not amt: amount=amt
                    refmult=mult*amt
                    if not include_dic.has_key(subrec.id):
                        d = self.getOptionalDic(self.rd.get_ings(subrec),
                                                refmult,
                                                self.prefs,
                                                )
                        include_dic[subrec.id]=d
                    nested_list=self.grabIngFromRec(subrec,
                                                    refmult)
                    lst.extend(nested_list)
                    continue
                else:
                    # it appears we don't have this recipe
                    debug("We don't have recipe %s"%i.item,0)
                    if not i.unit:
                        i.unit='recipe'
                    if not i.ingkey:
                        i.ingkey=i.item
            lst.append([amount,i.unit,i.ingkey])
        debug("grabIngFromRec returning %s"%lst,5)
        return lst

    def getOptionalDic (self, ivw, mult, prefs):
        """Return a dictionary of optional ingredients with a TRUE|FALSE value

        Alternatively, we return a boolean value, in which case that is
        the value for all ingredients.
        
        The dictionary will tell us which ingredients to add to our shopping list.
        We look at prefs to see if 'shop_always_add_optional' is set, in which case
        we don't ask our user."""    
        return True

    # Saving and printing
    def doSave (self, filename):
        debug("doSave (self, filename):",5)
        #import exporters.lprprinter
        #self._printList(exporters.lprprinter.SimpleWriter,file=filename,show_dialog=False)
        ofi = file(filename,'w')
        ofi.write(_("Shopping list for %s")%time.strftime("%x") + '\n\n')
        ofi.write(_("For the following recipes:"+'\n'))
        ofi.write('--------------------------------\n')
        for r,mult in self.recs.values():
            itm = "%s"%r.title
            if mult != 1:
                itm += _(" x%s")%mult
            ofi.write(itm+'\n')
        write_itm = lambda a,i: ofi.write("%s %s"%(a,i) + '\n')
        write_subh = lambda h: ofi.write('\n_%s_\n'%h)
        self.sh.list_writer(write_subh,write_itm)
        ofi.close()

    def _printList (self, printer, *args, **kwargs):
        w = printer(*args,**kwargs)
        w.write_header(_("Shopping list for %s")%time.strftime("%x"))
        w.write_subheader(_("For the following recipes:"))
        for r,mult in self.recs.values():
            itm = "%s"%r.title
            if mult != 1:
                itm += _(" x%s")%mult
            w.write_paragraph(itm)
        write_itm = lambda a,i: w.write_paragraph("%s %s"%(a,i))
        self.sh.list_writer(w.write_subheader,write_itm)
        w.close()

    # Setting up recipe...
    def addRec (self, rec, mult, includes={}):
        debug("addRec (self, rec, mult, includes={}):",5)
        """Add recipe to our list, assuming it's not already there.
        includes is a dictionary of optional items we want to include/exclude."""
        if rec.id in self.recs:
            _, mult_already = self.recs[rec.id]
            mult += mult_already
        self.recs[rec.id]=(rec,mult)
        self.includes[rec.id]=includes
        self.reset()

    def reset (self):
        self.grabIngsFromRecs(self.recs.values(),self.extras)
        

class ShopperTestCase (unittest.TestCase):
    def testAddition (self):
        sh = Shopper([('1','tsp.','pepper'),
                      ('1','tsp.','pepper')])
        assert(
            sh.dic['pepper'][0][0] == 2
            )

    def testUnitConversion (self):
        sh = Shopper([('1','tsp.','pepper'),
                      ('1','tsp.','pepper'),
                      ('1','tsp.','pepper'),])
        assert(
            sh.dic['pepper'][0][0] == 1
            )
        assert(
            sh.dic['pepper'][0][1] == 'tbs.'
            )

    def testRangeAddition (self):
        sh = Shopper([
            ((1,2),'c.','milk'),
            (1,'c.','milk')]
                     )
        assert(sh.dic['milk'][0][0]==(2,3))

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = sound
try:
    from sound_gst import Player
except ImportError:
    print 'No gst player'
    try:
        from sound_windows import Player
    except ImportError:
        print 'No windows player'
        import sys
        class Player:
            """Fallback player"""
            def play_file (self,path):
                print 'No player installed -- beeping instead'
                for n in range(5): sys.stdout.write('\a'); sys.stdout.flush()


########NEW FILE########
__FILENAME__ = sound_gst
import pygst
pygst.require("0.10")
import gst

class Player:
    def __init__ (self):
        self.player = gst.element_factory_make('playbin2','player')

    def play_file (self,path):
        self.player.set_state(gst.STATE_NULL)
        self.player.set_property('uri','file://'+path)
        self.player.set_state(gst.STATE_PLAYING)

    def stop_play (self,path):
        self.player.set_state(gst.STATE_NULL)

########NEW FILE########
__FILENAME__ = sound_windows
import winsound

class Player:
    def __init__ (self):
	pass

    def play_file (self,path):
        winsound.PlaySound(path,winsound.SND_FILENAME)

    def stop_play (self,path):
        pass

########NEW FILE########
__FILENAME__ = test
# Convenience for importing gourmet stuff from our local directory...
import sys, os, os.path, glob
if os.path.exists('foo'):
    os.remove('foo/gourmet')
    os.rmdir('foo')

os.mkdir('foo')
os.symlink(os.path.abspath('../lib'),'foo/gourmet')
sys.path = [os.path.abspath('foo')] + sys.path + [os.path.abspath('foo/gourmet')]
sys.argv.append('--data-directory=%s'%os.path.abspath('../../data/'))
sys.argv.append('--glade-directory=%s'%os.path.abspath('../../glade/'))
sys.argv.append('--image-directory=%s'%os.path.abspath('../../images/'))
base_path = os.path.split(__file__)[0]

def remove_sysargs ():
    sys.argv.remove('--data-directory=%s'%os.path.abspath('../../data/'))
    sys.argv.remove('--glade-directory=%s'%os.path.abspath('../../glade/'))
    sys.argv.remove('--image-directory=%s'%os.path.abspath('../../images/'))


def profile (f):
    import profile, tempfile,os.path
    import hotshot, hotshot.stats
    #profi = os.path.join(tempfile.tempdir,'GOURMET_PROFILE')
    prof = hotshot.Profile(os.path.join(tempfile.tempdir,'GOURMET_HOTSHOT_PROFILE'))
    prof.runcall(f)
    stats = hotshot.stats.load(os.path.join(tempfile.tempdir,'GOURMET_HOTSHOT_PROFILE'))
    stats.strip_dirs()
    stats.sort_stats('cumulative','calls').print_stats()
        

########NEW FILE########
__FILENAME__ = testExporters
import test
import os,os.path
DIR = os.path.abspath(os.path.join(os.path.split(__file__)[0],'reference_setup/'))
TEST_FILE_DIRECTORY = os.path.join(DIR,'recipes.db')
import gglobals

gglobals.gourmetdir = DIR
gglobals.dbargs['file'] = TEST_FILE_DIRECTORY

import recipeManager as rm
import time
import exporters

import tempfile
import traceback
import unittest
import re

OUTPUT_DIRECTORY = os.path.join(
    tempfile.tempdir,
    'export_tests')
OUTPUT_DIRECTORY = os.path.join(OUTPUT_DIRECTORY,
                                time.strftime('%d.%m.%y'))
if os.path.exists(OUTPUT_DIRECTORY):
    n = 1
    while os.path.exists(OUTPUT_DIRECTORY + '-' + str(n)): n+=1
    OUTPUT_DIRECTORY += '-%s'%n

if not os.path.exists(OUTPUT_DIRECTORY): os.makedirs(OUTPUT_DIRECTORY)

def confirm_strings_are_in_file (ss, fi):
    whole_file = file(fi,'r').read()
    for s in ss:
        try:
            assert(re.search(s,whole_file))
        except:
            raise AssertionError('Fail to find %s in exported file %s.'%(s,fi))

confirmation_tests = {
    # These are extra tests that should be run -- each method must
    # take the filename of the exported file as its argument and raise
    # an error if it fails

    # Gourmet File Format Test
    'Gourmet XML File':lambda f: confirm_strings_are_in_file([
    '''<ingref''',
    '''<link''',
    # Nested ingredients...
    '''<inggroup>\s*<groupname>\s*Dressing\s*</groupname>\s*<ingredient>\s*<amount>\s*1/2\s*</amount>\s*<unit>\s*tsp\.\s*</unit>\s*<item>\s*red pepper flakes\s*</item>\s*<key>\s*red pepper flakes\s*</key>\s*</ingredient>''',
    # Image
    '''<image format="jpeg">\s*<!\[CDATA\[/9j''',
    # Times
    '''<cooktime>\s*20 minutes''',
    '''<preptime>\s*1/2 hour''',
    '''<rating>\s*4/5 stars''',
    '''<servings>\s*4\s*''',
    '''<category>\s*Dessert''',
    '''<cuisine>\s*Asian/Chinese''',
    # Formatting
    re.escape('''&amp;lt;i&amp;gt;But this should be in italics'''),
    re.escape('''&amp;lt;b&amp;gt;And this should be in bold'''),
    ],
                                                  f),
    # End Gourmet File Format Test

    # MealMaster test
    'MealMaster file': lambda f: confirm_strings_are_in_file([
    # formatting
    re.escape('''*But this should be in italics*'''),
    '''AND THIS SHOULD BE IN BOLD''',
    'Title: Ranges', # title
    '1\s*recipe\s*Ranges', # recipe reference
    '-+DRESSING-+\s*1/2\s*t\s*red pepper flakes' # Ingredient group
    ],
                                                             f),
    # End MealMaster test

    # RTF Tests
    'RTF':lambda f: confirm_strings_are_in_file([
    # Formatting
    '\\i.*But this should be in italics',
    '\\b.*And this should be in bold',
    '1 recipe Ranges', #Recipe reference
    re.escape('\pict{\jpegblip'), #Image
    ],
                                                f),
    # End RTF Tests
    
    }


class ExportTest:

    #failures = []

    def run (self):
        for d in tests: self.run_test(d)

    def run_test (self, d):

        if d.has_key('filename'):
            d['filename']=os.path.join(OUTPUT_DIRECTORY,
                                       d['filename'])
            self.test_import(d['filename'])
        elif d.has_key('url'): self.test_web_import(d['url'])
        else: print 'WTF: no test contained in ',d
        if d.has_key('test'):
            self.do_test(d['test'])

    def do_test (self, test):
        recs = self.db.search(self.db.recipe_table,
                              'title',
                              test['title'],
                              exact=True,
                              use_regexp=False)
        rec = recs[0]
        ings = self.db.get_ings(rec)
        if test.get('all_ings_have_amounts',False):
            for i in ings:
                assert(i.amount)
        if test.get('all_ings_have_units',False):
            for i in ings:
                assert(i.unit)
                
    
    def setup_db (self):
        print 'rm.dbargs[file]=',rm.dbargs['file']
        self.db = rm.RecipeManager(**rm.dbargs)
        if self.db.fetch_len(self.db.recipe_table)==0:
            raise Exception("No recipes in database.")
        self.mult_export_args = {'rd':self.db,
                                 'rv':self.db.fetch_all(self.db.recipe_table),
                                 'conv':None,
                                 'prog':None,
                                 'extra_prefs':{}
                                 }

    def test_export (self, k):
        n = 1
        new_file = os.path.join(OUTPUT_DIRECTORY,
                                '.'.join([k,str(n)])
                                )
        while os.path.exists(new_file):
            n += 1
            new_file = os.path.join(OUTPUT_DIRECTORY,
                                    '.'.join([k,str(n)])
                                    )
        self.mult_export_args['file']=new_file
        print 'Testing export ',k,'to',new_file,self.mult_export_args
        exporters.exporter_dict[k]['mult_exporter'](self.mult_export_args.copy()).run()
        if confirmation_tests.has_key(k):
            print 'Running confirmation test on ',k
            confirmation_tests[k](new_file) # Test!
        print 'Done!'

    def test_all_exports (self):
        for k in exporters.exporter_dict: self.test_export(k)



def add_export_test_cases (name, bases, attrs):
    def make_method (k):
        def _ (self): self.et.test_export(k)
        return _
    for k in exporters.exporter_dict:
        method_name = 'test'+k.replace(' ','')
        attrs[method_name]= make_method(k)
    print "Our class has attrs:",attrs
    return type(name,bases,attrs)

et = None

class ExportTestCase (unittest.TestCase):

    __metaclass__ = add_export_test_cases # Makes us testFoo methods
                                          # for each type of Foo we
                                          # support

    def setUp (self):
        print 'setUp'
        global et
        if not et:
            print 'Initialize DB'
            et = self.et = ExportTest()
            self.et.setup_db()
        else:
            print 'Use previously initialized DB'
            self.et = et

    #def testAllExports (self):
    #    self.it.test_all_exports()

if __name__ == '__main__':
    #et=ExportTest()
    #et.setup_db()
    unittest.main()
    #pass

########NEW FILE########
__FILENAME__ = testImporters
import sys
from .. import recipeManager as rm
import time
import os,os.path,re
import tempfile
import traceback
import unittest
from ..importers.importManager import ImportManager, ImportFileList
from ..recipeManager import get_recipe_manager

TEST_FILE_DIRECTORY = os.path.join(os.path.dirname(__file__), 'recipe_files')

times = []
def time_me (f):
    def _ (*args, **kwargs):
        start = time.time()
        ret = f(*args,**kwargs)
        end = time.time()
        times.append(
            ((f.__name__,args,kwargs),end-start)
            )
        return ret
    return f

def old_time_me (f):
    def _ (*args,**kwargs):
        print 'Running',f.__name__,args,kwargs
        start = time.time()
        try:
            ret = f(*args,**kwargs)
        except:
            end = time.time()
            times.append((f.__name__,args,kwargs,start,end,end-start))
            print 'Failed after ',end-start,'seconds.'
            raise
        else:
            end = time.time()
            times.append((f.__name__,args,kwargs,start,end,end-start))
            print 'Finished in ',end-start,'seconds.'
            return ret
    return _

class ThreadlessImportManager (ImportManager):

    def get_app_and_prefs (self):
        self.prefs = {}

    def do_import (self, importer_plugin, method, *method_args):
        # No threading, for profiling purposes!
        try:
            importer = getattr(importer_plugin,method)(*method_args)
        except ImportFileList, ifl:
            # recurse with new filelist...
            self.import_filenames(ifl.filelist)
        else:
            if hasattr(importer,'pre_run'):
                importer.pre_run()
            importer.run()
            self.follow_up(None,importer)

def get_im ():
    try:
        return ThreadlessImportManager()
    except ThreadlessImportManager,im:
        return im

class ImportTest:

    #failures = []
    __count = 1

    def run (self, tests):
        for d in tests: self.run_test(d)

    def run_test (self, d):
        if d.has_key('filename'):
            d['filename']=os.path.join(TEST_FILE_DIRECTORY,
                                       d['filename'])
            self.test_import(d['filename'])
        elif d.has_key('url'):
            self.test_web_import(d['url'])
        else:
            print 'WTF: no test contained in ',d
        if d.has_key('test'):
            self.do_test(d['test'])

    def do_test (self, test):
        recs = self.db.search_recipes(
            [
                {'column':'deleted',
                 'search':False,
                 'operator':'='},
                {'column':'title',
                 'search':test['title'],
                 'operator':'=',
                 }
             ]
            )
        if not recs:
            raise AssertionError(
                'No recipe found with title "%s".'%test['title']
                )
        rec = recs[0]
        ings = self.db.get_ings(rec)
        if test.get('all_ings_have_amounts',False):
            for i in ings:
                try:
                    assert(i.amount)
                except:
                    print i,i.amount,i.unit,i.item,'has no amount!'
                    raise
        if test.get('all_ings_have_units',False):
            for i in ings:
                try:
                    assert(i.unit)
                except:
                    print i,i.amount,i.unit,i.item,'has no unit'
                    raise
        for blobby_attribute in ['instructions','modifications']:
            if test.get(blobby_attribute,False):
                match_text = test[blobby_attribute]
                match_text = re.sub('\s+','\s+',match_text)
                try:
                    assert(re.match(match_text,getattr(rec,blobby_attribute)))
                except:
                    raise AssertionError('%s == %s != %s'%(blobby_attribute,
                                                           getattr(rec,blobby_attribute),
                                                           match_text)
                                         )
        for non_blobby_attribute in ['source','cuisine','preptime','cooktime']:
            if test.get(non_blobby_attribute,None) is not None:
                try: assert(getattr(rec,non_blobby_attribute)==test[non_blobby_attribute])
                except:
                    raise AssertionError('%s == %s != %s'%(non_blobby_attribute,
                                                           getattr(rec,non_blobby_attribute),
                                                           test[non_blobby_attribute])
                                         )
        if test.get('categories',None):
            cats = self.db.get_cats(rec)
            for c in test.get('categories'):
                try:
                    assert(c in cats)
                except:
                    raise AssertionError("Found no category %s, only %s"%(c,cats))
                cats.remove(c)
            try:
                assert(not cats)
            except:
                raise AssertionError('Categories include %s not specified in %s'%(cats,test['categories']))
        print 'Passed test:',test
    
    @time_me
    def setup_db (self):
        self.im = get_im()
        self.db = get_recipe_manager(custom_url='sqlite:///:memory:')
        
    @time_me
    def test_import (self,filename):
        self.im.import_filenames([filename])

    @time_me
    def test_web_import (self, url):
        self.im.import_url(url)

    def progress (self, bar, msg):
        pass
        #print int(10 * bar) * '|'
        #if bar == 1: print msg
        

class ImportTestCase (unittest.TestCase):

    def setUp (self):
        print 'setUp'
        self.it = ImportTest()
        self.it.setup_db()

    def tearDown (self):
        print 'tearDown'
        from gourmet.plugins.import_export.gxml_plugin.gxml2_exporter import recipe_table_to_xml as gxml_exporter
        n = 1
        while os.path.exists('/tmp/gourmet_import_test_%s.grmt'%n): n+=1
        print 'Saving export of imported files to /tmp/gourmet_import_test_%s.grmt'%n
        ge=gxml_exporter(self.it.db,self.it.db.fetch_all(self.it.db.recipe_table,deleted=False),'/tmp/gourmet_import_test_%s.grmt'%n)
        ge.run()
        # Trash all our recipes so they don't contaminate the next test...
        self.it.db.recipe_table.update().execute({'deleted':True}) #; self.it.db.db.commit()

#    def testArchive (self):
#        self.it.run_test({
#                'filename' : 'mealmaster_recs.zip',
#                'test' : {'title':'Almond Mushroom Pate'},
#                }
#                         )
#        self.it.run_test({
#                'filename' : 'recipes.tar.bz2',
#                }
#                         )

    def testMastercookXML (self):
        self.it.run_test({'filename':'athenos1.mx2',
                          'test':{'title':'5 Layer Mediterranean Dip',
                                  'all_ings_have_amounts':True,
                                  'all_ings_have_units':True,
                                  }
                          })

    def testMealmaster (self):
        self.it.run_test({'filename':'mealmaster.mmf',
                          'test':{'title':'Almond Mushroom Pate',
                                  'categories':['Appetizers'],
                                  'servings':6,
                                  }
                          }) # mealmaster

    def testKrecipes (self):
        self.it.run_test({'filename':'sample.kreml',
                          'test':{
            'title':'Recipe title',
            'source':'Unai Garro, Jason Kivlighn',
            'categories':['Ethnic','Cakes'],
            'servings':5,
            'preptime':90*60,
            'instructions':'Write the recipe instructions here'
            }
                          }
                         ) #krecipes

    # AllRecipes import is broken as of 1/2/07
    #def testAllRecipes (self):
    #    self.it.run_test({'url':'http://allrecipes.com/recipe/asian-beef-with-snow-peas/',
    #
    #                 'test':{'title':'Asian Beef with Snow Peas',
    #                         'all_ings_have_amounts':True,
    #                         'all_ings_have_units':True,
    #                         'source':'Holly (beef.allrecipes.com)',
    #                         'instructions':'''Stir-fried beef with snow peas in a light gingery sauce.
    # In a small bowl, combine the soy sauce, rice wine, brown sugar and cornstarch. Set aside.
    # Heat oil in a wok or skillet over medium high heat. Stir-fry ginger and garlic for 30 seconds. Add the steak and stir-fry for 2 minutes or until evenly browned. Add the snow peas and stir-fry for an additional 3 minutes. Add the soy sauce mixture, bring to a boil, stirring constantly. Lower heat and simmer until the sauce is thick and smooth. Serve immediately.
    #Retrieved from http://beef.allrecipes.com/az/AsianBeefWithSnowPeas.asp.''',
    #}
    #                          })#allrecipes.com

    #def testEpicurious (self):
    #     self.it.run_test(
    #       {'url':'http://www.epicurious.com/recipes/recipe_views/views/106711'}
    #        ) #eatingwell

    #def testFoodNetwork (self):
    #     self.it.run_test(
    #        {'url':'http://www.foodnetwork.com/food/recipes/recipe/0,1977,FOOD_9936_31916,00.html'}
    #       )


if __name__ == '__main__':
    unittest.main()
    

########NEW FILE########
__FILENAME__ = testRecCard
import test # get ../lib/ in path
import gglobals
import time, gtk
gglobals.gourmetdir = '/tmp/'
gglobals.dbargs['file'] = '/tmp/recipes.db'

VERBOSE = True

import GourmetRecipeManager
from reccard import add_with_undo

def assert_with_message (callable,
                         description):
    try:
        assert(callable())
    except AssertionError:
        print 'FAILED:',description
        raise
    else:
        if VERBOSE:
            print 'SUCCEEDED:',description

def add_save_and_check (rc, lines_groups_and_dc):
    added = []
    for l,g,dc in lines_groups_and_dc:
        # add_with_undo is what's called by any of the ways a user can add an ingredient.
        add_with_undo(
            rc,
            lambda *args: added.append(rc.add_ingredient_from_line(l,group_iter=g))
            )
    #print 'add_save_and_check UNDO HISTORY:',rc.history
    added = [rc.ingtree_ui.ingController.get_persistent_ref_from_iter(i) for i in added]
    rc.saveEditsCB()
    ings = rc.rd.get_ings(rc.current_rec)
    check_ings([i[2] for i in lines_groups_and_dc],ings)
    #print 'add_save_and_check.return:',lines_groups_and_dc,'->',added
    return added

def check_ings (check_dics,ings):
    """Given a list of dictionaries of properties to check and
    ingredients, check that our ingredients have those properties.  We
    assume our check_dics refer to the last ingredients in the list
    ings
    """
    n = -1
    check_dics.reverse()
    for dic in check_dics:
        ings[n]
        for k,v in dic.items():
            try:
                assert(getattr(ings[n],k)==v)
            except AssertionError:
                #print 'Failed assertion',n,k,v,ings[n]
                #print 'We are looking for: '
                #for d in check_dics: print ' ',d
                #print 'in:'
                #for a,u,i in [(i.amount,i.unit,i.item) for i in ings]: print ' ',a,u,i
                #print 'we are at ',n,ings[n].amount,ings[n],ings[n].unit,ings[n].item
                #print 'we find ',k,'=',getattr(ings[n],k),'instead of ',v
                raise
        n -= 1

def test_ing_editing (rc):
    """Handed a recipe card, test ingredient editing"""
    # Add some ingredients in a group...
    rc.show_edit(tab=rc.NOTEBOOK_ING_PAGE)        
    g = rc.ingtree_ui.ingController.add_group('Foo bar')
    if VERBOSE: print "Testing ingredient editing - add 4 ingredients to a group."
    add_save_and_check(
        rc,
        [['1 c. sugar',g,
         {'amount':1,'unit':'c.','item':'sugar','inggroup':'Foo bar'}
         ],
        ['1 c. silly; chopped and sorted',g,
         {'amount':1,'unit':'c.','ingkey':'silly','inggroup':'Foo bar'},
         ],
        ['1 lb. very silly',g,
         {'amount':1,'unit':'lb.','item':'very silly','inggroup':'Foo bar'},
         ],
        ['1 tbs. extraordinarily silly',g,
         {'amount':1,'unit':'tbs.','item':'extraordinarily silly','inggroup':'Foo bar'}
         ],]
        )
    if VERBOSE: print "Ingredient editing successful"
    return g
    
def test_ing_undo (rc):
    rc.show_edit(tab=rc.NOTEBOOK_ING_PAGE)        
    ings_groups_and_dcs = [
        # Just 1 ing -- more will require more undos
        ['1 c. oil',None,{'amount':1,'unit':'c.','item':'oil'}]
        ] 
    refs = add_save_and_check(
        rc,
        ings_groups_and_dcs
        )
    #print 'refs',refs,
    #print '->',[rc.ingtree_ui.ingController.get_iter_from_persistent_ref(r)
    #            for r in refs]
    rc.ingtree_ui.ingController.delete_iters(
        *[rc.ingtree_ui.ingController.get_iter_from_persistent_ref(r)
         for r in refs]
        )
    #print 'test_ing_undo - just deleted - UNDO HISTORY:',rc.history
    # Saving our edits...
    rc.saveEditsCB()
    try:
        ii = rc.rd.get_ings(rc.current_rec)
        check_ings(
            [i[2] for i in ings_groups_and_dcs],
            ii
            )
    except AssertionError:
        if VERBOSE: print 'Deletion worked!' # we expect an assertion error
    else:
        if VERBOSE: print [i[2] for i in ings_groups_and_dcs]
        if VERBOSE: print 'corresponds to'
        if VERBOSE: print [(i.amount,i.unit,i.item) for i in ii]
        raise Exception("Ings Not Deleted!")
    # Undo after save...
    rc.undo.emit('activate') # Undo deletion
    #print 'test_ing_undo - just pressed undo - UNDO HISTORY:',rc.history
    rc.saveEditsCB()
    # Check that our ingredients have been put back properly by the undo action!
    #print 'Checking for ',[i[2] for i in ings_groups_and_dcs]
    #print 'Checking in ',rc.rd.get_ings(rc.current_rec)
    check_ings(
        [i[2] for i in ings_groups_and_dcs],
        rc.rd.get_ings(rc.current_rec)
        )
    if VERBOSE: print 'Undeletion worked!'

def test_ing_group_editing (rc):
    rc.show_edit(tab=rc.NOTEBOOK_ING_PAGE)
    # We rely on the first item being a group
    itr = rec_card.ingtree_ui.ingController.imodel.get_iter(0,)
    rc.ingtree_ui.change_group(itr,'New Foo')
    rc.saveEditsCB()
    ings = rc.rd.get_ings(rc.current_rec)
    assert(ings[0].inggroup == 'New Foo') # Make sure our new group got saved
    if VERBOSE: print 'Group successfully changed to "New Foo"'
    rc.undo.emit('activate') # Undo
    assert(rc.save.get_sensitive()) # Make sure "Save" is sensitive after undo
    rc.saveEditsCB() # Save new changes
    ings = rc.rd.get_ings(rc.current_rec)
    assert(ings[0].inggroup != 'New Foo') # Make sure our new group got un-done
    if VERBOSE: print 'Undo of group change worked.'
    
def test_undo_save_sensitivity (rc):
    rc.show_edit(tab=rc.NOTEBOOK_ATTR_PAGE)        
    rc.saveEditsCB()
    assert_with_message(
        lambda : not rc.save.get_sensitive(),
        'SAVE Button not properly desensitized after save'
        )
    for widget,value in [
                         ('preptime',30*60),
                         ('cooktime',60*60),
                         ('title','Foo bar'),
                         ('cuisine','Mexican'),
                         ('category','Entree'),
                         ('rating',8),
                         ]:
        if VERBOSE: print 'TESTING ',widget
        if type(value)==int:
            orig_value = rc.rw[widget].get_value()
            rc.rw[widget].set_value(value)
            get_method = rc.rw[widget].get_value
            if VERBOSE: print 'Set with set_value(',value,')'
        elif widget in rc.reccom:
            orig_value = rc.rw[widget].entry.get_text()
            rc.rw[widget].entry.set_text(value)
            get_method = rc.rw[widget].entry.get_text
            if VERBOSE: print 'Set with entry.set_text(',value,')'            
        else:
            orig_value = rc.rw[widget].get_text()
            rc.rw[widget].set_text(value)
            get_method = rc.rw[widget].get_text
            if VERBOSE: print 'Set with set_text(',value,')'                        
        assert_with_message(
            lambda : get_method()==value,
            '''Value set properly for %s to %s (should be %s)'''%(
            widget,get_method(),value
            )
            )
        assert_with_message(rc.save.get_sensitive,
                            'Save sensitized after setting %s'%widget)
        assert_with_message(rc.undo.get_sensitive,
                            'Undo sensitized after setting %s'%widget)
        print '-- Hitting UNDO'
        rc.undo.emit('activate')
        while gtk.events_pending():
            gtk.main_iteration()
        if orig_value and type(value)!=int: rc.undo.emit('activate') # Blank text, then fill it
        assert_with_message(
            lambda : get_method()==orig_value,
            'Value of %s set to %s after Undo'%(widget,orig_value)
            )
        assert_with_message(
            lambda: not rc.save.get_sensitive(),
            'Save desensitized correctly after unsetting %s'%widget
            )
        if VERBOSE: print "-- Hitting 'REDO'"
        rc.redo.emit('activate')
        if orig_value and type(value)!=int:
            if VERBOSE: print "(Hitting redo a second time for text...)"
            rc.redo.emit('activate') # Blank text, then fill it        
        assert_with_message(
            lambda : get_method()==value,
            'Value of %s set to %s (should be %s)'%(widget,
                                                          get_method(),
                                                          value)
            )
        assert_with_message(rc.save.get_sensitive,
                            'Save sensitized after setting %s via REDO'%widget)
        print '-- Hitting UNDO again'
        rc.undo.emit('activate')
        if orig_value and type(value)!=int:
            if VERBOSE: print '(Hitting UNDO a second time for text)'
            rc.undo.emit('activate') # Blank text, then fill it
        assert_with_message(
            lambda : get_method()==orig_value,
            'Value unset properly on for %s UNDO->REDO->UNDO'%widget
            )
        try:
            assert_with_message(lambda : not rc.save.get_sensitive(),
                                'Save desensitized after undo->redo->undo of %s'%widget)
        except:
            print 'rc.widgets_changed_since_save',rc.widgets_changed_since_save
            raise
        if VERBOSE: print 'DONE TESTING %s'%widget

rg = GourmetRecipeManager.RecGui()
rg.newRecCard()
while gtk.events_pending(): gtk.main_iteration()
rec_id,rec_card = rg.rc.items()[0]

try:
    test_ing_editing(rec_card)
    print 'Ing Editing works!'
    test_ing_undo(rec_card)
    print 'Ing Undo works!'
    test_undo_save_sensitivity(rec_card)
    print 'Undo properly sensitizes save widget.'
    test_ing_group_editing(rec_card)
    print 'Ing Group Editing works.'
except:
    import traceback; traceback.print_exc()
    gtk.main()
else:
    rec_card.hide()
    import sys
    sys.exit()
    
    
    

########NEW FILE########
__FILENAME__ = test_allrecipes_com_plugin
# encoding: utf-8
import os.path
import unittest
import BeautifulSoup

from gourmet.plugins.import_export.website_import_plugins import allrecipes_plugin

class DummyImporter(object):
    class WebParser(object):
        pass


class TestAllRecipesPlugin(unittest.TestCase):

    url = "http://allrecipes.com/recipe/asian-beef-with-snow-peas/"

    def _read_html(self):
        filename = os.path.join(os.path.dirname(__file__),
                                'recipe_files',
                                (os.path.splitext(os.path.basename(__file__))[0])[5:-7]+".html")
        return (open(filename).read())

    def setUp(self):
        self.text = self._read_html()
        self.plugin = allrecipes_plugin.AllRecipesPlugin()

    def test_url(self):
        self.assertEqual(self.plugin.test_url(self.url, self.text), 5)
        self.assertEqual(self.plugin.test_url("http://www.allrecipes.com/recipe", self.text), 5)
        self.assertEqual(self.plugin.test_url("http://allrecipes.com/recipe", self.text), 5)
        self.assertEqual(self.plugin.test_url("http://allrecipes.net/", self.text), 0)
        self.assertEqual(self.plugin.test_url("http://google.com", self.text), 0)

    def test_parse(self):
        # Setup
        parser = self.plugin.get_importer(DummyImporter)()
        parser.soup = BeautifulSoup.BeautifulSoup(self.text,
                            convertEntities=BeautifulSoup.BeautifulStoneSoup.XHTML_ENTITIES,
                        )
        # Do the parsing
        parser.preparse()
        # Pick apart results
        result = parser.preparsed_elements

        ingredients = [r for r in result if r[1] == "ingredients"]
        name = [r for r in result if r[1] == "recipe"][0][0].text
        instructions = [r for r in result if r[1] == "instructions"][0][0].text
        modifications = [r for r in result if r[1] == "modifications"][0][0].text
        preptime = [r for r in result if r[1] == "preptime"][0][0].text
        cooktime = [r for r in result if r[1] == "cooktime"][0][0].text
        yields = [r for r in result if r[1] == "yields"][0][0].text

        # Check results
        self.assertEqual(len(ingredients), 9)
        self.assertTrue('5mins' in preptime)
        self.assertTrue('10mins' in cooktime)
        self.assertEqual(yields, '4 servings')

        self.assertEqual(name, 'Asian Beef with Snow Peas')
        self.assertTrue('Stir-fried beef in a light gingery sauce. Serve over steamed rice or hot egg noodles.' in modifications)
        self.assertTrue('In a small bowl, combine the soy sauce, rice wine, brown sugar and cornstarch. Set aside.' in instructions)
        self.assertTrue('Heat oil in a wok or skillet over medium high heat. Stir-fry ginger and garlic for 30 seconds. Add the steak and stir-fry for 2 minutes or until evenly browned. Add the snow peas and stir-fry for an additional 3 minutes. Add the soy sauce mixture, bring to a boil, stirring constantly. Lower heat and simmer until the sauce is thick and smooth. Serve immediately.' in instructions)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_foodnetwork_plugin
# encoding: utf-8
import os.path
import unittest
import BeautifulSoup

from gourmet.plugins.import_export.website_import_plugins import foodnetwork_plugin

class DummyImporter(object):
    class MenuAndAdStrippingWebParser(object):
        def preparse(dummy):
            pass


class TestFoodnetworkPlugin(unittest.TestCase):

    url = "http://www.foodnetwork.com/recipes/ask-aida/pan-roasted-chicken-with-oranges-and-rosemary-recipe/index.html"

    def _read_html(self):
        filename = os.path.join(os.path.dirname(__file__),
                        'recipe_files',
                        (os.path.splitext(os.path.basename(__file__))[0])[5:-7]+".html")
        return (open(filename).read())

    def setUp(self):
        self.text = self._read_html()
        self.plugin = foodnetwork_plugin.FoodNetworkPlugin()

    def test_url(self):
        self.assertEqual(self.plugin.test_url(self.url, self.text), 5)
        self.assertEqual(self.plugin.test_url("http://www.foodnetwork.com/rec", self.text), 5)
        self.assertEqual(self.plugin.test_url("http://foodnetwork.com/rec", self.text), 5)
        self.assertEqual(self.plugin.test_url("http://www.foodnetwork.com", self.text), 5)
        self.assertEqual(self.plugin.test_url("http://www.foodnetwork.net", self.text), 0)
        self.assertEqual(self.plugin.test_url("http://google.com", self.text), 0)

    def test_parse(self):
        # Setup
        parser = self.plugin.get_importer(DummyImporter)()
        parser.soup = BeautifulSoup.BeautifulSoup(self.text,
                            convertEntities=BeautifulSoup.BeautifulStoneSoup.XHTML_ENTITIES,
                        )
        # Do the parsing
        parser.preparse()
        # Pick apart results
        result = parser.preparsed_elements

        ingredients = [r for r in result if r[1] == "ingredients"][0][0]
        ingredients = [i for i in ingredients if type(i) == BeautifulSoup.Tag]
        name = [r for r in result if r[1] == "title"][0][0][0].text
        instructions = [r for r in result if r[1] == "recipe"][0][0].text

        # Check results
        self.assertEqual(len(ingredients), 8)

        self.assertTrue('Pan-Roasted Chicken with Oranges and Rosemary' in name)

        self.assertTrue('Heat oven to 450 degrees F and arrange rack in middle.' in instructions)
        self.assertTrue('Let rest 5 minutes before serving.' in instructions)

        self.assertFalse('You must be logged in to review this recipe.' in instructions)



if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_gourmet
#!/usr/bin/env python
# Copyright (c) 2004, 2005, 2006, 2007 Tom Hinkle
# You may use and distribute this software under the terms of the
# GNU General Public License, version 2 or later

#import sys
#import signal
#signal.signal(signal.SIGINT, signal.SIG_DFL)
import sys, os, os.path, glob
from stat import ST_MTIME

def maybe_intltool (fname):
    '''Check whether the file at fname has been updated since
    intltool-merge was last used on it. If it has, then use
    intltool-merge to update the output file.

    '''
    to_name = fname[:-3]
    if (
        (not os.path.exists(to_name))
        or
        os.stat(to_name)[ST_MTIME] < os.stat(fname)[ST_MTIME]
        ):
        os.system('intltool-merge -d i18n/ %s %s'%(fname, to_name))

for desktop_file in glob.glob('lib/plugins/*plugin.in') + glob.glob('lib/plugins/*/*plugin.in'):
    maybe_intltool(desktop_file)

if os.path.exists('foo'):
    os.remove('foo/gourmet')
    os.rmdir('foo')

os.mkdir('foo')
os.symlink(os.path.abspath('lib'),'foo/gourmet')
sys.path = [os.path.abspath('foo')] + sys.path
sys.argv.append('--gourmet-directory=%s'%os.path.abspath('/tmp/asdfqwer122'))
sys.argv.append('--data-directory=%s'%os.path.abspath('../data/'))
sys.argv.append('--glade-directory=%s'%os.path.abspath('../glade/'))
sys.argv.append('--image-directory=%s'%os.path.abspath('../images/'))
import gourmet.gglobals
sys.argv = sys.argv[:-4]
import gourmet.backends.test_db

#import gourmet.test_reccard
import gourmet.importers.test_interactive_importer
import gourmet.importers.test_importer
import gourmet.importers.test_importManager
import gourmet.test_convert
import gourmet.exporters.test_exportManager
import unittest
testsuite = unittest.TestSuite()
for module in [
    gourmet.importers.test_importManager,    
    gourmet.exporters.test_exportManager,
    gourmet.importers.test_interactive_importer,
    gourmet.importers.test_importer,
    gourmet.test_convert,
    ]:
    testsuite.addTest(
        unittest.defaultTestLoader.loadTestsFromModule(
            module
            )
        )
testsuite.addTest(gourmet.backends.test_db.suite)
tr = unittest.TestResult()
testsuite.run(tr)
if tr.wasSuccessful():
    print 'All ',tr.testsRun,'tests completed successfully!'
else:
    print 'Uh oh...'
    print 'We had ',len(tr.failures),'failures in ',tr.testsRun,'tests'
    for er,tb in tr.failures:
        print '---'
        print er,':',tb
        print '---'
    if tr.errors:
        print 'We had ',len(tr.errors),' errors in',tr.testsRun,'tests'
        for er,tb in tr.errors:
            print '---'
            print er,':',tb
            print '---'

########NEW FILE########
__FILENAME__ = test_gui
'''This set of unit tests uses dogtail to do interface
testing. Dogtail works by running the application "from the outside",
so to speak. These tests cannot access Gourmet internals, but they can
simulate actual user clicks, etc.

'''
import unittest
import time
import tempfile
import os.path

import gtk
import dogtail
import dogtail.procedural as dp
from dogtail.utils import screenshot

GOURMET_APP_PATH = './gourmet_in_place'
APPNAME = 'gourmet_in_place'

class BasicTestsBase:

    gdir = tempfile.mktemp()

    def do_testFileImport (self, fn):
        shortname = os.path.split(fn)[1]
        dp.focus.application(APPNAME)
        dp.focus.frame('Gourmet Recipe Manager')
        dp.click("File")
        dp.click("Import file")
        dp.focus.dialog('Open recipe...')
        dp.keyCombo("<Alt>l")
        dp.type(fn)
        screenshot('import_dialog-%s-.png'%shortname)
        dp.keyCombo("Return")
        time.sleep(5) # wait for import to complete...
        print 'DONE SLEEPING -- IMPORT SHOULD BE DONE!'
        screenshot('import_done-%s.png'%shortname)
        dp.keyCombo("<Alt>C") # close dialog
        dp.focus.frame('Gourmet Recipe Manager')
        screenshot('with_imported_recs-%s.png'%shortname)

    def do_testWebImport (self, url):
        shortname = url.split('/')[-1]
        dp.focus.application(APPNAME)
        dp.focus.frame('Gourmet Recipe Manager')
        dp.click("File")
        dp.click('Import webpage')
        time.sleep(2)
        dp.focus.frame('Enter website address')
        print 'TYPING URL!'
        dp.type(url)
        dp.keyCombo("Return")
        time.sleep(1)
        screenshot('manual_web_import-%s.png'%shortname)
        dp.click('OK')
        screenshot('manual_web_import_done-%s.png'%shortname)
        dp.focus.dialog('Gourmet Import/Export')
        dp.click('Close')

    def search_and_open (self, txt):
        dp.focus.frame("Gourmet Recipe Manager")
        dp.keyCombo('<Alt>S') # Focus search
        dp.focus.text()
        dp.type(txt) # Search for our recipe
        dp.keyCombo('<Alt>L') # Focus recipe list
        dp.keyCombo('Return') # Open recipe
        time.sleep(1)

    def do_tearDown (self):
        print 'tearDown!'
        # Quit application!
        print 'Quit app!'
        dp.focus.application(APPNAME)
        dp.focus.frame('Gourmet Recipe Manager')
        dp.keyCombo('<Ctrl>Q')
        print 'Hit quit!'
        time.sleep(2)
        print 'tearDown done!'
        os.system('killall gourmet_in_place') # Maek sure it's really dead...

    def focus_nth_recipe (self, n=0):
        dp.focus.application(APPNAME)
        dp.focus.frame("Gourmet Recipe Manager")
        dp.focus.table()
        dp.keyCombo('<Up>')
        for i in range(n):
            dp.keyCombo('<Down>')

class BasicTests (
    #unittest.TestCase,
    BasicTestsBase):

    firstRun = True

    def tearDown (self): self.do_tearDown()

    def setUp (self):
        # Start application
        print self,'set up!'
        print 'running',GOURMET_APP_PATH,self.gdir
        dp.run(GOURMET_APP_PATH,'--gourmet-directory=%s'%self.gdir,APPNAME)
        print 'Done with run!'
        if BasicTests.firstRun:
            print 'first run, sleep a bit extra...'
            time.sleep(3)
            BasicTests.firstRun = False
        time.sleep(2)
        print 'focus frame'
        dp.focus.application(APPNAME)
        print 'setUp done!'


    def testZippedImport (self):
        raise NotImplementedError

    def testRecipeEditorCustomization (self):
        raise NotImplementedError

    def testRecipeCardImage (self):
        raise NotImplementedError

    def testEditingNewCard (self):
        dp.focus.application(APPNAME)
        dp.focus.frame('Gourmet Recipe Manager')
        #dp.keyCombo('<Ctrl>n')
        dp.click('File')
        dp.click('New')
        dp.focus.frame(u'New Recipe (Edit)')
        dp.keyCombo('<Alt>l')
        dp.focus.widget('Title Entry')
        time.sleep(1)        
        dp.type('Testing!')
        dp.focus.widget('Preparation Time Entry')
        time.sleep(1)                
        dp.type('30 minutes')
        dp.focus.widget('Rating Entry')
        time.sleep(1)                
        dp.type('4')
        screenshot('Edited_recipe.png')
        #dp.keyCombo('<Ctrl>w')
        dp.click("Recipe")
        dp.click("Close")
        screenshot('save_changes_to_edited_rec.png')
        dp.focus.dialog('Question')
        #dp.keyCombo('<Alt>C')
        dp.click("Cancel")
        #self.assertEqual(hasattr(rc,'recipe_editor'),True,'Cancelling save-changes did not work')
        dp.focus.frame(u'New Recipe (Edit)')
        time.sleep(3)
        dp.keyCombo('<Ctrl>w')
        time.sleep(3)
        dp.focus.dialog('Question')
        dp.keyCombo('<Alt>s')
        screenshot('new_rec_saved.png')

    def testWebImport (self):
        self.do_testWebImport('file:///home/tom/Projects/grecipe-manager/src/tests/recipe_files/sample_site.html')
        self.search_and_open("Spaghetti")
        screenshot('web_imported_recipe_card-sample_site.png')        

    def testFileImport (self):
        self.do_testFileImport("/home/tom/Projects/grecipe-manager/src/tests/recipe_files/test_set.grmt")

    def testMastercookFileImport (self):
        self.do_testFileImport("/home/tom/Projects/grecipe-manager/src/tests/recipe_files/athenos1.mx2")

    def testMMFImport (self):
        self.do_testFileImport("/home/tom/Projects/grecipe-manager/src/tests/recipe_files/mealmaster.mmf")            


class TestsWithBaseSet (
    BasicTestsBase,
    unittest.TestCase
    ):

    firstRun = not os.path.exists('/tmp/gourmet_test_set')
    # Note that if you want to "refresh" the test set, you need to
    # delete the directory /tmp/gourmet_test_set
    gdir = '/tmp/gourmet_test_set'

    def tearDown (self):
        self.do_tearDown()

    def setUp (self):
        dp.run(GOURMET_APP_PATH,'--gourmet-directory=%s'%self.gdir,APPNAME)
        print 'setUp -- first run?',self.firstRun
        if TestsWithBaseSet.firstRun:
            print 'first run, sleep a bit extra...'
            time.sleep(3)
        time.sleep(2)
        print 'focus frame'
        dp.focus.application(APPNAME)
        print 'setUp done!'
        if TestsWithBaseSet.firstRun:
            self.do_testFileImport("/home/tom/Projects/grecipe-manager/src/tests/recipe_files/test_set.grmt")
            TestsWithBaseSet.firstRun = False

    def testShoppingListGenerationFromIndex (self):
        self.focus_nth_recipe(0)
        dp.click('Actions')
        dp.click('Add to Shopping List')
        screenshot('generate_shopping_list_from_index.png')
        dp.focus.dialog('')
        dp.click('OK')
        screenshot('generated_shopping_list_from_index.png')
        dp.focus.frame('Shopping List')
        dp.keyCombo('<Ctrl>w')
        # Add a second recipe to the list...
        self.focus_nth_recipe(1)
        dp.keyCombo('<Ctrl>l') # Add with keycombo...
        dp.focus.dialog('')
        dp.focus.text()
        dp.type('12')
        dp.keyCombo('<Return>')
        screenshot('shopping list With two recipes+mult.png')
        dp.keyCombo('<Ctrl>w')

    def testShoppingListGenerationFromCard (self):
        # Test multiplication + no multiplication
        self.focus_nth_recipe()
        dp.keyCombo('<Ctrl>o') # open recipe card
        dp.focus.frame('')
        dp.click('Actions')
        dp.click('Shop') # using shop button
        dp.focus.frame('Shopping List')
        screenshot('add-to-shopping-list-from-card-w-button.png')
        dp.keyCombo('<Ctrl>w')
        dp.focus.frame('')
        dp.click('Recipe')
        dp.click("Add to Shopping List") # from menu
        dp.focus.frame('Shopping List')
        screenshot('add-to-shopping-list-from-card-w-menu.png')        
        screenshot('Adding Shopping List from Card')
        dp.keyCombo('<Ctrl>w')
        dp.focus.frame('')
        dp.keyCombo('<Alt>y')
        dp.focus.text()
        dp.type('12') # double...
        dp.keyCombo('<Ctrl>l') # from keyboard
        dp.keyCombo('<Return>')
        screenshot('add-to-shopping-list-from-card-w-keyboard-multiplied-by-2.png')
        dp.keyCombo('<Ctrl>w')

    #def testShoppingListOptionalIngredients (self):
    #    raise NotImplementedError

    #def testLimitedSearch (self):
    #    raise NotImplementedError

    #def testHtmlExport (self):
    #    raise NotImplementedError

    #def testGourmetExport (self):
    #    raise NotImplementedError

    #def testPDFExport (self):
    #    raise NotImplementedError

    #def testIndexViewColumnCustomization (self):
    #    raise NotImplementedError


if __name__ == '__main__':
    print 'unittest.main()'
    unittest.main()

########NEW FILE########
__FILENAME__ = test_ica_se_plugin
# encoding: utf-8
import os.path
import unittest
import BeautifulSoup

from gourmet.plugins.import_export.website_import_plugins import ica_se_plugin

class DummyImporter(object):
    class WebParser(object):
        pass


class TestIcaPlugin(unittest.TestCase):
    def test_excluder(self):
        url = "/src/doc/"
        excluder = ica_se_plugin.Excluder(url)

        self.assertTrue(excluder.search(url+"index.html"))
        self.assertTrue(excluder.search("index.html"))
        self.assertFalse(excluder.search(url))
        self.assertFalse(excluder.search("http://ica.se/"+url))


    url = "http://www.ica.se/recept/grillad-kyckling-med-melon-712641/"

    def _read_html(self):
        filename = os.path.join(os.path.dirname(__file__),
                                'recipe_files',
                                (os.path.splitext(os.path.basename(__file__))[0])[5:-7]+".html")
        return (open(filename).read())

    def setUp(self):
        self.text = self._read_html()
        self.plugin = ica_se_plugin.IcaSePlugin()

    def test_url(self):
        self.assertEqual(self.plugin.test_url(self.url, self.text), 5)
        self.assertEqual(self.plugin.test_url("http://www.ica.se/rec", self.text), 5)
        self.assertEqual(self.plugin.test_url("http://ica.se/rec", self.text), 5)
        self.assertEqual(self.plugin.test_url("http://ica.com/", self.text), 0)
        self.assertEqual(self.plugin.test_url("http://google.com", self.text), 0)

    def test_parse(self):
        # Setup
        parser = self.plugin.get_importer(DummyImporter)()
        parser.soup = BeautifulSoup.BeautifulSoup(self.text,
                            convertEntities=BeautifulSoup.BeautifulStoneSoup.XHTML_ENTITIES,
                        )
        # Do the parsing
        parser.preparse()
        # Pick apart results
        result = parser.preparsed_elements

        ingredients = [r for r in result if r[1] == "ingredients"]
        name = [r for r in result if r[1] == "recipe"][0][0].text
        instructions = [r for r in result if r[1] == "instructions"][0][0].text
        category = [r for r in result if r[1] == "category"][0][0].text
        cooktime = [r for r in result if r[1] == "cooktime"][0][0].text
        yields = [r for r in result if r[1] == "yields"][0][0].text

        # Check results
        self.assertEqual(len(ingredients), 9)

        self.assertTrue('Grillad kyckling med melon' in name)
        self.assertTrue('Huvudrätt' in category)
        self.assertTrue('Tid: Under 45 min' in cooktime)
        self.assertEqual(yields, 'Portioner: 6')

        print type(instructions)
        self.assertTrue('Dela varje kycklinglårfilé i 2 bitar.' in instructions,
                instructions)
        self.assertTrue('Ta upp dem och skölj ur pannan.' in instructions)
        self.assertTrue('Fri från gluten, laktos, mjölkprotein och ägg.' in instructions)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_convert
import unittest
import convert

class ConvertTest (unittest.TestCase):

    def setUp (self):
        self.c = convert.get_converter()

    def testEqual (self):
        self.assertEqual(self.c.convert_simple('c','c'),1)

    def testDensity (self):
         self.assertEqual(self.c.convert_w_density('ml','g',item='water'),1)
         self.assertEqual(self.c.convert_w_density('ml','g',density=0.5),0.5)

    def testReadability (self):
        self.failUnless(self.c.readability_score(1,'cup') > self.c.readability_score(0.8,'cups') )
        self.failUnless(self.c.readability_score(1/3.0,'tsp.') > self.c.readability_score(0.123,'tsp.'))
    
    def testAdjustments (self):
        amt,unit = self.c.adjust_unit(12,'Tbs.','water')
        self.assertEqual(amt,.75)

    def testIntegerRounding (self):
        self.failUnless(convert.integerp(0.99))
    
    def testFractionGenerator (self):
        for d in [2,3,4,5,6,8,10,16]:
            self.assertEqual(
                convert.float_to_frac(1.0/d,fractions=convert.FRACTIONS_ASCII),
                ('1/%s'%d)
                )
            
    def testFractToFloat (self):
        for s,n in [
            ('1',1),
            ('123',123),
            ('1 1/2',1.5),
            ('74 2/5',74.4),
            ('1/10',0.1),
            ('one',1),
            ('a half',0.5),
            ('three quarters',0.75),
            ]:
            self.assertEqual(convert.frac_to_float(s),n)
        
    def test_ingmatcher (self):
        for s,a,u,i in [
            ('1 cup sugar', '1','cup','sugar'),
            ('1 1/2 cup sugar', '1 1/2','cup','sugar'),
            ('two cloves garlic', 'two','cloves','garlic'),
                        ]:
            match = convert.ING_MATCHER.match(s)
            self.failUnless(match)
            self.assertEqual(match.group(convert.ING_MATCHER_AMT_GROUP).strip(),a)
            self.assertEqual(match.group(convert.ING_MATCHER_UNIT_GROUP).strip(),u)
            self.assertEqual(match.group(convert.ING_MATCHER_ITEM_GROUP).strip(),i)
            
if __name__ == '__main__':
    unittest.main()
        

########NEW FILE########
__FILENAME__ = test_plugin_loader
import unittest
import tempfile
import os

import gourmet.gglobals

# clear out Gourmet's DB
tmpdir = tempfile.mktemp()
os.makedirs(tmpdir)
gourmet.gglobals.gourmetdir = tmpdir

import gourmet.GourmetRecipeManager
import gourmet.backends.db

gourmet.backends.db.RecData.__single = None
gourmet.GourmetRecipeManager.GourmetApplication.__single = None
# end clearing out code

from plugin_loader import get_master_loader

class Test (unittest.TestCase):

    def testDefaultPlugins (self):
        ml = get_master_loader()
        ml.load_active_plugins()
        print 'active:',ml.active_plugins
        print 'instantiated:',ml.instantiated_plugins
        assert(not ml.errors)

    def testAvailablePlugins (self):
        ml = get_master_loader()
        for st in ml.available_plugin_sets:
            if st not in ml.active_plugins:
                ml.activate_plugin_set(st)
                
if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = threadManager
# This module is designed to handle all multi-threading processes in
# Gourmet. Separate threads are limited to doing the following things
# with respect to the GUI:
#
#   1. Start a notification dialog with a progress bar
#   2. Update the progress bar
#   3. Finish successfully
#   4. Stop with an error.
#
# If you need to get user input in the middle of your threaded process,
# you need to redesign so that it works as follows:
#
# 1. Run the first half of your process as a thread.
# 2. Upon completion of your thread, run your dialog to get your user
#    input
# 3. Run the second half of your process as a thread.
#
# In this module, we define the following base classes...
#
# A singleton ThreadingManager that tracks how many threads we have
# running, and allows a maximum number of threads to be run at any
# single time.
#
# A SuspendableThread base class for creating and running threaded
# processes.
#
#
from gettext import gettext as _
import threading, gtk, pango, gobject, time
gobject.threads_init()

# _IdleObject etc. based on example John Stowers
# <john.stowers@gmail.com>

class _IdleObject(gobject.GObject):
    """
    Override gobject.GObject to always emit signals in the main thread
    by emmitting on an idle handler
    """
    def __init__(self):
        gobject.GObject.__init__(self)

    def emit(self, *args):
        if args[0]!='progress': print 'emit',args
        gobject.idle_add(gobject.GObject.emit,self,*args)

class Terminated (Exception):
    def __init__ (self, value):
        self.value=value
    def __str__(self):
        return repr(self.value)

class SuspendableThread (threading.Thread, _IdleObject):


    """A class for long-running processes that shouldn't interrupt the
    GUI.
    """

    __gsignals__ = {
        'completed' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, []),
        'progress' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE,
                     [gobject.TYPE_FLOAT, gobject.TYPE_STRING]), #percent complete, progress bar text
        'error' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, [gobject.TYPE_INT, # error number
                                                                gobject.TYPE_STRING, # error name
                                                                gobject.TYPE_STRING # stack trace
                                                                ]),
        'stopped': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, []), # emitted when we are stopped
        'pause': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, []), # emitted when we pause
        'resume': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, []), # emitted when we resume
        'done': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, []), # emitted when/however we finish
        }

    def __init__(self, name=None):
        self.initialized = False
        #self.name = name
        self.suspended = False
        self.terminated = False
        self.done = False
        _IdleObject.__init__(self)
        threading.Thread.__init__(self, name=name)

    def initialize_thread (self):
        self.initialized = True
        self.start()

    def connect_subthread (self, subthread):
        '''For subthread subthread, connect to error and pause signals and 
        and emit as if they were our own.'''
        subthread.connect('error',lambda st,enum,ename,strace: self.emit('error',enum,ename,strace))
        subthread.connect('stopped',lambda st: self.emit('stopped'))
        subthread.connect('pause',lambda st: self.emit('pause'))
        subthread.connect('resume',lambda st: self.emit('resume'))

    def run (self):
        try:
            self.do_run()
        except Terminated:
            self.emit('stopped')
        except:
            import traceback
            self.emit('error',1,
                      'Error during %s'%self.name,
                      traceback.format_exc())
        else:
            self.emit('completed')
        self.done = True
        self.emit('done')

    def do_run (self):
        # Note that sub-classes need to call check_for_sleep
        # periodically, otherwise pausing & cancelling won't work
        raise NotImplementedError
    
    def suspend (self):
        self.suspended = True

    def resume (self):
        self.suspended = False

    def terminate (self):
        self.terminated = True
        self.emit('stopped')

    def check_for_sleep (self):
        """Check whether we have been suspended or terminated.
        """
        paused_emitted = False
        emit_resume = False
        if self.terminated:
            raise Terminated('%s terminated'%self.name)
        if self.suspended:
            self.emit('pause')
            emit_resume = True
        while self.suspended:
            if self.terminated:
                raise Terminated('%s terminated'%self.name)
            time.sleep(1)
        if emit_resume:
            self.emit('resume')

    def __repr__ (self):
        try:
            return threading.Thread.__repr__(self)
        except AssertionError:
            return '<SuspendableThread %s - uninitialized>'%self.name

class NotThreadSafe:

    """Subclasses of this do things that are not thread safe. An error
    will be raised if an object that is an instance of this class is
    added to a thread manager.
    """
    pass

class ThreadManager:

    __single = None

    def __init__ (self, max_concurrent_threads = 2):
        if ThreadManager.__single:
            raise ThreadManager.__single
        self.max_concurrent_threads = max_concurrent_threads
        self.thread_queue = []
        self.count = 0
        self.active_count = 0
        self.threads = []

    def add_thread (self, thread):
        try:
            assert(isinstance(thread,SuspendableThread))
        except AssertionError:
            print 'Class',thread,type(thread),'is not a SuspendableThread'
            raise
        if isinstance(thread,NotThreadSafe):
            raise TypeError("Thread %s is NotThreadSafe"%thread)
        self.threads.append(thread)
        thread.connect('pause',self.register_thread_paused)
        thread.connect('resume',self.register_thread_resume)
        thread.connect('done',self.register_thread_done)
        if self.active_count < self.max_concurrent_threads:
            self.active_count += 1
            thread.initialize_thread()
        else:
            self.thread_queue.append(thread)
        
    def register_thread_done (self, thread):
        if thread in self.threads:
            self.threads.remove(thread)
            self.active_count -= 1
            self.start_queued_threads()        

    def register_thread_paused (self, thread):
        self.active_count -= 1
        self.start_queued_threads()

    def register_thread_resume (self, thread):
        self.active_count += 1

    def resume_thread (self, thread):
        if self.active_count < self.max_concurrent_threads:
            thread.resume()
            self.active_count += 1
        else:
            self.thread_queue.append(thread)
    
    def start_queued_threads (self):
        while self.active_count < self.max_concurrent_threads and self.thread_queue:
            thread_to_add = self.thread_queue.pop()
            self.active_count += 1
            if thread_to_add.initialized:
                thread_to_add.resume()
            else:
                thread_to_add.initialize_thread()

def get_thread_manager ():
    try:
        return ThreadManager()
    except ThreadManager, tm:
        return tm

class ThreadManagerGui:

    __single__ = None
    paused_text = ' (' + _('Paused') + ')'
    PAUSE = 10

    def __init__ (self, messagebox=None):
        if ThreadManagerGui.__single__:
            raise ThreadManagerGui.__single__
        else:
            ThreadManagerGui.__single__ = self
        self.tm = get_thread_manager()
        self.threads = {}

        if not messagebox:
            from GourmetRecipeManager import get_application
            self.messagebox = get_application().messagebox
        else:
            self.messagebox = messagebox

        self.to_remove = [] # a list of widgets to remove when we close...

    def response (self, dialog, response):
        if response==gtk.RESPONSE_CLOSE:
            self.close()
        
    def register_thread_with_dialog (self, description, done_msg, thread):
        threadbox = gtk.InfoBar()
        threadbox.set_message_type(gtk.MESSAGE_INFO)
        pb = gtk.ProgressBar()
        pb.set_ellipsize(pango.ELLIPSIZE_MIDDLE)
        pause_button = gtk.ToggleButton(label=_('Pause'))
        threadbox.add_action_widget(pause_button, self.PAUSE)
        dlab = gtk.Label(description)
        dlab.set_ellipsize(pango.ELLIPSIZE_MIDDLE)
        cancel_button = threadbox.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
        vbox = gtk.VBox()
        vbox.pack_start(dlab, expand=True, fill=True)
        vbox.pack_start(pb, expand=True, fill=True)
        threadbox.get_content_area().add(vbox)
        threadbox.show_all()
        self.messagebox.pack_start(threadbox)

        # This is a somewhat dirty hack.
        threadbox.done_msg = done_msg

        #for b in threadbox.buttons: b.show()
        thread.connect('completed',self.thread_done,threadbox)
        thread.connect('error',self.thread_error,threadbox)
        thread.connect('stopped',self.thread_stopped,threadbox)        
        thread.connect('pause',self.thread_pause,threadbox)
        thread.connect('resume',self.thread_resume,threadbox)
        thread.connect('progress',self.progress_update,pb)
        pause_button.connect('clicked',self.pause_cb,thread)
        cancel_button.connect('clicked',self.cancel_cb,thread)

    def pause_cb (self, b, thread):
        if b.get_active():
            thread.suspend()
        else:
            self.tm.resume_thread(thread)

    def cancel_cb (self, b, thread):
        thread.terminate()

    def thread_done (self, thread, threadbox):
        for b in threadbox.get_action_area().get_children(): b.hide()
        threadbox.add_button(gtk.STOCK_DISCARD, gtk.RESPONSE_CLOSE)
        threadbox.connect('response', lambda ib, response_id: ib.hide())
        self.to_remove.append(threadbox)
        pb = threadbox.get_content_area().get_children()[0].get_children()[1]
        txt = pb.get_text()
        if txt:
            pb.set_text(txt + ' ('+_('Done')+')')
        else:
            pb.set_text('Done')
        pb.set_percentage(1)
        for widget in threadbox.get_content_area().get_children()[0]:
            widget.hide()

        l = gtk.Label()
        l.set_markup(threadbox.done_msg)
        l.show()
        threadbox.get_content_area().add(l)

    def progress_update (self, thread, perc, txt, pb):
        if perc >= 0.0:
            pb.set_fraction(perc)
        else:
            pb.pulse()
        pb.set_text(txt)

    def thread_error (self, thread, errno, errname, trace, threadbox):
        threadbox.get_action_area().get_children()[1].hide() # Pause button
        pb = threadbox.get_content_area().get_children()[0].get_children()[1]
        pb.set_text(_('Error: %s')%errname)
        b = threadbox.add_button(_('Details'), 11)
        b.connect('clicked',self.show_traceback,errno,errname,trace)
        b.show()
        self.to_remove.append(threadbox)

    def thread_stopped (self, thread, threadbox):
        pb = threadbox.get_content_area().get_children()[0].get_children()[1]
        txt = pb.get_text()
        txt += '(' + _('cancelled') + ')'
        pb.set_text(txt)

    def thread_pause (self, thread, threadbox):
        pb = threadbox.get_content_area().get_children()[0].get_children()[1]
        txt = pb.get_text()
        txt += self.paused_text
        pb.set_text(txt)

    def thread_resume (self, thread, threadbox):
        pb = threadbox.get_content_area().get_children()[0].get_children()[1]
        txt = pb.get_text()
        if txt.find(self.paused_text):
            txt = txt[:-len(self.paused_text)]
            pb.set_text(txt)
        
    def show (self, *args):
        self.messagebox.show()

    def delete_event_cb (self, *args):
        self.messagebox.hide()
        return True

    def close (self, *args):
        while self.to_remove:
            box_to_remove = self.to_remove.pop()
            for w in box_to_remove.widgets:
                w.hide()
                self.pbtable.remove(w)
        self.messagebox.hide()

    def show_traceback (self, button, errno, errname, traceback):
        import gourmet.gtk_extras.dialog_extras as de
        de.show_message(label=_('Error'),
                        sublabel=_('Error %s: %s')%(errno,errname),
                        expander=(_('Traceback'),traceback),
                        )

def get_thread_manager_gui ():
    try:
        return ThreadManagerGui()
    except ThreadManagerGui, tmg:
        return tmg

if __name__ == '__main__':
    import gtk
    class TestThread (SuspendableThread):

        def do_run (self):
            for n in range(1000):
                time.sleep(0.01)
                self.emit('progress',n/1000.0,'%s of 1000'%n)
                self.check_for_sleep()

    class TestError (SuspendableThread):

        def do_run (self):
            for n in range(1000):
                time.sleep(0.01)
                if n==100: raise AttributeError("This is a phony error")
                self.emit('progress',n/1000.0,'%s of 1000'%n)
                self.check_for_sleep()
                

    class TestInterminable (SuspendableThread):

        def do_run (self):
            while 1:
                time.sleep(0.1)
                self.emit('progress',-1,'Working interminably')
                self.check_for_sleep()
                
    tm = get_thread_manager()
    tmg = get_thread_manager_gui()
    for desc,thread in [
        ('Interminable 1',TestInterminable()),
        ('Linear 1',TestThread()),
        ('Linear 2',TestThread()),
        ('Interminable 2',TestInterminable()),
        ('Error 3',TestError())
        ]:
        tm.add_thread(thread)
        tmg.register_thread_with_dialog(desc,thread)
    def quit (*args): gtk.main_quit()
    tmg.dialog.connect('delete-event',quit)
    tmg.show()
    gtk.main()

########NEW FILE########
__FILENAME__ = timer
import gtk, gobject, time, gglobals, os
import xml.sax.saxutils
from sound import Player
from gtk_extras import cb_extras as cb
from gettext import gettext as _

class TimeSpinnerUI:

    def __init__ (self, hoursSpin, minutesSpin, secondsSpin):
        self.timer_hooks = []
        self.running = False
        self.hoursSpin = hoursSpin
        self.minutesSpin = minutesSpin
        self.secondsSpin = secondsSpin        
        for s in [self.hoursSpin,self.minutesSpin,self.secondsSpin]:
            # This is set up to assure 2 digit entries... 00:00:00, etc.
            s.connect('changed',self.val_changed_cb)
            s.val_change_is_changing_entry = False
            s.set_width_chars(2)
            s.set_value(1)
            s.set_value(0)            

    def set_time (self, s):
        s = int(s)
        if s < 0: s = 0
        #self.hoursSpin.set_text(self.pad_n(s / 3600))
        self.hoursSpin.set_value(s / 3600)
        s = s % 3600
        #self.minutesSpin.set_text(self.pad_n(s / 60))
        self.minutesSpin.set_value(s / 60)
        #self.secondsSpin.set_text(self.pad_n(s % 60))
        self.secondsSpin.set_value(s % 60)

    def val_changed_cb (self, widg):
        if not widg.val_change_is_changing_entry:
            widg.val_change_is_changing_entry = True
            widg.set_text(self.pad_n(int(widg.get_value())))
            widg.val_change_is_changing_entry = False            

    def pad_n (self, int):
        s = str(int)
        if len(s)==1: return '0'+s
        else: return s

    def get_time (self):
        return self.hoursSpin.get_value()*3600 + self.minutesSpin.get_value()*60 + self.secondsSpin.get_value()

    # Methods to run the timer...
    def tick (self):
        if self.running:
            elapsed = time.time() - self.running
            t = self.start_time - elapsed
            #t = self.get_time() - 1
            self.set_time(t)
            if t<=0:
                self.finish_timer()
                return False
            else:
                return True
        else:
            return False

    def start_cb (self,*args):
        if not self.running and self.get_time():
            self.running = time.time()
            self.orig_time = self.start_time = self.get_time()
            gobject.timeout_add(1000,self.tick)

    def pause_cb (self, *args):
        if self.running:
            self.running = False
        else:
            self.running = time.time()
            self.start_time = self.get_time()
        if self.running: gobject.timeout_add(1000,self.tick)

    def reset_cb (self, *args):
        self.running = False
        self.set_time(self.orig_time)

    def connect_timer_hook (self, h, prepend=False):
        if prepend:
            self.timer_hooks = [h] + self.timer_hooks
        else:
            self.timer_hooks.append(h)

    def finish_timer (self):
        self.running  = False
        for h in self.timer_hooks: h()


from gtk_extras import dialog_extras as de

class TimerDialog:

    keep_annoying = False

    sounds_and_files = {
        _('Ringing Sound'):'phone.wav',
        _('Warning Sound'):'warning.wav',
        _('Error Sound'):'error.wav',
        }

    def __init__ (self):
        self.init_player()
        self.ui = gtk.Builder()
        self.ui.add_from_file(os.path.join(gglobals.uibase,'timerDialog.ui'))
        self.timer = TimeSpinnerUI(
            self.ui.get_object('hoursSpinButton'),
            self.ui.get_object('minutesSpinButton'),
            self.ui.get_object('secondsSpinButton')
            )
        self.timer.connect_timer_hook(self.timer_done_cb)
        for w in ['timerDialog','mainLabel',
                  'soundComboBox','repeatCheckButton',
                  'noteEntry','expander1','timerBox','resetTimerButton',
                  'timerFinishedLabel','keepAnnoyingLabel'
                  ]:
            setattr(self,w,self.ui.get_object(w))
        cb.set_model_from_list(self.soundComboBox,self.sounds_and_files.keys())
        cb.cb_set_active_text(self.soundComboBox,_('Ringing Sound'))
        self.ui.connect_signals(
            {'reset_cb':self.timer.reset_cb,
             'pause_cb':self.timer.pause_cb,
             'start_cb':self.timer.start_cb,
             'note_changed_cb':self.note_changed_cb,
             }
            )
        self.timerDialog.connect('response',self.response_cb)
        self.timerDialog.connect('close',self.close_cb)
        self.timerDialog.set_modal(False)
        self.note = ''

    def set_time (self, s):
        self.timer.set_time(s)

    def note_changed_cb (self, entry):
        txt = entry.get_text()
        self.note = txt
        if txt: txt = _('Timer')+': '+txt
        else: txt = _('Timer')
        self.timerDialog.set_title(txt)
        self.mainLabel.set_markup('<span weight="bold" size="larger">' + xml.sax.saxutils.escape(txt) + '</span>')

    def init_player (self):
        self.player = Player()    

    def play_tune (self):
        sound_file = self.sounds_and_files[cb.cb_get_active_text(self.soundComboBox)]
        sound_file = os.path.join(gglobals.data_dir,'sound',sound_file)
        self.player.play_file(sound_file)

    def annoy_user (self):
        if self.keep_annoying:
            self.play_tune()
            return True

    def timer_done_cb (self):
        if hasattr(self.timerDialog,'set_urgency_hint'): self.timerDialog.set_urgency_hint(True)
        self.play_tune()
        if self.repeatCheckButton.get_active():
            self.keep_annoying = True
            gobject.timeout_add(3000,self.annoy_user)
        self.timerBox.hide()
        self.expander1.hide()
        self.timerFinishedLabel.show()
        self.resetTimerButton.show()                
        if self.keep_annoying: self.keepAnnoyingLabel.show()
        

    def stop_annoying (self):
        self.keep_annoying = False
        if hasattr(self.timerDialog,'set_urgency_hint'): self.timerDialog.set_urgency_hint(False)

    def refresh (self, *args):
        self.stop_annoying()
        self.timer.reset_cb()
        self.timerFinishedLabel.hide()
        self.keepAnnoyingLabel.hide()
        self.timerBox.show()
        self.resetTimerButton.hide()
        self.expander1.show()
    
    def response_cb (self, dialog, resp):
        if resp == gtk.RESPONSE_APPLY:
            self.refresh()
        else:
            self.close_cb()

    def close_cb (self,*args):
        self.stop_annoying()
        if (not self.timer.running) or de.getBoolean(label=_('Stop timer?'),
                                                 sublabel=_("You've requested to close a window with an active timer. You can stop the timer, or you can just close the window. If you close the window, it will reappear when your timer goes off."),
                                                 custom_yes=_('Stop _timer'),custom_no=_('_Keep timing')
                                                 ):
            self.timer.running = False
            self.timerDialog.hide()
            self.timerDialog.destroy()
        else:
            self.timer.connect_timer_hook(self.timerDialog.show,1)
            self.timerDialog.hide()

    def run (self): self.timerDialog.run()
    def show (self): self.timerDialog.show()

def show_timer (time=600,
                note=''):
    td = TimerDialog()
    td.set_time(time)
    if note:
        td.noteEntry.set_text(note)
    td.show()

if __name__ == '__main__':
    w = gtk.Window()
    b = gtk.Button('Show timer')
    b.connect('clicked',lambda *args: show_timer())
    w.add(b)
    w.connect('delete-event',lambda *args: gtk.main_quit())
    w.show_all()
    gtk.main()

########NEW FILE########
__FILENAME__ = timeScanner
"""Scan text for time and show links that will pop up a timer if the
user clicks on any time in the TextView."""

import convert, re, gtk, gobject
from gtk_extras import LinkedTextView
import timer
import xml.sax.saxutils

all_units = []
for base,units in convert.Converter.time_units:
    for u in units:
        u = re.escape(unicode(u))
        if u not in all_units: all_units.append(u)

time_matcher = re.compile(
    u'(?P<firstnum>'+convert.NUMBER_FINDER_REGEXP + u')(' + \
    convert.RANGE_REGEXP + convert.NUMBER_FINDER_REGEXP.replace(u'int',u'int2').replace(u'frac',u'frac2') + u')?' \
    + u'\s*' + u'(?P<unit>' + u'|'.join(all_units) + u')(?=$|\W)',
    re.UNICODE
    )



def make_time_links (s):
    return time_matcher.sub('<a href="\g<firstnum> \g<unit>">\g<0></a>',s)


class TimeBuffer (LinkedTextView.LinkedPangoBuffer):

    def set_text (self, txt):
         LinkedTextView.LinkedPangoBuffer.set_text(
             self,
             make_time_links(txt)
             )

class LinkedTimeView (LinkedTextView.LinkedTextView):
    __gtype_name__ = 'LinkedTimeView'

    __gsignals__ = {
        'time-link-activated':(gobject.SIGNAL_RUN_LAST,
                          gobject.TYPE_STRING,
                          [gobject.TYPE_STRING,gobject.TYPE_STRING]),
        }

    def make_buffer (self):
        return TimeBuffer()

    def follow_if_link (self, text_view, iter):
        tags = iter.get_tags()
        for tag in tags:
            href = tag.get_data('href')
            if href:
                start_sentence = iter.copy();
                start_sentence.backward_sentence_start() 
                end_sentence = iter.copy()
                if not end_sentence.ends_sentence(): end_sentence.forward_sentence_end()
                self.emit('time-link-activated',href,self.get_buffer().get_slice(start_sentence,end_sentence))
                return True


def show_timer_cb (tv,l,note,c):
    """Callback that expects a widget, a time string, and a converter instance"""
    timer.show_timer(c.timestring_to_seconds(l),
               note)

if __name__ == '__main__':
    
    import gtk
    c = convert.get_converter()
    tv = LinkedTimeView()
    tv.connect('time-link-activated',show_timer_cb,c)
    tv.get_buffer().set_text(
        """Cook potatoes for 1/2 hour.

        When you are finished, leave in the refrigerator for up to three days.

        After that, boil onions for 20 to 30 minutes.

        When finished, bake everything for two and a half hours.

        15-25 seconds.
        """
        )
    
    w = gtk.Window()
    w.add(tv)
    w.connect('delete-event',lambda *args: gtk.main_quit())
    w.show_all()
    gtk.main()
    

########NEW FILE########
__FILENAME__ = Undo
import gtk, difflib,re
from gourmet.gdebug import debug

class TooManyChanges (Exception):
    def __init__ (self, value):
        self.value=value
    def __str__(self):
        return repr(self.value)

class UndoableObject:
    """An UndoableObject. This must provide an action, an inverse and a history. Alternatively,
    it can supply get_reapply_action_args, which will allow the action to be "reapplied" to new
    arguments (for example, if the action is setting a text attribute, reapply might set that attribute
    for the currently highlighted text)."""
    
    def __init__ (self, action, inverse, history,
                  action_args=None,
                  undo_action_args=None,
                  get_reapply_action_args=None,
                  get_reundo_action_args=None,
                  reapply_name=None,
                  reundo_name=None,
                  is_undo=False,
                  widget=None, # Keep track of widget where this
                               # action began (useful for GUIs to
                               # check if actions have changed value
                               # from "saved" state)
                  ):
        if not action_args: action_args = []
        if not undo_action_args: undo_action_args = []
        self.history = history
        self.action = action
        self.inverse_action = inverse
        self.get_reapply_action_args = get_reapply_action_args
        self.undo_action_args = undo_action_args
        self.get_reundo_action_args = get_reundo_action_args
        self.reapply_name = reapply_name
        self.reundo_name = reundo_name
        self.is_undo = is_undo  # If our action itself is an undo
        self.widget = widget
        if self.get_reapply_action_args:
            self.reapplyable = True
        else:
            self.reapplyable = False
        self.action_args = action_args

    def perform (self):
        self.action(*self.action_args)
        self.history.append(self)

    def inverse (self):
        u = UndoableObject(self.inverse_action, self.action, self.history,
                           action_args=self.undo_action_args,
                           undo_action_args=self.action_args,
                           get_reapply_action_args=self.get_reundo_action_args,
                           get_reundo_action_args=self.get_reapply_action_args,
                           is_undo=not self.is_undo,
                           widget=self.widget)
        self.history.remove(self)
        u.perform()

    def reapply (self):
        if self.get_reapply_action_args:
            args,undoargs = self.get_reapply_action_args()
            u = UndoableObject(self.action,self.inverse_action,self.history,
                               action_args=args,
                               undo_action_args=undoargs,
                               get_reapply_action_args=self.get_reapply_action_args,
                               reapply_name=self.reundo_name, reundo_name=self.reapply_name)
            u.perform()

    def __repr__ (self):
        return '<Undo.UndoableObject %s widget=%s>'%(self.is_undo,self.widget)

class UndoableTextChange (UndoableObject):
    def __init__ (self, set_text_action, history, initial_text="",text="",txt_id=None,is_undo=False):
        self.txt_id = txt_id
        self.blob_matcher = re.compile('\s+\S+\s+')
        self.initial_text = initial_text
        self.text = text
        self._set_text = set_text_action
        UndoableObject.__init__(self,lambda *args: self._set_text(self.text),lambda *args: self._set_text(self.initial_text),history,
                                is_undo=is_undo,widget=self.txt_id)
        self.mode=self.determine_mode()
        try:
            self.cindex,self.clen = self.find_change(self.text)
        except TooManyChanges:
            debug('Too many changes - assume 0,0',0)
            self.cindex,self.clen = 0,0

    def determine_mode (self,text=None,initial_text=None):
        if not text: text=self.text
        if not initial_text: initial_text=self.initial_text
        if len(text) > len(initial_text):
            return 'add'
        elif len(text) < len(initial_text):
            return 'delete'

    def find_change (self, text2=None, initial_text=None):
        if initial_text is None: initial_text = self.initial_text
        if not self.mode:
            self.text = text2
            self.determine_mode()
        if text2 is None: text2=self.text
        blocks = difflib.SequenceMatcher(None,initial_text,text2).get_matching_blocks()
        # we only are interested in similar blocks at different positions
        # (which tell us where the changes happened).
        ch_blocks = filter(lambda x: x[0] != x[1] and x[2] != 0, blocks)
        if ch_blocks and len(ch_blocks)>1:
            raise TooManyChanges("More than one block changed from '%s' to '%s': %s"%(initial_text,text2,ch_blocks))
        if ch_blocks:
            i,j,n = ch_blocks[0]
            change_length = j-i
            change_index = i
            return [change_index,change_length]
        else:
            if self.mode=='delete':
                return [len(initial_text),len(initial_text)-len(text2)]
            else: #self.mode=='add', we presume
                return [len(initial_text),len(text2)-len(initial_text)]

    def add_text (self, new_text):
        mode=self.determine_mode(new_text,self.text)
        contmode = self.determine_mode(new_text,self.text)
        if (mode == contmode == self.mode):
            try:
                # This whole thing is in a try/except box because
                # there are multiple places where "Too many changes"
                # could crop up as an error.
                cindex,clen = self.find_change(new_text)
                if ((cindex==self.cindex) or
                    (self.mode=='add' and cindex==self.cindex) or
                    (self.mode=='delete' and cindex==(self.cindex-clen))
                    ):
                    if self.mode=='add': changed_text = new_text[cindex:cindex+(self.clen+clen)]
                    else: changed_text=''
                    # Now we make sure the addition is at the end or middle of our new text...
                    relative_cindex,relative_clen = self.find_change(new_text,self.text)
                    # We only consider a word at a time to be a continuous change...
                    if (
                        # Adding text to the end
                        (
                        relative_cindex==cindex+(clen-relative_clen) 
                        or
                        # Adding text to the beginning
                        (relative_cindex==self.clen or relative_cindex==self.cindex) 
                        )
                        and
                        not self.blob_matcher.search(changed_text)
                        ):
                        self.text = new_text
                        self.cindex,self.clen = self.find_change(new_text)
                        ## End here if we've worked
                        return                
            except TooManyChanges:
                pass # We'll go to the end of the method & create a new action
        # If the mode has changed or we have too many changes to
        # handle simply, we just create a new undo action for this new
        # change
        self.new_action(new_text)

    def new_action (self, new_text):
        self.history.append(UndoableTextChange(self._set_text,self.history,
                                               initial_text=self.text, text=new_text,
                                               txt_id=self.txt_id,
                                               )
                            )

    def inverse (self):
        #self._set_text(self.initial_text)
        u=UndoableTextChange(self._set_text,self.history,initial_text=self.text,
                             text=self.initial_text,txt_id=self.txt_id,
                             is_undo=not self.is_undo,
                             )
        self.history.remove(self)
        u.perform()

    def perform (self):
        self._set_text(self.text)
        self.history.append(self)

    def __repr__ (self):
        return '<Undo.UndoableTextChange '+repr(self.mode)+' '+repr(self.txt_id)+\
               repr(self.initial_text)+'=>'+repr(self.text)+'clen'+str(self.clen)+\
               'cindex'+str(self.cindex)+'>'

    def __eq__ (self,obj):
        """We are equal too objects that represent the same txt_id and
        are either the same action as us or the inverse of us
        """
        if not hasattr(obj,'txt_id'):
            return False
        else:
            return (
                self.txt_id==obj.txt_id
                and
                ((self.initial_text==obj.initial_text
                  and
                  self.text == obj.text)
                 or
                 (self.initial_text==obj.text
                  and
                  self.text==obj.initial_text)
                 )
                )
    

class UndoableTextContainer:
    def __init__ (self, container, history):
        self.history = history
        self.container = container
        self.setup_widgets()
        self.txt = self.get_text()
        self._setting = False

    def change_event_cb (self,*args):
        # if the last change is the same as us...
        if self._setting:
            return
        txt = self.get_text()
        if txt == self.txt: return
        if len(self.history)>=1 and hasattr(self.history[-1],'txt_id') and self.history[-1].txt_id==self.container:
            self.change = self.history[-1]
            self.history[-1].add_text(txt)
        else:
            self.change=UndoableTextChange(self._set_text,
                                           self.history,
                                           initial_text=self.txt,
                                           text=txt,
                                           txt_id=self.container)
            self.history.append(self.change)
        self.txt = txt
        
    def setup_widgets (self): pass
    def get_text (self): raise NotImplementedError

    def _set_text (self,txt):
        self._setting = True # Set flag so we don't trigger our own
                             # callbacks
        orig = self.get_text() # Get current text for comparison
                               # (helps with placement of cursor)
        if len(txt) > orig:         # If we're adding
            try:
                index,length = self.change.find_change(txt,orig)
                cursor_index = index+length
            except TooManyChanges:
                # If we changed more than one block, there is no obvious
                # place to put the cursor, so we put it at the end
                cursor_index = len(txt)
        else: # If we're Removing
            try:
                # We get the *index* of the inverse of our action
                # i.e. If we go from Thhis -> This, then we reverse to
                # This -> Thhis (which is the same as where it would
                # have been after hitting backspace) and we put it
                # there.
                index,length = self.change.find_change(orig,txt)
                cursor_index = index
            except TooManyChanges:
                cursor_index = len(txt)
        self.set_text(txt,cursor_index)
        self._setting = False # Unset flag

    def set_text (self,txt,cursor_index): raise NotImplementedError

class UndoableEntry (UndoableTextContainer):
    def __init__ (self, entry,history):
        self.entry = entry
        self.get_text = self.entry.get_text
        UndoableTextContainer.__init__(self,self.entry,history)

    def setup_widgets (self): 
        self.entry.connect('changed',
                           self.change_event_cb
                           )
        
    def set_text (self, txt, cursor_index):
        self.entry.grab_focus()
        self.entry.set_text(txt)
        self.entry.set_position(cursor_index)
        
class UndoableGenericWidget:
    """Wrap a widget in an Undo class.

    We take a set_method, a get_method, and a signal, as well as a
    history list to append our Undo objects to.
    """
    def __init__ (self, widget, history, set_method='set_value',get_method='get_value', signal='changed'):
        self.w = widget
        self.set_method = set_method
        self.get_method = get_method
        self.im_doing_the_setting = False
        self.history = history
        self.last_value = self.get()
        self.w.connect(signal,self.changecb)

    def set (self, val):
        self.im_doing_the_setting = True
        getattr(self.w,self.set_method)(val)
        self.im_doing_the_setting = False

    def get (self):
        return getattr(self.w,self.get_method)()

    def changecb (self,*args):
        if self.im_doing_the_setting:
            # If we are doing the setting, presumably this is from one
            # of the Undo objects we created, in which case we don't
            # want to add a new item to the Undo queue
            return
        old_val = self.last_value
        new_val = self.get()
        if old_val==new_val: return # Ignore redundant changes...
        if new_val != old_val:
            # We don't perform because we're being called after the action has happened.
            # We simply append ourselves to the history list.
            u = UndoableObject(lambda *args: self.set(new_val),
                               lambda *args: self.set(old_val),
                               self.history,
                               widget=self.w
                               )
            self.history.append(u)
            self.last_value=new_val
        
class UndoableTextView (UndoableTextContainer):
    def __init__ (self, textview, history):
        self.tv = textview
        UndoableTextContainer.__init__(self,self.tv,history)
        
    def setup_widgets (self):
        self.buffer = self.tv.get_buffer()
        self.buffer.connect('changed',
                            self.change_event_cb)
        self.buffer.connect('apply-tag',self.change_event_cb)
        self.buffer.connect('remove-tag',self.change_event_cb)
        
    def set_text (self, text, cursor_index):        
        self.buffer.set_text(text)
        self.tv.grab_focus()
        self.buffer.place_cursor(self.buffer.get_iter_at_offset(cursor_index))

    def get_text (self):
        return self.buffer.get_text(self.buffer.get_start_iter(),
                                    self.buffer.get_end_iter())        

class UndoHistoryList (list):
    """An UndoHistoryList."""
    def __init__ (self, undo_widget, redo_widget, reapply_widget=None, signal='activate'):
        self.undo_widget = undo_widget
        self.redo_widget = redo_widget
        self.reapply_widget = reapply_widget
        self.action_hooks = []
        list.__init__(self)
        self.gui_update()
        if signal:
            if self.undo_widget: self.undo_widget.connect(signal,self.undo)
            if self.redo_widget: self.redo_widget.connect(signal,self.redo)
            if self.reapply_widget: self.reapply_widget.connect(signal,self.reapply)

    def add_action_hook (self, hook):
        """Add action hook

        Hook will be a callback as follows

        hook(undo_history,action,type)

        where undo_history is this instance of UndoHistory and
        type is 'perform','undo','redo', or 'reapply'
        """
        self.action_hooks.append(hook)

    def undo (self, *args):
        index = -1
        if len(self) == 0: return False
        try:
            while self[index].is_undo:
                index -= 1
        except IndexError:
            debug('All %s available action are .is_undo=True'%len(self),0)
            print 'There is nothing to undo!'
            print 'All %s actions are undos'%len(self)
            print self,index
            raise
        action = self[index]
        action.inverse()
        for h in self.action_hooks: h(self,action,'undo')

    def redo (self, *args):
        if len(self) == 0: return False
        index = -1
        try:
            while not self[index].is_undo:
                index = index - 1
        except IndexError:
            debug('All %s available actions are is_undo=False'%len(self),0)
            print 'There is nothing to redo!'
            print 'All %s available actions are is_undo=False'%len(self)
            raise
        action = self[index]
        action.inverse()
        for h in self.action_hooks: h(self,action,'redo')

    def reapply (self, *args):
        debug('Reapplying',0)
        action = self[-1]
        action.reapply()
        for h in self.action_hooks: h(self,action,'reapply')

    def set_sensitive (self,w,val):
        debug('set_sensitive',0)
        if not w:
            #import traceback; traceback.print_stack()
            #print 'No widget to sensitize',w,val
            return
        w.set_sensitive(val)

    def gui_update (self):
        debug('gui_update',0)
        if len(self) >= 1:
            undoables = [x.is_undo for x in self]
            if False in undoables:
                self.set_sensitive(self.undo_widget,True)
                debug('Sensitizing undo_widget',0)
            else:
                self.set_sensitive(self.undo_widget,False)
                debug('Desensizing undo_widget',0)
            if True in undoables:
                debug('Sensitizing redo_widget',0)
                self.set_sensitive(self.redo_widget,True)
            else:
                debug('Desensitizing redo widget',0)
                self.set_sensitive(self.redo_widget,False)
            if self[-1].reapplyable:
                debug('Sensitizing "reapply" widgets',0)
                self.set_sensitive(self.reapply_widget,True)
                if self[-1].reapply_name:
                    if type(self.reapply_widget)==gtk.MenuItem:
                        alabel = self.reapply_widget.get_children()[0]
                        alabel.set_text_with_mnemonic(self[-1].reapply_name)
                        alabel.set_use_markup(True)
        else:
            debug('Nothing to undo, desensitizing widgets',0)
            self.set_sensitive(self.redo_widget,False)
            self.set_sensitive(self.undo_widget,False)
            self.set_sensitive(self.reapply_widget,False)
            
    def append (self,obj):
        debug('Appending %s'%obj,0)
        list.append(self,obj)
        if obj.is_undo==False: # Is this necessary? Not sure...
            for h in self.action_hooks:
                h(self,obj,'perform')
        self.gui_update()

    def remove (self,obj):
        debug('Removing %s'%obj,0)        
        list.remove(self,obj)
        self.gui_update()

class MultipleUndoLists:
    """For tabbed interfaces and other places where it makes sense for one
    Action (menu item, etc.) to control multiple UndoLists (since presumably
    nobody wants to undo things they can't see)"""
    def __init__ (self, undo_widget, redo_widget, reapply_widget=None, signal='activate',
                  get_current_id=None):
        self.undo_widget = undo_widget
        self.redo_widget = redo_widget
        self.reapply_widget = reapply_widget
        self.signal = signal
        self.get_current_id = get_current_id
        self.histories = {}
        self.action_hooks = []
        if signal:
            if self.undo_widget: self.undo_widget.connect(signal,self.undo)
            if self.redo_widget: self.redo_widget.connect(signal,self.redo)
            if self.reapply_widget: self.reapply_widget.connect(signal,self.reapply)
        
        # attempts to implement the following programatically are failing me...
        # it feels awful to write each of these methods out here, but here goes...

    def add_action_hook (self, hook):
        self.action_hooks.append(hook)
        for h in self.get_all_histories(): h.add_action_hook(hook)
    def __add__ (self,*args,**kwargs): return self.get_history().__add__(*args,**kwargs)
    def __contains__ (self,*args,**kwargs): return self.get_history().__contains__(*args,**kwargs)
    def __delitem__ (self,*args,**kwargs): return self.get_history().__delitem__(*args,**kwargs)
    def __delslice__ (self,*args,**kwargs): return self.get_history().__delslice__(*args,**kwargs)
    def __doc__ (self,*args,**kwargs): return self.get_history().__doc__(*args,**kwargs)
    def __eq__ (self,*args,**kwargs): return self.get_history().__eq__(*args,**kwargs)
    def __ge__ (self,*args,**kwargs): return self.get_history().__ge__(*args,**kwargs)
    def __getitem__ (self,*args,**kwargs): return self.get_history().__getitem__(*args,**kwargs)
    def __getslice__ (self,*args,**kwargs): return self.get_history().__getslice__(*args,**kwargs)
    def __gt__ (self,*args,**kwargs): return self.get_history().__gt__(*args,**kwargs)
    def __hash__ (self,*args,**kwargs): return self.get_history().__hash__(*args,**kwargs)
    def __iadd__ (self,*args,**kwargs): return self.get_history().__iadd__(*args,**kwargs)
    def __imul__ (self,*args,**kwargs): return self.get_history().__imul__(*args,**kwargs)
    def __iter__ (self,*args,**kwargs): return self.get_history().__iter__(*args,**kwargs)
    def __le__ (self,*args,**kwargs): return self.get_history().__le__(*args,**kwargs)
    def __len__ (self,*args,**kwargs): return self.get_history().__len__(*args,**kwargs)
    def __lt__ (self,*args,**kwargs): return self.get_history().__lt__(*args,**kwargs)
    def __mul__ (self,*args,**kwargs): return self.get_history().__mul__(*args,**kwargs)
    def __ne__ (self,*args,**kwargs): return self.get_history().__ne__(*args,**kwargs)
    def __new__ (self,*args,**kwargs): return self.get_history().__new__(*args,**kwargs)
    def __reduce__ (self,*args,**kwargs): return self.get_history().__reduce__(*args,**kwargs)
    def __reduce_ex__ (self,*args,**kwargs): return self.get_history().__reduce_ex__(*args,**kwargs)
    def __repr__ (self,*args,**kwargs): return self.get_history().__repr__(*args,**kwargs)
    def __rmul__ (self,*args,**kwargs): return self.get_history().__rmul__(*args,**kwargs)
    def __setitem__ (self,*args,**kwargs): return self.get_history().__setitem__(*args,**kwargs)
    def __setslice__ (self,*args,**kwargs): return self.get_history().__setslice__(*args,**kwargs)
    def __str__ (self,*args,**kwargs): return self.get_history().__str__(*args,**kwargs)
    def append (self,*args,**kwargs): return self.get_history().append(*args,**kwargs)
    def count (self,*args,**kwargs): return self.get_history().count(*args,**kwargs)
    def extend (self,*args,**kwargs): return self.get_history().extend(*args,**kwargs)
    def index (self,*args,**kwargs): return self.get_history().index(*args,**kwargs)
    def insert (self,*args,**kwargs): return self.get_history().insert(*args,**kwargs)
    def pop (self,*args,**kwargs): return self.get_history().pop(*args,**kwargs)
    def remove (self,*args,**kwargs): return self.get_history().remove(*args,**kwargs)
    def reverse (self,*args,**kwargs): return self.get_history().reverse(*args,**kwargs)
    def sort (self,*args,**kwargs): return self.get_history().sort(*args,**kwargs)

    def redo (self,*args,**kwargs):
        return self.get_history().redo(*args,**kwargs)

    def undo (self,*args,**kwargs):
        return self.get_history().undo(*args,**kwargs)
    
    def reapply (self,*args,**kwargs): return self.get_history().reapply(*args,**kwargs)

    def get_all_histories (self): return self.histories.values()

    def get_history (self):
        hid=self.get_current_id()
        if self.histories.has_key(hid):
            #debug('Returning history %s for id %s'%([repr(i) for i in self.histories[hid]],hid),0)
            return self.histories[hid]
        else:
            #debug('Creating new history for id %s'%hid,0)
            self.histories[hid]=self.make_history()
            return self.histories[hid]

    def make_history (self):
        uhl = UndoHistoryList(self.undo_widget,self.redo_widget,None,None)
        for h in self.action_hooks: uhl.add_action_hook(h)
        return uhl

    def switch_context (self, hid):
        # set sensitivity for current context
        debug('switching context...',0)
        self.get_history().gui_update()
            
if __name__ == '__main__':
    #txt = raw_input('Text: ')
    #history = []
    #utc = UndoableTextChange(None,None,history,text=txt)
    #history.append(utc)
    #while txt:
    #    txt = raw_input('Text: ')
    #    history[-1].add_text(txt)
    import gtk
    w = gtk.Window()
    e = gtk.Entry()
    sb = gtk.SpinButton()
    adj = sb.get_adjustment()
    adj.upper=100
    adj.lower=-100
    adj.step_increment = 1
    adj.page_increment = 10
    tv = gtk.TextView()
    ub = gtk.Button(stock=gtk.STOCK_UNDO)
    rb = gtk.Button(stock=gtk.STOCK_REDO)
    sc = gtk.Button('show changes')
    vb = gtk.VBox()
    bb = gtk.HButtonBox()
    bb.add(ub)
    bb.add(rb)
    bb.add(sc)
    vb.add(bb)
    vb.add(e)
    vb.add(tv)
    vb.add(sb); sb.show()
    w.add(vb)
    uhl = UndoHistoryList(ub,rb,signal='clicked')
    UndoableTextView(tv,uhl)
    UndoableEntry(e,uhl)
    UndoableGenericWidget(sb,uhl)
    w.show_all()
    w.connect('delete-event',lambda *args:gtk.main_quit())
    def show_changes (*args):
        for c in uhl:
            if hasattr(c,'initial_text'):
                print c,' initial: ',c.initial_text,' current: ',c.text
            else:
                print c
    ub.connect('clicked',lambda *args: debug('Undo clicked!',0))
    sc.connect('clicked',show_changes)
    rb.connect('clicked',lambda *args: debug('Redo clicked!',0))    
    gtk.main()



########NEW FILE########
__FILENAME__ = version
import settings
from gettext import gettext as _
# To have strings from .ui files (gtk.Builder) translated on all platforms,
# we need the following module to enable localization on all platforms.
try:
    import elib.intl
    elib.intl.install('gourmet', settings.locale_base)
except ImportError:
    print 'elib.intl failed to load.'
    print 'IF YOU HAVE TROUBLE WITH TRANSLATIONS, MAKE SURE YOU HAVE THIS LIBRARY INSTALLED.'

name= 'gourmet'
appname = _("Gourmet Recipe Manager")
copyright = _("Copyright (c) 2004-2014 Thomas M. Hinkle. GNU GPL v2")
version = "0.17.3"
website = "http://thinkle.github.io/gourmet/"
description = "Recipe Organizer and Shopping List Generator"
long_description = _("""\
Gourmet Recipe Manager is an application to store, organize and search recipes.

Features:
* Makes it easy to create shopping lists from recipes.
* Imports recipes from a number of sources, including MealMaster and MasterCook
  archives and several popular websites.
* Exports recipes as PDF files, plain text, MealMaster files, HTML web pages,
  and a custom XML format for exchange with other Gourmet users.
* Supports linking images with recipes.
* Can calculate nutritional information for recipes based on the ingredients.
""")
author = 'Thomas Mills Hinkle'
author_email = 'Thomas_Hinkle@alumni.brown.edu'
maintainer = 'Bernhard Reiter'
maintainer_email = 'ockham@raz.or.at'
authors = ["Thomas M. Hinkle <Thomas_Hinkle@alumni.brown.edu>",
           _("Roland Duhaime (Windows porting assistance)"),
           _("Daniel Folkinshteyn <nanotube@gmail.com> (Windows installer)"),
           _("Richard Ferguson (improvements to Unit Converter interface)"),
           _("R.S. Born (improvements to Mealmaster export)"),
           _("ixat <ixat.deviantart.com> (logo and splash screen)"),
           _("Yula Zubritsky (nutrition and add-to-shopping list icons)"),
           _("Simon Darlington <simon.darlington@gmx.net> (improvements to internationalization, assorted bugfixes)"),
           _("Bernhard Reiter <ockham@raz.or.at> (maintenance since 0.16.0, website re-design)"),
           ]
artists = [_("Nyall Dawson (cookie icon)"),
           _("Kati Pregartner (splash screen image)")]
license = 'GPL'

########NEW FILE########
__FILENAME__ = gourmetwidgets
#import os, sys
#execpath = os.path.dirname(__file__)
#sys.path.insert (0, os.path.join(execpath, "../../src/lib"))
#print sys.path

#from gtk_extras import timeEntry, ratingWidget, timeEntry
#import timeScanner

import gtk

class TimeEntry (gtk.Entry):
    __gtype_name__ = 'TimeEntry'

class StarButton (gtk.Button):
    __gtype_name__ = 'StarButton'

class StarImage (gtk.Image):
    __gtype_name__ = 'StarImage'

class LinkedTextView (gtk.TextView):
    __gtype_name__ = 'LinkedTextView'

class LinkedTimeView (LinkedTextView):
    __gtype_name__ = 'LinkedTimeView'

########NEW FILE########
