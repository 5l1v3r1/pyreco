__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# TiddlyWeb documentation build configuration file, created by
# sphinx-quickstart on Tue Sep  3 15:59:47 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'TiddlyWeb'
copyright = u'2013, Chris Dent'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.4'
# The full version, including alpha/beta/rc tags.
release = '1.4'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#html_theme = 'agogo'
#html_theme = 'default'
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'TiddlyWebdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'TiddlyWeb.tex', u'TiddlyWeb Documentation',
   u'Chris Dent', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'tiddlyweb', u'TiddlyWeb Documentation',
     [u'Chris Dent'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'TiddlyWeb', u'TiddlyWeb Documentation',
   u'Chris Dent', 'TiddlyWeb', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = list_tiddlers

import sys
sys.path.insert(0, '.')

import shutil

from time import time

from tiddlyweb.config import config

from tiddlyweb.model.bag import Bag
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.store import Store
from tiddlyweb import control
from tiddlyweb.serializer import Serializer
from tiddlyweb.filters import parse_for_filters

environ = {}
environ['tiddlyweb.config'] = config

def run():
    clean_store()
    make_tiddlers_for_bag()
    profile_listing_tiddlers()


def clean_store():
    try:
        shutil.rmtree('store')
    except OSError:
        pass

def make_tiddlers_for_bag():
    store = Store('text', environ['tiddlyweb.config']['server_store'][1], environ)

    print 'store', time()
    bag = Bag('profiler')
    store.put(bag)

    for name in range(1, 10000):
        tag = name % 10
        name = str(name)
        tag = str(tag)
        tiddler = Tiddler(name, bag.name)
        tiddler.text = name
        tiddler.tags.append(tag)
        store.put(tiddler)
    print 'stored', time()

def profile_listing_tiddlers():
    store = Store('text', environ['tiddlyweb.config']['server_store'][1], environ)
    environ['tiddlyweb.store'] = store

    bag = Bag('profiler')

    print 'filter', time()
    filter_string = 'select=tag:1'
    filters, leftovers = parse_for_filters(filter_string, environ)
    tiddlers = control.filter_tiddlers(store.list_bag_tiddlers(bag), filters, environ=environ)

    print 'output', time()
    print [tiddler.title for tiddler in tiddlers]

    #print 'serializer', time()
    #serializer = Serializer('wiki', environ)
    #print 'wikify', time()
    #output = serializer.list_tiddlers(tmp_bag)

    print 'done', time()


if __name__ == '__main__':
    command = sys.argv[1]
    print command
    if command == 'clean':
        clean_store()
    elif command == 'make':
        make_tiddlers_for_bag()
    elif command == 'filter':
        profile_listing_tiddlers()
    else:
        run()

########NEW FILE########
__FILENAME__ = fixtures
"""
Data structures required for our testing.
"""

import os
import shutil

from wsgi_intercept import httplib2_intercept
import wsgi_intercept

import httplib2

from tiddlyweb.web.serve import load_app
from tiddlyweb.model.collections import Tiddlers
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.config import config
from tiddlyweb.store import Store

config['server_host'] = {
        'scheme': 'http',
        'host': 'our_test_domain',
        'port': '8001',
        }

TiddlerOne = Tiddler('TiddlerOne')
TiddlerOne.modifier = 'AuthorOne'
TiddlerOne.text = u'c tiddler one content'
TiddlerOne.tags = ['tagone', 'tagtwo']

TiddlerTwo = Tiddler('TiddlerTwo')
TiddlerTwo.modifier = u'AuthorTwo'
TiddlerTwo.text = u'b tiddler two content'

TiddlerThree = Tiddler('TiddlerThree')
TiddlerThree.modifier = u'AuthorThree'
TiddlerThree.text = u'a tiddler three content'
TiddlerThree.tags = [u'tagone', u'tagthree']

tiddlers = [TiddlerOne, TiddlerTwo, TiddlerThree]

bagone = Bag(name='bagone')
bagtwo = Bag(name='bagtwo')
bagthree = Bag(name='bagthree')
bagfour = Bag(name='bagfour')

tiddler_collection = Tiddlers()
for tiddler in tiddlers:
    tiddler.bag = u'bagfour'
    tiddler_collection.add(tiddler)


def initialize_app():
    app = load_app()

    def app_fn():
        return app

    httplib2_intercept.install()
    wsgi_intercept.add_wsgi_intercept('our_test_domain', 8001, app_fn)


def get_store(config):
    return Store(config['server_store'][0], config['server_store'][1],
            {'tiddlyweb.config': config})


def _teststore():
    """
    Different from the above because it is using config loaded in this
    module. Kept for backwards awareness.
    """
    return Store(config['server_store'][0], config['server_store'][1],
            environ={'tiddlyweb.config': config})


def reset_textstore():
    if os.path.exists('store'):
        shutil.rmtree('store')


def muchdata(store):
    for bag_numeral in range(30):
        bag = create_bag(store, bag_numeral)
        for tiddler_numeral in range(10):
            create_tiddler(store, bag, tiddler_numeral)

    recipe = Recipe('long')

    recipe_list = [(u'bag1', '')]
    for numeral in range(0, 30, 2):
        bag_name = u'bag%s' % numeral
        filter_string = u'select=title:tiddler%s' % (numeral % 10)
        if not (numeral % 10) % 3:
            filter_string = filter_string + u';select=tag:tag three'
        recipe_list.append([bag_name, filter_string])
    recipe.set_recipe(recipe_list)

    store.put(recipe)


def create_tiddler(store, bag, numeral):
    tiddler = Tiddler('tiddler%s' % numeral)
    tiddler.bag = bag.name
    tiddler.text = u'i am tiddler %s' % numeral
    tags = [u'basic tag']
    if not numeral % 2:
        tags.append(u'tagtwo')
    if not numeral % 3:
        tags.append(u'tagthree')
    if not numeral % 4:
        tags.append(u'tagfour')
    tiddler.tags = tags
    if tiddler.title == 'tiddler8':
        tiddler.modified = '200805230303'
    store.put(tiddler)


def create_bag(store, numeral):
    bag = Bag('bag%s' % numeral)
    store.put(bag)
    return bag


def get_http():
    """
    Get a httplib2 object, patched to provide a requestU method
    which returns decoded content.
    """
    def requestU(*args, **kwargs):
        self = args[0]
        args = args[1:]
        response, content = self.request(*args, **kwargs)
        return response, content.decode('utf-8')

    http = httplib2.Http()
    http.__class__.requestU = requestU
    return http

########NEW FILE########
__FILENAME__ = http_runner
"""
An HTTP test running. Call http_test with the filename
of a YAML file containing tests and a base_url for the
test server.
"""

from .fixtures import (muchdata, reset_textstore, _teststore, initialize_app,
        get_http)

from tiddlyweb.model.user import User

tests = store = base_url = None
http = get_http()

__all__ = ('http_test', 'test_assert_response', 'test_the_TESTS')


def http_test(test_data, base):
    global tests, store, base_url
    base_url = base
    tests = test_data
    initialize_app()
    reset_textstore()
    store = _teststore()
    muchdata(store)

    # we're going to need a user for testing auth stuff
    # so make that now
    user = User('cdent')
    user.set_password('cowpig')
    store.put(user)


def test_assert_response():
    """
    Make sure our assertion tester is valid.
    """
    response = {
            'status': '200',
            'location': 'http://example.com',
            }
    content = 'Hello World\n'
    status = '200'
    headers = {
            'location': 'http://example.com',
            }
    expected = ['Hello']

    assert_response(response, content, status, headers, expected)


EMPTY_TEST = {
        'name': '',
        'desc': '',
        'method': 'GET',
        'url': '',
        'status': '200',
        'request_headers': {},
        'response_headers': {},
        'expected': [],
        'data': '',
        }


def test_the_TESTS():
    """
    Run the entire TEST.
    """
    for test_data in tests:
        test = dict(EMPTY_TEST)
        test.update(test_data)
        yield test['name'], _run_test, test


def _run_test(test):
    full_url = base_url + test['url']
    if test['method'] == 'GET' or test['method'] == 'DELETE':
        response, content = http.requestU(full_url,
                method=test['method'],
                headers=test['request_headers'])
    else:
        response, content = http.requestU(full_url,
                method=test['method'],
                headers=test['request_headers'],
                body=test['data'].encode('UTF-8'))
    assert_response(response, content, test['status'],
            headers=test['response_headers'], expected=test['expected'])


def assert_response(response, content, status, headers=None, expected=None):
    if response['status'] == '500':
        print(content)
    assert response['status'] == '%s' % status, (response, content)

    if headers:
        for header in headers:
            assert response[header] == headers[header]

    if expected:
        for expect in expected:
            #assert expect.encode('UTF-8') in content
            assert expect in content

########NEW FILE########
__FILENAME__ = indexer
"""
A stub module providing an index_query method to test
the recipe indexer functionality.
"""

from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.filters import FilterIndexRefused


def index_query(environ, **kwords):
    store = environ['tiddlyweb.store']
    bag_name, tiddler_title = kwords['id'].split(':', 1)
    if bag_name == 'fwoop':
        if tiddler_title == 'swell':
            yield store.get(Tiddler('swell', 'fwoop'))
    raise FilterIndexRefused('bad stuff')

########NEW FILE########
__FILENAME__ = debug

"""
External serialization for testing remote module loading.
"""

from tiddlyweb.serializations import SerializationInterface


class Serialization(SerializationInterface):

    def list_recipes(self, recipes):
        print(recipes)

    def list_bags(self, bags):
        print(bags)

    def recipe_as(self, recipe):
        print("r_as: %s" % recipe)

    def as_recipe(self, recipe, input):
        print("as_r: %s" % input)

    def bag_as(self, bag):
        print("b_as: %s" % bag)

    def as_bag(self, bag, input):
        print("as_b: %s" % input)

    def tiddler_as(self, tiddler):
        print("t_as: %s" % tiddler)

    def as_tiddler(self, tiddler, input):
        print("as_t: %s" % input)

########NEW FILE########
__FILENAME__ = simpleplugin


class PluginHere(Exception):
    pass


def init(config):
    raise PluginHere()

########NEW FILE########
__FILENAME__ = test_bag

"""
Test the basics of bags.
"""

from tiddlyweb.model.bag import Bag
from tiddlyweb.model.policy import Policy

import py.test


def test_bag_create():
    """
    Confirm that Bag() requires a name argument.
    """
    py.test.raises(TypeError, "Bag()")


def test_bag_name():
    """
    Confirm the bag gets its name right.
    """
    bag = Bag('foobag')
    assert bag.name == 'foobag'
    bag_repr = '%s' % bag
    assert 'foobag:<tiddlyweb.model.bag.Bag' in bag_repr


def test_bag_has_policy():
    """
    Confirm a created bag gets a policy.
    """
    bag = Bag('heartfelt')

    assert bag.name == 'heartfelt'
    assert type(bag.policy) == Policy


def test_bag_has_description():
    """
    Confirm a bag can set and use a description.
    """
    bag = Bag('hasbeen', desc='monkey puzzle')

    assert bag.name == 'hasbeen'
    assert bag.desc == 'monkey puzzle'

    bag.desc = 'collapsing sideburns'
    assert bag.desc == 'collapsing sideburns'

########NEW FILE########
__FILENAME__ = test_bag_filtering
"""
Test that things work correctly when attempting to filter
the contents of a bag.
"""

from tiddlyweb.config import config
from tiddlyweb.filters import parse_for_filters
from tiddlyweb import control
from tiddlyweb.model.bag import Bag

from .fixtures import reset_textstore, tiddlers, get_store


def setup_module(module):
    reset_textstore()
    module.store = get_store(config)
    module.environ = {'tiddlyweb.config': config,
            'tiddlyweb.store': module.store}


def test_filter_bag_by_filter():
    """
    Confirm a bag will properly filter.
    """
    bagfour = Bag('bagfour')
    store.put(bagfour)
    bagfour.store = store
    for tiddler in tiddlers:
        tiddler.bag = 'bagfour'
        store.put(tiddler)

    filtered_tiddlers = list(control._filter_tiddlers_from_bag(bagfour,
        'select=title:TiddlerOne', environ=environ))
    assert len(filtered_tiddlers) == 1
    assert filtered_tiddlers[0].title == 'TiddlerOne'

    filtered_tiddlers = list(control._filter_tiddlers_from_bag(bagfour,
        'select=tag:tagone', environ=environ))
    assert len(filtered_tiddlers) == 2

    filters, thing = parse_for_filters(
            'select=tag:tagone;select=title:TiddlerThree', environ=environ)
    filtered_tiddlers = list(control._filter_tiddlers_from_bag(bagfour,
        filters, environ=environ))
    assert len(filtered_tiddlers) == 1
    assert filtered_tiddlers[0].title == 'TiddlerThree'

########NEW FILE########
__FILENAME__ = test_collection_tiddlers
"""
Start building tests for the concept of a tiddler collection,
which is likely a subclass of a generic collection.

A collection provides:

* way to add a thing
* way to get a hash of the things in it
* way to get stuff out
"""

from tiddlyweb.config import config
from tiddlyweb.model.collections import Collection, Tiddlers
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.model.bag import Bag

from .fixtures import reset_textstore, get_store


def setup_module(module):
    reset_textstore()
    module.store = get_store(config)


def test_create_collection():
    collection = Collection()
    assert isinstance(collection, Collection)


def test_collection_title():
    collection = Collection(u'barney')
    assert collection.title == u'barney'


def test_add_thing():
    collection = Collection()
    collection.add(u'monkey')
    assert u'monkey' in collection


def test_hash_things():
    collection = Collection()

    collection.add(u'monkey')
    assert u'monkey' in collection

    mdigest = collection.hexdigest()
    assert mdigest

    collection.add(u'cow')
    assert u'cow' in collection

    cdigest = collection.hexdigest()
    assert cdigest
    assert mdigest != cdigest


def test_get_things():
    collection = Collection()
    collection.add(u'monkey')
    collection.add(u'cow')
    all = list(collection)
    assert all == [u'monkey', u'cow']


def test_tiddler_collection():
    tiddlers = Tiddlers()
    n = 4
    for title in [u'how', u'now', u'cow']:
        n = n - 1
        tiddler = Tiddler(title, 'bag')
        tiddler.modified = n
        tiddlers.add(tiddler)
    modified = tiddlers.modified
    assert [u'how', u'now', u'cow'] == list(
            tiddler.title for tiddler in tiddlers)
    assert modified == '30000000000000'


def test_tiddler_racing():

    def race_tiddlers(bag_name, count=2, intitles=['x', 'z'],
            outtitles=['y']):
        bag = Bag(bag_name)
        store.put(bag)
        tiddlers = Tiddlers(store=store)

        for title in ['x', 'y', 'z']:
            tiddler = Tiddler(title, 'foo')
            store.put(tiddler)
            tiddlers.add(tiddler)

        tiddler = Tiddler('y', 'foo')
        store.delete(tiddler)

        tids = list(tiddlers)
        assert len(tids) == count
        for title in intitles:
            assert title in [tid.title for tid in tids]
        for title in outtitles:
            assert title not in [tid.title for tid in tids]

    stored_config = config.get('collections.use_memory')
    config['collections.use_memory'] = False
    race_tiddlers('foo')
    config['collections.use_memory'] = True
    race_tiddlers('bar', count=3, intitles=['x', 'y', 'z'], outtitles=[])
    store.delete(Bag('foo'))
    store.delete(Bag('bar'))
    config['collections.use_memory'] = stored_config


def test_tiddlers_container():
    tiddlers = Tiddlers()

    assert not tiddlers.is_search
    assert not tiddlers.is_revisions
    assert not tiddlers.bag
    assert not tiddlers.recipe

    tiddlers = Tiddlers(bag='foobar')
    assert tiddlers.bag == 'foobar'
    assert not tiddlers.recipe

    tiddlers = Tiddlers(recipe='foobar')
    assert tiddlers.recipe == 'foobar'
    assert not tiddlers.bag

########NEW FILE########
__FILENAME__ = test_commands
"""
Test the manager a little bit.
"""

import sys
try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

from .fixtures import reset_textstore

from tiddlyweb import __version__
from tiddlyweb.config import config
from tiddlyweb.manage import handle
from tiddlyweb.store import Store
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.model.user import User

BAG_STRING = """
{"desc": "hello", "policy": {}}
"""

RECIPE_STRING = """/bags/bag1/tiddlers
/bags/bag2/tiddlers
"""

TIDDLER_STRING = """modifier: cdent

Hello!
"""


def setup_module(module):
    reset_textstore()
    module.savedin = sys.stdin
    sys.exit = boring_exit
    module.store = Store(config['server_store'][0],
            config['server_store'][1],
            environ={'tiddlyweb.config': config})


class InternalExit(Exception):
    pass


def boring_exit(value):
    raise InternalExit()


def teardown_module(module):
    sys.stdin = module.savedin


def test_adduser():
    handle(['', u'adduser', u'cdent', u'crunk'])
    the_user = User('cdent')
    the_user = store.get(the_user)
    assert the_user.check_password('crunk')


def test_adduser_with_roles():
    handle(['', u'adduser', u'cdent', u'crunk', u'cow', u'monkey'])
    the_user = User('cdent')
    the_user = store.get(the_user)
    assert the_user.check_password('crunk')
    assert 'cow' in the_user.list_roles()
    assert 'monkey' in the_user.list_roles()


def test_addrole():
    handle(['', u'addrole', u'cdent', u'pig'])
    the_user = User('cdent')
    the_user = store.get(the_user)
    assert 'cow' in the_user.list_roles()


def test_userpass():
    handle(['', u'userpass', u'cdent', u'drunk'])
    the_user = User('cdent')
    the_user = store.get(the_user)
    assert the_user.check_password('drunk')


def test_bag():
    set_stdin(BAG_STRING)
    handle(['', u'bag', u'bag1'])

    the_bag = Bag('bag1')
    the_bag = store.get(the_bag)

    assert the_bag.name == 'bag1'
    assert the_bag.desc == 'hello'


def test_recipe():
    set_stdin(RECIPE_STRING)
    handle(['', u'recipe', u'recipe1'])

    the_recipe = Recipe('recipe1')
    the_recipe = store.get(the_recipe)

    assert the_recipe.name == 'recipe1'
    assert u'bag1' in the_recipe.get_recipe()[0]
    assert u'bag2' in the_recipe.get_recipe()[1]


def test_tiddler():
    set_stdin(TIDDLER_STRING)
    handle(['', u'tiddler', u'bag1', u'tiddler1'])

    the_tiddler = Tiddler('tiddler1', 'bag1')
    the_tiddler = store.get(the_tiddler)

    assert the_tiddler.title == 'tiddler1'
    assert the_tiddler.bag == u'bag1'
    assert the_tiddler.modifier == 'cdent'


def test_info(capsys):
    handle(['', 'info'])
    results, err = capsys.readouterr()
    assert 'current store is' in results
    assert __version__ in results


def test_server(capsys):
    import tiddlyweb.web.serve

    def start_server(config):
        print('host is %s' % config['server_host']['host'])

    tiddlyweb.web.serve.start_server = start_server
    handle(['', 'server'])
    results, err = capsys.readouterr()
    assert 'host is our_test_domain' in results

    handle(['', 'server', '192.168.1.1', '8001'])
    results, err = capsys.readouterr()
    assert 'host is 192.168.1.1' in results
    config['server_host']['host'] = 'our_test_domain'


def test_lusers(capsys):
    handle(['', 'lusers'])
    results, err = capsys.readouterr()
    # cdent user with role monkey was created above
    assert 'cdent' in results
    assert 'monkey' in results


def test_lbags(capsys):
    handle(['', u'lbags'])
    results, err = capsys.readouterr()
    assert 'Name: bag1' in results


def test_lrecipes(capsys):
    handle(['', u'lrecipes'])
    results, err = capsys.readouterr()
    assert 'recipe1 ' in results


def test_ltiddlers(capsys):
    handle(['', u'ltiddlers'])
    results, err = capsys.readouterr()
    assert 'bag1' in results
    assert '\ttiddler1' in results
    handle(['', 'ltiddlers', 'bag1'])
    results, err = capsys.readouterr()
    assert 'bag1' in results
    assert '\ttiddler1' in results


def set_stdin(content):
    f = StringIO(content)
    sys.stdin = f

########NEW FILE########
__FILENAME__ = test_control
"""
Tests for parts of control.py not otherwise covered by
tests.
"""

import py.test

from tiddlyweb.config import config
from tiddlyweb.store import NoBagError
from tiddlyweb.control import (determine_bag_for_tiddler,
        get_tiddlers_from_recipe, determine_bag_from_recipe,
        readable_tiddlers_by_bag)
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.model.tiddler import Tiddler

from .fixtures import get_store


def setup_module(module):
    module.environ = {'tiddlyweb.config': config}
    module.store = get_store(config)
    module.environ['tiddlyweb.store'] = module.store


def teardown_module(module):
    try:
        del config['indexer']
    except KeyError:
        pass


def test_determine_bag_for_tiddler():
    recipe = Recipe('example')
    recipe.set_recipe([
        ('bagone', u''),
        ('bagtwo', u'select=title:monkey')])

    tiddler = Tiddler('happy')

    bag = determine_bag_for_tiddler(recipe, tiddler)
    assert bag.name == 'bagone'

    tiddler = Tiddler('monkey')
    bag = determine_bag_for_tiddler(recipe, tiddler)
    assert bag.name == 'bagtwo'

    recipe.set_recipe([
        ('bagone', u'select=tag:foo'),
        ('bagtwo', u'select=title:monkeys')])

    py.test.raises(NoBagError, 'determine_bag_for_tiddler(recipe, tiddler)')


def test_bag_object_in_recipe():
    bag = Bag('fwoop')
    store.put(bag)
    tiddler = Tiddler('swell', 'fwoop')
    tiddler.text = 'hi'
    store.put(tiddler)

    recipe = Recipe('heyo')
    recipe.set_recipe([(bag, '')])
    recipe.store = store
    tiddlers = list(get_tiddlers_from_recipe(recipe, environ))
    assert len(tiddlers) == 1
    assert tiddlers[0].title == 'swell'
    assert tiddlers[0].bag == 'fwoop'


def test_index_query_in_recipe():
    config['indexer'] = 'test.indexernot'

    bag = Bag('noop')
    store.put(bag)
    tiddler = Tiddler('dwell', 'noop')
    store.put(tiddler)

    recipe = Recipe('coolio')
    recipe.set_recipe([('noop', u''), ('fwoop', u'')])
    recipe.store = store

    tiddler = Tiddler('swell')
    py.test.raises(ImportError,
            'determine_bag_from_recipe(recipe, tiddler, environ)')

    config['indexer'] = 'test.indexer'
    bag = determine_bag_from_recipe(recipe, tiddler, environ)
    assert bag.name == 'fwoop'

    tiddler = Tiddler('dwell')
    bag = determine_bag_from_recipe(recipe, tiddler, environ)
    assert bag.name == 'noop'

    tiddler = Tiddler('carnaby')  # nowhere
    py.test.raises(NoBagError,
            'determine_bag_from_recipe(recipe, tiddler, environ)')


def test_readable_tiddlers_by_bag():
    bagone = Bag('cdentread')
    bagone.policy.read = ['cdent']
    store.put(bagone)
    bagtwo = Bag('fndread')
    bagtwo.policy.read = ['fnd']
    store.put(bagtwo)
    bagthree = Bag('allread')
    store.put(bagthree)

    count = 0
    tiddlers = []
    for bag in ['cdent', 'fnd', 'all', 'cdent', 'fnd', 'all', 'notreal']:
        count += 1
        tiddler = Tiddler('tiddler%s' % count, '%sread' % bag)
        tiddler.text = 'narf'
        tiddlers.append(tiddler)

    usersign = {'name': 'cdent', 'roles': []}
    readable = list(readable_tiddlers_by_bag(store, tiddlers, usersign))
    assert (['tiddler1', 'tiddler3', 'tiddler4', 'tiddler6', 'tiddler7'] ==
            [tiddler.title for tiddler in readable])

    usersign = {'name': 'fnd', 'roles': []}
    readable = list(readable_tiddlers_by_bag(store, tiddlers, usersign))
    assert (['tiddler2', 'tiddler3', 'tiddler5', 'tiddler6', 'tiddler7'] ==
            [tiddler.title for tiddler in readable])

    usersign = {'name': 'GUEST', 'roles': []}
    readable = list(readable_tiddlers_by_bag(store, tiddlers, usersign))
    assert (['tiddler3', 'tiddler6', 'tiddler7'] ==
            [tiddler.title for tiddler in readable])

########NEW FILE########
__FILENAME__ = test_external_load
"""
Test handling of loading external stuff in twanager.
"""

from tiddlyweb.manage import handle
from tiddlyweb.config import config as global_config


config = {
        'monkey': 'bar',
        }


def test_load_file():
    handle(['twanager', '--load', 'test/test_external_load.py', 'info'])
    assert global_config['monkey'] == 'bar'


def test_load_module():
    handle(['twanager', '--load', 'test.test_external_load', 'info'])
    assert global_config['monkey'] == 'bar'

########NEW FILE########
__FILENAME__ = test_filter

"""
Test filtering tiddlers by the filter syntax which is not really
described just yet. Use this as the basis for building the basic
tiddler data store. And the rest of the underneath the web code.
"""


import copy

from tiddlyweb.filters import FilterError, parse_for_filters, recursive_filter
from tiddlyweb.model.tiddler import Tiddler

from .fixtures import tiddlers

import py.test

# cook up some bagged tiddlers
tiddlers = copy.deepcopy(tiddlers)
for tiddler in tiddlers:
    tiddler.bag = tiddler.title


def setup_module(module):
    pass


def test_filter_by_title():
    """
    Given a title and a list of
    tiddlers (or rather ducks that can title)
    return those that match the title.
    """

    found_tiddlers = list(filter('select=title:TiddlerOne', tiddlers))
    assert len(found_tiddlers) == 1
    assert found_tiddlers[0] == tiddlers[0]

    found_tiddlers = list(filter('select=title:TiddlerFive', tiddlers))
    assert len(found_tiddlers) == 0


def test_filter_by_since():
    """
    Get the tiddlers modified since <timespec>.
    """
    tiddler_old = Tiddler('old')
    tiddler_old.modified = '19691009000000'
    tiddler_new = Tiddler('new')
    tiddler_new.modified = '20090401030303'
    found_tiddlers = list(filter('select=modified:>20010101010100',
        [tiddler_old, tiddler_new]))
    assert len(found_tiddlers) == 1
    assert found_tiddlers[0].title == 'new'

    found_tiddlers = list(filter('select=modified:>200101010101',
        [tiddler_old, tiddler_new]))
    assert len(found_tiddlers) == 1
    assert found_tiddlers[0].title == 'new'

    found_tiddlers = list(filter('select=modified:<200101010101',
        [tiddler_old, tiddler_new]))
    assert len(found_tiddlers) == 1
    assert found_tiddlers[0].title == 'old'


def test_filter_by_tag():
    """
    Given a tag, find the tiddlers that use that tag.
    """
    found_tiddlers = list(filter('select=tag:tagone', tiddlers))
    assert len(found_tiddlers) == 2

    found_tiddlers = list(filter('select=tag:tagoe', tiddlers))
    assert len(found_tiddlers) == 0

    found_tiddlers = list(filter('select=tag:tagthree', tiddlers))
    assert len(found_tiddlers) == 1

    assert found_tiddlers[0].title == tiddlers[2].title


def test_filter_by_bag():
    """
    Given a bag, find the tiddlers that are in that bag.
    """

    found_tiddlers = list(filter('select=bag:TiddlerThree', tiddlers))
    assert len(found_tiddlers) == 1
    assert found_tiddlers[0].bag == 'TiddlerThree'

    found_tiddlers = list(filter('select=bag:NoHit', tiddlers))
    assert len(found_tiddlers) == 0


def test_negate_fitler_by_title():
    """
    Return those tiddlers which are not of provided title.
    """

    found_tiddlers = list(filter('select=title:!TiddlerOne', tiddlers))
    assert len(found_tiddlers) == 2


def test_sort_filter_by_title():
    """
    Get some tiddlers by a filter, and then sort them.
    """
    found_tiddlers = filter('sort=title', tiddlers)
    assert [tiddler.title for tiddler in found_tiddlers] == [
            'TiddlerOne', 'TiddlerThree', 'TiddlerTwo']


def test_sort_filter_by_bogus():
    """
    Attempt to sort by a field that does not exist. Get an error.
    """
    py.test.raises(FilterError, 'filter("sort=monkey", tiddlers)')


def test_count_filter():
    """
    Get some tiddlers by a filter, and then sort them.
    """
    found_tiddlers = filter('limit=2', tiddlers)
    assert [tiddler.title for tiddler in found_tiddlers] == [
            'TiddlerOne', 'TiddlerTwo']


def test_compose_filters():
    """
    Compose a list of filters and see that they do the right thing.
    """

    found_tiddlers = list(
            filter('select=tag:tagone;select=title:TiddlerThree', tiddlers))
    assert len(found_tiddlers) == 1


def test_compose_with_negate_filters():
    """
    Compose a list of filters and see that they do the right thing.
    """
    # this is only one because of the title check
    found_tiddlers = list(
            filter('select=tag:!tagtwo;select=title:TiddlerTwo', tiddlers))
    assert len(found_tiddlers) == 1


def test_empty_composed_filters():
    found_tiddlers = filter('', tiddlers)
    assert list(found_tiddlers) == tiddlers


def test_string_to_composed_filter_positive_tag():
    found_tiddlers = list(filter('select=tag:tagone', tiddlers))
    assert len(found_tiddlers) == 2
    assert 'TiddlerOne' in [tiddler.title for tiddler in found_tiddlers]
    assert 'TiddlerThree' in [tiddler.title for tiddler in found_tiddlers]


def test_string_to_composed_filter_positive_bag():
    found_tiddlers = list(filter('select=bag:TiddlerThree', tiddlers))
    assert len(found_tiddlers) == 1
    assert found_tiddlers[0].bag == 'TiddlerThree'
    assert found_tiddlers[0].title == 'TiddlerThree'


def test_string_to_composed_filter_negative_title():
    found_tiddlers = list(filter('select=title:!TiddlerOne', tiddlers))
    assert len(found_tiddlers) == 2
    assert 'TiddlerThree' in [tiddler.title for tiddler in found_tiddlers]
    assert 'TiddlerTwo' in [tiddler.title for tiddler in found_tiddlers]


def test_string_to_composed_filter_negative_tag():
    found_tiddlers = list(filter('select=tag:!tagthree', tiddlers))
    assert len(found_tiddlers) == 2
    assert 'TiddlerOne' in [tiddler.title for tiddler in found_tiddlers]
    assert 'TiddlerTwo' in [tiddler.title for tiddler in found_tiddlers]


def test_string_to_composed_filter_negative_bag():
    found_tiddlers = list(filter('select=bag:!TiddlerThree', tiddlers))
    assert len(found_tiddlers) == 2
    assert 'TiddlerOne' in [tiddler.title for tiddler in found_tiddlers]
    assert 'TiddlerTwo' in [tiddler.title for tiddler in found_tiddlers]


def test_string_composed_filter_with_spaces():
    """
    Test spaces in filter.
    """
    tiddlers = []
    for name in ['one', 'two', 'three']:
        tiddler = Tiddler('tiddler %s' % name)
        tiddler.text = name
        tiddlers.append(tiddler)

    found_tiddlers = list(filter('select=title:tiddler one', tiddlers))
    assert len(found_tiddlers) == 1
    assert found_tiddlers[0].title == 'tiddler one'


def test_string_composed_filter_with_sort():
    """
    Test sort composed string filter.
    """
    found_tiddlers = filter('sort=-title', tiddlers)
    assert [tiddler.title for tiddler in found_tiddlers] == [
            'TiddlerTwo', 'TiddlerThree', 'TiddlerOne']


def test_string_composed_filter_with_count():
    """
    Test count composed string filter.
    """
    found_tiddlers = filter('sort=-title;limit=2', tiddlers)
    assert [tiddler.title for tiddler in found_tiddlers] == [
            'TiddlerTwo', 'TiddlerThree']


def test_field_composed_filter():
    """
    Add a field to a tiddler and then make sure we can filter for it.
    """
    tiddler1 = Tiddler('one')
    tiddler1.fields = {'status': 'hot'}
    tiddler2 = Tiddler('two')
    tiddler2.fields = {'status': 'cold'}
    tiddler3 = Tiddler('three')

    found_tiddlers = filter('select=status:hot',
            [tiddler1, tiddler2, tiddler3])
    assert [tiddler.title for tiddler in found_tiddlers] == ['one']

    found_tiddlers = filter('select=status:!hot',
            [tiddler1, tiddler2, tiddler3])
    assert [tiddler.title for tiddler in found_tiddlers] == ['two', 'three']

    found_tiddlers = filter('select=status:cold',
            [tiddler1, tiddler2, tiddler3])
    assert [tiddler.title for tiddler in found_tiddlers] == ['two']

    found_tiddlers = filter('select=barnabas:monkey',
            [tiddler1, tiddler2, tiddler3])
    assert [tiddler.title for tiddler in found_tiddlers] == []

    found_tiddlers = filter('select=barnabas:!monkey',
            [tiddler1, tiddler2, tiddler3])
    assert [tiddler.title for tiddler in found_tiddlers] == [
            'one', 'two', 'three']


def filter(filter_string, tiddlers):
    return recursive_filter(parse_for_filters(filter_string)[0], tiddlers)

########NEW FILE########
__FILENAME__ = test_filtered_recipes
from tiddlyweb import control
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.recipe import Recipe

from .fixtures import reset_textstore, _teststore


def setup_module(module):
    reset_textstore()
    module.store = _teststore()


def test_in_a_recipe():
    bag = Bag('hi')
    store.put(bag)
    tiddler = Tiddler('thing1', 'hi')
    tiddler.tags = ['research']
    store.put(tiddler)
    tiddler = Tiddler('thing2', 'hi')
    store.put(tiddler)

    recipe1 = Recipe('oi')
    recipe1.set_recipe([('hi', 'select=tag:research')])
    recipe1.store = store
    recipe2 = Recipe('boi')
    recipe2.set_recipe([('hi', '')])
    recipe2.store = store
    environ = {'tiddlyweb.store': store}
    tiddlers = list(control.get_tiddlers_from_recipe(recipe1, environ))
    assert len(tiddlers) == 1
    tiddlers = list(control.get_tiddlers_from_recipe(recipe2, environ))
    assert len(tiddlers) == 2

########NEW FILE########
__FILENAME__ = test_json_perms

import simplejson

from tiddlyweb.serializer import Serializer
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.model.bag import Bag

from tiddlyweb.config import config

from .fixtures import get_store


def test_json_perms():
    store = get_store(config)
    bag = Bag('permstest')
    store.put(bag)
    serializer = Serializer('json', environ={'tiddlyweb.usersign': {
        'name': 'bang', 'roles': []}, 'tiddlyweb.config': config})
    tiddler = Tiddler('permstest', 'permstest')
    tiddler.text = 'permstest'
    store.put(tiddler)
    tiddler.store = store
    serializer.object = tiddler
    string = serializer.to_string()

    info = simplejson.loads(string)

    assert info['title'] == 'permstest'
    assert info['text'] == 'permstest'
    assert info['permissions'] == ['read', 'write', 'create', 'delete']

########NEW FILE########
__FILENAME__ = test_limit_filter
"""
Test the abilities of the limit filter.
This is not about query parsing, but rather
handling once we have the filter.
"""

import py.test

from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.filters.limit import limit
from tiddlyweb.filters import parse_for_filters, recursive_filter, FilterError

tiddlers = [Tiddler('1'), Tiddler('c'), Tiddler('a'), Tiddler('b')]


def test_simple_limit():
    limited_tiddlers = limit(tiddlers, count=2)

    assert ['1', 'c'] == [tiddler.title for tiddler in limited_tiddlers]


def test_ranged_limit():
    limited_tiddlers = limit(tiddlers, index=1, count=2)

    assert ['c', 'a'] == [tiddler.title for tiddler in limited_tiddlers]


def test_negative_limit():
    py.test.raises(ValueError, 'limit(tiddlers, index=-1, count=2)')


def test_exception():
    filter, _ = parse_for_filters('limit=-1,2')
    py.test.raises(FilterError, 'recursive_filter(filter, tiddlers)')

########NEW FILE########
__FILENAME__ = test_make_cookie
"""
Cover tiddlyweb.web.util.make_cookie.

It creates the string used to put in a Set-Cookie
header.
"""

import sys

from tiddlyweb.util import sha
from tiddlyweb.web.util import make_cookie


def test_cookie_name_value():
    string = make_cookie('test1', 'alpha1')

    assert string == 'test1=alpha1; httponly'


def test_unicode_cookie_value():
    string = make_cookie('tiddlyweb', u'\u3454')
    assert string == 'tiddlyweb=%E3%91%94; httponly'


def test_cookie_path():
    string = make_cookie('test2', 'alpha2', path='/path/to/location')

    assert string == 'test2=alpha2; Path=/path/to/location; httponly'

    string = make_cookie('test2', 'alpha2', path='/path/to/location',
            httponly=False)

    assert string == 'test2=alpha2; Path=/path/to/location'


def test_cookie_expire():
    string = make_cookie('test3', 'alpha3', expires=50)

    assert string == 'test3=alpha3; Max-Age=50; httponly'


def test_cookie_mac():
    string = make_cookie('test4', 'alpha4', mac_key='secret')

    secret_string = sha('%s%s' % ('alpha4', 'secret')).hexdigest()

    if sys.version_info[0] == 2:  # Cookie changed
        assert string == 'test4="alpha4:%s"; httponly' % secret_string
    else:
        assert string == 'test4=alpha4:%s; httponly' % secret_string


def test_cookie_domain():
    string = make_cookie('test5', 'alpha5', domain=".tiddlyspace.com")

    assert string == 'test5=alpha5; Domain=.tiddlyspace.com; httponly'

########NEW FILE########
__FILENAME__ = test_merge_config
"""
Test that merging config results in what's
expected when updating dicts. There had been some
problems in this area, so here we try to lay down
a bit of reality.
"""
from copy import deepcopy

from tiddlyweb.config import config as global_config
from tiddlyweb.util import merge_config


def setup_module(module):
    """
    Protect against py.test's new collection mechanism
    which carries about globals during the test collection phase.
    """
    if 'selector' in global_config:
        del global_config['selector']


def test_merge_sub_addition():
    config = deepcopy(global_config)
    new_config = {
            'serializers': {
                'text/bar': ['bar', 'type'],
            }
    }
    merge_config(config, new_config, reconfig=False)
    assert 'text/bar' in config['serializers']
    assert config['serializers']['text/bar'] == ['bar', 'type']
    assert 'text/html' in config['serializers']
    assert 'html' in config['serializers']['text/html']
    assert 'default_serializer' in config
    assert config['default_serializer'] == 'text/html'


def test_merge_sub_replace():
    config = deepcopy(global_config)
    new_config = {
            'serializers': {
                'text/html': ['bar', 'type'],
            }
    }
    merge_config(config, new_config, reconfig=False)
    assert 'text/html' in config['serializers']
    assert config['serializers']['text/html'] == ['bar', 'type']
    assert 'application/json' in config['serializers']
    assert 'json' in config['serializers']['application/json']
    assert 'default_serializer' in config
    assert config['default_serializer'] == 'text/html'


def test_merge_addition():
    config = deepcopy(global_config)
    new_config = {
            'extra': {
                'stuff': ['one', 'two'],
            }
    }
    merge_config(config, new_config, reconfig=False)
    assert 'extra' in config
    assert 'stuff' in config['extra']
    assert 'one' in config['extra']['stuff']


def test_merge_addition_double_over_no_twc():
    config = deepcopy(global_config)
    custom_config = {
            'nextra': {
                'show': ['three', 'four'],
                'stuff': ['five', 'six'],
            }
    }
    plugin_config = {
            'nextra': {
                'show': ['seven', 'eight']
            }
    }
    merge_config(config, custom_config, reconfig=False)
    assert 'nextra' in config
    assert 'stuff' in config['nextra']
    assert 'five' in config['nextra']['stuff']
    assert 'show' in config['nextra']
    assert 'three' in config['nextra']['show']
    merge_config(config, plugin_config, reconfig=False)
    assert 'nextra' in config
    assert 'stuff' in config['nextra']
    assert 'five' in config['nextra']['stuff']
    assert 'show' in config['nextra']
    assert 'seven' in config['nextra']['show']
    merge_config(config, custom_config, reconfig=False)
    assert 'show' in config['nextra']
    assert 'seven' not in config['nextra']['show']


def test_merge_addition_double_over_twc():
    new_config = {
            'extra': {
                'show': ['three', 'four'],
                'stuff': ['five', 'six'],
            }
    }
    merge_config(global_config, new_config)
    assert 'extra' in global_config
    assert 'stuff' in global_config['extra']
    assert 'one' in global_config['extra']['stuff']
    assert 'show' in global_config['extra']
    assert 'three' in global_config['extra']['show']

########NEW FILE########
__FILENAME__ = test_muchdata
"""
Make a big data store and see what we learn
from playing with it.
"""

import os

import py.test

import tiddlyweb.stores.text
from tiddlyweb.serializer import Serializer
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.recipe import Recipe
from tiddlyweb import control

from .fixtures import reset_textstore, muchdata, _teststore


def setup_module(module):
    reset_textstore()
    module.store = _teststore()
    if type(module.store.storage) != tiddlyweb.stores.text.Store:
        py.test.skip('skipping this test for non-text store')
    muchdata(module.store)


def test_many_bags_and_tiddlers():
    """
    Create a bunch of bags and tiddlers.
    """
    assert len(os.listdir('store/bags')) == 30
    assert len(os.listdir('store/bags/bag0/tiddlers')) == 10


def test_long_recipe():
    """
    Check muchdata() stored a recipe
    """
    assert os.path.exists('store/recipes/long')


def test_construct_from_recipe():
    """
    Make sure the tiddlywiki that results from
    a recipe has the right stuff in it.
    """

    recipe = Recipe('long')
    recipe = store.get(recipe)

    serializer = Serializer('html')
    serializer.object = recipe
    html_text = serializer.to_string()

    assert 'filter:select=title:tiddler8' in html_text


def test_get_tiddlers_from_bag():
    """
    Make sure a bag comes to life as expected.
    """
    bag = Bag('bag0')
    bag = store.get(bag)

    tiddlers = list(control.get_tiddlers_from_bag(bag))

    assert len(tiddlers) == 10
    text = ''
    for tiddler in tiddlers:
        store.get(tiddler)
        text += tiddler.text
    assert 'i am tiddler 4' in text


def test_filter_tiddlers_from_bag():
    """
    Make sure a bag comes to life and filters as expect.
    """
    bag = Bag('bag0')
    bag = store.get(bag)

    tiddlers = list(control._filter_tiddlers_from_bag(bag,
        'select=tag:tagfour', environ={'tiddlyweb.store': store}))
    assert len(tiddlers) == 3

########NEW FILE########
__FILENAME__ = test_parse_filter_query
"""
Experimental diddling around to make sure that
a CGI query string will become what we think it should.

This test file is a playground for the moment.
"""

from tiddlyweb.web.query import parse_for_filters
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.filters import recursive_filter


def test_parsing():
    """
    Incomplete testing of parsing the filter string
    as part of the query string parsing, leaving the rest
    of the query string intact.
    """
    string = 'slag=absolute;foo=;select=tag:systemConfig;select=tag:blog;fat=1;sort=-modified;limit=0,10;select=title:monkey'

    filters, leftovers = parse_for_filters(string)

    assert len(filters) == 5
    assert leftovers == 'slag=absolute;foo=;fat=1'

    text_filters = []
    for filter, text, environ in filters:
        text_filters.append(text)
    assert len(text_filters) == 5
    assert text_filters[0][1] == 'tag:systemConfig'
    assert text_filters[1][1] == 'tag:blog'
    assert text_filters[2][1] == '-modified'
    assert text_filters[3][1] == '0,10'

    tiddlers = [Tiddler('a'), Tiddler('monkey')]
    tiddlers[1].tags = ['systemConfig', 'blog']
    tiddlers = list(recursive_filter(filters, tiddlers))

    assert len(tiddlers) == 1
    assert tiddlers[0].title == 'monkey'

########NEW FILE########
__FILENAME__ = test_policy

"""
Test the creation and data handling of policies.
"""

from tiddlyweb.model.bag import Bag
from tiddlyweb.model.policy import (Policy, ForbiddenError,
        UserRequiredError, create_policy_check)

import py.test

jeremy_info = {'name': 'jeremy'}
chris_info = {'name': 'chris', 'roles': ['ADMIN']}
roller_info = {'name': 'chris', 'roles': ['ROLLER']}
none_info = {'name': 'NONE'}
barnabas_info = {'name': 'barnabas'}
randomer_info = {'name': 'randomer'}
boom_info = {'name': 'boom'}
guest_info = {'name': 'GUEST'}


def test_policy_create():
    policy = Policy()

    assert type(policy) == Policy
    assert policy.read == []
    assert policy.write == []
    assert policy.create == []
    assert policy.delete == []
    assert policy.manage == []


def test_policy_init_set():
    policy = Policy(read=['chris', 'jeremy'], write=['NONE'],
            manage=['chris'])

    assert policy.read == ['chris', 'jeremy']
    assert policy.write == ['NONE']
    assert policy.create == []
    assert policy.delete == []
    assert policy.manage == ['chris']


def test_policy_post_set():
    policy = Policy(read=['chris', 'jeremy'], write=['NONE'],
            manage=['chris'])

    assert policy.read == ['chris', 'jeremy']

    policy.read = ['one', 'tall']

    assert 'chris' not in policy.read
    assert 'jeremy' not in policy.read
    assert 'tall' in policy.read


def test_policy_allows():
    policy = Policy(read=['chris', 'jeremy'], write=['NONE'],
            delete=['R:ADMIN'], manage=['chris'])

    assert policy.allows(chris_info, 'read')
    assert policy.allows(chris_info, 'delete')
    assert policy.allows(jeremy_info, 'read')
    py.test.raises(ForbiddenError, 'policy.allows(jeremy_info, "write")')
    assert policy.allows(chris_info, 'manage')
    py.test.raises(ForbiddenError, 'policy.allows(jeremy_info, "manage")')
    assert policy.allows(chris_info, 'create')
    py.test.raises(ForbiddenError, 'policy.allows(none_info, "write")')
    py.test.raises(ForbiddenError, 'policy.allows(barnabas_info, "read")')
    py.test.raises(ForbiddenError, 'policy.allows(barnabas_info, "write")')
    assert policy.allows(barnabas_info, 'create')
    py.test.raises(ForbiddenError, 'policy.allows(barnabas_info, "manage")')


def test_policy_any():
    policy = Policy(read=['ANY'], write=['ANY'])
    assert policy.allows(randomer_info, 'read')
    assert policy.allows(boom_info, 'write')
    py.test.raises(UserRequiredError, 'policy.allows(guest_info, "read")')


def test_bag_policy():

    bag = Bag('policy_tester')
    bag.policy = Policy(read=['chris', 'jeremy'])

    assert bag.policy.allows(chris_info, 'read')
    py.test.raises(UserRequiredError, 'bag.policy.allows(guest_info, "read")')


def test_user_perms():
    policy = Policy()
    assert policy.user_perms(chris_info) == ['read', 'write',
            'create', 'delete']

    policy = Policy(read=['R:ADMIN'], write=['R:ADMIN'],
            create=['jeremy'], delete=['jeremy'])
    assert policy.user_perms(chris_info) == ['read', 'write']

    assert policy.user_perms(jeremy_info) == ['create', 'delete']


def test_create_policy_check():
    no_environ = {'tiddlyweb.config': {'bag_create_policy': ''}}
    all_environ = {'tiddlyweb.config': {'recipe_create_policy': ''}}
    any_environ = {'tiddlyweb.config': {'recipe_create_policy': 'ANY'}}
    admin_environ = {'tiddlyweb.config': {'recipe_create_policy': 'ADMIN'}}
    weird_environ = {'tiddlyweb.config': {'recipe_create_policy': 'WEIRD'}}

    py.test.raises(ForbiddenError,
            'create_policy_check(no_environ, "recipe", chris_info)')
    assert create_policy_check(all_environ, "recipe", chris_info)
    assert create_policy_check(any_environ, "recipe", chris_info)
    py.test.raises(UserRequiredError,
            'create_policy_check(any_environ, "recipe", {"name":"GUEST"})')
    assert create_policy_check(admin_environ, "recipe", chris_info)
    py.test.raises(ForbiddenError,
            'create_policy_check(admin_environ, "recipe", jeremy_info)')
    py.test.raises(ForbiddenError,
            'create_policy_check(admin_environ, "recipe", roller_info)')
    py.test.raises(ForbiddenError,
            'create_policy_check(weird_environ, "recipe", jeremy_info)')


def test_malformed_policy():
    policy = Policy()
    policy.read = None  # set the policy to a bad form
    assert policy.allows(guest_info, 'read')


def test_confirm_attributes():
    """Confirm the class attributes of a policy."""
    attributes = Policy.attributes
    for name in ['read', 'write', 'create', 'delete', 'accept',
            'manage', 'owner']:
        assert name in attributes


def test_policy_equal():
    policy1 = Policy()
    policy2 = Policy()
    policy1.owner = 'frank'
    policy1.read = ['cow', 'moo']
    policy2.owner = 'frank'
    policy2.read = ['cow', 'moo']

    assert policy1 == policy2

    policy2.read = ['cow', 'noo']

    assert policy1 != policy2

    policy2.read = ['cow', 'moo']
    policy2.owner = 'sam'

    assert policy1 != policy2

########NEW FILE########
__FILENAME__ = test_query
"""
Test extracting the QUERY_STRING into tiddlyweb.query.
Not much yet as it is just a directly mappen.
"""

from tiddlyweb.web.query import Query


def test_interpret_query():
    environ = {
            'QUERY_STRING':
                'hello=good%20bye&barney=ugly&special=nice',
            'REQUEST_METHOD': 'GET'
    }

    def app(environ, start_response):
        pass

    query = Query(app)
    query(environ, lambda x: x)

    assert environ['tiddlyweb.query']['hello'][0] == 'good bye'
    assert environ['tiddlyweb.query']['barney'][0] == 'ugly'
    assert environ['tiddlyweb.query']['special'][0] == 'nice'
    assert environ['tiddlyweb.query'].get('flip', [None])[0] is None

########NEW FILE########
__FILENAME__ = test_query_extract
"""
Test tiddlyweb.web.query's query_extract, especially
unicode handling.
"""

from tiddlyweb.web.query import Query

try:
    from StringIO import StringIO
except ImportError:
    from io import BytesIO as StringIO


def app(environ, start_response):
    pass


def test_operation_simple_get():
    q = Query(app)

    environ = {}
    environ['REQUEST_METHOD'] = 'GET'
    environ['QUERY_STRING'] = 'text=hello'

    q.extract_query(environ)
    assert 'text' in environ['tiddlyweb.query']
    assert environ['tiddlyweb.query']['text'][0] == 'hello'


def test_operation_encoded_get():
    q = Query(app)

    environ = {}
    environ['REQUEST_METHOD'] = 'GET'
    environ['QUERY_STRING'] = 'text=m%C3%B6ass'

    q.extract_query(environ)
    assert 'text' in environ['tiddlyweb.query']
    assert environ['tiddlyweb.query']['text'][0] == u'm\xf6ass'


def test_operation_simple_post():
    q = Query(app)
    post = StringIO()
    post_data = 'text=m%C3%B6ass'
    post.write(post_data.encode('UTF-8'))
    post.seek(0)
    environ = {}
    environ['CONTENT_LENGTH'] = 15
    environ['CONTENT_TYPE'] = 'application/x-www-form-urlencoded'
    environ['REQUEST_METHOD'] = 'POST'
    environ['wsgi.input'] = post
    q.extract_query(environ)
    assert 'text' in environ['tiddlyweb.query']
    assert environ['tiddlyweb.query']['text'][0] == u'm\xf6ass'

########NEW FILE########
__FILENAME__ = test_recipe
"""
Test a recipe to confirm it does all its recipe
things.
"""

from tiddlyweb.model.recipe import Recipe

recipe_list = [
        [u'bagone', u'select=title:TiddlerOne'],
        [u'bagtwo', u'select=title:TiddlerTwo'],
        [u'bagthree', u'select=tag:tagone;select=tag:tagthree']
]


def setup_module(module):
    module.recipe = Recipe(name='foorecipe')


def test_recipe_name():
    assert recipe.name == 'foorecipe', 'our recipe gets its name right'


def test_set_recipe():
    """
    Confirm setting the recipe to the contents of a list.
    """
    recipe.set_recipe(recipe_list)
    assert len(recipe.get_recipe()) == 3


def test_recipe_has_description():
    """
    Confirm a recipe can set and use a description.
    """
    recipe = Recipe('hasbeen', desc='monkey puzzle')

    assert recipe.name == 'hasbeen'
    assert recipe.desc == 'monkey puzzle'

    recipe.desc = 'collapsing sideburns'
    assert recipe.desc == 'collapsing sideburns'


def test_get_recipe_list():
    """
    Get a representation of the recipe, a list of bag + filter URLs.

    Note that you can just use the object itself if you want.
    """
    rlist = recipe.get_recipe()
    assert rlist == recipe_list


def test_get_recipe_list_templated_bag():
    recipe = Recipe('tr')
    recipe.set_recipe([('{{ user }}', '')])
    list = recipe.get_recipe({'user': 'testuser'})
    assert list[0][0] == 'testuser'


def test_get_recipe_list_templated_filter():
    recipe = Recipe('tr')
    recipe.set_recipe([('system', 'modifier={{ user }}')])
    list = recipe.get_recipe({'user': 'testuser'})
    assert list[0][1] == 'modifier=testuser'


def test_get_recipe_list_templated_filter2():
    recipe = Recipe('tr')
    recipe.set_recipe([('system', 'modifier={{ user }};creator={{ user }}')])
    list = recipe.get_recipe({'user': 'testuser'})
    assert list[0][1] == 'modifier=testuser;creator=testuser'


def test_get_recipe_list_templated_bag_filter():
    recipe = Recipe('tr')
    recipe.set_recipe([('{{ bagname }}', 'modifier={{ user }}')])
    list = recipe.get_recipe({'user': 'testuser', 'bagname': 'foobar'})
    assert list[0][1] == 'modifier=testuser'
    assert list[0][0] == 'foobar'


def test_get_recipe_list_templated_bag_filter_defaulted_bag():
    recipe = Recipe('tr')
    recipe.set_recipe([('{{ bagname:common }}', 'modifier={{ user }}')])
    list = recipe.get_recipe({'user': 'testuser'})
    assert list[0][1] == 'modifier=testuser'
    assert list[0][0] == 'common'


def test_recipe_policy():
    policy_recipe = Recipe(name='policed')
    # test them all even though only manage is really used
    policy_recipe.policy.manage = ['a']
    policy_recipe.policy.read = ['b']
    policy_recipe.policy.create = ['c']
    policy_recipe.policy.delete = ['d']
    policy_recipe.policy.owner = 'e'

    assert policy_recipe.policy.manage == ['a']
    assert policy_recipe.policy.read == ['b']
    assert policy_recipe.policy.create == ['c']
    assert policy_recipe.policy.delete == ['d']
    assert policy_recipe.policy.owner == 'e'

########NEW FILE########
__FILENAME__ = test_recipe_template
"""
test to ensure that extra template variables in the recipe
are picked up in control.recipe_template
"""
from tiddlyweb.control import recipe_template
from tiddlyweb.model.recipe import Recipe

environ = {
    'tiddlyweb.recipe_template': {
        'foo': 'bar'
    },
    'tiddlyweb.usersign': {
        'name': 'JohnSmith'
    }
}


def test_get_template_from_recipe_template():
    template = recipe_template(environ)
    assert template['user'] == 'JohnSmith'
    assert template['foo'] == 'bar'


def test_get_recipe():
    recipe = Recipe('templated')
    recipe.set_recipe([
        ('common', 'select=topic:{{ id:default }}'),
        ('{{ user }}', ''),
        ('system', '')
    ])

    stuff = recipe.get_recipe()
    assert stuff[0][1] == 'select=topic:{{ id:default }}'
    assert stuff[1][0] == '{{ user }}'

    filled = recipe.get_recipe(recipe_template(environ))
    assert filled[0][1] == 'select=topic:default'
    assert filled[1][0] == 'JohnSmith'

########NEW FILE########
__FILENAME__ = test_render_wikitext

from tiddlyweb.config import config
from tiddlyweb.model.tiddler import Tiddler

from tiddlyweb.wikitext import render_wikitext

import py


def setup_module(module):
    tiddler = Tiddler('foo')
    tiddler.text = '!Hello'
    module.tiddler = tiddler


def test_render_wikitext_plain():
    renderer = config['wikitext.default_renderer']
    config['wikitext.default_renderer'] = 'raw'
    text = render_wikitext(tiddler, {'tiddlyweb.config': config})
    config['wikitext.default_renderer'] = renderer

    assert '<h1' not in text
    assert '<pre>' in text


def test_render_no_config():
    text = render_wikitext(tiddler)
    assert '<pre>' in text
    assert '!Hello' in text


def test_renderer_not_found():
    renderer = config['wikitext.default_renderer']
    config['wikitext.default_renderer'] = 'monkey'
    py.test.raises(ImportError,
            'render_wikitext(tiddler, {"tiddlyweb.config":config})')
    config['wikitext.default_renderer'] = renderer


def test_renderer_type_not_found_does_raw():
    tiddler.type = 'fake/type'
    text = render_wikitext(tiddler)
    assert '!Hello' in text


def test_renderer_type_found_no_import():
    tiddler.type = 'image/gif'
    config['wikitext.type_render_map'][tiddler.type] = 'monkey'
    py.test.raises(ImportError,
            'render_wikitext(tiddler, {"tiddlyweb.config":config})')

########NEW FILE########
__FILENAME__ = test_roundtrip
"""
Flow through the entire process we might have.

* someone sends in a tiddler to be saved in a
  bag, thinking the bag exists
  * the bag is not there, throw something
* create a bag and store it
* store that tiddler
* get it back
* diddle it
* store it again, different bag

* someone has a tiddler, but doesn't
  know where it goes
  * find the proper bag via recipe
* save to the bag
* retrieve it again
"""

import os

import tiddlyweb.stores.text
from tiddlyweb.store import NoBagError
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.model.recipe import Recipe
from tiddlyweb import control

from .fixtures import reset_textstore, _teststore

import py.test

recipe_list = [
        ('bagone', u'select=title:TiddlerOne'),
        ('bagtwo', u'select=title:TiddlerTwo'),
        ('bagthree', u'select=tag:tagone;select=tag:tagthree')
]


def setup_module(module):
    reset_textstore()
    module.store = _teststore()
    if type(module.store.storage) != tiddlyweb.stores.text.Store:
        py.test.skip('skipping this test for non-text store')


def test_no_bag_for_tiddler():
    tiddler = Tiddler('testnobag')
    tiddler.text = 'no bag here'
    tiddler.bag = u'no bag of this name'

    py.test.raises(NoBagError, "store.put(tiddler)")


def test_put_and_get_tiddler():
    tiddler = Tiddler('testbag')
    tiddler.text = 'bag1 here'
    bag = Bag('bag1')
    tiddler.bag = u'bag1'

    store.put(bag)
    store.put(tiddler)

    new_tiddler = Tiddler('testbag')
    new_tiddler.bag = u'bag1'
    new_tiddler = store.get(new_tiddler)

    assert new_tiddler.text == 'bag1 here'


def test_get_diddle_put_tiddler():
    new_tiddler = Tiddler('testbag')
    new_tiddler.bag = u'bag1'
    new_tiddler = store.get(new_tiddler)

    new_tiddler.bag = u'bag2'
    new_tiddler.text = 'bag2 here'

    py.test.raises(NoBagError, "store.put(new_tiddler)")

    bag = Bag('bag2')
    store.put(bag)

    store.put(new_tiddler)

    assert os.path.exists('store/bags/bag2/tiddlers/testbag')
    assert os.path.exists('store/bags/bag1/tiddlers/testbag')


def test_tiddler_unique_by_bags():
    tiddler_one = Tiddler('testbag')
    tiddler_one.bag = 'bag1'
    tiddler_two = Tiddler('testbag')
    tiddler_two.bag = 'bag2'

    assert tiddler_one.text == tiddler_two.text == '', \
            'empty tiddlers have equally empty content'

    tiddler_one = store.get(tiddler_one)
    tiddler_two = store.get(tiddler_two)

    assert tiddler_one.text != tiddler_two.text, \
            'empty tiddlers have different content'


def test_put_recipe():
    recipe = Recipe('cookies')
    recipe.set_recipe(recipe_list)

    store.put(recipe)

    assert os.path.exists('store/recipes/cookies')


def test_where_this_tiddler():
    """
    recipe bag determination presumes there is a tiddler of the same name
    already in the bag. Is this right or not? Seems like maybe we want to
    put the bag in the collection if it matches the filter stream.
    """
    tiddler_lonely = Tiddler('TiddlerOne')
    tiddler_lonely.text = 'tiddlerincookiesyay'

    recipe = Recipe('cookies')
    recipe = store.get(recipe)

    bag = control.determine_bag_for_tiddler(recipe, tiddler_lonely)

    assert bag.name == 'bagone'

    tiddler_lonely.bag = bag.name
    try:
        store.put(tiddler_lonely)
    except NoBagError:
        store.put(bag)
        store.put(tiddler_lonely)

    assert os.path.exists('store/bags/bagone/tiddlers/TiddlerOne')

########NEW FILE########
__FILENAME__ = test_select_filter
"""
Tests on select style filters.
"""

from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.filters.select import (select_by_attribute,
        select_relative_attribute, ATTRIBUTE_SELECTOR)

tiddlers = [Tiddler('1'), Tiddler('c'), Tiddler('a'), Tiddler('b')]

tags = ['foo', 'bar', 'foo', 'baz']
dates = ['200905090011', '20090509000000', '2008', '2007']
for i, tiddler in enumerate(tiddlers):
    tiddler.tags.append(tags[i])
    tiddler.modified = dates[i]
    tiddler.fields['index'] = str(i)


def has_year(tiddler, attribute, value):
    return tiddler.modified.startswith(value)


ATTRIBUTE_SELECTOR['year'] = has_year


def test_simple_select():
    selected_tiddlers = select_by_attribute('tag', 'foo', tiddlers)

    assert ['1', 'a'] == [tiddler.title for tiddler in selected_tiddlers]


def test_negate_select():
    selected_tiddlers = select_by_attribute('tag', 'foo',
            tiddlers, negate=True)
    assert ['c', 'b'] == [tiddler.title for tiddler in selected_tiddlers]


def test_simple_sorted_select():
    selected_tiddlers = select_relative_attribute('title', 'c',
            tiddlers, lesser=True)
    assert ['1', 'a', 'b'] == [tiddler.title for tiddler in selected_tiddlers]


def test_relative_missing_args():
    """If we forget to set lesser or greater, then we want it all."""
    selected_tiddlers = select_relative_attribute('title', 'c', tiddlers)
    assert ['1', 'c', 'a', 'b'] == [tiddler.title for tiddler in
            selected_tiddlers]


def test_sorted_select():
    selected_tiddlers = select_relative_attribute('modified', '2009',
            tiddlers, greater=True)
    assert ['1', 'c'] == [tiddler.title for tiddler in selected_tiddlers]


def test_custom_select():
    selected_tiddlers = select_by_attribute('year', '2009',
            tiddlers)
    assert ['1', 'c'] == [tiddler.title for tiddler in selected_tiddlers]
    selected_tiddlers = select_by_attribute('year', '2000',
            tiddlers)
    assert [] == [tiddler.title for tiddler in selected_tiddlers]
    selected_tiddlers = select_by_attribute('year', '2009',
            tiddlers, negate=True)
    assert ['a', 'b'] == [tiddler.title for tiddler in selected_tiddlers]


def test_field_exists_select():
    selected_tiddlers = select_by_attribute('field', 'index', tiddlers)
    assert ['1', 'c', 'a', 'b'] == [tiddler.title for tiddler in
            selected_tiddlers]


def test_field_not_exists_select():
    selected_tiddlers = select_by_attribute('field', 'barney',
            tiddlers, negate=True)
    results = [tiddler.title for tiddler in selected_tiddlers]
    assert ['1', 'c', 'a', 'b'] == results


def test_field_not_exists_empty_select():
    selected_tiddlers = select_by_attribute('field', 'index',
            tiddlers, negate=True)
    assert [] == [tiddler.title for tiddler in selected_tiddlers]


def test_sorted_field_select():
    selected_tiddlers = select_relative_attribute('index', '2',
            tiddlers, greater=True)
    assert ['b'] == [tiddler.title for tiddler in selected_tiddlers]


def test_sorted_field_select_no_exist():
    selected_tiddlers = select_relative_attribute('indix', '2',
            tiddlers, greater=True)
    assert [] == [tiddler.title for tiddler in selected_tiddlers]

########NEW FILE########
__FILENAME__ = test_serializer

"""
Confirm the serializer knows how to fail
to load a module.
"""

import py.test

from tiddlyweb.serializer import Serializer


def setup_module(module):
    pass


def test_module_load_fail():
    py.test.raises(ImportError,
            'serializer = Serializer("notexistserialization")')


def test_load_module_on_other_path():
    serializer = Serializer("test.other.tiddlyweb.serializations.debug")
    assert type(serializer) == Serializer


def test_wrong_class():
    class Foo(object):
        pass

    foo = Foo()
    serializer = Serializer('text')
    serializer.object = foo
    string = 'haha'

    py.test.raises(AttributeError, 'serializer.to_string()')
    py.test.raises(AttributeError, 'serializer.from_string(string)')

########NEW FILE########
__FILENAME__ = test_serialize_bag

"""
Test turning a bag into other forms.
"""

import simplejson

from tiddlyweb.serializer import Serializer
from tiddlyweb.model.bag import Bag
from tiddlyweb.config import config

from .fixtures import bagfour, tiddler_collection, reset_textstore


def setup_module(module):
    reset_textstore()


def test_generate_json():
    serializer = Serializer('json')
    bagfour.desc = 'a tasty little bag'
    bagfour.policy.manage = ['NONE']
    serializer.object = bagfour
    string = serializer.to_string()

    json = simplejson.loads(string)
    assert json['policy']['manage'] == ['NONE']
    assert json['desc'] == 'a tasty little bag'


def test_generated_string():
    serializer = Serializer('text')
    string = ''.join(serializer.list_tiddlers(tiddler_collection))

    assert 'TiddlerOne' in string
    assert 'TiddlerTwo' in string
    assert 'TiddlerThree' in string


def test_generated_string_with_revbag():
    serializer = Serializer('text')
    tiddler_collection.is_revisions = True
    string = ''.join(serializer.list_tiddlers(tiddler_collection))

    # XXX: Check for presense of ':'. The value of the revision
    # changes based on test ordering.
    assert 'TiddlerOne:' in string
    assert 'TiddlerTwo:' in string
    assert 'TiddlerThree:' in string
    tiddler_collection.is_revisions = False


def test_generated_html():
    html_serializer = Serializer('html')
    string = html_serializer.list_tiddlers(tiddler_collection)
    assert (
        '<li><a href="/bags/bagfour/tiddlers/TiddlerOne">TiddlerOne</a></li>'
        in string)


def test_generated_html_with_prefix():
    new_config = config.copy()
    new_config['server_prefix'] = '/salacious'
    environ = {'tiddlyweb.config': new_config}
    html_serializer = Serializer('html', environ)
    string = html_serializer.list_tiddlers(tiddler_collection)

    assert (
        '<li><a href="/salacious/bags/bagfour/tiddlers/TiddlerOne">TiddlerOne</a></li>'
        in string)


def test_json_to_bag():
    serializer = Serializer('json')
    json_string = simplejson.dumps(dict(policy=dict(read=['user1'],
        manage=['NONE']), desc='simply the best'))
    newbag = Bag('bagho')
    serializer.object = newbag
    serializer.from_string(json_string)

    assert newbag.name == 'bagho'
    assert newbag.policy.read == ['user1']
    assert newbag.policy.manage == ['NONE']
    assert newbag.desc == 'simply the best'


def test_text_list():
    serializer = Serializer('text')
    bags = [Bag('bag' + str(name)) for name in range(2)]
    string = ''.join(serializer.list_bags(bags))

    assert 'bag0' in string
    assert 'bag1' in string


def test_html_list():
    serializer = Serializer('html')
    bags = [Bag('bag' + str(name)) for name in range(2)]
    string = ''.join(serializer.list_bags(bags))

    assert 'href="bags/bag0' in string
    assert 'href="bags/bag1' in string

########NEW FILE########
__FILENAME__ = test_serialize_recipe

"""
Test turning a recipe into other forms.
"""

import pytest
import sys
py_version = sys.version_info[0]

from tiddlyweb.model.recipe import Recipe
from tiddlyweb.serializer import Serializer


recipe_list = [
        ('bagone', u'select=title:TiddlerOne'),
        ('bagtwo', u'select=title:TiddlerTwo'),
        ('bagthree', u'select=tag:tagone;select=tag:tagthree')
]

expected_string = """desc: 
policy: {"read": [], "create": [], "manage": [], "accept": [], "write": [], "owner": null, "delete": []}

/bags/bagone/tiddlers?select=title:TiddlerOne
/bags/bagtwo/tiddlers?select=title:TiddlerTwo
/bags/bagthree/tiddlers?select=tag:tagone;select=tag:tagthree"""

no_desc = """/bags/bagone/tiddlers?select=title:TiddlerOne
/bags/bagtwo/tiddlers?select=title:TiddlerTwo
/bags/bagthree/tiddlers?select=tag:tagone;select=tag:tagthree"""

expected_html_string = """<div id="recipedesc" class="description">Courage of Bags</div>
<ul id="recipe" class="listing">
<li><a href="/bags/bagone/tiddlers?select=title:TiddlerOne">bag: bagone filter:select=title:TiddlerOne</a></li>
<li><a href="/bags/bagtwo/tiddlers?select=title:TiddlerTwo">bag: bagtwo filter:select=title:TiddlerTwo</a></li>
<li><a href="/bags/bagthree/tiddlers?select=tag:tagone;select=tag:tagthree">bag: bagthree filter:select=tag:tagone;select=tag:tagthree</a></li>
</ul>"""


def setup_module(module):
    module.recipe = Recipe(name='testrecipe')
    module.recipe.set_recipe(recipe_list)


@pytest.mark.skipif(py_version > 2, reason='python 2 required')
def test_generated_text():
    serializer = Serializer('text')
    serializer.object = recipe
    string = serializer.to_string()

    assert string == expected_string
    assert '%s' % serializer == expected_string


def test_simple_recipe():
    recipe = Recipe('other')
    recipe.set_recipe([('bagbuzz', '')])
    recipe.policy.manage = ['a']
    recipe.policy.read = ['b']
    recipe.policy.create = ['c']
    recipe.policy.delete = ['d']
    recipe.policy.owner = 'e'
    serializer = Serializer('text')
    serializer.object = recipe
    string = serializer.to_string()

    new_recipe = Recipe('other')
    serializer.object = new_recipe
    serializer.from_string(string)

    assert recipe.get_recipe() == new_recipe.get_recipe()

    recipe = Recipe('other')
    recipe.set_recipe([('bagboom', '')])
    assert recipe != new_recipe


def test_json_recipe():
    """
    JSON serializer roundtrips.
    """
    recipe = Recipe('other')
    recipe.set_recipe([('bagbuzz', '')])
    recipe.policy.manage = ['a']
    recipe.policy.read = ['b']
    recipe.policy.create = ['c']
    recipe.policy.delete = ['d']
    recipe.policy.owner = 'e'
    serializer = Serializer('json')
    serializer.object = recipe
    string = serializer.to_string()

    other_recipe = Recipe('other')
    serializer.object = other_recipe
    serializer.from_string(string)

    serializer.object = other_recipe
    other_string = serializer.to_string()

    assert string == other_string


@pytest.mark.skipif(py_version > 2, reason='python 2 required')
def test_old_text():
    """
    Send in text without a description
    and make sure we are able to accept it.
    """
    recipe = Recipe('other')
    serializer = Serializer('text')
    serializer.object = recipe
    serializer.from_string(no_desc)

    output = serializer.to_string()

    assert output == expected_string


def test_generated_html():
    serializer = Serializer('html')
    recipe.desc = 'Courage of Bags'
    serializer.object = recipe
    string = serializer.to_string()

    assert expected_html_string in string
    assert expected_html_string in '%s' % serializer


def test_text_list():
    serializer = Serializer('text')
    recipes = [Recipe('recipe' + str(name)) for name in range(2)]
    string = ''.join(serializer.list_recipes(recipes))

    assert string == 'recipe0\nrecipe1\n'


def test_html_list():
    serializer = Serializer('html')
    recipes = [Recipe('recipe' + str(name)) for name in range(2)]
    string = ''.join(serializer.list_recipes(recipes))

    assert 'href="recipes/recipe0' in string
    assert 'href="recipes/recipe1' in string

########NEW FILE########
__FILENAME__ = test_serialize_tiddler
"""
Test turning a tiddler into other forms.
"""

import simplejson
import pytest

from base64 import b64encode

from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.serializer import Serializer, TiddlerFormatError
from tiddlyweb.config import config

expected_string = """creator: test@example.com
created: 
modifier: test@example.com
modified: 200803030303
tags: foobar [[foo bar]]
type: 

Hello, I'm the content.
"""

# cosmic rays have injected noise into this tiddler string
bad_string = """modifiXr: test@example.com
modiFied: 200803030303
tags:foobar [[foo bar]]

Hello, I'm the content.
"""

expected_json_string = '{"created": "", "text": "Hello, I\'m the content.", "modifier": "test@example.com", "modified": "200803030303", "tags": ["foobar", "foo bar"]}'

tiddler = Tiddler('test tiddler')
tiddler.bag = 'snoop'
tiddler.modifier = 'test@example.com'
tiddler.tags = ['foobar', 'foo bar']
tiddler.text = "Hello, I'm the content."
tiddler.modified = '200803030303'


def test_generated_txt_string():
    serializer = Serializer('text')
    serializer.object = tiddler
    string = serializer.to_string()

    assert string == expected_string
    assert '%s' % serializer == expected_string


def test_bad_string_raises():
    serializer = Serializer('text')
    foobar = Tiddler('foobar')
    serializer.object = foobar

    pytest.raises(TiddlerFormatError, 'serializer.from_string(bad_string)')


def test_generated_json_string():
    serializer = Serializer('json', environ={'tiddlyweb.config': config})
    serializer.object = tiddler
    string = serializer.to_string()

    info = simplejson.loads(string)

    assert info['title'] == 'test tiddler'
    assert info['text'] == "Hello, I'm the content."
    assert info['uri'] == '%s://%s:%s/bags/snoop/tiddlers/test%%20tiddler' % (
            config['server_host']['scheme'],
            config['server_host']['host'],
            config['server_host']['port'])


def test_tiddler_from_json():
    serializer = Serializer('json')
    tiddler = Tiddler('test tiddler')
    serializer.object = tiddler
    serializer.from_string(expected_json_string)

    assert tiddler.title == 'test tiddler'
    assert tiddler.text == "Hello, I'm the content."


def test_tiddler_html_encode():
    serializer = Serializer('html')
    tiddler = Tiddler('jeremy found a bug')
    tiddler.bag = u'foo'
    tiddler.text = u'"Hello." I\'m > than 5 & < you.'
    serializer.object = tiddler
    string = serializer.to_string()

    assert '"Hello." I\'m &gt; than 5 &amp; &lt; you.' in string


def test_html_attribute_escape():
    tiddler = Tiddler(
            'escape "double" quotes & &amp; in <tiddler> field values')
    tiddler.bag = u'foo "bar" baz'
    tiddler.modifier = 'Chris "sensei" Dent'
    tiddler.tags = ["foo", 'xxx "yyy" zzz']
    tiddler.fields["custom"] = u"""lorem 'ipsum' dolor "sit" amet"""
    tiddler.text = ''
    serializer = Serializer('html')
    serializer.object = tiddler
    string = serializer.to_string()

    assert r'''title="escape &quot;double&quot; quotes &amp; &amp;amp; in &lt;tiddler&gt; field values"''' in string
    assert r'''modifier="Chris &quot;sensei&quot; Dent"''' in string
    assert r'''tags="foo [[xxx &quot;yyy&quot; zzz]]"''' in string
    assert r'''custom="lorem 'ipsum' dolor &quot;sit&quot; amet"''' in string


def test_tiddler_json_base64():
    serializer = Serializer('json', environ={'tiddlyweb.config': config})
    tiddler = Tiddler('binarytiddler')
    tiddler.bag = u'foo'
    with open('test/peermore.png', 'rb') as image_file:
        tiddler.text = image_file.read()
    bininfo = tiddler.text
    b64expected = b64encode(bininfo)
    tiddler.type = 'image/png'
    serializer.object = tiddler
    string = serializer.to_string()
    info = simplejson.loads(string)
    assert info['text'] == b64expected.decode('utf-8')

    tiddler = serializer.from_string(string)
    assert tiddler.text == bininfo

    info['text'] = '..badbinary..'
    string = simplejson.dumps(info)
    pytest.raises(TiddlerFormatError, 'serializer.from_string(string)')


def test_tiddler_json_render():
    serializer = Serializer('json', environ={'tiddlyweb.query': {
        'render': [1]}, 'tiddlyweb.config': config})
    tiddler = Tiddler('htmltest')
    tiddler.text = '!Hi\n//you//'
    tiddler.bag = 'snoop'

    serializer.object = tiddler

    output = serializer.to_string()
    info = simplejson.loads(output)
    assert info['render'] == '<pre>\n!Hi\n//you//</pre>\n'
    assert info['text'] == '!Hi\n//you//'


def test_tiddler_json_render_skinny():
    serializer = Serializer('json', environ={'tiddlyweb.query': {
        'render': ['1'], 'fat': ['0']}, 'tiddlyweb.config': config})
    tiddler = Tiddler('htmltest')
    tiddler.bag = 'snoop'
    tiddler.text = '!Hi\n//you//'

    serializer.object = tiddler

    output = serializer.to_string()
    info = simplejson.loads(output)
    assert info['render'] == '<pre>\n!Hi\n//you//</pre>\n'
    pytest.raises(KeyError, "info['text']")


def test_tiddler_no_text():
    serializer = Serializer('text')
    tiddler = Tiddler('hello')
    serializer.object = tiddler
    header, body = serializer.to_string().split('\n\n')
    assert 'None' not in body

########NEW FILE########
__FILENAME__ = test_sort_filter
"""
Test the abilities of the sort filter.
This is not about query parsing, but rather
handling once we have the filter.
"""

import py.test

from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.filters.sort import sort_by_attribute, ATTRIBUTE_SORT_KEY


ATTRIBUTE_SORT_KEY['count'] = int

tiddlers = [Tiddler('1'), Tiddler('c'), Tiddler('a'), Tiddler('b')]
numbs = [5, 24, 13, 8]
dates = ['200905090011', '20090509000000', '2008', '2007']
for i, tiddler in enumerate(tiddlers):
    tiddler.fields['count'] = '%s' % numbs[i]
    tiddler.modified = dates[i]


def test_simple_sort():
    sorted_tiddlers = sort_by_attribute('title', tiddlers)
    assert ['1', 'a', 'b', 'c'] == [
            tiddler.title for tiddler in sorted_tiddlers]


def test_reverse_sort():
    sorted_tiddlers = sort_by_attribute('title', tiddlers, reverse=True)
    assert ['c', 'b', 'a', '1'] == [
            tiddler.title for tiddler in sorted_tiddlers]


def test_count_sort():
    sorted_tiddlers = sort_by_attribute('count', tiddlers)
    assert ['5', '8', '13', '24'] == [tiddler.fields['count']
            for tiddler in sorted_tiddlers]


def test_modified_sort():
    sorted_tiddlers = sort_by_attribute('modified', tiddlers)

    assert ['2007', '2008', '20090509000000', '200905090011'] == [
            tiddler.modified for tiddler in sorted_tiddlers]


def test_modifier_sort():
    py.test.raises(AttributeError,
            'sort_by_attribute("blam", tiddlers, reverse=True)')

########NEW FILE########
__FILENAME__ = test_specialbag
"""
Get coverage on specialbag handling.
"""

from tiddlyweb.config import config
from tiddlyweb.control import get_tiddlers_from_recipe
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.model.tiddler import Tiddler

from .fixtures import get_store


def get_x_tiddlers(environ, name):
    for title in ['alpha', 'beta', 'gamma']:
        yield Tiddler(title, name)


def get_x_tiddler(environ, tiddler):
    tiddler.text = tiddler.title
    return tiddler


def spector(environ, bagname):
    """
    Simple special bag detector.
    """
    def curry(environ, func):
        def actor(bag):
            return func(environ, bag)
        return actor

    if bagname.startswith('X'):
        return (curry(environ, get_x_tiddlers),
                curry(environ, get_x_tiddler))
    return None


def setup_module(module):
    config['special_bag_detectors'] = [spector]
    module.store = get_store(config)


def test_two_bags():
    bag_normal = Bag('normal')
    store.put(bag_normal)
    tiddler_normal = Tiddler('thing', 'normal')
    tiddler_normal.text = 'hi'
    store.put(tiddler_normal)

    tiddlers = store.list_bag_tiddlers(bag_normal)
    assert 'thing' in [tiddler.title for tiddler in tiddlers]

    bag_special = Bag('Xnine')
    tiddlers = store.list_bag_tiddlers(bag_special)
    assert 'alpha' in [tiddler.title for tiddler in tiddlers]
    tiddler = Tiddler('alpha', 'Xnine')
    tiddler = store.get(tiddler)
    assert tiddler.text == 'alpha'


def test_recipe_with_special():
    recipe = Recipe('special')
    recipe.set_recipe([
        ('normal', ''),
        ('Xnine', '')])
    recipe.store = store

    environ = {'tiddlyweb.config': config}
    tiddlers = list(get_tiddlers_from_recipe(recipe, environ))

    assert len(tiddlers) == 4
    assert 'thing' in [tiddler.title for tiddler in tiddlers]
    assert 'alpha' in [tiddler.title for tiddler in tiddlers]
    assert 'beta' in [tiddler.title for tiddler in tiddlers]
    assert 'gamma' in [tiddler.title for tiddler in tiddlers]

    # roundtrip the recipes with a special
    store.put(recipe)
    recipe2 = store.get(Recipe('special'))

    assert recipe.get_recipe() == recipe2.get_recipe()

########NEW FILE########
__FILENAME__ = test_store

"""
Confirm the store knows how to fail
to load a module.
"""

import py.test

from tiddlyweb.config import config
from tiddlyweb.store import Store

from .fixtures import get_store


def test_module_load_fail():
    py.test.raises(ImportError, 'store = Store("notexiststore")')


def test_unsupported_class():

    class Foo(object):
        pass

    foo = Foo()
    store = get_store(config)
    py.test.raises(AttributeError, 'store.put(foo)')

########NEW FILE########
__FILENAME__ = test_store_bag
"""
Store and retrieve a bag.

See about doing this lazily.
"""

import os

import py.test

import tiddlyweb.stores.text

from tiddlyweb.store import NoBagError
from tiddlyweb.model.bag import Bag

from .fixtures import tiddlers, bagone, reset_textstore, _teststore


def setup_module(module):
    reset_textstore()
    module.store = _teststore()


def test_simple_put():
    bagone.desc = 'I enjoy being stored'
    store.put(bagone)

    if type(store.storage) != tiddlyweb.stores.text.Store:
        py.test.skip('skipping this test for non-text store')

    assert os.path.exists('store/bags/bagone')
    assert os.path.exists('store/bags/bagone/policy')
    assert os.path.exists('store/bags/bagone/description')
    assert os.path.exists('store/bags/bagone/tiddlers')


def test_simple_get():

    tiddler = tiddlers[0]
    tiddler.bag = u'bagone'
    store.put(tiddler)

    bag = Bag(name='bagone')
    bag = store.get(bag)

    the_tiddler = next(store.list_bag_tiddlers(bag))
    assert bag.policy.read == bagone.policy.read
    assert bag.policy.write == bagone.policy.write
    assert bag.policy.create == bagone.policy.create
    assert bag.policy.delete == bagone.policy.delete
    assert bag.policy.manage == bagone.policy.manage
    assert bag.policy.owner == bagone.policy.owner
    assert bag.desc == 'I enjoy being stored'

    the_tiddler = store.get(the_tiddler)
    assert the_tiddler.title == tiddler.title
    assert sorted(the_tiddler.tags) == sorted(tiddler.tags)


def test_failed_get():
    bag = Bag(name='bagnine')
    py.test.raises(NoBagError, 'store.get(bag)')


def test_delete():
    bag = Bag('deleteme')
    bag.desc = 'delete me please'
    store.put(bag)

    stored_bag = Bag('deleteme')
    stored_bag = store.get(stored_bag)
    assert stored_bag.desc == 'delete me please'

    deleted_bag = Bag('deleteme')
    store.delete(deleted_bag)

    py.test.raises(NoBagError, 'store.get(deleted_bag)')
    py.test.raises(NoBagError, 'store.delete(deleted_bag)')


def test_list():
    bag = Bag('bagtwo')
    store.put(bag)
    bags = list(store.list_bags())

    assert len(bags) == 2
    assert u'bagone' in [bag.name for bag in bags]
    assert u'bagtwo' in [bag.name for bag in bags]

########NEW FILE########
__FILENAME__ = test_store_hooks

from tiddlyweb.config import config
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.store import HOOKS

from .fixtures import get_store


OUTPUT = ''


def recipe_put_hook(store, recipe):
    global OUTPUT
    OUTPUT += 'recipe put hook ahoy! %s' % recipe.name


def recipe_get_hook(store, recipe):
    global OUTPUT
    OUTPUT += 'recipe get hook ahoy! %s' % recipe.name


def setup_module(module):
    HOOKS['recipe']['put'].append(recipe_put_hook)
    HOOKS['recipe']['get'].append(recipe_get_hook)


def teardown_module(module):
    HOOKS['recipe']['put'].remove(recipe_put_hook)
    HOOKS['recipe']['get'].remove(recipe_get_hook)


def test_put_recipe():
    global OUTPUT
    assert OUTPUT == ''
    store = get_store(config)
    recipe = Recipe('keen')
    store.put(recipe)
    store.get(recipe)
    assert 'recipe put hook ahoy' in OUTPUT
    assert 'recipe get hook ahoy' in OUTPUT

########NEW FILE########
__FILENAME__ = test_store_recipe
"""
Exploratory testing for storing recipes.

"""

import os

import sys

import py.test

import tiddlyweb.stores.text

from tiddlyweb.model.recipe import Recipe
from tiddlyweb.store import NoRecipeError

from .fixtures import reset_textstore, _teststore

expected_stored_filename = os.path.join('store', 'recipes', 'testrecipe')

recipe_list_string = [
        [u'bagone', u'select=title:TiddlerOne'],
        [u'bagtwo', u'select=title:TiddlerTwo'],
        [u'bagthree', u'select=tag:tagone;select=tag:tagthree']
]

expected_stored_content = """desc: I enjoy being stored
policy: {"read": [], "create": [], "manage": [], "accept": [], "write": [], "owner": null, "delete": []}

/bags/bagone/tiddlers?select=title:TiddlerOne
/bags/bagtwo/tiddlers?select=title:TiddlerTwo
/bags/bagthree/tiddlers?select=tag:tagone;select=tag:tagthree"""


def setup_module(module):
    """
    Need to clean up the store here.
    """
    reset_textstore()
    module.store = _teststore()


def test_recipe_put():
    """
    put a recipe to disk and make sure it is there.
    """

    recipe = Recipe('testrecipe')
    recipe.desc = 'I enjoy being stored'
    recipe.set_recipe(recipe_list_string)
    store.put(recipe)

    if type(store.storage) != tiddlyweb.stores.text.Store:
        py.test.skip('skipping this test for non-text store')

    assert os.path.exists(expected_stored_filename)

    with open(expected_stored_filename) as f:
        content = f.read()

    if sys.version_info[0] < 3:
        assert content == expected_stored_content


def test_recipe_get():
    """
    get a recipe from disk and confirm it has proper form.
    """

    stored_recipe = Recipe('testrecipe')
    stored_recipe = store.get(stored_recipe)

    assert stored_recipe.get_recipe() == recipe_list_string


def test_recipe_delete():
    recipe = Recipe('deleteme')
    recipe.desc = 'delete me please'
    store.put(recipe)

    stored_recipe = Recipe('deleteme')
    stored_recipe = store.get(stored_recipe)
    assert stored_recipe.desc == 'delete me please'

    deleted_recipe = Recipe('deleteme')
    store.delete(deleted_recipe)

    py.test.raises(NoRecipeError, 'store.get(deleted_recipe)')
    py.test.raises(NoRecipeError, 'store.delete(deleted_recipe)')


def test_recipe_no_recipe():
    """
    make a sure a recipe that is stored without a recipe is retrievable
    """
    recipe = Recipe('testrecipe2')
    recipe.desc = 'I enjoy being stored'
    store.put(recipe)

    stored_recipe = Recipe('testrecipe2')
    stored_recipe = store.get(stored_recipe)

    assert stored_recipe.desc == recipe.desc


def test_list():
    recipe = Recipe('testrecipe3')
    store.put(recipe)
    recipes = list(store.list_recipes())

    assert len(recipes) == 3
    assert u'testrecipe' in [recipe.name for recipe in recipes]
    assert u'testrecipe2' in [recipe.name for recipe in recipes]
    assert u'testrecipe3' in [recipe.name for recipe in recipes]


def test_recipe_weird_bag():
    recipe = Recipe('weirdbags')
    recipe.set_recipe([
        ('foo/bar', ''),
        ('zam/boom', ''),
    ])
    store.put(recipe)

    new_recipe = Recipe('weirdbags')
    new_recipe = store.get(new_recipe)
    bags = [bag for bag, filter in new_recipe.get_recipe()]
    assert bags == ['foo/bar', 'zam/boom']


def test_recipe_bad_name():
    recipe = Recipe('../badname')
    py.test.raises(NoRecipeError, 'store.put(recipe)')
    py.test.raises(NoRecipeError, 'store.get(recipe)')

########NEW FILE########
__FILENAME__ = test_store_search

from tiddlyweb.model.bag import Bag
from tiddlyweb.model.tiddler import Tiddler

from .fixtures import reset_textstore, muchdata, _teststore

name = u'boom\u00BB\u00BBboom'


def setup_module(module):
    reset_textstore()
    module.store = _teststore()
    muchdata(store)


def test_simple_search():
    tiddlers = list(store.search('i am tiddler 0'))

    assert len(tiddlers) > 0
    assert type(tiddlers[0]) == Tiddler
    assert tiddlers[0].text is u''


def test_unicode_search():
    bag = Bag(name)
    store.put(bag)

    tiddler = Tiddler('barney', name)
    tiddler.text = name

    store.put(tiddler)

    tiddlers = list(store.search(name))

    assert len(tiddlers) == 1

########NEW FILE########
__FILENAME__ = test_store_tiddler
"""
Exploratory testing for storing tiddlers.

Prequisites:

    * We know which bag this tiddler belongs to.
    * We've already established authorization to write.

"""

import os

from tiddlyweb.store import StoreLockError, NoTiddlerError, NoBagError
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.stores.text import Store as Texter
from tiddlyweb.util import write_lock, LockError

from .fixtures import tiddlers, reset_textstore, _teststore

import py.test

expected_stored_filename = os.path.join('store', 'bags', 'bagone',
    'tiddlers', 'TiddlerOne', '1')

expected_stored_text = """modifier: AuthorOne
modified: 200803030303
tags: tagone tagtwo [[tag five]]

c tiddler one content
"""


def setup_module(module):
    """
    Need to clean up the store here.
    """
    reset_textstore()
    module.store = _teststore()


def test_simple_put():
    """
    put a tiddler to disk and make sure it is there.
    """
    bagone = Bag('bagone')
    store.put(bagone)

    tiddler = tiddlers[0]
    tiddler.bag = bagone.name
    tiddler.tags = ['tagone', 'tagtwo', 'tag five']
    tiddler.modified = '200803030303'
    store.put(tiddler)

    if type(store.storage) != Texter:
        py.test.skip('skipping this test for non-text store')

    assert os.path.exists(expected_stored_filename)

    with open(expected_stored_filename) as fh:
        text = fh.read()

    assert text == expected_stored_text


def test_simple_get():
    """
    get a tiddler that had been stored
    """
    stored_tiddler = Tiddler('TiddlerOne')
    stored_tiddler.bag = u'bagone'
    stored_tiddler.modified = '200803030303'
    stored_tiddler = store.get(stored_tiddler)

    assert stored_tiddler.title == 'TiddlerOne'
    assert stored_tiddler.bag == 'bagone'
    assert stored_tiddler.text == 'c tiddler one content'

    assert sorted(stored_tiddler.tags) == ['tag five', 'tagone', 'tagtwo']


def test_get_revision():
    """
    Test we are able to retrieve a particular revision.
    """
    bagone = Bag('bagone')

    store.put(bagone)
    tiddler = Tiddler('RevisionTiddler')
    tiddler.text = 'how now 1'
    tiddler.bag = u'bagone'
    store.put(tiddler)
    tiddler.text = 'how now 2'
    store.put(tiddler)
    tiddler.text = 'how now 3'
    store.put(tiddler)

    tiddler = Tiddler('RevisionTiddler', 'bagone')
    tiddler = store.get(tiddler)

    assert tiddler.text == 'how now 3'
    assert tiddler.revision == 3

    tiddler = Tiddler('RevisionTiddler', 'bagone')
    tiddler.revision = 2
    tiddler = store.get(tiddler)

    assert tiddler.text == 'how now 2'
    assert tiddler.revision == 2

    revisions = store.list_tiddler_revisions(tiddler)
    assert len(revisions) == 3
    assert revisions[0] == 3


def test_delete():
    tiddler = Tiddler('RevisionTiddler', 'bagone')

    if type(store.storage) != Texter:
        py.test.skip('skipping this test for non-text store')

    assert os.path.exists(os.path.join('store', 'bags', 'bagone',
        'tiddlers', 'RevisionTiddler'))
    store.delete(tiddler)
    assert not os.path.exists(os.path.join('store', 'bags', 'bagone',
        'tiddlers', 'RevisionTiddler'))


def test_failed_delete_not_there():
    tiddler = Tiddler('RevisionTiddler', 'bagone')
    # in case we skipped deleting it above, delete it again
    try:
        store.delete(tiddler)
    except NoTiddlerError:
        pass
    py.test.raises(NoTiddlerError, 'store.delete(tiddler)')


def test_failed_delete_perms():
    tiddler = Tiddler('TiddlerOne', 'bagone')

    if type(store.storage) != Texter:
        py.test.skip('skipping this test for non-text store')

    path = os.path.join('store', 'bags', 'bagone', 'tiddlers', 'TiddlerOne')
    assert os.path.exists(path)
    os.chmod(path, 0o555)
    py.test.raises(IOError, 'store.delete(tiddler)')
    os.chmod(path, 0o755)


def test_store_lock():
    """
    Make the sure the locking system throws the proper lock.
    """
    if type(store.storage) != Texter:
        py.test.skip('skipping this test for non-text store')

    write_lock('store/bags')
    py.test.raises(LockError, 'write_lock("store/bags")')

    write_lock('store/bags' + '/bagone/tiddlers/foobar')
    tiddler = Tiddler('foobar')
    tiddler.text = 'hello'
    tiddler.bag = u'bagone'
    py.test.raises(StoreLockError, 'store.put(tiddler)')


def test_put_with_slash():
    tiddler1 = Tiddler('He is 5 and 1/2', 'bagone')
    store.put(tiddler1)

    tiddler2 = Tiddler('He is 5 and 1/2', 'bagone')
    store.get(tiddler2)
    assert tiddler1.title == tiddler2.title


def test_put_no_bag():
    tiddler = Tiddler('hi')
    py.test.raises(NoBagError, 'store.put(tiddler)')


def test_bad_filename():
    """
    If there is ../ in the tiddler name, choke.
    """
    if type(store.storage) != Texter:
        py.test.skip('skipping this test for non-text store')
    tiddler = Tiddler('../nastyone', 'bagone')
    py.test.raises(NoTiddlerError, 'store.put(tiddler)')


def test_put_and_get_dotted_file():
    """
    store and retrieve a file beginning with '.'
    """
    tiddlers0 = list(store.list_bag_tiddlers(Bag('bagone')))
    tiddler1 = Tiddler('.profile', 'bagone')
    tiddler1.text = 'alias ls ls -a'
    tiddler1.tags = ['foo']
    store.put(tiddler1)
    tiddlers1 = list(store.list_bag_tiddlers(Bag('bagone')))

    tiddler2 = Tiddler('.profile', 'bagone')
    tiddler2 = store.get(tiddler2)

    assert tiddler1.title == tiddler2.title
    assert tiddler1.text == tiddler2.text
    assert tiddler1.tags == tiddler2.tags
    assert tiddler2.text == 'alias ls ls -a'
    assert tiddler2.tags == ['foo']

    assert len(tiddlers1) == len(tiddlers0) + 1

########NEW FILE########
__FILENAME__ = test_store_user

import os

import py.test

import tiddlyweb.stores.text

from tiddlyweb.store import NoUserError
from tiddlyweb.model.user import User

from .fixtures import reset_textstore, _teststore

expected_stored_filename = os.path.join('store', 'users', 'cdent')


def setup_module(module):
    reset_textstore()
    module.store = _teststore()


def test_simple_put():
    user = User('cdent', note='foo')
    user.set_password('cowpig')
    user.add_role('ADMIN')
    user.add_role('BOSS')
    store.put(user)

    if type(store.storage) != tiddlyweb.stores.text.Store:
        py.test.skip('skipping this test for non-text store')

    assert os.path.exists(expected_stored_filename)


def test_simple_get():
    user = User('cdent')
    user = store.get(user)

    assert user.note == 'foo'
    assert user.check_password('cowpig')
    assert sorted(user.list_roles()) == ['ADMIN', 'BOSS']
    assert not user.check_password('pigcow')


def test_failed_get():
    py.test.raises(NoUserError, 'store.get(User("nothere"))')


def test_list_users():
    user1 = User('test1')
    user2 = User('test2')
    store.put(user1)
    store.put(user2)

    users = list(store.list_users())
    assert len(users) == 3
    usernames = [user.usersign for user in users]
    assert 'test1' in usernames
    assert 'test2' in usernames
    assert 'cdent' in usernames
    assert 'laramie' not in usernames


def test_delete_users():
    user = User('test1')
    store.delete(user)

    users = list(store.list_users())
    assert len(users) == 2
    usernames = [user.usersign for user in users]
    assert 'test1' not in usernames


def test_delete():
    user = User('deleteme')
    user.note = 'delete me please'
    store.put(user)

    stored_user = User('deleteme')
    stored_user = store.get(stored_user)
    assert stored_user.note == 'delete me please'

    deleted_user = User('deleteme')
    store.delete(deleted_user)

    py.test.raises(NoUserError, 'store.get(deleted_user)')
    py.test.raises(NoUserError, 'store.delete(deleted_user)')


def test_complex_username():
    username = u'test\u00BB\u00BBuser.com/foo'
    user = User(username)
    store.put(user)

    users = list(store.list_users())
    assert username in [user.usersign for user in users]

    user_out = User(username)
    user_out = store.get(user_out)
    assert user_out.usersign == username

########NEW FILE########
__FILENAME__ = test_text_filter
"""
Tests for a [text[<string>]] style filter.
"""


from tiddlyweb import control
from tiddlyweb.model.bag import Bag

from .fixtures import muchdata, reset_textstore, _teststore


def setup_module(module):
    reset_textstore()
    module.store = _teststore()
    muchdata(module.store)


def test_filter_by_text():
    bag = Bag('bag0')
    bag = store.get(bag)

    bags_tiddlers = list(store.list_bag_tiddlers(bag))
    assert len(bags_tiddlers) == 10

    found_tiddlers = list(control._filter_tiddlers_from_bag(
        bag, 'select=text:tiddler 0',
        environ={'tiddlyweb.store': store}))
    assert len(found_tiddlers) == 1
    assert found_tiddlers[0].title == 'tiddler0'


def test_filter_by_text_string():
    bag = Bag('bag0')
    bag = store.get(bag)

    bags_tiddlers = list(store.list_bag_tiddlers(bag))
    assert len(bags_tiddlers) == 10

    found_tiddlers = list(control._filter_tiddlers_from_bag(
        bag, 'select=text:tiddler 0',
        environ={'tiddlyweb.store': store}))
    assert len(found_tiddlers) == 1
    assert found_tiddlers[0].title == 'tiddler0'


def test_filter_by_text_string_negate():
    bag = Bag('bag0')
    bag = store.get(bag)

    bags_tiddlers = list(store.list_bag_tiddlers(bag))
    assert len(bags_tiddlers) == 10

    found_tiddlers = list(control._filter_tiddlers_from_bag(bag,
        'select=text:!tiddler 0',
        environ={'tiddlyweb.store': store}))
    assert len(found_tiddlers) == 9

########NEW FILE########
__FILENAME__ = test_text_store_fields
"""
Fields which match tiddler attributes can result
in clobbering those tiddler attributes.
"""

import pytest

from tiddlyweb.model.bag import Bag
from tiddlyweb.model.tiddler import Tiddler

from tiddlyweb.serializer import TiddlerFormatError

from .fixtures import reset_textstore, _teststore


def setup_module(module):
    reset_textstore()
    module.store = _teststore()


def test_title_fields():
    store.put(Bag('abag'))

    tiddler = Tiddler('one', 'abag')
    tiddler.text = 'hi'
    tiddler.fields = {'title': 'two'}

    assert tiddler.title == 'one'
    assert tiddler.fields['title'] == 'two'

    pytest.raises(TiddlerFormatError, 'store.put(tiddler)')


def test_unicode_field_keys():
    tiddler = Tiddler('two', 'abag')
    tiddler.text = 'hi'
    tiddler.fields = {u'h\u8976': 'two'}

    assert tiddler.fields[u'h\u8976'] == 'two'

    store.put(tiddler)

    tiddler = store.get(Tiddler('two', 'abag'))
    assert tiddler.fields[u'h\u8976'] == 'two'

########NEW FILE########
__FILENAME__ = test_tiddler

"""
Test tiddler, a simple data container for a tiddler.
"""

import datetime

from tiddlyweb.model.tiddler import (Tiddler, current_timestring,
        tags_list_to_string, string_to_tags_list, timestring_to_datetime)

test_tiddler_text = "Race car drivers\ngo really very fast."


def setup_module(module):
    pass


def test_tiddler_create():
    tiddler = Tiddler('hello')

    assert type(tiddler) == Tiddler, ('Tiddler returns a Tiddler, %s, %s'
            % (type(tiddler), Tiddler))
    assert 'hello<tiddlyweb.model.tiddler.Tiddler object' in '%s' % tiddler


def test_tiddler_full_create():
    """
    Confirm we can populate a tiddler at create time.
    """

    tiddler = Tiddler('test tiddler')
    tiddler.modifier = 'test@example.com'
    tiddler.text = test_tiddler_text
    tiddler.tags = ['foo', 'bar']
    tiddler.bag = u'bagone'

    assert type(tiddler) == Tiddler, \
            'Tiddler returns a Tiddler'
    assert tiddler.title == 'test tiddler', \
            'tiddler title should be test tiddler, got %s' \
            % tiddler.title
    assert tiddler.modifier == 'test@example.com', \
            'tiddler modifier should test@example.com, got %s' \
            % tiddler.modifier
    assert tiddler.text == test_tiddler_text, \
            'tiddler content is correct'
    assert tiddler.tags == ['foo', 'bar'], \
            'tiddler tags are correct'
    assert tiddler.bag == 'bagone', \
            'tiddler has a bag of bagone'
    assert tiddler.revision is None, \
            'tiddler revision is None'
    assert tiddler.creator == 'test@example.com'


def test_tiddler_revision_create():
    """
    Confirm that when we set revision in a new Tiddler,
    we are able to retrieve that attribute.
    """

    tiddler = Tiddler('test tiddler r')
    tiddler.text = 'revision test'
    tiddler.revision = 5

    assert type(tiddler) == Tiddler, \
            'Tiddler returns a Tiddler'
    assert tiddler.revision == 5, \
            'revision is set as expected, to 5'


def test_current_timestring():
    """
    Confirm timestring has desired format and is at least in
    the ballpark of now.
    """

    current_time = datetime.datetime.utcnow()
    year = current_time.year
    month = current_time.month
    timestring = current_timestring()

    assert len(timestring) == 14
    assert timestring.startswith('%d%02d' % (year, month))


def test_tags_list_to_string():
    """
    Confirm that tags format as TiddlyWiki likes them.
    """
    tags = ['alpha', 'beta', 'Gamma Fire', 'troll']

    output = tags_list_to_string(tags)

    assert output == 'alpha beta [[Gamma Fire]] troll'

    assert sorted(string_to_tags_list(output)) == sorted(tags)


def test_timestring_to_datetime():
    """
    Confirm a timestring becomes the expected datetime object.
    """
    timestring = '20130711154400'
    date_object = timestring_to_datetime(timestring)

    assert date_object.year == 2013
    assert date_object.month == 7
    assert date_object.day == 11
    assert date_object.hour == 15
    assert date_object.minute == 44
    assert date_object.second == 00

########NEW FILE########
__FILENAME__ = test_tiddlers_fields
"""
Test extended fields on tiddlers.
Some tiddlers have additional fields what we don't
know about ahead of time, but we'd like to handle.
Most straightforward things to do here seems to be
to do what TiddlyWiki does: have a fields field.
"""


import simplejson

from tiddlyweb.config import config
from tiddlyweb.serializer import Serializer
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.model.bag import Bag

from .fixtures import reset_textstore, _teststore


def setup_module(module):
    reset_textstore()
    module.store = _teststore()


def test_tiddler_has_fields():
    tiddler = Tiddler('feebles')
    assert hasattr(tiddler, 'fields')


def test_tiddler_fields_dict():
    tiddler = Tiddler('feebles')
    assert type(tiddler.fields) == dict


def test_tiddler_fields_contains_stuff():
    tiddler = Tiddler('feebles')
    tiddler.fields = {u'this': u'is cool', u'so': u'is that'}
    assert tiddler.fields['this'] == 'is cool'
    assert tiddler.fields['so'] == 'is that'


def test_tiddler_fields_are_stored():
    bag = Bag('bag0')
    store.put(bag)
    tiddler = Tiddler('feebles', bag='bag0')
    tiddler.fields = {u'field1': u'value1', u'field2': u'value2'}
    store.put(tiddler)

    tiddler_second = Tiddler('feebles', bag='bag0')
    tiddler_second = store.get(tiddler_second)
    assert tiddler_second.fields['field1'] == 'value1'
    assert tiddler_second.fields['field2'] == 'value2'


def test_tiddler_fields_ignore_server():
    bag = Bag('bag0')
    store.put(bag)
    tiddler = Tiddler('server\nimpostor', bag='bag0')
    tiddler.tags = [u'foo\nbar']
    tiddler.fields = {u'field1': u'value1\nafterlinefeed',
            u'server.host': u'value1', u'server.type': u'value2'}
    store.put(tiddler)

    tiddler_second = Tiddler('server\nimpostor', bag='bag0')
    tiddler_second = store.get(tiddler_second)
    assert tiddler_second.fields['field1'] == 'value1\nafterlinefeed'
    assert 'server.host' not in tiddler_second.fields.keys()
    assert 'server.type' not in tiddler_second.fields.keys()


# these following rely on the previous
def test_tiddler_fields_as_text():
    tiddler = Tiddler('feebles', bag='bag0')
    tiddler = store.get(tiddler)
    serializer = Serializer('text')
    serializer.object = tiddler
    text_of_tiddler = serializer.to_string()
    assert 'field1: value1\n' in text_of_tiddler
    assert 'field2: value2\n' in text_of_tiddler


def test_tiddler_fields_as_json():
    tiddler = Tiddler('feebles', bag='bag0')
    tiddler = store.get(tiddler)
    serializer = Serializer('json', environ={'tiddlyweb.config': config})
    serializer.object = tiddler
    json_string = serializer.to_string()
    tiddler_info = simplejson.loads(json_string)
    assert tiddler_info['fields']['field1'] == 'value1'
    assert tiddler_info['fields']['field2'] == 'value2'
    assert tiddler_info['bag'] == 'bag0'

    tiddler = Tiddler('new feebles', bag='bag0')
    serializer.object = tiddler
    serializer.from_string(json_string)

    assert tiddler.fields['field1'] == 'value1'
    assert tiddler.fields['field2'] == 'value2'
    assert tiddler.bag == 'bag0'


def test_tiddler_fields_as_html():
    tiddler = Tiddler('feebles', bag='bag0')
    tiddler = store.get(tiddler)
    serializer = Serializer('html')
    serializer.object = tiddler
    wiki_string = serializer.to_string()

    assert 'field1="value1"' in wiki_string
    assert 'field2="value2"' in wiki_string
    assert 'title="feebles"' in wiki_string

#def test_fields_in_tiddler_put():
#def test_fields_in_tiddler_get():

########NEW FILE########
__FILENAME__ = test_tiddler_fields_as_strings
"""
Make sure that tiddler fields which are not strings
are stringified, otherwise, the text serialization will
assplode.
"""

from tiddlyweb.serializer import Serializer
from tiddlyweb.model.tiddler import Tiddler


def test_float_field():
    tiddler = Tiddler('foo', 'bar')
    tiddler.fields['float'] = 100.5

    serializer = Serializer('text')
    serializer.object = tiddler
    assert '100.5' in '%s' % serializer

########NEW FILE########
__FILENAME__ = test_tiddler_slash
"""
Test using / in names and titles.
"""


from tiddlyweb.model.bag import Bag
from tiddlyweb.model.tiddler import Tiddler

from .fixtures import reset_textstore, _teststore


def setup_module(module):
    reset_textstore()


def test_tiddler_title_with_slash():
    store = _teststore()
    bag = Bag('bag/puss')
    store.put(bag)
    tiddler = Tiddler('hello/monkey')
    tiddler.bag = u'bag/puss'
    tiddler.text = 'artifice'

    assert tiddler.title == 'hello/monkey'

    store.put(tiddler)

    tiddler2 = Tiddler('hello/monkey')
    tiddler2.bag = u'bag/puss'

    tiddler2 = store.get(tiddler2)

    assert tiddler2.title == 'hello/monkey'
    assert tiddler2.text == 'artifice'

########NEW FILE########
__FILENAME__ = test_urlmap
#!/usr/bin/env python

import selector
import string
import simplejson

# test_the_TESTS required to make tests go
from .http_runner import http_test, test_the_TESTS


def fixup(pattern):
    for replaceme in ['^', '\\', '(', ')', '?', '$', '[/]+', '[/.]+', '>']:
        pattern = pattern.replace(replaceme, '')
    pattern = pattern.replace('P<', '$')
    pattern = pattern.replace('.$format', '')
    return pattern


def filled_pattern(pattern):
    template = string.Template(pattern)
    info = {
            'recipe_name': 'recipeurlmap1',
            'tiddler_name': 'tiddlerurlmap1',
            'bag_name': 'bagurlmap1',
            'revision': '1',
            'challenger': 'cookie_form',
            }
    return template.substitute(**info)


def data_from_pattern(pattern):
    data = {}
    if '$recipe_name' in pattern:
        if '$tiddler_name' in pattern:
            data['text'] = 'oh hai'
        else:
            data['recipe'] = [
                    ['bagurlmap1', ''],
                    ]
    if '$bag_name' in pattern:
        if '$tiddler_name' in pattern:
            data['text'] = 'oh hai'
        else:
            data['description'] = "hey buddy"
    return simplejson.dumps(data)


def figure_tests(app):
    tests = []
    for pattern, methods in app.mappings:
        pattern = fixup(pattern.pattern)
        for method_type in methods:
            test = {}
            test['method'] = method_type
            test['name'] = '%s:%s' % (method_type, pattern)
            test['desc'] = test['name']
            test['url'] = filled_pattern(pattern)
            if 'challenge' in test['url']:
                continue
            if 'revisions' in test['url']:
                continue
            if 'search' in test['url']:
                test['url'] = test['url'] + '?q=hai'
                test['expected'] = ['tiddlerurlmap1']
            if method_type == 'GET':
                test['status'] = '200'
                test['request_headers'] = {
                        'accept': 'application/json',
                        }
                if 'recipe_name' in pattern and 'tiddler_name' in pattern:
                    test['expected'] = ['oh hai']
                elif 'tiddlers' in pattern and 'tiddler_name' not in pattern:
                    test['expected'] = ['tiddlerurlmap1']
            elif method_type == 'DELETE':
                test['status'] = '204'
                if 'recipe_name' in pattern and 'tiddler_name' in pattern:
                    continue
            elif method_type == 'PUT':
                test['status'] = '204'
                test['data'] = data_from_pattern(pattern)
                test['request_headers'] = {
                        'content-type': 'application/json',
                        }
            else:
                continue
            tests.append(test)

    def test_sorter(test):
        method = test['method']
        if method == 'DELETE':
            key = test['method'] + 'x' * len(test['name'])
        else:
            key = test['method'] + 'x' * (70 - len(test['name']))
        return key

    return sorted(tests, key=test_sorter, reverse=True)


def setup_module(module):
    tests = do_run()
    http_test(tests, 'http://our_test_domain:8001')
    # the below is for testing tiddlynode
    #http_test(tests, 'http://127.0.0.1:8000')


def do_run():
    app = selector.Selector(mapfile='tiddlyweb/urls.map')
    return figure_tests(app)


if __name__ == '__main__':
    do_run()

########NEW FILE########
__FILENAME__ = test_user
"""
Test user, a simple data container for a user.
"""


import py.test

from tiddlyweb.model.user import User

usersign = 'cdent'
note = 'for future expansion'


def setup_module(module):
    pass


def test_user_create():
    user = User('cdent')
    assert type(user) == User

    assert user.usersign == 'cdent'
    user.note = note
    assert user.note == note

    user.note = 'bar'
    assert user.note == 'bar'


def test_user_args():
    py.test.raises(TypeError, 'user = User()')


def test_user_stringification():
    user = User('monkey')

    assert 'monkey' in '%s' % user


def test_user_password():
    user = User('monkey')
    user.set_password('cowpig')

    assert user.check_password('cowpig'), 'correct password returns true'
    assert not user.check_password('pigcow'), 'bad password returns false'


def test_empty_password():
    user = User('ape')
    assert not user.check_password('xow'), 'no password on user returns false'
    assert not user.check_password('')
    user.set_password('')
    assert not user.check_password('')


def test_user_role():
    user = User('paper')
    assert user.list_roles() == []

    user.add_role('ADMIN')
    assert user.list_roles() == ['ADMIN']

    user.del_role('ADMIN')
    assert user.list_roles() == []

    # add twice to confirm set-ness
    user.add_role('ADMIN')
    user.add_role('ADMIN')

    assert user.list_roles() == ['ADMIN']

########NEW FILE########
__FILENAME__ = test_validate

import sys
sys.path.insert(0, '.')

import py.test

from tiddlyweb.model.bag import Bag
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.web.validator import (validate_bag, validate_tiddler,
        InvalidTiddlerError)
import tiddlyweb.web.validator


def check_for_text(tiddler, environ):
    if 'foobar' not in tiddler.text:
        raise InvalidTiddlerError('missing "foobar" in tiddler.text')


def modify_text(tiddler, environ):
    tiddler.text = tiddler.text.replace('foobar', 'FOOBAR')


tiddlyweb.web.validator.TIDDLER_VALIDATORS = [
        check_for_text,
        modify_text,
        ]


def test_validate_tiddler():
    tiddler = Tiddler('foobar', 'barney')
    tiddler.text = 'I am a dinosaur'
    tiddler.tags = ['tag1', 'tag2']

    py.test.raises(InvalidTiddlerError, 'validate_tiddler(tiddler)')

    tiddler.text = 'I am a dinosaur who likes to foobar'

    validate_tiddler(tiddler)

    assert 'FOOBAR' in tiddler.text


def test_validate_bag_desc():
    bag = Bag('barney')
    bag.desc = '<script>alert("foo");</script>'

    validate_bag(bag)

    assert bag.desc == '&lt;script&gt;alert("foo");&lt;/script&gt;'

########NEW FILE########
__FILENAME__ = test_web
"""
Test that GETting a bag can list the tiddlers.
"""


import sys
import py.test

import tiddlyweb.web
import tiddlyweb.web.util
from tiddlyweb.config import config
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.model.bag import Bag
from tiddlyweb.web import serve

from test.simpleplugin import PluginHere

from .fixtures import initialize_app, get_http

http = get_http()

expected_content = """<ul id="root" class="listing">
<li><a href="/recipes">recipes</a></li>
<li><a href="/bags">bags</a></li>
</ul>"""

environ = {
        'tiddlyweb.config': {
            'server_host': {
                'scheme': 'http',
                'host': 'example.com',
                'port': 80
            }
        }
}


def setup_module(module):
    initialize_app()


def test_get_root():
    response, content = http.requestU('http://our_test_domain:8001/',
            method='GET')

    assert response['status'] == '200'
    assert response['content-type'] == 'text/html; charset=UTF-8'
    assert expected_content in content


def test_head_root():
    response, content = http.requestU(
            'http://our_test_domain:8001/',
            method='HEAD')

    assert response['status'] == '200'
    assert response['content-type'] == 'text/html; charset=UTF-8'
    assert content == ''


def test_with_header_and_css():
    config['css_uri'] = 'http://example.com/example.css'
    response, content = http.requestU(
            'http://our_test_domain:8001/',
            method='GET',
            headers={'User-Agent': 'Mozilla/5'})
    assert response['status'] == '200'
    assert 'link rel="stylesheet" href="http://example.com/example.css"' in content


def test_missing_system_plugin():
    config['system_plugins'] = ['missingplugin']
    py.test.raises(ImportError, 'serve.load_app()')
    config['system_plugins'] = []


def test_existing_system_plugin():
    config['system_plugins'] = ['test.simpleplugin']
    py.test.raises(PluginHere, 'serve.load_app()')
    config['system_plugins'] = []


def test_recipe_url():
    recipe = Recipe('hello')

    assert tiddlyweb.web.util.recipe_url(
            environ, recipe) == 'http://example.com/recipes/hello'


def test_bag_url():
    bag = Bag('hello')

    assert tiddlyweb.web.util.bag_url(
            environ, bag) == 'http://example.com/bags/hello'


def test_invalid_http_caching_timestamp():
    """
    Thunderbird's feed module sends `If-Modified-Since: 0`, which is invalid -
    Postel demands that we don't freak out over that
    """
    response, content = http.request(
            'http://our_test_domain:8001/',
            method='GET',
            headers={'If-Modified-Since': '0'})

    assert response['status'] == '200'


def test_http_date_from_timestamp():
    timestamp = '200805231010'
    assert tiddlyweb.web.util.http_date_from_timestamp(
            timestamp) == 'Fri, 23 May 2008 10:10:00 GMT'


def test_http_date_from_timestamp_invalid():
    timestamp = '200702291010'
    badone = tiddlyweb.web.util.http_date_from_timestamp(timestamp)
    timestamp = '20 15'
    badtwo = tiddlyweb.web.util.http_date_from_timestamp(timestamp)
    assert badone[:14] == badtwo[:14]

    if sys.version_info[0] > 2:
        py.test.skip('skipping invalid date on python3')
    timestamp = '108502281010'
    py.test.raises(ValueError,
        'tiddlyweb.web.util.http_date_from_timestamp(timestamp)')


def test_datetime_from_http_date():
    timestamp = '200805231010'
    datestring = tiddlyweb.web.util.http_date_from_timestamp(timestamp)
    datetime_object = tiddlyweb.web.util.datetime_from_http_date(datestring)
    new_timestamp = datetime_object.strftime('%Y%m%d%H%M')
    assert '2008' in datestring
    assert 'May' in datestring
    assert new_timestamp == timestamp


def test_datetime_from_http_date_semi():
    """
    IE likes to send a length attribute with the http date on
    an If-Modified-Since.
    """
    timestamp = '200805231010'
    datestring = tiddlyweb.web.util.http_date_from_timestamp(timestamp)
    datestring = datestring + "; length=443333"
    datetime_object = tiddlyweb.web.util.datetime_from_http_date(datestring)
    new_timestamp = datetime_object.strftime('%Y%m%d%H%M')
    assert new_timestamp == timestamp


def test_datetime_form_http_date_utc():
    datestring = 'Wed, 09 Mar 2011 00:00:00 UTC'
    timestamp = '201103090000'
    datetime_object = tiddlyweb.web.util.datetime_from_http_date(datestring)
    new_timestamp = datetime_object.strftime('%Y%m%d%H%M')
    assert new_timestamp == timestamp

########NEW FILE########
__FILENAME__ = test_web_304_handling

import random
import string

from .fixtures import reset_textstore, initialize_app, _teststore, get_http

from tiddlyweb.model.bag import Bag
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.model.tiddler import Tiddler


http = get_http()
RELEVANT_HEADERS = [
        'cache-control',
        'etag',
        'vary',
        'last-modified']


def setup_module(module):
    initialize_app()
    reset_textstore()
    module.store = _teststore()


def _random_name(length=5):
        return ''.join(random.choice(string.ascii_lowercase)
                for i in range(length))


def test_get_tiddler():
    bag = Bag(_random_name())
    store.put(bag)

    tiddler = Tiddler(_random_name(), bag.name)
    tiddler.text = _random_name(10)
    store.put(tiddler)

    _get_entity('http://our_test_domain:8001/bags/%s/tiddlers/%s' % (
        bag.name, tiddler.title), test_last_modified=True)


def test_get_maxage_tiddler():
    bag = Bag(_random_name())
    store.put(bag)

    tiddler = Tiddler(_random_name(), bag.name)
    tiddler.text = _random_name(10)
    tiddler.fields['_cache-max-age'] = '3600'
    store.put(tiddler)

    _get_entity('http://our_test_domain:8001/bags/%s/tiddlers/%s' % (
        bag.name, tiddler.title), test_last_modified=True)


def test_get_bag():
    bag = Bag(_random_name())
    store.put(bag)
    _get_entity('http://our_test_domain:8001/bags/%s' % bag.name)


def test_get_recipe():
    recipe = Recipe(_random_name())
    store.put(recipe)
    _get_entity('http://our_test_domain:8001/recipes/%s' % recipe.name)


def test_get_tiddlers():
    bag = Bag(_random_name())
    store.put(bag)

    for i in range(10):
        tiddler = Tiddler(_random_name(), bag.name)
        store.put(tiddler)

    _get_entity('http://our_test_domain:8001/bags/%s/tiddlers' % bag.name,
            test_last_modified=True)


def _get_entity(uri, test_last_modified=False):
    """
    Get a uri and confirm that for those relevant headers
    in a 200 response, the same things are there for a
    304 response.
    """
    response, content = http.request(uri,
        method='GET')

    assert response['status'] == '200', content
    response_200 = response
    etag = response['etag']
    if 'last-modified' in response:
        last_modified = response['last-modified']

    response, content = http.request(uri,
        headers={'If-None-Match': etag},
        method='GET')

    assert response['status'] == '304', content
    response_304 = response

    for header in RELEVANT_HEADERS:
        if header in response_200:
            assert header in response_304
            assert response_200[header] == response_304[header]

    if test_last_modified:
        response, content = http.request(uri,
                headers={'If-Modified-Since': last_modified},
                method='GET')
        response_lm_304 = response

        for header in RELEVANT_HEADERS:
            if header in response_200:
                assert header in response_lm_304
                assert response_200[header] == response_lm_304[header]

########NEW FILE########
__FILENAME__ = test_web_bag
"""
Test that GETting a bag can list the tiddlers.
"""


import simplejson

from tiddlyweb.fixups import unquote

from tiddlyweb.model.bag import Bag

from .fixtures import (muchdata, reset_textstore, _teststore, initialize_app,
        get_http)

http = get_http()
policy_dict = dict(
        read=[u'chris', u'jeremy', u'GUEST'],
        write=[u'chris', u'jeremy'],
        create=[u'chris', u'jeremy'],
        delete=[u'chris'],
        manage=[],
        owner=u'chris')


def setup_module(module):
    initialize_app()

    reset_textstore()
    module.store = _teststore()
    muchdata(module.store)


def test_get_bag_tiddler_list_default():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers',
            method='GET')

    assert response['status'] == '200'
    assert response['content-type'] == 'text/html; charset=UTF-8'
    assert content.count('<li>') == 10


def test_bad_http_caching_timestamp():
    """
    Thunderbird's feed module sends `If-Modified-Since: 0`, which is invalid -
    Postel demands that we don't freak out over that
    """
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers',
            method='GET',
            headers={'If-Modified-Since': '0'})

    assert response['status'] == '200'


def test_get_bag_tiddler_list_404():
    """
    A request for the tiddlers in a non existent bag gives a 404.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag99/tiddlers',
            method='GET')

    assert response['status'] == '404'
    assert '(' not in content


def test_get_bag_tiddler_list_text():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers.txt',
            method='GET')

    assert response['status'] == '200'
    assert response['content-type'] == 'text/plain; charset=UTF-8'
    assert len(content.rstrip().split('\n')) == 10


def test_get_bag_tiddler_list_html():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers.html',
            method='GET')

    assert response['status'] == '200'
    assert response['content-type'] == 'text/html; charset=UTF-8'
    assert content.count('<li>') == 10


def test_get_bag_tiddler_list_415():
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers.gif',
            method='GET')

    assert response['status'] == '415'


def test_get_bag_tiddler_list_415_accept():
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers.gif',
            headers={'Accept': 'text/html'},
            method='GET')

    assert response['status'] == '415'


def test_get_bag_tiddler_list_html_default():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers',
            method='GET', headers={'Accept': 'text/html'})

    assert response['status'] == '200'
    assert response['content-type'] == 'text/html; charset=UTF-8'
    assert content.count('<li>') == 10


def test_get_bag_tiddler_list_filtered():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers.txt?select=title:tiddler8',
            method='GET')

    assert response['status'] == '200'
    assert response['last-modified'] == 'Fri, 23 May 2008 03:03:00 GMT'
    assert len(content.rstrip().split('\n')) == 1


def test_get_bag_tiddler_list_bogus_filter():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers.txt?sort=-monkey',
            method='GET')

    assert response['status'] == '400'
    assert 'malformed filter' in content


def test_get_bags_default():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags',
            method='GET')

    assert response['status'] == '200'
    assert response['content-type'] == 'text/html; charset=UTF-8'
    assert content.count('<li>') == 30
    assert content.count('bags/') == 30


def test_get_bags_txt():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags.txt',
            method='GET')

    assert response['status'] == '200'
    assert response['content-type'] == 'text/plain; charset=UTF-8'
    assert len(content.rstrip().split('\n')) == 30


def test_get_bags_html():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags.html',
            method='GET')

    assert response['status'] == '200'
    assert response['content-type'] == 'text/html; charset=UTF-8'
    assert content.count('<li>') == 30
    assert content.count('bags/') == 30


def test_get_bags_unsupported_neg_format():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags.gif',
            method='GET')

    assert response['status'] == '415'


def test_get_bags_unsupported_format():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags.jpeg',
            method='GET')

    assert response['status'] == '415'


def test_get_bags_unsupported_format_browser():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags.jpeg',
            method='GET',
            headers={'Accept': 'text/html'})

    assert response['status'] == '415'


def test_get_bags_json():
    """
    Uses extension.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/bags.json',
            method='GET')

    assert response['status'] == '200'
    assert response['content-type'] == 'application/json'
    assert 'charset=UTF-8' not in response['content-type']
    info = simplejson.loads(content)
    assert type(info) == list
    assert len(info) == 30


def test_get_bags_wiki():
    """
    Doesn't support wiki.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/bags.wiki',
            method='GET')
    assert response['status'] == '415'


def test_get_bags_unsupported_neg_format_with_accept():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags.gif',
            method='GET',
            headers={'Accept': 'text/html'})

    assert response['status'] == '415'


def test_get_bag_tiddler_list_empty():
    """
    A request for the tiddlers in an empty bag gives a 200, empty page.
    """

    bag = Bag('bagempty')
    store.put(bag)

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bagempty/tiddlers.json',
            method='GET')

    assert response['status'] == '200'

    results = simplejson.loads(content)
    assert len(results) == 0


def test_put_bag():
    """
    PUT a new bag to the server.
    """
    json_string = simplejson.dumps(dict(policy=policy_dict))

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bagpuss',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json_string)
    location = response['location']

    assert response['status'] == '204'
    assert location == 'http://our_test_domain:8001/bags/bagpuss'

    response, content = http.requestU(location,
            method='GET',
            headers={'Accept': 'application/json'})

    assert response['status'] == '200'
    assert 'etag' in response
    etag = response['etag']
    info = simplejson.loads(content)
    assert info['policy']['delete'] == policy_dict['delete']

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bagpuss.json',
            method='GET',
            headers={'if-none-match': etag})
    assert response['status'] == '304', content

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bagpuss.json',
            method='GET',
            headers={'if-none-match': etag + 'foo'})
    assert response['status'] == '200', content


def test_put_bag_bad_json():
    """
    PUT a new bag to the server.
    """
    json_string = simplejson.dumps(dict(policy=policy_dict))
    json_string = json_string[0:-1]

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bagpuss',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json_string)

    assert response['status'] == '400'
    assert 'unable to put bag' in content
    assert 'unable to make json into' in content


def test_delete_bag():
    """
    PUT a new bag to the server and then DELETE it.
    """
    json_string = simplejson.dumps(dict(policy={}))

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/deleteme',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json_string)
    location = response['location']

    assert response['status'] == '204'
    assert location == 'http://our_test_domain:8001/bags/deleteme'

    response, content = http.request(location,
            method='DELETE')
    assert response['status'] == '204'

    response, content = http.request(location,
            method='GET',
            headers={'Accept': 'application/json'})
    assert response['status'] == '404'


def test_put_bag_wrong_type():
    """
    PUT a new bag to the server.
    """
    json_string = simplejson.dumps(dict(policy=policy_dict))

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bagpuss',
            method='PUT',
            headers={'Content-Type': 'text/plain'},
            body=json_string)

    assert response['status'] == '415'


def test_get_bag_tiddlers_constraints():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers',
            method='GET')
    assert response['status'] == '200'

    _put_policy('bag0', dict(policy=dict(read=['NONE'])))
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers',
            method='GET')
    assert response['status'] == '403'
    assert 'may not read' in content


def test_roundtrip_unicode_bag():
    encoded_bag_name = '%E3%81%86%E3%81%8F%E3%81%99'
    bag_name = unquote(encoded_bag_name)
    bag_content = {'policy': {'read': ['a', 'b', 'c', 'GUEST']}}
    body = simplejson.dumps(bag_content)
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/%s' % encoded_bag_name,
            method='PUT',
            body=body,
            headers={'Content-Type': 'application/json'})
    assert response['status'] == '204'

    bag = Bag(bag_name)
    bag = store.get(bag)
    assert bag.name == bag_name

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/%s.json' % encoded_bag_name,
            method='GET')
    bag_data = simplejson.loads(content)
    assert response['status'] == '200'
    assert bag_data['policy']['read'] == ['a', 'b', 'c', 'GUEST']


def test_no_delete_store():
    """
    XXX: Not sure how to test this. We want to test for
    StoreMethodNotImplemented raising HTTP400. But
    it is hard to inject in a false store.
    """
    pass


def test_put_bag_vnd():
    """
    PUT a new bag to the server with vnd.tiddlyweb
    """
    json_string = simplejson.dumps(dict(policy=policy_dict))

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bagpuss',
            method='PUT',
            headers={'Content-Type': 'application/vnd.tiddlyweb+json'},
            body=json_string)
    location = response['location']

    assert response['status'] == '204'
    assert location == 'http://our_test_domain:8001/bags/bagpuss'

    response, content = http.requestU(location,
            method='GET',
            headers={'Accept': 'application/vnd.tiddlyweb+json'})

    assert response['status'] == '200'
    assert 'etag' in response
    etag = response['etag']
    info = simplejson.loads(content)
    assert info['policy']['delete'] == policy_dict['delete']

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bagpuss.json',
            method='GET',
            headers={'if-none-match': etag})
    assert response['status'] == '304', content

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bagpuss.json',
            method='GET',
            headers={'if-none-match': etag + 'foo'})
    assert response['status'] == '200', content


def _put_policy(bag_name, policy_dict):
    """
    XXX: This is duplicated from test_web_tiddler. Clean up!
    """
    json = simplejson.dumps(policy_dict)

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/%s' % bag_name,
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json)
    assert response['status'] == '204'

########NEW FILE########
__FILENAME__ = test_web_bags

from .fixtures import reset_textstore, _teststore, initialize_app, get_http
from tiddlyweb.model.bag import Bag

http = get_http()


def setup_module(module):
    initialize_app()
    reset_textstore()
    module.store = _teststore()

    for i in range(5):
        bag = Bag('bag%s' % i)
        module.store.put(bag)


def test_get_bags_txt():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '200'
    for i in range(5):
        assert 'bag%s\n' % i in content
    assert 'etag' in response
    etag = response['etag']

    response, content = http.requestU(
            'http://our_test_domain:8001/bags',
            headers={'Accept': 'text/plain',
                'if-none-match': etag},
            method='GET')
    assert response['status'] == '304', content

    response, content = http.requestU('http://our_test_domain:8001/bags',
            headers={'Accept': 'text/plain',
                'if-none-match': etag + 'foo'},
            method='GET')
    assert response['status'] == '200', content


def test_get_bags_filters():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags?select=name:bag1',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '200', content
    assert 'bag1\n' in content
    assert 'bag2\n' not in content


def test_get_bags_filters_bad():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags?select=rbag:figgy',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '400', content
    assert 'malformed filter' in content


def test_get_bags_selected_sorted_filters():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags?select=name:>bag2',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '200', content
    assert 'bag1\n' not in content
    assert 'bag2\n' not in content
    assert 'bag3\n' in content


def test_get_bags_sorted_filters():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags?sort=-name',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '200', content
    assert 'bag4\nbag3\nbag2\nbag1\nbag0' in content


def test_get_bags_sorted_limitedfilters():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags?sort=-name;limit=1,1',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '200', content
    assert content == 'bag3\n'


def test_get_bags_bad_filter():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags?sort=title',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '400', content
    assert 'malformed filter' in content

########NEW FILE########
__FILENAME__ = test_web_bag_tiddlers
"""
Test posting a wiki to a bag.
"""


import simplejson

from tiddlyweb.model.user import User

from .fixtures import (muchdata, reset_textstore, _teststore, initialize_app,
        get_http)

from base64 import b64encode

authorization = b64encode(u'cd\u2714nt:cowpig'.encode('utf-8')).decode('utf-8')
http = get_http()


def setup_module(module):
    initialize_app()
    reset_textstore()
    module.store = _teststore()
    user = User(u'cd\u2714nt')
    user.set_password('cowpig')
    module.store.put(user)
    muchdata(module.store)


def test_get_sorted_tiddlers():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers.json?sort=title',
            method='GET')
    etag = response['etag']
    assert response['status'] == '200'
    tiddlers = simplejson.loads(content)
    assert tiddlers[0]['title'] == 'tiddler0'
    assert tiddlers[0]['uri'] == 'http://our_test_domain:8001/bags/bag0/tiddlers/tiddler0'

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers.json?sort=title',
            method='GET')
    etag2 = response['etag']
    assert etag == etag2

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers.json?sort=title',
            method='GET',
            headers={'if-none-match': etag})
    assert response['status'] == '304'

    # confirm head
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers.json?sort=title',
            method='HEAD',
            headers={'if-none-match': etag})
    assert response['status'] == '304'

    # confirm head
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers.json?sort=title',
            method='HEAD')
    assert response['status'] == '200'
    assert content == ''


def test_get_tiddlers_with_unicode_user():
    """
    Cover a bug in sendtiddlers related to unicode users.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers.json?sort=title',
            method='GET',
            headers={'Content-Type': 'text/plain',
                'Authorization': 'Basic %s' % authorization})
    assert response['status'] == '200'


def test_get_selected_sorted_limited_tiddlers():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers.json?select=title:!tiddler1;select=title:!tiddler0;sort=title;limit=1',
            method='GET')
    assert response['status'] == '200'
    tiddlers = simplejson.loads(content)
    assert len(tiddlers) == 1
    assert tiddlers[0]['title'] == 'tiddler2'


def test_not_post_to_bag_tiddlers():
    content = "HI EVERYBODY!"
    response, content = http.request(
            'http://our_test_domain:8001/bags/wikibag/tiddlers',
            method='POST',
            headers={'Content-Type': 'text/x-tiddlywiki'},
            body=content)

    assert response['status'] == '405'

########NEW FILE########
__FILENAME__ = test_web_challenge
"""
Test the way in which the /challenge URI produces stuff.
"""


import httplib2
import simplejson

from tiddlyweb.model.user import User
from tiddlyweb.config import config

from .fixtures import (muchdata, reset_textstore, _teststore, initialize_app,
        get_http)

http = get_http()


def setup_module(module):
    config['auth_systems'].append('not.really.there')
    initialize_app()
    reset_textstore()
    module.store = _teststore()
    muchdata(module.store)

    user = User('cdent')
    user.set_password('cowpig')
    store.put(user)


def test_challenge_base():
    response, content = http.requestU(
            'http://our_test_domain:8001/challenge', method='GET')

    assert response['status'] == '401'
    assert '<title>TiddlyWeb - Login Challengers</title>' in content
    assert 'cookie_form' in content
    assert '>TiddlyWeb username and password</a>' in content


def test_challenge_cookie_form():
    response, content = http.requestU(
            'http://our_test_domain:8001/challenge/cookie_form',
            method='GET')

    assert response['status'] == '401'
    assert '<title>TiddlyWeb - Cookie Based Login</title>' in content
    assert '<form' in content


def test_challenge_not_there_in_config():
    response, content = http.requestU(
            'http://our_test_domain:8001/challenge/not_there',
            method='GET')

    assert response['status'] == '404'


def test_challenge_unable_to_import():
    response, content = http.requestU(
            'http://our_test_domain:8001/challenge/not.really.there',
            method='GET')

    assert response['status'] == '404'
    assert 'Unable to import' in content


def test_redirect_to_challenge():
    _put_policy('bag28', dict(policy=dict(read=['cdent'], write=['cdent'])))

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/tiddler8?select=tag:foo',
            method='GET')
    assert response['status'] == '401'
    assert 'cookie_form' in content
    assert 'tiddlyweb_redirect=%2Frecipes%2Flong%2Ftiddlers%2Ftiddler8%3Fselect%3Dtag%3Afoo' in content


def test_redirect_default_in_list():
    """
    When we go to the challenge page directly,
    we should not get a tiddlyweb_redirect.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/challenge',
            method='GET')
    assert response['status'] == '401'
    assert 'tiddlyweb_redirect=%2F' in content


def test_simple_cookie_redirect():
    nested_response = None
    try:
        response, content = http.requestU(
                'http://our_test_domain:8001/challenge/cookie_form',
                method='POST',
                headers={'content-type': 'application/x-www-form-urlencoded'},
                body='user=cdent&password=cowpig&tiddlyweb_redirect=/recipes/long/tiddlers/tiddler8',
                redirections=0)
    except httplib2.RedirectLimit as e:
        nested_response = e

    assert nested_response
    assert nested_response.response['status'] == '303'
    headers = {}
    headers['cookie'] = nested_response.response['set-cookie']
    response, content = http.requestU(nested_response.response['location'],
            method='GET', headers=headers)
    assert response['status'] == '200'
    assert 'i am tiddler 8' in content


def test_malformed_post():
    """
    If we leave out some info in the post,
    we need to just see the form again.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/challenge/cookie_form',
            method='POST',
            body='user=cdent&tiddlyweb_redirect=/recipes/long/tiddlers/tiddler8',
            headers={'Content-Type': 'application/x-www-form-urlencoded'},
            redirections=0)
    assert response['status'] == '401'
    assert '<form' in content


def test_charset_in_content_type():
    """
    Make sure we are okay with charset being set in the content type.
    """
    nested_response = None
    try:
        response, content = http.request(
                'http://our_test_domain:8001/challenge/cookie_form',
                method='POST',
                headers={'content-type':
                    'application/x-www-form-urlencoded; charset=UTF-8'},
                body='user=cdent&password=cowpig&tiddlyweb_redirect=/recipes/long/tiddlers/tiddler8',
                redirections=0)
    except httplib2.RedirectLimit as e:
        nested_response = e

    assert nested_response
    assert nested_response.response['status'] == '303'
    headers = {}
    headers['cookie'] = nested_response.response['set-cookie']
    assert 'Max-Age' not in nested_response.response['set-cookie']
    response, content = http.requestU(nested_response.response['location'],
            method='GET',
            headers=headers)
    assert response['status'] == '200'
    assert 'i am tiddler 8' in content


def test_single_challenge_redirect():
    """
    When there is only one challenger configured, we should
    be redirected to it instead of getting a list.
    """

    config['auth_systems'] = ['cookie_form']
    nested_response = None
    try:
        response, content = http.request(
                'http://our_test_domain:8001/challenge',
                method='GET', redirections=0)
    except httplib2.RedirectLimit as e:
        nested_response = e

    assert nested_response
    assert nested_response.response['status'] == '302'


def test_cookie_path_prefix_max_age():
    """
    This test is a bit messed up. Because we have a persistent app
    loaded by load_app in fixtures, the prefix that the selector uses
    is already set and we cannot address requests there, so we address
    a non prefixed URL, but expect a Path in the cookie.
    """
    original_prefix = config['server_prefix']
    config['server_prefix'] = '/wiki'
    config['cookie_age'] = '300'
    nested_response = None
    try:
        response, content = http.request(
                'http://our_test_domain:8001/challenge/cookie_form',
                method='POST',
                headers={'content-type':
                    'application/x-www-form-urlencoded; charset=UTF-8'},
                body='user=cdent&password=cowpig&tiddlyweb_redirect=/recipes/long/tiddlers/tiddler8',
                redirections=0)
    except httplib2.RedirectLimit as e:
        nested_response = e

    assert nested_response
    assert 'Path=/wiki/' in nested_response.response['set-cookie']
    assert 'Max-Age=300' in nested_response.response['set-cookie']
    config['server_prefix'] = original_prefix


def _put_policy(bag_name, policy_dict):
    json = simplejson.dumps(policy_dict)

    response, content = http.request(
            'http://our_test_domain:8001/bags/%s' % bag_name,
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json)
    assert response['status'] == '204'

########NEW FILE########
__FILENAME__ = test_web_extract
"""
Test the way in which the /challenge URI produces stuff.

XXX This test file appears to have never been completed.
"""

from base64 import b64encode

from .fixtures import (reset_textstore, _teststore, initialize_app,
        get_http)

from tiddlyweb.config import config
from tiddlyweb.model.user import User


http = get_http()


def init(config):
    config['selector'].add('/current_user', GET=user)


def user(environ, start_response):
    username = environ['tiddlyweb.usersign']['name']
    start_response('200 OK', [
        ('Content-Type', 'text/plain')])
    return ["%s\n" % username]


def auth_string(info):
    return b64encode(info.encode('utf-8')).decode('utf-8')


def setup_module(module):
    config['system_plugins'].append('test.test_web_extract')
    initialize_app()
    reset_textstore()
    module.store = _teststore()
    user = User('cow')
    user.set_password('pig')
    module.store.put(user)


def test_extractor_not_there_in_config():
    config['extractors'].append('saliva')
    response, content = http.requestU(
            'http://our_test_domain:8001/',
            method='GET')

    assert response['status'] == '500'
    assert 'ImportError' in content
    config['extractors'].remove('saliva')


def test_guest_extract():
    response, content = http.requestU(
            'http://our_test_domain:8001/current_user',
            method='GET')

    assert response['status'] == '200'
    assert 'GUEST' in content


def test_user_extract():
    response, content = http.requestU(
            'http://our_test_domain:8001/current_user',
            method='GET',
            headers={'Authorization': 'Basic %s' % auth_string('cow:pig')})
    assert response['status'] == '200'
    assert 'cow' in content


def test_user_extract_bad_pass():
    """User gets their password wrong, user is GUEST"""
    response, content = http.requestU(
            'http://our_test_domain:8001/current_user',
            method='GET',
            headers={'Authorization': 'Basic %s' % auth_string('cow:pog')})
    assert response['status'] == '200'
    assert 'GUEST' in content


def test_user_extract_no_user():
    """User doesn't exist, user is GUEST"""
    response, content = http.requestU(
            'http://our_test_domain:8001/current_user',
            method='GET',
            headers={'Authorization': 'Basic %s' % auth_string('ciw:pig')})
    assert response['status'] == '200'
    assert 'GUEST' in content


def test_user_extract_bogus_data():
    """User doesn't exist, user is GUEST"""
    response, content = http.requestU(
            'http://our_test_domain:8001/current_user',
            method='GET',
            headers={'Authorization': 'Basic %s' % auth_string(':')})
    assert response['status'] == '200'
    assert 'GUEST' in content


def test_bad_cookie():
    """confirm a bad cookie results in an error"""
    response, content = http.requestU(
            'http://our_test_domain:8001/current_user',
            method='GET',
            headers={'Cookie': 'foo(bar)bar="monkey"'})
    assert response['status'] == '400'
    assert 'Illegal key value' in content


def test_malformed_tiddlyweb_cookie():
    """confirm a malformed user cookie results in GUEST"""
    response, content = http.requestU(
            'http://our_test_domain:8001/current_user',
            method='GET',
            headers={'Cookie': 'tiddlyweb_user="cdent.tumblr.com"'})
    assert response['status'] == '200', content
    assert 'GUEST' in content

########NEW FILE########
__FILENAME__ = test_web_http_api
"""
Run through the entire API to expound,
expand, explain, etc.
"""

import yaml

# test_* required to make tests discoverable
from .http_runner import http_test, test_the_TESTS, test_assert_response


def setup_module(module):
    with open('test/httptest.yaml') as yaml_file:
        tests = yaml.load(yaml_file)
        http_test(tests, 'http://our_test_domain:8001')

########NEW FILE########
__FILENAME__ = test_web_json_tiddler
"""
Tests related to fixing and confirming

    https://github.com/tiddlyweb/tiddlyweb/issues/99

The idea is that we want to be able to get a tiddler containing
JSON as JSON and as a tiddler with JSON in it.
"""

import simplejson

from tiddlyweb.model.bag import Bag
from tiddlyweb.model.tiddler import Tiddler

from .fixtures import (reset_textstore, _teststore, initialize_app,
        get_http)

def setup_module(module):
    initialize_app()

    reset_textstore()
    module.store = _teststore()
    module.http = get_http()

    module.store.put(Bag('holder'))


def test_tiddler_is_json():
    data = {'alpha': 'one', 'beta': 'two'}
    json_data = simplejson.dumps(data)
    tiddler = Tiddler('json1', 'holder')
    tiddler.type = 'application/json'
    tiddler.text = json_data
    store.put(tiddler)

    stored_tiddler = store.get(Tiddler('json1', 'holder'))

    assert stored_tiddler.type == 'application/json'
    assert stored_tiddler.text == json_data


def test_get_tiddler_as_default():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/holder/tiddlers/json1')

    assert response['status'] == '200'
    assert 'application/json' in response['content-type']
    assert '"alpha": "one"' in content
    assert '"text"' not in content

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/holder/tiddlers/json1',
            headers={'Accept': 'application/json'})

    assert response['status'] == '200'
    assert 'application/json' in response['content-type']
    assert '"alpha": "one"' in content
    assert '"text"' not in content


def test_get_tiddler_as_tiddler():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/holder/tiddlers/json1',
            headers={'Accept': 'application/vnd.tiddlyweb+json'})

    assert response['status'] == '200'
    assert 'application/json' in response['content-type']
    assert r'\"alpha\": \"one\"' in content
    assert '"text"' in content


def test_put_tiddler_x_tiddler():
    json_internal_data = simplejson.dumps({'alpha': 'one', 'beta': 'one'})
    json_external_data = simplejson.dumps({'type': 'application/json',
        'text': json_internal_data})

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/holder/tiddlers/json2',
            headers={'Content-Type': 'application/vnd.tiddlyweb+json'},
            method='PUT',
            body=json_external_data)

    assert response['status'] == '204'

    location = response['location']
    response, content = http.requestU(location,
            headers={'Accept': 'application/json'})
    assert response['status'] == '200'
    assert response['content-type'].startswith('application/json')
    assert '"alpha": "one"' in content

    response, content = http.requestU(location,
            headers={'Accept': 'application/vnd.tiddlyweb+json'})
    assert response['status'] == '200'
    assert response['content-type'].startswith('application/json')
    assert r'\"alpha\": \"one\"' in content


def test_put_tiddler_json():
    json_internal_data = simplejson.dumps({'alpha': 'one', 'beta': 'one'})
    json_external_data = simplejson.dumps({'type': 'application/json',
        'text': json_internal_data})

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/holder/tiddlers/json3',
            headers={'Content-Type': 'application/json'},
            method='PUT',
            body=json_external_data)

    assert response['status'] == '204'

    location = response['location']
    response, content = http.requestU(location,
            headers={'Accept': 'application/json'})
    assert response['status'] == '200'
    assert response['content-type'].startswith('application/json')
    assert '"alpha": "one"' in content

    response, content = http.requestU(location,
            headers={'Accept': 'application/vnd.tiddlyweb+json'})
    assert response['status'] == '200'
    assert response['content-type'].startswith('application/json')
    assert r'\"alpha\": \"one\"' in content

########NEW FILE########
__FILENAME__ = test_web_negotiate
"""
Test the content negotiation pieces.

Content negotiation will put something in
the environment that allows us to determine
what kind of store and serializer to use.
"""


from tiddlyweb.web.negotiate import figure_type
from tiddlyweb.config import config

environ = {
        'tiddlyweb.config': config,
        'REQUEST_METHOD': 'GET'
}


def test_accept_header():
    """
    Given an accept header in the environ,
    determine the type we want.
    """
    environ['HTTP_ACCEPT'] = 'text/plain; q=1.0, text/html; q=0.9, text/x-dvi; q=0.8, text/x-c'

    figure_type(environ)
    assert environ['tiddlyweb.type'][0] == 'text/plain'


def test_accept_ill_formed_header():
    """
    Given an accept header in the environ,
    that is poorly formed, use default.
    """
    environ['HTTP_ACCEPT'] = '; q=1.0, text/plain; q=1.0, text/html, text/x-dvi; q=0.8, text/x-c'

    figure_type(environ)
    assert environ['tiddlyweb.type'][0] == 'text/html'


def test_accept_bad_q():
    """
    Given a non-float q, ignore.
    """
    environ['HTTP_ACCEPT'] = 'text/plain; q=hot, text/html, text/postscript; q=0.5'

    figure_type(environ)
    assert environ['tiddlyweb.type'][0] == 'text/html'


def test_accept_extension():
    """
    Ignore non q= style parameters.
    """
    environ['HTTP_ACCEPT'] = 'text/plain; cookies=chip'
    figure_type(environ)
    assert environ['tiddlyweb.type'][0] == 'text/plain'


def test_file_extension():
    """
    Given a \.extension in the path_info,
    determine the type we want.
    """
    environ['PATH_INFO'] = '/bags/bag0/tiddlers/bigbox.html'

    figure_type(environ)
    assert environ['tiddlyweb.type'][0] == 'text/html'


def test_file_wins_over_header():
    """
    Where there is both an extension and
    an accept header, the extension wins.
    """
    environ['HTTP_ACCEPT'] = 'text/plain; q=1.0, text/html, text/x-dvi; q=0.8, text/x-c'
    environ['PATH_INFO'] = '/bags/bag0/tiddlers/bigbox.html'

    figure_type(environ)
    assert environ['tiddlyweb.type'][0] == 'text/html'

########NEW FILE########
__FILENAME__ = test_web_recipe

"""
Test that GETting recipes.
"""


from base64 import b64encode

from tiddlyweb.fixups import unquote

import simplejson

from .fixtures import (muchdata, reset_textstore, _teststore, initialize_app,
        get_http)
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.model.user import User

authorization = b64encode('cdent:cowpig'.encode('utf-8')).decode('utf-8')
http = get_http()


def setup_module(module):
    from tiddlyweb.filters.select import ATTRIBUTE_SELECTOR
    from tiddlyweb.filters import FilterError

    def hell_raiser(entity, attribute, value):
        raise FilterError('no good man')

    ATTRIBUTE_SELECTOR['error'] = hell_raiser

    initialize_app()
    reset_textstore()
    module.store = _teststore()
    muchdata(module.store)

    user = User('cdent')
    user.set_password('cowpig')
    module.store.put(user)


def test_get_recipe_txt():
    """
    Return a wiki for a recipe we can access.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long.txt',
            method='GET')

    assert response['status'] == '200'
    assert '/bags/bag8/tiddlers?select=title:tiddler8' in content
    assert 'etag' in response
    etag = response['etag']

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long.txt',
            method='GET', headers={'if-none-match': etag})
    assert response['status'] == '304'

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long.txt',
            method='GET', headers={'if-none-match': etag + 'foo'})
    assert response['status'] == '200'


def test_get_recipe_not():
    """
    Return a 404 when content type not regonized.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long.xml',
            method='GET')

    assert response['status'] == '404'


def test_get_recipe_dot_name():
    """
    Effectively return an entity with a dot in the name.
    """
    recipe = Recipe('long.gif')
    recipe.desc = u'hello'
    store.put(recipe)

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long.gif',
            method='GET')

    assert response['status'] == '200'

    store.delete(recipe)


def test_get_recipe_not_with_accept():
    """
    Return a default content type when the extension and
    content type conflict.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long.html',
            method='GET', headers={'Accept': 'text/plain'})

    assert response['status'] == '200'


def test_get_missing_recipe():
    """
    Return 404 for a recipe that is not there.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/not_there',
            method='GET')

    assert response['status'] == '404'


def test_get_recipe_tiddler_list():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers',
            method='GET')

    assert response['status'] == '200'
    assert content.count('<li>') == 10


def test_get_recipe_tiddler_list_disposition():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers?download=long.html',
            method='GET')

    assert response['status'] == '200'
    assert response['content-disposition'] == 'attachment; filename="long.html"'


def test_get_recipe_tiddler_list_filtered_one():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers.txt?select=title:tiddler8',
            method='GET')

    assert response['status'] == '200'
    assert response['last-modified'] == 'Fri, 23 May 2008 03:03:00 GMT'
    assert content == 'tiddler8\n'


def test_get_recipe_tiddler_list_filtered_empty():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers.txt?select=title:tiddlerfoo',
            method='GET')

    assert response['status'] == '200'


def test_get_recipe_tiddler_list_bogus_filter():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers.txt?sort=monkey',
            method='GET')
    assert response['status'] == '400'
    assert 'malformed filter' in content


def test_get_recipes_default():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes',
            method='GET')

    assert response['status'] == '200'
    assert response['content-type'] == 'text/html; charset=UTF-8'
    assert content.count('<li>') == 1
    assert content.count('recipes/long') == 1


def test_get_recipes_txt():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes.txt',
            method='GET')

    assert response['status'] == '200'
    assert response['content-type'] == 'text/plain; charset=UTF-8'
    assert len(content.rstrip().split('\n')) == 1


def test_get_recipes_json():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes.json',
            method='GET')

    assert response['status'] == '200'
    assert response['content-type'] == 'application/json'
    info = simplejson.loads(content)
    assert type(info) == list
    assert len(info) == 1
    assert info[0] == 'long'


def test_get_recipes_unsupported_neg_format():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes.gif',
            method='GET')

    assert response['status'] == '415'


def test_get_recipes_unsupported_neg_format_with_accept():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes.gif',
            method='GET', headers={'Accept': 'text/html'})

    assert response['status'] == '415'


def test_put_recipe():
    """
    Get a recipe as json then put it back with a different name.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long.json',
            method='GET')

    json = content
    assert response['status'] == '200'

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/other',
            method='PUT', headers={'Content-Type': 'application/json'},
            body=json)

    assert response['status'] == '204'
    assert response['location'] == 'http://our_test_domain:8001/recipes/other'


def test_put_recipe_bad_json():
    """
    Get a recipe as json then put it back with a different name.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long.json',
            method='GET')

    assert response['status'] == '200'
    json = content[0:-1]

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/other',
            method='PUT', headers={'Content-Type': 'application/json'},
            body=json)

    assert response['status'] == '400'
    assert 'unable to put recipe: unable to make json' in content


def test_put_bad_recipe():
    """
    Get a recipe as json then put it back with a different name.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/other',
            method='PUT', headers={'Content-Type': 'application/json'},
            body='{ "recipe": null }')

    assert response['status'] == '400'
    assert 'malformed input' in content


def test_put_recipe_change_description():
    """
    Get a recipe as json then put it back with a different name.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long.json',
            method='GET')

    assert response['status'] == '200'

    info = simplejson.loads(content)
    info['desc'] = 'new description'
    json = simplejson.dumps(info)

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/other',
            method='PUT', headers={'Content-Type': 'application/json'},
            body=json)

    assert response['status'] == '204'
    assert response['location'] == 'http://our_test_domain:8001/recipes/other'

    response, content = http.requestU(response['location'],
            headers={'Accept': 'application/json'},
            method='GET')

    assert response['status'] == '200'

    info = simplejson.loads(content)
    assert info['desc'] == 'new description'


def test_put_recipe_415():
    """
    Get a recipe as text then fail to put it back as wiki.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long.txt',
            method='GET')

    text = content
    assert response['status'] == '200'

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/other',
            method='PUT', headers={'Content-type': 'text/x-tiddlywiki'},
            body=text)

    assert response['status'] == '415'


def test_delete_recipe():
    """
    DELETE the other recipe
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/other',
            method='DELETE')
    assert response['status'] == '204'

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/other',
            method='GET')
    assert response['status'] == '404'

    # what happens when we delete the same recipe again?
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/other',
            method='DELETE')
    assert response['status'] == '404'


def test_get_recipe_wiki_bag_constraints():
    """
    Make sure that when the constraints on a bag don't let read
    that a recipe with that bag throws an error.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers',
            method='GET')
    assert response['status'] == '200'

    _put_bag_policy('bag28', dict(policy=dict(read=['NONE'])))
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers',
            method='GET')
    assert response['status'] == '403'
    assert 'may not read' in content


def test_roundtrip_unicode_recipe():
    encoded_recipe_name = '%E3%81%86%E3%81%8F%E3%81%99'
    recipe_name = unquote(encoded_recipe_name)
    recipe_list = [[recipe_name, '']]
    body = simplejson.dumps(dict(desc='', recipe=recipe_list))
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/%s' % encoded_recipe_name,
            method='PUT', body=body.encode('utf-8'),
            headers={'Content-Type': 'application/json'})
    assert response['status'] == '204'

    recipe = Recipe(recipe_name)
    recipe = store.get(recipe)
    assert recipe.get_recipe() == recipe_list

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/%s.json'
                % encoded_recipe_name,
            method='GET')
    assert response['status'] == '200'
    assert simplejson.loads(content)['recipe'] == recipe_list


def test_recipe_policy():
    recipe_dict = {
            'desc': 'hello',
            'policy': {'manage': ['cdent'], 'read': []},
            'recipe': [['bag0', '']],
            }
    recipe_json = simplejson.dumps(recipe_dict)

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/boom', method='PUT',
            headers={'Content-Type': 'application/json'}, body=recipe_json)
    assert response['status'] == '204'

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/boom', method='GET')
    assert response['status'] == '200'

    recipe_dict = {
            'desc': 'hello',
            'policy': {'manage': ['cdent'], 'read': ['NONE']},
            'recipe': [['bag0', '']],
            }
    recipe_json = simplejson.dumps(recipe_dict)

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/boom', method='PUT',
            headers={'Content-Type': 'application/json',
                'Authorization': 'Basic %s' % authorization},
            body=recipe_json)
    assert response['status'] == '204'

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/boom', method='GET')
    assert response['status'] == '403'

    recipe_dict = {
            'desc': 'hello',
            'policy': {'manage': ['NONE'], 'read': ['NONE']},
            'recipe': [['bag0', '']],
            }
    recipe_json = simplejson.dumps(recipe_dict)
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/boom', method='PUT',
            headers={'Content-Type': 'application/json',
                'Authorization': 'Basic %s' % authorization},
            body=recipe_json)
    assert response['status'] == '204'

    recipe_dict = {
            'desc': 'hello',
            'policy': {'manage': ['cdent'], 'read': ['NONE']},
            'recipe': [['bag0', '']],
            }
    recipe_json = simplejson.dumps(recipe_dict)
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/boom', method='PUT',
            headers={'Content-Type': 'application/json',
                'Authorization': 'Basic %s' % authorization},
            body=recipe_json)
    assert response['status'] == '403'


def test_recipe_bad_filter_400():
    recipe = Recipe('badfilter')
    recipe.desc = u'hello'
    recipe.set_recipe([('bag8', 'select=error:5')])
    store.put(recipe)

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/badfilter/tiddlers')
    assert response['status'] == '400', content


def test_put_recipe():
    """
    Get a recipe as json then put it back with a different name
    using vnd.tiddlyweb.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long.json',
            method='GET')

    json = content
    assert response['status'] == '200'

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/other',
            method='PUT', headers={'Content-Type':
                'application/vnd.tiddlyweb+json'},
            body=json)

    assert response['status'] == '204'
    assert response['location'] == 'http://our_test_domain:8001/recipes/other'


def _put_bag_policy(bag_name, policy_dict):
    """
    XXX: This is duplicated from test_web_tiddler. Clean up!
    """
    json = simplejson.dumps(policy_dict)

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/%s' % bag_name,
            method='PUT', headers={'Content-Type': 'application/json'},
            body=json)
    assert response['status'] == '204'

########NEW FILE########
__FILENAME__ = test_web_recipes


from .fixtures import reset_textstore, _teststore, initialize_app, get_http
from tiddlyweb.model.recipe import Recipe


http = get_http()


def setup_module(module):
    initialize_app()
    reset_textstore()
    module.store = _teststore()

    for i in range(5):
        recipe = Recipe('recipe%s' % i)
        recipe.set_recipe([('monkey', '')])
        module.store.put(recipe)


def test_get_recipes_txt():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '200'
    for i in range(5):
        assert 'recipe%s\n' % i in content

    assert 'etag' in response
    etag = response['etag']

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes',
            headers={'Accept': 'text/plain', 'if-none-match': etag},
            method='GET')
    assert response['status'] == '304', content

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes',
            headers={'Accept': 'text/plain', 'if-none-match': etag + 'foo'},
            method='GET')
    assert response['status'] == '200', content


def test_get_recipes_filters():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes?select=name:recipe1',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '200', content
    assert 'recipe1\n' in content
    assert 'recipe2\n' not in content


def test_get_recipes_filters_bad_select():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes?select=text:recipe1',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '400', content
    assert 'malformed filter' in content
    assert "object has no attribute 'text'" in content


def test_get_recipes_filters_rbag():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes?select=rbag:monkey',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '200', content
    assert 'recipe0' in content


def test_get_recipes_selected_sorted_filters():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes?select=name:>recipe2',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '200', content
    assert 'recipe1\n' not in content
    assert 'recipe2\n' not in content
    assert 'recipe3\n' in content


def test_get_recipes_sorted_filters():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes?sort=-name',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '200', content
    assert 'recipe4\nrecipe3\nrecipe2\nrecipe1\nrecipe0' in content


def test_get_recipes_sorted_limitedfilters():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes?sort=-name;limit=1,1',
            headers={'Accept': 'text/plain'},
            method='GET')

    assert response['status'] == '200', content
    assert content == 'recipe3\n'

########NEW FILE########
__FILENAME__ = test_web_search
"""
Test search via the web.
"""


import sys
import simplejson

from .fixtures import (muchdata, reset_textstore, _teststore, initialize_app,
        get_http)

http = get_http()


def setup_module(module):
    initialize_app()
    reset_textstore()
    module.store = _teststore()
    muchdata(module.store)


def test_simple_search():
    response, content = http.request(
            'http://our_test_domain:8001/search?q=tiddler%200',
            headers={'User-Agent': 'Mozilla'},
            method='GET')

    assert response['status'] == '200'


def test_title_search():
    response, content = http.request(
            'http://our_test_domain:8001/search?q=tiddler0',
            method='GET')

    assert response['status'] == '200'


def test_malformed_search():
    response, content = http.request(
            'http://our_test_domain:8001/search',
            method='GET')

    assert response['status'] == '400'


def test_json_search():
    response, content = http.requestU(
            'http://our_test_domain:8001/search.json?q=tiddler%200',
            method='GET')

    assert response['status'] == '200'
    assert 'application/json' in response['content-type']
    info = simplejson.loads(content)
    assert len(info) == 30


def test_search_bad_ext():
    response, content = http.request(
            'http://our_test_domain:8001/search.monkey?q=tiddler%200',
            method='GET')

    assert response['status'] == '415'


def test_search_bad_ext_accept():
    response, content = http.request(
            'http://our_test_domain:8001/search.monkey?q=tiddler%200',
            method='GET',
            headers={'Accept': 'text/html'})

    assert response['status'] == '415'


def test_json_search_filtered():
    response, content = http.requestU(
            'http://our_test_domain:8001/search.json?q=tiddler%200;select=tag:tagtwo',
            method='GET')

    assert response['status'] == '200'
    assert 'application/json' in response['content-type']
    assert 'charset' not in response['content-type']
    info = simplejson.loads(content)
    assert len(info) == 30

########NEW FILE########
__FILENAME__ = test_web_tiddler
"""
Test that GETting a tiddler in some form.
"""

import os
import sys

import py.test

import httplib2
import simplejson

from base64 import b64encode
from re import match

from .fixtures import (muchdata, reset_textstore, _teststore, initialize_app,
        get_http)

import tiddlyweb.stores.text

from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.model.user import User
from tiddlyweb.web.util import http_date_from_timestamp

authorization = b64encode('cdent:cowpig'.encode('utf-8')).decode('utf-8')
bad_authorization = b64encode('cdent:cdent'.encode('utf-8')).decode('utf-8')
no_user_authorization = b64encode('foop:foop'.encode('utf-8')).decode('utf-8')

text_put_body = u"""modifier: JohnSmith
created: 
modified: 200803030303
tags: tagone
type: 

Hello, I'm John Smith \xbb and I have something to sell.
"""

http = get_http()


def setup_module(module):
    initialize_app()
    reset_textstore()
    module.store = _teststore()
    muchdata(module.store)

    user = User('cdent')
    user.set_password('cowpig')
    module.store.put(user)

    try:
        os.mkdir('.test_cache')
    except OSError:
        pass  # we don't care if it already exists


def test_get_tiddler():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/tiddler8',
            method='GET')

    assert response['status'] == '200', content
    assert 'i am tiddler 8' in content


def test_bad_http_caching_timestamp():
    """
    Thunderbird's feed module sends `If-Modified-Since: 0`, which is invalid -
    Postel demands that we don't freak out over that
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/tiddler8',
            method='GET', headers={'If-Modified-Since': '0'})

    assert response['status'] == '200', content


def test_get_tiddler_revision():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/tiddler8/revisions/1',
            method='GET')

    assert response['status'] == '200'
    assert 'i am tiddler 8' in content
    assert 'revision="1"' in content


def test_get_missing_tiddler():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/tiddler27',
            method='GET')

    assert response['status'] == '404'


def test_get_missing_tiddler_revision():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/tiddler27/revisions/99',
            method='GET')

    assert response['status'] == '404'


def test_get_tiddler_missing_revision():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/tiddler8/revisions/99',
            method='GET')

    assert response['status'] == '404'


def test_put_tiddler_txt():
    encoded_body = text_put_body.encode('utf-8')
    funkity_encoding = text_put_body.encode('latin1')
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/TestOne',
            method='PUT',
            headers={'Content-Type': 'text/plain'},
            body=encoded_body)
    tiddler_url = response['location']
    assert response['status'] == '204', content

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/TestOne',
            method='PUT', headers={'Content-Type': 'text/plain'},
            body=funkity_encoding)

    assert response['status'] == '400', content
    assert 'unable to decode tiddler' in content

    assert tiddler_url == 'http://our_test_domain:8001/bags/bag0/tiddlers/TestOne'

    response, content = http.requestU(tiddler_url,
            headers={'Accept': 'text/plain'})
    contents = content.strip().split('\n\n')[0].split('\n')
    texts = text_put_body.strip().split('\n\n')[0].split('\n')
    received_headers = dict((key, value)
            for key, value in [line.split(': ') for line in contents])
    sent_headers = dict((key, value)
            for key, value in [line.split(': ') for line in texts])
    assert sent_headers['type'] == received_headers['type']
    assert sent_headers['tags'] == received_headers['tags']
    assert sent_headers['modifier'] == 'JohnSmith'
    assert received_headers['modifier'] == 'GUEST'
    assert received_headers['creator'] == 'GUEST'


def test_put_tiddler_txt_with_modifier():
    """
    Putting a tiddler with modifier and no auth should result in default.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/TestOne',
            method='PUT',
            headers={'Content-Type': 'text/plain'},
            body='modifier: ArthurDent\n\nTowels')

    assert response['status'] == '204'
    tiddler_url = response['location']
    assert tiddler_url == 'http://our_test_domain:8001/bags/bag0/tiddlers/TestOne'

    response, content = http.requestU(tiddler_url,
            headers={'Accept': 'text/plain'})
    assert 'modified: 2' in content
    assert 'modifier: GUEST' in content
    assert 'creator: GUEST' in content


def test_put_tiddler_json():
    json = simplejson.dumps(dict(text='i fight for the users',
        tags=['tagone', 'tagtwo'], modifier=''))

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/TestTwo',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'Content-Length': '0'},
            body='')
    assert response['status'] == '400'
    assert 'unable to make json into' in content

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/TestTwo',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body='{"text": "}')
    assert response['status'] == '400'
    assert 'unable to make json into' in content

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/TestTwo',
            method='PUT', headers={'Content-Type': 'application/json'},
            body=json)

    assert response['status'] == '204'
    tiddler_url = response['location']
    assert (tiddler_url ==
            'http://our_test_domain:8001/bags/bag0/tiddlers/TestTwo')

    response, content = http.requestU(tiddler_url,
            headers={'Accept': 'application/json'})
    info = simplejson.loads(content)
    now_time = http_date_from_timestamp('')
    assert response['last-modified'].split(':', 1)[0] == (
            now_time.split(':', 1)[0])
    assert info['title'] == 'TestTwo'
    assert info['text'] == 'i fight for the users'
    assert info['uri'] == tiddler_url


def test_put_tiddler_json_with_slash():
    json = simplejson.dumps(dict(text='i fight for the users',
        tags=['tagone', 'tagtwo'], modifier='',
        modified='200805230303', created='200803030303'))

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/Test%2FSlash',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json)

    assert response['status'] == '204'
    assert response['location'] == 'http://our_test_domain:8001/bags/bag0/tiddlers/Test%2FSlash'


def test_put_tiddler_html_in_json():
    json = simplejson.dumps(dict(
        text='<html><head><title>HI</title><body><h1>HI</h1></body></html>'))

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/TestHTML',
            method='PUT', headers={'Content-Type': 'application/json'},
            body=json)

    assert response['status'] == '204'
    location = response['location']

    response, content = http.requestU(
            location,
            headers={'User-Agent': 'Mozilla'})
    assert response['status'] == '200'
    assert 'text/html; charset=UTF-8' in response['content-type']
    # Title should not be there
    assert '<title>HI</title>' not in content
    assert '<title>TiddlyWeb - TestHTML</title>' in content
    assert '&lt;h1&gt;HI&lt;/h1&gt;' in content

    json = simplejson.dumps(dict(
        text='<html><head><title>HI</title><body><h1>HI</h1></body></html>',
        type='text/html'))

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/TestHTML',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'User-Agent': 'Mozilla'},
            body=json)

    assert response['status'] == '204'
    location = response['location']

    response, content = http.requestU(location)
    assert response['status'] == '200'
    assert 'text/html; charset=UTF-8' in response['content-type']
    # Title should not be wrapping in tiddly info
    assert '<title>HI</title>' in content
    assert '<h1>HI</h1>' in content


def test_put_tiddler_json_bad_path():
    """
    / in tiddler title is an unresolved source of some confusion.
    """
    if type(store.storage) != tiddlyweb.stores.text.Store:
        py.test.skip('skipping this test for non-text store')

    json = simplejson.dumps(dict(text='i fight for the users 2',
        tags=['tagone', 'tagtwo'], modifier='',
        modified='200803030303', created='200803030303'))

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/..%2F..%2F..%2F..%2FTestThree',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json)

    assert response['status'] == '404'


def test_put_tiddler_json_no_bag():
    json = simplejson.dumps(dict(text='i fight for the users 2',
        tags=['tagone', 'tagtwo'], modifier='', modified='200803030303',
        created='200803030303'))

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/nobagheremaam/tiddlers/SomeKindOTiddler',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json)

    assert response['status'] == '409'
    assert 'There is no bag named: nobagheremaam' in content


def test_get_tiddler_via_recipe():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/tiddler8.json',
            method='GET')

    assert response['status'] == '200', content
    tiddler_info = simplejson.loads(content)
    assert tiddler_info['bag'] == 'bag28'


def test_get_tiddler_etag_recipe():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/tiddler8.json',
            method='GET')

    assert response['status'] == '200'
    assert response['etag'].startswith('"bag28/tiddler8/1:')
    tiddler_info = simplejson.loads(content)
    assert tiddler_info['bag'] == 'bag28'


def test_get_tiddler_etag_bag():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag28/tiddlers/tiddler8.json',
            method='GET')

    assert response['status'] == '200'
    assert response['etag'].startswith('"bag28/tiddler8/1:')
    tiddler_info = simplejson.loads(content)
    assert tiddler_info['bag'] == 'bag28'


def test_get_tiddler_manual_cache():
    [os.unlink('.test_cache/%s' % x) for x in os.listdir('.test_cache')]
    http = httplib2.Http('.test_cache')
    tiddler = Tiddler('cached', 'bag28')
    tiddler.text = 'hi!'
    tiddler.fields['_cache-max-age'] = 3000
    store.put(tiddler)

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag28/tiddlers/cached')
    assert not response.fromcache
    assert response['status'] == '200'
    assert response['cache-control'] == 'max-age=3000, no-transform'
    assert 'text/html; charset=UTF-8' in response['content-type']
    htmletag = response['etag']

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag28/tiddlers/cached',
            headers={'Accept': 'text/plain'})
    assert not response.fromcache
    assert response['status'] == '200'
    assert response['cache-control'] == 'max-age=3000, no-transform'
    assert 'text/plain; charset=UTF-8' in response['content-type']

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag28/tiddlers/cached')
    # this one does not cache because we Vary on Accept
    assert not response.fromcache
    assert response['status'] == '200'
    assert response['etag'] == htmletag

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag28/tiddlers/cached')
    assert response.fromcache
    assert response['status'] == '304'
    assert 'text/html; charset=UTF-8' in response['content-type']
    assert response['etag'] == htmletag

    tiddler = Tiddler('notcached', 'bag28')
    tiddler.text = 'hi!'
    tiddler.fields['_cache-max-age'] = 'salami'
    store.put(tiddler)
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag28/tiddlers/notcached')
    assert not response.fromcache
    assert response['status'] == '200'
    assert response['cache-control'] == 'no-cache, no-transform'
    assert 'max-age' not in response['cache-control']
    assert 'text/html; charset=UTF-8' in response['content-type']


def test_get_tiddler_cached():
    [os.unlink('.test_cache/%s' % x) for x in os.listdir('.test_cache')]
    http = httplib2.Http('.test_cache')
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag28/tiddlers/tiddler8',
            headers={'Accept': 'application/json'},
            method='GET')
    assert not response.fromcache
    assert response['status'] == '200'
    assert response['etag'].startswith('"bag28/tiddler8/1:')

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag28/tiddlers/tiddler8',
            headers={'Accept': 'application/json'},
            method='GET')
    assert response.fromcache
    assert response['status'] == '304'
    assert response['etag'].startswith('"bag28/tiddler8/1:')

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag28/tiddlers/tiddler8',
            headers={'Accept': 'text/html'},
            method='GET')
    assert response['etag'].startswith('"bag28/tiddler8/1:')
    assert not response.fromcache
    assert response['status'] == '200'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag28/tiddlers/tiddler8',
            headers={'Accept': 'application/json'},
            method='GET')
    assert not response.fromcache
    assert response['status'] == '200'
    assert response['etag'].startswith('"bag28/tiddler8/1:')

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag28/tiddlers/tiddler8',
            headers={'Accept': 'application/json'},
            method='GET')
    assert response.fromcache
    assert response['status'] == '304'
    assert response['etag'].startswith('"bag28/tiddler8/1:')


def test_put_tiddler_recipe_with_filter():
    recipe = Recipe('recipe1')
    bag1 = Bag('bag1')
    bag2 = Bag('bag2')
    recipe.set_recipe([('bag1', ''), ('bag2', 'select=tag:foo')])
    store.put(bag1)
    store.put(bag2)
    store.put(recipe)

    tiddler_json_one = simplejson.dumps(dict(text='hello', tags=[]))
    tiddler_json_two = simplejson.dumps(dict(text='hello', tags=['foo']))

    response, content = http.request(
            'http://our_test_domain:8001/recipes/recipe1/tiddlers/tiddler_one',
            headers={'Content-Type': 'application/json'},
            method='PUT',
            body=tiddler_json_one)
    assert response['status'] == '204'
    assert 'bag1' in response['etag']

    response, content = http.request(
            'http://our_test_domain:8001/recipes/recipe1/tiddlers/tiddler_two',
            headers={'Content-Type': 'application/json'},
            method='PUT',
            body=tiddler_json_two)
    assert response['status'] == '204'
    assert 'bag2' in response['etag']

    tiddler = Tiddler('tiddler_three', 'bag2')
    tiddler.tags = ['foo']
    store.put(tiddler)

    response, content = http.request(
            'http://our_test_domain:8001/recipes/recipe1/tiddlers/tiddler_two',
            headers={'Content-Type': 'application/json'},
            method='PUT',
            body=tiddler_json_two)
    assert response['status'] == '204'
    assert 'bag2' in response['etag']


def test_put_tiddler_cache_fakey():
    [os.unlink('.test_cache/%s' % x) for x in os.listdir('.test_cache')]
    http_caching = httplib2.Http('.test_cache')
    http = httplib2.Http()

    json = simplejson.dumps(dict(text='i fight for the users 2',
        tags=['tagone', 'tagtwo'], modifier='',
        modified='200803030303', created='200803030303'))

    response, content = http_caching.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/CashForCache',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json)
    assert response['status'] == '204'
    assert response['etag'].startswith('"bag1/CashForCache/1:')

    response, content = http_caching.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/CashForCache',
            method='GET',
            headers={'Accept': 'application/json'})
    assert response['status'] == '200'
    assert response['etag'].startswith('"bag1/CashForCache/1:')

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/CashForCache',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json)
    assert response['status'] == '204'
    assert response['etag'].startswith('"bag1/CashForCache/2:')

    response, content = http_caching.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/CashForCache',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json)
    assert response['status'] == '412'


def test_put_tiddler_via_recipe():
    json = simplejson.dumps(dict(text='i fight for the users 2',
        tags=['tagone', 'tagtwo'], modifier='', modified='200803030303',
        created='200803030303'))

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/FantasticVoyage',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json)

    assert response['status'] == '204'
    assert response['etag'].startswith('"bag1/FantasticVoyage/1:')
    url = response['location']

    reponse, content = http.requestU(url,
            method='GET',
            headers={'Accept': 'application/json'})
    tiddler_dict = simplejson.loads(content)
    assert tiddler_dict['bag'] == 'bag1'
    assert response['etag'].startswith('"bag1/FantasticVoyage/1:')


def test_slash_in_etag():
    json = simplejson.dumps(dict(text='i fight for the users',
        tags=['tagone', 'tagtwo'], modifier='', modified='200805230303',
        created='200803030303'))

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/Test%2FTwo',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json)
    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/Test%2FTwo',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'If-Match': '"bag0/Test%2FTwo/1"'},
            body=json)
    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/Test%2FTwo',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'If-Match': '"bag0/Test/Two/2"'},
            body=json)
    assert response['status'] == '412'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/Test%2FTwo',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'If-Match': '"bag0/Test%2FTwo/2"'},
            body=json)
    assert response['status'] == '204'


def test_paren_in_etag():
    json = simplejson.dumps(dict(text='i fight for the users',
        tags=['tagone', 'tagtwo'], modifier='', modified='200805230303',
        created='200803030303'))

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/Test(Two)',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json)
    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/Test(Two)',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'If-Match': '"bag0/Test(Two)/1"'},
            body=json)
    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/Test(Two)',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'If-Match': '"bag0/Test%28Two%29/2"'},
            body=json)
    assert response['status'] == '412'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/Test(Two)',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'If-Match': '"bag0/Test(Two)/2"'},
            body=json)
    assert response['status'] == '204'


def test_get_tiddler_text_created():
    """
    Make sure the tiddler comes back to us as we expect.
    In the process confirm that Accept header processing is working
    as expect, by wanting xml (which we don't do), more than text/plain,
    which we do.
    """
    tiddler_url = 'http://our_test_domain:8001/bags/bag0/tiddlers/TestOne'
    response, content = http.requestU(tiddler_url,
            headers={'Accept': 'text/xml; q=1, text/plain'})

    contents = content.strip().rstrip().split('\n')
    assert contents[-1] == u'Towels'  # text
    assert contents[0] == u'creator: GUEST'
    assert match(r'^created: \d{14}$', contents[1])


def test_tiddler_bag_constraints():
    encoded_body = text_put_body.encode('utf-8')
    _put_policy('unreadable',
            dict(policy=dict(manage=['cdent'], read=['NONE'],
                write=['NONE'], create=['NONE'])))

    # try to create a tiddler and fail
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/unreadable/tiddlers/WroteOne',
            method='PUT',
            headers={'Content-Type': 'text/plain',
                'Authorization': 'Basic %s' % authorization},
            body=encoded_body)
    assert response['status'] == '403'
    assert 'may not create' in content

    # create and succeed
    _put_policy('unreadable',
            dict(policy=dict(manage=['cdent'], read=['NONE'],
                write=['NONE'], create=['cdent'])))
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/unreadable/tiddlers/WroteOne',
            method='PUT',
            headers={'Content-Type': 'text/plain',
                'Authorization': 'Basic %s' % authorization},
            body=encoded_body)
    assert response['status'] == '204'

    # fail when bad auth format
    _put_policy('unreadable',
            dict(policy=dict(manage=['cdent'], read=['NONE'],
                write=['NONE'], create=['cdent'])))
    response, content = http.request(
            'http://our_test_domain:8001/bags/unreadable/tiddlers/WroteOne',
            method='PUT',
            headers={'Content-Type': 'text/plain',
                'Authorization': '%s' % authorization},
            body=encoded_body)
    assert response['status'] == '403'

    # fail when bad auth info
    _put_policy('unreadable',
            dict(policy=dict(manage=['cdent'], read=['NONE'],
                write=['NONE'], create=['cdent'])))
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/unreadable/tiddlers/WroteOne',
            method='PUT',
            headers={'Content-Type': 'text/plain',
                'Authorization': 'Basic %s' % bad_authorization},
            body=encoded_body)
    assert response['status'] == '403'

    # fail when bad user info
    _put_policy('unreadable',
            dict(policy=dict(manage=['cdent'], read=['NONE'],
                write=['NONE'], create=['cdent'])))
    response, content = http.request(
            'http://our_test_domain:8001/bags/unreadable/tiddlers/WroteOne',
            method='PUT',
            headers={'Content-Type': 'text/plain',
                'Authorization': 'Basic %s' % no_user_authorization},
            body=encoded_body)
    assert response['status'] == '403'

    # write and fail
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/unreadable/tiddlers/WroteOne',
            method='PUT',
            headers={'Content-Type': 'text/plain',
                'Authorization': 'Basic %s' % authorization},
            body=encoded_body)
    assert response['status'] == '403'
    assert 'may not write' in content

    # write and succeed
    _put_policy('unreadable',
            dict(policy=dict(manage=['cdent'], read=['NONE'],
                write=['cdent'], create=['NONE'])))
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/unreadable/tiddlers/WroteOne',
            method='PUT',
            headers={'Content-Type': 'text/plain',
                'Authorization': 'Basic %s' % authorization},
            body=encoded_body)
    assert response['status'] == '204'

    # read and fail
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/unreadable/tiddlers/WroteOne',
            method='GET',
            headers={'Accept': 'text/plain',
                'Authorization': 'Basic %s' % authorization})
    assert response['status'] == '403'
    assert 'may not read' in content

    # update the policy so we can read and GET the thing
    _put_policy('unreadable',
            dict(policy=dict(manage=['cdent'], read=['cdent'],
                write=['NONE'], delete=['NONE'])))
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/unreadable/tiddlers/WroteOne',
            method='GET',
            headers={'Accept': 'text/plain',
                'Authorization': 'Basic %s' % authorization})
    assert response['status'] == '200'
    assert 'John Smith' in content


def test_get_tiddler_via_recipe_with_perms():
    _put_policy('bag28',
            dict(policy=dict(manage=['cdent'], read=['NONE'],
                write=['NONE'])))
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/tiddler8.json',
            method='GET')
    assert response['status'] == '403'
    assert 'may not read' in content

    _put_policy('bag28',
            dict(policy=dict(manage=['cdent'], read=['cdent'],
                write=['NONE'])))
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/tiddler8.json',
            headers=dict(Authorization='Basic %s' % authorization),
            method='GET')
    assert response['status'] == '200'

    tiddler_info = simplejson.loads(content)
    assert tiddler_info['bag'] == 'bag28'

    encoded_body = text_put_body.encode('utf-8')
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/tiddler8',
            method='PUT',
            headers={'Content-Type': 'text/plain',
                'Authorization': 'Basic %s' % authorization},
            body=encoded_body)
    assert response['status'] == '403'
    assert 'may not write' in content

    _put_policy('bag28',
            dict(policy=dict(manage=['cdent'], read=['cdent'],
                write=['nancy'])))
    encoded_body = text_put_body.encode('utf-8')
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/tiddler8',
            method='PUT',
            headers={'Content-Type': 'text/plain',
                'Authorization': 'Basic %s' % authorization},
            body=encoded_body)
    assert response['status'] == '403'

    _put_policy('bag28',
            dict(policy=dict(manage=['cdent'], read=['cdent'],
                write=['cdent'])))
    encoded_body = text_put_body.encode('utf-8')
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/tiddler8',
            method='PUT',
            headers={'Content-Type': 'text/plain'},
            body=encoded_body)
    # when we PUT without permission there's no good way to handle auth
    # so we just forbid.
    assert response['status'] == '403'


def test_delete_tiddler_in_recipe():
    """disabled in tiddlyweb 1.1"""
    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/tiddler8',
            method='DELETE')
    assert response['status'] == '405'


def test_delete_tiddler_in_bag():
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/TestOne',
            method='DELETE')
    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/TestOne',
            method='DELETE')
    assert response['status'] == '404'


def test_delete_tiddler_etag():
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag5/tiddlers/tiddler0',
            method='DELETE',
            headers={'If-Match': '"bag5/tiddler0/9"'})
    assert response['status'] == '412'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag5/tiddlers/tiddler0',
            method='DELETE',
            headers={'If-Match': '"bag5/tiddler0/1"'})
    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag5/tiddlers/tiddler0',
            method='DELETE')
    assert response['status'] == '404'


def test_delete_tiddler_in_bag_perms():
    _put_policy('bag0',
            dict(policy=dict(manage=['cdent'], read=['cdent'],
                write=['cdent'], delete=['cdent'])))
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/tiddler0',
            method='DELETE')
    assert response['status'] == '403'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/tiddler0',
            method='DELETE',
            headers={'Authorization': 'Basic %s' % authorization})
    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/tiddler0',
            method='DELETE',
            headers={'Authorization': 'Basic %s' % authorization})
    assert response['status'] == '404'


def test_tiddler_no_recipe():
    response, content = http.request(
            'http://our_test_domain:8001/recipes/short/tiddlers/tiddler8',
            method='GET')
    assert response['status'] == '404'


def test_binary_text_tiddler():
    text = 'alert("hello");'
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/jquery.min.js',
            method='PUT',
            headers={'Content-Type': 'text/javascript'},
            body=text)
    assert response['status'] == '204', content

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/jquery.min.js',
            method='GET')
    assert response['status'] == '200'
    assert content == text

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/jquery.min.js',
            headers={'Accept': 'application/json'},
            method='GET')
    assert response['status'] == '200'
    assert '"text"' in content

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/jquery.min.js.json',
            method='GET')
    assert response['status'] == '200'
    assert '"text"' in content


def test_binary_tiddler():
    image = open('test/peermore.png', 'rb')
    image_content = image.read()
    image.close()

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermorepng',
            method='PUT',
            headers={'Content-Type': 'image/png'},
            body=image_content)

    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermore.png',
            method='PUT',
            headers={'Content-Type': 'image/png'},
            body=image_content)

    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermore.foo.png',
            method='PUT',
            headers={'Content-Type': 'image/png'},
            body=image_content)

    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermore.foo.bar',
            method='PUT',
            headers={'Content-Type': 'image/png'},
            body=image_content)

    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermorepng',
            method='GET')
    assert response['status'] == '200'
    assert response['content-type'] == 'image/png'

    # make sure a binary tiddler in a recipe doesn't cause a select
    # filter to blow up
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag1/tiddlers?select=text:hello',
            method='GET')
    assert response['status'] == '200'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermorepng.json',
            method='GET')
    assert response['status'] == '200'
    assert response['content-type'] == 'application/json'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermorepng',
            headers={'Accept': 'application/json'},
            method='GET')
    assert response['status'] == '200'
    assert response['content-type'] == 'application/json'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermore.png',
            method='GET')
    assert response['status'] == '200'
    assert response['content-type'] == 'image/png'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermore.png.json',
            method='GET')
    assert response['status'] == '200'
    assert response['content-type'] == 'application/json'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermore.png',
            headers={'Accept': 'application/json'},
            method='GET')
    assert response['status'] == '200'
    assert response['content-type'] == 'application/json'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermore.foo.png',
            method='GET')
    assert response['status'] == '200'
    assert response['content-type'] == 'image/png'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermore.foo.png.json',
            method='GET')
    assert response['status'] == '200'
    assert response['content-type'] == 'application/json'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermore.foo.png',
            headers={'Accept': 'application/json'},
            method='GET')
    assert response['status'] == '200'
    assert response['content-type'] == 'application/json'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermore.foo.bar',
            method='GET')
    assert response['status'] == '200'
    assert response['content-type'] == 'image/png'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermore.foo.bar.json',
            method='GET')
    assert response['status'] == '200'
    assert response['content-type'] == 'application/json'

    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/peermore.foo.bar',
            headers={'Accept': 'application/json'},
            method='GET')
    assert response['status'] == '200'
    assert response['content-type'] == 'application/json'


def test_put_json_pseudo_binary():
    json_internal = simplejson.dumps(dict(alpha='car', beta='zoom'))
    json_external = simplejson.dumps(dict(text=json_internal,
        type='application/json'))

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag5/tiddlers/intjson',
            method='PUT',
            body=json_external,
            headers={'Content-Type': 'application/json'})

    assert response['status'] == '204', content

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag5/tiddlers/intjson.json')

    assert response['status'] == '200', content

    info = simplejson.loads(content)
    assert info['text'] == json_internal

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag5/tiddlers/intjson',
            headers={'Accept': 'application/json'})

    assert response['status'] == '200', content
    assert content == json_internal


def test_bad_uri_encoding():
    py.test.skip('modern python does not allow this web request')
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag5/tiddlers/\x8a\xfa\x91\xd2\x96{\x93y\x98A\xe3\x94\x8c\x80\x92\xf1\x8f\xa1')
    assert response['status'] == '400', content
    assert "codec can't" in content


def test_tiddler_put_create():
    tiddler_data = simplejson.dumps(dict(text='hello'))
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag5/tiddlers/hellotiddler',
            method='PUT',
            headers={'If-Match': '"monkeypetard"'})
    # no body raises 400
    assert response['status'] == '400'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag5/tiddlers/hellotiddler',
            method='PUT',
            headers={'If-Match': '"monkeypetard"'},
            body=tiddler_data)
    # no content type raises 400
    assert response['status'] == '400'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag5/tiddlers/hellotiddler',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'If-Match': '"monkeypetard"'},
            body=tiddler_data)
    # Bad form ETag causes 412 on create
    assert response['status'] == '412'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag5/tiddlers/hellotiddler',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'If-Match': '"bag5/hellotiddler/99"'},
            body=tiddler_data)
    # Bad form ETag causes 412 on create
    assert response['status'] == '412'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag5/tiddlers/hellotiddler',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=tiddler_data)
    # No ETag we get 204
    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag5/tiddlers/hellotiddler2',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'If-Match': '"bag5/hellotiddler2/0"'},
            body=tiddler_data)
    # Correct ETag we get 204
    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag5/tiddlers/hellotiddler2',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'If-Match': '"bag5/hellotiddler2/1"'},
            body=tiddler_data)
    # Correct ETag we get 204
    assert response['status'] == '204'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag5/tiddlers/hellotiddler2',
            method='PUT',
            headers={'Content-Type': 'application/json',
                'If-Match': '"bag5/hellotiddler2/2:application/heartattack"'},
            body=tiddler_data)
    # Correct ETag we get 204
    assert response['status'] == '204'


def test_bad_tags_json_put():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag5/tiddlers/hellotiddler3',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body='{"tags":[["foo","bar","baz"]]}')
    assert response['status'] == '409'
    assert 'Unable to put badly formed tiddler' in content


def test_put_canonical():
    json_data = simplejson.dumps({'fields': {
        '_canonical_uri': 'http://peermore.com/images/peermore.png'}})
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag5/tiddlers/cantiddler',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=json_data)

    assert response['status'] == '204'
    assert response['location'] == 'http://our_test_domain:8001/bags/bag5/tiddlers/cantiddler'

    nested_response = None
    try:
        response, content = http.request(
                'http://our_test_domain:8001/bags/bag5/tiddlers/cantiddler',
                redirections=0)
    except httplib2.RedirectLimit as exc:
        nested_response = exc

    assert nested_response
    assert nested_response.response['status'] == '302'
    assert nested_response.response['location'] == 'http://peermore.com/images/peermore.png'

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag5/tiddlers/cantiddler',
            headers={'Accept': 'application/json'})
    assert response['status'] == '200'
    info = simplejson.loads(content)
    assert info['fields']['_canonical_uri'] == 'http://peermore.com/images/peermore.png'

    # vnd.tiddlyweb
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag5/tiddlers/cantiddler',
            headers={'Accept': 'application/vnd.tiddlyweb+json'})
    assert response['status'] == '200'
    info = simplejson.loads(content)
    assert info['fields']['_canonical_uri'] == 'http://peermore.com/images/peermore.png'

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag5/tiddlers/cantiddler.json')
    assert response['status'] == '200'
    info = simplejson.loads(content)
    assert info['fields']['_canonical_uri'] == 'http://peermore.com/images/peermore.png'

    # immitate browser being defaulty
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag5/tiddlers/cantiddler.json',
            headers={'Accept': 'text/html'})
    assert response['status'] == '200'
    info = simplejson.loads(content)
    assert info['fields']['_canonical_uri'] == 'http://peermore.com/images/peermore.png'


def _put_policy(bag_name, policy_dict):
    json = simplejson.dumps(policy_dict)

    response, content = http.request(
            'http://our_test_domain:8001/bags/%s' % bag_name,
            method='PUT',
            headers={'Content-Type': 'application/json',
                'Authorization': 'Basic %s' % authorization},
            body=json)
    assert response['status'] == '204'

########NEW FILE########
__FILENAME__ = test_web_tiddlers_fields
"""
Test extended fields on tiddlers via the HTTP API.
"""


import simplejson

from .fixtures import (reset_textstore, _teststore, muchdata, initialize_app,
        get_http)

http = get_http()


def setup_module(module):
    initialize_app()
    reset_textstore()
    module.store = _teststore()
    muchdata(module.store)


def test_put_tiddler_with_fields():
    tiddler_dict = {
            'tags': ['one', 'two', 'three'],
            'text': 'hello',
            'fields': {
                'server.first': 'base',
                'field1': 'value1',
                'field2': 'value2',
            },
    }
    tiddler_json = simplejson.dumps(tiddler_dict)

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/feebles',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=tiddler_json)

    assert response['status'] == '204'


def test_get_tiddler_with_fields():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/feebles.json',
            method='GET')

    assert response['status'] == '200'
    tiddler_dict = simplejson.loads(content)
    assert tiddler_dict['text'] == 'hello'
    assert tiddler_dict['uri'] == (
            'http://our_test_domain:8001/bags/bag0/tiddlers/feebles')
    assert tiddler_dict['fields']['field1'] == 'value1'
    assert tiddler_dict['fields']['field2'] == 'value2'
    assert 'server.first' not in tiddler_dict['fields']

########NEW FILE########
__FILENAME__ = test_web_tiddler_revisions
"""
Test GETting a tiddler revision list.
"""


import simplejson

from .fixtures import (muchdata, reset_textstore, _teststore, initialize_app,
        get_http)

text_put_body = u"""modifier: JohnSmith
created: 
modified: 200803030303
tags: [[tag three]]

Hello, I'm John Smith \xbb and I have something to sell.
"""

text_put_body2 = u"""modifier: Frank
created: 
modified: 200803030303
tags: [[tag three]]

Hello, I'm John Smith \xbb and I have something to sell.
"""

http = get_http()


def setup_module(module):
    initialize_app()
    reset_textstore()
    module.store = _teststore()
    muchdata(module.store)


def test_put_tiddler_txt_1():
    encoded_body = text_put_body.encode('utf-8')
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag1/tiddlers/TestOne',
            method='PUT',
            headers={'Content-Type': 'text/plain'},
            body=encoded_body)
    assert response['status'] == '204'


def test_put_tiddler_txt_2():
    encoded_body = text_put_body.encode('utf-8')
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag1/tiddlers/TestOne',
            method='PUT',
            headers={'Content-Type': 'text/plain'},
            body=encoded_body)
    assert response['status'] == '204'


def test_put_tiddler_txt_3():
    encoded_body = text_put_body.encode('utf-8')
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag1/tiddlers/TestOne',
            method='PUT',
            headers={'Content-Type': 'text/plain'},
            body=encoded_body)
    assert response['status'] == '204'
    assert response['etag'].startswith('"bag1/TestOne/3:')


def test_put_tiddler_txt_4():
    encoded_body = text_put_body2.encode('utf-8')
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag1/tiddlers/TestOne',
            method='PUT',
            headers={'Content-Type': 'text/plain'},
            body=encoded_body)
    assert response['status'] == '204'
    assert response['etag'].startswith('"bag1/TestOne/4:')


def test_get_tiddler_revision_list():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag1/tiddlers/TestOne/revisions',
            method='GET')

    assert response['status'] == '200'
    assert '3' in content
    assert 'revisions' in content


def test_get_tiddler_revision_1():
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag1/tiddlers/TestOne/revisions/1',
            method='GET')
    assert response['status'] == '200'


def test_get_tiddler_revision_2():
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag1/tiddlers/TestOne/revisions/2',
            method='GET')
    assert response['status'] == '200'


def test_get_tiddler_revision_3():
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag1/tiddlers/TestOne/revisions/3',
            method='GET')
    assert response['status'] == '200'
    assert response['etag'].startswith('"bag1/TestOne/3:')


def test_get_tiddler_revision_5_fail():
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag1/tiddlers/TestOne/revisions/5',
            method='GET')
    assert response['status'] == '404'


def test_get_tiddler_revision_nonint_fail():
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag1/tiddlers/TestOne/revisions/four',
            method='GET')
    assert response['status'] == '404'


def test_get_tiddler_revision_list_404():
    """
    Get a 404 when the tiddler doesn't exist.
    """
    response, content = http.request(
            'http://our_test_domain:8001/bags/bag1/tiddlers/Test99/revisions',
            method='GET')

    assert response['status'] == '404'


def test_get_tiddler_not_revision_list():
    """
    When we retrieve a tiddler list we don't want their revision links.
    """
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag1/tiddlers',
            method='GET')

    assert response['status'] == '200'
    assert '3' in content
    assert 'revisions' not in content


def test_get_tiddler_revision_list_json():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/TestOne/revisions.json',
            method='GET')

    info = simplejson.loads(content)
    assert response['status'] == '200'
    assert len(info) == 4

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/TestOne/revisions.json?sort=revision',
            method='GET')
    info2 = simplejson.loads(content)
    assert len(info) == 4
    assert info[0]['revision'] == info2[-1]['revision']


def test_tiddler_revision_list_json_fat():
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/TestOne/revisions.json?fat=1',
            method='GET')

    info = simplejson.loads(content)
    assert response['status'] == '200'
    assert len(info) == 4
    assert info[0]['revision'] == 4
    assert info[0]['modifier'] == 'GUEST'
    assert info[0]['creator'] == 'GUEST'
    assert info[-1]['modifier'] == 'GUEST'
    assert info[-1]['creator'] == 'GUEST'
    assert 'I have something to sell' in info[0]['text']

    response, resp_content = http.requestU(
            'http://our_test_domain:8001/bags/bag28/tiddlers/tiddler0/revisions.json',
            method='POST',
            headers={'if-match': '"bag28/tiddler0/1"',
                'content-type': 'text/plain'},
            body=content)
    assert response['status'] == '415'
    assert 'application/vnd.tiddlyweb+json required' in resp_content

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag28/tiddlers/tiddler0/revisions.json',
            method='POST',
            headers={'if-match': '"bag28/tiddler0/1"',
                'content-type': 'application/json'},
            body=content)

    assert response['status'] == '204'
    assert response['location'] == 'http://our_test_domain:8001/bags/bag28/tiddlers/tiddler0'

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag28/tiddlers/tiddler0/revisions.json',
            method='GET')

    info = simplejson.loads(content)
    assert response['status'] == '200'

    # confirm new media type
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag28/tiddlers/tiddler0/revisions.json',
            method='POST',
            headers={'if-match': '"bag28/tiddler0/5"',
                'content-type': 'application/vnd.tiddlyweb+json'},
            body=content)

    assert response['status'] == '204'
    assert response['location'] == 'http://our_test_domain:8001/bags/bag28/tiddlers/tiddler0'


def test_etag_generation():
    from tiddlyweb.web.util import tiddler_etag
    from tiddlyweb.model.bag import Bag
    from tiddlyweb.model.tiddler import Tiddler
    from tiddlyweb.config import config

    tiddler = Tiddler('monkey', 'bar')
    etag = tiddler_etag({'tiddlyweb.config': config}, tiddler)

    assert etag.startswith('"bar/monkey/0:')

    bag = Bag('bar')
    store.put(bag)
    store.put(tiddler)
    etag = tiddler_etag({'tiddlyweb.config': config}, tiddler)
    assert etag.startswith('"bar/monkey/1:')


def test_tiddler_revision_list_bad_ext():
    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/TestOne/revisions.monkeys',
            method='GET')

    assert response['status'] == '415'


def test_tiddler_revision_list_bad_ext_accept():
    response, content = http.request(
            'http://our_test_domain:8001/recipes/long/tiddlers/TestOne/revisions.monkeys',
            method='GET',
            headers={'Accept': 'text/html'})

    assert response['status'] == '415'


def test_post_revision_etag_handling():
    # GET a list of revisions
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/long/tiddlers/TestOne/revisions.json?fat=1',
            method='GET')

    json_content = content

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag28/tiddlers/newone/revisions.json',
            method='POST',
            headers={'content-type': 'application/json'},
            body=json_content)

    assert response['status'] == '412'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag28/tiddlers/newone/revisions.json',
            method='POST',
            headers={'If-Match': '"bag28/newone/0"',
                'content-type': 'application/json'},
            body=json_content)

    assert response['status'] == '204'

########NEW FILE########
__FILENAME__ = test_web_unicode
"""
Test a full suite of unicode interactions.
"""


from tiddlyweb.fixups import unquote
import simplejson
import httplib2

from .fixtures import (reset_textstore, _teststore, initialize_app,
        get_http)
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.user import User
from tiddlyweb.config import config

encoded_name = 'aaa%25%E3%81%86%E3%81%8F%E3%81%99'
name = unquote(encoded_name)
http = get_http()


def setup_module(module):
    initialize_app()
    reset_textstore()
    module.store = _teststore()
    user = User(name)
    user.set_password(name)
    module.store.put(user)
    module.cookie = None


def test_unicode_cookie():
    global cookie
    nested_response = None
    try:
        response, content = http.requestU(
                'http://our_test_domain:8001/challenge/cookie_form',
                method='POST',
                body='user=%s&password=%s' % (encoded_name, encoded_name),
                redirections=0,
                headers={'Content-type': 'application/x-www-form-urlencoded'}
                )
    except httplib2.RedirectLimit as e:
        nested_response = e

    assert nested_response.response['status'] == '303', content
    cookie = nested_response.response['set-cookie']
    assert encoded_name in cookie


def test_put_unicode_bag():
    encoded_bag_name = encoded_name
    bag_name = name

    bag_policy = dict(delete=[bag_name])
    bag_json = simplejson.dumps({'policy': bag_policy})
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/%s' % encoded_bag_name,
            method='PUT',
            body=bag_json,
            headers={'Content-Type': 'application/json',
                'Cookie': cookie})
    assert response['status'] == '204'

    bag = Bag(bag_name)
    bag = store.get(bag)
    assert bag.policy.delete == bag_policy['delete']
    assert bag.policy.owner == name
    assert bag.name == bag_name


def test_put_unicode_tiddler():
    encoded_tiddler_name = encoded_name
    tiddler_name = name
    encoded_bag_name = encoded_name
    bag_name = name

    tiddler_text = u'hello %s' % name
    tiddler_json = simplejson.dumps(dict(modifier=name,
        text=tiddler_text, tags=[name]))
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/%s/tiddlers/%s'
            % (encoded_bag_name, encoded_tiddler_name),
            method='PUT',
            body=tiddler_json,
            headers={'Content-Type': 'application/json'})

    assert response['status'] == '204'

    tiddler = Tiddler(tiddler_name, bag=bag_name)
    tiddler = store.get(tiddler)
    assert tiddler.title == tiddler_name
    assert tiddler.text == tiddler_text
    assert tiddler.tags == [name]


def test_put_unicode_recipe():
    encoded_recipe_name = encoded_name
    recipe_name = name
    bag_name = name

    recipe_list = [[bag_name, '[tag[%s]]' % name]]
    json_recipe_list = simplejson.dumps(dict(recipe=recipe_list))
    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/%s' % encoded_recipe_name,
            method='PUT',
            body=json_recipe_list,
            headers={'Content-Type': 'application/json'})
    assert response['status'] == '204'

    recipe = Recipe(recipe_name)
    recipe = store.get(recipe)
    assert recipe.get_recipe() == recipe_list
    assert recipe.name == recipe_name


def test_get_tiddlers_from_recipe():
    get_tiddlers_from_thing('recipes')


def test_get_tiddlers_from_bag():
    get_tiddlers_from_thing('bags')


def test_filter_tiddlers():
    response, content = http.requestU(
            'http://our_test_domain:8001/bags/%s/tiddlers.json?select=tag:%s'
            % (encoded_name, encoded_name),
            method='GET')
    assert response['status'] == '200'
    info = simplejson.loads(content)
    assert info[0]['tags'] == [name]
    assert info[0]['title'] == name
    assert info[0]['bag'] == name
    assert len(info) == 1


def test_double_uri_encoded_title():
    """
    This test works against wsgi-intercept but fails when
    used with web server like CherryPy, nginx or Apache.

    This is because PATH_INFO is being decoded before being given
    to the environment. This is not a good thing, it means that things
    like %2F get turned into / in URIs.

    See: https://github.com/tiddlyweb/tiddlyweb/issues/86
         https://mail.python.org/pipermail/web-sig/2008-January/thread.html#3122
    """
    store.put(Bag('double'))

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/double/tiddlers/test%2520one',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body='{"text": "hi"}')

    assert response['status'] == '204'

    tiddler = store.get(Tiddler('test%20one', 'double'))
    assert tiddler.title == 'test%20one'


def get_tiddlers_from_thing(container):
    response, content = http.requestU(
            'http://our_test_domain:8001/%s/%s/tiddlers.json' % (
                container, encoded_name),
            method='GET')
    assert response['status'] == '200'
    tiddler_info = simplejson.loads(content)
    assert tiddler_info[0]['title'] == name
    assert tiddler_info[0]['tags'] == [name]

    response, content = http.requestU(
            'http://our_test_domain:8001/%s/%s/tiddlers/%s.json'
            % (container, encoded_name, encoded_name),
            method='GET')
    assert response['status'] == '200'
    tiddler_info = simplejson.loads(content)
    assert tiddler_info['title'] == name
    assert tiddler_info['tags'] == [name]
    assert tiddler_info['text'] == 'hello %s' % name

########NEW FILE########
__FILENAME__ = test_web_util
"""
Test utilities in tiddlyweb.web.util
"""

try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

from httpexceptor import HTTP400

from tiddlyweb.web.util import (tiddler_url, datetime_from_http_date,
        encode_name, bag_etag, recipe_etag, read_request_body)
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.model.tiddler import Tiddler

from tiddlyweb.config import config

import pytest


def setup_module(module):
    config['server_host'] = {'scheme': 'http',
            'host': 'our_test_domain', 'port': '8001'}
    module.environ = {'tiddlyweb.config': config}


def teardown_module(module):
    config['server_prefix'] = ''


def test_tiddler_url():
    tiddler = Tiddler('foobar')
    tiddler.bag = 'zoom'

    url = tiddler_url(environ, tiddler)

    assert url == 'http://our_test_domain:8001/bags/zoom/tiddlers/foobar'

    tiddler.recipe = 'car'

    url = tiddler_url(environ, tiddler, container='recipes')

    assert url == 'http://our_test_domain:8001/recipes/car/tiddlers/foobar'

    url = tiddler_url(environ, tiddler, container='recipes', full=False)

    assert url == '/recipes/car/tiddlers/foobar'

    config['server_prefix'] = '/sleep'

    url = tiddler_url(environ, tiddler, container='recipes', full=False)

    assert url == '/sleep/recipes/car/tiddlers/foobar'

    url = tiddler_url(environ, tiddler)

    assert url == 'http://our_test_domain:8001/sleep/bags/zoom/tiddlers/foobar'

    tiddler.fields['_canonical_uri'] = 'http://example.com'
    url = tiddler_url(environ, tiddler)

    # we decided url is always local
    #assert url == 'http://example.com'
    assert url == 'http://our_test_domain:8001/sleep/bags/zoom/tiddlers/foobar'


def test_bad_http_timestamp():
    assert datetime_from_http_date('0') is None


def test_encode_name():
    """
    Ensure encode name encodes similarly to JavaScript.
    """
    assert encode_name("~alpha's (.beta*)!") == "~alpha's%20(.beta*)!"


def test_read_request_body():
    data = 'content of handle'
    data_length = len(data)
    fh = StringIO(data)
    environ['wsgi.input'] = fh

    output = read_request_body(environ, data_length)
    assert output == data

    output = read_request_body(environ, data_length)
    assert output == ''

    fh.close()

    pytest.raises(HTTP400, 'read_request_body(environ, data_length)')


def test_bag_etag():
    """
    Explicitly test bag_etag method (not used by the core code).
    """
    bag1 = Bag('foo')
    bag1.desc = 'desc'
    bag2 = Bag('foo')
    bag2.desc = 'desc'

    assert bag_etag(environ, bag1) == bag_etag(environ, bag2)


def test_recipe_etag():
    """
    Explicitly test recipe_etag method (not used by the core code).
    """
    recipe1 = Recipe('foo')
    recipe1.desc = 'desc'
    recipe2 = Recipe('foo')
    recipe2.desc = 'desc'

    assert recipe_etag(environ, recipe1) == recipe_etag(environ, recipe2)

########NEW FILE########
__FILENAME__ = test_web_validate
"""
Test that GETting a tiddler in some form.
"""

import simplejson

from base64 import b64encode

from .fixtures import reset_textstore, _teststore, initialize_app, get_http

from tiddlyweb.model.user import User
from tiddlyweb.model.bag import Bag

authorization = b64encode('cdent:cowpig'.encode('utf-8'))

from tiddlyweb.web.validator import InvalidTiddlerError
import tiddlyweb.web.validator


http = get_http()


def check_for_text(tiddler, environ):
    if 'foobar' not in tiddler.text:
        raise InvalidTiddlerError('missing "foobar" in tiddler.text')


def modify_text(tiddler, environ):
    tiddler.text = tiddler.text.replace('foobar', 'FOOBAR')


tiddlyweb.web.validator.TIDDLER_VALIDATORS = [
        check_for_text,
        modify_text,
        ]


def setup_module(module):
    initialize_app()
    reset_textstore()
    module.store = _teststore()

    bag = Bag('bag0')
    module.store.put(bag)

    user = User('cdent')
    user.set_password('cowpig')
    module.store.put(user)


def test_validate_one_tiddler():
    """No policy"""
    tiddler_json = '{"text": "barney is foobar"}'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/barney',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=tiddler_json)

    assert response['status'] == '204'

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/barney.txt',
            method='GET')

    assert response['status'] == '200'
    assert 'foobar' in content


def test_validate_one_tiddler_reject():
    """No policy"""
    bag = Bag('bag0')
    bag.policy.accept = ['NONE']
    store.put(bag)

    tiddler_json = '{"text": "barney is fobar"}'

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag0/tiddlers/barney',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=tiddler_json)

    assert response['status'] == '409'
    assert 'Tiddler content is invalid' in content


def test_validate_one_tiddler_modify():
    """No policy"""
    bag = Bag('bag0')
    bag.policy.accept = ['NONE']
    store.put(bag)

    tiddler_json = '{"text": "barney is foobar"}'

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag0/tiddlers/barney',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=tiddler_json)

    assert response['status'] == '204'

    location = response['location']
    response, content = http.requestU(location, method='GET')

    assert response['status'] == '200'
    assert 'FOOBAR' in content


def test_validate_one_bag():
    bag_json = simplejson.dumps(dict(
        desc='<script>alert("hot!");</script>', policy={}))

    response, content = http.request(
            'http://our_test_domain:8001/bags/bag1',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=bag_json)

    assert response['status'] == '204'

    response, content = http.requestU(
            'http://our_test_domain:8001/bags/bag1',
            method='GET')

    assert response['status'] == '200'

    assert '<script>' not in content
    assert '&lt;script' in content


def test_validate_one_recipe():
    recipe_json = simplejson.dumps(dict(
        desc='<script>alert("hot!");</script>', policy={}, recipe=[]))

    response, content = http.request(
            'http://our_test_domain:8001/recipes/recipe1',
            method='PUT',
            headers={'Content-Type': 'application/json'},
            body=recipe_json)

    assert response['status'] == '204'

    response, content = http.requestU(
            'http://our_test_domain:8001/recipes/recipe1',
            method='GET')

    assert response['status'] == '200'

    assert '<script>' not in content
    assert '&lt;script' in content

########NEW FILE########
__FILENAME__ = interact
"""
This module provides a ``twanager`` command ``interact`` which
provides a Python shell preloaded with the necessary local
variables to interact with the current instance's :py:class:`store
<tiddlyweb.store.Store>` and the entities within. The locals are:

* :py:class:`Recipe <tiddlyweb.model.recipe.Recipe>`
* :py:class:`Bag <tiddlyweb.model.bag.Bag>`
* :py:class:`Tiddler <tiddlyweb.model.tiddler.Tiddler>`
* :py:class:`User <tiddlyweb.model.user.User>`
* :py:class:`Policy <tiddlyweb.model.policy.Policy>`
* :py:class:`Serializer <tiddlyweb.serializer.Serializer>`
* :py:mod:`control <tiddlyweb.control>`
* :py:mod:`util <tiddlyweb.util>`
* :py:mod:`web <tiddlyweb.web.util>`
* An ``environ`` containing ``tiddlyweb.config`` and
  `tiddlyweb.store`` keys and values.
* A ``config`` containing the current ``tiddlyweb.config``.

These are enough to do most operations.
"""

import sys
import atexit
import code
import rlcompleter


def launch_shell(config, store, args):
    """
    Establish the basic environment for the shell and then start it.
    """
    # make basic API elements available within the REPL context
    from tiddlyweb.model.recipe import Recipe
    from tiddlyweb.model.bag import Bag
    from tiddlyweb.model.policy import Policy
    from tiddlyweb.model.tiddler import Tiddler
    from tiddlyweb.model.user import User
    from tiddlyweb.serializer import Serializer
    from tiddlyweb import control
    from tiddlyweb import util
    from tiddlyweb.web import util as web

    environ = {
        'tiddlyweb.config': config,
        'tiddlyweb.store': store
    }
    _locals = locals()
    _locals['config'] = config

    TiddlyWebREPL(locals=_locals).interact()


# See
# http://stackoverflow.com/questions/4031135/why-does-my-python-interactive-console-not-work-properly
# and
# http://stackoverflow.com/questions/7116038/python-tab-completion-mac-osx-10-7-lion
# for the details on tab completion
class TiddlyWebREPL(code.InteractiveConsole):
    """
    An interactive console for the current TiddlyWeb instance.

    This augments it's super class by adding tab completion and
    establishing a set of useful local variables.
    """

    def __init__(self, locals=None, filename="<console>"):
        code.InteractiveConsole.__init__(self, locals, filename)
        try:
            import readline
        except ImportError:
            pass
        else:
            try:
                readline.set_completer(TabCompleter(locals).complete)
            except ImportError:
                pass

            if 'libedit' in readline.__doc__:
                readline.parse_and_bind("bind -e")
                readline.parse_and_bind("bind '\t' rl_complete")
            else:
                readline.parse_and_bind("tab: complete")

            # history file support
            histfile = '.twihistory'
            try:
                readline.read_history_file(histfile)
            except IOError:
                pass
            atexit.register(readline.write_history_file, histfile)
            del histfile


class TabCompleter(rlcompleter.Completer):
    """
    Tab completion for the interactive shell that allows pressing
    the tab character to indicate an indent.
    """

    def complete(self, text, state):
        """
        Complete the provided ``text``. If there is no text, indent.
        """
        if not text:
            return ('    ', None)[state]
        else:
            return rlcompleter.Completer.complete(
                    self, text, state)

########NEW FILE########
__FILENAME__ = config
"""
The configuration of a particular instance of TiddlyWeb, carried around
as a dict in the WSGI ``environ`` as ``tiddlyweb.config``.

If there is a ``tiddlywebconfig.py`` file in the working directory
where ``twanager`` or the web server is started, its values will
override the defaults established in this module.

The server administrator may add additional keys to the config via
extensions.

Config Keys
===========

system_plugins
    A list of Python module names that act as plugins for the running
    server. At server startup time they are found, compiled, and the
    function ``init(config)`` is called on them, where ``config`` is
    a reference to the current config. Use this to add functionality to the
    server that cannot be accomplished from the defaults, such as adding
    additional web handlers, storage hooks or overriding existing
    behaviors.

twanager_plugins
    A list of Python module names that act as plugins for ``twanager``,
    adding command line functionality. As with ``system_plugins``
    ``init(config)`` is called.

server_store
    A list containing a module name and a configuration dictionary. The
    named module is an implementation of
    :py:class:`tiddlyweb.stores.StorageInterface` (first looked up in the
    :py:mod:`tiddlyweb.stores` package space, then in ``sys.path``).
    The configuration is an arbitrary dictionary of information to be
    passed to the store (e.g. database ``username`` and ``password``).

server_request_filters
    A list of WSGI applications which, in order, process the incoming
    requests made to the server. This can extract, add, or filter
    information as necessary. The defaults provide query string
    processing, content negotiation and establish ``environ`` settings.

server_response_filters
    A list of WSGI applications which, in order, process the outgoing
    response from the server. This can transform, log, or handle
    exceptions as necessary.

server_host
    The hostname of this server, usually set from whatever starts the
    server. This is a dictionary with keys: ``scheme``, ``host``, ``port``.

server_prefix
    A ``URL`` path portion which is a prefix to every ``URL`` the system uses
    and produces. Use this to host TiddlyWeb in a subdirectory (e.g.
    ``/wiki``). Default is ``''``.

extension_types
    A dictionary that pairs extension strings used in ``URLs`` as human
    controlled content-negotiation with the ``MIME`` types they represent.
    Add to this if you add to serializers.

serializers
    Incoming request ``Accept`` headers, or extension ``MIME`` types
    paired with a :py:class:`tiddlyweb.serializations.Serializer`
    implementation and an outgoing ``MIME`` type for that type of
    serialization.

extractors
    An extractor is a credential extractor (see
    :py:class:`tiddlyweb.web.extractors.ExtractorInterface`) that looks
    in an incoming request to attempt to extract information from it
    that indicates a potential user in the system. This config item is
    an ordered list of extractors, tried in succession until one returns
    ``tiddlyweb.usersign`` information or there are no more left.

auth_systems
    A list of challengers available to the system when it needs to ask
    for a user. (See
    :py:class:`tiddlyweb.web.challengers.ChallengerInterface`) If there
    is more than one challenger the user is presented with a list of
    those available. If there is only one, the user is automatically
    directed to just that one. A challenger needs to work with the
    extractors system so that the challenger provides something for
    future requests that the extractor can extract.

secret
    A string used to encrypt the cookie installed by some of the
    challengers and used by the cookie extractor. **NOTE: EVERY
    INSTALLATION SHOULD CHANGE THIS IN ITS OWN CONFIGURATION.**

urls_map
    The file location of the text file that maps ``URL`` paths to Python
    code, doing method dispatch. Usually it is better to use plugins to
    change the available ``URLs`` and handlers.

bag_create_policy
    A policy statement on who or what kind of user can create new bags
    on the system through the web ``API``. ``ANY`` means any
    authenticated user can. ``ADMIN`` means any user with role ADMIN
    can. ``''`` means anyone can.

recipe_create_policy
    A policy statement on who or what kind of user can create new
    recipes on the system through the web ``API``. See
    ``bag_create_policy``.

log_file
    Path and filename of the TiddlyWeb log file.

log_level
    String of loglevel to log. Pick one of ``CRITICAL``, ``DEBUG``,
    ``ERROR``, ``INFO``, ``WARNING``.

css_uri
    A URI of a css file that can be used to style the ``HTML`` output
    of the server. See :py:mod:`tiddlyweb.serializations.html` for the
    classes and ids used.

wikitext.default_renderer
    The default module for rendering ``tiddler.text`` to HTML when
    ``tiddler.type`` is ``None``.

wikitext.type_render_map
    A dictionary mapping ``tiddler.type`` ``MIME`` types to modules with
    a ``render()`` function for turning that type into ``HTML``.

wsgi_server
    The name of a module that provides a ``start_server`` method which
    starts a server to run this TiddlyWeb instance. Used by the
    ``twanager server`` command only.

special_bag_detectors
    A list of functions that take an ``environ`` and bag name and return
    a tuple of two functions: the first returns the tiddlers in that
    bag, the second returns one tiddler from that bag.

collections.use_memory
    If ``True`` :py:class:`Tiddler Collections
    <tiddlyweb.model.collections.Tiddlers>` are kept in memory during a
    single request. Defaults to ``False`` to save memory.
"""

try:
    from pkg_resources import resource_filename
    URLS_MAP = resource_filename('tiddlyweb', 'urls.map')
except NotImplementedError:
    # we seem to be in a py2app perhaps, so go local to RESOURCES
    URLS_MAP = 'urls.map'
except ImportError:
    URLS_MAP = 'tiddlyweb/urls.map'

from tiddlyweb.util import read_config

# The server filters (the WSGI MiddleWare)
from httpexceptor import HTTPExceptor
from tiddlyweb.web.negotiate import Negotiate
from tiddlyweb.web.query import Query
from tiddlyweb.web.extractor import UserExtract
from tiddlyweb.web.wsgi import StoreSet, EncodeUTF8, SimpleLog, \
        Header, PermissionsExceptor, TransformProtect

# A dict containing the configuration of TiddlyWeb, both
# as a server and as a library. This dictionary can contain
# anything. If there is a file called tiddlywebconfig.py in
# the startup working directory of twanager or other tiddlyweb
# using code, its contents will be merged with these defaults.
DEFAULT_CONFIG = {
        'system_plugins': [],
        'twanager_plugins': [],
        'server_store': ['text', {'store_root': 'store'}],
        'server_request_filters': [
            Query,
            StoreSet,
            UserExtract,
            Header,
            Negotiate],
        'server_response_filters': [
            PermissionsExceptor,
            HTTPExceptor,
            EncodeUTF8,
            TransformProtect,
            SimpleLog],
        'server_host': {
            'scheme': 'http',
            'host': '0.0.0.0',
            'port': '8080'},
        'server_prefix': '',
        'extension_types': {
            'txt': 'text/plain',
            'html': 'text/html',
            'json': 'application/vnd.tiddlyweb+json'},
        'serializers': {
            'text/html': ['html', 'text/html; charset=UTF-8'],
            'text/plain': ['text', 'text/plain; charset=UTF-8'],
            'application/json': ['json', 'application/json'],
            'application/vnd.tiddlyweb+json': ['json', 'application/json']},
        'default_serializer': 'text/html',
        'extractors': [
            'http_basic',
            'simple_cookie'],
        'auth_systems': [
            'cookie_form'],
        'secret': 'this should come from a file',
        'urls_map': URLS_MAP,
        'bag_create_policy': '',  # ANY (authenticated user)
                                  # or ADMIN (role) or '' (all can create)
        'recipe_create_policy': '',  # ANY or ADMIN or ''
        'log_level': 'INFO',
        'log_file': './tiddlyweb.log',
        'css_uri': '',
        'wikitext.default_renderer': 'raw',
        'wikitext.type_render_map': {},
        'wsgi_server': 'tiddlyweb.web.serve',
        'root_dir': '',
        'special_bag_detectors': [],
        'collections.use_memory': False,
}


config = DEFAULT_CONFIG
read_config(config)

########NEW FILE########
__FILENAME__ = control
"""
control provides routines which integrate the basic :py:mod:`model classes
<tiddlyweb.model>` with the rest of the system. The model classes are
intentionally simple. The methods here act as controllers on those classes.

These are primarily related to handling :py:class:`recipes
<tiddlyweb.model.recipe.Recipe>`.
"""

import logging

from tiddlyweb.model.bag import Bag
from tiddlyweb.model.policy import ForbiddenError, UserRequiredError
from tiddlyweb.filters import (FilterIndexRefused, parse_for_filters,
        recursive_filter)
from tiddlyweb.store import NoBagError, StoreError
from tiddlyweb.specialbag import get_bag_retriever, SpecialBagError

from tiddlyweb.fixups import basestring


LOGGER = logging.getLogger(__name__)


def get_tiddlers_from_recipe(recipe, environ=None):
    """
    Return the list of tiddlers that result from processing the ``recipe``.

    This list of tiddlers is unique by title with tiddlers later in the
    recipe taking precedence over those earlier in the recipe.

    The tiddlers returned are empty objects (i.e. not loaded from the
    :py:mod:`store <tiddlyweb.store>`).
    """
    template = recipe_template(environ)
    store = recipe.store
    uniquifier = {}
    for bag, filter_string in recipe.get_recipe(template):

        if isinstance(bag, basestring):
            retriever = get_bag_retriever(environ, bag)
            if not retriever:
                bag = Bag(name=bag)
                retriever = store.list_bag_tiddlers
            else:
                retriever = retriever[0]
        else:
            retriever = store.list_bag_tiddlers

        try:
            for tiddler in filter_tiddlers(retriever(bag), filter_string,
                    environ=environ):
                uniquifier[tiddler.title] = tiddler
        except SpecialBagError as exc:
            raise NoBagError('unable to retrieve from special bag: %s, %s'
                    % (bag, exc))

    return uniquifier.values()


def determine_bag_from_recipe(recipe, tiddler, environ=None):
    """
    Given a ``recipe`` and a ``tiddler`` determine the :py:class:`bag
    <tiddlyweb.model.bag.Bag>` in which this :py:class:`tiddler
    <tiddlyweb.model.tiddler.Tiddler>` can be found. This is different from
    :py:func:`determine_bag_for_tiddler`. That one finds the bag the tiddler
    *could* be in. This is the bag the tiddler *is* in.

    This is done by reversing the recipe's list, and filtering each bag
    according to any :py:mod:`filters <tiddlyweb.filters>` present. The
    resulting tiddlers are checked.

    If an ``indexer`` is configured use the index to determine if a tiddler
    exists in a bag.
    """
    store = recipe.store
    template = recipe_template(environ)
    try:
        indexer = environ.get('tiddlyweb.config', {}).get('indexer', None)
        if indexer:
            index_module = __import__(indexer, {}, {}, ['index_query'])
        else:
            index_module = None
    except (AttributeError, KeyError):
        index_module = None

    for bag, filter_string in reversed(recipe.get_recipe(template)):
        bag = _look_for_tiddler_in_bag(tiddler, bag,
                filter_string, environ, store, index_module)
        if bag:
            return bag

    raise NoBagError('no suitable bag for %s' % tiddler.title)


def _look_for_tiddler_in_bag(tiddler, bag, filter_string,
        environ, store, index_module):
    """
    Look up the indicated tiddler in a bag, filtered by filter_string.
    """
    if isinstance(bag, basestring):
        bag = Bag(name=bag)
    if store:
        bag = store.get(bag)

    def _query_index(bag):
        """
        Try looking in an available index to see if the tiddler exists.
        """
        kwords = {'id': '%s:%s' % (bag.name, tiddler.title)}
        try:
            tiddlers = index_module.index_query(environ, **kwords)
            if list(tiddlers):
                LOGGER.debug(
                        'satisfied recipe bag query via filter index: %s:%s',
                        bag.name, tiddler.title)
                return bag
        except StoreError as exc:
            raise FilterIndexRefused('unable to index_query: %s' % exc)
        return None

    def _query_bag(bag):
        """
        Look in a bag to see if tiddler is in there.
        """
        for candidate_tiddler in _filter_tiddlers_from_bag(bag,
                filter_string, environ=environ):
            if tiddler.title == candidate_tiddler.title:
                return bag
        return None

    if not filter_string and index_module:
        try:
            found_bag = _query_index(bag)
        except FilterIndexRefused:
            LOGGER.debug('determined bag filter refused')
            found_bag = _query_bag(bag)
        if found_bag:
            return bag
    else:
        found_bag = _query_bag(bag)
        if found_bag:
            return found_bag

    return None


def readable_tiddlers_by_bag(store, tiddlers, usersign):
    """
    Yield those tiddlers which are readable by the current ``usersign``.
    This means, depending on the ``read`` constraint on the
    :py:class:`tiddler's <tiddlyweb.model.tiddler.Tiddler>`
    :py:class:`bag's <tiddlyweb.model.bag.Bag>` :py:class:`policy
    <tiddlyweb.model.policy.Policy>`, yield or not.
    """
    bag_readable = {}

    for tiddler in tiddlers:
        try:
            if bag_readable[tiddler.bag]:
                yield tiddler
        except KeyError:
            bag = Bag(tiddler.bag)
            try:
                bag = store.get(bag)
            except NoBagError:
                pass
            try:
                bag.policy.allows(usersign, 'read')
                bag_readable[tiddler.bag] = True
                yield tiddler
            except(ForbiddenError, UserRequiredError):
                bag_readable[tiddler.bag] = False


def determine_bag_for_tiddler(recipe, tiddler, environ=None):
    """
    Return the :py:class:`bag <tiddlyweb.model.bag.Bag>` which this
    :py:class:`tiddler <tiddlyweb.model.tiddler.Tiddler>` would be in
    if we were to save it to the named :py:class:`recipe
    <tiddlyweb.model.recipe.Recipe>` rather than to a bag.

    This is done reversing the recipe list and seeing if the
    tiddler passes the constraint of the bag and its associated
    :py:mod:`filter <tiddlyweb.filters>`. If bag+filter is true,
    return that bag.
    """
    template = recipe_template(environ)
    for bag, filter_string in reversed(recipe.get_recipe(template)):
        for candidate_tiddler in filter_tiddlers([tiddler],
                filter_string, environ=environ):
            if tiddler.title == candidate_tiddler.title:
                if isinstance(bag, basestring):
                    bag = Bag(name=bag)
                return bag

    raise NoBagError('no suitable bag for %s' % tiddler.title)


def get_tiddlers_from_bag(bag):
    """
    Yield the individual :py:class:`tiddlers <tiddlyweb.model.tiddler.Tiddler>`
    that are in a :py:class:`bag <tiddlyweb.model.bag.Bag>`.

    The tiddlers return are empty objects that have not been loaded from
    the :py:class:`store <tiddlyweb.store.Store>`.

    Rarely used, see :py:func:`tiddlyweb.store.Store.list_bag_tiddlers`.
    """
    for tiddler in bag.store.list_bag_tiddlers(bag):
        yield tiddler


def filter_tiddlers(tiddlers, filters, environ=None):
    """
    Return a generator of tiddlers resulting from filtering the provided
    iterator of tiddlers by the provided :py:mod:`filters <tiddlyweb.filters>`.

    If filters is a string, it will be :py:func:`parsed for filters
    <tiddlyweb.filters.parse_for_filters>`.
    """
    if isinstance(filters, basestring):
        filters, _ = parse_for_filters(filters, environ)
    return recursive_filter(filters, tiddlers)


def _filter_tiddlers_from_bag(bag, filters, environ=None):
    """
    Return the list of tiddlers resulting from filtering bag by filter.
    The filter is a string that will be parsed to a list of filters.
    """
    indexable = bag

    if isinstance(filters, basestring):
        filters, _ = parse_for_filters(filters, environ)
    return recursive_filter(filters, bag.store.list_bag_tiddlers(bag),
            indexable=indexable)


def recipe_template(environ):
    """
    Provide a means to specify custom ``{{ key }}`` values in
    :py:class:`recipes <tiddlyweb.model.recipe.Recipe>` which are then
    replaced with the value specified in
    ``environ['tiddlyweb.recipe_template']``.

    This allows recipes to be dynamic in the face of conditions in the
    current request.
    """
    template = {}
    if environ:
        template = environ.get('tiddlyweb.recipe_template', {})
        try:
            template['user'] = environ['tiddlyweb.usersign']['name']
        except KeyError:
            pass

    return template

########NEW FILE########
__FILENAME__ = limit
"""
A :py:mod:`filter <tiddlyweb.filters>` type to limit a group of entities
using a syntax similar to SQL Limit::

    limit=<index>,<count>
    limit=<count>
"""

import itertools


def limit_parse(count='0'):
    """
    Parse the argument of a ``limit`` :py:mod:`filter <tiddlyweb.filters>`
    for a count and index argument, return a function which does the limiting.

    Exceptions while parsing are passed up the stack.
    """
    index = '0'
    if ',' in count:
        index, count = count.split(',', 1)
    index = int(index)
    count = int(count)

    def limiter(entities, indexable=False, environ=None):
        return limit(entities, index=index, count=count)

    return limiter


def limit(entities, count=0, index=0):
    """
    Make a slice of a list of entities based on a count and index.
    """

    return itertools.islice(entities, index, index + count)

########NEW FILE########
__FILENAME__ = select
"""
A :py:mod:`filter <tiddlyweb.filters>` type for selecting only some
entities, usually :py:class:`tiddlers <tiddlyweb.model.tiddler.Tiddler>`,
from a collection of entities, usually by an attribute of the tiddlers.

The syntax is::

    select=attribute:value    # attribute is value
    select=attribute:!value   # attribute is not value
    select=attribute:>value   # attribute is greater than value
    select=attribute:<value   # attribute is less than value

``ATTRIBUTE_SELECTOR`` is checked for a function which returns ``True``
or ``False`` for whether the provided value matches for the entity being
tested. The default case is lower case string equality. Other functions
may be provided by plugins. Attributes may be virtual, i.e. not real
attributes on entity. For example we can check for the presence of a
tag in a tiddlers tags attribute with::

    select=tag:tagvalue

An attribute function takes an entity, an attribute name and a value.
It may then do anything it wants with it, and must return ``True`` or
``False``.

* ``!`` negates a selection, getting all those entities that don't match.
* ``>`` gets those entities that sort greater than the value.
* ``<`` gets those entities that sort less than the value.

When doing sorting ``ATTRIBUTE_SORT_KEY`` is consulted to canonicalize the
value. See :py:mod:`tiddlyweb.filters.sort`.
"""

try:
    from itertools import ifilter as filter
except ImportError:  # Python3 has built in filter that iterates
    pass
from operator import gt, lt

from tiddlyweb.filters.sort import ATTRIBUTE_SORT_KEY
from tiddlyweb.store import get_entity


def select_parse(command):
    """
    Parse a select :py:mod:`filter <tiddlyweb.filters>` string into
    attributes and arguments and return a function (for later use)
    which will do the selecting.
    """
    attribute, args = command.split(':', 1)

    if args.startswith('!'):
        args = args.replace('!', '', 1)

        def selector(entities, indexable=False, environ=None):
            """
            Perform a negated select: match when attribute and value are not
            equal.
            """
            return select_by_attribute(attribute, args, entities, negate=True,
                    environ=environ)

    elif args.startswith('<'):
        args = args.replace('<', '', 1)

        def selector(entities, indexable=False, environ=None):
            """
            Perform a less than select: match when attribute is less than
            value.
            """
            return select_relative_attribute(attribute, args, entities,
                    lesser=True, environ=environ)

    elif args.startswith('>'):
        args = args.replace('>', '', 1)

        def selector(entities, indexable=False, environ=None):
            """
            Perform a greater than select: match when attribute is greater than
            value.
            """
            return select_relative_attribute(attribute, args, entities,
                    greater=True, environ=environ)

    else:

        def selector(entities, indexable=False, environ=None):
            """
            Perform a match select: match when attribute is equal the value.
            """
            if environ is None:
                environ = {}
            return select_by_attribute(attribute, args, entities,
                    indexable=indexable, environ=environ)

    return selector


def bag_in_recipe(entity, attribute, value):
    """
    Return ``True`` if the named :py:class:`bag <tiddlyweb.model.bag.Bag>`
    is in the :py:class:`recipe <tiddlyweb.model.recipe.Recipe>`.
    """
    bags = [bag for bag, _ in entity.get_recipe()]
    return value in bags


def field_in_fields(entity, attribute, value):
    """
    Return ``True`` if the entity has the named field.
    """
    return value in entity.fields


def tag_in_tags(entity, attribute, value):
    """
    Return ``True`` if the provided entity has a tag of value in its
    tag list.
    """
    return value in entity.tags


def text_in_text(entity, attribute, value):
    """
    Return ``True`` if the provided entity has the string provided in
    ``value`` within its text attribute.
    """
    try:
        return value.lower() in entity.text.lower()
    except (UnicodeDecodeError, TypeError):
        # Binary tiddler
        return False


ATTRIBUTE_SELECTOR = {
        'tag': tag_in_tags,
        'text': text_in_text,
        'field': field_in_fields,
        'rbag': bag_in_recipe,
}


def default_func(entity, attribute, value):
    """
    Look in the entity for an attribute with the provided value.
    First real object attributes are checked, then, if available,
    extended fields. If neither of these are present, return ``False``.
    """
    try:
        return getattr(entity, attribute) == value
    except AttributeError:
        try:
            return entity.fields[attribute] == value
        except (AttributeError, KeyError):
            return False


def select_by_attribute(attribute, value, entities, negate=False,
        indexable=None, environ=None):
    """
    Select entities where value of ``attribute`` matches the provide value.

    If ``negate`` is ``True``, get those that don't match.
    """
    if environ is None:
        environ = {}

    store = environ.get('tiddlyweb.store', None)
    indexer = environ.get('tiddlyweb.config', {}).get('indexer', None)
    if indexable and indexer:
        # If there is an exception, just let it raise.
        imported_module = __import__(indexer, {}, {}, ['index_query'])
        # dict keys may not be unicode
        kwords = {str(attribute): value, 'bag': indexable.name}
        return imported_module.index_query(environ, **kwords)
    else:
        select = ATTRIBUTE_SELECTOR.get(attribute, default_func)

        def _posfilter(entity):
            """
            Return True if the entity's attribute matches value.
            """
            stored_entity = get_entity(entity, store)
            return select(stored_entity, attribute, value)

        if negate:

            def _negfilter(entity):
                """
                Return True if the entity's attribute does not match value.
                """
                return not _posfilter(entity)

            _filter = _negfilter
        else:
            _filter = _posfilter

        return filter(_filter, entities)


def select_relative_attribute(attribute, value, entities,
        greater=False, lesser=False, environ=None):
    """
    Select entities that sort greater or less than the provided ``value``
    for the provided ``attribute``.
    """
    if environ is None:
        environ = {}

    store = environ.get('tiddlyweb.store', None)

    def normalize_value(value):
        """lower case the value if it is a string"""
        try:
            return value.lower()
        except AttributeError:
            return value

    func = ATTRIBUTE_SORT_KEY.get(attribute, normalize_value)

    if greater:
        comparator = gt
    elif lesser:
        comparator = lt
    else:
        comparator = lambda x, y: True

    def _select(entity):
        """
        Return true if entity's attribute is < or > (depending on
        comparator) the value in the filter.
        """
        stored_entity = get_entity(entity, store)
        if hasattr(stored_entity, 'fields'):
            return comparator(func(getattr(stored_entity, attribute,
                stored_entity.fields.get(attribute, ''))), func(value))
        else:
            return comparator(func(getattr(stored_entity, attribute, None)),
                    func(value))

    return filter(_select, entities)

########NEW FILE########
__FILENAME__ = sort
"""
A :py:mod:`filter <tiddlyweb.filters>` type to sort a collection of
entities by some attribute. The syntax is::

    sort=attribute   # sort ascending
    sort=-attribute  # sort descending

Atribute is either a real entity attribute or a key in
``ATTRIBUTE_SORT_KEY`` that has as its value a function used to generate a
key to pass to the sort. ``ATTRIBUTE_SORT_KEY`` can be extended by plugins.
"""

from tiddlyweb.store import get_entity


def date_to_canonical(datestring):
    """
    Take a (TiddlyWiki-style) string of 14 or less digits and turn it
    into 14 digits for the sake of comparing entity dates.
    """
    return datestring.ljust(14, '0')


def as_int(attribute):
    """
    Treat attribute as ``int`` if it looks like one.
    """
    try:
        return int(attribute)
    except ValueError:
        return attribute


ATTRIBUTE_SORT_KEY = {
        'modified': date_to_canonical,
        'created': date_to_canonical,
        'revision': as_int,
}


def sort_parse(attribute):
    """
    Create a function which will sort a collection of entities.
    """
    if attribute.startswith('-'):
        attribute = attribute.replace('-', '', 1)

        def sorter(entities, indexable=False, environ=None):
            return sort_by_attribute(attribute, entities, reverse=True,
                    environ=environ)

    else:

        def sorter(entities, indexable=False, environ=None):
            return sort_by_attribute(attribute, entities, environ=environ)

    return sorter


def sort_by_attribute(attribute, entities, reverse=False, environ=None):
    """
    Sort a group of entities by some attribute.
    Inspect ``ATTRIBUTE_SORT_KEY`` to see if there is a special
    function by which we should generate the value for this
    attribute.
    """
    if environ is None:
        environ = {}

    store = environ.get('tiddlyweb.store', None)

    func = ATTRIBUTE_SORT_KEY.get(attribute, lambda x: x.lower())

    def key_gen(entity):
        """
        Reify the attribute needed for sorting. If the entity
        has not already been loaded from the store, do so.
        """
        stored_entity = get_entity(entity, store)
        try:
            return func(getattr(stored_entity, attribute))
        except AttributeError as attribute_exc:
            try:
                return func(stored_entity.fields[attribute])
            except (AttributeError, KeyError) as exc:
                raise AttributeError('on %s, no attribute: %s, %s, %s'
                        % (stored_entity, attribute, attribute_exc, exc))

    return (entity for entity in
            sorted(entities, key=key_gen, reverse=reverse))

########NEW FILE########
__FILENAME__ = fixups
"""
Fixups used in various places to manage simultaneous support
for Python 2.7 and 3.
"""


try:
    unicode = unicode
except NameError:
    def unicode(input, encoding=None):
        return str(input)


try:
    basestring = basestring
    bytes = str
except NameError:
    basestring = str
    bytes = bytes


try:
    from Cookie import SimpleCookie, CookieError
except ImportError:
    from http.cookies import SimpleCookie, CookieError


try:
    from urllib import quote, unquote as unquote2

    def unquote(name):
        if isinstance(name, unicode):
            name = name.encode('UTF-8')
        return unquote2(name).decode('UTF-8')
except ImportError:
    from urllib.parse import quote, unquote


try:
    from urllib.parse import parse_qs
except ImportError:
    try:
        from urlparse import parse_qs
    except ImportError:
        from cgi import parse_qs

########NEW FILE########
__FILENAME__ = manage
"""
manage provides the workings for the ``twanager`` command line tool.
``twanager`` calls :py:func:`handle`, making available all commands
that have been put into the ``COMMANDS`` dictionary by the
:py:func:`make_command` decorator. See :py:mod:`tiddlyweb.commands`
for examples.

Plugins which add commands must be added to the ``twanager_plugins``
:py:mod:`config <tiddlyweb.config>` setting so they are imported at
the proper time.
"""

import logging
import os
import sys

from tiddlyweb.util import merge_config, std_error_message, initialize_logging


INTERNAL_PLUGINS = ['tiddlyweb.commands']

COMMANDS = {}


LOGGER = logging.getLogger(__name__)


try:
    unicode = unicode
except NameError:
    unicode = str


def make_command():
    """
    A decorator that marks the decorated method as a member of the
    commands dictionary, with associated help.

    The pydoc of the method is used in automatically generated :py:func:usage
    information.
    """

    def decorate(func):
        """
        Add the function to the commands dictionary.
        """
        COMMANDS[func.__name__] = func
        return func
    return decorate


@make_command()
def usage(args):
    """List this help"""
    if args:
        std_error_message('ERROR: ' + args + '\n')
    for key in sorted(COMMANDS):
        std_error_message('%10s: %s' % (key, COMMANDS[key].__doc__.strip()))
    sys.exit(1)


def handle(args):
    """
    Dispatch to the proper function for the command given in ``args[1]``.
    """
    from tiddlyweb.config import config

    options = _extract_options(args, ['load'])
    if 'load' in options:
        _external_load(options['load'], config)
    if 'tb' in options:
        config['twanager.tracebacks'] = True

    initialize_logging(config)

    plugins = INTERNAL_PLUGINS
    try:
        plugins.extend(config['twanager_plugins'])
        for plugin in plugins:
            LOGGER.debug('attempting to import twanager plugin %s', plugin)
            # let the import fail with error if it does
            imported_module = __import__(plugin, {}, {}, ['init'])
            imported_module.init(config)
    except KeyError:
        pass  # no plugins

    candidate_command = None
    try:
        candidate_command = args[1]
    except IndexError:
        usage('Missing command')

    try:
        args = args[2:]
    except IndexError:
        args = []

    args = [unicode(arg) for arg in args]
    if candidate_command and candidate_command in COMMANDS:
        try:
            LOGGER.debug('running command %s with %s',
                    candidate_command, args)
            COMMANDS[candidate_command](args)
        except IndexError as exc:
            usage('Incorect number of arguments')
        except Exception as exc:
            if config.get('twanager.tracebacks', False):
                raise
            import traceback
            LOGGER.error('twanager error with command "%s %s"\n%s',
                    candidate_command, args, traceback.format_exc())
            usage('%s: %s' % (exc.__class__.__name__, exc.args[0]))
    else:
        usage('No matching command found')


def _external_load(module, config):
    """
    Load a module to adjust configuration.
    """
    if module.endswith('.py'):
        path, module = os.path.split(module)
        module = module.replace('.py', '')
        sys.path.insert(0, path)
        imported_config = _import_module_config(module)
        sys.path.pop(0)
    else:
        imported_config = _import_module_config(module)

    merge_config(config, imported_config)


def _import_module_config(module):
    """
    Import the module named by ``module`` to get at its config.
    """
    imported_module = __import__(module, {}, {}, ['config'])
    return imported_module.config


def _extract_options(args, parameterized=[]):
    """
    Parse command-line arguments, removing options prefixed by "--" from the
    given list and returning them as a dictionary.
    """
    options = {}
    while len(args) > 1 and args[1].startswith('--'):
        option = args.pop(1)[2:]
        if option in parameterized:
            options[option] = args.pop(1)
        else:
            options[option] = None

    return options

########NEW FILE########
__FILENAME__ = bag
"""
A module containing the :py:class:`Bag` class.
"""

from tiddlyweb.model.policy import Policy


class Bag(object):
    """
    A Bag is a virtual container for :py:class:`tiddlers
    <tiddlyweb.model.tiddler.Tiddler>`. The bag provides a domain
    for the tiddlers within identifying those tiddlers uniquely and
    optionally acting a topical, functional or authorization container
    for the tiddlers.

    A bag can contain many tiddlers but every tiddler must have a different
    title. The canonical identifier of a tiddler is the combination of the
    containing bag's name and the tiddler's title.

    Containership is achieved via association: There are no methods on a
    bag to access the contained tiddlers. These are found via
    :py:func:`store.list_bag_tiddlers
    <tiddlyweb.store.Store.list_bag_tiddlers>`.

    A Bag has a :py:class:`Policy <tiddlyweb.model.policy.Policy>`
    which may be used to control access to both the Bag and the tiddlers
    within. These controls are optional and are primarily designed for
    use within the :py:mod:`web handlers <tiddlyweb.web.handler>`.
    """

    def __init__(self, name, desc=u''):
        self.name = name
        self.desc = desc
        self.policy = Policy()  # set to default policy
        self.store = None

    def __repr__(self):
        return '%s:%s' % (self.name, object.__repr__(self))

########NEW FILE########
__FILENAME__ = collections
"""
Classes representing collections of :py:class:`bags
<tiddlyweb.model.bag.Bag>`, :py:class:`recipes
<tiddlyweb.model.recipe.Recipe>` and :py:class:`tiddlers
<tiddlyweb.model.tiddler.Tiddler>`.

Because the main reason for having a collection is to send it out over
the web, the collections keep track of their last-modified time and
generate a hash suitable for use as an ETag.
"""

import logging

from tiddlyweb.store import StoreError
from tiddlyweb.util import sha

from tiddlyweb.model.tiddler import Tiddler


LOGGER = logging.getLogger(__name__)


class Collection(object):
    """
    Base class for all collections.

    Can be used directly for general collections if required.

    A collection acts as generator, yielding one of its contents when
    iterated.
    """

    def __init__(self, title=''):
        self._digest = sha()
        self.modified = '0'
        self.title = title
        self.link = ''
        self._container = []

    def __contains__(self, item):
        return item in self._container

    def add(self, thing):
        """
        Add an item to the container, updating the digest and
        modified information.
        """
        self._update_digest(thing)
        self._container.append(thing)
        try:
            modified_string = str(thing.modified)
            modified_string = modified_string.ljust(14, '0')
            if modified_string > self.modified:
                self.modified = modified_string
        except AttributeError:
            pass

    def _update_digest(self, thing):
        """
        Update the digest with this thing.
        """
        self._digest.update(thing.encode('utf-8'))

    def hexdigest(self):
        """
        Return the current hex representation of the hash digest of this
        collection.
        """
        return self._digest.hexdigest()

    def __iter__(self):
        """
        Generate the items in this container.
        """
        for thing in self._container:
            yield thing


class Container(Collection):
    """
    A collection of things which have a ``name`` attribute.

    In TiddlyWeb this is for lists of :py:class:`bags
    <tiddlyweb.model.bag.Bag>` and :py:class:`recipes
    <tiddlyweb.model.recipe.Recipe>`.
    """

    def _update_digest(self, thing):
        """
        Update the digest with this thing's ``name``.
        """
        self._digest.update(thing.name.encode('utf-8'))


class Tiddlers(Collection):
    """
    A Collection specifically for :py:class:`tiddlers
    <tiddlyweb.model.tiddler.Tiddler>`.

    This differs from the base class in two ways:

    The calculation of the digest is more detailed in order to create
    stong ``ETags`` for the collection.

    When iterated, if ``store`` is set on the Collection, then a yielded
    tiddler will be loaded from the store to fill in all its attributes.
    When a tiddler is added to the collection, if it is already filled,
    a non-full copy is made and put into the collection. This is done
    to save memory and because often the data is not needed.

    If ``collections.use_memory`` is ``True`` in ``config`` then the
    full tiddler is kept in the collection. On servers with adequate
    memory this can be more efficient.
    """

    def __init__(self, title='', store=None, bag=None, recipe=None):
        Collection.__init__(self, title)
        self.is_revisions = False
        self.is_search = False
        self.bag = bag
        self.recipe = recipe
        self.store = store

    def __iter__(self):
        """
        Generate the items in this container. Since these are
        :py:class:`tiddlers <tiddlyweb.model.tiddler.Tiddler>`,
        load them if they are not loaded. If a tiddler has been removed since
        this request was started, skip it.
        """
        for tiddler in self._container:
            if not tiddler.store and self.store:
                try:
                    tiddler = self.store.get(tiddler)
                except StoreError as exc:
                    LOGGER.debug('missed tiddler in collection: %s, %s',
                            tiddler, exc)
                    continue
            yield tiddler

    def add(self, tiddler):
        """
        Add a reference to the :py:class:`tiddler
        <tiddlyweb.model.tiddler.Tiddler>` to the container, updating the
        digest and modified information. If the tiddler has recently been
        deleted, resulting in a :py:class:`StoreError
        <tiddlyweb.store.StoreError>`, don't add it.
        """
        if not tiddler.store and self.store:
            try:
                tiddler = self.store.get(tiddler)
            except StoreError as exc:
                LOGGER.debug(
                        'tried to add missing tiddler to collection: %s, %s',
                        tiddler, exc)
                return
            if not self.store.environ['tiddlyweb.config'].get(
                    'collections.use_memory', False):
                reference = Tiddler(tiddler.title, tiddler.bag)
                if tiddler.revision:
                    reference.revision = tiddler.revision
                if tiddler.recipe:
                    reference.recipe = tiddler.recipe
                self._container.append(reference)
            else:
                self._container.append(tiddler)
        else:
            self._container.append(tiddler)
        self._update_digest(tiddler)
        modified_string = str(tiddler.modified)
        modified_string = modified_string.ljust(14, '0')
        if modified_string > self.modified:
            self.modified = modified_string

    def _update_digest(self, tiddler):
        """
        Update the digest with information from this tiddler.
        """
        try:
            self._digest.update(tiddler.bag.encode('utf-8'))
        except AttributeError:
            pass
        self._digest.update(tiddler.title.encode('utf-8'))
        self._digest.update(str(tiddler.revision).encode('utf-8'))

########NEW FILE########
__FILENAME__ = policy
"""
A module containing the :py:class:`Policy` class and associated
exceptions.
"""


class PermissionsError(Exception):
    """
    Base class for :py:class:`Policy` violations.
    """


class ForbiddenError(PermissionsError):
    """
    The provided user cannot do this action.
    """
    pass


class UserRequiredError(PermissionsError):
    """
    To do this action a user is required.
    """
    pass


class Policy(object):
    """
    A container for information about the contraints on a :py:class:`bag
    <tiddlyweb.model.bag.Bag>` or :py:class:`recipe
    <tiddlyweb.model.recipe.Recipe>`. Both are containers of
    :py:class:`tiddlers <tiddlyweb.model.tiddler.Tiddler>`. We need to
    be able to control who can do what to do those tiddlers. We also
    need to be able to control who can manage those constraints.

    The :pu:func:__init__ parameters represent a default policy.

    There are six constraints plus one identifying attribute (``owner``).
    The constraints are listed below with descriptions of what is allowed
    if the constraint passes.

    read
        View this entity in lists. View the contained entities.

    write
        Edit the contained entities that already exist.

    create
        Create new entities in the container.

    delete
        Remove a contained entity.

    manage
        Change the policy itself.

    accept
         Accept the entity into the container without requiring
         :py:mod:`validation <tiddlyweb.web.validator>`.
    """

    attributes = [u'read', u'write', u'create', u'delete', u'manage',
            u'accept', u'owner']

    def __init__(self, owner=None,
            read=None, write=None, create=None, delete=None,
            manage=None, accept=None):
        # avoid "dangerous" warnings from pylint and
        # and possible memory leaks
        if read is None:
            read = []
        if write is None:
            write = []
        if create is None:
            create = []
        if delete is None:
            delete = []
        if manage is None:
            manage = []
        if accept is None:
            accept = []
        self.owner = owner
        self.read = read
        self.write = write
        self.create = create
        self.delete = delete
        self.manage = manage
        self.accept = accept

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not self == other

    def allows(self, usersign, constraint):
        """
        Is the user encapsulated by the ``usersign`` dict allowed to
        perform the action described by ``constraint``. If so, return
        True. If not raise a :py:class:`UserRequiredError` (if the user is
        ``GUEST``) or :py:class:`ForbiddenError` exception.

        The dict has a ``name`` key with a string value which is a
        ``username`` and a ``roles`` key with a list of roles as its value.
        Either may match in the constraint. Usersign is usually populated
        during the :py:class:`CredentialsExtractor
        <tiddlyweb.web.extractors.ExtractorInterface>` phase of a
        request.
        """
        try:
            roles = usersign['roles']
        except KeyError:
            roles = []
        username = usersign['name']

        info_list = self.__getattribute__(constraint)

        if _no_constraint(info_list):
            return True

        user_list = [x for x in info_list if not x.startswith('R:')]

        # always reject if the constraint is NONE
        if _single_value_set(user_list, u'NONE'):
            raise ForbiddenError('%s may not %s' % (username, constraint))

        if _user_valid(username, user_list):
            return True

        role_list = [x[2:] for x in info_list if x.startswith('R:')]

        if _role_valid(roles, role_list):
            return True

        # if the user is set to GUEST (meaning nobody in credentials)
        # then we don't pass, and we need a user
        if username == u'GUEST':
            raise UserRequiredError('real user required to %s' % constraint)

        # we've fallen through, the user we have matches nothing
        raise ForbiddenError('%s may not %s' % (username, constraint))

    def user_perms(self, usersign):
        """
        For this policy return a list of constraints for which
        this usersign passes.
        """
        perms = ['read', 'write', 'create', 'delete']
        matched_perms = []
        for perm in perms:
            try:
                self.allows(usersign, perm)
                matched_perms.append(perm)
            except (UserRequiredError, ForbiddenError):
                pass
        return matched_perms


def create_policy_check(environ, entity, usersign):
    """
    Determine if the user in ``usersign`` can create ``entity`` type.
    """
    try:
        entity_policy = '%s_create_policy' % entity
        policy = environ['tiddlyweb.config'][entity_policy]
    except KeyError:
        raise ForbiddenError('create policy not set for %s' % entity)

    if policy == '':
        return True

    if policy == u'ANY':
        if usersign['name'] != u'GUEST':
            return True
        else:
            raise UserRequiredError('authenticated user required to create')

    if policy == u'ADMIN':
        try:
            if u'ADMIN' in usersign['roles']:
                return True
            else:
                raise ForbiddenError('admin role required to create')
        except KeyError:
            raise ForbiddenError(
                    'admin role required to create, user has no roles')

    raise ForbiddenError('create access denied')


def _single_value_set(target_list, value):
    """
    Return true if this constraint has only one value and it is
    this one.
    """
    return len(target_list) == 1 and target_list[0] == value


def _no_constraint(info_list):
    """
    If there is no constraint set, then anything passes.
    """
    try:
        if len(info_list) == 0:
            return True
    except TypeError:
        # constraint not set (weirdness in DB)
        return True

    return False


def _role_valid(roles, role_list):
    """
    Return ``True`` if there is an intersection between the users roles
    and any roles in the constraint.
    """
    if [role for role in roles if role in role_list]:
        return True
    return False


def _user_valid(user_sign, user_list):
    """
    If the user_sign is in the constraint or the constraint value
    is ANY, return true.
    """
    if _single_value_set(user_list, u'ANY'):
        if user_sign != u'GUEST':
            return True

    if user_sign in user_list:
        return True

    return False

########NEW FILE########
__FILENAME__ = recipe
"""
The Recipe class.
"""

import re

from tiddlyweb.model.policy import Policy


RECIPE_TEMPLATE_RE = re.compile(r'{{ (\w+) }}')
RECIPE_TEMPLATE_DEFAULT_RE = re.compile(r'{{ (\w+):(\w+) }}')


class Recipe(object):
    """
    A Recipe is an ordered list that represents a program for creating a
    collection of :py:class:`tiddlers <tiddlyweb.model.tiddler.Tiddler>`.

    Each line in the recipe is the combination of a :py:class:`bag
    <tiddlyweb.model.bag.Bag>` name and a :py:mod:`filter <tiddlyweb.filters>`
    string. This implementation uses list of tuples.

    In common usage a recipe contains only strings representing bags
    and filters, but for the sake of easy testing, the bag argument
    can be a :py:class:`Bag <tiddlyweb.model.bag.Bag>` object.

    A Recipe has a :py:class:`Policy <tiddlyweb.model.policy.Policy>`
    which can be used to control access to the Recipe. These controls are
    optional and are primarily designed for use within the :py:mod:`web
    handlers <tiddlyweb.web.handler>`.
    """

    def __init__(self, name, desc=u''):
        self._recipe = []
        self.name = name
        self.desc = desc
        self.store = None
        self.policy = Policy()

    def set_recipe(self, recipe_list):
        """
        Set the contents of the recipe list.
        """
        self._recipe = recipe_list

    def get_recipe(self, template=None):
        """
        Return the recipe list, as a list of tuple pairs.
        """
        our_list = self._recipe
        real_list = []

        # If no template is provided the below
        # will fail over to not doing template
        # processing. Which is what we want.

        for entry in our_list:
            new_entry = []
            for item in entry:
                value = None
                try:
                    match = RECIPE_TEMPLATE_DEFAULT_RE.search(item)
                    if match:
                        keyname = match.group(1)
                        default = match.group(2)
                        try:
                            value = template[keyname]
                        except KeyError:
                            value = default
                    match = RECIPE_TEMPLATE_RE.search(item)
                    if match:
                        keyname = match.group(1)
                        value = template[keyname]
                    if value:
                        value = re.sub(r'{{ [\w:]+ }}', value, item)
                        new_entry.append(value)
                    else:
                        new_entry.append(item)
                except TypeError:  # item is not a string
                    new_entry.append(item)

            real_list.append(new_entry)

        return real_list

########NEW FILE########
__FILENAME__ = tiddler
"""
A module containing the :py:class:`Tiddler` class and related functions.
"""

import re

from datetime import datetime
from time import strptime

from tiddlyweb.fixups import unicode


def current_timestring():
    """
    Translate the current UTC time into a TiddlyWiki conformat timestring.
    """
    time_object = datetime.utcnow()
    return unicode(time_object.strftime('%Y%m%d%H%M%S'))


def timestring_to_datetime(timestring):
    """
    Turn a TiddlyWiki timestring into a datetime object.

    Will raise ValueError if the input is not a 12 or 14
    digit timestring.
    """
    try:
        timestring_datetime = datetime(*(strptime(timestring,
            '%Y%m%d%H%M')[0:6]))
    except ValueError:
        timestring_datetime = datetime(*(strptime(timestring,
            '%Y%m%d%H%M%S')[0:6]))
    return timestring_datetime


def tags_list_to_string(tags):
    """
    Given a list of ``tags``, turn it into the canonical string representation
    (space-delimited, enclosing tags containing spaces in double brackets).
    """
    tag_string_list = []
    for tag in tags:
        if ' ' in tag:
            tag = '[[%s]]' % tag
        tag_string_list.append(tag)
    return u' '.join(tag_string_list)


def string_to_tags_list(string):
    """
    Given a string representing tags (space-delimited, tags containing spaces
    are enclosed in in double brackets), parse them into a list of tag strings.

    Duplicates are removed.
    """
    tags = []
    tag_matcher = re.compile(r'([^ \]\[]+)|(?:\[\[([^\]]+)\]\])')
    for match in tag_matcher.finditer(string):
        if match.group(2):
            tags.append(match.group(2))
        elif match.group(1):
            tags.append(match.group(1))

    return list(set(tags))


class Tiddler(object):
    """
    The primary content object in the TiddlyWiki and TiddlyWeb universe,
    representing a distinct piece of content, often vaguely
    corresponding to a Page in wiki systems. A Tiddler has text and some
    associated metadata. The text can be anything, often wikitext in
    some form, or Javascript code. It is possible for a Tiddler to
    container binary content, such as image data.

    A Tiddler is intentionally solely a container of data. That is, it has
    no methods which change the state of attributes in the Tiddler or
    manipulate the tiddler. Changing the attributes is done by directly
    changing the attributes. This is done to make the Tiddler easier to
    :py:class:`store <tiddlyweb.store.Store>` and :py:class:`serialize
    <tiddlyweb.serializer.Serializer>` in many ways.

    A Tiddler has several attributes:

    title
        The name of the tiddler. Required.

    created
        A string representing when this tiddler was created.

    modified
        A string representing when this tiddler was last changed.
        Defaults to now.

    modifier
        A string representing a personage that changed this tiddler in
        some way. This doesn't necessarily have any assocation with the
        tiddlyweb.usersign, though it may.

    tags
        A list of strings that describe the tiddler.

    fields
        An arbitrary dictionary of extended (custom) fields on the tiddler.

    text
        The contents of the tiddler. A string.

    revision
        The revision of this tiddler. The type of a revision is unspecified
        and is :py:class:`store <tiddlyweb.store.Store>` dependent.

    bag
        The name of the bag in which this tiddler exists, if any.

    recipe
        The name of the recipe in which this tiddler exists, if any.

    store
        A reference to the :py:class:`Store <tiddlyweb.store.Store>` object
        which retrieved this tiddler from persistent storage.
    """

    data_members = ['title',
            'creator',
            'created',
            'modifier',
            'modified',
            'tags',
            'fields',
            'type',
            'text']
    # TiddlyWeb-specific attributes
    slots = data_members + ['revision', 'bag', 'recipe', 'store']

    def __init__(self, title=None, bag=None):
        """
        Create a new Tiddler object.

        A ``title`` is required to create a tiddler.
        """
        self.title = title
        self.bag = bag

        self._creator = u''
        self.modifier = None
        self.created = u''
        self.modified = current_timestring()
        self.tags = []
        self.fields = {}
        self.text = u''
        self.type = None
        self.revision = None
        self.recipe = None
        # reference to the store which 'got' us
        self.store = None

    def _get_creator(self):
        """
        Get the creator of this tiddler. If it has not been
        set then use modifier.

        Use the creator property instead.
        """
        if not self._creator:
            self._creator = self.modifier
        return self._creator

    def _set_creator(self, creator):
        """
        Set the creator of this tiddler.

        Use the creator property instead.
        """
        self._creator = creator

    creator = property(_get_creator, _set_creator)

    def __repr__(self):
        """
        Make the printed tiddler include the title so we
        can distinguish between them while debugging.
        """
        return self.title + object.__repr__(self)

########NEW FILE########
__FILENAME__ = user
"""
A class representing a simple user entity.

A User object is not required during TiddlyWeb requests,
:py:class:`credentials extractors
<tiddlyweb.web.extractors.ExtractorInterface>` and :py:class:`policies
<tiddlyweb.model.policy.Policy>` may work with arbitrary data for
authentication and authorization. However if a locally stored user
is required the :py:class:`User` may be used.
"""

from tiddlyweb.util import sha

from tiddlyweb.fixups import unicode


class User(object):
    """
    A simple representation of a user. A user is a username, an optional
    password, an optional list of roles, and an optional note.
    """

    def __init__(self, usersign, note=None):
        self.usersign = unicode(usersign)
        self.note = note
        if self.note:
            self.note = unicode(self.note)
        self._password = None
        self.roles = set()

    def add_role(self, role):
        """
        Add the named ``role`` (a string) to this user.
        """
        self.roles.add(unicode(role))

    def del_role(self, role):
        """
        Remove the named ``role`` (a string) from this user.
        If it is not there, do nothing.
        """
        self.roles.discard(role)

    def list_roles(self):
        """
        List (as a list of strings) the roles that this
        user has.
        """
        return list(self.roles)

    def set_password(self, password):
        """
        Set the password for this user.
        """
        password = password.strip()
        # The null password or empty password string never auths
        if not password:
            return
        self._password = sha(password.strip()).hexdigest()

    def check_password(self, candidate_password):
        """
        Check the password for this user. Return ``True`` if correct.
        """
        if not self._password:
            return False
        crypted_thing = sha(candidate_password.strip()).hexdigest()
        return crypted_thing == self._password

    def __repr__(self):
        return self.usersign + ' ' + object.__repr__(self)

########NEW FILE########
__FILENAME__ = html
"""
:py:class:`Serialization <tiddlyweb.serializations.SerializationInterface>`
for HTML.

``HEADER`` and ``FOOTER`` can be overridden to change the basic framing
of the system.
"""

from tiddlyweb import __version__ as VERSION
from tiddlyweb.serializations import SerializationInterface
from tiddlyweb.web.util import encode_name, escape_attribute_value, tiddler_url
from tiddlyweb.wikitext import render_wikitext

from tiddlyweb.fixups import quote


HEADER = u"""<!DOCTYPE HTML>
<html>
<head>
<meta charset="UTF-8">
<title>TiddlyWeb - %(title)s</title>
%(css)s
%(links)s
</head>
<body>
<div id="header">
<h1>%(title)s</h1>
</div>
<div id="content">
"""

FOOTER = u"""
</div>
<div id="footer">
<div id="badge">This is <a href="http://tiddlyweb.com/">TiddlyWeb</a>
%(version)s</div>
<div id="usergreet">User %(username)s.</div>
</div>
</body>
</html>
"""


class Serialization(SerializationInterface):
    """
    Serialize entities and collections to ``HTML`` representations. This
    is primarily used to create browser based presentations. No support
    is provided for turning ``HTML`` into entities.

    Set ``css_uri`` in :py:mod:`config <tiddlyweb.config>` to control
    CSS.

    Set ``tiddlyweb.links`` in ``environ`` to a list of ``<link>``
    elements to include those links in the output.
    """

    def __init__(self, environ=None):
        SerializationInterface.__init__(self, environ)
        self.environ['tiddlyweb.title'] = ''
        self.environ['tiddlyweb.links'] = []

    def list_recipes(self, recipes):
        """
        Yield the provided :py:class:`recipes <tiddlyweb.model.recipe.Recipe>`
        as HTML.
        """
        self.environ['tiddlyweb.title'] = 'Recipes'

        def wrap_list():
            yield self._header()
            yield '<ul id="recipes" class="listing">\n'
            for recipe in recipes:
                yield '<li><a href="recipes/%s">%s</a></li>\n' % (
                        encode_name(recipe.name), recipe.name)
            yield '\n</ul>'
            yield self._footer()

        return wrap_list()

    def list_bags(self, bags):
        """
        Yield the provided :py:class:`bags <tiddlyweb.model.bag.Bag>`
        as HTML.
        """
        self.environ['tiddlyweb.title'] = 'Bags'

        def wrap_list():
            yield self._header()
            yield '<ul id="bags" class="listing">\n'
            for bag in bags:
                yield '<li><a href="bags/%s/tiddlers">%s</a></li>\n' % (
                        encode_name(bag.name), bag.name)
            yield '\n</ul>'
            yield self._footer()

        return wrap_list()

    def list_tiddlers(self, tiddlers):
        """
        Yield the provided :py:class:`tiddlers
        <tiddlyweb.model.tiddler.Tiddler>` as HTML.

        This is somewhat more complex than the other list methods as
        we need to list the tiddler whether it is a revision or not,
        if it is in a bag or recipe or if it is a search result.
        """
        tiddlers.store = None
        title = tiddlers.title
        server_prefix = self._server_prefix()
        lines = []
        container_link = ''

        if tiddlers.link:
            representation_link = tiddlers.link
        elif tiddlers.is_search:
            representation_link = '%s/search' % server_prefix
        else:
            representation_link = ''

        for tiddler in tiddlers:
            if tiddlers.is_revisions:
                line = self._tiddler_revision_info(tiddler)
            else:
                line = self._tiddler_in_container_info(tiddler)
            lines.append(line)

        if not tiddlers.is_revisions and not tiddlers.is_search:
            if tiddlers.bag:
                container_link = ('<div class="baglink">'
                        '<a href="%s/bags/%s">Bag %s</a></div>'
                        % (server_prefix, encode_name(tiddlers.bag),
                            tiddlers.bag))
            elif tiddlers.recipe:
                container_link = ('<div class="recipelink">'
                        '<a href="%s/recipes/%s">Recipe %s</a></div>'
                        % (server_prefix, encode_name(tiddlers.recipe),
                            tiddlers.recipe))

        output = "\n".join(lines)
        self.environ['tiddlyweb.title'] = title

        return """
%s
%s
%s
<ul id="tiddlers" class="listing">
%s
</ul>
%s
""" % (self._header(), self._tiddler_list_header(representation_link),
        container_link, output, self._footer())

    def recipe_as(self, recipe):
        """
        :py:class:`Recipe <tiddlyweb.model.recipe.Recipe>` as HTML,
        including a link to the tiddlers within.
        """
        self.environ['tiddlyweb.title'] = 'Recipe %s' % recipe.name
        lines = []
        for bag, filter_string in recipe.get_recipe():
            line = '<li><a href="'
            line += '%s/bags/%s/tiddlers' % (
                    self._server_prefix(), encode_name(bag))
            if filter_string:
                line += '?%s' % quote(
                        filter_string.encode('utf-8'), safe=':=;')
            line += '">bag: %s filter:%s</a></li>' % (bag, filter_string)
            lines.append(line)
        output = "\n".join(lines)
        tiddler_link = '%s/tiddlers' % encode_name(recipe.name)
        return """
%s
<div class="tiddlerslink"><a href="%s">Tiddlers in Recipe</a></div>
<div id="recipedesc" class="description">%s</div>
<ul id="recipe" class="listing">
%s
</ul>
%s
""" % (self._header(), tiddler_link, recipe.desc, output, self._footer())

    def bag_as(self, bag):
        """
        :py:class:`Bag <tiddlyweb.model.bag.Bag>` as HTML,
        including a link to the tiddlers within.
        """
        self.environ['tiddlyweb.title'] = 'Bag %s' % bag.name
        tiddler_link = '%s/tiddlers' % encode_name(bag.name)
        return """
%s
<div id="bagdesc" class="description">%s</div>
<div class="tiddlerslink"><a href="%s">Tiddlers in Bag %s</a></div>
%s
""" % (self._header(), bag.desc, tiddler_link, bag.name, self._footer())

    def tiddler_as(self, tiddler):
        """
        Transform the provided :py:class:`tiddler
        <tiddlyweb.model.tiddler.Tiddler>` into an HTML representation.
        :py:mod:`Render <tiddlyweb.wikitext>` the ``text`` of the tiddler
        if its ``type`` is configured.
        """
        if tiddler.recipe:
            list_link = 'recipes/%s/tiddlers' % encode_name(tiddler.recipe)
            list_title = 'Tiddlers in Recipe %s' % tiddler.recipe
        else:
            list_link = 'bags/%s/tiddlers' % encode_name(tiddler.bag)
            list_title = 'Tiddlers in Bag %s' % tiddler.bag
        list_html = ('<div class="tiddlerslink"><a href="%s/%s" ' %
                (self._server_prefix(), list_link) +
                'title="tiddler list">%s</a></div>' % list_title)
        html = render_wikitext(tiddler, self.environ)
        self.environ['tiddlyweb.title'] = tiddler.title
        return (self._header() + list_html + self._tiddler_div(tiddler)
                + html + '</div>' + self._footer())

    def _server_prefix(self):
        """
        Return the string that is the server prefix,
        for creating URLs.
        """
        config = self.environ.get('tiddlyweb.config', {})
        return config.get('server_prefix', '')

    def _tiddler_div(self, tiddler):
        """
        The string that starts the div that contains a tiddler.
        """
        return u"""
<div class="tiddler" title="%s" server.page.revision="%s"
     modifier="%s" creator="%s" modified="%s" created="%s" tags="%s" %s>
 """ % (escape_attribute_value(tiddler.title),
         tiddler.revision,
         escape_attribute_value(tiddler.modifier),
         escape_attribute_value(tiddler.creator),
         tiddler.modified,
         tiddler.created,
         escape_attribute_value(self.tags_as(tiddler.tags)),
         self._tiddler_fields(tiddler.fields))

    def _tiddler_fields(self, fields):
        """
        Turn tiddler fields into a string suitable for
        _tiddler_div.
        """
        output = []
        for key, val in fields.items():
            output.append('%s="%s"' % (key, escape_attribute_value(val)))
        return ' '.join(output)

    def _tiddler_in_container_info(self, tiddler):
        """
        Get the info for a non-revision tiddler in a list.
        """
        if tiddler.recipe:
            base = 'recipes'
        else:
            base = 'bags'
        return '<li><a href="%s">%s</a></li>' % (
            tiddler_url(self.environ, tiddler, container=base, full=False),
            tiddler.title.replace(' ', '&nbsp;', 1))

    def _tiddler_list_header(self, representation_link):
        """
        The string we present at the top of a list of tiddlers.
        """
        if representation_link:
            extension_types = self.environ.get('tiddlyweb.config',
                    {}).get('extension_types', {}).keys()
            links = []
            query_string = self.environ.get('QUERY_STRING', '')
            if query_string:
                query_string = '?%s' % query_string
            for extension in extension_types:
                link = '<a href="%s.%s%s">%s</a>' % (representation_link,
                        extension, query_string, extension)
                links.append(link)
            link_info = ' '.join(links)
            return """
<div id="tiddlersheader">This list of tiddlers as: %s</div>
""" % (link_info)
        return ''

    def _tiddler_revision_info(self, tiddler):
        """
        Get the individual revision info for listing revisions.
        """
        if tiddler.recipe:
            base = 'recipes'
        else:
            base = 'bags'
        return ('<li><a href="%s/revisions/%s">%s:%s</a></li>' % (
            tiddler_url(self.environ, tiddler, container=base, full=False),
            tiddler.revision,
            tiddler.title,
            tiddler.revision))

    def _header(self, title=''):
        """
        Return HTML header section.
        """
        css = ''
        css_config = self.environ.get(
                'tiddlyweb.config', {}).get('css_uri', '')
        if css_config:
            css = ('<link rel="stylesheet" href="%s" type="text/css" />' %
                    css_config)
        links = '\n'.join(self.environ.get('tiddlyweb.links', []))
        env_title = self.environ.get('tiddlyweb.title')
        if env_title:
            title = env_title
        template = {
                'title': title,
                'css': css,
                'links': links,
        }
        return HEADER % template

    def _footer(self):
        """
        Return a footer frame for the HTML.
        """
        return FOOTER % {'version': VERSION,
                'username': self.environ.get(
                    'tiddlyweb.usersign', {}).get('name', 'GUEST')}

########NEW FILE########
__FILENAME__ = json
"""
:py:class:`Serialization <tiddlyweb.serializations.SerializationInterface>`
for ``JSON``.
"""

import simplejson

from base64 import b64encode, b64decode

from tiddlyweb.serializer import (TiddlerFormatError, BagFormatError,
        RecipeFormatError)
from tiddlyweb.serializations import SerializationInterface
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.policy import Policy
from tiddlyweb.util import binary_tiddler, renderable
from tiddlyweb.wikitext import render_wikitext
from tiddlyweb.store import StoreError
from tiddlyweb.web.util import tiddler_url


class Serialization(SerializationInterface):
    """
    Turn entities and collections thereof to and from ``JSON``.
    """

    def list_recipes(self, recipes):
        """
        Create a ``JSON`` list of :py:class:`recipe
        <tiddlyweb.model.recipe.Recipe>` names from the provided ``recipes``.
        """
        return simplejson.dumps([recipe.name for recipe in recipes])

    def list_bags(self, bags):
        """
        Create a ``JSON`` list of :py:class:`bag <tiddlyweb.model.bag.Bag>`
        names from the provided ``bags``.
        """
        return simplejson.dumps([bag.name for bag in bags])

    def list_tiddlers(self, tiddlers):
        """
        List the provided :py:class:`tiddlers
        <tiddlyweb.model.tiddler.Tiddler>` as ``JSON``. The format is a
        list of dicts in the form described by :py:func:`_tiddler_dict`.

        If ``fat=1`` is set in ``tiddlyweb.query`` include the ``text``
        of each tiddler in the output.

        If ``render=1`` is set in ``tiddlyweb.query`` include the
        :py:mod:`rendering <tiddlyweb.wikitext>` of the ``text``
        of each tiddler in the output, if the tiddler is renderable.
        """
        query = self.environ.get('tiddlyweb.query', {})
        fat = 0
        render = 0
        try:
            fat = int(query.get('fat', [fat])[0])
            render = int(query.get('render', [render])[0])
        except ValueError:
            pass

        return simplejson.dumps([self._tiddler_dict(tiddler, fat, render) for
            tiddler in tiddlers])

    def recipe_as(self, recipe):
        """
        A :py:class:`recipe <tiddlyweb.model.recipe.Recipe>` as a
        ``JSON`` dictionary. Includes the recipe's :py:class:`policy
        <tiddlyweb.model.policy.Policy>`.
        """
        policy_dict = dict([(key, getattr(recipe.policy, key)) for
                key in Policy.attributes])
        return simplejson.dumps(dict(desc=recipe.desc, policy=policy_dict,
            recipe=recipe.get_recipe()))

    def as_recipe(self, recipe, input_string):
        """
        Turn a ``JSON`` dictionary into a :py:class:`recipe
        <tiddlyweb.model.recipe.Recipe>` if it is in the proper form.
        Include the :py:class:`policy <tiddlyweb.model.policy.Policy>`.
        """
        try:
            info = simplejson.loads(input_string)
        except simplejson.JSONDecodeError as exc:
            raise RecipeFormatError(
                    'unable to make json into recipe: %s, %s'
                    % (recipe.name, exc))
        recipe.set_recipe(info.get('recipe', []))
        recipe.desc = info.get('desc', u'')
        if info.get('policy', {}):
            recipe.policy = Policy()
            for key, value in info['policy'].items():
                recipe.policy.__setattr__(key, value)
        return recipe

    def bag_as(self, bag):
        """
        A :py:class:`bag <tiddlyweb.model.bag.Bag>` as a
        ``JSON`` dictionary. Includes the bag's :py:class:`policy
        <tiddlyweb.model.policy.Policy>`.
        """
        policy_dict = dict([(key, getattr(bag.policy, key)) for
                key in Policy.attributes])
        info = dict(policy=policy_dict, desc=bag.desc)
        return simplejson.dumps(info)

    def as_bag(self, bag, input_string):
        """
        Turn a ``JSON`` dictionary into a :py:class:`bag
        <tiddlyweb.model.bag.Bag>` if it is in the proper form.
        Include the :py:class:`policy <tiddlyweb.model.policy.Policy>`.
        """
        try:
            info = simplejson.loads(input_string)
        except simplejson.JSONDecodeError as exc:
            raise BagFormatError(
                    'unable to make json into bag: %s, %s'
                    % (bag.name, exc))

        if info.get('policy', {}):
            bag.policy = Policy()
            for key, value in info['policy'].items():
                bag.policy.__setattr__(key, value)
        bag.desc = info.get('desc', u'')
        return bag

    def tiddler_as(self, tiddler):
        """
        Create a ``JSON`` dictionary representing a tiddler, as described by
        :py:func:`_tiddler_dict` plus the ``text`` of the tiddler.

        If ``fat=0`` is set in ``tiddlyweb.query`` do not include the
        ``text`` of the tiddler in the output.

        If ``render=1`` is set in ``tiddlyweb.query`` include the
        :py:mod:`rendering <tiddlyweb.wikitext>` of the ``text``
        of the tiddler in the output, if the tiddler is renderable.
        """
        query = self.environ.get('tiddlyweb.query', {})
        fat = 1
        render = 0
        try:
            fat = int(query.get('fat', [fat])[0])
            render = int(query.get('render', [render])[0])
        except ValueError:
            pass

        tiddler_dict = self._tiddler_dict(tiddler, fat=fat, render=render)
        return simplejson.dumps(tiddler_dict)

    def as_tiddler(self, tiddler, input_string):
        """
        Turn a ``JSON`` dictionary into a :py:class:`tiddler
        <tiddlyweb.model.tiddler.Tiddler>`. Any keys in the ``JSON``
        which are not recognized will be ignored.
        """
        try:
            dict_from_input = simplejson.loads(input_string)
        except simplejson.JSONDecodeError as exc:
            raise TiddlerFormatError(
                    'unable to make json into tiddler: %s, %s'
                    % (tiddler.title, exc))
        accepted_keys = ['created', 'modified', 'modifier', 'tags', 'fields',
                'text', 'type']
        for key, value in dict_from_input.items():
            if value is not None and key in accepted_keys:
                setattr(tiddler, key, value)
        if binary_tiddler(tiddler):
            try:
                tiddler.text = b64decode(tiddler.text)
            except (TypeError, ValueError) as exc:
                raise TiddlerFormatError(
                        'unable to decode expected base64 input in %s: %s'
                        % (tiddler.title, exc))
        return tiddler

    def _tiddler_dict(self, tiddler, fat=False, render=False):
        """
        Select fields from a tiddler to create
        a dictonary.
        """
        unwanted_keys = ['text', 'store']
        wanted_keys = [attribute for attribute in tiddler.slots if
                attribute not in unwanted_keys]
        wanted_info = {}
        for attribute in wanted_keys:
            wanted_info[attribute] = getattr(tiddler, attribute, None)
        wanted_info['permissions'] = self._tiddler_permissions(tiddler)
        wanted_info['uri'] = tiddler_url(self.environ, tiddler)
        if fat:
            if tiddler.text:
                if binary_tiddler(tiddler):
                    wanted_info['text'] = b64encode(tiddler.text)
                else:
                    wanted_info['text'] = tiddler.text
            else:
                wanted_info['text'] = ''
        if render and renderable(tiddler, self.environ):
            wanted_info['render'] = render_wikitext(tiddler, self.environ)
        return wanted_info

    def _tiddler_permissions(self, tiddler):
        """
        Make a list of the permissions the current user has
        on this tiddler.
        """

        def _read_bag_perms(environ, tiddler):
            """
            Read the permissions for the bag containing
            this tiddler.
            """
            perms = []
            if 'tiddlyweb.usersign' in environ:
                store = tiddler.store
                if store:
                    try:
                        bag = Bag(tiddler.bag)
                        bag = store.get(bag)
                        perms = bag.policy.user_perms(
                                environ['tiddlyweb.usersign'])
                    except StoreError:
                        pass
            return perms

        perms = []
        bag_name = tiddler.bag
        if hasattr(self, '_bag_perms_cache'):
            if bag_name in self._bag_perms_cache:
                perms = self._bag_perms_cache[bag_name]
            else:
                perms = _read_bag_perms(self.environ, tiddler)
        else:
            self._bag_perms_cache = {}
            perms = _read_bag_perms(self.environ, tiddler)
        self._bag_perms_cache[bag_name] = perms
        return perms

########NEW FILE########
__FILENAME__ = text
"""
:py:class:`Serialization <tiddlyweb.serializations.SerializationInterface>`
for plain text.
"""

import simplejson

from base64 import b64encode, b64decode

from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.specialbag import get_bag_retriever
from tiddlyweb.serializer import TiddlerFormatError
from tiddlyweb.serializations import SerializationInterface
from tiddlyweb.model.policy import Policy
from tiddlyweb.util import binary_tiddler

from tiddlyweb.fixups import quote, unquote, basestring, unicode


class Serialization(SerializationInterface):
    """
    Serialize entities and collections to and from
    textual representations. This is primarily used
    by the :py:class:`text <tiddlyweb.stores.text.Store>`
    :py:class:`Store <tiddlyweb.store.Store>`.
    """

    tiddler_members = [field for field in Tiddler.data_members if not field in
            ['title', 'text', 'fields']]

    def list_recipes(self, recipes):
        """
        Return a linefeed separated list of :py:class:`recipe
        <tiddlyweb.model.recipe.Recipe>` names in the ``recipes`` list.
        """
        return ('%s\n' % recipe.name for recipe in recipes)

    def list_bags(self, bags):
        """
        Return a linefeed separated list of :py:class:`bag
        <tiddlyweb.model.bag.Bag>` names in the ``bags`` list.
        """
        return ('%s\n' % bag.name for bag in bags)

    def list_tiddlers(self, tiddlers):
        """
        Return a linefeed separated list of :py:class:`tiddler
        <tiddlyweb.model.tiddler.Tiddler>` titles in the ``tiddlers`` list.

        If the tiddlers are a collection of revisions, include the
        revision identifier.
        """
        tiddlers.store = None
        if hasattr(tiddlers, 'is_revisions') and tiddlers.is_revisions:
            for tiddler in tiddlers:
                yield "%s:%s\n" % (tiddler.title, tiddler.revision)
        else:
            for tiddler in tiddlers:
                yield "%s\n" % tiddler.title
        return

    def recipe_as(self, recipe):
        """
        Dump a :py:class:`recipe <tiddlyweb.model.recipe.Recipe>` as text.
        """
        policy_dict = dict([(key, getattr(recipe.policy, key)) for
                key in Policy.attributes])
        lines = ['desc: %s' % recipe.desc, 'policy: %s' %
                simplejson.dumps(policy_dict), '']

        for bag, filter_string in recipe.get_recipe():
            line = ''
            if not get_bag_retriever(self.environ, bag):
                # If there is a retriever for this bag name then
                # we want to write its name straight.
                line += '/bags/%s/tiddlers' % quote(
                        bag.encode('utf-8'), safe='')
            else:
                line += bag
            if filter_string:
                line += '?%s' % filter_string
            lines.append(line)

        return "\n".join(lines)

    def as_recipe(self, recipe, input_string):
        """
        Turn a string into a :py:class:`recipe
        <tiddlyweb.model.recipe.Recipe>` if possible.
        """

        def _handle_headers(recipe, header):
            """
            Parse recipe headers from text.
            """
            headers = header.split('\n')
            for field, value in [x.split(': ', 1) for x in headers]:
                if field == 'policy':
                    recipe.policy = Policy()
                    info = simplejson.loads(value)
                    for key, value in info.items():
                        recipe.policy.__setattr__(key, value)
                else:
                    setattr(recipe, field, value)

        try:
            header, body = input_string.rstrip().split('\n\n', 1)
            _handle_headers(recipe, header)
        except ValueError:
            body = input_string.rstrip()
            if body.startswith('desc:'):
                header = body
                body = ''
                _handle_headers(recipe, header)

        recipe_lines = self._recipe_lines(body)
        recipe.set_recipe(recipe_lines)
        return recipe

    def tiddler_as(self, tiddler, omit_empty=False, omit_members=None):
        """
        Represent a :py:class:`tiddler <tiddlyweb.model.tiddler.Tiddler>`
        as a text string: headers, blank line, text.

        ``omit_*`` arguments are non-standard options, usable only when this
        method is called directly (outside the regular Serializer interface)

        If ``omit_empty`` is True, don't emit empty Tiddler members.

        ``omit_members`` can be used to provide a list of members to not
        include in the output.
        """
        omit_members = omit_members or []

        headers = []
        for member in self.tiddler_members:
            if member in omit_members:
                continue

            value = getattr(tiddler, member)
            if member == 'tags':  # XXX: special-casing
                value = self.tags_as(tiddler.tags).replace('\n', '\\n')

            if value or not omit_empty:
                if value is None:
                    value = ''
                headers.append('%s: %s' % (member, value))

        custom_fields = self.fields_as(tiddler)
        headers.extend(custom_fields)

        if binary_tiddler(tiddler):
            body = b64encode(tiddler.text).decode('UTF-8')
        else:
            body = tiddler.text

        return '%s\n\n%s\n' % ('\n'.join(headers), body)

    def fields_as(self, tiddler):
        """
        Turn extended :py:class:`tiddler <tiddlyweb.model.tiddler.Tiddler>`
        fields into RFC 822-style header strings.
        """
        fields = []
        for key in tiddler.fields:
            try:
                if hasattr(tiddler, key):
                    raise TiddlerFormatError(
                            'reserved key "%s" in fields of tiddler: %s'
                            % (key, tiddler.title))
            except UnicodeEncodeError:
                pass
            # XXX: TiddlyWiki legacy remnant?
            if not key.startswith('server.'):
                value = unicode(tiddler.fields[key])
                fields.append('%s: %s' % (key, value.replace('\n', '\\n')))
        return fields

    def as_tiddler(self, tiddler, input_string):
        """
        Transform a text representation of a :py:class:`tiddler
        <tiddlyweb.model.tiddler.Tiddler>` into a tiddler object.
        """
        try:
            header, text = input_string.split('\n\n', 1)
            tiddler.text = text.rstrip()
            headers = header.split('\n')

            for field, value in [x.split(': ', 1) for x in headers]:
                if value == '':
                    continue
                try:
                    if hasattr(tiddler, field):
                        setattr(tiddler, field, value)
                    else:
                        tiddler.fields[field] = value.replace('\\n', '\n')
                except UnicodeEncodeError:
                    tiddler.fields[field] = value.replace('\\n', '\n')
        except ValueError as exc:
            raise TiddlerFormatError('bad headers in tiddler: %s, %s' %
                    (tiddler.title, exc))

        # In some strange situations tiddler.tags will not
        # be a string here, so will still have its default
        # value of [], which we want to keep.
        if isinstance(tiddler.tags, basestring):
            tag_string = tiddler.tags
            if tag_string:
                tiddler.tags = self.as_tags(tag_string)

        # If this is a binary tiddler, clean up.
        if binary_tiddler(tiddler):
            tiddler.text = b64decode(tiddler.text.lstrip().rstrip())

        return tiddler

    def _recipe_lines(self, body):
        """
        Given text containing a list of recipes, calculate
        the recipe information they hold and return
        as a list of bagname, filter lists.
        """
        recipe_lines = []
        if len(body):
            lines = body.rstrip().split('\n')
            for line in lines:
                if '?' in line:
                    bag, query_string = line.split('?')
                    filter_string = query_string
                else:
                    bag = line
                    filter_string = ''
                if bag.startswith('/bags/'):
                    bagname = bag.split('/')[2]
                    bagname = unquote(bagname)
                else:
                    bagname = bag
                recipe_lines.append((bagname, filter_string))
        return recipe_lines

########NEW FILE########
__FILENAME__ = serializer
"""
Serialize TiddlyWeb entities for the sake of taking input and sending
output.

This module provides the facade for accessing the possibly many modules
which act as serializations. It is asked by calling code to provide a
serialization for a given MIME type. Plugins may override what MIME
types are handled and by what modules. See :py:mod:`tiddlyweb.config`
for related configuration settings.
"""

from tiddlyweb.util import superclass_name


class TiddlerFormatError(Exception):
    """
    The provided input is insufficient to form a valid Tiddler.
    """
    pass


class BagFormatError(Exception):
    """
    The provided input is insufficient to form a valid Bag.
    """
    pass


class RecipeFormatError(Exception):
    """
    The provided input is insufficient to form a valid Recipe.
    """
    pass


class NoSerializationError(Exception):
    """
    There is a NoSerialization of this type for the entity.
    """
    pass


class Serializer(object):
    """
    A Serializer is a facade to a Serialization which implements the
    :py:class:`tiddlyweb.serializations.SerializationInterface` to turn a
    TiddlyWeb :py:mod:`entity <tiddlyweb.model>` into a particular
    representation or vice versa.

    A Serializer can also list collections of entities in a particular
    representation.

    A single Serializer is a reusable tool which can serialize more than
    one object. You must set serializer.object after initialization and
    then again for each subsequent object being serialized.

    The following example turns the :py:class:`tiddler
    <tiddlyweb.model.tiddler.Tiddler>` into JSON and vice-versa::

        tiddler = Tiddler('cow', 'bag')
        tiddler.text = 'moo'
        serializer = Serializer('json', environ)
        serializer.object = tiddler
        json_string = serializer.to_string()
        assert '"text": "moo"' in json_string
        new_string = json_string.replace('moo', 'meow')
        serializer.from_string(new_string)
        assert tiddler.text == 'meow'

    Note that :py:meth:`to_string` and :py:meth:`from_string` operate on the
    Serializer which dispatches to a method in the SerializationInterface
    implementation based on the class of the object being serialized.
    """

    def __init__(self, engine, environ=None):
        if environ is None:
            environ = {}
        self.engine = engine
        self.object = None
        self.environ = environ
        self.serialization = None
        self._figure_serialization()

    def _figure_serialization(self):
        """
        Import the required Serialization.
        """
        if self.engine is None:
            raise NoSerializationError
        try:
            imported_module = __import__('tiddlyweb.serializations.%s'
                    % self.engine, {}, {}, ['Serialization'])
        except ImportError as err:
            err1 = err
            try:
                imported_module = __import__(self.engine, {}, {},
                        ['Serialization'])
            except ImportError as err:
                raise ImportError("couldn't load module for %s: %s, %s"
                        % (self.engine, err, err1))
        self.serialization = imported_module.Serialization(self.environ)

    def __str__(self):
        lower_class = superclass_name(self.object)
        try:
            string_func = getattr(self.serialization, '%s_as' % lower_class)
        except AttributeError as exc:
            raise AttributeError(
                    'unable to find to string function for %s: %s'
                    % (lower_class, exc))
        return string_func(self.object)

    def to_string(self):
        """
        Provide a (usually unicode) string representation of the
        :py:class:`bag <tiddlyweb.model.bag.Bag>`, :py:class:`recipe
        <tiddlyweb.model.recipe.Recipe>` or :py:class:`tiddler
        <tiddlyweb.model.tiddler.Tiddler>` at ``self.object``.
        """
        return self.__str__()

    def from_string(self, input_string):
        """
        Turn the provided ``input_string`` into a TiddlyWeb entity object
        of the type of ``self.object``. That is: populate ``self.object``
        based on ``input_string``.
        """
        lower_class = superclass_name(self.object)
        try:
            object_func = getattr(self.serialization, 'as_%s' % lower_class)
        except AttributeError as exc:
            raise AttributeError(
                    'unable to find from string function for %s: %s'
                    % (lower_class, exc))
        return object_func(self.object, input_string)

    def list_recipes(self, recipes):
        """
        Provide a (usually unicode) string representation of the provided
        :py:class:`recipes <tiddlyweb.model.recipe.Recipe>` in the current
        serialization.
        """
        return self.serialization.list_recipes(recipes)

    def list_bags(self, bags):
        """
        Provide a (usually unicode) string representation of the provided
        :py:class:`bags <tiddlyweb.model.bag.Bag>` in the current
        serialization.
        """
        return self.serialization.list_bags(bags)

    def list_tiddlers(self, tiddlers):
        """
        Provide a (usually unicode) string representation of the
        :py:class:`tiddlers <tiddlyweb.model.tiddler.Tiddler>` in the
        provided :py:class:`Tiddlers collection
        <tiddlyweb.model.collections.Tiddlers>`.
        """
        return self.serialization.list_tiddlers(tiddlers)

########NEW FILE########
__FILENAME__ = specialbag
"""
Special bags are a feature implemented in plugins that allow
non-standard collections of data to be represented as a
:py:class:`bag <tiddlyweb.model.bag.Bag>` of :py:class:`tiddlers
<tiddlyweb.model.tiddler.Tiddler>`. An example is `remotebag`_.

.. _remotebag: https://pypi.python.org/pypi/tiddlywebplugins.remotebag

If ``config['special_bag_detectors']`` is set, it is a list of functions
that take two arguments: a WSGI ``environ`` and a string and return either:

* two functions
* None

The first function yields tiddlers, like
:py:func:`tiddlyweb.store.list_bag_tiddlers`. It's arguments are a
WSGI `environ` and a string.

The second function returns a single :py:class:`tiddler
<tiddlyweb.model.tiddler.Tiddler>`. It's arguments are a WSGI
``environ`` and a tiddler object (with at least ``title`` and ``bag`` set).
"""


class SpecialBagError(Exception):
    """
    A generic exception to be raised by special bag implementations.
    """
    pass


def get_bag_retriever(environ, bag):
    """
    When loading :py:class:`bag <tiddlyweb.model.bag.Bag>` or
    :py:class:`tiddlers <tiddlyweb.model.tiddler.Tiddler>` within it
    from the :py:class:`store <tiddlyweb.store.Store>`, this method is
    used to inspect ``config['special_bag_detectors']`` to determine
    if there is a special handler. If there is, the handler is returned
    and used for retrieval, otherwise ``None`` is returned and the store
    is used as normal.
    """
    try:
        config = environ['tiddlyweb.config']
    except KeyError:
        from tiddlyweb.config import config
    testers = config.get('special_bag_detectors', [])
    for bag_tester in testers:
        retriever = bag_tester(environ, bag)
        if retriever:
            return retriever
    return None

########NEW FILE########
__FILENAME__ = store
"""
Store TiddlyWeb entities to a configured persistence layer.

This module provides the facade for accessing one of many possible
modules which provide storage for entities. It provides a general
interface to get, put, delete or list :py:mod:`entities <tiddlyweb.model>`.

Each of the single entity methods can be augmented with hooks
provided by plugins. This allows actions to be performed based on
data in the store being retrieved or updated, such as updating an
index.
"""

from copy import deepcopy

from tiddlyweb.specialbag import get_bag_retriever, SpecialBagError
from tiddlyweb.model.policy import Policy
from tiddlyweb.util import superclass_name

from tiddlyweb.fixups import basestring


class StoreError(IOError):
    """
    Base Exception for Store Exceptions.
    """
    def __str__(self):
        # self.args may or may not be a string, and when that
        # is the case is proving rather difficult to tell between
        # minor and micro versions of Python. woot!
        # So here we do some extra work.
        message = []
        for arg in self.args:
            if isinstance(arg, basestring):
                message.append(arg)
        return ' '.join(message)


class StoreMethodNotImplemented(StoreError):
    """
    A :py:class:`tiddlyweb.stores.StorageInterface` does not implement
    this method.
    """
    pass


class NoBagError(StoreError):
    """
    No :py:class:`tiddlyweb.model.bag.Bag` was found.
    """
    pass


class NoRecipeError(StoreError):
    """
    No :py:class:`tiddlyweb.model.recipe.Recipe` was found.
    """
    pass


class NoTiddlerError(StoreError):
    """
    No :py:class:`tiddlyweb.model.tiddler.Tiddler` was found.
    """
    pass


class NoUserError(StoreError):
    """
    No :py:class:`tiddlyweb.model.user.User` was found.
    """
    pass


class StoreLockError(StoreError):
    """
    This process was unable to get a lock on the store.
    """
    pass


class StoreEncodingError(StoreError):
    """
    Something about an entity made it impossible to be encoded to the
    form required by the store.
    """
    pass


EMPTY_HOOKS = {
        'put': [],
        'delete': [],
        'get': [],
}
HOOKS = {
        'recipe': deepcopy(EMPTY_HOOKS),
        'bag': deepcopy(EMPTY_HOOKS),
        'tiddler': deepcopy(EMPTY_HOOKS),
        'user': deepcopy(EMPTY_HOOKS),
}


class Store(object):
    """
    A Store is a facade to an implementation of
    :py:class:`tiddlyweb.stores.StorageInterface` to handle the storage
    and retrieval of all :py:mod:`entities <tiddlyweb.model>` in the
    TiddlyWeb system.

    Because of the facade system it is relatively straightforward to
    create diverse storage systems for all sorts of or multiple media. In
    addition stores can be layered to provide robust caching and
    reliability.

    The Store distinguishes between single entities and collections.
    With single entities, an entity is passed to the store and the
    store is asked to :py:meth:`get`, :py:meth:`put` or :py:meth:`delete`
    it. When :py:meth:`get` is used the provided object is updated in
    place in operation that could be described as population. Dispatch
    is based on the class of the provided entity.

    After any of those operations optional ``HOOKS`` are called.

    With collections there are specific ``list`` methods:

    * :py:meth:`list_bags`
    * :py:meth:`list_recipes`
    * :py:meth:`list_bag_tiddlers`
    * :py:meth:`list_tiddler_revisions`
    * :py:meth:`list_users`

    Finally a store may optionally provide a :py:meth:`search`. How
    search works and what it even means is up to the implementation.
    """

    def __init__(self, engine, config=None, environ=None):
        if config is None:
            config = {}
        self.engine = engine
        self.environ = environ
        self.storage = None
        self.config = config
        self._import()

    def _import(self):
        """
        Import the required :py:class:`tiddlyweb.stores.StorageInterface`.
        """
        try:
            imported_module = __import__('tiddlyweb.stores.%s' % self.engine,
                    {}, {}, ['Store'])
        except ImportError as err:
            err1 = err
            try:
                imported_module = __import__(self.engine, {}, {}, ['Store'])
            except ImportError as err:
                raise ImportError("couldn't load store for %s: %s, %s"
                        % (self.engine, err, err1))
        self.storage = imported_module.Store(self.config, self.environ)

    def delete(self, thing):
        """
        Delete a thing: recipe, bag, tiddler or user.
        """
        func = self._figure_function('delete', thing)
        result = func(thing)
        self._do_hook('delete', thing)
        return result

    def get(self, thing):
        """
        Get a thing: recipe, bag, tiddler or user.
        """
        lower_class = superclass_name(thing)
        if lower_class == 'tiddler':
            retriever = get_bag_retriever(self.environ, thing.bag)
            if retriever:
                try:
                    thing = retriever[1](thing)
                except SpecialBagError as exc:
                    raise NoTiddlerError(
                            'unable to get special tiddler: %s:%s:%s'
                            % (thing.bag, thing.title, exc))
                thing.store = self
                self._do_hook('get', thing)
                return thing
        elif lower_class == 'bag':
            if get_bag_retriever(self.environ, thing.name):
                policy = Policy(read=[], write=['NONE'], create=['NONE'],
                        delete=['NONE'], manage=['NONE'], accept=['NONE'])
                thing.policy = policy
                thing.store = self
                self._do_hook('get', thing)
                return thing
        func = self._figure_function('get', thing)
        thing = func(thing)
        thing.store = self
        self._do_hook('get', thing)
        return thing

    def put(self, thing):
        """
        Put a thing, recipe, bag, tiddler or user.
        """
        func = self._figure_function('put', thing)
        result = func(thing)
        self._do_hook('put', thing)
        return result

    def _figure_function(self, activity, storable):
        """
        Determine which function on the StorageInterface
        we should use to store or retrieve storable.
        """
        lower_class = superclass_name(storable)
        try:
            func = getattr(self.storage, '%s_%s' % (lower_class, activity))
        except AttributeError as exc:
            raise AttributeError('unable to figure function for %s: %s'
                    % (lower_class, exc))
        return func

    def list_bags(self):
        """
        List all the available bags in the system.
        """
        list_func = getattr(self.storage, 'list_bags')
        return list_func()

    def list_bag_tiddlers(self, bag):
        """
        List all the tiddlers in the bag.
        """
        retriever = get_bag_retriever(self.environ, bag.name)
        if retriever:
            try:
                return retriever[0](bag.name)
            except SpecialBagError as exc:
                raise NoBagError('unable to get special bag: %s: %s'
                        % (bag.name, exc))
        list_func = getattr(self.storage, 'list_bag_tiddlers')
        return list_func(bag)

    def list_recipes(self):
        """
        List all the available recipes in the system.
        """
        list_func = getattr(self.storage, 'list_recipes')
        return list_func()

    def list_tiddler_revisions(self, tiddler):
        """
        List the revision ids of the revisions of the indicated tiddler
        in reverse chronological older (newest first).
        """
        list_func = getattr(self.storage, 'list_tiddler_revisions')
        return list_func(tiddler)

    def list_users(self):
        """
        List all the available users in the system.
        """
        list_func = getattr(self.storage, 'list_users')
        return list_func()

    def search(self, search_query):
        """
        Search in the store, using a search algorithm
        specific to the :py:class:`tiddlyweb.stores.StorageInterface`
        implementation.
        """
        list_func = getattr(self.storage, 'search')
        return list_func(search_query)

    def _do_hook(self, method, thing):
        """
        Call the hook in HOOKS identified by method on thing.
        """
        hooked_class = superclass_name(thing)
        hooks = _get_hooks(method, hooked_class)
        for hook in hooks:
            hook(self, thing)


def get_entity(entity, store):
    """
    Load the provided entity from the store if it has not already
    been loaded. If it can't be found, still return the same entity,
    just keep it empty.

    This works for tiddlers, bags and recipes. Not users!
    """
    if store and not entity.store:
        try:
            try:
                stored_entity = entity.__class__(entity.title, entity.bag)
                if entity.revision:
                    stored_entity.revision = entity.revision
            except AttributeError:
                stored_entity = entity.__class__(entity.name)
            stored_entity = store.get(stored_entity)
        except (AttributeError, StoreError):
            stored_entity = entity
    else:
        stored_entity = entity
    return stored_entity


def _get_hooks(method, name):
    """
    Look in HOOKS for the list of functions to run
    for the class of things named by name when store
    method method is called.
    """
    try:
        return HOOKS[name][method]
    except KeyError:
        return []

########NEW FILE########
__FILENAME__ = text
"""
A text-based :py:class:`StorageInterface
<tiddlyweb.stores.StorageInterface>` that stores entities
in a hierarchy of directories in the filesystem.
"""

import codecs
import logging
import os
import simplejson
import shutil
import time

from tiddlyweb.model.bag import Bag
from tiddlyweb.model.policy import Policy
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.model.user import User
from tiddlyweb.serializer import Serializer
from tiddlyweb.store import (NoBagError, NoRecipeError, NoTiddlerError,
        NoUserError, StoreLockError, StoreEncodingError)
from tiddlyweb.stores import StorageInterface
from tiddlyweb.util import (LockError, write_lock, write_unlock,
        read_utf8_file, write_utf8_file)

from tiddlyweb.fixups import quote, unquote


LOGGER = logging.getLogger(__name__)


class Store(StorageInterface):
    """
    A :py:class:`StorageInterface <tiddlyweb.stores.StorageInterface>`
    which stores text-based representations in a collection of directories
    and files.

    Some of the entities are serialized to and from text by the
    :py:class:`text <tiddlyweb.serializations.text.Serialization>`
    :py:class:`Serializer <tiddlyweb.serializer.Serializer>`.
    """

    def __init__(self, store_config=None, environ=None):
        super(Store, self).__init__(store_config, environ)
        self.serializer = Serializer('text')
        self._root = self._fixup_root(store_config['store_root'])
        self._init_store()

    def _fixup_root(self, path):
        """
        Adjust the ``store_root`` path so it is absolute.

        This is required in some web serving environments.
        """
        if not os.path.isabs(path):
            path = os.path.join(self.environ['tiddlyweb.config'].
                    get('root_dir', ''), path)
        return path

    def _init_store(self):
        """
        Make sure the data storage directory and structure is present.
        """
        if not os.path.exists(self._store_root()):
            os.mkdir(self._store_root())
            for name in ['bags', 'recipes', 'users']:
                path = os.path.join(self._store_root(), name)
                if not os.path.exists(path):
                    os.mkdir(path)

    def recipe_delete(self, recipe):
        """
        Remove a :py:class:`recipe <tiddlyweb.model.recipe.Recipe>`,
        irrevocably, from the system. No impact on :py:class:`tiddlers
        <tiddlyweb.model.tiddler.Tiddler>`.
        """
        try:
            recipe_path = self._recipe_path(recipe)
            if not os.path.exists(recipe_path):
                raise NoRecipeError('%s not present' % recipe_path)
            os.remove(recipe_path)
        except (NoRecipeError, StoreEncodingError) as exc:
            raise NoRecipeError(exc)
        except Exception as exc:
            raise IOError('unable to delete recipe %s: %s' %
                    (recipe.name, exc))

    def recipe_get(self, recipe):
        """
        Fill :py:class:`recipe <tiddlyweb.model.recipe.Recipe>` with
        data in the store.
        """
        try:
            recipe_path = self._recipe_path(recipe)
            self.serializer.object = recipe
            recipe_string = read_utf8_file(recipe_path)
        except StoreEncodingError as exc:
            raise NoRecipeError(exc)
        except IOError as exc:
            raise NoRecipeError('unable to get recipe %s: %s' %
                    (recipe.name, exc))

        return self.serializer.from_string(recipe_string)

    def recipe_put(self, recipe):
        """
        Put :py:class:`recipe <tiddlyweb.model.recipe.Recipe>`
        into the store.
        """
        try:
            recipe_path = self._recipe_path(recipe)
            self.serializer.object = recipe
            write_utf8_file(recipe_path, self.serializer.to_string())
        except StoreEncodingError as exc:
            raise NoRecipeError(exc)

    def bag_delete(self, bag):
        """
        Delete :py:class:`bag <tiddlyweb.model.bag.Bag>` **and** the
        :py:class:`tiddlers <tiddlyweb.model.tiddler.Tiddler>` within from
        the system.
        """
        bag_path = self._bag_path(bag.name)

        try:
            if not os.path.exists(bag_path):
                raise NoBagError('%s not present' % bag_path)
            shutil.rmtree(bag_path)
        except NoBagError:
            raise
        except Exception as exc:
            raise IOError('unable to delete bag %s: %s' % (bag.name, exc))

    def bag_get(self, bag):
        """
        Fill :py:class:`bag <tiddlyweb.model.bag.Bag>` with data
        from the store.
        """
        bag_path = self._bag_path(bag.name)

        try:
            bag.desc = self._read_bag_description(bag_path)
            bag.policy = self._read_policy(bag_path)
        except IOError as exc:
            raise NoBagError(
                    'unable to read policy or description at %s: %s' %
                    (bag_path, exc))

        return bag

    def bag_put(self, bag):
        """
        Put :py:class:`bag <tiddlyweb.model.bag.Bag>` into the store.
        """
        bag_path = self._bag_path(bag.name)
        tiddlers_dir = self._tiddlers_dir(bag.name)

        if not os.path.exists(bag_path):
            os.mkdir(bag_path)

        if not os.path.exists(tiddlers_dir):
            os.mkdir(tiddlers_dir)

        self._write_bag_description(bag.desc, bag_path)
        self._write_policy(bag.policy, bag_path)

    def tiddler_delete(self, tiddler):
        """
        Irrevocably remove :py:class:`tiddler
        <tiddlyweb.model.tiddler.Tiddler>` from the filesystem.
        """
        try:
            tiddler_base_filename = self._tiddler_base_filename(tiddler)
            if not os.path.exists(tiddler_base_filename):
                raise NoTiddlerError('%s not present' % tiddler_base_filename)
            shutil.rmtree(tiddler_base_filename)
        except NoTiddlerError:
            raise
        except Exception as exc:
            raise IOError('unable to delete %s: %s' % (tiddler.title, exc))

    def tiddler_get(self, tiddler):
        """
        Fill :py:class:`tiddler <tiddlyweb.model.tiddler.Tiddler>` with
        data from the store.
        """
        try:
            # read in the desired tiddler
            tiddler = self._read_tiddler_revision(tiddler)
            # now make another tiddler to get created time
            first_rev = Tiddler(tiddler.title)
            first_rev.bag = tiddler.bag
            first_rev = self._read_tiddler_revision(first_rev, index=-1)
            # set created on new tiddler from modified on first_rev
            # (might be the same)
            tiddler.created = first_rev.modified
            tiddler.creator = first_rev.modifier
            return tiddler
        except IOError as exc:
            raise NoTiddlerError('no tiddler for %s: %s' %
                    (tiddler.title, exc))

    def tiddler_put(self, tiddler):
        """
        Write a :py:class:`tiddler <tiddlyweb.model.tiddler.Tiddler>`
        into the store. We only write if the tiddler's :py:class:`bag
        <tiddlyweb.model.bag.Bag>` already exists. Bag creation is a
        separate action.
        """
        tiddler_base_filename = self._tiddler_base_filename(tiddler)
        if not os.path.exists(tiddler_base_filename):
            try:
                os.mkdir(tiddler_base_filename)
            except OSError as exc:
                raise NoTiddlerError('unable to put tiddler: %s' % exc)

        locked = 0
        lock_attempts = 0
        while not locked:
            try:
                lock_attempts = lock_attempts + 1
                write_lock(tiddler_base_filename)
                locked = 1
            except LockError as exc:
                if lock_attempts > 4:
                    raise StoreLockError(exc)
                time.sleep(.1)

        # Protect against incoming tiddlers that have revision
        # set. Since we are putting a new one, we want the system
        # to calculate.
        tiddler.revision = None
        revision = self._tiddler_revision_filename(tiddler) + 1
        tiddler_filename = self._tiddler_full_filename(tiddler, revision)

        representation = self.serializer.serialization.tiddler_as(tiddler,
                omit_empty=True, omit_members=['creator'])
        write_utf8_file(tiddler_filename, representation)
        write_unlock(tiddler_base_filename)

        tiddler.revision = revision

    def user_delete(self, user):
        """
        Delete :py:class:`user <tiddlyweb.model.user.User>` from
        the store.
        """
        try:
            user_path = self._user_path(user)
            if not os.path.exists(user_path):
                raise NoUserError('%s not present' % user_path)
            os.unlink(user_path)
        except NoUserError:
            raise
        except Exception as exc:
            raise IOError('unable to delete %s: %s' % (user.usersign, exc))

    def user_get(self, user):
        """
        Fill :py:class:`user <tiddlyweb.model.user.User>` with
        data from the store.
        """
        try:
            user_path = self._user_path(user)
            user_info = read_utf8_file(user_path)
            user_data = simplejson.loads(user_info)
            for key, value in user_data.items():
                if key == 'roles':
                    user.roles = set(value)
                    continue
                if key == 'password':
                    key = '_password'
                user.__setattr__(key, value)
            return user
        except IOError as exc:
            raise NoUserError('unable to get user %s: %s' %
                    (user.usersign, exc))

    def user_put(self, user):
        """
        Put :py:class:`user <tiddlyweb.model.user.User>` data into the store.
        """
        user_path = self._user_path(user)
        user_dict = {}
        for key in ['usersign', 'note', '_password', 'roles']:
            value = user.__getattribute__(key)
            if key == 'roles':
                user_dict[key] = list(value)
                continue
            if key == '_password':
                key = 'password'
            user_dict[key] = value
        user_info = simplejson.dumps(user_dict, indent=0)
        write_utf8_file(user_path, user_info)

    def list_recipes(self):
        """
        List all the :py:class:`recipes <tiddlyweb.model.recipe.Recipe>`
        in the store.
        """
        path = os.path.join(self._store_root(), 'recipes')
        recipes = self._files_in_dir(path)

        return (Recipe(unquote(recipe)) for recipe in recipes)

    def list_bags(self):
        """
        List all the :py:class:`bags <tiddlyweb.model.bag.Bag>`
        in the store.
        """
        bags = self._bag_filenames()

        return (Bag(unquote(bag)) for bag in bags)

    def list_bag_tiddlers(self, bag):
        """
        List all the :py:class:`tiddlers <tiddlyweb.model.tiddler.Tiddler>`
        in the provided :py:class:`bag <tiddlyweb.model.bag.Bag>`.
        """
        tiddlers_dir = self._tiddlers_dir(bag.name)

        try:
            tiddlers = (filename for filename
                    in self._files_in_dir(tiddlers_dir)
                    if os.path.isdir(os.path.join(tiddlers_dir, filename)))
        except (IOError, OSError) as exc:
            raise NoBagError('unable to list tiddlers in bag: %s' % exc)
        for title in tiddlers:
            title = unquote(title)
            tiddler = Tiddler(title, bag.name)
            yield tiddler

    def list_users(self):
        """
        List all the :py:class:`users <tiddlyweb.model.user.User>`
        in the store.
        """
        path = os.path.join(self._store_root(), 'users')
        users = self._files_in_dir(path)

        return (User(unquote(user)) for user in users)

    def list_tiddler_revisions(self, tiddler):
        """
        List all the revisions of one :py:class:`tiddler
        <tiddlyweb.model.tiddler.Tiddler>`, returning a list of ints.
        """
        tiddler_base_filename = self._tiddler_base_filename(tiddler)
        try:
            revisions = sorted(
                    int(x) for x in
                        self._numeric_files_in_dir(tiddler_base_filename))
        except OSError as exc:
            raise NoTiddlerError('unable to list revisions in tiddler: %s'
                    % exc)
        revisions.reverse()
        return revisions

    def search(self, search_query):
        """
        Search in the store for :py:class:`tiddlers
        <tiddlyweb.model.tiddler.Tiddler>` that match ``search_query``.
        This is intentionally implemented as a simple and limited grep
        through files.
        """
        bag_filenames = self._bag_filenames()

        query = search_query.lower()

        for bagname in bag_filenames:
            bagname = unquote(bagname)
            tiddler_dir = self._tiddlers_dir(bagname)
            tiddler_files = self._files_in_dir(tiddler_dir)
            for tiddler_name in tiddler_files:
                tiddler = Tiddler(title=unquote(tiddler_name), bag=bagname)
                try:
                    revision_id = self.list_tiddler_revisions(tiddler)[0]
                    if query in tiddler.title.lower():
                        yield tiddler
                        continue
                    with codecs.open(
                        self._tiddler_full_filename(tiddler, revision_id),
                            encoding='utf-8') as tiddler_file:
                        for line in tiddler_file:
                            if query in line.lower():
                                yield tiddler
                                break
                except (OSError, NoTiddlerError) as exc:
                    LOGGER.warn('malformed tiddler during search: %s:%s, %s',
                            bagname, tiddler_name, exc)
        return

    def _bag_filenames(self):
        """
        List the filenames that are bags.
        """
        path = os.path.join(self._store_root(), 'bags')
        return self._files_in_dir(path)

    def _bag_path(self, bag_name):
        """
        Return a string that is the path to a bag.
        """
        try:
            return os.path.join(self._store_root(), 'bags',
                    _encode_filename(bag_name))
        except (AttributeError, StoreEncodingError) as exc:
            raise NoBagError('No bag name: %s' % exc)

    def _files_in_dir(self, path):
        """
        List the filenames in a dir that do not start with .
        """
        return (x for x in os.listdir(path))

    def _numeric_files_in_dir(self, path):
        """
        List the filenames in a dir that are made up of
        digits.
        """
        return (x for x in self._files_in_dir(path) if x.isdigit())

    def _read_tiddler_file(self, tiddler, tiddler_filename):
        """
        Read a tiddler file from the disk, returning
        a tiddler object.
        """
        tiddler_string = read_utf8_file(tiddler_filename)
        self.serializer.object = tiddler
        self.serializer.from_string(tiddler_string)
        return tiddler

    def _read_tiddler_revision(self, tiddler, index=0):
        """
        Read a specific revision of a tiddler from disk.
        """
        tiddler_revision = self._tiddler_revision_filename(tiddler,
                index=index)
        tiddler_filename = self._tiddler_full_filename(tiddler,
                tiddler_revision)
        tiddler = self._read_tiddler_file(tiddler, tiddler_filename)
        tiddler.revision = tiddler_revision
        return tiddler

    def _read_bag_description(self, bag_path):
        """
        Read and return the description of a bag.
        """
        desc_filename = os.path.join(bag_path, 'description')
        if not os.path.exists(desc_filename):
            return ''
        desc = read_utf8_file(desc_filename)
        return desc

    def _read_policy(self, bag_path):
        """
        Read and return a bag's policy file,
        return the Policy object.
        """
        policy_filename = os.path.join(bag_path, 'policy')
        policy = read_utf8_file(policy_filename)
        policy_data = simplejson.loads(policy)
        policy = Policy()
        for key, value in policy_data.items():
            policy.__setattr__(key, value)
        return policy

    def _recipe_path(self, recipe):
        """
        Return a string representing the pathname of a recipe.
        """
        return os.path.join(self._store_root(), 'recipes',
                _encode_filename(recipe.name))

    def _store_root(self):
        """
        Return a string which is the path to the root of the store.
        """
        return self._root

    def _tiddler_base_filename(self, tiddler):
        """
        Return the string that is the pathname to
        a tiddler's directory.
        """
        # should we get a Bag or a name here?
        bag_name = tiddler.bag

        store_dir = self._tiddlers_dir(bag_name)

        if not os.path.exists(store_dir):
            raise NoBagError('%s does not exist' % store_dir)

        try:
            return os.path.join(store_dir, _encode_filename(tiddler.title))
        except StoreEncodingError as exc:
            raise NoTiddlerError(exc)

    def _tiddler_full_filename(self, tiddler, revision):
        """
        Return the full path to the respective tiddler file.
        """
        return os.path.join(self._tiddlers_dir(tiddler.bag),
            _encode_filename(tiddler.title), str(revision))

    def _tiddlers_dir(self, bag_name):
        """
        Return the string that is the pathname of the
        tiddlers directory in a bag.
        """
        return os.path.join(self._bag_path(bag_name), 'tiddlers')

    def _tiddler_revision_filename(self, tiddler, index=0):
        """
        Calculate the revision filename for the tiddler revision
        we want.
        """
        revision = 0
        if tiddler.revision:
            revision = tiddler.revision
        else:
            revisions = self.list_tiddler_revisions(tiddler)
            if revisions:
                revision = revisions[index]

        try:
            revision = int(revision)
        except ValueError:
            raise NoTiddlerError('%s is not a valid revision id' % revision)

        return revision

    def _user_path(self, user):
        """
        Return the pathname for a user in the store.
        """
        return os.path.join(self._store_root(), 'users',
                _encode_filename(user.usersign))

    def _write_bag_description(self, desc, bag_path):
        """
        Write the description of a bag to disk.
        """
        desc_filename = os.path.join(bag_path, 'description')
        write_utf8_file(desc_filename, desc)

    def _write_policy(self, policy, bag_path):
        """
        Write the policy of a bad to disk.
        """
        policy_dict = {}
        for key in Policy.attributes:
            policy_dict[key] = policy.__getattribute__(key)
        policy_string = simplejson.dumps(policy_dict)
        policy_filename = os.path.join(bag_path, 'policy')
        write_utf8_file(policy_filename, policy_string)


def _encode_filename(filename):
    """
    utf-8 encode, then url escape, some filename,
    making it easy to use on various filesystems.

    Also check for no ../ in filenames.
    """

    if not filename or '../' in filename:
        raise StoreEncodingError('invalid name for entity')
    return quote(filename.encode('utf-8'), safe=".!~*'()")

########NEW FILE########
__FILENAME__ = util
"""
This module provides a centralized collection of miscellaneous utility
functions used throughout TiddlyWeb and plugins.

Web specific utilities are in :py:mod:`tiddlyweb.web.util`.
"""

from __future__ import print_function

import logging
import codecs
import os
import sys

try:
    from hashlib import sha1
except ImportError:
    from sha import sha as sha1


class LockError(IOError):
    """
    This process was unable to get a lock.
    """
    pass


def merge_config(global_config, additional_config, reconfig=True):
    """
    Update the ``global_config`` with the additional data provided in
    the dict ``additional_config``. If ``reconfig`` is ``True``, then
    reread and merge ``tiddlywebconfig.py`` so its overrides continue
    to operate.

    Note that if the value of a existing key is a dict, then it is
    updated (merged) with the value from ``additional_config``.
    Otherwise the value is replaced.

    *Warning*: Please ensure (via tests) when using this that it will
    give the desired results.
    """
    for key in additional_config:
        try:
            # If this config item is a dict, update to
            # update it
            additional_config[key].keys()
            try:
                global_config[key].update(additional_config[key])
            except KeyError:
                global_config[key] = {}
                global_config[key].update(additional_config[key])
        except AttributeError:
            global_config[key] = additional_config[key]
    if reconfig:
        read_config(global_config)


def read_config(global_config):
    """
    Read in a local configuration override, named ``tiddlywebconfig.py``,
    from the current working directory. If the file exists but can't be
    imported as valid Python an exception will be thrown, preventing
    unexpected results.

    What is expected in the override file is a dict with the name ``config``.

    ``global_config`` is a reference to the currently operational
    main TiddlyWeb :py:mod:`config <tiddlyweb.config>`. The read
    configuration data is merged into it.
    """
    try:
        from tiddlywebconfig import config as custom_config
        merge_config(global_config, custom_config, reconfig=False)
    except ImportError as exc:
        if not ('module named' in exc.args[0]
                and 'tiddlywebconfig' in exc.args[0]):
            raise  # error within tiddlywebconfig.py


def sha(data=''):
    """
    Create a sha1 digest of the ``data``.
    """
    return sha1(data.encode('UTF-8'))


def binary_tiddler(tiddler):
    """
    Test if a :py:class:`tiddler <tiddlyweb.model.tiddler.Tiddler>`
    represents binary content (e.g. an image).

    Return ``True`` if this Tiddler has a ``type`` which suggests the
    content of the tiddler is non-textual.
    """
    return (tiddler.type and tiddler.type != 'None'
            and not pseudo_binary(tiddler.type))


def pseudo_binary(content_type):
    """
    Test if a :py:class:`tiddler <tiddlyweb.model.tiddler.Tiddler>`
    represents textual content that should be treated as a pseudo-binary.

    A pseudo binary is defined as textual content for which (this) TiddlyWeb
    (instance) has no :py:class:`serialization
    <tiddlyweb.serializations.SerializationInterface>` or is not treated
    as :py:mod:`wikitext <tiddlyweb.wikitext>`. It is identified by a
    ``MIME`` type that looks like ``text``, ``json``, ``xml`` or
    ``javascript``.

    TiddlyWeb requires that such content be uploaded encoded as ``UTF-8``.
    """
    content_type = content_type.lower()
    return (content_type.startswith('text/')
            or content_type.endswith('+xml')
            or content_type.endswith('+json')
            or content_type == 'application/javascript'
            or content_type == 'application/json')


def read_utf8_file(filename):
    """
    Read the ``UTF-8`` encoded file at ``filename`` and return unicode.

    Allow any exceptions to raise.
    """
    with codecs.open(filename, encoding='utf-8') as source_file:
        content = source_file.read()
    return content


def renderable(tiddler, environ=None):
    """
    Return ``True`` if the provided :py:class:`tiddler's
    <tiddlyweb.model.tiddler.Tiddler>` ``type`` is one that can be
    rendered to HTML by the :py:mod:`wikitext <tiddlyweb.wikitext>`
    rendering subsystem.
    """
    if not environ:
        environ = {}
    return (not tiddler.type
            or tiddler.type == 'None'
            or tiddler.type
                in environ.get('tiddlyweb.config', {}).get(
                    'wikitext.type_render_map', []))


def std_error_message(message):
    """
    Display ``message`` on the ``stderr`` console.
    """
    print(message, file=sys.stderr)


def superclass_name(instance):
    """
    Given an instance return the lowerclass name of the penultimate
    class in the hierarchy (the last is object). This is used to do
    dynamic method lookups in adaptor classes via serializer.py and
    store.py while still allowing model entities to be subclassed.
    Those subclasses must insure that their __mro__ results in
    Bag, User, Recipe or Tiddler in the penultimate slot.
    """
    return instance.__class__.mro()[-2].__name__.lower()


def write_utf8_file(filename, content):
    """
    Write the unicode string in ``content`` to a ``UTF-8`` encoded
    file named ``filename``.

    Allow any exceptions to raise.
    """
    dest_file = codecs.open(filename, 'w', encoding='utf-8')
    dest_file.write(content)
    dest_file.close()


def write_lock(filename):
    """
    Create an advisory lock file based on ``filename``.

    This is primarily used by the :py:mod:`text store
    <tiddlyweb.stores.text>`.
    """

    lock_filename = _lock_filename(filename)

    if os.path.exists(lock_filename):
        pid = _read_lock_file(lock_filename)
        raise LockError('write lock for %s taken by %s' % (filename, pid))

    lock = open(lock_filename, 'w')
    pid = os.getpid()
    lock.write(str(pid))
    lock.close()


def write_unlock(filename):
    """
    Unlock the write lock associated with ``filename``.
    """
    lock_filename = _lock_filename(filename)
    os.unlink(lock_filename)


def initialize_logging(config, server=False):
    """
    Initialize the system's logging.

    If this code is reached from ``twanager`` when there is no sub_command
    logging is not started. This avoids spurious ``tiddlyweb.log`` files
    popping up all over the place.
    """
    try:
        sub_command = sys.argv[1]
    except IndexError:
        sub_command = None
    if server or sub_command:
        _initialize_logging(config)


def _initialize_logging(config):
    """
    Configure logging.

    Two loggers are established: ``tiddlyweb`` and ``tiddlywebplugins``.
    Modules which wish to log should use ``logging.getLogger(__name__)``
    to get a logger in the right part of the logging hierarchy.
    """
    logger = logging.getLogger('tiddlyweb')
    logger.propagate = False
    logger.setLevel(logging._levelNames[config['log_level']])

    plugin_logger = logging.getLogger('tiddlywebplugins')
    plugin_logger.propagate = False
    plugin_logger.setLevel(logging._levelNames[config['log_level']])

    from logging import FileHandler
    file_handler = FileHandler(
            filename=os.path.join(config['root_dir'], config['log_file']))
    formatter = logging.Formatter(
            '%(asctime)s %(levelname)s %(name)s: %(message)s')
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)
    plugin_logger.addHandler(file_handler)

    logger.debug('TiddlyWeb starting up as %s', sys.argv[0])


def _lock_filename(filename):
    """
    Return the pathname of the lock to used with ``filename``.
    """
    pathname, basename = os.path.split(filename)
    lock_filename = os.path.join(pathname, '.%s' % basename)
    return lock_filename


def _read_lock_file(lockfile):
    """
    Read the pid from the file named by ``lockfile``.
    """
    lock = open(lockfile, 'r')
    pid = lock.read()
    lock.close()
    return pid

########NEW FILE########
__FILENAME__ = challenge
"""
WSGI App for running the base challenge system, which lists and links
to the available :py:class:`challengers
<tiddlyweb.web.challengers.ChallengerInterface>`. If there is only one
challenger, redirect to it.
"""

from httpexceptor import HTTP302, HTTP404

from tiddlyweb.web.util import server_base_url, get_route_value, html_frame

from tiddlyweb.fixups import quote


def base(environ, start_response):
    """
    The basic listing page that shows all available
    :py:class:`challenger systems
    <tiddlyweb.web.challengers.ChallengerInterface>`. If there is only
    one challenger, we redirect to that instead of listing.
    """
    auth_systems = environ['tiddlyweb.config']['auth_systems']
    if len(auth_systems) == 1:
        raise HTTP302(_challenger_url(environ, auth_systems[0]))
    start_response('401 Unauthorized', [('Content-Type', 'text/html')])
    title = 'Login Challengers'

    header, footer = html_frame(environ, title)

    challenger_info = []
    for system in auth_systems:
        uri = _challenger_url(environ, system)
        try:
            challenger = _get_challenger_module(system)
            label = getattr(challenger, 'desc', uri)
            challenger_info.append((uri, label))
        except ImportError:
            pass

    output = ['<li><a href="%s">%s</a></li>' % (uri, label)
            for uri, label in challenger_info]
    return [header] + output + [footer]


def challenge_get(environ, start_response):
    """
    Dispatch a ``GET`` request to the chosen :py:class:`challenger
    <tiddlyweb.web.challengers.ChallengerInterface>`.
    """
    challenger = _determine_challenger(environ)
    return challenger.challenge_get(environ, start_response)


def challenge_post(environ, start_response):
    """
    Dispatch a ``POST`` request to the chosen :py:class:`challenger
    <tiddlyweb.web.challengers.ChallengerInterface>`.
    """
    challenger = _determine_challenger(environ)
    return challenger.challenge_post(environ, start_response)


def _challenger_url(environ, system):
    """
    Return the proper URL for a specific challenger system.
    """
    default_redirect = '%s/' % environ['tiddlyweb.config']['server_prefix']
    redirect = (environ['tiddlyweb.query'].get('tiddlyweb_redirect',
            [default_redirect])[0])
    redirect = '?tiddlyweb_redirect=%s' % quote(
            redirect.encode('utf-8'), safe='')
    return '%s/challenge/%s%s' % (server_base_url(environ), system, redirect)


def _determine_challenger(environ, challenger_name=None):
    """
    Determine which challenger we are using and import it as necessary.
    """
    if challenger_name is None:
        challenger_name = get_route_value(environ, 'challenger')
    # If the challenger is not in config, do a 404, we don't want
    # to import any old code.
    if challenger_name not in environ['tiddlyweb.config']['auth_systems']:
        raise HTTP404('Challenger Not Found')
    try:
        return _get_challenger_module(challenger_name)
    except ImportError as exc:
        raise HTTP404('Unable to import challenger %s: %s' %
                (challenger_name, exc))


def _get_challenger_module(challenger_name):
    """
    Return given challenger's module, importing it as necessary.
    """
    try:
        imported_module = __import__('tiddlyweb.web.challengers.%s' %
                challenger_name, {}, {}, ['Challenger'])
    except ImportError:
        imported_module = __import__(challenger_name, {}, {}, ['Challenger'])
    return imported_module.Challenger()

########NEW FILE########
__FILENAME__ = cookie_form
"""
A :py:class:`challenger <tiddlyweb.web.challengers.ChallengerInterface>`
that presents or validates a form for getting a username and password.
"""

import logging

from tiddlyweb.web.challengers import ChallengerInterface
from tiddlyweb.web.util import server_host_url, make_cookie, html_frame
from tiddlyweb.model.user import User
from tiddlyweb.store import NoUserError


LOGGER = logging.getLogger(__name__)


class Challenger(ChallengerInterface):
    """
    A simple login challenger that asks the user agent, via an HTML form,
    for a username and password and vaidates it against a :py:class:`User
    entity <tiddlyweb.model.user.User>` in the :py:class:`store
    <tiddlyweb.store.Store>`.

    If valid, a cookie is set in the response. This is used in subsequent
    requests by the :py:mod:`simple_cookie
    <tiddlyweb.web.extractors.simple_cookie>` :py:class:`credentials
    extractor <tiddlyweb.web.extractors.ExtractorInterface>`.
    """

    desc = "TiddlyWeb username and password"

    def challenge_get(self, environ, start_response):
        """
        Respond to a ``GET`` request by sending a form.
        """
        redirect = (environ['tiddlyweb.query'].
                get('tiddlyweb_redirect', ['/'])[0])
        return self._send_cookie_form(environ, start_response, redirect)

    def challenge_post(self, environ, start_response):
        """
        Respond to a ``POST`` by processing data sent from a form.
        The form should include a username and password. If it
        does not, send the form aagain. If it does, validate
        the data.
        """
        query = environ['tiddlyweb.query']
        redirect = query.get('tiddlyweb_redirect', ['/'])[0]

        try:
            user = query['user'][0]
            password = query['password'][0]
            return self._validate_and_redirect(environ, start_response,
                    user, password, redirect)
        except KeyError:
            return self._send_cookie_form(environ, start_response,
                    redirect, message='missing input')

    def _send_cookie_form(self, environ, start_response, redirect,
            status='401 Unauthorized', message=''):
        """
        Send a simple form to the client asking for a username
        and password.
        """
        start_response(status, [('Content-Type', 'text/html')])
        title = 'Cookie Based Login'
        header, footer = html_frame(environ, title)
        return [header, """
<p>%s</p>

<form action="" method="POST">
    <label>
        User:
        <input name="user" />
    </label>
    <label>
        Password:
        <input type="password" name="password" />
    </label>
    <input type="hidden" name="tiddlyweb_redirect" value="%s" />
    <input type="submit" value="submit" />
</form>
""" % (message, redirect), footer]

    def _validate_and_redirect(self, environ, start_response, username,
            password, redirect):
        """
        Check a username and password. If valid, send a cookie
        to the client. If it is not, send the form again.
        """
        status = '401 Unauthorized'
        try:
            store = environ['tiddlyweb.store']
            secret = environ['tiddlyweb.config']['secret']
            cookie_age = environ['tiddlyweb.config'].get('cookie_age', None)
            user = User(username)
            user = store.get(user)
            if user.check_password(password):
                uri = '%s%s' % (server_host_url(environ), redirect)
                cookie_header_string = make_cookie('tiddlyweb_user',
                        user.usersign, mac_key=secret,
                        path=self._cookie_path(environ), expires=cookie_age)
                LOGGER.debug('303 to %s', uri)
                start_response('303 See Other',
                        [('Set-Cookie', cookie_header_string),
                            ('Content-Type', 'text/plain'),
                            ('Location', str(uri))])
                return [uri]
        except KeyError:
            pass
        except NoUserError:
            pass
        return self._send_cookie_form(environ, start_response, redirect,
                status, 'User or Password no good')

########NEW FILE########
__FILENAME__ = extractor
"""
Extract of user credentials from incoming web requests.
:py:class:`UserExtract` passes to a stack of extractors. If an
:py:class:`extractor <tiddlyweb.web.extractors.ExtractorInterface>`
returns something other than ``None``, we have found
valid data with which to set ``tiddlyweb.usersign``.
"""
import logging


LOGGER = logging.getLogger(__name__)


class UserExtract(object):
    """
    WSGI Middleware to set the ``tiddlyweb.usersign``, if it can
    be found in the request.
    """

    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):
        userinfo = {"name": u'GUEST', "roles": []}

        extractors = environ['tiddlyweb.config']['extractors']
        candidate_userinfo = _try_extractors(environ,
                extractors, start_response)

        if candidate_userinfo:
            userinfo = candidate_userinfo
        environ['tiddlyweb.usersign'] = userinfo

        return self.application(environ, start_response)


def _try_extractors(environ, extractors, start_response):
    """
    Loop through the available extractors until
    one returns a usersign instead of None, or we
    run out of extractors.
    """
    for extractor_name in extractors:
        try:
            imported_module = __import__('tiddlyweb.web.extractors.%s' %
                    extractor_name, {}, {}, ['Extractor'])
        except ImportError:
            try:
                imported_module = __import__(extractor_name, {}, {},
                        ['Extractor'])
            except ImportError as exc:
                raise ImportError('could not load extractor %s: %s' %
                        (extractor_name, exc))
        extractor = imported_module.Extractor()
        extracted_user = extractor.extract(environ, start_response)
        if extracted_user:
            LOGGER.debug('UserExtract:%s found %s',
                    extractor_name, extracted_user)
            return extracted_user
    return False

########NEW FILE########
__FILENAME__ = http_basic
"""
A very simple :py:class:`extractor
<tiddlyweb.web.extractors.ExtractorInterface>` that looks at the
HTTP ``Authorization`` header and looks for Basic auth information
therein.
"""

from base64 import b64decode

from tiddlyweb.web.extractors import ExtractorInterface


class Extractor(ExtractorInterface):
    """
    An :py:class:`extractor <tiddlyweb.web.extractors.ExtractorInterface>`
    for HTTP Basic Authentication. If there is an `Authorization` header
    attempt to get a username and password out of it and compare with
    :py:class:`User <tiddlyweb.model.user.User>` information in the
    :py:class:`Store <tiddlyweb.store.Store>`. If the password is valid,
    return the user information. Otherwise return ``False``.
    """

    def extract(self, environ, start_response):
        """
        Look in the request for an ``Authorization`` header.
        """
        user_info = environ.get('HTTP_AUTHORIZATION', None)
        if user_info is None:
            return False
        if user_info.startswith('Basic'):
            user_info = user_info.strip().split(' ')[1]
            decoded = b64decode(user_info.encode('utf-8')).decode('utf-8')
            candidate_username, password = decoded.split(':')
            user = self.load_user(environ, candidate_username)
            if user.check_password(password):
                return {"name": user.usersign, "roles": user.list_roles()}
        return False

########NEW FILE########
__FILENAME__ = simple_cookie
"""
An :py:class:`extractor <tiddlyweb.web.extractors.ExtractorInterface>`
that looks at a cookie named ``tiddlyweb_user``.
"""


import logging

from httpexceptor import HTTP400

from tiddlyweb.web.extractors import ExtractorInterface
from tiddlyweb.util import sha

from tiddlyweb.fixups import SimpleCookie, CookieError, unquote

LOGGER = logging.getLogger(__name__)


class Extractor(ExtractorInterface):
    """
    Look in the headers for a cookie named ``tiddlyweb_user``.

    If it is there and the associated hashed value validates against
    a server side secret, return the indicated user.
    """

    def extract(self, environ, start_response):
        """
        Extract the cookie, if there, from the headers
        and attempt to validate its contents.
        """
        try:
            user_cookie = environ['HTTP_COOKIE']
            LOGGER.debug('simple_cookie looking at cookie string: %s',
                    user_cookie)
            cookie = SimpleCookie()
            cookie.load(str(user_cookie))
            cookie_value = cookie['tiddlyweb_user'].value
            secret = environ['tiddlyweb.config']['secret']
            usersign, cookie_secret = cookie_value.rsplit(':', 1)

            if cookie_secret == sha('%s%s' % (usersign, secret)).hexdigest():
                usersign = unquote(usersign)
                user = self.load_user(environ, usersign)
                return {"name": user.usersign, "roles": user.list_roles()}
        except CookieError as exc:
            raise HTTP400('malformed cookie: %s' % exc)
        except (KeyError, ValueError):
            pass
        return False

########NEW FILE########
__FILENAME__ = bag
"""
Methods for accessing :py:class:`Bag <tiddlyweb.model.bag.Bag>` entities.
"""

from httpexceptor import HTTP400, HTTP404, HTTP409, HTTP415

from tiddlyweb.model.bag import Bag
from tiddlyweb.model.collections import Tiddlers
from tiddlyweb.model.policy import create_policy_check
from tiddlyweb.store import NoBagError, StoreMethodNotImplemented
from tiddlyweb.serializer import (Serializer, NoSerializationError,
        BagFormatError)
from tiddlyweb.web import util as web
from tiddlyweb.web.sendentity import send_entity
from tiddlyweb.web.sendtiddlers import send_tiddlers
from tiddlyweb.web.listentities import list_entities
from tiddlyweb.web.validator import validate_bag, InvalidBagError


def delete(environ, start_response):
    """
    Handle ``DELETE`` on a single bag URI.

    Remove the :py:class:`bag <tiddlyweb.model.bag.Bag>` and the
    :py:class:`tiddlers <tiddlyweb.model.tiddler.Tiddler>` within
    from the :py:class:`store <tiddlyweb.store.Store>`.

    How the store chooses to handle remove and what it means is
    up to the store.
    """
    bag_name = web.get_route_value(environ, 'bag_name')
    bag_name = web.handle_extension(environ, bag_name)

    usersign = environ['tiddlyweb.usersign']

    bag = _get_bag(environ, bag_name)
    bag.policy.allows(usersign, 'manage')
    # reuse the store attribute that was set on the
    # bag when we "got" it.
    # we don't need to check for existence here because
    # the above get already did
    try:
        store = environ['tiddlyweb.store']
        store.delete(bag)
    except StoreMethodNotImplemented:
        raise HTTP400('Bag DELETE not supported')

    start_response("204 No Content", [])
    return []


def get(environ, start_response):
    """
    Handle ``GET`` on a single bag URI.

    Get a representation in some serialization determined by
    :py:mod:`tiddlyweb.web.negotiate` of a :py:class:`bag
    <tiddlyweb.model.bag.Bag>` (the bag itself, not the tiddlers within).
    """
    bag_name = web.get_route_value(environ, 'bag_name')
    bag_name = web.handle_extension(environ, bag_name)
    bag = _get_bag(environ, bag_name)

    bag.policy.allows(environ['tiddlyweb.usersign'], 'manage')

    return send_entity(environ, start_response, bag)


def get_tiddlers(environ, start_response):
    """
    Handle ``GET`` on a tiddlers-within-a-bag URI.

    Get a list representation of the :py:class:`tiddlers
    <tiddlyweb.model.tiddler.Tiddler>` in a :py:class:`bag
    <tiddlyweb.model.bag.Bag>`.

    The information sent is dependent on the serialization chosen
    via :py:mod:`tiddlyweb.web.negotiate`.
    """
    store = environ['tiddlyweb.store']
    filters = environ['tiddlyweb.filters']
    bag_name = web.get_route_value(environ, 'bag_name')
    bag = _get_bag(environ, bag_name)
    title = 'Tiddlers From Bag %s' % bag.name
    title = environ['tiddlyweb.query'].get('title', [title])[0]

    usersign = environ['tiddlyweb.usersign']
    # will raise exception if there are problems
    bag.policy.allows(usersign, 'read')

    tiddlers = Tiddlers(title=title)
    if not filters:
        tiddlers.store = store
    tiddlers.bag = bag_name

    # A special bag can raise NoBagError here.
    try:
        for tiddler in store.list_bag_tiddlers(bag):
            tiddlers.add(tiddler)
    except NoBagError as exc:
        raise HTTP404('%s not found, %s' % (bag.name, exc))

    tiddlers.link = '%s/tiddlers' % web.bag_url(environ, bag, full=False)

    return send_tiddlers(environ, start_response, tiddlers=tiddlers)


def list_bags(environ, start_response):
    """
    Handle ``GET`` on the bags URI.

    List all the :py:class:`bags <tiddlyweb.model.bag.Bag>` that are
    readable by the current usersign.

    The information sent is dependent on the serialization chosen
    via :py:mod:`tiddlyweb.web.negotiate`.
    """
    return list_entities(environ, start_response, 'list_bags')


def put(environ, start_response):
    """
    Handle ``PUT`` on a single bag URI.

    Put a :py:class:`bag <tiddlyweb.model.bag.Bag>` to the server,
    meaning the description and policy of the bag, if :py:class:`policy
    <tiddlyweb.model.policy.Policy>` allows.
    """
    bag_name = web.get_route_value(environ, 'bag_name')
    bag_name = web.handle_extension(environ, bag_name)

    bag = Bag(bag_name)
    store = environ['tiddlyweb.store']
    length, _ = web.content_length_and_type(environ)

    usersign = environ['tiddlyweb.usersign']

    try:
        bag = store.get(bag)
        bag.policy.allows(usersign, 'manage')
    except NoBagError:
        create_policy_check(environ, 'bag', usersign)

    try:
        serialize_type = web.get_serialize_type(environ)[0]
        serializer = Serializer(serialize_type, environ)
        serializer.object = bag
        content = web.read_request_body(environ, length)
        serializer.from_string(content.decode('utf-8'))

        bag.policy.owner = usersign['name']

        _validate_bag(environ, bag)
        store.put(bag)
    except BagFormatError as exc:
        raise HTTP400('unable to put bag: %s' % exc)
    except TypeError:
        raise HTTP400('Content-type header required')
    except NoSerializationError:
        raise HTTP415('Content type not supported: %s' % serialize_type)

    start_response("204 No Content",
            [('Location', web.bag_url(environ, bag))])

    return []


def _validate_bag(environ, bag):
    """
    Unless bag is valid raise a `409` with the reason why.
    """
    try:
        validate_bag(bag, environ)
    except InvalidBagError as exc:
        raise HTTP409('Bag content is invalid: %s' % exc)


def _get_bag(environ, bag_name):
    """
    Get the named bag out of the store.
    """
    store = environ['tiddlyweb.store']
    bag = Bag(bag_name)
    try:
        bag = store.get(bag)
    except NoBagError as exc:
        raise HTTP404('%s not found, %s' % (bag.name, exc))
    return bag

########NEW FILE########
__FILENAME__ = chronicle
"""
A chronicle is a stack of :py:class:`tiddlers
<tiddlyweb.model.tiddler.Tiddler>`, usually revisions of
one tiddler. By POSTing a chronicle of tiddlers originally
named A to tiddler B, it is possible to rename a tiddler
while preserving revision history.
"""

import simplejson

from httpexceptor import HTTP400, HTTP409, HTTP412, HTTP415

from tiddlyweb.model.bag import Bag
from tiddlyweb.model.tiddler import Tiddler
from tiddlyweb.serializer import Serializer
from tiddlyweb.store import NoTiddlerError
from tiddlyweb.web.util import (get_route_value, content_length_and_type,
        tiddler_url, check_bag_constraint)
from tiddlyweb.web.handler.tiddler import validate_tiddler_headers


CHRONICLE_TYPES = ['application/json', 'application/vnd.tiddlyweb+json']


def post_revisions(environ, start_response):
    """
    Handle a ``POST`` of a chronicle of :py:class:`tiddlers
    <tiddlyweb.model.tiddler.Tiddler>` at a tiddler revisions
    URI.

    Take a collection of ``JSON`` tiddlers, each with a
    text key and value, and process them into the store.
    """
    tiddler_name = get_route_value(environ, 'tiddler_name')
    bag_name = get_route_value(environ, 'bag_name')
    tiddler = Tiddler(tiddler_name, bag_name)
    return _post_tiddler_revisions(environ, start_response, tiddler)


def _post_tiddler_revisions(environ, start_response, tiddler):
    """
    We have a list of revisions, put them in a new place.
    """
    length, content_type = content_length_and_type(environ)

    if content_type not in CHRONICLE_TYPES:
        raise HTTP415('application/vnd.tiddlyweb+json required')

    # we need a matching etag in order to be able to do
    # this operation. This will raise exception if there
    # isn't a valid etag.
    _require_valid_etag_for_write(environ, tiddler)

    bag = Bag(tiddler.bag)
    #  both create and write required for this action
    check_bag_constraint(environ, bag, 'create')
    check_bag_constraint(environ, bag, 'write')

    content = environ['wsgi.input'].read(int(length))

    _store_tiddler_revisions(environ, content, tiddler)

    response = [('Location', tiddler_url(environ, tiddler))]
    start_response("204 No Content", response)

    return []


def _require_valid_etag_for_write(environ, tiddler):
    """
    Unless there is an Etag and it is valid
    we send a ``412``.
    """
    incoming_etag = environ.get('HTTP_IF_MATCH', None)
    if not incoming_etag:
        raise HTTP412('If Match header required to update tiddlers.')
    tiddler_copy = Tiddler(tiddler.title, tiddler.bag)
    try:
        tiddler_copy = environ['tiddlyweb.store'].get(tiddler_copy)
    except NoTiddlerError:
        tiddler_copy.revision = None
    return validate_tiddler_headers(environ, tiddler_copy)


def _store_tiddler_revisions(environ, content, tiddler):
    """
    Given JSON revisions in content, store them
    as a revision history to tiddler.
    """
    try:
        json_tiddlers = simplejson.loads(content)
    except ValueError as exc:
        raise HTTP409('unable to handle json: %s' % exc)

    store = environ['tiddlyweb.store']
    serializer = Serializer('json', environ)
    serializer.object = tiddler
    try:
        for json_tiddler in reversed(json_tiddlers):
            json_string = simplejson.dumps(json_tiddler)
            serializer.from_string(json_string)
            store.put(tiddler)
    except NoTiddlerError as exc:
        raise HTTP400('Unable to store tiddler revisions: %s', exc)

########NEW FILE########
__FILENAME__ = recipe
"""
Methods for accessing :py:class:`Recipe
<tiddlyweb.model.recipe.Recipe>` entities.
"""

from httpexceptor import HTTP400, HTTP409, HTTP415, HTTP404

from tiddlyweb.filters import FilterError
from tiddlyweb.model.collections import Tiddlers
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.model.policy import create_policy_check
from tiddlyweb.store import (NoRecipeError, NoBagError,
        StoreMethodNotImplemented)
from tiddlyweb.serializer import (Serializer, NoSerializationError,
        RecipeFormatError)
from tiddlyweb.web.sendentity import send_entity
from tiddlyweb.web.sendtiddlers import send_tiddlers
from tiddlyweb.web.listentities import list_entities
from tiddlyweb import control
from tiddlyweb.web import util as web
from tiddlyweb.web.validator import validate_recipe, InvalidBagError


def delete(environ, start_response):
    """
    Handle ``DELETE`` on a single recipe URI.

    Delete a :py:class:`recipe <tiddlyweb.model.recipe.Recipe>`.
    This just removes the recipe, not any associated :py:class:`bags
    <tiddlyweb.model.bag.Bag>` or :py:class:`tiddlers
    <tiddlyweb.model.tiddler.Tiddler>`.
    """
    recipe = _determine_recipe(environ)
    store = environ['tiddlyweb.store']

    recipe.policy.allows(environ['tiddlyweb.usersign'], 'manage')

    try:
        store.delete(recipe)
    except StoreMethodNotImplemented:
        raise HTTP400('Recipe DELETE not supported')

    start_response("204 No Content", [])
    return []


def get(environ, start_response):
    """
    Handle ``GET`` on a single recipe URI.

    Get a representation in some serialization determined by
    :py:mod:`tiddlyweb.web.negotiate` of a :py:class:`recipe
    <tiddlyweb.model.recipe.Recipe>` (just the recipe itself,
    not the tiddlers it can produce).
    """
    recipe = _determine_recipe(environ)
    recipe.policy.allows(environ['tiddlyweb.usersign'], 'read')
    return send_entity(environ, start_response, recipe)


def get_tiddlers(environ, start_response):
    """
    Handle ``GET`` on a tiddlers-within-a-recipe URI.

    Get a list representation of the :py:class:`tiddlers
    <tiddlyweb.model.tiddler.Tiddler>` generated from a :py:class:`recipe
    <tiddlyweb.model.recipe.Recipe>`.

    The information sent is dependent on the serialization chosen
    via :py:mod:`tiddlyweb.web.negotiate`.
    """
    usersign = environ['tiddlyweb.usersign']
    store = environ['tiddlyweb.store']
    filters = environ['tiddlyweb.filters']
    recipe = _determine_recipe(environ)
    title = 'Tiddlers From Recipe %s' % recipe.name
    title = environ['tiddlyweb.query'].get('title', [title])[0]

    # check the recipe can be read
    recipe.policy.allows(usersign, 'read')

    # check the bags in the recipe can be read
    try:
        template = control.recipe_template(environ)
        for bag_name, _ in recipe.get_recipe(template):
            bag = Bag(bag_name)
            bag = store.get(bag)
            bag.policy.allows(usersign, 'read')
    except NoBagError as exc:
        raise HTTP404('recipe %s lists an unknown bag: %s' %
                (recipe.name, exc))

    # from this point forward we know the tiddlers are
    # readable

    # get the tiddlers from the recipe and uniquify them
    try:
        candidate_tiddlers = control.get_tiddlers_from_recipe(recipe, environ)
    except NoBagError as exc:
        raise HTTP404('recipe %s lists an unknown bag: %s' %
                (recipe.name, exc))
    except FilterError as exc:
        raise HTTP400('malformed filter: %s' % exc)

    tiddlers = Tiddlers(title=title)
    if not filters:
        tiddlers.store = store
    tiddlers.recipe = recipe.name

    for tiddler in candidate_tiddlers:
        tiddler.recipe = recipe.name
        tiddlers.add(tiddler)

    tiddlers.link = '%s/tiddlers' % web.recipe_url(environ, recipe,
            full=False)

    return send_tiddlers(environ, start_response, tiddlers=tiddlers)


def list_recipes(environ, start_response):
    """
    Handle ``GET`` on the recipes URI.

    List all the :py:class:`recipes <tiddlyweb.model.recipe.Recipe>` that are
    readable by the current usersign.

    The information sent is dependent on the serialization chosen
    via :py:mod:`tiddlyweb.web.negotiate`.
    """
    return list_entities(environ, start_response, 'list_recipes')


def put(environ, start_response):
    """
    Handle ``PUT`` on a single recipe URI.

    Put a :py:class:`recipe <tiddlyweb.model.recipe.Recipe>` to the server,
    meaning the description, policy and recipe list of the recipe,
    if :py:class:`policy <tiddlyweb.model.policy.Policy>` allows.
    """
    recipe_name = web.get_route_value(environ, 'recipe_name')
    recipe_name = web.handle_extension(environ, recipe_name)

    recipe = Recipe(recipe_name)
    store = environ['tiddlyweb.store']
    length, _ = web.content_length_and_type(environ)

    usersign = environ['tiddlyweb.usersign']

    try:
        recipe = store.get(recipe)
        recipe.policy.allows(usersign, 'manage')
    except NoRecipeError:
        create_policy_check(environ, 'recipe', usersign)

    try:
        serialize_type = web.get_serialize_type(environ)[0]
    except TypeError:
        raise HTTP400('Content-type header required')

    try:
        serializer = Serializer(serialize_type, environ)
        serializer.object = recipe
        content = web.read_request_body(environ, length)
        serializer.from_string(content.decode('utf-8'))

        recipe.policy.owner = usersign['name']

        _validate_recipe(environ, recipe)
        store.put(recipe)
    except RecipeFormatError as exc:
        raise HTTP400('unable to put recipe: %s' % exc)
    except TypeError as exc:
        raise HTTP400('malformed input: %s' % exc)
    except NoSerializationError:
        raise HTTP415('Content type %s not supported' % serialize_type)

    start_response("204 No Content",
            [('Location', web.recipe_url(environ, recipe))])

    return []


def _validate_recipe(environ, recipe):
    """
    Unless recipe is valid raise a ``409`` with the reason why.
    """
    try:
        validate_recipe(recipe, environ)
    except InvalidBagError as exc:
        raise HTTP409('Recipe content is invalid: %s' % exc)


def _determine_recipe(environ):
    """
    Interpret URL information to determine the target
    recipe and then get it from the store.
    """
    recipe_name = web.get_route_value(environ, 'recipe_name')
    recipe_name = web.handle_extension(environ, recipe_name)
    recipe = Recipe(recipe_name)

    store = environ['tiddlyweb.store']

    try:
        recipe = store.get(recipe)
    except NoRecipeError as exc:
        raise HTTP404('%s not found, %s' % (recipe.name, exc))

    return recipe

########NEW FILE########
__FILENAME__ = search
"""
Handle searches for :py:class:`tiddlers <tiddlyweb.model.tiddler.Tiddler>`
if the configured :py:class:`store <tiddlyweb.stores.StorageInterface>`
supports search.
"""

import logging

from httpexceptor import HTTP400

from tiddlyweb.control import readable_tiddlers_by_bag
from tiddlyweb.model.collections import Tiddlers
from tiddlyweb.store import StoreMethodNotImplemented, StoreError
from tiddlyweb.web.sendtiddlers import send_tiddlers


LOGGER = logging.getLogger(__name__)


def get_search_query(environ):
    """
    Inspect :py:mod:`tiddlyweb.query <tiddlyweb.web.query>` in the
    environment to find the search query in a parameter named ``q``.
    """
    try:
        search_query = environ['tiddlyweb.query']['q'][0]
    except (KeyError, IndexError):
        raise HTTP400('query string required')
    return search_query


def get_tiddlers(environ):
    """
    Call search in the :py:class:`store <tiddlyweb.store.Store>`
    to get the generator of :py:class:`tiddlers
    <tiddlyweb.model.tiddler.Tiddler>` matching the query found
    by :py:func:`get_search_query`.
    """
    search_query = get_search_query(environ)
    store = environ['tiddlyweb.store']
    tiddlers = store.search(search_query)
    LOGGER.debug('got search results from store')
    return tiddlers


def get(environ, start_response):
    """
    Handle ``GET`` on the search URI.

    Perform a search against the :py:class:`store <tiddlyweb.store.Store>`.

    What search means and what results are returned is dependent
    on the search implementation (if any) in the :py:class:`chosen store
    <tiddlyweb.stores.StorageInterface>`.
    """
    store = environ['tiddlyweb.store']
    filters = environ['tiddlyweb.filters']
    search_query = get_search_query(environ)
    title = 'Search for %s' % search_query
    title = environ['tiddlyweb.query'].get('title', [title])[0]

    try:
        tiddlers = get_tiddlers(environ)

        usersign = environ['tiddlyweb.usersign']

        if filters:
            candidate_tiddlers = Tiddlers(title=title)
        else:
            candidate_tiddlers = Tiddlers(title=title, store=store)
        candidate_tiddlers.is_search = True

        for tiddler in readable_tiddlers_by_bag(store, tiddlers, usersign):
            candidate_tiddlers.add(tiddler)

    except StoreMethodNotImplemented:
        raise HTTP400('Search system not implemented')
    except StoreError as exc:
        raise HTTP400('Error while processing search: %s' % exc)

    return send_tiddlers(environ, start_response, tiddlers=candidate_tiddlers)

########NEW FILE########
__FILENAME__ = tiddler
"""
Methods for accessing :py:class:`Tiddler <tiddlyweb.model.tiddler.Tiddler>`
entities.
"""

import logging

from httpexceptor import (HTTP404, HTTP415, HTTP412, HTTP409,
        HTTP400, HTTP302)

from tiddlyweb.model.collections import Tiddlers
from tiddlyweb.model.bag import Bag
from tiddlyweb.model.policy import PermissionsError
from tiddlyweb.model.recipe import Recipe
from tiddlyweb.model.tiddler import Tiddler, current_timestring
from tiddlyweb.store import (NoTiddlerError, NoBagError, NoRecipeError,
        StoreMethodNotImplemented)
from tiddlyweb.serializer import (Serializer, TiddlerFormatError,
        NoSerializationError)
from tiddlyweb.util import pseudo_binary, renderable
from tiddlyweb import control
from tiddlyweb.web.util import (check_bag_constraint, get_route_value,
        handle_extension, content_length_and_type, read_request_body,
        get_serialize_type, tiddler_etag, tiddler_url, encode_name,
        http_date_from_timestamp, check_last_modified, check_incoming_etag)
from tiddlyweb.web.sendtiddlers import send_tiddlers
from tiddlyweb.web.validator import validate_tiddler, InvalidTiddlerError

from tiddlyweb.fixups import basestring, bytes


CACHE_CONTROL_FIELD = '_cache-max-age'
CANONICAL_URI_FIELD = '_canonical_uri'
CANONICAL_URI_PASS_TYPE = 'application/json'


LOGGER = logging.getLogger(__name__)


def get(environ, start_response):
    """
    Handle ``GET`` on a single tiddler or tiddler revision URI.

    Get a representation in some serialization determined by
    :py:mod:`tiddlyweb.web.negotiate` of a :py:class:`tiddler
    <tiddlyweb.model.tiddler.Tiddler>`.
    """
    tiddler = _determine_tiddler(environ,
            control.determine_bag_from_recipe)
    return _send_tiddler(environ, start_response, tiddler)


def get_revisions(environ, start_response):
    """
    Handle ``GET`` on the collection of revisions of single tiddler URI.

    Get a list representation in some serialization determined by
    :py:mod:`tiddlyweb.web.negotiate` of the revisions of a :py:class:`tiddler
    <tiddlyweb.model.tiddler.Tiddler>`.
    """
    tiddler = _determine_tiddler(environ,
            control.determine_bag_from_recipe,
            revisions=True)
    return _send_tiddler_revisions(environ, start_response, tiddler)


def delete(environ, start_response):
    """
    Handle ``DELETE`` on a single tiddler URI.

    Delete a :py:class:`tiddler <tiddlyweb.model.tiddler.Tiddler>` from
    the :py:class:`store <tiddlyweb.store.Store>`.

    What delete means is up to the store.
    """
    tiddler = _determine_tiddler(environ,
            control.determine_bag_from_recipe)
    return _delete_tiddler(environ, start_response, tiddler)


def put(environ, start_response):
    """
    Handle ``PUT`` on a single tiddler URI.

    Put a :py:class:`tiddler <tiddlyweb.model.tiddler.Tiddler>` to
    the server.
    """
    tiddler = _determine_tiddler(environ,
            control.determine_bag_for_tiddler)
    return _put_tiddler(environ, start_response, tiddler)


def _base_tiddler_object(environ, tiddler_name, revisions):
    """
    Create a tiddler object, without bag or recipe, based on
    URI values.

    ``revisions`` is true when the request is for a revisions
    collection. When true, extension handling is not done on
    the tiddler_name.
    """
    if not revisions:
        try:
            revision = get_route_value(environ, 'revision')
            revision = handle_extension(environ, revision)
        except KeyError:
            tiddler_name = handle_extension(environ, tiddler_name)
            revision = None
    else:
        revision = None

    tiddler = Tiddler(tiddler_name)
    tiddler.revision = revision  # reset to default None if HEAD
    return tiddler


def _delete_tiddler(environ, start_response, tiddler):
    """
    The guts of deleting a tiddler from the store.
    """
    store = environ['tiddlyweb.store']

    try:
        tiddler = store.get(tiddler)
        validate_tiddler_headers(environ, tiddler)

        bag = Bag(tiddler.bag)
        # this will raise 403 if constraint does not pass
        check_bag_constraint(environ, bag, 'delete')

        store.delete(tiddler)
    except NoTiddlerError as exc:
        raise HTTP404('%s not found, %s' % (tiddler.title, exc))

    start_response("204 No Content", [])
    return []


def _determine_tiddler(environ, bag_finder, revisions=False):
    """
    Determine, using URL info, the target tiddler.
    This can be complicated because of the mechanics
    of recipes and bags.

    Set revisions to True when the current request ends in
    ``/revisions`` or ``/revisions.*``. Doing so ensures that
    processing of extensions does not impact the name of
    the tiddler.
    """
    tiddler_name = get_route_value(environ, 'tiddler_name')
    tiddler = _base_tiddler_object(environ, tiddler_name, revisions)

    # We have to deserialize the tiddler here so that
    # PUTs to recipes are aware of values like tags when
    # doing filter checks.
    if environ['REQUEST_METHOD'] == 'PUT':
        _process_request_body(environ, tiddler)

    try:
        recipe_name = get_route_value(environ, 'recipe_name')
        recipe = Recipe(recipe_name)
        try:
            store = environ['tiddlyweb.store']
            recipe = store.get(recipe)
            tiddler.recipe = recipe_name
        except NoRecipeError as exc:
            raise HTTP404('%s not found via recipe, %s' % (tiddler.title, exc))

        try:
            bag = bag_finder(recipe, tiddler, environ)
        except NoBagError as exc:
            raise HTTP404('%s not found via bag, %s' % (tiddler.title, exc))

        bag_name = bag.name
    except KeyError:
        bag_name = get_route_value(environ, 'bag_name')

    tiddler.bag = bag_name
    return tiddler


def _process_request_body(environ, tiddler):
    """
    Read request body to set tiddler content.

    If a serializer exists for the content type, use it,
    otherwise treat the content as binary or pseudo-binary
    tiddler.
    """
    length, content_type = content_length_and_type(environ)
    content = read_request_body(environ, length)

    try:
        try:
            serialize_type = get_serialize_type(environ)[0]
            serializer = Serializer(serialize_type, environ)
            # Short circuit de-serialization attempt to avoid
            # decoding content multiple times.
            if hasattr(serializer.serialization, 'as_tiddler'):
                serializer.object = tiddler
                try:
                    serializer.from_string(content.decode('utf-8'))
                except TiddlerFormatError as exc:
                    raise HTTP400('unable to put tiddler: %s' % exc)
            else:
                raise NoSerializationError()
        except NoSerializationError:
            tiddler.type = content_type
            if pseudo_binary(tiddler.type):
                tiddler.text = content.decode('utf-8')
            else:
                tiddler.text = content
    except UnicodeDecodeError as exc:
        raise HTTP400('unable to decode tiddler, utf-8 expected: %s', exc)


def _check_and_validate_tiddler(environ, bag, tiddler):
    """
    If the tiddler does not exist, check we have create
    in the bag. If the tiddler does exist, check we
    have edit. In either case, check ETag to be sure
    that if it is set, that it maches what is currently
    in the store.
    """
    store = environ['tiddlyweb.store']
    try:
        try:
            revision = store.list_tiddler_revisions(tiddler)[0]
        except StoreMethodNotImplemented:
            # If list_tiddler_revisions is not implemented
            # we still need to check if the tiddler exists.
            # If it doesn't NoTiddlerError gets raised and
            # the except block below is run.
            test_tiddler = Tiddler(tiddler.title, tiddler.bag)
            store.get(test_tiddler)
            revision = 1
        tiddler.revision = revision
        # These both next will raise exceptions if
        # the contraints don't match.
        check_bag_constraint(environ, bag, 'write')
        validate_tiddler_headers(environ, tiddler)
    except NoTiddlerError:
        check_bag_constraint(environ, bag, 'create')
        tiddler.revision = None
        incoming_etag = environ.get('HTTP_IF_MATCH', None)
        if incoming_etag and not (
                incoming_etag == _new_tiddler_etag(tiddler)):
            raise HTTP412('ETag incorrect for new tiddler')


def _put_tiddler(environ, start_response, tiddler):
    """
    The guts of putting a tiddler into the store.

    There's a fair bit of special handling done here
    depending on whether the tiddler already exists or
    not.
    """
    store = environ['tiddlyweb.store']

    try:
        bag = Bag(tiddler.bag)
        _check_and_validate_tiddler(environ, bag, tiddler)

        user = environ['tiddlyweb.usersign']['name']
        tiddler.modifier = user
        tiddler.modified = current_timestring()

        try:
            check_bag_constraint(environ, bag, 'accept')
        except (PermissionsError) as exc:
            _validate_tiddler_content(environ, tiddler)

        store.put(tiddler)
    except NoBagError as exc:
        raise HTTP409("Unable to put tiddler, %s. There is no bag named: "
                "%s (%s). Create the bag." %
                (tiddler.title, tiddler.bag, exc))
    except NoTiddlerError as exc:
        raise HTTP404('Unable to put tiddler, %s. %s' % (tiddler.title, exc))
    except TypeError as exc:
        raise HTTP409('Unable to put badly formed tiddler, %s:%s. %s'
                % (tiddler.bag, tiddler.title, exc))

    etag = ('ETag', tiddler_etag(environ, tiddler))
    response = [('Location', tiddler_url(environ, tiddler))]
    if etag:
        response.append(etag)
    start_response("204 No Content", response)

    return []


def _validate_tiddler_content(environ, tiddler):
    """
    Unless tiddler is valid raise a 409 with the reason why
    things to check are presumably tags and title, but we don't
    want to worry about that here, we want to dispatch elsewhere.
    """
    try:
        validate_tiddler(tiddler, environ)
    except InvalidTiddlerError as exc:
        raise HTTP409('Tiddler content is invalid: %s' % exc)


def validate_tiddler_headers(environ, tiddler):
    """
    Check ETag and last modified header information to
    see if a) on ``GET`` the user agent can use its cached tiddler
    b) on ``PUT`` we have edit contention.
    """
    request_method = environ['REQUEST_METHOD']
    this_tiddlers_etag = tiddler_etag(environ, tiddler)

    LOGGER.debug('attempting to validate %s with revision %s',
            tiddler.title, tiddler.revision)

    etag = None
    last_modified = None
    if request_method == 'GET':
        last_modified_string = http_date_from_timestamp(tiddler.modified)
        last_modified = ('Last-Modified', last_modified_string)
        cache_header = 'no-cache'
        if CACHE_CONTROL_FIELD in tiddler.fields:
            try:
                cache_header = 'max-age=%s' % int(
                        tiddler.fields[CACHE_CONTROL_FIELD])
            except ValueError:
                pass  # if the value is not an int use default header
        incoming_etag = check_incoming_etag(environ, this_tiddlers_etag,
                last_modified=last_modified_string,
                cache_control=cache_header)
        if not incoming_etag:  # only check last-modified if no etag
            check_last_modified(environ, last_modified_string,
                    etag=this_tiddlers_etag,
                    cache_control=cache_header)

    else:
        incoming_etag = environ.get('HTTP_IF_MATCH', None)
        LOGGER.debug('attempting to validate incoming etag(PUT):'
            '%s against %s', incoming_etag, this_tiddlers_etag)
        if incoming_etag and not _etag_write_match(incoming_etag,
                this_tiddlers_etag):
            raise HTTP412('Provided ETag does not match. '
                'Server content probably newer.')
    etag = ('ETag', '%s' % this_tiddlers_etag)
    return last_modified, etag


def _etag_write_match(incoming_etag, server_etag):
    """
    Compare two tiddler etags for a satisfactory match
    for a ``PUT`` or ``DELETE``. This means comparing without the
    content type that _may_ be on the end.
    """
    incoming_etag = incoming_etag.split(':', 1)[0].strip('"')
    server_etag = server_etag.split(':', 1)[0].strip('"')
    return (incoming_etag == server_etag)


def _send_tiddler(environ, start_response, tiddler):
    """
    Push a single tiddler out the network in the
    form of the chosen serialization.
    """
    store = environ['tiddlyweb.store']

    bag = Bag(tiddler.bag)
    # this will raise 403 if constraint does not pass
    try:
        check_bag_constraint(environ, bag, 'read')
    except NoBagError as exc:
        raise HTTP404('%s not found, no bag %s, %s' %
                (tiddler.title, tiddler.bag, exc))

    try:
        tiddler = store.get(tiddler)
    except NoTiddlerError as exc:
        raise HTTP404('%s not found, %s' % (tiddler.title, exc))

    # this will raise 304
    # have to do this check after we read from the store because
    # we need the revision, which is sad
    last_modified, etag = validate_tiddler_headers(environ, tiddler)

    # make choices between binary or serialization
    content, mime_type, serialized = _get_tiddler_content(environ, tiddler)

    vary_header = ('Vary', 'Accept')
    cache_header = ('Cache-Control', 'no-cache')
    if CACHE_CONTROL_FIELD in tiddler.fields:
        try:
            cache_header = ('Cache-Control', 'max-age=%s'
                    % int(tiddler.fields[CACHE_CONTROL_FIELD]))
        except ValueError:
            pass  # if the value is not an int use default header

    # Add charset to pseudo_binary tiddler
    if not serialized and pseudo_binary(tiddler.type):
        mime_type = '%s; charset=UTF-8' % mime_type
    content_header = ('Content-Type', str(mime_type))

    response = [cache_header, content_header, vary_header]
    if last_modified:
        response.append(last_modified)
    if etag:
        response.append(etag)
    start_response('200 OK', response)

    if isinstance(content, basestring) or isinstance(content, bytes):
        return [content]
    else:
        return content


def _get_tiddler_content(environ, tiddler):
    """
    Extract the content of the tiddler, either straight up if
    the content is not considered text, or serialized if it is.
    """
    config = environ['tiddlyweb.config']
    default_serializer = config['default_serializer']
    default_serialize_type = config['serializers'][default_serializer][0]
    serialize_type, mime_type, accept = get_serialize_type(
            environ, accept_type=True)
    extension = environ.get('tiddlyweb.extension')
    serialized = False

    # If this is a tiddler with a CANONICAL_URI_FIELD redirect
    # there unless we are requesting a json form
    if (CANONICAL_URI_FIELD in tiddler.fields
            and not CANONICAL_URI_PASS_TYPE in mime_type):
        raise HTTP302(tiddler.fields[CANONICAL_URI_FIELD])

    if not renderable(tiddler, environ):
        if (serialize_type == default_serialize_type or
                accept.startswith(tiddler.type) or
                extension == 'html'):
            mime_type = tiddler.type
            content = tiddler.text
            return content, mime_type, serialized

    serializer = Serializer(serialize_type, environ)
    serializer.object = tiddler

    try:
        content = serializer.to_string()
        serialized = True
    except (TiddlerFormatError, NoSerializationError) as exc:
        raise HTTP415(exc)
    return content, mime_type, serialized


def _send_tiddler_revisions(environ, start_response, tiddler):
    """
    Push the list of tiddler revisions out the network.
    """
    store = environ['tiddlyweb.store']

    title = 'Revisions of Tiddler %s' % tiddler.title
    title = environ['tiddlyweb.query'].get('title', [title])[0]
    container = 'recipes' if tiddler.recipe else 'bags'

    if environ['tiddlyweb.filters']:
        tiddlers = Tiddlers(title=title)
    else:
        tiddlers = Tiddlers(title=title, store=store)

    tiddlers.is_revisions = True
    tiddlers.link = '%s/revisions' % tiddler_url(environ, tiddler,
            container=container, full=False)

    # Set the container on the tiddlers. Since tiddler.recipe
    # defaults to None, we're "safe" here.
    tiddlers.recipe = tiddler.recipe
    tiddlers.bag = tiddler.bag

    try:
        for revision in store.list_tiddler_revisions(tiddler):
            tmp_tiddler = Tiddler(title=tiddler.title, bag=tiddler.bag)
            tmp_tiddler.revision = revision
            tmp_tiddler.recipe = tiddler.recipe
            tiddlers.add(tmp_tiddler)
    except NoTiddlerError as exc:
        # If a tiddler is not present in the store.
        raise HTTP404('tiddler %s not found, %s' % (tiddler.title, exc))
    except NoBagError as exc:
        raise HTTP404('tiddler %s not found, bag %s does not exist, %s'
                % (tiddler.title, tiddler.bag, exc))
    except StoreMethodNotImplemented:
        raise HTTP400('no revision support')

    return send_tiddlers(environ, start_response, tiddlers=tiddlers)


def _new_tiddler_etag(tiddler):
    """
    Calculate the ETag of a tiddler that does not
    yet exist. This is a bastardization of ETag handling
    but is useful for doing edit contention handling.
    """
    return str('"%s/%s/%s"' % (encode_name(tiddler.bag),
        encode_name(tiddler.title), '0'))

########NEW FILE########
__FILENAME__ = listentities
"""
Common code used for listing :py:class:`bags <tiddlyweb.model.bag.Bag>`
and :py:class:`recipes <tiddlyweb.model.recipe.Recipe>` in HTTP responses.
"""

from httpexceptor import HTTP400, HTTP415

from tiddlyweb.filters import recursive_filter, FilterError
from tiddlyweb.model.collections import Container
from tiddlyweb.model.policy import UserRequiredError, ForbiddenError
from tiddlyweb.serializer import Serializer, NoSerializationError
from tiddlyweb.util import sha
from tiddlyweb.web.util import get_serialize_type, check_incoming_etag

from tiddlyweb.fixups import basestring


def list_entities(environ, start_response, method_name,
        store_list=None, serializer_list=None):
    """
    Get an optionally :py:mod:`filtered <tiddlyweb.filters>` list
    of all the :py:class:`bags <tiddlyweb.model.bag.Bag>` or
    :py:class:`recipes <tiddlyweb.model.recipe.Recipe>`
    the current ``tiddlyweb.usersign`` can read.
    """
    store = environ['tiddlyweb.store']
    serialize_type, mime_type = get_serialize_type(environ, collection=True)
    serializer = Serializer(serialize_type, environ)
    filters = environ['tiddlyweb.filters']
    if method_name:
        if not store_list:
            store_list = getattr(store, method_name)
        if not serializer_list:
            serializer_list = getattr(serializer, method_name)

    try:
        kept_entities = _filter_readable(environ, store_list(), filters)
    except FilterError as exc:
        raise HTTP400(exc)

    etag_string = '"%s:%s"' % (kept_entities.hexdigest(),
            sha(mime_type).hexdigest())
    check_incoming_etag(environ, etag_string)

    try:
        output = serializer_list(kept_entities)
    except NoSerializationError:
        raise HTTP415('Content type not supported: %s' % mime_type)

    start_response("200 OK", [('Content-Type', mime_type),
                ('Vary', 'Accept'),
                ('Cache-Control', 'no-cache'),
                ('Etag', etag_string)])

    if isinstance(output, basestring):
        return [output]
    else:
        return output


def _filter_readable(environ, entities, filters):
    """
    Traverse entities to get those that are readable
    and those that pass the filter.

    XXX: There is a bug here, depending on how
    filters are to be interpreted: If limit is used
    it is being calculated before the readability
    of the entities is checked.
    """
    store = environ['tiddlyweb.store']

    def _load(entities):
        for entity in entities:
            if hasattr(entity, 'store') and entity.store:
                yield entity
            else:
                entity = store.get(entity)
                yield entity

    kept_entities = Container()
    try:
        for entity in recursive_filter(filters, _load(entities)):
            try:
                entity.policy.allows(environ['tiddlyweb.usersign'], 'read')
                kept_entities.add(entity)
            except(UserRequiredError, ForbiddenError):
                pass
    except AttributeError as exc:
        raise FilterError('malformed filter: %s' % exc)
    return kept_entities

########NEW FILE########
__FILENAME__ = negotiate
"""
WSGI Middleware to do a limited version of content negotiation
and put the type in ``tiddlyweb.type``. On ``GET`` and ``HEAD``
requests the ``Accept`` header is examined. On ``POST`` and ``PUT``,
``Content-Type``. If extensions are provided on a URI used in a ``GET``
request if the extension matches something in ``extension_types`` in
:py:mod:`config <tiddlyweb.config>`, the type indicated by the
extension wins over the Accept header.
"""

import logging
import mimeparse


LOGGER = logging.getLogger(__name__)


class Negotiate(object):
    """
    Perform a form of content negotiation to provide information
    to the WSGI environment that will later be used to choose
    serializers.
    """

    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):
        figure_type(environ)
        return self.application(environ, start_response)


def figure_type(environ):
    """
    Determine either the ``Content-Type`` (for ``POST`` and ``PUT``)
    or ``Accept`` header (for ``GET``) and put that information
    in ``tiddlyweb.type`` in the WSGI environment.
    """
    if environ['REQUEST_METHOD'].upper() == 'GET':
        _figure_type_for_get(environ)
    else:
        _figure_type_for_other(environ)


def _figure_type_for_other(environ):
    """
    Determine the type for PUT and POST
    requests, based on the content-type
    header.
    """
    content_type = environ.get('CONTENT_TYPE', None)
    if content_type:
        LOGGER.debug('negotiating for content-type %s', content_type)
        content_type = content_type.split(';')[0]
        environ['tiddlyweb.type'] = content_type


def _figure_type_for_get(environ):
    """
    Determine the type for a GET request, based on the ``Accept``
    header and URI path filename extensions. If there is an extension
    and the extension matches something in ``extension_types`` in
    :py:mod:`config <tiddlyweb.config>`, the type indicated by the
    extension wins over ``Accept``. This allows humans to easily
    declare a desired representation from a browser.
    """
    accept_header = environ.get('HTTP_ACCEPT')
    path_info = environ.get('PATH_INFO')

    extension_types = environ['tiddlyweb.config']['extension_types']

    our_types = []

    if path_info:
        last_segment = path_info.rsplit('/', 1)[-1]
        extension = last_segment.rsplit('.', 1)
        if len(extension) == 2:
            ext = extension[-1]
            environ['tiddlyweb.extension'] = ext
            try:
                our_type = extension_types[ext]
                our_types.append(our_type)
            except KeyError:
                pass

    if accept_header:
        default_type = environ['tiddlyweb.config']['default_serializer']
        matchable_types = list(
                environ['tiddlyweb.config']['serializers'].keys())
        matchable_types.append(default_type)
        try:
            our_types.append(mimeparse.best_match(
                matchable_types, accept_header))
        except ValueError:
            our_types.append(default_type)

    LOGGER.debug('negotiating for accept and extensions %s', our_types)

    environ['tiddlyweb.type'] = our_types

    return

########NEW FILE########
__FILENAME__ = query
"""
WSGI Middleware that extracts ``CGI`` parameters from the
``QUERY_STRING`` and puts them in ``tiddlyweb.query`` in the
environ in the same structure that cgi.py uses (dictionary of lists).
If the current request is a ``POST`` of HTML form data, parse that too.
"""

# XXX not using tiddlyweb.fixups here because of ENCODED_QUERY
# presumably there is a way around that.
try:
    from urllib.parse import parse_qs
    ENCODED_QUERY = False
except ImportError:
    try:
        from urlparse import parse_qs
    except ImportError:
        from cgi import parse_qs
    ENCODED_QUERY = True

from cgi import FieldStorage

from httpexceptor import HTTP400

from tiddlyweb.filters import parse_for_filters
from tiddlyweb.web.util import read_request_body

try:
    unicode
except NameError:
    def unicode(input, encoding=None):
        return input


class Query(object):
    """
    Extract ``CGI`` parameter data from ``QUERY_STRING`` and POSTed form data.
    """

    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):
        self.extract_query(environ)
        return self.application(environ, start_response)

    def extract_query(self, environ):
        """
        Read the ``QUERY_STRING`` and body (if a POSTed form) to extract
        query parameters. Put the results in ``tiddlyweb.query`` in
        environ. The query names and values are decoded from UTF-8 to
        unicode.

        If there are file uploads in posted form data, the files are
        not put into ``tiddlyweb.query``. Instead the file handles are
        appended to ``tiddlyweb.input_files``.
        """
        content_type = environ.get('CONTENT_TYPE', '')
        environ['tiddlyweb.query'] = {}
        environ['tiddlyweb.input_files'] = []
        if _cgi_post(environ, content_type):
            _process_post(environ, content_type)
        filters, leftovers = parse_for_filters(
                environ.get('QUERY_STRING', ''), environ)
        query_data = parse_qs(leftovers, keep_blank_values=True)
        try:
            _update_tiddlyweb_query(environ, query_data, encoded=ENCODED_QUERY)
        except UnicodeDecodeError as exc:
            raise HTTP400(
                    'Invalid encoding in query string, utf-8 required: %s',
                    exc)
        environ['tiddlyweb.filters'] = filters


def _update_tiddlyweb_query(environ, data, encoded=True):
    """
    Update ``tiddlyweb.query`` with decoded form data.
    """
    if encoded:
        environ['tiddlyweb.query'].update(dict(
            [(unicode(key, 'UTF-8'), [unicode(value, 'UTF-8')
                for value in values]) for key, values in data.items()]))
    else:
        environ['tiddlyweb.query'].update(data)


def _cgi_post(environ, content_type):
    """
    Test if there is POST form data to handle.
    """
    return (environ['REQUEST_METHOD'].upper() == 'POST'
            and (
                content_type.startswith('application/x-www-form-urlencoded')
                or content_type.startswith('multipart/form-data')))


def _process_post(environ, content_type):
    """
    Process posted form data.
    """
    try:
        if content_type.startswith('application/x-www-form-urlencoded'):
            posted_data = _process_encodedform(environ)
        elif content_type.startswith('multipart/form-data'):
            posted_data = _process_multipartform(environ)
        _update_tiddlyweb_query(environ, posted_data, encoded=ENCODED_QUERY)
    except UnicodeDecodeError as exc:
        raise HTTP400(
                'Invalid encoding in query data, utf-8 required: %s',
                exc)


def _process_encodedform(environ):
    """
    Read ``application/x-www-form-urlencoded`` from the request
    body and parse for form data and return.
    """
    try:
        length = environ['CONTENT_LENGTH']
        content = read_request_body(environ, length)
        if not ENCODED_QUERY:
            content = content.decode('UTF-8')
    except KeyError as exc:
        raise HTTP400('Invalid post, unable to read content: %s' % exc)
    return parse_qs(content, keep_blank_values=True)


def _process_multipartform(environ):
    """
    Read ``multipart/form-data`` using ``FieldStorage``, return
    a dictionary of form data and set ``tiddlyweb.input_files``
    to a list of available files.
    """
    posted_data = {}
    try:
        field_storage = FieldStorage(fp=environ['wsgi.input'],
                environ=environ, keep_blank_values=True)
    except ValueError as exc:
        raise HTTP400('Invalid post, bad form: %s' % exc)
    for key in field_storage.keys():
        if (hasattr(field_storage[key], 'filename')
                and field_storage[key].filename):
            environ['tiddlyweb.input_files'].append(
                    field_storage[key])
        else:
            posted_data[key] = field_storage.getlist(key)
    return posted_data

########NEW FILE########
__FILENAME__ = sendentity
"""
Send a :py:class:`bag <tiddlyweb.model.bag.Bag>` or :py:class:`recipe
<tiddlyweb.model.recipe.Recipe>` out over HTTP, first :py:class:`serializing
<tiddlyweb.serializer.Serializer>` to the correct type.

This consolidates common code for bags and recipes.
"""

from httpexceptor import HTTP415

from tiddlyweb.serializer import Serializer, NoSerializationError
from tiddlyweb.web.util import (get_serialize_type, entity_etag,
        check_incoming_etag)

from tiddlyweb.fixups import basestring


def send_entity(environ, start_response, entity):
    """
    Send a :py:class:`bag <tiddlyweb.model.bag.Bag>` or :py:class:`recipe
    <tiddlyweb.model.recipe.Recipe>` out over HTTP, first
    :py:class:`serializing <tiddlyweb.serializer.Serializer>` to
    the correct type. If an incoming ``Etag`` validates, raise a
    ``304`` response.
    """
    etag_string = entity_etag(environ, entity)
    check_incoming_etag(environ, etag_string)

    try:
        serialize_type, mime_type = get_serialize_type(environ)
        serializer = Serializer(serialize_type, environ)
        serializer.object = entity
        content = serializer.to_string()
    except NoSerializationError:
        raise HTTP415('Content type %s not supported' % mime_type)

    start_response("200 OK",
            [('Content-Type', mime_type),
                ('Cache-Control', 'no-cache'),
                ('ETag', etag_string),
                ('Vary', 'Accept')])

    if isinstance(content, basestring):
        return [content]
    else:
        return content

########NEW FILE########
__FILENAME__ = sendtiddlers
"""
Routines related to sending a list of :py:class:`tiddlers
<tiddlyweb.model.tiddler.Tiddler>` out to the web, including optionally
:py:mod:`filtering <tiddlyweb.filters>` those tiddlers and
validating cache-oriented request headers.
"""

import logging
import inspect

from httpexceptor import HTTP400, HTTP415

from tiddlyweb.filters import FilterError, recursive_filter
from tiddlyweb.model.collections import Tiddlers
from tiddlyweb.serializer import Serializer, NoSerializationError
from tiddlyweb.util import sha
from tiddlyweb.web.util import (get_serialize_type, http_date_from_timestamp,
        check_last_modified, check_incoming_etag, encode_name)

from tiddlyweb.fixups import basestring


LOGGER = logging.getLogger(__name__)


def send_tiddlers(environ, start_response, tiddlers=None):
    """
    Output the :py:class:`tiddlers <tiddlyweb.model.tiddler.Tiddler>`
    contained in the provided :py:class:`Tiddlers collection
    <tiddlyweb.model.collections.Tiddlers>` in a :py:mod:`Negotiated
    <tiddlyweb.web.negotiate>` representation.
    """
    download = environ['tiddlyweb.query'].get('download', [None])[0]
    filters = environ['tiddlyweb.filters']
    store = environ['tiddlyweb.store']

    if tiddlers.store is None and not filters:
        LOGGER.warn('Incoming tiddlers no store set %s', inspect.stack()[1])

    if filters:
        candidate_tiddlers = _filter_tiddlers(filters, store, tiddlers)
    else:
        candidate_tiddlers = tiddlers

    last_modified, etag = _validate_tiddler_list(environ, candidate_tiddlers)

    serialize_type, mime_type = get_serialize_type(environ, collection=True)

    response = [('Content-Type', mime_type),
            ('Cache-Control', 'no-cache'),
            ('Vary', 'Accept')]

    if download:
        response.append(('Content-Disposition',
            'attachment; filename="%s"' % encode_name(download)))

    if last_modified:
        response.append(last_modified)

    if etag:
        response.append(etag)

    try:
        serializer = Serializer(serialize_type, environ)
        output = serializer.list_tiddlers(candidate_tiddlers)
    except NoSerializationError as exc:
        raise HTTP415('Content type not supported: %s:%s, %s' %
                (serialize_type, mime_type, exc))
    except FilterError as exc:  # serializations may filter tildders
        raise HTTP400('malformed filter or tiddler during filtering: %s' % exc)

    start_response("200 OK", response)

    if isinstance(output, basestring):
        return [output]
    else:
        return output


def _filter_tiddlers(filters, store, tiddlers):
    """
    Filter the tiddlers by filters provided by the environment.
    """
    candidate_tiddlers = Tiddlers(store=store)
    try:
        candidate_tiddlers.title = tiddlers.title
        candidate_tiddlers.link = tiddlers.link
        candidate_tiddlers.is_search = tiddlers.is_search
        candidate_tiddlers.is_revisions = tiddlers.is_revisions
        candidate_tiddlers.bag = tiddlers.bag
        candidate_tiddlers.recipe = tiddlers.recipe
    except AttributeError:
        pass
    try:
        for tiddler in recursive_filter(filters, tiddlers):
            candidate_tiddlers.add(tiddler)
    except FilterError as exc:
        raise HTTP400('malformed filter: %s' % exc)
    return candidate_tiddlers


def _validate_tiddler_list(environ, tiddlers):
    """
    Do Etag and Last modified checks on the
    collection of tiddlers.

    If ETag testing is done, no last modified handling
    is done, even if the ETag testing fails.

    If no 304 is raised, then just return last-modified
    and ETag for the caller to use in constructing
    its HTTP response.
    """
    last_modified_string = http_date_from_timestamp(tiddlers.modified)
    last_modified = ('Last-Modified', last_modified_string)

    username = environ.get('tiddlyweb.usersign', {}).get('name', '')

    try:
        _, mime_type = get_serialize_type(environ)
        mime_type = mime_type.split(';', 1)[0].strip()
    except TypeError:
        mime_type = ''
    etag_string = '"%s:%s"' % (tiddlers.hexdigest(),
            sha('%s:%s' % (username, mime_type)).hexdigest())
    etag = ('Etag', etag_string)

    incoming_etag = check_incoming_etag(environ, etag_string,
            last_modified=last_modified_string)
    if not incoming_etag:  # only check last modified when no etag
        check_last_modified(environ, last_modified_string,
                etag=etag_string)

    return last_modified, etag

########NEW FILE########
__FILENAME__ = serve
"""
Functions and Classes for running a TiddlyWeb server, including
optionally a built in web server.
"""
import logging

from selector import Selector

from tiddlyweb.util import std_error_message, initialize_logging


LOGGER = logging.getLogger(__name__)


def load_app(app_prefix=None, dirname=None):
    """
    Create our application from a series of layers. The innermost
    layer is a Selector application based on ``urls_map`` defined in
    :py:mod:`config <tiddlyweb.config>`. This is surrounded by wrappers,
    which either set something in the environment, modify the request,
    or transform the response. The wrappers are WSGI middleware defined
    by ``server_request_filters`` and ``server_response_filters`` in
    :py:mod:`tiddlyweb.config`.
    """
    from tiddlyweb.config import config
    if dirname:
        config['root_dir'] = dirname

    # If the logger is not already initialized (from twanager),
    # let's initialize it.
    if LOGGER.parent.name is not 'tiddlyweb':
        initialize_logging(config, server=True)

    mapfile = config['urls_map']
    if app_prefix is not None:
        prefix = app_prefix
    else:
        prefix = config['server_prefix']
    app = Selector(mapfile=mapfile, prefix=prefix)
    config['selector'] = app

    try:
        plugins = config['system_plugins']
        for plugin in plugins:
            LOGGER.debug('attempt to import system plugin %s', plugin)
            # let the import fail with error if it does
            imported_module = __import__(plugin, {}, {}, ['init'])
            imported_module.init(config)
    except KeyError:
        pass  # no plugins

    wrappers = []
    wrappers.extend(reversed(config['server_request_filters']))
    wrappers.append(RequestStarter)  # required as the first app
    wrappers.append(Configurator)  # required as the second app
    wrappers.extend(config['server_response_filters'])
    if wrappers:
        for wrapper in wrappers:
            LOGGER.debug('wrapping app with %s', wrapper)
            if wrapper == Configurator:
                app = wrapper(app, config=config)
            else:
                app = wrapper(app)
    return app


def start_server(config):
    """
    Start a simple webserver, from ``wsgiref``, to run our app.
    """

    import sys
    from wsgiref.simple_server import make_server, WSGIRequestHandler

    class NoLogRequestHandler(WSGIRequestHandler):
        def log_request(self, code='-', size='-'):
            pass

    hostname = config['server_host']['host']
    port = int(config['server_host']['port'])
    scheme = config['server_host']['scheme']
    httpd = make_server(hostname, port, load_app(),
            handler_class=NoLogRequestHandler)

    LOGGER.debug('starting wsgi server at %s://%s:%s',
            scheme, hostname, port)
    std_error_message("starting wsgi server at %s://%s:%s"
            % (scheme, hostname, port))
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        sys.exit(0)


class RequestStarter(object):
    """
    WSGI middleware that logs basic request information and cleans
    ``PATH_INFO`` in the environment.

    ``PATH_INFO`` cleaning is done to ensure that there is a
    well known encoding of special characters and to support
    ``/`` in entity names (see :py:func:`clean_path_info`).
    """

    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):
        LOGGER.debug('starting %s request with URI "%s", script_name "%s"'
                ', path_info "%s" and query "%s"',
                environ.get('REQUEST_METHOD', None),
                environ.get('REQUEST_URI', None),
                environ.get('SCRIPT_NAME', None),
                environ.get('PATH_INFO', None),
                environ.get('QUERY_STRING', None))
        self.clean_path_info(environ)
        return self.application(environ, start_response)

    def clean_path_info(self, environ):
        """
        Clean ``PATH_INFO`` in the environment.

        This is necessary because WSGI servers tend to decode
        the URI before putting it in ``PATH_INFO``. This means that
        uri encoded data, such as the ``%2F`` encoding of ``/``
        will be decoded before we get to route dispatch handling,
        by which time the ``/`` is treated as a separator. People
        say that the right thing to do here is not use ``%2F``.
        This is hogwash. The right thing to do is not decode
        ``PATH_INFO``. In this solution if ``REQUEST_URI`` is present
        we use a portion of it to set ``PATH_INFO``.
        """
        request_uri = environ.get('REQUEST_URI', environ.get('RAW_URI', ''))

        if request_uri:
            request_uri = request_uri.decode()
            path_info = environ.get('PATH_INFO', '')
            script_name = environ.get('SCRIPT_NAME', '')
            query_string = environ.get('QUERY_STRING', '')

            path_info = request_uri.replace(script_name, "", 1)
            path_info = path_info.replace('?' + query_string, "", 1)
            environ['PATH_INFO'] = path_info


class Configurator(object):
    """
    WSGI middleware to set ``tiddlyweb.config`` in ``environ`` for
    every request from :py:mod:`config <tiddlyweb.config>`.
    """

    def __init__(self, application, config):
        self.application = application
        self.config = config

    def __call__(self, environ, start_response):
        environ['tiddlyweb.config'] = self.config
        return self.application(environ, start_response)

########NEW FILE########
__FILENAME__ = util
"""
General utility routines shared by various web related modules.
"""

from datetime import datetime

from email.utils import parsedate

from httpexceptor import HTTP415, HTTP400, HTTP304

from tiddlyweb.model.policy import PermissionsError
from tiddlyweb.model.tiddler import timestring_to_datetime, current_timestring
from tiddlyweb.serializer import Serializer
from tiddlyweb.util import sha

from tiddlyweb.fixups import SimpleCookie, quote, unquote

try:
    unicode
except NameError:
    unicode = str


def check_bag_constraint(environ, bag, constraint):
    """
    Check to see if the provided :py:class:`bag <tiddlyweb.model.bag.Bag>`
    allows the current ``tiddlyweb.usersign`` to perform the action described
    by ``constraint``. Lets NoBagError raise if the bag does not exist.

    This is a web util because user and store come from the WSGI environ.
    """
    try:
        store = environ['tiddlyweb.store']
        usersign = environ['tiddlyweb.usersign']
        bag = store.get(bag)
        bag.policy.allows(usersign, constraint)
    except (PermissionsError) as exc:
        # XXX this throws away traceback info
        msg = 'for bag %s: %s' % (bag.name, exc)
        raise exc.__class__(msg)


def check_incoming_etag(environ, etag_string, cache_control='no-cache',
        last_modified=None, vary='Accept'):
    """
    Raise 304 if the provided ``etag_string`` is the same as that found
    in the ``If-None-Match`` header of the incoming request.

    Return ``incoming_etag`` to indicate if an etag was there but
    did not match.
    """
    incoming_etag = environ.get('HTTP_IF_NONE_MATCH', None)
    if incoming_etag:
        if incoming_etag == etag_string:
            raise HTTP304(incoming_etag, vary=vary,
                    cache_control=cache_control,
                    last_modified=last_modified)
    return incoming_etag


def check_last_modified(environ, last_modified_string, etag='',
        cache_control='no-cache', vary='Accept'):
    """
    Raise ``304`` if an ``If-Modified-Since`` header matches
    ``last_modified_string``.
    """
    incoming_modified = environ.get('HTTP_IF_MODIFIED_SINCE', None)
    if incoming_modified:
        incoming_modified = datetime_from_http_date(incoming_modified)
        if incoming_modified and (incoming_modified >=
                datetime_from_http_date(last_modified_string)):
            raise HTTP304(etag, vary=vary, cache_control=cache_control,
                    last_modified=last_modified_string)


def content_length_and_type(environ):
    """
    For ``PUT`` or ``POST`` request there must be ``Content-Length`` and
    ``Content-Type`` headers. Raise ``400`` if not present in the request.
    """
    try:
        length = environ['CONTENT_LENGTH']
        content_type = environ['tiddlyweb.type']
    except KeyError:
        raise HTTP400(
                'Content-Length and content-type required to PUT or POST')
    return length, content_type


def get_route_value(environ, name):
    """
    Retrieve and decode ``name`` from data provided in WSGI route.

    If ``name`` is not present in the route, allow KeyError to raise.
    """
    value = environ['wsgiorg.routing_args'][1][name]
    value = unquote(value)
    return value.replace('%2F', '/')


def get_serialize_type(environ, collection=False, accept_type=False):
    """
    Look in the ``environ`` to determine which :py:class:`serializer
    <tiddlyweb.serializer.Serializer>` should be used for this request.

    If ``collection`` is ``True``, then the presence of an extension
    on the URI which does not match any serializer should lead to a ``415``.
    """
    config = environ['tiddlyweb.config']
    accept = environ.get('tiddlyweb.type', [])[:]
    ext = environ.get('tiddlyweb.extension')
    extension_types = config['extension_types']
    serializers = config['serializers']
    serialize_type, mime_type, candidate_type = None, None, None

    if collection and ext and ext not in extension_types:
        accept = [None]

    if type(accept) == unicode or type(accept) == str:
        accept = [accept]

    while len(accept) and serialize_type is None:
        candidate_type = accept.pop(0)
        try:
            serialize_type, mime_type = serializers[candidate_type]
        except KeyError:
            pass
    if not serialize_type:
        if ext:
            raise HTTP415('%s type unsupported' % ext)
        # If we are a PUT and we haven't found a serializer, don't
        # state a default as that makes no sense.
        if environ.get('REQUEST_METHOD') == 'GET':
            default_serializer = config['default_serializer']
            serialize_type, mime_type = serializers[default_serializer]
    if accept_type:
        return serialize_type, mime_type, candidate_type
    else:
        return serialize_type, mime_type


def handle_extension(environ, resource_name):
    """
    Look for an extension (as defined in :py:mod:`config <tiddlyweb.config>`)
    on the provided ``resource_name`` and trim it off to give the
    "real" resource name.
    """
    extension = environ.get('tiddlyweb.extension')
    extension_types = environ['tiddlyweb.config']['extension_types']
    if extension and extension in extension_types:
        try:
            resource_name = resource_name[0:resource_name.rindex('.'
                + extension)]
        except ValueError:
            pass
    else:
        try:
            del(environ['tiddlyweb.extension'])
        except KeyError:
            pass

    return resource_name


def html_frame(environ, title=''):
    """
    Return the header and footer from the current HTML
    :py:class:`serialization
    <tiddlyweb.serializations.SerializationInterface>`.
    """
    html = environ.get('tiddlyweb.config', {}).get(
            'serializers', {}).get('text/html')[0]
    html = Serializer(html, environ).serialization
    header = html._header(title)
    footer = html._footer()
    return header, footer


def http_date_from_timestamp(timestamp):
    """
    Turn a modifier or created tiddler ``timestamp``
    into a properly formatted HTTP date. If the timestamp
    is invalid use the current time as the timestamp.
    """
    try:
        timestamp_datetime = timestring_to_datetime(timestamp)
    except ValueError:
        timestamp_datetime = timestring_to_datetime(current_timestring())
    return timestamp_datetime.strftime('%a, %d %b %Y %H:%M:%S GMT')


def datetime_from_http_date(http_datestring):
    """
    Turn an HTTP formatted date into a datetime object.
    Return ``None`` if the date string is invalid.
    """
    if ';' in http_datestring:
        http_datestring = http_datestring.split(';', 1)[0].rstrip().lstrip()
    try:
        return datetime(*parsedate(http_datestring)[:6])
    except TypeError:
        return None


def make_cookie(name, value, mac_key=None, path=None,
        expires=None, httponly=True, domain=None):
    """
    Create a cookie string, optionally with a MAC, path and
    expires value. If ``expires`` is provided, its value should be
    in seconds.
    """
    cookie = SimpleCookie()

    value = encode_name(value)

    if mac_key:
        secret_string = sha('%s%s' % (value, mac_key)).hexdigest()
        cookie[name] = '%s:%s' % (value, secret_string)
    else:
        cookie[name] = value

    if path:
        cookie[name]['path'] = path

    if expires:
        cookie[name]['max-age'] = expires

    if domain:
        cookie[name]['domain'] = domain

    output = cookie.output(header='').lstrip().rstrip()
    if httponly:
        output += '; httponly'
    return output


def read_request_body(environ, length):
    """
    Read the ``wsgi.input`` handle to get the request body.

    Length is a required parameter because it is tested for existence
    earlier in the process.
    """
    try:
        length = int(length)
        input_handle = environ['wsgi.input']
        return input_handle.read(length)
    except (KeyError, ValueError, IOError) as exc:
        raise HTTP400('Error reading request body: %s', exc)


def server_base_url(environ):
    """
    Using information in :py:mod:`tiddlyweb.config`, construct
    the base URL of the server, without the trailing ``/``.
    """
    return '%s%s' % (server_host_url(environ), _server_prefix(environ))


def server_host_url(environ):
    """
    Generate the scheme and host portion of our server url.
    """
    server_host = environ['tiddlyweb.config']['server_host']
    port = str(server_host['port'])
    if port == '80' or port == '443':
        port = ''
    else:
        port = ':%s' % port
    return '%s://%s%s' % (server_host['scheme'], server_host['host'], port)


def _server_prefix(environ):
    """
    Get the ``server_prefix`` out of :py:mod:`tiddlyweb.config`.
    """
    config = environ.get('tiddlyweb.config', {})
    return config.get('server_prefix', '')


def encode_name(name):
    """
    Encode a unicode value as utf-8 and then URL encode that
    string. Use for entity titles in URLs.
    """
    return quote(name.encode('utf-8'), safe=".!~*'()")


def html_encode(text):
    """
    Encode ``&``, ``<`` and ``>`` entities in ``text`` that will
    be used in or as HTML.
    """
    return (text.replace('&', '&amp;').replace('<', '&lt;').
            replace('>', '&gt;'))


def escape_attribute_value(text):
    """
    Escape common HTML character entities, including double quotes
    in attribute values

    This assumes values are enclosed in double quotes (key="value").
    """
    try:
        return html_encode(text).replace('"', '&quot;')
    except AttributeError:  # value might be None
        return text


def entity_etag(environ, entity):
    """
    Construct an Etag from the digest of the :py:class:`JSON
    <tiddlyweb.serializations.json.Serialization>` reprepresentation
    of an entity.

    The JSON representation provides a reasonably repeatable and
    unique string of data.
    """
    try:
        _, mime_type = get_serialize_type(environ)
        mime_type = mime_type.split(';', 1)[0].strip()
    except (AttributeError, TypeError):
        mime_type = ''
    if 'tiddlyweb.etag_serializer' in environ:
        serializer = environ['tiddlyweb.etag_serializer']
    else:
        serializer = Serializer('json', environ)
        environ['tiddlyweb.etag_serializer'] = serializer
    serializer.object = entity
    content = serializer.to_string()
    return '"%s"' % sha(content + mime_type).hexdigest()


def bag_etag(environ, bag):
    """
    Construct an etag for a :py:class:`bag <tiddlyweb.model.bag.Bag>`.
    """
    return entity_etag(environ, bag)


def bag_url(environ, bag, full=True):
    """
    Construct a URL for a :py:class:`bag <tiddlyweb.model.bag.Bag>`.
    """
    bag_link = 'bags/%s' % encode_name(bag.name)

    if full:
        return '%s/%s' % (server_base_url(environ), bag_link)
    else:
        return '%s/%s' % (_server_prefix(environ), bag_link)


def tiddler_etag(environ, tiddler):
    """
    Construct an etag for a :py:class:`tiddler
    <tiddlyweb.model.tiddler.Tiddler>` from the tiddler's attributes,
    but not its text.
    """
    text = tiddler.text
    tiddler.text = ''
    if not tiddler.revision:
        tiddler.revision = 0
    bag_name = tiddler.bag or ''
    tiddler_id = '"%s/%s/%s:' % (encode_name(bag_name),
            encode_name(tiddler.title), encode_name('%s' % tiddler.revision))
    etag = entity_etag(environ, tiddler)
    tiddler.text = text
    etag = etag.replace('"', tiddler_id, 1)
    return etag


def tiddler_url(environ, tiddler, container='bags', full=True):
    """
    Construct a URL for a :py:class:`tiddler
    <tiddlyweb.model.tiddler.Tiddler>`.
    """
    container_name = tiddler.recipe if container == 'recipes' else tiddler.bag
    tiddler_link = '%s/%s/tiddlers/%s' % (container,
            encode_name(container_name), encode_name(tiddler.title))

    if full:
        return '%s/%s' % (server_base_url(environ), tiddler_link)
    else:
        return '%s/%s' % (_server_prefix(environ), tiddler_link)


def recipe_etag(environ, recipe):
    """
    Construct an etag for a :py:class:`recipe <tiddlyweb.model.recipe.Recipe>`.
    """
    return entity_etag(environ, recipe)


def recipe_url(environ, recipe, full=True):
    """
    Construct a URL for a :py:class:`recipe <tiddlyweb.model.recipe.Recipe>`.
    """
    recipe_link = 'recipes/%s' % encode_name(recipe.name)

    if full:
        return '%s/%s' % (server_base_url(environ), recipe_link)
    else:
        return '%s/%s' % (_server_prefix(environ), recipe_link)

########NEW FILE########
__FILENAME__ = validator
"""
A collection of routines for validating, santizing and otherwise messing
with content coming in from the web to be :py:class:`tiddlers
<tiddlyweb.model.tiddler.Tidder>`, :py:class:`bags
<tiddlyweb.model.bag.Bag>` or :py:class:`recipes
<tiddlyweb.model.recipe.Recipe>`.

The validators can be extended by adding functions to the ``BAG_VALIDATORS``,
``RECIPE_VALIDATORS`` and ``TIDDLER_VALIDATORS``. The functions take an
entity object, and an optional WSGI ``environ`` dict.
"""


class InvalidTiddlerError(Exception):
    """
    The provided :py:class:`tiddler <tiddlyweb.model.tiddler.Tiddler>`
    has not passed a validation routine and has been rejected.
    The caller should stop processing and return an error to calling
    code or user-agent.
    """
    pass


class InvalidBagError(Exception):
    """
    The provided :py:class:`bag <tiddlyweb.model.bag.Bag>` has not passed
    a validation routine and has been rejected. The caller should stop
    processing and return an error to calling code or user-agent.
    """
    pass


class InvalidRecipeError(Exception):
    """
    The provided :py:class:`recipe <tiddlyweb.model.recipe.Recipe>` has
    not passed a validation routine and has been rejected. The caller
    should stop processing and return an error to calling code or
    user-agent.
    """
    pass


def sanitize_desc(entity, environ):
    """
    Strip any dangerous HTML which may be present in a :py:class:`bag
    <tiddlyweb.model.bag.Bag>` or :py:class:`recipe
    <tiddlyweb.model.recipe.Recipe>` description.
    """
    desc = entity.desc
    entity.desc = sanitize_html_fragment(desc)


BAG_VALIDATORS = [
        sanitize_desc,
]

TIDDLER_VALIDATORS = []

RECIPE_VALIDATORS = [
        sanitize_desc,
]


def validate_tiddler(tiddler, environ=None):
    """
    Pass the :py:class:`tiddler <tiddlyweb.model.tiddler.Tiddler>`
    to each of the functions in ``TIDDLER_VALIDATORS``, in order,
    either changing the content of the tiddler's attributes, or if
    some aspect of the tiddler can not be accepted raising
    :py:class:`InvalidTiddlerError`.

    ``TIDDLER_VALIDATORS`` is an empty list which may be extended
    by plugins.

    ``validate_tiddler`` is called from :py:mod:`web handlers
    <tiddlyweb.web.handler>`, when the ``accept`` constraint on
    the :py:class:`policy <tiddlyweb.model.policy.Policy>` of the
    :py:class:`bag <tiddlyweb.model.bag.Bag>` containing the
    tiddler does not pass.
    """
    _validate(tiddler, environ, TIDDLER_VALIDATORS)


def validate_bag(bag, environ=None):
    """
    Pass the :py:class:`bag <tiddlyweb.model.bag.Bag>` to each of
    the functions in ``BAG_VALIDATORS``, in order, either changing
    the content of the bags's attributes, or if some aspect of the
    bag can not be accepted raising :py:class:`InvalidBagError`.

    ``BAG_VALIDATORS`` may be extended by plugins.

    ``validate_bag`` is called whenever a bag is ``PUT`` via HTTP.
    """
    _validate(bag, environ, BAG_VALIDATORS)


def validate_recipe(recipe, environ=None):
    """
    Pass the :py:class:`recipe <tiddlyweb.model.recipe.Recipe>` to
    each of the functions in ``RECIPE_VALIDATORS``, in order, either
    changing the content of the recipes's attributes, or if some aspect
    of the recipe can not be accepted raising :py:class:`InvalidRecipeError`.

    ``RECIPE_VALIDATORS`` may be extended by plugins.

    ``validate_recipe`` is called whenever a recipe is ``PUT`` via HTTP.
    """
    _validate(recipe, environ, RECIPE_VALIDATORS)


def _validate(entity, environ, validators):
    """
    Validate the provided entity against the list of functions
    in validators.
    """
    if environ is None:
        environ = {}

    for validator in validators:
        validator(entity, environ)


def sanitize_html_fragment(fragment):
    """
    Santize an HTML ``fragment``, returning a copy of the fragment
    that has been cleaned up.
    """
    if fragment:
        import html5lib
        from html5lib.sanitizer import HTMLSanitizer
        from html5lib.serializer.htmlserializer import HTMLSerializer

        parser = html5lib.HTMLParser(tokenizer=HTMLSanitizer)
        parsed = parser.parseFragment(fragment)
        walker = html5lib.treewalkers.getTreeWalker('etree')
        stream = walker(parsed)
        serializer = HTMLSerializer(quote_attr_values=True,
                omit_optional_tags=False)
        output = serializer.render(stream)
        return output
    else:
        return fragment

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI Middleware apps that haven't gotten around to being extracted to
their own modules.
"""

import logging
import time

from httpexceptor import HTTP403, HTTP302

from tiddlyweb.model.policy import UserRequiredError, ForbiddenError
from tiddlyweb.store import Store
from tiddlyweb.web.util import server_base_url

from tiddlyweb.fixups import quote

try:
    unicode = unicode
except NameError:
    unicode = str


class Header(object):
    """
    If ``REQUEST_METHOD`` is HEAD, change it internally to ``GET`` and
    consume the generated output so the response has no body.
    """

    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):
        if environ['REQUEST_METHOD'] == 'HEAD':
            environ['REQUEST_METHOD'] = 'GET'
            self.application(environ, start_response)
            return []
        else:
            return self.application(environ, start_response)


class SimpleLog(object):
    """
    WSGI Middleware to write a very simple log to ``stdout``.

    Borrowed from Paste Translogger
    """

    format = ('%(REMOTE_ADDR)s - %(REMOTE_USER)s [%(time)s] '
            '"%(REQUEST_METHOD)s %(REQUEST_URI)s %(HTTP_VERSION)s" '
            '%(status)s %(bytes)s "%(HTTP_REFERER)s" "%(HTTP_USER_AGENT)s"')

    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):
        logger = logging.getLogger('tiddlyweb')
        if logger.isEnabledFor(logging.INFO):
            return self._log_app(environ, start_response)
        else:
            return self.application(environ, start_response)

    def _log_app(self, environ, start_response):
        req_uri = quote(environ.get('SCRIPT_NAME', '')
                + environ.get('PATH_INFO', ''))
        if environ.get('QUERY_STRING'):
            req_uri += '?' + environ['QUERY_STRING']

        def replacement_start_response(status, headers, exc_info=None):
            """
            We need to gaze at the content-length, if set, to
            write log info.
            """
            size = None
            for name, value in headers:
                if name.lower() == 'content-length':
                    size = value
            self.write_log(environ, req_uri, status, size)
            return start_response(status, headers, exc_info)

        return self.application(environ, replacement_start_response)

    def write_log(self, environ, req_uri, status, size):
        """
        Write the log info out in a formatted form to ``logging.info``.

        This is rather more complex than desirable because there is
        a mix of ``str`` and ``unicode`` in the gathered data and it
        needs to be made acceptable for output.
        """
        environ['REMOTE_USER'] = None
        try:
            environ['REMOTE_USER'] = environ['tiddlyweb.usersign']['name']
        except KeyError:
            pass
        if size is None:
            size = '-'
        log_format = {
                'REMOTE_ADDR': environ.get('REMOTE_ADDR') or '-',
                'REMOTE_USER': environ.get('REMOTE_USER') or '-',
                'REQUEST_METHOD': environ['REQUEST_METHOD'],
                'REQUEST_URI': req_uri,
                'HTTP_VERSION': environ.get('SERVER_PROTOCOL'),
                'time': time.strftime('%d/%b/%Y:%H:%M:%S ', time.localtime()),
                'status': status.split(None, 1)[0],
                'bytes': size,
                'HTTP_REFERER': environ.get('HTTP_REFERER', '-'),
                'HTTP_USER_AGENT': environ.get('HTTP_USER_AGENT', '-'),
        }
        message = self.format % log_format
        logging.info(message)


class StoreSet(object):
    """
    WSGI Middleware that sets our choice of :py:class:`Store
    <tiddlyweb.store.Store>` in the ``environ``. That is, initialize
    the store for each request.
    """

    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):
        database = Store(environ['tiddlyweb.config']['server_store'][0],
                environ['tiddlyweb.config']['server_store'][1],
                environ)
        environ['tiddlyweb.store'] = database
        return self.application(environ, start_response)


class TransformProtect(object):
    """
    WSGI Middleware to add a ``Cache-Control: no-transform``` header
    so that mobile companies that transcode content over their 3G (etc)
    networks don't, as it will break various JavaScript things,
    including TiddlyWiki.
    """

    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):

        def replacement_start_response(status, headers, exc_info=None):
            if '200' in status or '304' in status:
                headers.append(('Cache-Control', 'no-transform'))
            return start_response(status, headers, exc_info)

        return self.application(environ, replacement_start_response)


class EncodeUTF8(object):
    """
    WSGI Middleware to ensure that the unicode content sent out the
    pipe is encoded to UTF-8. Within the application string-based content
    is *unicode* (i.e. not encoded).
    """

    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):
        return (_encoder(output) for output in
                self.application(environ, start_response))


def _encoder(string):
    """
    Take a potentially unicode string and encode it
    as UTF-8.
    """
    # if we are currently unicode, encode to utf-8
    if type(string) == unicode:
        string = string.encode('utf-8')
    return string


class PermissionsExceptor(object):
    """
    Trap :py:class:`permissions exceptions
    <tiddlyweb.model.policy.PermissionsError>` and turn them into HTTP
    exceptions so the errors are propagated to clients.
    """

    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):
        try:
            output = self.application(environ, start_response)
            return output
        except ForbiddenError as exc:
            raise HTTP403(exc)
        except UserRequiredError as exc:
            # We only send to the challenger on a GET
            # request. Otherwise we're in for major confusion
            # on dealing with redirects and the like in
            # scripts and javascript, where follow
            # behavior is inconsistent.
            if environ['REQUEST_METHOD'] == 'GET':
                url = _challenge_url(environ)
                raise HTTP302(url)
            raise HTTP403(exc)


def _challenge_url(environ):
    """
    Generate the URL of the challenge system
    so that GET requests are redirected to the
    right place.
    """
    script_name = environ.get('SCRIPT_NAME', '')
    query_string = environ.get('QUERY_STRING', None)
    redirect = script_name
    if query_string:
        redirect += '?%s' % query_string
    redirect = quote(redirect, safe='')
    return '%s/challenge?tiddlyweb_redirect=%s' % (
            server_base_url(environ), redirect)

########NEW FILE########
__FILENAME__ = raw
"""
A default simple wikitext renderer which does not render the wikitext
but instead wraps it in ``pre`` tags.
"""
from tiddlyweb.web.util import html_encode


def render(tiddler, environ):
    """
    Wrap HTML encoded wikitext with ``pre`` tags.
    """
    return '<pre>\n' + html_encode(tiddler.text) + '</pre>\n'

########NEW FILE########
__FILENAME__ = tiddlywebconfig
config = {
        'log_level':'DEBUG',
        'extra': { 'stuff': ['one', 'two'], }, # required for test_merge_config
        #'twanager.tracebacks': True
}

########NEW FILE########
__FILENAME__ = wsgiapp
"""
This is a handler for running tiddlyweb under web servers that can be
configured to host an Python module as a WSGI application. Such servers
include apache2 using mod_wsgi, or nginx using uwsgi.

This file has also been used with Passenger: http://www.modrails.com/

The hosted module provides a global named 'application'.

##################################################
For mod_wsgi

Your apache must be configured to use mod_wsgi.

Add the following to server config (this is a real virtual host,
the names have been changed...):

<VirtualHost *>
    ServerName barney.example.com
    AllowEncodedSlashes On
    Alias /static /home/barney/public_html/barney.example.com/static
    <Directory /home/barney/public_html/barney.example.com/static>
        Order allow,deny
        Allow from all
    </Directory>
    ErrorLog /var/log/apache2/barney.example.com-error.log
    CustomLog /var/log/apache2/barney.example.com-access.log combined
    WSGIDaemonProcess barney.example.com user=barney processes=1 threads=10
    WSGIProcessGroup barney.example.com
    WSGIPassAuthorization On
    WSGIScriptAlias /wiki /home/barney/tiddlywebs/barney.example.com/wsgiapp.py
</VirtualHost>

Replace barney.example.com with the hostname being used.
Replace barney with the user the process should run as.
Replace /wiki with the prefix to the tiddlyweb (often just '/').
Replace the path after /wiki with the path to apache.py which
    should live in in the tiddlyweb instance directory.

If you wish to use the http_basic extractor when using
mod_wsgi, you need to set

    WSGIPassAuthorization On

in the apache configuration.

For more mod_wsgi configuration info see:

    http://code.google.com/p/modwsgi/wiki/ConfigurationDirectives

##################################################

Information on using nginx and uwsgi can be found at:

    http://tiddlyweb.tiddlyspace.com/Using%20nginx%20and%20uwsgi
    http://tsdbup.tiddlyspace.com/WorkingNginxConfig

##################################################

In tiddlywebconfig.py:

    set server_prefix to the prefix above (/wiki)
    set server_host to the scheme, hostname and port being used
    set css_uri to a css file if you have one

server_host is a complex data structure as follows:

    'server_host': {
        'scheme': 'http',
        'host': 'some.example.com',
        'port': '80',
    }

##################################################

If you are using Passenger, thus far the only 
testing has been with Dreamhosts setup. For that
rename wsgiapp.py to passenger_wsgi.py and configure
as described here:

    http://wiki.dreamhost.com/Passenger_WSGI
"""

import os
import sys

# If on a hosting service with Passenger and you want to
# use a custom Python, you may uncomment the following. Change
# INTERP to your preferred Python.
#INTERP = "/home/osmosoft/bin/python"
#if sys.executable != INTERP: os.execl(INTERP, INTERP, *sys.argv)

# you may wish to change this path
# It can also be controlled from mod_wsgi config.
os.environ['PYTHON_EGG_CACHE'] = '/tmp'

def start():
    dirname = os.path.dirname(__file__)
    if sys.path[0] != dirname:
        sys.path.insert(0, dirname)
    from tiddlyweb.web import serve
    app = serve.load_app(app_prefix='', dirname=dirname)
    return app

# web server code will look for a callable named application
application = start()

########NEW FILE########
