__FILENAME__ = autobuild
'''
Script to generate PyMT API from source code.

Code is messy, but working.
Be careful if you change anything in !

'''

import os
import sys
import re
from glob import glob

os.environ['PYMT_SHADOW_WINDOW'] = '0'
import pymt
import pymt.graphics


# Directory of doc
base_dir = os.path.dirname(__file__)
dest_dir = os.path.join(base_dir, 'sources')
examples_framework_dir = os.path.join(base_dir, '..', 'examples', 'framework')

def writefile(filename, data):
    global dest_dir
    print 'write', filename
    f = os.path.join(dest_dir, filename)
    h = open(f, 'w')
    h.write(data)
    h.close()


# Activate PyMT modules
for k in pymt.pymt_modules.list().keys():
    pymt.pymt_modules.import_module(k)

# Search all pymt module
l = [(x, sys.modules[x], os.path.basename(sys.modules[x].__file__).rsplit('.', 1)[0]) for x in sys.modules if x.startswith('pymt') and sys.modules[x]]

# Extract packages from modules
packages = []
modules = {}
for name, module, filename in l:
    if filename == '__init__':
        packages.append(name)
    else:
        if hasattr(module, '__all__'):
            modules[name] = module.__all__
        else:
            modules[name] = [x for x in dir(module) if not x.startswith('__')]

packages.sort()

# Create index
api_index = \
'''===================================================================
API documentation for PyMT
===================================================================

.. toctree::

'''
for package in [x for x in packages if len(x.split('.')) <= 2]:
    api_index += "    api-%s.rst\n" % package

writefile('api-index.rst', api_index)

# Create index for all packages
template = \
'''==========================================================================================================
$SUMMARY
==========================================================================================================

$EXAMPLES_REF

.. automodule:: $PACKAGE
    :members:
    :show-inheritance:

.. toctree::

$EXAMPLES
'''

template_examples = \
'''.. _example-reference%d:

Examples
--------

%s
'''

template_examples_ref = \
'''# :ref:`Jump directly to Examples <example-reference%d>`'''

for package in packages:
    try:
        summary = [x for x in sys.modules[package].__doc__.split("\n") if len(x) > 1][0]
        try:
            title, content = summary.split(':', 1)
            summary = '**%s**: %s' % (title, content)
        except:
            pass
    except:
        summary = 'NO DOCUMENTATION (package %s)' % package
    t = template.replace('$SUMMARY', summary)
    t = t.replace('$PACKAGE', package)
    t = t.replace('$EXAMPLES', '')
    t = t.replace('$EXAMPLES_REF', '')

    # search packages
    for subpackage in packages:
        packagemodule = subpackage.rsplit('.', 1)[0]
        if packagemodule != package or len(subpackage.split('.')) <= 2:
            continue
        t += "    api-%s.rst\n" % subpackage

    # search modules
    m = modules.keys()
    m.sort()
    for module in m:
        packagemodule = module.rsplit('.', 1)[0]
        if packagemodule != package:
            continue
        t += "    api-%s.rst\n" % module

    writefile('api-%s.rst' % package, t)


# Create index for all module
m = modules.keys()
m.sort()
refid = 0
for module in m:
    try:
        summary = [x for x in sys.modules[module].__doc__.split("\n") if len(x) > 1][0]
        try:
            title, content = summary.split(':', 1)
            summary = '**%s**: %s' % (title, content)
        except:
            pass
    except:
        summary = 'NO DOCUMENTATION (module %s)' % module

    # search examples
    example_output = []
    example_prefix = module
    if module.startswith('pymt.'):
        example_prefix = module[5:]
    example_prefix = example_prefix.replace('.', '_')

    # try to found any example in framework directory
    list_examples = glob('%s*.py' % os.path.join(examples_framework_dir, example_prefix))
    for x in list_examples:
        # extract filename without directory
        xb = os.path.basename(x)

        # add a section !
        example_output.append('File :download:`%s <%s>` ::' % (
            xb, os.path.join('..', x)))

        # put the file in
        with open(x, 'r') as fd:
            d = fd.read().strip()
            d = '\t' + '\n\t'.join(d.split('\n'))
            example_output.append(d)

    t = template.replace('$SUMMARY', summary)
    t = t.replace('$PACKAGE', module)
    if len(example_output):
        refid += 1
        example_output = template_examples % (refid, '\n\n\n'.join(example_output))
        t = t.replace('$EXAMPLES_REF', template_examples_ref % refid)
        t = t.replace('$EXAMPLES', example_output)
    else:
        t = t.replace('$EXAMPLES_REF', '')
        t = t.replace('$EXAMPLES', '')
    writefile('api-%s.rst' % module, t)


# Generation finished
print 'Generation finished, do make html'

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# PyMT documentation build configuration file, created by
# sphinx-quickstart on Wed Jan 21 22:37:12 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed automatically).
#
# All configuration values have a default value; values that are commented out
# serve to show the default value.

import sys, os

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
#sys.path.append(os.path.abspath('some/directory'))

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# General substitutions.
project = 'PyMT'
copyright = '2009, pymt-dev'

# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
#
import os
os.environ['PYMT_DOC_INCLUDE'] = '1'
import pymt
print pymt.__file__

version = pymt.__version__
release = pymt.__version__

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directories, that shouldn't be searched
# for source files.
#exclude_dirs = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'default.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (within the static path) to place at the top of
# the sidebar.
html_logo = 'pymt-logo.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['.static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'PyMTdoc'


# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class [howto/manual]).
latex_documents = [
  ('index', 'PyMT.tex', 'PyMT Documentation',
   'pymt-dev', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = 3Ddrawing
from __future__ import with_statement

# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = '3D Painting'
PLUGIN_AUTHOR = 'Thomas Hansen'
PLUGIN_EMAIL = 'thomas.hansen@gmail.com'

import os
from pymt import *
from OpenGL.GL import *
from OpenGL.GLU import *

current_dir = os.path.dirname(__file__)
particle_fn = os.path.join(current_dir, 'particle.png')
set_brush(particle_fn, 10)

class GL3DPerspective:
    """
    Handy Class for use with python 'with' statement.
    on enter: sets the openGL pojection matrix to a standart perspective projection, enables, lighting, normalizing fo normals and depth test
    on exit: restores matrices and states to what they were before
    """
    def __init__(self, angle=60.0, aspect=4.0/3.0, near=1.0, far=100.0):
        self.angle = angle
        self.aspect = aspect
        self.near = near
        self.far = far

    def __enter__(self):
        glEnable(GL_LIGHTING)
        glEnable(GL_LIGHT0)
        glEnable(GL_NORMALIZE)
        glEnable(GL_DEPTH_TEST)

        glMatrixMode(GL_PROJECTION)
        glPushMatrix()
        glLoadIdentity()
        gluPerspective(self.angle,self.aspect , self.near, self.far)

        glMatrixMode(GL_MODELVIEW)
        glPushMatrix()
        glLoadIdentity()
        glTranslatef(0.0,0.0,-3.0)


    def __exit__(self, type, value, traceback):
        glMatrixMode(GL_MODELVIEW)
        glPopMatrix()
        glMatrixMode(GL_PROJECTION)
        glPopMatrix()
        glMatrixMode(GL_MODELVIEW)
        glDisable(GL_DEPTH_TEST)
        glDisable(GL_LIGHTING)
        glDisable(GL_LIGHT0)



class ModelPainter(MTWidget):

    def __init__(self, **kwargs):
        super(ModelPainter, self).__init__(**kwargs)

        #the persepctuve we use for drawing teh 3D world
        self.perspective = GL3DPerspective()

        #load the obj model file
        #set compat=False, mneans we have to setup lighting etc ourselves
        #but since we need to disable ligthing during picking, we need this here
        self.model = OBJ(os.path.join(current_dir, 'cow.obj'), compat=False)

        #texture and FBO used for picking
        self.picking_image = Image.load(os.path.join(current_dir, 'picking.png'))
        self.picking_texture = self.picking_image.get_texture()
        self.fbo = Fbo(size=self.size)
        self.painting_fbo = Fbo(size=(512,512))

        #initialize the painting buffer as white
        with self.painting_fbo:
            glClearColor(1,1,1,1)
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

        #stuff for rotating and keeping track of touches
        self.touch_position = {}
        self.rotation_matrix = None
        self.reset_rotation()
        self.touch1, self.touch2 = None, None
        self.zoom = 3.0

        self.mode = 'painting'
        self.has_moved = True


    def on_resize(self, w, h):
        del self.fbo
        self.fbo = Fbo(self.size)


    def reset_rotation(self):
        glMatrixMode(GL_MODELVIEW)
        glPushMatrix()
        glLoadIdentity()
        self.rotation_matrix = glGetFloatv(GL_MODELVIEW_MATRIX)
        glPopMatrix()


    def rotate_scene(self, x,y,z):
        glMatrixMode(GL_MODELVIEW)
        glPushMatrix()
        glLoadIdentity()
        glRotatef(z, 0,0,1)
        glRotatef(x, 0,1,0)
        glRotatef(y, 1,0,0)
        glMultMatrixf(self.rotation_matrix)
        self.rotation_matrix = glGetFloatv(GL_MODELVIEW_MATRIX)
        glPopMatrix()
        self.has_moved = True


    def on_draw(self):
        #draw into FBO
        glClearColor(0.3,0.6,0.3,0)
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        with DO(self.perspective, gx_texture(self.painting_fbo.texture)):
            self.draw()

        #display teh FBO contents
        glColor3f(1,1,1)
        #drawTexturedRectangle(self.fbo.texture, size=self.size)
        #drawTexturedRectangle(self.painting_fbo.texture, size=(256,256))
        #drawTexturedRectangle(self.picking_texture.id,pos=(256,0), size=(256,256))



    def draw(self):
        glMultMatrixf(self.rotation_matrix)
        glRotatef(90.0, 1,0,0)
        glScalef(self.zoom, self.zoom, self.zoom)
        glColor3f(1,1,1)
        self.model.draw()


    def draw_picking(self):
        glDisable(GL_LIGHTING)
        glColor3f(1,1,1)
        with gx_texture(self.picking_texture):
            self.draw()


    def pick(self, x,y):
        pick = None
        with self.fbo:
            if self.has_moved:
                glClearColor(0,0,0,0)
                glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
                with self.perspective:
                    self.draw_picking()
                self.has_moved = False
            pick = glReadPixels(int(x), int(y), 1, 1, GL_RGB, GL_UNSIGNED_BYTE)
            pick = map(ord, pick)
        return pick[0]*4, 1024 - pick[1]*4

    def paint(self, x, y):
        x,y =  self.pick(x,y)
        s = self.painting_fbo.size
        x /= 1024 / s[0]
        y /= 1024 / s[1]

        with self.painting_fbo:
            glColor3f(.1, .1, 0)
            drawCircle(pos=(x,y), radius=8)
            #paintLine([x,y,x,y])


    def on_touch_down(self, touch):
        self.touch_position[touch.id] = (touch.x, touch.y)

        #check if this touch should eb used to draw
        pick = self.pick(touch.x, touch.y)
        if pick[0] != 0 or pick[1] != 1024:
            touch.userdata['drawing'] = True
            return

        #if not, its going to be a touch that turns/scales the object
        touch.userdata['drawing'] = False
        if len(self.touch_position) == 1:
            self.touch1 = touch.id
        elif len(self.touch_position) == 2:
            self.touch1, self.touch2 = self.touch_position.keys()
            v1 = Vector(*self.touch_position[self.touch1])
            v2 = Vector(*self.touch_position[self.touch2])
            self.scale_dist = v1.distance(v2)




    def on_touch_move(self, touch):


        #if its one used to draw, but its now away from teh model
        #just dont do anything, until its back on teh model, or gone
        if touch.userdata.get('drawing'):
            pick = self.pick(touch.x, touch.y)
            #if its still on the model, draw on it
            if pick[0] != 0 or pick[1] != 1024:
                self.paint(touch.x, touch.y)
            return

        #if we got here, its a touch to turn/scale the model
        dx, dy, angle = 0,0,0
        #two touches:  scale and rotate around Z
        if  self.touch_position.has_key(self.touch1) and self.touch_position.has_key(self.touch2):
            v1 = Vector(*self.touch_position[self.touch1])
            v2 = Vector(*self.touch_position[self.touch2])

            #compute scale factor
            new_dist = v1.distance(v2)
            zoomfactor = new_dist/self.scale_dist
            self.zoom *= zoomfactor
            self.scale_dist = new_dist

            # compute rotation angle
            old_line = v1 - v2
            new_line = Vector(touch.x, touch.y) - v2
            if self.touch1 != touch.id: new_line = v1 - Vector(touch.x, touch.y)
            angle = -1.0 * old_line.angle(new_line)

        else: #only one touch:  rotate using trackball method
            dx = 200.0*(touch.x-self.touch_position[touch.id][0])/float(self.width)
            dy = 200.0*(touch.y-self.touch_position[touch.id][1])/float(self.height)

        #apply the transformations we just computed
        self.rotate_scene(dx,-dy, angle)
        self.touch_position[touch.id] = (touch.x, touch.y)


    def on_touch_up(self, touch):
        del self.touch_position[touch.id]








def pymt_plugin_activate(root, ctx):
    ctx.mp = ModelPainter(size=(root.width,root.height))
    root.add_widget(ctx.mp)

def pymt_plugin_deactivate(root, ctx):
    root.remove_widget(ctx.mp)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = 3Dviewer
from __future__ import with_statement

# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = '3D Viewer'
PLUGIN_AUTHOR = 'Thomas Hansen'
PLUGIN_EMAIL = 'thomas.hansen@gmail.com'

import os
from pymt import *
from OpenGL.GL import *
from OpenGL.GLU import *

current_dir = os.path.dirname(__file__)

class GLPerspectiveWidget(MTWidget):
    """Sets up 3d projection in on_draw function and then calls seld.draw, origin in the center"""
    def __init__(self, **kargs):
        super(GLPerspectiveWidget, self).__init__(**kargs)
        self.needs_redisplay = True
        self.fbo = Fbo(size=self.size)

    def on_resize(self, w, h):
        self.size = w, h
        del self.fbo
        self.fbo = Fbo(size=self.size)
        self.needs_redisplay = True

    def on_draw(self):
        if self.needs_redisplay:
            with self.fbo:
                self.draw3D()
        glColor3f(1,1,1)
        drawTexturedRectangle(self.fbo.texture, size=self.size)

    def draw3D(self):
        glPushAttrib(GL_VIEWPORT_BIT)
        glViewport(0,0,self.fbo.size[0], self.fbo.size[1])
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        glEnable(GL_LIGHTING)
        glEnable(GL_LIGHT0)
        glEnable(GL_NORMALIZE)
        glEnable(GL_DEPTH_TEST)

        glMatrixMode(GL_PROJECTION)
        glPushMatrix()
        glLoadIdentity()
        gluPerspective(60.,self.width/float(self.height) , 1., 100.)

        glMatrixMode(GL_MODELVIEW)
        glPushMatrix()
        glLoadIdentity()
        glTranslatef(0.0,0.0,-3.0)

        self.draw()

        glMatrixMode(GL_MODELVIEW)
        glPopMatrix()
        glMatrixMode(GL_PROJECTION)
        glPopMatrix()
        glMatrixMode(GL_MODELVIEW)
        glDisable(GL_DEPTH_TEST)
        glDisable(GL_LIGHTING)
        glDisable(GL_LIGHT0)
        glPopAttrib()
        self.needs_redisplay = False


class ModelViewer(GLPerspectiveWidget):
    def __init__(self, **kargs):
        GLPerspectiveWidget.__init__(self, **kargs)
        self.touch_position = {}
        self.model = bunny = OBJ(os.path.join(current_dir, 'monkey.obj'))
        self.rotation_matrix = None
        self.reset_rotation()
        self.touch1, self.touch2 = None, None
        self.zoom = 1.0


    def reset_rotation(self):
        glMatrixMode(GL_MODELVIEW)
        glPushMatrix()
        glLoadIdentity()
        self.rotation_matrix = glGetFloatv(GL_MODELVIEW_MATRIX)
        glPopMatrix()

    def draw(self):
        glMultMatrixf(self.rotation_matrix)
        #glRotatef(180.0, 0,0,1)
        glRotatef(90.0, 1,0,0)
        glScalef(self.zoom, self.zoom, self.zoom)
        self.model.draw()

    def check_touches(self, touches):
        if self.touch1 and not self.touch1 in touches:
            if self.touch1 in self.touch_position:
                del self.touch_position[self.touch1]
            self.touch1 = None
        if self.touch2 and not self.touch2 in touches:
            if self.touch2 in self.touch_position:
                del self.touch_position[self.touch2]
            self.touch2 = None

    def on_touch_down(self, touch):
        self.check_touches(getCurrentTouches())
        self.touch_position[touch.id] = (touch.x, touch.y)
        touch.grab(self)
        if len(self.touch_position) == 1:
            self.touch1 = touch
        elif len(self.touch_position) == 2:
            self.touch2 = touch
            if self.touch1 and self.touch2 and \
               self.touch1.id in self.touch_position and \
               self.touch2.id in self.touch_position:
                v1 = Vector(*self.touch_position[self.touch1.id])
                v2 = Vector(*self.touch_position[self.touch2.id])
                self.scale_dist = v1.distance(v2)

    def on_touch_move(self, touch):
        if not touch.grab_current == self:
            return
        self.check_touches(getCurrentTouches())
        dx, dy = 0,0
        scale = 1.0
        angle = 0.0
        if self.touch1 and self.touch2 and \
           self.touch1.id in self.touch_position and \
           self.touch2.id in self.touch_position:
            v1 = Vector(*self.touch_position[self.touch1.id])
            v2 = Vector(*self.touch_position[self.touch2.id])
            new_dist = v1.distance(v2)
            zoomfactor = new_dist/self.scale_dist
            if zoomfactor > 1.0:
                zoomfactor = 1.0 + (zoomfactor - 1.0) * 0.5
            else:
                zoomfactor = 1.0 - abs(1.0 - zoomfactor ) * 0.5
            self.zoom *= zoomfactor
            self.scale_dist = new_dist


            # compute rotation angle
            old_line = v1 - v2
            new_line = None
            if self.touch1.id == touch.id:
                new_line = Vector(touch.x, touch.y) - v2
            else:
                new_line = v1 - Vector(touch.x, touch.y)

            angle = -1.0 * old_line.angle(new_line)
        elif touch.id in self.touch_position:
            dx = 200.0*(touch.x-self.touch_position[touch.id][0])/float(self.width)
            dy = 200.0*(touch.y-self.touch_position[touch.id][1])/float(self.height)
        glMatrixMode(GL_MODELVIEW)
        glPushMatrix()
        glLoadIdentity()
        glRotatef(angle, 0,0,1)
        glRotatef(dx, 0,1,0)
        glRotatef(-dy, 1,0,0)
        glMultMatrixf(self.rotation_matrix)
        self.rotation_matrix = glGetFloatv(GL_MODELVIEW_MATRIX)
        glPopMatrix()
        if touch.id in self.touch_position:
            self.touch_position[touch.id] = (touch.x, touch.y)
            self.needs_redisplay = True

    def on_touch_up(self, touch):
        if not touch.grab_current == self:
            return
        self.check_touches(getCurrentTouches())
        if touch.id in self.touch_position:
            del self.touch_position[touch.id]
            self.needs_redisplay = True

def pymt_plugin_activate(root, ctx):
    ctx.mv = ModelViewer(size=(root.width,root.height))
    root.add_widget(ctx.mv)

def pymt_plugin_deactivate(root, ctx):
    root.remove_widget(ctx.mv)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = flowchart
# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'FlowChart'
PLUGIN_AUTHOR = 'Mathieu Virbel'
PLUGIN_DESCRIPTION = 'A test for doing some flowchart'

from pymt import *
from OpenGL.GL import GL_LINE_LOOP

flowcss = '''
flowchart {
    bg-color: rgba(255, 255, 255, 255);
}
flowtext {
    draw-background: 0;
    draw-border: 0;
    color: rgb(255, 255, 255);
}
'''
css_add_sheet(flowcss)


class FlowText(MTTextInput):
    def __init__(self, **kwargs):
        kwargs.setdefault('padding_x', 10)
        kwargs.setdefault('autosize', True)
        super(FlowText, self).__init__(**kwargs)
        self.orig = (0, 0)
        self.label_obj.options['font_size'] = self.height / 2.
        self.label_obj.refresh()

    def on_press(self, touch):
        self.orig = Vector(self.to_window(*touch.pos))

    def on_release(self, touch):
        final = Vector(self.to_window(*touch.pos))
        if self.orig.distance(final) <= 4:
            if not self.is_active_input:
                self.parent.disable_all()
            super(FlowText, self).on_release(touch)

    def on_touch_down(self, touch):
        super(FlowText, self).on_touch_down(touch)
        return False


class FlowElement(MTScatterWidget):
    def __init__(self, **kwargs):
        super(FlowElement, self).__init__(**kwargs)
        self.editmode = True
        self.label = FlowText(style={'font-size': self.height / 2.},
                              keyboard=kwargs.get('keyboard'))
        self.add_widget(self.label)

    def disable_all(self):
        self.parent.disable_all()

    def disable(self):
        self.label.hide_keyboard()

    def enable(self):
        self.label.show_keyboard()

    def draw(self):
        '''
        set_color(.509, .407, .403, .95)
        drawRoundedRectangle(size=self.size)
        set_color(.298, .184, .192, .95)
        drawRoundedRectangle(size=self.size, linewidth=2, style=GL_LINE_LOOP)
        '''
        self.width = max(100, self.label.width)
        set_color(.435, .749, .996)
        drawRoundedRectangle(size=self.size)
        set_color(.094, .572, .858)
        drawRoundedRectangle(size=self.size, linewidth=2, style=GL_LINE_LOOP)
        # 24 146 219 (black)
        # 111 191 254 (white)


class FlowLink(MTWidget):
    def __init__(self, **kwargs):
        super(FlowLink, self).__init__(**kwargs)
        self.node1 = kwargs.get('node1')
        self.node2 = kwargs.get('node2')

    def draw(self):
        if isinstance(self.node2, FlowElement):
            node2p = self.node2.center
        else:
            node2p = self.node2.pos
        ax, ay = self.to_widget(*self.to_window(*self.node1.center))
        if type(self.node2) == FlowElement:
            bx, by = self.to_widget(*self.to_window(*node2p))
        else: # touch case
            bx, by = self.parent.to_local(*node2p)
        set_color(.094, .572, .858)
        drawLine((ax, ay, bx, by), width=8. * self.parent.scale)


class FlowChart(MTScatterPlane):
    def __init__(self, **kwargs):
        kwargs.setdefault('do_rotation', False)
        kwargs.setdefault('scale_min', 0.2)
        kwargs.setdefault('scale_max', 1.0)
        super(FlowChart, self).__init__(**kwargs)
        self.keyboard = MTVKeyboard()
        self.show_ui_help = True
        self.inactivity_timer = 0

    def create_node(self, x, y):
        node = FlowElement(pos=(x, y), keyboard=self.keyboard)
        self.add_widget(node, front=True)
        return node

    def create_link(self, node1, node2):
        link = FlowLink(node1=node1, node2=node2)
        self.add_widget(link, front=False)
        return link

    def find_node(self, x, y):
        for c in self.children:
            if c.collide_point(x, y):
                return c

    def on_touch_down(self, touch):
        x, y = self.to_local(*touch.pos)
        self.show_ui_help = False
        self.inactivity_timer = 0
        if touch.is_double_tap:
            node = self.find_node(x, y)
            if node:
                touch.grab(self)
                link = self.create_link(node, touch)
                self.disable_all()
                touch.userdata['flow.link'] = link
            else:
                node = self.create_node(x - 50, y - 50)
                self.disable_all()
                node.enable()
            return True
        return super(FlowChart, self).on_touch_down(touch)

    def on_touch_up(self, touch):
        x, y = self.to_local(*touch.pos)
        if touch.grab_current == self and 'flow.link' in touch.userdata:
            link = touch.userdata['flow.link']
            node = self.find_node(x, y)
            if node is None or node == link.node1:
                self.remove_widget(link)
            else:
                link.node2 = node
        return super(FlowChart, self).on_touch_up(touch)


    def disable_all(self):
        for w in self.children:
            if type(w) != FlowElement:
                continue
            w.disable()

    def draw_ui(self):
        w = self.get_parent_window()
        drawLabel(label='-', pos=(w.width - 25, 25), font_size=40,
            color=(0, 0, 0, 50))
        drawLabel(label='+', pos=(w.width - 25, 250), font_size=40,
            color=(0, 0, 0, 50))
        set_color(0, 0, 0, .1)
        drawRoundedRectangle(pos=(w.width - 40, 40), size=(30, 175))
        set_color(0, 0, 0, .1)
        drawRoundedRectangle(pos=(w.width - 40, 40),
             size=(30, 175 * self.scale))

        self.inactivity_timer += getFrameDt()
        if self.inactivity_timer > 10:
            self.show_ui_help = True
        if self.show_ui_help:
            p = w.width / 2., 50
            c = (0, 0, 0, 180)
            fs = 22
            set_color(0, 0, 0, .1)
            w2 = (w.width - 750) / 2.
            drawRoundedRectangle(pos=(w2, 20), size=(w.width - w2 * 2, 140))
            drawLabel(label='Double-tap on background to create a node',
                      pos=p, color=c, font_size=24)
            p = w.width / 2., 90
            drawLabel(label='Double-tap & hold on a node to create a link',
                      pos=p, color=c, font_size=24)
            p = w.width / 2., 130
            drawLabel(label='Tap a node to toggle keyboard',
                      pos=p, color=c, font_size=24)

    def on_draw(self):
        w = self.get_parent_window()
        set_color(*self.style['bg-color'])
        drawRectangle(size=w.size)
        super(FlowChart, self).on_draw()
        self.draw_ui()

    def draw(self):
        w = self.get_parent_window()
        a = self.to_local(0, 0)
        b = self.to_local(w.width, w.height)
        scale = max(1, int(1 / self.scale))
        step = 200 * scale
        a = int(a[0] / step - 1) * step, int(a[1] / step - 1) * step
        b = int(b[0] / step + 1) * step, int(b[1] / step + 1) * step
        for x in xrange(a[0], b[0], step):
            for y in xrange(a[1], b[1], step):
                set_color(.9, .9, .9)
                drawLine((a[0], y, b[0], y), width=1)
                drawLine((x, a[1], x, b[1]), width=1)

def pymt_plugin_activate(root, ctx):
    ctx.flowchart = FlowChart()
    root.add_widget(ctx.flowchart)

def pymt_plugin_deactivate(root, ctx):
    root.remove_widget(ctx.flowchart)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = fridgeletter
import os
from pymt import *
from random import randint, random

# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Fridge letter'
PLUGIN_AUTHOR = 'Mathieu Virbel'
PLUGIN_DESCRIPTION = 'Original idea from leijou (see README for more info.)'

current_dir = os.path.dirname(__file__)

class FridgeLetterAtomic(MTDragable):
    def __init__(self, **kwargs):
        kwargs.setdefault('letter', 'A')
        kwargs.setdefault('color', (1, 0, 0, 1))
        super(FridgeLetterAtomic, self).__init__(**kwargs)

        self.letter = Label(
            font_name = os.path.join(current_dir, 'AlphaFridgeMagnets.ttf'),
            font_size = 48,
            bold = True,
            anchor_x = 'left',
            anchor_y = 'bottom',
            multiline = False,
            halign = 'top',
            color = kwargs.get('color'),
            label = kwargs.get('letter')
        )
        self.size = self.letter.content_width, self.letter.content_height

    def draw(self):
        self.letter.x, self.letter.y = self.pos
        self.letter.draw()

class FridgeLetter(MTWidget):
    def __init__(self, **kwargs):
        super(FridgeLetter, self).__init__(**kwargs)
        self.do_randomize = 1
        self.btn_clear = MTButton(label='Clear Fridge')
        self.btn_clear.push_handlers(on_press=self.clear)
        self.btn_more = MTButton(label='More letters')
        self.btn_more.push_handlers(on_press=self.createletters)
        self.btn_boum = MTButton(label='Boum !')
        self.btn_boum.push_handlers(on_press=self.randomize)
        self.buttons = MTBoxLayout()
        self.buttons.add_widget(self.btn_clear)
        self.buttons.add_widget(self.btn_more)
        self.buttons.add_widget(self.btn_boum)
        self.add_widget(self.buttons)
        self.createletters()

    def createletters(self, *largs):
        w = self.get_parent_window()
        for c in xrange(65, 91): # A-Z
            count = 1
            if chr(c) in 'AEUIO':
                count = 4
            for i in xrange(0, count):
                color = map(lambda x: x/255., (randint(100,255), randint(100,255), randint(100,255), 255))
                l = FridgeLetterAtomic(letter=chr(c), color=color)
                if w:
                    l.pos = randint(0, w.width), randint(0, w.height)
                self.add_widget(l)

    def clear(self, *largs):
        self.children.clear()
        self.add_widget(self.buttons)
        self.createletters()

    def randomize(self, *largs):
        w = self.get_parent_window()
        for letter in self.children:
            if letter == self.buttons:
                continue
            letter.do(Animation(pos=map(lambda x: x * random(), w.size),
                                f='ease_out_cubic', duration=.5))

    def draw(self):
        if self.do_randomize:
            self.randomize();
            self.do_randomize = 0

def pymt_plugin_activate(w, ctx):
    fl = FridgeLetter()
    w.add_widget(fl)

def pymt_plugin_deactivate(w, ctx):
    pass

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = gestures
# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Gesture tester'
PLUGIN_AUTHOR = 'Mathieu Virbel'
PLUGIN_DESCRIPTION = 'A tester of gesture'

from pymt import *

class CaptureGesture(MTGestureWidget):
    def __init__(self, gdb, bgcolor=(.4,.4,.4, .8)):
        super(CaptureGesture, self).__init__()
        self.gdb = gdb
        self.bgcolor = bgcolor
        self.lastgesture = None
        self.lastbest = None

    def on_touch_down(self, touch):
        if not self.collide_point(touch.x, touch.y):
            return
        super(CaptureGesture, self).on_touch_down(touch)

    def on_touch_move(self, touch):
        if not self.collide_point(touch.x, touch.y):
            return
        super(CaptureGesture, self).on_touch_move(touch)

    def on_touch_up(self, touch):
        super(CaptureGesture, self).on_touch_up(touch)
        if not self.collide_point(touch.x, touch.y):
            return

    def on_gesture(self, gesture, touch):
        # try to find gesture from database
        best = self.gdb.find(gesture, minscore=0.5)
        if not best:
            print 'No gesture found\nString version of your last gesture :\n', self.gdb.gesture_to_str(gesture)
        else:
            print 'Gesture found, score', best[0], ':', best[1].label
        self.lastgesture = gesture
        self.lastbest = best

    def draw(self):
        # draw background
        set_color(*self.bgcolor)
        drawRectangle(pos=self.pos, size=self.size)

        # draw current trace
        set_color(1,1,1)
        for trace in self.points:
            l = []
            for p in self.points[trace]:
                l.append(p[0])
                l.append(p[1])
            drawLine(l)

        # draw last gesture
        scoretext = ''
        if self.lastbest:
            if self.lastbest[0] < 0.8:
                set_color(1, 0.2, .2, .8)
                scoretext = 'bad'
            elif self.lastbest[0] < 0.9:
                set_color(1, 0.5, .0, .8)
                scoretext = 'medium'
            elif self.lastbest[0] < 0.95:
                set_color(0.2, 0.8, .2, .8)
                scoretext = 'good'
            else:
                set_color(0.2, 1, .2, .8)
                scoretext = 'excellent !'
        else:
            set_color(.3, .3, .3, .8)
        s = self.width * 0.1
        drawRectangle(pos=(self.pos[0], self.pos[1] + self.height), size=(s*2, s*2))
        set_color(1,1,1,.8)
        if self.lastgesture:
            l = []
            for p in self.lastgesture.strokes[0].points:
                l.append(self.pos[0] + s + p.x * s)
                l.append(self.pos[1] + s + self.height + p.y * s)
            drawLine(l)
            set_color(1,1,1,.4)
            l = []
            for p in self.lastgesture.strokes[0].screenpoints:
                l.append(p[0])
                l.append(p[1])
            drawLine(l)

        if self.lastbest:
            labeltext = 'Gesture found : %s' % self.lastbest[1].label
            labeltext2 = 'Score is %f, %s' % (self.lastbest[0], scoretext)
        else:
            labeltext = 'No gesture found'
            labeltext2 = ''
        drawLabel(label=labeltext, pos=(self.pos[0] + s*3, self.pos[1] + self.height + s * 0.8 + self.height * 0.07),
                font_size=self.height * 0.07, center=False)
        drawLabel(label=labeltext2, pos=(self.pos[0] + s*3, self.pos[1] + self.height + s * 0.7),
                font_size=self.height * 0.07, center=False)

class GestureUI(MTWidget):
    def __init__(self, gdb, **kwargs):
        super(GestureUI, self).__init__(**kwargs)
        self.gdb = gdb
        self.capture = CaptureGesture(gdb)
        self.add_widget(self.capture)
        self.title = MTLabel(label='Gesture Recognition', autosize=True,
                             font_size=42)
        self.add_widget(self.title)

    def on_draw(self):
        if not self.parent:
            return
        w, h = self.parent.size
        self.capture.pos = 0.1 * w, 0.1 * h
        self.capture.size = 0.8 * w, 0.5 * h
        self.title.font_size = h * 0.07
        self.title.pos = w/2-self.title.width/2, h - self.title.height - 20
        super(GestureUI, self).on_draw()

def pymt_plugin_activate(root, ctx):
    gdb = GestureDatabase()

    # Circle
    g = gdb.str_to_gesture('eNqllttqHEcURd/7R6SXiHO//IDzGtAHBMcWxsSJBkmG+O+zqzzqbkOSEkQIBma6dp86a5/L7efLtz9e7j49PL98fXrYfr5+Xmi7/Xjh7f7m+eXp8feH55vtItvtl4tut/944n4+tl1snHOcuzx+/vNlHItxLP/l2C/jqe1S41Tj1DccYNre0Z0Em4pIumoL5fZ8f/PX+JW3dz/RHbWyZVMkpUil6Pb82/v/fAnLvJNun17fkFTc5mRFZgWFT1d1fFsmJdyIIrxjLT4vzr6LXwMXs+a04kNcmqqKuJPYs8rX4jHF81Wc3ajS2zLcvfkkrmGqppZajltkrsVn8rlfxakCEXYZro30utmhbqRVotH4mQL5X6rLNJLwd/UBbqRdNTwqjCFzCh65IiSGiZAb3GsdvEymors8zrJ1tGoSqZ3FI0haQkIbzhrvXYlPpuK7OA6VWYwMmSR7nNSTI6sRvat76NoxMqFKHuoNM0AhBkO8x/9X7JOq9K4+wJVLwc2kqXISl4A/xYiMPLhrKa4Tqh5QTZtV0kzgdXD7wZBXs1SjZBtFuFSfTPVg6hQtrY6sRJfiakctpTZuFoCBJhFvSIxOqHpAdYORUxPSXv6DZbiaETSaA+rJON6gPqHqAdUL2YbX0cHg6D6l/UiJgm5yvUF9QtU+qcMXrt1ehhZ4LtXX/tKEemVBGEt5m1iNl/KjSSRMSq5gju4G56/VJ1Y7YQ2F9VwarhR423d1IRRBGvwo47W+zoxNqnai6sKS1Ggp3ZkRh3gHcMAqGYCasTakTah2gnqNGb7QMTtyF9dizA0UMHojAqA3iE+mdjC1rChCxMXoBNxH5OgxaL7oDLASUpTrQvVJ1E+FyoGxVIlPaoyHg6hzkjBAF5zYzusG5hOoH0AxkUsLZhlj2XOv05EwlC3DkoViM6RnLf59kTj1Xq5sVClzBDROgcM7yQqbq6CaZO1Enzz94MmY1lZXPyoPideUV2UKHCSGG+kbzOKTpx88MTKJUH8ocbTxqDpChzlhok4kpTAUfR16TKDB+7B2wZIRCWBowBx2hK5olZkH1jXQmEBjX5B47CnoitiAxNEk9dB2TJM2VBcyx3N1WmlPnrHvR4Mm+i1mg5OigupUn0zo8di/HPsfpspae/KMfT0SpzGNGp8eKYcyo5tHaZM7YpY1zJgwY9+NBJMM86Cxe5Hx7HpXbUZdQhcUUKSR64TkJJk7SbQUHQ0Ve2/BJnr0FDI0GthSQ3msY7xuhzlJ5k5SsVEVveaF8rTq4pWYS0g3aANr9Mz3+L+/eXn88vD0/s8PD9i70SqmJX7847GWX2P49fL0+PHrh5fxsG/vCtI06xVZb+x5w913fwPv4lI1')
    g.label = 'Circle'
    g.id = 'circle'
    gdb.add_gesture(g)

    # up_left, bottom_left, bottom_right, up_right
    g = gdb.str_to_gesture('eNqllt1qHEcQhe/nRaSbiPr/eQHlNqAHCI4tjIljLdo1xG+fMy1pZwRJesBiQRcz/U13nVOn+vbL6cdfl7vPj+fL9+fH5dfX/ydabj+deHm4OV+en/58PN8sJ1luv550uf3XFQ/jteVk6zrHutPTl2+XdVmsy/I/lv22vrWcal3VWPUDC5iWe7rjcDNSjzRLco3l/HDz9/qYl/tf6E5NNNRUIzKLupfzHx/+9yMs40y6fH75AnmmFVmTi3YGL+fPV3hac2hle9f6ZMYe52Z/YYNASeZJ2eySSl72M/QY9LzSuVQyvblTxVR0B1dhfFzUmBUbyDl9VJ/7SpcgIYqo6lAhlR2dwsK7M5PUXGRKl+Ek4Ssdp9ci9qD0orRd2aVDqL3SWVt9zh6Kil7ZxkYWJZImKDLFjk1NSkykanBUzP0iQ1PxI3QWLqdgZbeO9ckMPiSVPAInbqlwJm8qh2l0jh+aSu/wzekkWUkBV+YrHvQqQyt0MrFZQ5opXYemumlq0qZsWixJ1X6FC0cwtTiMg3Y70KU6NNWdpvCZd8Dl7vjMtU1Xq++feM+trkNS9QNw02TRNC9uPdSlOiTVPALPYmutKHPStgNlGYLqEUE9XKUKHhJ0aNR85zb0tE1PQWOyWrVRw5cZG7ypo6s7wnEqnTvdhqC2CYp6uhqRCPodwb7tPIhFQhHmwogCrzl8CGqboEyhbs5OTvCeblYMZitJIc7SlAPsoadteiI7sslYrNDiSCjZFA0UOlLVPaSreN6iNhS1fhtH2B57YVQYWI4w2Ngm4txOjdxC7M5r7kNQ5zc2qtqJXZWUoiq92/e7NEa6zNlDT7+OURw3U6OJMIZh6Z2cyt2Oo+CDEB15OmW/XB/8ja3vayKy+VA7KstKS53ogMl9yOl5ZaPxiBFWQoEZmrV15/vQyrmWPrT03mqiYW5laO2CKeInMiuGlrFpWeWckl0IV0GAXNn8bm6zz30SQ8vQORsZUy24JXkVHI75PIcPMcM3uGo1Jn70enlT20+4vc748LzkMeSMPEJvhkG0ROFvnIHnRowhaPQBOlIMzmyhslzTdr71HIrmpmgUkZm3YhbTGMDbfYtVMTcFGYAg5rnNc0iam6Tv7ski+3sopgM3it2yThMZ8PX3cHN5+vr4/OHbx0dcuNOGuej9H6/38dct/H56fvr0/eNlfdmX+7pDxFqs84fXARJr1t79A9YLUNw=')
    g.label = 'Square'
    g.id = 'square'
    gdb.add_gesture(g)

    # Up
    g = gdb.str_to_gesture('eNq1ltuO2jAQQN/zI/BSNPexf4C+VuIDqr2g1arbJQJW6v597YE4UHWbtigICQlnjh2fmbGXz/379+PqaXs4vu233efzbw/d8rHHbrM4HPe7b9vDouupW7703C1/G7GJx7peapyWuH73/HqsYVbD/IOwL/Wprk81Kpeo9xKA0K0/wcpYmABdhZNmc+sOm8WPOo7dGlagisoKyR0zZeDUHe7v/jgLUrwUd0/nKTShpQqXjESJCuJpoIPbMLUkYZmmx6ujjnSFnCwJISgZc76JbkH3kQ6OFK+eSNQqYqCLcUL1lMW57Bv8xc6EAMzz0CmSibDRpcQ1dwzgF3TMWQ0FYhiAp+lhlUarAkYK7VPGG53LegfbYOg+TQ+rpDPRwyqNVpkNXIYNuMgYSol9ECIuNs0Op5TnYHMY5dEo6Yf5gmp++rdMXJ7BaXoYZZ6JHkZZZ6KHUR6NYiK1oVySKF7QkTK39oMwnS8cTjnPQ5ewKqNVhAQgDaJDnZYhAEx2rlIvbVphOmskvArPxg+zMpqFXzpwsssJrurYVaf54VZ8Nn7YlbPdQACDD2eg5dZsKh/BuB1dWI6ySb6GX8XZ+OFXufGZWFo/zMnlNvzpbqEN70bQjgrLeLn7JWGolTRhms4eDbvqAx6p7E8rrbI/l/Qs0IqOPE/DQ63mWeAWXq15xeur0VVZ/Ts8pFqTikmT1mw/3QHkNngotaa05AvCsO5E5VAf4cQ+9jMux+s0PYxaM0qKJufFIYxH4H/SQ6k1peX+eJntOd1E93DqzSlDMqvkU7mC3kYPqd6kMkv21FoBT9Lrd7M47l62+7vXh225lZfirtkB1x+sl/bzGr72+93j28OxPqzdmkueYmk/XmKsXCprd7hf/QS75FeQ')
    g.label = 'Up'
    g.id = 'up'
    gdb.add_gesture(g)

    # NUI-wave
    g = gdb.str_to_gesture('eNq1lttqHEcURd/7R6SXiHO//IDzGtAHBMcehIljDZoxxH+f3eXRdCskKSVBQiDBTK2urnVqn3P76fjtt/Pdw+F0/vp0WH68/D3ScvvxyMv9zen89Pjr4XSzHGW5/XzU5fYvV9yPry1HW9c51h0fP305r8tiXZZ/s+yn9VvLsdZVjVXfsIBpefcD3UmIsXqGRlJY53K6v/l9/ZzH566cxmSqUe0kupx+ef+PT2EZL6XLw+URXKwq1i7lXVpAPPx3+nh19o0u5MJRZumcSv2/6DHoeaUTNyepKouWcOaOziWSLl3uphGvoA8B3N/pgFtpp6iZaZp3x0a3xosRNl1SRh0xpcsoJuFnOmN3wu6VUZQELRvccS6R3GQW4tVz+JAq+jbw4VT8Cs/I9GC8u7CY1A4O0xmc5WRUrjKHD6WSz3ARo5RmYm5D4fgGR2lSi7alkBK7zeHDqFyNimNnEa1Nirq0XakrXc5K2ztzvnEdPpVfwRbL9hRvL+eIVxS6Dp969SlM7kBHkDcV7SqRn5+I68TwPvepw6duPtk7rEhw5oqwsR1cu1DqzpZJXjo/ch0+Nd8GPnzqdkPd2bWf76Lnrs6pG06DqTWQPO5Tug2jxrt0+VP48g4f7mIlyS6pmllz/pBqW/Jie6nZRNGs1cq7w6GX4Ug0TxgbXm2XvZHF1YVcRAmOgB140OHDJI2MEXKa4a/Y/jBr+Vb44db6ihepkM5GRqnUNcLWo/GSwOlzw2+6zuE+1PqmFp2hJQm7L8LFtdjogT6oKCwRD0O6zS+UD7G+iUVOJSNQ0HbQemR3Moxgcyorx01FWs6t+vdhYrMqHdxAX0BpGzwzuUClxnXoeYb5UOqbUvQM5hDUZDRSfjsV8ZdGc84ePn3zyQj25nZDL0VHlR0cV9WIQGVBSPA8CGL4DH4b+NAZu3uajSpnU5BCBZlzpasrGhJhColgdL15KcbwGZtP5Na+FNVyo1fCaSG8DNNH1TzDYhiNa/ySWpWiYSIMRdE86wqHzn9XLTGMxpa+mLgK9XyZs1AvGxsdryoKyUmJf+fwHEZzOh6BHSh8YShJk5ael2IOoblNR425DU0jVD00a3cmUetIhD6uyN7ucffX3/ub8+Pnw9P7Lx8OGL5x51YMvfzhdTa/7ODn49Pjx68fzuuXfXlnd4FpBhdK1kMThD7Ad38A6q5S7Q==')
    g.label = 'NUI-wave'
    g.id = 'menu'
    gdb.add_gesture(g)

    #A (without cross-bar)
    g = gdb.str_to_gesture('eNq1lttu00AQQN/9I+0L1dwvPwCvSP0AxCWqKgq1miDB3zNeJ7a5lC0PTqImqXfOxnN2Z+f6fvzx5XRzdzievj0dhjfn9xGG608jDrdXx9PT4+fD8WoYabh+GHm4/mvEbRs2jDLFacWNj/dfT1OYTWH+TNjbadQwxhSVFfWjAhCG16/ghl2ckJIxU1U4huPt1ffpOrbrBmqU4c6WAOY6HD+8/+csSO2meLg7T7HAwRIx1Yfj3ZmuzkCIgY4WTEl9ert11JXOEYpOnkFoXNdXuoAgSRiYmCZEn26N7gsd6xdSZsxzBPNKl7RkIdK6JUg279ObAMyFDg7sLOaIpOkhW7zEf6aG2moinPFFJxclwyxuTmnaJL6+1X8u6YfAPr1pJd6J3rSSXujIhhLkBOjBFraBU4hqmjCp1ue+VWpWyfeBN6mUFzhpZSYcLACkWLjCqaZyZp13lHEfzk0p4z7wZpQXo6z1rO1pbGpW7jZwiEhwmVe8UH+tcxPKug+8CeVFaKUiuSjgyFKwjVB0iKpw5+RUGejDm1BehEpwurDG/FdzA1dRqa05T1E1sguXJlQWoSqJiX7ROq23BU64rS+RfXgTKotQg2dzjgANK16DsKpyH96Eiq5pSYFEQQ2GOjg22x9+r7v9/S/NqPhO9KZUFqVct2/IpS8Nqu5eyu4ER4QkZTB11xcY1WZUcRd2E6qLUHT562qpK4heRY2sZowa0/epcw+hu7CbTfVd2M2lZvccKniQVK0HiMQwesHetybTcB94s2lrY1SLYT74VZwD1lVeNVFq9xtBariiZL+aW/NpuhO9GbVNY+Q5t3MUptOyXuFpKlKlx1zEUfuNizWllrvAvSl1XBtGyd873jO8qExmUqkCpDrBuuxm1PutbrGryfsj5dPr9ur0+HB4ev/146G6bpe2tuDXB05N+fknvBufHj99+3iaBuvwWm/q4FSvZqtaVKiSOYFvfgJuKVKI')
    g.label = 'A (no cross-bar)'
    g.id = 'contextmenu'
    gdb.add_gesture(g)

    #X up_letf, bottom_right, top_right, bottom_left
    g = gdb.str_to_gesture('eNq1VttqHFcQfJ8fkV4s+n75Afk1oA8Iji2EiWMt2jXEf+86x6udSXAySoTFgmB3Tk2fqq7qvv54+PrH6ebh/nj68nS/vD3/P9By/eHAy93V8fT0+Pv98Wo5yHL96aDL9Q9P3M3HloONc45zh8ePn0/jWIxj+Q/HfhlPLYcapxqnvuIA03JLN0rRaZqhWekmthzvrv4cP/Ny+4ZuwiLYQtLFODt9Of727l9fwjLvpMvD9zeIFCBYVCOSvHM5PpzB3UzIuqqjO6RtH3xenP0ZnCusxQyvyGZqXcEts7VbKqW6m19QeUzwfAanCGJyofakSK1N6Sqpms5NTYb3v6D0yT73z0GX2UnCF3TyjHZPJg7z0uYVXkyJ8D1ol3JT2YefospZVECwUOpojm5L7ZQVnQrNBLHxQUuV0D7zMmUV/1nwU1jJFb4S93dJUZCvaWf4wZt2ZZYwwxXmQbEPP5WVvsADldukS4XImGSFTxKXMjzhqqW+T71OZZUv6MrtClEzGbZlXdG5DHqjl6IotGOfGZ266qorqE0rZwdFzlQrM+IQA1cipWQQU/vgU1VdVTXqaoVLnQilV6zgMGiUE37wthdIqlNSXSWVZBBaicZQJAnpK7CnnrrRE2dhUAaniDES+//YNtW0VU3EAJrFuxGwhUToV5BiU01b1YTLxc1RdilC1hAmr4GfetoavlQYCSg+3CtktNszdCUcrCyiaKawfQ/Z1NNyL9iH0BAD9mxDDiSPebKHPfW0S/JKob7sptJw5F9vepww4pC9LRyktp+7PvX0S+4qIBBbYERdi3LDCQliBWOuNMHVuNEe9pTT10lqsLYaI0EUTW65Gn/YPTFMkYnerPuc+PcNYtXScV2sAKRu4bmdFkRIkxFj4RjgmKgvyBWfcvo6SjtYGd1YiKhEM24GNWH/QJcmVScumLyfLD4V9XWWGjcbo3a2wj7hm1nK/3mDialpbDzKSPJA1xhsIgKCN7OUqzFBysAgyM/eh5+yxsalTcHesCL4xbKCfl3hG50+8ixHr3Ptz4uYysZmliKriwkxQGh6uQy7kfYBf2IDSeQl9sDa92lMYWOTu6gQVSO4YJcxOjcb2OAbPoA6ngYR9tGnrrFJ3sZ64hLCWE6hYW+Wx7+15b6fcuqam0lqCjsSvAT2kZXb1dRDMGURcHiDIW/20aesqZtphwmH1TMZmwbyZLPD/HCrHp+7q9Pjp/und5/f32MHh1TT3H/947Gin2v49fD0+OHL+9N42JdbHz4eaT5gDWoD9+YbKhZUkQ==')
    g.label = 'X'
    g.id = 'close'
    gdb.add_gesture(g)

    ctx.ui = GestureUI(gdb)
    root.add_widget(ctx.ui)

def pymt_plugin_deactivate(root, ctx):
    root.remove_widget(ctx.ui)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = ibar
#! /usr/bin/python
# Original Ibar from kaswy
# Website http://kaswy.free.fr

from random import random
from pymt import *

class PaintWidget(MTWidget):
    def __init__(self, **kwargs):
        super(PaintWidget, self).__init__(**kwargs)
        self.touch_positions = {}

    def on_draw(self):
        for p in self.touch_positions:
            for pos in self.touch_positions[p][len(self.touch_positions[p])-1:]:
                set_color(0.5,0,0.8)
                drawCircle((pos[0],pos[1]),25)
                for p in self.touch_positions:
                    for pos2 in self.touch_positions[p][len(self.touch_positions[p])-1:]:
                        err = 30
                        set_color(random()-0.1,0,random()+0.4)
                        drawLine((pos[0]+err*(random()-random()),pos[1]+err*(random()-random()),pos2[0]+err*(random()-random()),pos2[1]+err*(random()-random())), 15*random())

    def on_touch_down(self, touch):
        self.touch_positions[touch.id] = [(touch.x,touch.y)]

    def on_touch_move(self, touch):
        global ox
        global oy
        if (touch.x != ox) or (touch.y != oy):
            ox,oy = touch.x,touch.y
            self.touch_positions[touch.id].append((touch.x,touch.y))

    def on_touch_up(self, touch):
        del self.touch_positions[touch.id]

ox=oy=0
w = MTWindow()
w.add_widget(PaintWidget())

runTouchApp()

########NEW FILE########
__FILENAME__ = mandelbrot
import OpenGL
#OpenGL.FULL_LOGGING = True

# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Mandelbrot Viewer'
PLUGIN_AUTHOR = 'Thomas Hansen'
PLUGIN_DESCRIPTION = 'Uses a fragment shader to draw the mandelbrot set, so you can just keep zooming and zooming and zoomming :)'




#The shader source to draw the mandelbrot set is taken from the TyphonLab Tutorial on Advanced OpenGl shaders
#http://www.opengl.org/sdk/docs/tutorials/TyphoonLabs/Chapter_4.pdf

vertex_shader_src = """
varying vec3 position;

void main()
{
    position = vec3(gl_MultiTexCoord0 - 0.5) * 5.0;
    gl_Position = ftransform();
}
"""

fragment_shader_src = """
varying vec3 position;
uniform int maxIterations;
uniform float zoom;

void main()
{
    vec2 center = vec2(-0.65,0);
    vec3 outerColor1 = vec3(0.0,0.2,0.7);
    vec3 outerColor2 = vec3(1.0,1.0,1.0);

    float real = position.x * (1.0/zoom) + center.x;
    float imag = position.y * (1.0/zoom) + center.y;
    float cReal = real;
    float cImag = imag;
    float r2 = 0.0;

    int iter;
    for (iter = 0; iter < maxIterations && r2 < 4.0; ++iter)
    {
        float tempreal = real;
        real = (tempreal * tempreal) - (imag * imag) + cReal;
        imag = 2.0 * tempreal * imag + cImag;
        r2 = real*real;  // this line is missing in the tutorial
    }

    vec3 color;
    if (r2 < 4.0)
        color = vec3(0.1,0.0,0.0);
    else{
        float intensity = float(iter) + 1.0 -  (( log( log( sqrt(r2) ) )/log(2.0)  )  /log(2.0));
        float val = float(intensity)*0.02;
        if (mod(val,2.0) < 1.0){
            color = mix(outerColor1, outerColor2, fract(float(intensity)*0.02));
        }else{
            color = mix(outerColor2, outerColor1, fract(float(intensity)*0.02));
        }

    }
    gl_FragColor = vec4 (clamp(color, 0.0, 1.0), 1.0);
}
"""




from pymt import *
from OpenGL.GL import *




class MandelbrotViewer(MTScatterWidget):
    """ Mandelbrot viewer.   Draws a square and uses a Shader to draw the mandelbrot set on it """
    def __init__(self, **kwargs):
        super(MandelbrotViewer, self).__init__(**kwargs)
        self.shader = Shader(vertex_shader_src, fragment_shader_src)
        self.zoom = 1.8
        self.iterations = 100

    def draw(self):
        w,h = self.size
        self.shader.use()
        self.shader['zoom'] = self.zoom
        self.shader['maxIterations'] = self.iterations
        drawTexturedRectangle(None, size=(w,h))
        self.shader.stop()


def update_iterations(viewer, label, value):
    # simple callback function for the slider on_value_changed event.
    # sets iterations on mandelbrot viewer and uopates text label
    viewer.iterations = int(value)
    label.label = "Number of iterations: "+str(int(value))


def pymt_plugin_activate(w, ctx):
    # crerate a widget and put the mandelbrot viwer inside it
    #( otherwise the touchsimulator draws teh cuircles underneath?!  probably a bug)
    root = MTWidget()
    mbviewer = MandelbrotViewer(size=(512,512))
    root.add_widget(mbviewer)

    #create a label and a slider for setting the number of iterations
    label = MTLabel(label="Number of iterations: 50", pos=(10,50), autosize=True)
    slider = MTSlider(orientation='horizontal', min=25, max=250, value=100, size=(w.width-20, 30), pos=(10,10))

    # attach the event handler to the slider
    # uses curry to save the firt two arguments, since this is where we have the refernce to them
    # and the on_value_changed event only provides on argument ('value')
    callback = curry(update_iterations, mbviewer, label)
    slider.push_handlers(on_value_change=callback)

    # add the widgets to the window
    w.add_widget(root)
    w.add_widget(label)
    w.add_widget(slider)


def pymt_plugin_deactivate(w, ctx):
    w.children = []



#so you can run it as a standalone app
if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = stylus
from pymt import *

class Painter(MTWidget):
    def __init__(self, **kwargs):
        super(Painter, self).__init__(**kwargs)
        self.lines = []

    def on_touch_down(self, touch):
        if touch.device == 'wm_pen':
            touch.userdata['line'] = list(touch.pos)
            self.lines.append( touch.userdata['line'] )
            return True

    def on_touch_move(self, touch):
        if touch.device == 'wm_pen':
            touch.userdata['line'].extend(touch.pos)
            return True


    def draw(self):
        for line in self.lines:
            set_color(1,1,1,.9)
            drawLine(line, width=5)

scatter = MTScatterPlane()
scatter.add_widget(Painter())

runTouchApp(scatter)

########NEW FILE########
__FILENAME__ = start
import sys
import twitter
import random
import textwrap
from pymt import *

#Spawn Multi-Touch Window
w = MTWindow(fullscreen=True)
sz = w.size

#Exit Button
exitButton = MTButton(label="X", pos=(sz[0]-30, sz[1]-30), size=(30, 30))
w.add_widget(exitButton)

@exitButton.event
def on_press(*largs):
	sys.exit()

#Create Twitter API interface and login
api = twitter.Api(username=sys.argv[1], password=sys.argv[2])

#Place Everything On a Kinetic Scatter Plane
k = MTKinetic()
w.add_widget(k)

p = MTScatterPlane()
k.add_widget(p)

#Generate and Load Friend List
FriendListScatter = MTScatterWidget(size=(500, 500))
p.add_widget(FriendListScatter)

friendList = MTKineticList(searchable=False, deletable=False, size=(400, 500), pos=(50,0), title="Friends")
FriendListScatter.add_widget(friendList)

twitFriends = api.GetFriends()
for f in twitFriends:
	un = f.name.encode('ASCII', 'replace')
	friendList.add_widget(MTKineticItem(label=un, size=(350, 50)))

#Load Firends Timeline Based on Selection From Friend List
@friendList.event
def on_press(item, callback):
	FriendTimelineScatter = MTScatterWidget(size=(500, 500))
	p.add_widget(FriendTimelineScatter)

	FriendTimelineList = MTKineticList(searchable=False, deletable=False, size=(400, 500), pos=(50, 0), title=callback.name)
	FriendTimelineScatter.add_widget(FriendTimelineList)

	TimelineExitButton = MTButton(label='X', pos=(450, 450), size=(50, 50), font_size=20)
	FriendTimelineScatter.add_widget(TimelineExitButton)

	FriendTimelineItems = api.GetUserTimeline(callback.id)
	for s in FriendTimelineItems:
		us = s.text.encode('ASCII', 'replace')
		FriendTimelineList.add_widget(MTKineticItem(label=us, size=(390, 50), multiline=True, width=300))


	@TimelineExitButton.event
	def on_press(*largs):
		p.remove_widget(FriendTimelineScatter)

#Status Update Window
statusInput = MTTextInput()
w.add_widget(statusInput)

@statusInput.event
def on_text_validate():
	if len(statusInput.label) > 140:
		statusPostError = MTModalPopup(title="ERROR!", content="Warning, your status update is larger than 140 characters, please shorten your post.", size=(300, 150))
		w.add_widget(statusPostError)
	else:
		api.PostUpdate(statusInput.label)
		statusPostSucess = MTModalPopup(title="SUCESS!", content="Your post has been successfully sent to twitter.")
		w.add_widget(statusPostSucess)
		statusInput.label = ""

runTouchApp()

########NEW FILE########
__FILENAME__ = twitter
#!/usr/bin/python
#
# Copyright 2007 Google Inc. All Rights Reserved.

'''A library that provides a python interface to the Twitter API'''

__author__ = 'dewitt@google.com'
__version__ = '0.5'


import base64
import md5
import os
import simplejson
import sys
import tempfile
import time
import urllib
import urllib2
import urlparse
import twitter

class TwitterError(Exception):
  '''Base class for Twitter errors'''


class Status(object):
  '''A class representing the Status structure used by the twitter API.

  The Status structure exposes the following properties:

    status.created_at
    status.created_at_in_seconds # read only
    status.id
    status.text
    status.relative_created_at # read only
    status.user
  '''
  def __init__(self,
               created_at=None,
               id=None,
               text=None,
               user=None,
               now=None):
    '''An object to hold a Twitter status message.

    This class is normally instantiated by the twitter.Api class and
    returned in a sequence.

    Note: Dates are posted in the form "Sat Jan 27 04:17:38 +0000 2007"

    Args:
      created_at: The time this status message was posted
      id: The unique id of this status message
      text: The text of this status message
      relative_created_at:
        A human readable string representing the posting time
      user:
        A twitter.User instance representing the person posting the message
      now:
        The current time, if the client choses to set it.  Defaults to the
        wall clock time.
    '''
    self.created_at = created_at
    self.id = id
    self.text = text
    self.user = user
    self.now = now

  def GetCreatedAt(self):
    '''Get the time this status message was posted.

    Returns:
      The time this status message was posted
    '''
    return self._created_at

  def SetCreatedAt(self, created_at):
    '''Set the time this status message was posted.

    Args:
      created_at: The time this status message was created
    '''
    self._created_at = created_at

  created_at = property(GetCreatedAt, SetCreatedAt,
                        doc='The time this status message was posted.')

  def GetCreatedAtInSeconds(self):
    '''Get the time this status message was posted, in seconds since the epoch.

    Returns:
      The time this status message was posted, in seconds since the epoch.
    '''
    return time.mktime(time.strptime(self.created_at, '%a %b %d %H:%M:%S +0000 %Y'))

  created_at_in_seconds = property(GetCreatedAtInSeconds,
                                   doc="The time this status message was "
                                       "posted, in seconds since the epoch")

  def GetId(self):
    '''Get the unique id of this status message.

    Returns:
      The unique id of this status message
    '''
    return self._id

  def SetId(self, id):
    '''Set the unique id of this status message.

    Args:
      id: The unique id of this status message
    '''
    self._id = id

  id = property(GetId, SetId,
                doc='The unique id of this status message.')

  def GetText(self):
    '''Get the text of this status message.

    Returns:
      The text of this status message.
    '''
    return self._text

  def SetText(self, text):
    '''Set the text of this status message.

    Args:
      text: The text of this status message
    '''
    self._text = text

  text = property(GetText, SetText,
                  doc='The text of this status message')

  def GetRelativeCreatedAt(self):
    '''Get a human redable string representing the posting time

    Returns:
      A human readable string representing the posting time
    '''
    fudge = 1.25
    delta  = int(self.now) - int(self.created_at_in_seconds)

    if delta < (1 * fudge):
      return 'about a second ago'
    elif delta < (60 * (1/fudge)):
      return 'about %d seconds ago' % (delta)
    elif delta < (60 * fudge):
      return 'about a minute ago'
    elif delta < (60 * 60 * (1/fudge)):
      return 'about %d minutes ago' % (delta / 60)
    elif delta < (60 * 60 * fudge):
      return 'about an hour ago'
    elif delta < (60 * 60 * 24 * (1/fudge)):
      return 'about %d hours ago' % (delta / (60 * 60))
    elif delta < (60 * 60 * 24 * fudge):
      return 'about a day ago'
    else:
      return 'about %d days ago' % (delta / (60 * 60 * 24))

  relative_created_at = property(GetRelativeCreatedAt,
                                 doc='Get a human readable string representing'
                                     'the posting time')

  def GetUser(self):
    '''Get a twitter.User reprenting the entity posting this status message.

    Returns:
      A twitter.User reprenting the entity posting this status message
    '''
    return self._user

  def SetUser(self, user):
    '''Set a twitter.User reprenting the entity posting this status message.

    Args:
      user: A twitter.User reprenting the entity posting this status message
    '''
    self._user = user

  user = property(GetUser, SetUser,
                  doc='A twitter.User reprenting the entity posting this '
                      'status message')

  def GetNow(self):
    '''Get the wallclock time for this status message.

    Used to calculate relative_created_at.  Defaults to the time
    the object was instantiated.

    Returns:
      Whatever the status instance believes the current time to be,
      in seconds since the epoch.
    '''
    if self._now is None:
      self._now = time.mktime(time.gmtime())
    return self._now

  def SetNow(self, now):
    '''Set the wallclock time for this status message.

    Used to calculate relative_created_at.  Defaults to the time
    the object was instantiated.

    Args:
      now: The wallclock time for this instance.
    '''
    self._now = now

  now = property(GetNow, SetNow,
                 doc='The wallclock time for this status instance.')


  def __ne__(self, other):
    return not self.__eq__(other)

  def __eq__(self, other):
    try:
      return other and \
             self.created_at == other.created_at and \
             self.id == other.id and \
             self.text == other.text and \
             self.user == other.user
    except AttributeError:
      return False

  def __str__(self):
    '''A string representation of this twitter.Status instance.

    The return value is the same as the JSON string representation.

    Returns:
      A string representation of this twitter.Status instance.
    '''
    return self.AsJsonString()

  def AsJsonString(self):
    '''A JSON string representation of this twitter.Status instance.

    Returns:
      A JSON string representation of this twitter.Status instance
   '''
    return simplejson.dumps(self.AsDict(), sort_keys=True)

  def AsDict(self):
    '''A dict representation of this twitter.Status instance.

    The return value uses the same key names as the JSON representation.

    Return:
      A dict representing this twitter.Status instance
    '''
    data = {}
    if self.created_at:
      data['created_at'] = self.created_at
    if self.id:
      data['id'] = self.id
    if self.text:
      data['text'] = self.text
    if self.user:
      data['user'] = self.user.AsDict()
    return data

  @staticmethod
  def NewFromJsonDict(data):
    '''Create a new instance based on a JSON dict.

    Args:
      data: A JSON dict, as converted from the JSON in the twitter API
    Returns:
      A twitter.Status instance
    '''
    if 'user' in data:
      user = User.NewFromJsonDict(data['user'])
    else:
      user = None
    return Status(created_at=data.get('created_at', None),
                  id=data.get('id', None),
                  text=data.get('text', None),
                  user=user)


class User(object):
  '''A class representing the User structure used by the twitter API.

  The User structure exposes the following properties:

    user.id
    user.name
    user.screen_name
    user.location
    user.description
    user.profile_image_url
    user.url
    user.status
  '''
  def __init__(self,
               id=None,
               name=None,
               screen_name=None,
               location=None,
               description=None,
               profile_image_url=None,
               url=None,
               status=None):
    self.id = id
    self.name = name
    self.screen_name = screen_name
    self.location = location
    self.description = description
    self.profile_image_url = profile_image_url
    self.url = url
    self.status = status


  def GetId(self):
    '''Get the unique id of this user.

    Returns:
      The unique id of this user
    '''
    return self._id

  def SetId(self, id):
    '''Set the unique id of this user.

    Args:
      id: The unique id of this user.
    '''
    self._id = id

  id = property(GetId, SetId,
                doc='The unique id of this user.')

  def GetName(self):
    '''Get the real name of this user.

    Returns:
      The real name of this user
    '''
    return self._name

  def SetName(self, name):
    '''Set the real name of this user.

    Args:
      name: The real name of this user
    '''
    self._name = name

  name = property(GetName, SetName,
                  doc='The real name of this user.')

  def GetScreenName(self):
    '''Get the short username of this user.

    Returns:
      The short username of this user
    '''
    return self._screen_name

  def SetScreenName(self, screen_name):
    '''Set the short username of this user.

    Args:
      screen_name: the short username of this user
    '''
    self._screen_name = screen_name

  screen_name = property(GetScreenName, SetScreenName,
                         doc='The short username of this user.')

  def GetLocation(self):
    '''Get the geographic location of this user.

    Returns:
      The geographic location of this user
    '''
    return self._location

  def SetLocation(self, location):
    '''Set the geographic location of this user.

    Args:
      location: The geographic location of this user
    '''
    self._location = location

  location = property(GetLocation, SetLocation,
                      doc='The geographic location of this user.')

  def GetDescription(self):
    '''Get the short text description of this user.

    Returns:
      The short text description of this user
    '''
    return self._description

  def SetDescription(self, description):
    '''Set the short text description of this user.

    Args:
      description: The short text description of this user
    '''
    self._description = description

  description = property(GetDescription, SetDescription,
                         doc='The short text description of this user.')

  def GetUrl(self):
    '''Get the homepage url of this user.

    Returns:
      The homepage url of this user
    '''
    return self._url

  def SetUrl(self, url):
    '''Set the homepage url of this user.

    Args:
      url: The homepage url of this user
    '''
    self._url = url

  url = property(GetUrl, SetUrl,
                 doc='The homepage url of this user.')

  def GetProfileImageUrl(self):
    '''Get the url of the thumbnail of this user.

    Returns:
      The url of the thumbnail of this user
    '''
    return self._profile_image_url

  def SetProfileImageUrl(self, profile_image_url):
    '''Set the url of the thumbnail of this user.

    Args:
      profile_image_url: The url of the thumbnail of this user
    '''
    self._profile_image_url = profile_image_url

  profile_image_url= property(GetProfileImageUrl, SetProfileImageUrl,
                              doc='The url of the thumbnail of this user.')

  def GetStatus(self):
    '''Get the latest twitter.Status of this user.

    Returns:
      The latest twitter.Status of this user
    '''
    return self._status

  def SetStatus(self, status):
    '''Set the latest twitter.Status of this user.

    Args:
      status: The latest twitter.Status of this user
    '''
    self._status = status

  status = property(GetStatus, SetStatus,
                  doc='The latest twitter.Status of this user.')

  def __ne__(self, other):
    return not self.__eq__(other)

  def __eq__(self, other):
    try:
      return other and \
             self.id == other.id and \
             self.name == other.name and \
             self.screen_name == other.screen_name and \
             self.location == other.location and \
             self.description == other.description and \
             self.profile_image_url == other.profile_image_url and \
             self.url == other.url and \
             self.status == other.status
    except AttributeError:
      return False

  def __str__(self):
    '''A string representation of this twitter.User instance.

    The return value is the same as the JSON string representation.

    Returns:
      A string representation of this twitter.User instance.
    '''
    return self.AsJsonString()

  def AsJsonString(self):
    '''A JSON string representation of this twitter.User instance.

    Returns:
      A JSON string representation of this twitter.User instance
   '''
    return simplejson.dumps(self.AsDict(), sort_keys=True)

  def AsDict(self):
    '''A dict representation of this twitter.User instance.

    The return value uses the same key names as the JSON representation.

    Return:
      A dict representing this twitter.User instance
    '''
    data = {}
    if self.id:
      data['id'] = self.id
    if self.name:
      data['name'] = self.name
    if self.screen_name:
      data['screen_name'] = self.screen_name
    if self.location:
      data['location'] = self.location
    if self.description:
      data['description'] = self.description
    if self.profile_image_url:
      data['profile_image_url'] = self.profile_image_url
    if self.url:
      data['url'] = self.url
    if self.status:
      data['status'] = self.status.AsDict()
    return data

  @staticmethod
  def NewFromJsonDict(data):
    '''Create a new instance based on a JSON dict.

    Args:
      data: A JSON dict, as converted from the JSON in the twitter API
    Returns:
      A twitter.User instance
    '''
    if 'status' in data:
      status = Status.NewFromJsonDict(data['status'])
    else:
      status = None
    return User(id=data.get('id', None),
                name=data.get('name', None),
                screen_name=data.get('screen_name', None),
                location=data.get('location', None),
                description=data.get('description', None),
                profile_image_url=data.get('profile_image_url', None),
                url=data.get('url', None),
                status=status)

class DirectMessage(object):
  '''A class representing the DirectMessage structure used by the twitter API.

  The DirectMessage structure exposes the following properties:

    direct_message.id
    direct_message.created_at
    direct_message.created_at_in_seconds # read only
    direct_message.sender_id
    direct_message.sender_screen_name
    direct_message.recipient_id
    direct_message.recipient_screen_name
    direct_message.text
  '''

  def __init__(self,
               id=None,
               created_at=None,
               sender_id=None,
               sender_screen_name=None,
               recipient_id=None,
               recipient_screen_name=None,
               text=None):
    '''An object to hold a Twitter direct message.

    This class is normally instantiated by the twitter.Api class and
    returned in a sequence.

    Note: Dates are posted in the form "Sat Jan 27 04:17:38 +0000 2007"

    Args:
      id: The unique id of this direct message
      created_at: The time this direct message was posted
      sender_id: The id of the twitter user that sent this message
      sender_screen_name: The name of the twitter user that sent this message
      recipient_id: The id of the twitter that received this message
      recipient_screen_name: The name of the twitter that received this message
      text: The text of this direct message
    '''
    self.id = id
    self.created_at = created_at
    self.sender_id = sender_id
    self.sender_screen_name = sender_screen_name
    self.recipient_id = recipient_id
    self.recipient_screen_name = recipient_screen_name
    self.text = text

  def GetId(self):
    '''Get the unique id of this direct message.

    Returns:
      The unique id of this direct message
    '''
    return self._id

  def SetId(self, id):
    '''Set the unique id of this direct message.

    Args:
      id: The unique id of this direct message
    '''
    self._id = id

  id = property(GetId, SetId,
                doc='The unique id of this direct message.')

  def GetCreatedAt(self):
    '''Get the time this direct message was posted.

    Returns:
      The time this direct message was posted
    '''
    return self._created_at

  def SetCreatedAt(self, created_at):
    '''Set the time this direct message was posted.

    Args:
      created_at: The time this direct message was created
    '''
    self._created_at = created_at

  created_at = property(GetCreatedAt, SetCreatedAt,
                        doc='The time this direct message was posted.')

  def GetCreatedAtInSeconds(self):
    '''Get the time this direct message was posted, in seconds since the epoch.

    Returns:
      The time this direct message was posted, in seconds since the epoch.
    '''
    return time.mktime(time.strptime(self.created_at, '%a %b %d %H:%M:%S +0000 %Y'))

  created_at_in_seconds = property(GetCreatedAtInSeconds,
                                   doc="The time this direct message was "
                                       "posted, in seconds since the epoch")

  def GetSenderId(self):
    '''Get the unique sender id of this direct message.

    Returns:
      The unique sender id of this direct message
    '''
    return self._sender_id

  def SetSenderId(self, sender_id):
    '''Set the unique sender id of this direct message.

    Args:
      sender id: The unique sender id of this direct message
    '''
    self._sender_id = sender_id

  sender_id = property(GetSenderId, SetSenderId,
                doc='The unique sender id of this direct message.')

  def GetSenderScreenName(self):
    '''Get the unique sender screen name of this direct message.

    Returns:
      The unique sender screen name of this direct message
    '''
    return self._sender_screen_name

  def SetSenderScreenName(self, sender_screen_name):
    '''Set the unique sender screen name of this direct message.

    Args:
      sender_screen_name: The unique sender screen name of this direct message
    '''
    self._sender_screen_name = sender_screen_name

  sender_screen_name = property(GetSenderScreenName, SetSenderScreenName,
                doc='The unique sender screen name of this direct message.')

  def GetRecipientId(self):
    '''Get the unique recipient id of this direct message.

    Returns:
      The unique recipient id of this direct message
    '''
    return self._recipient_id

  def SetRecipientId(self, recipient_id):
    '''Set the unique recipient id of this direct message.

    Args:
      recipient id: The unique recipient id of this direct message
    '''
    self._recipient_id = recipient_id

  recipient_id = property(GetRecipientId, SetRecipientId,
                doc='The unique recipient id of this direct message.')

  def GetRecipientScreenName(self):
    '''Get the unique recipient screen name of this direct message.

    Returns:
      The unique recipient screen name of this direct message
    '''
    return self._recipient_screen_name

  def SetRecipientScreenName(self, recipient_screen_name):
    '''Set the unique recipient screen name of this direct message.

    Args:
      recipient_screen_name: The unique recipient screen name of this direct message
    '''
    self._recipient_screen_name = recipient_screen_name

  recipient_screen_name = property(GetRecipientScreenName, SetRecipientScreenName,
                doc='The unique recipient screen name of this direct message.')

  def GetText(self):
    '''Get the text of this direct message.

    Returns:
      The text of this direct message.
    '''
    return self._text

  def SetText(self, text):
    '''Set the text of this direct message.

    Args:
      text: The text of this direct message
    '''
    self._text = text

  text = property(GetText, SetText,
                  doc='The text of this direct message')

  def __ne__(self, other):
    return not self.__eq__(other)

  def __eq__(self, other):
    try:
      return other and \
          self.id == other.id and \
          self.created_at == other.created_at and \
          self.sender_id == other.sender_id and \
          self.sender_screen_name == other.sender_screen_name and \
          self.recipient_id == other.recipient_id and \
          self.recipient_screen_name == other.recipient_screen_name and \
          self.text == other.text
    except AttributeError:
      return False

  def __str__(self):
    '''A string representation of this twitter.DirectMessage instance.

    The return value is the same as the JSON string representation.

    Returns:
      A string representation of this twitter.DirectMessage instance.
    '''
    return self.AsJsonString()

  def AsJsonString(self):
    '''A JSON string representation of this twitter.DirectMessage instance.

    Returns:
      A JSON string representation of this twitter.DirectMessage instance
   '''
    return simplejson.dumps(self.AsDict(), sort_keys=True)

  def AsDict(self):
    '''A dict representation of this twitter.DirectMessage instance.

    The return value uses the same key names as the JSON representation.

    Return:
      A dict representing this twitter.DirectMessage instance
    '''
    data = {}
    if self.id:
      data['id'] = self.id
    if self.created_at:
      data['created_at'] = self.created_at
    if self.sender_id:
      data['sender_id'] = self.sender_id
    if self.sender_screen_name:
      data['sender_screen_name'] = self.sender_screen_name
    if self.recipient_id:
      data['recipient_id'] = self.recipient_id
    if self.recipient_screen_name:
      data['recipient_screen_name'] = self.recipient_screen_name
    if self.text:
      data['text'] = self.text
    return data

  @staticmethod
  def NewFromJsonDict(data):
    '''Create a new instance based on a JSON dict.

    Args:
      data: A JSON dict, as converted from the JSON in the twitter API
    Returns:
      A twitter.DirectMessage instance
    '''
    return DirectMessage(created_at=data.get('created_at', None),
                         recipient_id=data.get('recipient_id', None),
                         sender_id=data.get('sender_id', None),
                         text=data.get('text', None),
                         sender_screen_name=data.get('sender_screen_name', None),
                         id=data.get('id', None),
                         recipient_screen_name=data.get('recipient_screen_name', None))

class Api(object):
  '''A python interface into the Twitter API

  By default, the Api caches results for 1 minute.

  Example usage:

    To create an instance of the twitter.Api class, with no authentication:

      >>> import twitter
      >>> api = twitter.Api()

    To fetch the most recently posted public twitter status messages:

      >>> statuses = api.GetPublicTimeline()
      >>> print [s.user.name for s in statuses]
      [u'DeWitt', u'Kesuke Miyagi', u'ev', u'Buzz Andersen', u'Biz Stone'] #...

    To fetch a single user's public status messages, where "user" is either
    a Twitter "short name" or their user id.

      >>> statuses = api.GetUserTimeline(user)
      >>> print [s.text for s in statuses]

    To use authentication, instantiate the twitter.Api class with a
    username and password:

      >>> api = twitter.Api(username='twitter user', password='twitter pass')

    To fetch your friends (after being authenticated):

      >>> users = api.GetFriends()
      >>> print [u.name for u in users]

    To post a twitter status message (after being authenticated):

      >>> status = api.PostUpdate('I love python-twitter!')
      >>> print status.text
      I love python-twitter!

    There are many other methods, including:

      >>> api.PostDirectMessage(user, text)
      >>> api.GetUser(user)
      >>> api.GetReplies()
      >>> api.GetUserTimeline(user)
      >>> api.GetStatus(id)
      >>> api.DestroyStatus(id)
      >>> api.GetFriendsTimeline(user)
      >>> api.GetFriends(user)
      >>> api.GetFollowers()
      >>> api.GetFeatured()
      >>> api.GetDirectMessages()
      >>> api.PostDirectMessage(user, text)
      >>> api.DestroyDirectMessage(id)
      >>> api.DestroyFriendship(user)
      >>> api.CreateFriendship(user)
  '''

  DEFAULT_CACHE_TIMEOUT = 60 # cache for 1 minute

  _API_REALM = 'Twitter API'

  def __init__(self,
               username=None,
               password=None,
               input_encoding=None,
               request_headers=None):
    '''Instantiate a new twitter.Api object.

    Args:
      username: The username of the twitter account.  [optional]
      password: The password for the twitter account. [optional]
      input_encoding: The encoding used to encode input strings. [optional]
      request_header: A dictionary of additional HTTP request headers. [optional]
    '''
    self._cache = _FileCache()
    self._urllib = urllib2
    self._cache_timeout = Api.DEFAULT_CACHE_TIMEOUT
    self._InitializeRequestHeaders(request_headers)
    self._InitializeUserAgent()
    self._input_encoding = input_encoding
    self.SetCredentials(username, password)

  def GetPublicTimeline(self, since_id=None):
    '''Fetch the sequnce of public twitter.Status message for all users.

    Args:
      since_id:
        Returns only public statuses with an ID greater than (that is,
        more recent than) the specified ID. [Optional]

    Returns:
      An sequence of twitter.Status instances, one for each message
    '''
    parameters = {}
    if since_id:
      parameters['since_id'] = since_id
    url = 'http://twitter.com/statuses/public_timeline.json'
    json = self._FetchUrl(url,  parameters=parameters)
    data = simplejson.loads(json)
    return [Status.NewFromJsonDict(x) for x in data]

  def GetFriendsTimeline(self, user=None, since=None):
    '''Fetch the sequence of twitter.Status messages for a user's friends

    The twitter.Api instance must be authenticated if the user is private.

    Args:
      user:
        Specifies the ID or screen name of the user for whom to return
        the friends_timeline.  If unspecified, the username and password
        must be set in the twitter.Api instance.  [optional]
      since:
        Narrows the returned results to just those statuses created
        after the specified HTTP-formatted date. [optional]

    Returns:
      A sequence of twitter.Status instances, one for each message
    '''
    if user:
      url = 'http://twitter.com/statuses/friends_timeline/%s.json' % user
    elif not user and not self._username:
      raise TwitterError("User must be specified if API is not authenticated.")
    else:
      url = 'http://twitter.com/statuses/friends_timeline.json'
    parameters = {}
    if since:
      parameters['since'] = since
    json = self._FetchUrl(url, parameters=parameters)
    data = simplejson.loads(json)
    return [Status.NewFromJsonDict(x) for x in data]

  def GetUserTimeline(self, user=None, count=None, since=None):
    '''Fetch the sequence of public twitter.Status messages for a single user.

    The twitter.Api instance must be authenticated if the user is private.

    Args:
      user:
        either the username (short_name) or id of the user to retrieve.  If
        not specified, then the current authenticated user is used. [optional]
      count: the number of status messages to retrieve [optional]
      since:
        Narrows the returned results to just those statuses created
        after the specified HTTP-formatted date. [optional]

    Returns:
      A sequence of twitter.Status instances, one for each message up to count
    '''
    try:
      if count:
        int(count)
    except:
      raise TwitterError("Count must be an integer")
    parameters = {}
    if count:
      parameters['count'] = count
    if since:
      parameters['since'] = since
    if user:
      url = 'http://twitter.com/statuses/user_timeline/%s.json' % user
    elif not user and not self._username:
      raise TwitterError("User must be specified if API is not authenticated.")
    else:
      url = 'http://twitter.com/statuses/user_timeline.json'
    json = self._FetchUrl(url, parameters=parameters)
    data = simplejson.loads(json)
    return [Status.NewFromJsonDict(x) for x in data]

  def GetStatus(self, id):
    '''Returns a single status message.

    The twitter.Api instance must be authenticated if the status message is private.

    Args:
      id: The numerical ID of the status you're trying to retrieve.

    Returns:
      A twitter.Status instance representing that status message
    '''
    try:
      if id:
        int(id)
    except:
      raise TwitterError("id must be an integer")
    url = 'http://twitter.com/statuses/show/%s.json' % id
    json = self._FetchUrl(url)
    data = simplejson.loads(json)
    return Status.NewFromJsonDict(data)

  def DestroyStatus(self, id):
    '''Destroys the status specified by the required ID parameter.

    The twitter.Api instance must be authenticated and thee
    authenticating user must be the author of the specified status.

    Args:
      id: The numerical ID of the status you're trying to destroy.

    Returns:
      A twitter.Status instance representing the destroyed status message
    '''
    try:
      if id:
        int(id)
    except:
      raise TwitterError("id must be an integer")
    url = 'http://twitter.com/statuses/destroy/%s.json' % id
    json = self._FetchUrl(url, post_data={})
    data = simplejson.loads(json)
    return Status.NewFromJsonDict(data)

  def PostUpdate(self, text):
    '''Post a twitter status message from the authenticated user.

    The twitter.Api instance must be authenticated.

    Args:
      text: The message text to be posted.  Must be less than 140 characters.

    Returns:
      A twitter.Status instance representing the message posted
    '''
    if not self._username:
      raise TwitterError("The twitter.Api instance must be authenticated.")
    if len(text) > 140:
      raise TwitterError("Text must be less than or equal to 140 characters.")
    url = 'http://twitter.com/statuses/update.json'
    data = {'status': text}
    json = self._FetchUrl(url, post_data=data)
    data = simplejson.loads(json)
    return Status.NewFromJsonDict(data)

  def GetReplies(self):
    '''Get a sequence of status messages representing the 20 most recent
    replies (status updates prefixed with @username) to the authenticating
    user.

    Returns:
      A sequence of twitter.Status instances, one for each reply to the user.
    '''
    url = 'http://twitter.com/statuses/replies.json'
    if not self._username:
      raise TwitterError("The twitter.Api instance must be authenticated.")
    json = self._FetchUrl(url)
    data = simplejson.loads(json)
    return [Status.NewFromJsonDict(x) for x in data]

  def GetFriends(self, user=None):
    '''Fetch the sequence of twitter.User instances, one for each friend.

    Args:
      user: the username or id of the user whose friends you are fetching.  If
      not specified, defaults to the authenticated user. [optional]

    The twitter.Api instance must be authenticated.

    Returns:
      A sequence of twitter.User instances, one for each friend
    '''
    if not self._username:
      raise TwitterError("twitter.Api instance must be authenticated")
    if user:
      url = 'http://twitter.com/statuses/friends/%s.json' % user
    else:
      url = 'http://twitter.com/statuses/friends.json'
    json = self._FetchUrl(url)
    data = simplejson.loads(json)
    return [User.NewFromJsonDict(x) for x in data]

  def GetFollowers(self):
    '''Fetch the sequence of twitter.User instances, one for each follower

    The twitter.Api instance must be authenticated.

    Returns:
      A sequence of twitter.User instances, one for each follower
    '''
    if not self._username:
      raise TwitterError("twitter.Api instance must be authenticated")
    url = 'http://twitter.com/statuses/followers.json'
    json = self._FetchUrl(url)
    data = simplejson.loads(json)
    return [User.NewFromJsonDict(x) for x in data]

  def GetFeatured(self):
    '''Fetch the sequence of twitter.User instances featured on twitter.com

    The twitter.Api instance must be authenticated.

    Returns:
      A sequence of twitter.User instances
    '''
    url = 'http://twitter.com/statuses/featured.json'
    json = self._FetchUrl(url)
    data = simplejson.loads(json)
    return [User.NewFromJsonDict(x) for x in data]

  def GetUser(self, user):
    '''Returns a single user.

    The twitter.Api instance must be authenticated.

    Args:
      user: The username or id of the user to retrieve.

    Returns:
      A twitter.User instance representing that user
    '''
    url = 'http://twitter.com/users/show/%s.json' % user
    json = self._FetchUrl(url)
    data = simplejson.loads(json)
    return User.NewFromJsonDict(data)

  def GetDirectMessages(self, since=None):
    '''Returns a list of the direct messages sent to the authenticating user.

    The twitter.Api instance must be authenticated.

    Args:
      since:
        Narrows the returned results to just those statuses created
        after the specified HTTP-formatted date. [optional]

    Returns:
      A sequence of twitter.DirectMessage instances
    '''
    url = 'http://twitter.com/direct_messages.json'
    if not self._username:
      raise TwitterError("The twitter.Api instance must be authenticated.")
    parameters = {}
    if since:
      parameters['since'] = since
    json = self._FetchUrl(url, parameters=parameters)
    data = simplejson.loads(json)
    return [DirectMessage.NewFromJsonDict(x) for x in data]

  def PostDirectMessage(self, user, text):
    '''Post a twitter direct message from the authenticated user

    The twitter.Api instance must be authenticated.

    Args:
      user: The ID or screen name of the recipient user.
      text: The message text to be posted.  Must be less than 140 characters.

    Returns:
      A twitter.DirectMessage instance representing the message posted
    '''
    if not self._username:
      raise TwitterError("The twitter.Api instance must be authenticated.")
    url = 'http://twitter.com/direct_messages/new.json'
    data = {'text': text, 'user': user}
    json = self._FetchUrl(url, post_data=data)
    data = simplejson.loads(json)
    return DirectMessage.NewFromJsonDict(data)

  def DestroyDirectMessage(self, id):
    '''Destroys the direct message specified in the required ID parameter.

    The twitter.Api instance must be authenticated, and the
    authenticating user must be the recipient of the specified direct
    message.

    Args:
      id: The id of the direct message to be destroyed

    Returns:
      A twitter.DirectMessage instance representing the message destroyed
    '''
    url = 'http://twitter.com/direct_messages/destroy/%s.json' % id
    json = self._FetchUrl(url, post_data={})
    data = simplejson.loads(json)
    return DirectMessage.NewFromJsonDict(data)

  def CreateFriendship(self, user):
    '''Befriends the user specified in the user parameter as the authenticating user.

    The twitter.Api instance must be authenticated.

    Args:
      The ID or screen name of the user to befriend.
    Returns:
      A twitter.User instance representing the befriended user.
    '''
    url = 'http://twitter.com/friendships/create/%s.json' % user
    json = self._FetchUrl(url, post_data={})
    data = simplejson.loads(json)
    return User.NewFromJsonDict(data)

  def DestroyFriendship(self, user):
    '''Discontinues friendship with the user specified in the user parameter.

    The twitter.Api instance must be authenticated.

    Args:
      The ID or screen name of the user  with whom to discontinue friendship.
    Returns:
      A twitter.User instance representing the discontinued friend.
    '''
    url = 'http://twitter.com/friendships/destroy/%s.json' % user
    json = self._FetchUrl(url, post_data={})
    data = simplejson.loads(json)
    return User.NewFromJsonDict(data)

  def SetCredentials(self, username, password):
    '''Set the username and password for this instance

    Args:
      username: The twitter username.
      password: The twitter password.
    '''
    self._username = username
    self._password = password

  def ClearCredentials(self):
    '''Clear the username and password for this instance
    '''
    self._username = None
    self._password = None

  def SetCache(self, cache):
    '''Override the default cache.  Set to None to prevent caching.

    Args:
      cache: an instance that supports the same API as the  twitter._FileCache
    '''
    self._cache = cache

  def SetUrllib(self, urllib):
    '''Override the default urllib implementation.

    Args:
      urllib: an instance that supports the same API as the urllib2 module
    '''
    self._urllib = urllib

  def SetCacheTimeout(self, cache_timeout):
    '''Override the default cache timeout.

    Args:
      cache_timeout: time, in seconds, that responses should be reused.
    '''
    self._cache_timeout = cache_timeout

  def SetUserAgent(self, user_agent):
    '''Override the default user agent

    Args:
      user_agent: a string that should be send to the server as the User-agent
    '''
    self._request_headers['User-Agent'] = user_agent

  def SetXTwitterHeaders(self, client, url, version):
    '''Set the X-Twitter HTTP headers that will be sent to the server.

    Args:
      client:
         The client name as a string.  Will be sent to the server as
         the 'X-Twitter-Client' header.
      url:
         The URL of the meta.xml as a string.  Will be sent to the server
         as the 'X-Twitter-Client-URL' header.
      version:
         The client version as a string.  Will be sent to the server
         as the 'X-Twitter-Client-Version' header.
    '''
    self._request_headers['X-Twitter-Client'] = client
    self._request_headers['X-Twitter-Client-URL'] = url
    self._request_headers['X-Twitter-Client-Version'] = version

  def _BuildUrl(self, url, path_elements=None, extra_params=None):
    # Break url into consituent parts
    (scheme, netloc, path, params, query, fragment) = urlparse.urlparse(url)

    # Add any additional path elements to the path
    if path_elements:
      # Filter out the path elements that have a value of None
      p = [i for i in path_elements if i]
      if not path.endswith('/'):
        path += '/'
      path += '/'.join(p)

    # Add any additional query parameters to the query string
    if extra_params and len(extra_params) > 0:
      extra_query = self._EncodeParameters(extra_params)
      # Add it to the existing query
      if query:
        query += '&' + extra_query
      else:
        query = extra_query

    # Return the rebuilt URL
    return urlparse.urlunparse((scheme, netloc, path, params, query, fragment))

  def _InitializeRequestHeaders(self, request_headers):
    if request_headers:
      self._request_headers = request_headers
    else:
      self._request_headers = {}

  def _InitializeUserAgent(self):
    user_agent = 'Python-urllib/%s (python-twitter/%s)' % \
                 (self._urllib.__version__, twitter.__version__)
    self.SetUserAgent(user_agent)

  def _AddAuthorizationHeader(self, username, password):
    if username and password:
      basic_auth = base64.encodestring('%s:%s' % (username, password))[:-1]
      self._request_headers['Authorization'] = 'Basic %s' % basic_auth

  def _RemoveAuthorizationHeader(self):
    if self._request_headers and 'Authorization' in self._request_headers:
      del self._request_headers['Authorization']

  def _GetOpener(self, url, username=None, password=None):
    if username and password:
      self._AddAuthorizationHeader(username, password)
      handler = self._urllib.HTTPBasicAuthHandler()
      (scheme, netloc, path, params, query, fragment) = urlparse.urlparse(url)
      handler.add_password(Api._API_REALM, netloc, username, password)
      opener = self._urllib.build_opener(handler)
    else:
      opener = self._urllib.build_opener()
    opener.addheaders = self._request_headers.items()
    return opener

  def _Encode(self, s):
    if self._input_encoding:
      return unicode(s, self._input_encoding).encode('utf-8')
    else:
      return unicode(s).encode('utf-8')

  def _EncodeParameters(self, parameters):
    '''Return a string in key=value&key=value form

    Values of None are not included in the output string.

    Args:
      parameters:
        A dict of (key, value) tuples, where value is encoded as
        specified by self._encoding
    Returns:
      A URL-encoded string in "key=value&key=value" form
    '''
    if parameters is None:
      return None
    else:
      return urllib.urlencode(dict([(k, self._Encode(v)) for k, v in parameters.items() if v is not None]))

  def _EncodePostData(self, post_data):
    '''Return a string in key=value&key=value form

    Values are assumed to be encoded in the format specified by self._encoding,
    and are subsequently URL encoded.

    Args:
      post_data:
        A dict of (key, value) tuples, where value is encoded as
        specified by self._encoding
    Returns:
      A URL-encoded string in "key=value&key=value" form
    '''
    if post_data is None:
      return None
    else:
      return urllib.urlencode(dict([(k, self._Encode(v)) for k, v in post_data.items()]))

  def _FetchUrl(self,
                url,
                post_data=None,
                parameters=None,
                no_cache=None):
    """Fetch a URL, optionally caching for a specified time.

    Args:
      url: The URL to retrieve
      data: A dict of (str, unicode) key value pairs.  If set, POST will be used.
      parameters: A dict of key/value pairs that should added to
                  the query string. [OPTIONAL]
      username: A HTTP Basic Auth username for this request
      username: A HTTP Basic Auth password for this request
      no_cache: If true, overrides the cache on the current request

    Returns:
      A string containing the body of the response.
    """
    # Add key/value parameters to the query string of the url
    url = self._BuildUrl(url, extra_params=parameters)

    # Get a url opener that can handle basic auth
    opener = self._GetOpener(url, username=self._username, password=self._password)

    encoded_post_data = self._EncodePostData(post_data)

    # Open and return the URL immediately if we're not going to cache
    if encoded_post_data or no_cache or not self._cache or not self._cache_timeout:
      url_data = opener.open(url, encoded_post_data).read()
    else:
      # Unique keys are a combination of the url and the username
      if self._username:
        key = self._username + ':' + url
      else:
        key = url

      # See if it has been cached before
      last_cached = self._cache.GetCachedTime(key)

      # If the cached version is outdated then fetch another and store it
      if not last_cached or time.time() >= last_cached + self._cache_timeout:
        url_data = opener.open(url, encoded_post_data).read()
        self._cache.Set(key, url_data)
      else:
        url_data = self._cache.Get(key)

    # Always return the latest version
    return url_data

class _FileCacheError(Exception):
  '''Base exception class for FileCache related errors'''

class _FileCache(object):

  DEPTH = 3

  def __init__(self,root_directory=None):
    self._InitializeRootDirectory(root_directory)

  def Get(self,key):
    path = self._GetPath(key)
    if os.path.exists(path):
      return open(path).read()
    else:
      return None

  def Set(self,key,data):
    path = self._GetPath(key)
    directory = os.path.dirname(path)
    if not os.path.exists(directory):
      os.makedirs(directory)
    if not os.path.isdir(directory):
      raise _FileCacheError('%s exists but is not a directory' % directory)
    temp_fd, temp_path = tempfile.mkstemp()
    temp_fp = os.fdopen(temp_fd, 'w')
    temp_fp.write(data)
    temp_fp.close()
    if not path.startswith(self._root_directory):
      raise _FileCacheError('%s does not appear to live under %s' %
                            (path, self._root_directory))
    if os.path.exists(path):
      os.remove(path)
    os.rename(temp_path, path)

  def Remove(self,key):
    path = self._GetPath(key)
    if not path.startswith(self._root_directory):
      raise _FileCacheError('%s does not appear to live under %s' %
                            (path, self._root_directory ))
    if os.path.exists(path):
      os.remove(path)

  def GetCachedTime(self,key):
    path = self._GetPath(key)
    if os.path.exists(path):
      return os.path.getmtime(path)
    else:
      return None

  def _GetUsername(self):
    '''Attempt to find the username in a cross-platform fashion.'''
    return os.getenv('USER') or \
        os.getenv('LOGNAME') or \
        os.getenv('USERNAME') or \
        os.getlogin() or \
        'nobody'

  def _GetTmpCachePath(self):
    username = self._GetUsername()
    cache_directory = 'python.cache_' + username
    return os.path.join(tempfile.gettempdir(), cache_directory)

  def _InitializeRootDirectory(self, root_directory):
    if not root_directory:
      root_directory = self._GetTmpCachePath()
    root_directory = os.path.abspath(root_directory)
    if not os.path.exists(root_directory):
      os.mkdir(root_directory)
    if not os.path.isdir(root_directory):
      raise _FileCacheError('%s exists but is not a directory' %
                            root_directory)
    self._root_directory = root_directory

  def _GetPath(self,key):
    hashed_key = md5.new(key).hexdigest()
    return os.path.join(self._root_directory,
                        self._GetPrefix(hashed_key),
                        hashed_key)

  def _GetPrefix(self,hashed_key):
    return os.path.sep.join(hashed_key[0:_FileCache.DEPTH])

########NEW FILE########
__FILENAME__ = paint
import collections
import os
from pymt import *
from OpenGL.GL import *
from glob import glob

# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Paint Sandbox'
PLUGIN_AUTHOR = 'Thomas Hansen'
PLUGIN_EMAIL = 'thomas.hansen@gmail.com'
PLUGIN_DESCRIPTION = 'This is a simple paint canvas.'

current_dir = os.path.dirname(__file__)

class PaintBrushLayout(MTBoxLayout):
    def draw(self):
        set_color(0, 0, 0, 0.7)
        drawRectangle(self.pos, self.size)


class MTPaintColorPicker(MTWidget):
    def __init__(self, **kwargs):
        kwargs.setdefault('min', 0)
        kwargs.setdefault('max', 255)
        kwargs.setdefault('target', [])
        super(MTPaintColorPicker, self).__init__(**kwargs)
        self.targets = kwargs.get('targets')
        self.sliders = [ MTSlider(min=kwargs.get('min'), max=kwargs.get('max'), size=(30,200), style = {'slider-color': (1,0,0,1)}),
                        MTSlider(min=kwargs.get('min'), max=kwargs.get('max'), size=(30,200), style = {'slider-color': (0,1,0,1)}),
                        MTSlider(min=kwargs.get('min'), max=kwargs.get('max'), size=(30,200), style = {'slider-color': (0,0,1,1)}),
                        MTSlider(min=kwargs.get('min'), max=kwargs.get('max'), size=(30,200), style = {'slider-color': (1,1,1,.7)}),
                        MTSlider(min=kwargs.get('min'), max=kwargs.get('max'), size=(30,200), style = {'slider-color': (1,1,1,.7)}) ]
        for slider in self.sliders:
            slider.value = 200
        self.update_color()
        self.touch_positions = {}
        self.brush_size = (self.sliders[4].value/4) + 1
        set_brush_size(self.brush_size)

    def draw(self):
        set_color(0.2,0.2,0.2,0.5)
        drawRoundedRectangle(pos=(self.x, self.y),
                             size=(self.width, self.height),
                             radius=15)

        set_color(*self.current_color)
        drawRectangle(pos=(self.x+10, self.y+220), size=(110,60))

        pos = self.x + 170, self.y + 250
        set_brush_size(self.brush_size)
        paintLine(pos+pos)


        for i in range(len(self.sliders)):
            self.sliders[i].x = 10 + self.x + i*42
            self.sliders[i].y = 10 + self.y
            self.sliders[i].draw()

    def update_color(self):
        r = self.sliders[0].value/255.0
        g = self.sliders[1].value/255.0
        b = self.sliders[2].value/255.0
        a = self.sliders[3].value/255.0
        for w in self.targets:
            w.color = (r,g,b,a)
        self.current_color = (r,g,b,a)
        self.brush_size = (self.sliders[4].value/4) + 1
        set_brush_size(self.brush_size)

    def on_touch_down(self, touch):
        for s in self.sliders:
            if s.on_touch_down(touch):
                self.update_color()
                return True

        if self.collide_point(touch.x, touch.y):
            self.touch_positions[touch.id] = (touch.x, touch.y, touch.id)
            return True

    def on_touch_move(self, touch):
        for s in self.sliders:
            if s.on_touch_move(touch):
                self.update_color()
                return True
        if touch.id in self.touch_positions:
            self.x += touch.x - self.touch_positions[touch.id][0]
            self.y += touch.y - self.touch_positions[touch.id][1]
            self.touch_positions[touch.id] = (touch.x, touch.y, touch.id)
            return True

    def on_touch_up(self, touch):
        for s in self.sliders:
            if s.on_touch_up(touch):
                self.update_color()
                return True
        if touch.id in self.touch_positions:
            del self.touch_positions[touch.id]



class Canvas(MTWidget):
    def __init__(self, min=0, max=100, pos=(0,0), size=(640,480)):
        MTWidget.__init__(self, pos=pos, size=size)
        self.touch_positions = {}
        self.fbo = Fbo(size=(self.width, self.height), with_depthbuffer=False)
        self.bgcolor = (0,0,0,1)
        self.color = (0,1,0,1.0)
        set_brush(os.path.join(current_dir, 'brushes', 'brush_particle.png'))
        self.paint_queue = collections.deque()
        self.do_paint_queue = False
        self.clear()

    def clear(self):
        self.fbo.bind()
        glClearColor(*self.bgcolor)
        glClear(GL_COLOR_BUFFER_BIT)
        glClearColor(1,0,1,1)
        self.fbo.release()

    def draw(self):
        # draw the whole queue
        if self.do_paint_queue:
            self.fbo.bind()
            while True:
                try:
                    item = self.paint_queue.pop()
                except IndexError:
                    break
                color, positions = item
                set_color(*color)
                paintLine(positions)
            self.fbo.release()
            self.do_paint_queue = False
        set_color(1,1,1,1)
        drawTexturedRectangle(self.fbo.texture, size=(self.width, self.height))

    def on_resize(self, w, h):
        if self.fbo.size == (w, h):
            return
        del self.fbo
        self.fbo = Fbo(size=(w, h), push_viewport=False)

    def on_touch_down(self, touch):
        self.paint_queue.appendleft((self.color, (touch.x,touch.y,touch.x,touch.y)))
        self.do_paint_queue = True
        self.touch_positions[touch.id] = (touch.x, touch.y)

    def on_touch_move(self, touch):
        if self.touch_positions.has_key(touch.id):
            ox,oy = self.touch_positions[touch.id]
            self.paint_queue.appendleft((self.color, (ox,oy,touch.x,touch.y)))
            self.do_paint_queue = True
            self.touch_positions[touch.id] = (touch.x, touch.y)

    def on_touch_up(self, touch):
        if self.touch_positions.has_key(touch.id):
            del self.touch_positions[touch.id]

def update_brush(brush, size, *largs):
    set_brush(brush, size=size)

def clear_canvas(canvas, *largs):
    canvas.clear()

def pymt_plugin_activate(root, ctx):

    ctx.canvas = Canvas(pos=(40,40),size=(root.width,root.height))
    def resizeCanvas(w,h):
        ctx.canvas.size = (w, h)
        ctx.btnclear.pos = (0, root.height - 50)
    root.push_handlers(on_resize=resizeCanvas)

    root.add_widget(ctx.canvas)
    ctx.slider = MTPaintColorPicker(size=(220,290), targets=[ctx.canvas])
    root.add_widget(ctx.slider)

    ctx.btnclear = MTButton(label='Clear', size=(50,50), pos=(0, root.height-50))
    ctx.btnclear.push_handlers(on_press=curry(clear_canvas, ctx.canvas))
    root.add_widget(ctx.btnclear)

    ctx.brushes = PaintBrushLayout(pos=(300, 0), size_hint=(None, None))
    for brush in glob(os.path.join(current_dir, 'brushes', '*.png')):
        button = MTImageButton(filename=brush)
        button.push_handlers(on_press=curry(update_brush, brush,
                                            ctx.slider.brush_size))
        ctx.brushes.add_widget(button)
    root.add_widget(ctx.brushes)



def pymt_plugin_deactivate(root, ctx):
    root.remove_widget(ctx.canvas)
    root.remove_widget(ctx.slider)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = particles
from __future__ import with_statement
from pymt import *
from OpenGL.GL import *
import random
import math
import os

# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Particles Sandbox'
PLUGIN_AUTHOR = 'Sharath Patali & Mathieu Virbel'
PLUGIN_DESCRIPTION = 'All stars are coming under touches!'

current_dir = os.path.dirname(__file__)

class ParticleObject:
    def __init__(self, settings):
        self.x, self.y  = 0, 0
        self.opacity    = 1.
        self.visible    = False
        self.alpha_func = AnimationAlpha.linear
        self.from_x     = 0
        self.from_y     = 0
        self.to_x       = 0
        self.to_y       = 0
        self.lifetime   = 1
        self.frame      = 0
        self.settings   = settings
        self.random_color()

    def random_color(self):
        r_min, r_max = map(lambda x: x/255., self.settings.color_r)
        g_min, g_max = map(lambda x: x/255., self.settings.color_g)
        b_min, b_max = map(lambda x: x/255., self.settings.color_b)
        self.color      = [random.uniform(r_min, r_max),
                           random.uniform(g_min, g_max),
                           random.uniform(b_min, b_max),
                           self.opacity]

    def alpha(self, a, b):
        alpha = self.alpha_func(self.frame / self.lifetime)
        return a * (1-alpha) + b * alpha

    def ramp(self, value_from, value_to, length, frame):
        return (1.0 - frame / length) * value_from  +  frame / length * value_to

    def animate(self, **kwargs):
        pos = kwargs.get('pos')
        rs = random.random() * self.settings.dispersion_start
        re = random.random() * self.settings.dispersion_end
        d = random.random() * math.pi * 2
        self.x, self.y  = pos
        self.from_x     = self.x + math.cos(d) * rs
        self.from_y     = self.y + math.sin(d) * rs
        self.to_x       = self.x + math.cos(d) * re
        self.to_y       = self.y + math.sin(d) * re
        self.lifetime   = self.settings.lifetime
        self.alpha_func = self.settings.alpha
        self.frame      = 0
        self.visible    = True
        self.random_color()

    def update(self, dt):
        if self.frame > self.lifetime:
            self.visible = False
            return True
        progress = self.frame / self.lifetime
        self.frame      += dt
        self.x          = self.alpha(self.from_x, self.to_x)
        self.y          = self.alpha(self.from_y, self.to_y)

        alpha = self.settings.alpha_decrease / 100.
        if progress < alpha:
            self.opacity = 1
        else:
            self.opacity    = 1 - ((progress - alpha) * (1 / (1 - alpha)))
        self.visible    = True
        self.color[3]   = self.opacity


class ParticleEngine(MTWidget):
    def __init__(self, max=5000, **kwargs):
        super(ParticleEngine, self).__init__(**kwargs)
        self.max        = max
        self.particles  = []
        self.image      = Image(os.path.join(current_dir, 'dot.png'))

        # properties used by particles
        self.alpha      = AnimationAlpha.linear
        self.dispersion_start   = 10
        self.dispersion_end     = 200
        self.alpha_decrease = 10
        self.color_r    = [0, 255]
        self.color_g    = [0, 255]
        self.color_b    = [0, 255]
        self.lifetime   = 1
        self.number     = 20
        self.pointsize  = 10

        for i in range(self.max):
            self.particles.append(ParticleObject(self))

        self.create_ui()

    def create_ui(self):
        xml = '''<?xml version="1.0" encoding="UTF-8"?>
        <MTBoxLayout id="'layout'" orientation="'vertical'" size_hint='(None,
        None)' invert_y='True'>
        <MTGridLayout cols="4" size_hint='(None,None)'>
            <MTLabel label="'Lifetime'" size="(200, 30)" anchor_x="'center'" anchor_y="'middle'"/>
            <MTSlider id="'sl_lifetime'" min="1" max="10" value="1"
                orientation="'horizontal'" value_show="True" size="(200, 30)"/>
            <MTLabel label="'Alpha decrease'" size="(200, 30)" anchor_x="'center'" anchor_y="'middle'"/>
            <MTSlider id="'sl_alpha_decrease'" min="1" max="100" value="40"
                orientation="'horizontal'" value_show="True" size="(200, 30)"/>
            <MTLabel label="'Start dispertion'" size="(200, 30)" anchor_x="'center'" anchor_y="'middle'"/>
            <MTSlider id="'sl_dispersion_start'" min="10" max="500" value="10"
                orientation="'horizontal'" value_show="True" size="(200, 30)"/>
            <MTLabel label="'End dispertion'" size="(200, 30)" anchor_x="'center'" anchor_y="'middle'"/>
            <MTSlider id="'sl_dispersion_end'" min="10" max="500" value="200"
                orientation="'horizontal'" value_show="True" size="(200, 30)"/>
            <MTLabel label="'Number'" size="(200, 30)" anchor_x="'center'" anchor_y="'middle'"/>
            <MTSlider id="'sl_number'" min="5" max="100" value="20"
                orientation="'horizontal'" value_show="True" size="(200, 30)"/>
            <MTLabel label="'Size'" size="(200, 30)" anchor_x="'center'" anchor_y="'middle'"/>
            <MTSlider id="'sl_pointsize'" min="1" max="50" value="10"
                orientation="'horizontal'" value_show="True" size="(200, 30)"/>
            <MTLabel label="'Color range'" size="(200, 30)" anchor_x="'center'" anchor_y="'middle'"/>
            <MTBoundarySlider id="'sl_color_r'" min="0" max="255"
                value_min="100" value_max="255"
                orientation="'horizontal'" showtext="True" size="(200, 30)"/>
            <MTBoundarySlider id="'sl_color_g'" min="0" max="255"
                value_min="0" value_max="255"
                orientation="'horizontal'" showtext="True" size="(200, 30)"/>
            <MTBoundarySlider id="'sl_color_b'" min="0" max="255"
                value_min="0" value_max="255"
                orientation="'horizontal'" showtext="True" size="(200, 30)"/>
        </MTGridLayout>
        <MTGridLayout rows="1" size_hint='(None,None)'>
            <MTLabel label="'Animation'" size="(120, 30)" anchor_x="'center'" anchor_y="'middle'"/>
            <MTToggleButton group="'animation'" id="'btn_linear'" label="'linear'" size="(90, 30)"/>
            <MTToggleButton group="'animation'" id="'btn_ease_in_bounce'" label="'in bounce'" size="(90, 30)"/>
            <MTToggleButton group="'animation'" id="'btn_ease_out_bounce'" label="'out bounce'" size="(90, 30)"/>
            <MTToggleButton group="'animation'" id="'btn_ease_in_cubic'" label="'in cubic'" size="(90, 30)"/>
            <MTToggleButton group="'animation'" id="'btn_ease_out_cubic'" label="'out cubic'" size="(90, 30)"/>
            <MTToggleButton group="'animation'" id="'btn_ease_in_elastic'" label="'in elastic'" size="(90, 30)"/>
            <MTToggleButton group="'animation'" id="'btn_ease_out_elastic'" label="'out elastic'" size="(90, 30)"/>
        </MTGridLayout>
        </MTBoxLayout>
        '''
        w = XMLWidget()
        w.loadString(xml)

        layout = w.getById('layout')
        corner = MTSidePanel(layout=layout)
        self.add_widget(corner)

        w.getById('sl_number').connect('on_value_change', self, 'number')
        w.getById('sl_dispersion_start').connect(
            'on_value_change', self, 'dispersion_start')
        w.getById('sl_dispersion_end').connect(
            'on_value_change', self, 'dispersion_end')
        w.getById('sl_lifetime').connect('on_value_change', self, 'lifetime')
        w.getById('sl_pointsize').connect('on_value_change', self, 'pointsize')
        w.getById('sl_alpha_decrease').connect(
            'on_value_change', self, 'alpha_decrease')
        w.getById('sl_color_r').connect('on_value_change', self, 'color_r')
        w.getById('sl_color_g').connect('on_value_change', self, 'color_g')
        w.getById('sl_color_b').connect('on_value_change', self, 'color_b')
        for x in ('linear', 'ease_in_bounce', 'ease_out_bounce',
                  'ease_in_cubic', 'ease_out_cubic',
                  'ease_in_elastic', 'ease_out_elastic'):
            w.getById('btn_%s' % x).connect('on_press',
                   curry(self._btn_alpha_change, x))

    def _btn_alpha_change(self, funcname, *largs):
        self.alpha = getattr(AnimationAlpha, funcname)
        return True



    def draw(self):
        dt = getFrameDt()
        glTexEnvf(GL_POINT_SPRITE_ARB, GL_COORD_REPLACE_ARB, GL_TRUE)
        blend = GlBlending(sfactor=GL_SRC_ALPHA, dfactor=GL_ONE_MINUS_SRC_ALPHA)
        set_texture(self.image.texture)
        glPointSize(self.pointsize)
        with DO(blend,
                gx_enable(self.image.texture.target),
                gx_enable(GL_POINT_SPRITE_ARB),
                gx_begin(GL_POINTS)):
            for p in self.particles:
                if p.update(dt):
                    continue
                glColor4f(*p.color)
                glVertex2f(p.x, p.y)

        count = len([x for x in self.particles if x.visible])
        statusline = 'Particles: %4d/%4d' % (count, self.max)
        w = getWindow()
        drawLabel(statusline, pos=(10, w.height - 20), anchor_x='left')

    def generate(self, pos, count):
        for i in range(self.max):
            if self.particles[i].visible:
                continue
            count = count - 1
            if count <= 0:
                return
            self.particles[i].animate(pos=pos)

    def on_touch_down(self, touch):
        if super(ParticleEngine, self).on_touch_down(touch):
            return True
        self.generate((touch.x, touch.y), self.number)
        return True

    def on_touch_move(self, touch):
        if super(ParticleEngine, self).on_touch_move(touch):
            return True
        self.generate((touch.x, touch.y), self.number)
        return True


def pymt_plugin_activate(w, ctx):
    ctx.pe = ParticleEngine()
    w.add_widget(ctx.pe)

def pymt_plugin_deactivate(w, ctx):
    w.remove_widget(ctx.pe)

#start the application (inits and shows all windows)
if __name__ == '__main__':
    w = MTWindow(color=(0,0,0,1))
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = pictures
# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Picture Viewer'
PLUGIN_AUTHOR = 'Thomas Hansen'
PLUGIN_DESCRIPTION = 'Demonstration of MTScatterImage object'

from pymt import *
import os
import random
from OpenGL.GL import *

current_dir = os.path.dirname(__file__)

def handle_image_move(image, *largs):
    w = image.get_parent_window()
    if not w:
        return
    if image.x < 0:
        image.pos = (0, image.y)
    if image.y < 0:
        image.pos = (image.x, 0)
    if image.x > w.width:
        image.pos = (w.width, image.y)
    if image.y > w.height:
        image.pos = (image.x, w.height)

def draw_border(image, *largs):
    set_color(1,1,1,1)
    with gx_matrix:
        glTranslatef(image.center[0], image.center[1], 0)
        glRotated(image.rotation,0,0,1)
        glScalef(image._scale, image._scale, 1)
        b = 5 * (1 / image._scale)
        drawRectangle(pos=(-image.width/2-b,-image.height/2-b),
                      size=(image.width+b*2, image.height+b*2))

def image_on_load(scatter):
    scatter.scale = 1 / random.uniform(3, 10)

def pymt_plugin_activate(w, ctx):
    ctx.c = MTKinetic()
    for i in range(6):
        img = Loader.image(os.path.join(current_dir, 'images', 'pic%d.jpg' % (i+1)))
        x = int(random.uniform(100, w.width-100))
        y = int(random.uniform(100, w.height-100))
        rot = random.uniform(0, 360)
        scale = random.uniform(3, 10)
        b = MTScatterImage(image=img, pos=(x,y), rotation=rot)
        img.connect('on_load', curry(image_on_load, b))
        b.size = b.image.width / scale, b.image.height / scale
        b.push_handlers(on_move=curry(handle_image_move, b))
        b.push_handlers(on_draw=curry(draw_border, b))
        ctx.c.add_widget(b)
    w.add_widget(ctx.c)

def pymt_plugin_deactivate(w, ctx):
    w.remove_widget(ctx.c)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = matrixseq
# -*- coding: utf-8 -*-

# Note: To use this example, you will need Csound and ounk.
# Csound download: http://sourceforge.net/project/showfiles.php?group_id=81968 (take the one labeled 'f' and don't install python support if asked)
# Ounk download: http://code.google.com/p/ounk/source/checkout (once you checkout, run setup.py)

# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Matrix Sequencer'
PLUGIN_AUTHOR = 'Nathanaël Lécaudé'
PLUGIN_DESCRIPTION = 'This plugin is a demonstration of the integration between pymt and the ounk library.'

from pymt import *
from OpenGL.GL import *
from ounk import ounklib as ounk
import random, time

tt1 = 0
proc = 0
pit1 = 0

def init_ounk():
    global tt1, proc, pit1
    ounk.setGlobalDuration(-1)

    env = ounk.genAdsr(release=0.8)

    tt1 = ounk.genDataTable([1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0])

    pit1 = ounk.genDataTable([1,1,1,1,.5,1,1,1,.25,1,1,1,.125,1,1,1])

    ounk.oscReceive(bus='tempo', address='/tempo', port = 9005, portamento = 0.05)
    ounk.metro(bus='metro', tempo=200, tempoVar = 'tempo')


    # solo sequence
    ounk.beginSequencer(input='metro', table=tt1)
    ounk.sequencerPitchTable(pit1)
    notes = 10
    pitchs = [random.randint(180,190)*2 for x in range(notes)]
    durs = [random.randint(1,15)*.05 for x in range(notes)]
    ounk.readTable(bus='index2', table=env, duration=durs[0])
    ounk.freqMod(pitch=pitchs, modulator=0.502, amplitude=.07, starttime=0, duration=durs, envelope=env, pan=[0,.25,.5,.75,1], index=10,indexVar='index2')
    ounk.endSequencer()

    proc = ounk.startCsound()
    time.sleep(1)
    ounk.sendOscControl(0.8, address='/tempo', port=9005)

def pymt_plugin_activate(w, ctx):
    init_ounk()
    ctx.c = MTWidget()
    temposlider = MTSlider(min = 0, max = 1, height = 125, slidercolor = (0,1,0.5,1))
    temposlider.pos = (w.width/5-temposlider.width-5, 20)
    temposlider.set_value(0.8)
    matrix = MTButtonMatrix(matrix_size = (16,1), size = (400, 25), pos = (w.width/5, 130), border = 1)
    multislider = MTMultiSlider(sliders = 16, size = (400,100), pos = (w.width/5, 20))
    ctx.c.add_widget(matrix)
    ctx.c.add_widget(multislider)
    ctx.c.add_widget(temposlider)
    w.add_widget(ctx.c)


    @matrix.event
    def on_value_change(matrix):
        table = [m[0] for m in matrix]
        ounk.reGenDataTable(tt1, table, proc)

    @multislider.event
    def on_value_change(values):
        ounk.reGenDataTable(pit1, values, proc)

    @temposlider.event
    def on_value_change(value):
        ounk.sendOscControl(value, address='/tempo', port=9005)

def pymt_plugin_deactivate(w, ctx):
    w.remove_widget(ctx.c)
    ounk.stopCsound()

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = sinemixer
# -*- coding: utf-8 -*-

# Note: To use this example, you will need the pyo library.
# Download link : http://pyo.googlecode.com


# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Sine Player'
PLUGIN_AUTHOR = 'Nathanaël Lécaudé'
PLUGIN_DESCRIPTION = 'This plugin is a demonstration of the integration between pymt and the pyo library.'

from pymt import *
from OpenGL.GL import *
import pyo

# will not work if 2 app use pyo
pyo_server = pyo.Server(nchnls=2).boot()
pyo_count = 0

def pymt_plugin_activate(w, ctx):
    ctx.c = MTWidget()

    # We initialize the pyo server.
    global pyo_count
    pyo_count += 1
    if pyo_count == 1:
        pyo_server.start()

    # We create 4 lists which will contain our sliders (to control pitch),
    # buttons (to trigger the sound), pyo sine waves and fader objects.
    sliders = []
    buttons = []
    sines = []
    faders = []

    vlayouts = []

    hlayout = MTBoxLayout(spacing=w.width / 10, size=w.size)

    def resize_hlayout(w, h):
        # reajust layout when moving
        hlayout.spacing = w / 10
        hlayout.size = w, h
        hlayout.do_layout()

    w.connect('on_resize', resize_hlayout)

    # We create 4 instances of each of the above
    for widget in range(4):
        vlayouts.append(MTBoxLayout(orientation='vertical', spacing=10))
        sliders.append(MTSlider(min=100, max=1000, size_hint=(1, .9)))
        buttons.append(MTButton(label='', size_hint=(1, .1)))
        vlayouts[widget].add_widget(buttons[widget])
        vlayouts[widget].add_widget(sliders[widget])
        hlayout.add_widget(vlayouts[widget])
        faders.append(pyo.Fader(fadein = 0.5, fadeout = 0.5, dur = 0, mul = 0.25))
        sines.append(pyo.Sine(mul = faders[widget], freq = 300))
        sines[widget].out()

    ctx.c.add_widget(hlayout)

    # This function gets called when a slider moves, it sets the pitch of each sine.
    def on_value_change_callback(slider, value):
        sines[slider].freq = value

    # When the button is pressed, the fader object performs it's fade.
    def on_press_callback(btn, *largs):
        faders[btn].play()

    # When the button is released, the fader object fades back to 0.
    def on_release_callback(btn, *largs):
        faders[btn].stop()

    # We push the handlers and feed it with the slider number so the callback function knows which sine to work on.
    for s in range(4):
        sliders[s].push_handlers(on_value_change = curry(on_value_change_callback, s))
        sliders[s].value = 300

    # Handlers for the buttons are pushed here.
    for b in range(4):
        buttons[b].push_handlers(on_press = curry(on_press_callback, b))
        buttons[b].push_handlers(on_release = curry(on_release_callback, b))

    w.add_widget(ctx.c)

def pymt_plugin_deactivate(w, ctx):
    # pyo Server is stopped
    global pyo_count
    pyo_count -= 1
    if pyo_count == 0:
        pyo_server.stop()
    w.remove_widget(ctx.c)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = svg
# -*- coding: utf-8 -*-
from pymt import *
import os
from os.path import join

# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'SVG Viewer'
PLUGIN_AUTHOR = 'Nathanaël Lécaudé'
PLUGIN_DESCRIPTION = 'This is an example of Scalable Vector Graphics using the Squirtle library for pyglet.'

current_dir = os.path.dirname(__file__)

def pymt_plugin_activate(w, ctx):
    ctx.c = MTKinetic()
    for svg_file in ['sun.svg', 'cloud.svg', 'ship.svg']:
        filename=join(current_dir, svg_file)
        scatter = MTScatterWidget(style={'bg-image':Svg(filename), 'bg-color': (0,0,0,0)})        
        ctx.c.add_widget(scatter)
    w.add_widget(ctx.c)

def pymt_plugin_deactivate(w, ctx):
    w.remove_widget(ctx.c)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = svg2
# -*- coding: utf-8 -*-
from pymt import *

# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'SVG Viewer'
PLUGIN_AUTHOR = 'Nathanaël Lécaudé'
PLUGIN_DESCRIPTION = 'This is an example of Scalable Vector Graphics using the Squirtle library for pyglet.'

svgdata = """<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 13.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 14948)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg version="1.0" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="128px" height="128px" viewBox="0 0 128 128" enable-background="new 0 0 128 128" xml:space="preserve">
<polygon fill="#F1E323" points="26.318,46.295 64.821,19.125 110.014,42.609 112.881,96.541 67.961,111.15 26.045,92.309 "/>
<polygon fill="#F8F191" points="64.957,22.128 108.238,43.974 110.969,95.312 99.637,50.392 "/>
<polyline points="82.844,51.822 77.109,44.931 73.285,53.273 78.809,57.082 "/>
<polyline points="59.072,54.47 52.683,47.113 48.422,56.019 54.576,60.084 "/>
<polygon points="45.979,75.24 44.887,70.871 39.016,79.201 44.477,78.518 59.223,89.441 77.246,90.807 92.674,77.973 96.77,77.152
	90.898,70.734 90.217,75.787 76.836,87.529 59.769,86.164 "/>
<polygon fill="#404040" points="52.942,48.89 57.584,54.215 53.352,51.757 "/>
<polygon fill="#404040" points="77.109,46.159 81.479,51.757 77.518,49.846 "/>
<polygon fill="#404040" points="44.478,72.783 45.569,75.924 58.95,86.301 44.341,76.469 "/>
<polygon fill="#404040" points="91.172,71.691 95.814,76.742 92.4,74.967 "/>
<polyline fill="#CFC31E" points="27.547,47.115 27.273,91.354 68.098,109.785 30.687,89.168 "/>
<polygon fill="#F1E323" points="116.173,58.063 145.789,54.59 147.251,77.99 119.646,77.259 "/>
<polygon fill="#F1E323" points="103.376,31.92 80.341,19.854 96.063,-3.363 114.893,5.778 "/>
<polygon fill="#F1E323" points="53.833,21.134 33.723,-6.288 10.688,7.24 27.507,33.383 "/>
<polygon fill="#F1E323" points="21.292,58.611 -11.25,57.697 -11.25,80.549 19.281,79.817 "/>
<polygon fill="#F1E323" points="28.604,98.647 13.065,124.059 34.637,133.383 52.736,110.348 "/>
<polygon fill="#F1E323" points="84.18,110.348 104.473,103.035 113.979,130.092 92.955,133.748 "/>
<polygon fill="#F8F191" points="96.978,-1.352 112.882,6.875 102.827,29.727 108.86,7.789 "/>
<polygon fill="#F8F191" points="118.55,59.342 144.326,56.6 145.789,76.161 141.401,60.622 "/>
<polygon fill="#F8F191" points="33.906,-3.729 51.09,20.585 38.111,11.262 "/>
<polygon fill="#F8F191" points="-9.056,59.891 19.098,60.622 18.001,77.989 15.807,63.364 "/>
<polygon fill="#F8F191" points="103.741,105.778 112.15,128.63 104.29,117.844 "/>
<polygon fill="#F8F191" points="29.518,101.757 48.714,111.812 35.368,130.458 44.326,113.64 "/>
<polygon fill="#CFC31E" points="95.5,1 83.75,18.5 101.5,28.75 87.75,18.25 "/>
<polygon fill="#CFC31E" points="118.75,62.25 121,76 143.5,76.25 123.25,74 "/>
<polygon fill="#CFC31E" points="85.75,111.25 93.5,132.75 91.5,120 "/>
<polygon fill="#CFC31E" points="27.75,103 14.75,123.5 32.5,131.5 18.25,122.75 "/>
<polygon fill="#CFC31E" points="16.25,78.5 -10.5,79.25 -10,60.5 -8.75,77 "/>
<polygon fill="#CFC31E" points="28.25,31.25 13,8 23.75,17.5 "/>
</svg>""";


def pymt_plugin_activate(w, ctx):
    sun = MTScatterSvg(filename = 'sun', pos = (200,200), rawdata=svgdata)
    ctx.c = MTKinetic()
    ctx.c.add_widget(sun)
    w.add_widget(ctx.c)

def pymt_plugin_deactivate(w, ctx):
    w.remove_widget(ctx.c)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = touchtracer
# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Touch Tracer'
PLUGIN_AUTHOR = 'Thomas Hansen'
PLUGIN_DESCRIPTION = ''

from OpenGL.GL import *
from pymt import *
import os
from os.path import join

current_dir = os.path.dirname(__file__)
crosshair = Image.load(join(current_dir, 'crosshair.png'))
crosshair.scale = 0.6


def drawCrossLabel(x, y, ID):
    drawLabel('ID: %s' % str(ID), pos=(x+30, y),
              font_size=12, anchor_x='left', anchor_y='bottom')
    drawLabel('x:%d y:%d' % (int(x), int(y)), pos=(x+30, y),
              font_size=10, anchor_x='left', anchor_y='top')
    crosshair.x = x - (crosshair.width / 2.) * crosshair.scale
    crosshair.y = y - (crosshair.height / 2.) * crosshair.scale
    crosshair.draw()


class TouchTracer(MTWidget):
    def __init__(self, **kwargs):
        super(TouchTracer, self).__init__(**kwargs)
        self.touchPositions = {}

    def on_touch_down(self, touch):
        color = get_random_color()
        self.touchPositions[touch.id] = [(touch.id,color,touch.x,touch.y)]


    def on_touch_up(self, touch):
        if touch.id in self.touchPositions:
            del self.touchPositions[touch.id]


    def on_touch_move(self, touch):
        if touch.id in self.touchPositions:
            # don't append same position on the line
            if len(self.touchPositions[touch.id]) > 1:
                pos = self.touchPositions[touch.id][-1]
                if int(pos[0]) == int(touch.x) and int(pos[1]) == int(touch.y):
                    return
            self.touchPositions[touch.id].append((touch.x,touch.y))


    def draw(self):
        set_brush(join(current_dir, 'particle.png'), 10)
        w = self.get_parent_window()
        set_color(.1, .1, .1)
        drawRectangle(size=w.size)
        for p in self.touchPositions:
            lines = []
            touchID,color,x,y = self.touchPositions[p][0]
            set_color(*color)
            lines += [x, y]
            for pos in self.touchPositions[p][1:]:
                lines += pos
            if len(lines) > 2:
                paintLine(lines)
            x, y = lines[-2:]
            drawCrossLabel(x, y, touchID)

def pymt_plugin_activate(w, ctx):
    ctx.c = TouchTracer()
    w.add_widget(ctx.c)

def pymt_plugin_deactivate(w, ctx):
    w.remove_widget(ctx.c)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = test
from pymt import *


class MTVideoBase(MTScatterWidget):
    def __init__(self, filename, **kwargs):
        super(MTVideoBase, self).__init__(**kwargs)
        self.video = Video(filename=filename)

    def draw(self):
        self.size = self.video.size
        self.video.draw()


if __name__ == '__main__':

    m = MTWidget()

    v = MTVideo(filename='super-fly.avi')
    v.player.play()
    v.player.volume = 0.1
    m.add_widget(v)

    v = MTVideo(filename='http://samples.mplayerhq.hu/MPEG-4/MP4_with_ttxtSUB/1Video_2Audio_2SUBs(timed%20text%20streams).mp4')
    v.player.play()
    m.add_widget(v)

    runTouchApp(m)

########NEW FILE########
__FILENAME__ = video
from pymt import *
from os.path import dirname, join

current_dir = dirname(__file__)

if __name__ == '__main__':
    filename = join(current_dir, 'softboy.avi')
    video = MTVideo(filename=filename, autostart=True)
    scat = MTScatterWidget(size=video.size, pos=(20, 20))
    connect(video, 'on_resize', scat, 'size')
    scat.add_widget(video)

    runTouchApp(scat)

########NEW FILE########
__FILENAME__ = desktop-multi
from __future__ import with_statement
import os
import math
from pymt import *
from OpenGL.GL import GL_LINE_STRIP, glColor4f, glVertex2f, GL_LINE_BIT, glLineWidth
from OpenGL.GL import glTranslatef

plugins = MTPlugins(plugin_paths=[
    os.path.join(os.path.dirname(__file__), '..', 'apps'),
    os.path.join(os.path.dirname(__file__), '..', 'games')
])
plugins.search_plugins()

def gesture_add_default(gdb):
    # Circle
    g = gdb.str_to_gesture('eNqdWk2PHDcOvfcf8VwyEL8k8h5ksbcF/AMWjjPwBpt4GtNjIPn3q5LYVaxYqupsH9oYztMr1SNFvqrx06/XP39/f/7ycnv/9vZy+Yf/e02Xp1+ucPn44fb+9vrfl9uHyxUvT79d6fI0XPGxwS5XXtZJXXd9/fXr+7IsL8vKZNm/FtTlqssqq6v+rAsgXX5Kz6iskIoZgRUsmi+3jx/+WH4Ny69B2VitmBgoFYLL7edPh9cAbLdEly/9AgTCSIkZoWQtSS+3L507ZZRzunanICsdiRJgKqxYN13udD9UPjAgzEIpAyKLnpPnRl5WcpSMBVBUEnGispEDgyjkO396QIimNthKngRBLTu75I0cibjKmwtxNtJzbmx1g3DnHmTxzl31TwIJE6e6f8x2Tt4yiGsGEYgUsdIagJSEgVwze20smy/n+cSWT1zzCVjrQ9g3bhwkZymWVs3F8Jy85RPXfCYyg6pNAspJmCWQq4prsvA/UInY8omez6XeBAxJjUWK1hI32OglqaFKAW7ftcTO6KmllGClByGr6kJSZZKaxrB504J8P5elPMDeckq0si/nIwHf976UxcqeFZYD5Px10Sl7SyrJyk5QKmmCklLWhBxKhmtESxGvyfzA3ltWqWzsWVESozT+EtNaG422M9Sv8IjuLa20pZWTpZyLk5vFc4qEntHlW87PEresMjzCXo8CeAdYdp/O+xe3rPKWVa4VWVss3T+wNdsEuIpeTzM9Qt/SyvIIfT3AsWbwAWlaWjmk1VRrg/KayXljBxO4t/V6BT2vSG5Z5S2rdVLUNiONumCYQlhy2Q6qnFNLS6lsKSUsXKeFaabWC8rKXQs1b6KAnDd2aRmV83Nak8HpbzZ26a5hyydkhjqTzU/SOpKW9pg0r8WYH5j70tIp5bw9Lv2rDqvtID2QT2n5lHWYJkkA2dxTlK0H/D/kuWU0r9O0znoTqnJwG9YYNM+J12mX7Xxo5JbPfDpLl+qvaoXDz+fcLZ1ZzkzAYppqDaV13MH50c8tm7mc2a56Vcm0tfNqF8+5Wy7zZoyq6aLK6eS8cde6/5uOrrRUljWVlDPXwym1EJNJrYatYwlicC78QJ2UlsyyWdtS2YvQ3V8EK0omHLxLauTVWd8+v728fF1Ne+Hm2uXy9FMp+lxZjZ8tfuo1368lXz4tiDJHlI6QOUI7ghoi1+8asx6DFqvs8VP9zvtVU0Nkc8T3vNWtNkSeI7AjeI6gjsCGsLa3egBaDGJMeizFWNdG2g4hpf1N0ILo2ojOEV0bKXNEV0pkirCulPAc0ZUSmCO6Ujy/F+tKcQ4KWFeKKca6UgxTza3rRmWae+u6kcwRXTfCOaLrRilUXb2xFkSbFuvyfNUgegDpYmF2yPcXh9TVwn4H5FfnGIThuq4e9opNvq4Lhk1m1eGWumKIDhlRd8mwCaIyZOmagTlkwAJdQWjJUxyxQFcQmjwK/R6gawbt3osNqSlC1Nd1zaDde8nDdRIhNNxSjhB06q4ZNM1KGq7TAMnm6ywGRxVex1WEePGh69JORh5WFrpKLUe1AY0gtIcMBEEOEBkWA0qEDIsBc4Sw30MJ9yDD9KPuIaOrW4DUnjNgobSHDFgIgsjs9UIYg3lITaEYeFhSFKuOxalds3Y2eVhnlPeQEXWJEC9F0lD6a9DCOeI0IuN4GsnrkyGcYirDdRh6wQRCEeIlzN7BYBeU0J5oWNec95DR9UpojuQdk71n9fsbnge20K/HEElhFNDwyEjXjPqNed8VDEMGh31XukptvwtkRN01Iz6ASJh3E4gPzXwAKWGuTiA+NptYTdUl2BXkFIM5hTG+BrtKjLsgBmOwBt0t7C6UOdgQHDad3JUQOoDkYIgmkBJc1QSiwdBNIBa84RhSUjCYE0h0qROI29SD7RYKbngC4WCpJ5Cubjm6oxzM+j1xO4+/BjU8GozL7e7ybQ5xm69wAOkKKs2PoRt95QNIV1AlnnC3+lp2wa6S6i7YdVHbBbsudtBY3OAbzNuTO3zDOcQtvlFsju7qjXfBrkQzvJNm7E7eSmzi3cpruk+E0TrpEJjPo27tNdF8/nVvr+lginZzr0nmA7q7e015Ouaxe/07ZOQgsHv9DTJiwQ5pYkk3s9jd/T2IQ2qOEPZ1rqBOXRemHCE6pC4BkpNTawzCkNoiZDSEEVKElCEEIqRbDgQMwZKG6yhC0NdxDNJwnQQhh+4eIYc0FnHqEoqoDCsEYp35AweCxeCwbDAFiD/gIEKo6+GDESKG06FeE+i64PSZC5HDwRs+uaH7ebPp8x+6nzedPkWiu/veGfzpE93PexCG1Baajg2Lz/28yQEk9jN/Zkb3873zDZ+10f38ChlRc2ix/jIA3c/b/B0Uup+3+csMpDgDJhANs8Nfk6C7+z5l7kH38zp/HYTu7lUOIHEaTiAUZuoC2W+7QXw24gFEwvCeQHxupg7xc+9mv5R91B0F76NuIvYM7umzM9DgHt3TZzmAuPOiAwgFoziB8O5F4BAif4F8r5Q7/PvLwiGk7N4WDiH+QjEfQGz3vnAEcfcvdADxd4p4AMHda8chpKsrB+r6UwPrAcTfOe7LyR8U/hqtGvY34u+v3z7/558/Lv/xpT4NfPzw++u32wu3H+3Sfv/by9unr59fllDpf59J+w8sOH9l/+/r2+sv3z6/NzTU2fjMUBuIScLlr+hL7Pbz8/8A9Aw2sQ==')
    g.label = 'Circle'
    g.id = 'circle'
    gdb.add_gesture(g)


def action_close_menu(menu, w, args, *largs):
    menu.parent.remove_widget(menu)
    del menu

def action_close_all(menu, w, args):
    sys.exit()

def action_launch_plugin(menu, w, plugin, *largs):
    if not menu.parent:
        return
    pos = w.parent.to_parent(*w.pos)
    win = MTInnerWindow(size=(320,280), pos=pos)
    plugins.activate(plugin, win)
    menu.parent.add_widget(win)

    action_close_menu(menu, w, None)

class MTActionButton(MTButton):
    def __init__(self, **kwargs):
        kwargs.setdefault('action', None)
        kwargs.setdefault('args', None)
        super(MTActionButton, self).__init__(**kwargs)
        self.height = self.label_obj.content_height + 10
        self.width = self.label_obj.content_width + 10
        self.action = kwargs.get('action')
        self.args = kwargs.get('args')

    def on_touch_up(self, touch):
        if not self.collide_point(touch.x, touch.y):
            return
        if self.action:
            self.action(self.parent, self, self.args)

class MTMenuItem(MTKineticItem):
    def __init__(self, path, label, icon, **kwargs):
        super(MTMenuItem, self).__init__(**kwargs)
        self._label = MTLabel(label=label, font_size=12, anchor_x='left',
                           anchor_y='center', size=(self.width, self.height),
                             color=self.style.get('color'))
        self._icon = None
        try:
            ficon = None
            for icon_filename in (icon, 'icon.png'):
                ficon = os.path.join(path, icon_filename)
                if os.path.exists(ficon):
                    break
                ficon = None
            if ficon is not None:
                self._icon = Loader.image(ficon)
        except:
            pass

    def on_move(self, x, y):
        # don't invalidate cache when moving position
        # we'll optimize the position by using pop/push matrix
        pass

    def draw(self):
        with gx_matrix:
            glTranslatef(self.x, self.y, 0)
            set_color(.2, .2, .2, .5)
            drawRectangle(size=self.size)
            self._label.x = 32
            self._label.y = (self.height - self._label.height) / 2.
            self._label.draw()
            if self._icon:
                self._icon.x = (32 - self._icon.width) / 2.
                self._icon.y = (self.height - self._icon.height) / 2.
                self._icon.draw()

class MTMenu(MTKineticList):
    def __init__(self, **kwargs):
        kwargs.setdefault('title', None)
        kwargs.setdefault('searchable', False)
        kwargs.setdefault('deletable', False)
        kwargs.setdefault('padding_x', 0)
        kwargs.setdefault('padding_y', 1)
        super(MTMenu, self).__init__(**kwargs)

        self.size = (190, 230)
        self.center = self.pos
        self.fbo = Fbo(size=self.size)

        self.orig_x = self.x
        self.orig_y = self.y
        self.color = kwargs.get('color')
        self.alpha = 0
        self.dragpos = 0, 0
        self.dragid = 0

        w = MTKineticItem(label='Close Menu', size=(190, 32),
                          style={'font-size': 12, 'bg-color': (.2, .2, .2, .9)})
        w.push_handlers(on_press=curry(action_close_menu,
            self, w, []))
        self.add_widget(w)

        pluginlist = plugins.list()
        keylist = sorted(pluginlist, cmp=lambda x,y:
            cmp(plugins.get_infos(pluginlist[x]).get('title').lower(),
                plugins.get_infos(pluginlist[y]).get('title').lower()))
        for key in keylist:
            plugin = pluginlist[key]
            infos = plugins.get_infos(plugin)
            w = MTMenuItem(infos.get('path'), infos.get('title'), infos.get('icon'), size=(190, 32))
            w.push_handlers(on_press=curry(action_launch_plugin,
                self, w, plugin))
            self.add_widget(w)

    def on_draw(self):
        self.alpha += getFrameDt() * 3
        if self.alpha < 1:
            with DO(self.fbo, gx_matrix):
                glTranslatef(-self.x, -self.y, 0)
                super(MTMenu, self).on_draw()
            set_color(1, 1, 1, self.alpha)
            a = (1 - self.alpha) * 100
            pos = Vector(self.pos) + Vector(a, a)
            size = Vector(self.size) - Vector(a, a) * 2
            drawTexturedRectangle(texture=self.fbo.texture, pos=pos, size=size)
        else:
            super(MTMenu, self).on_draw()

    def collide_menu(self, x, y):
        if x > self.x and x < self.x + self.width and \
            y > self.y + self.height and y < self.y + self.height + 40:
            return True

    def on_touch_down(self, touch):
        if self.collide_menu(touch.x, touch.y):
            self.dragpos = touch.x - self.x, touch.y - self.y
            self.dragid = touch.uid
            touch.grab(self)
            return True
        return super(MTMenu, self).on_touch_down(touch)

    def on_touch_move(self, touch):
        if touch.grab_current == self and self.dragid == touch.uid:
            self.pos = Vector(touch.pos) - Vector(self.dragpos)
            return True
        return super(MTMenu, self).on_touch_move(touch)

    def on_touch_up(self, touch):
        if touch.grab_current == self and self.dragid == touch.uid:
            touch.ungrab(self)
            return True
        return super(MTMenu, self).on_touch_up(touch)

    def draw(self):
        set_color(*self.style.get('bg-color'))

        # outter
        pos = self.x - 5, self.y - 5
        size = self.width + 10, self.height + 40
        drawRoundedRectangle(pos=pos, size=size)

        # title
        drawLabel(label='Menu', pos=(self.x + 5, self.y + self.height + 4),
                  font_size=16, center=False)

        super(MTMenu, self).draw()


class MTGestureDetector(MTGestureWidget):
    def __init__(self, gdb, **kwargs):
        super(MTGestureDetector, self).__init__(**kwargs)
        self.gdb = gdb
        self.dt = 0
        self.inactivity = 0
        self.inactivity_timeout = 5

    def on_touch_down(self, touch):
        touch.userdata['desktop.gesture'] = list(touch.pos)
        return super(MTGestureDetector, self).on_touch_down(touch)

    def on_touch_move(self, touch):
        if 'desktop.gesture' in touch.userdata:
            touch.userdata['desktop.gesture'] += list(touch.pos)
        return super(MTGestureDetector, self).on_touch_move(touch)

    def draw(self):
        # draw gestures
        set_color(1, 1, 1, .6)
        for touch in getCurrentTouches():
            if not 'desktop.gesture' in touch.userdata:
                continue
            drawLine(touch.userdata['desktop.gesture'], width=5.)

        if len(getCurrentTouches()):
            self.inactivity = 0
            return
        self.inactivity += getFrameDt()
        if self.inactivity < self.inactivity_timeout:
            return
        alpha = (self.inactivity - self.inactivity_timeout) / 3.
        alpha = boundary(alpha, 0, 1.)

        w = self.get_parent_window()
        s2 = Vector(w.size) / 2.
        self.dt += getFrameDt() * 2

        step = math.pi / 20.
        radius = 50
        i = 0
        with DO(gx_attrib(GL_LINE_BIT), gx_blending):
            glLineWidth(3)
            with gx_begin(GL_LINE_STRIP):
                while i < math.pi * 2:
                    x, y = math.cos(self.dt - i) * radius, math.sin(self.dt - i) * radius
                    glColor4f(1, 1, 1, min(alpha, i / math.pi))
                    glVertex2f(x + s2.x, y + s2.y - 70)
                    i += step

            set_color(1, 1, 1, alpha)
            drawCircle(pos=(x + s2.x, y + s2.y - 70), radius=4)
            drawCircle(pos=(x + s2.x, y + s2.y - 70), radius=20, linewidth=2)

        label='Draw a circle to make the menu appear'
        k = {'font_size': 24, 'bold': True}
        pos = Vector(w.size) / 2. + Vector(0, 10)
        drawLabel(label=label, pos=pos, color=(.5, .5, .5, min(alpha, .5)), **k)
        pos += Vector(1, -1)
        drawLabel(label=label, pos=pos, color=(1, 1, 2, alpha), **k)

    def on_gesture(self, gesture, touch):
        #print self.gdb.gesture_to_str(gesture)
        # NOT WORKING WITH BIG SETUP.
        # 1/10 is really too big.
        # Check whether gesture is to small
        #if ((gesture.width < self.parent.width / 10) or ((gesture.height < self.parent.height / 10)):
        #if (gesture.width < self.parent.width / 10) or (gesture.height < self.parent.height / 10):
        #    return

        try:
            score, best = self.gdb.find(gesture, minscore=.5)
        except Exception, e:
            return

        if best.id == 'circle':
            angle = gesture.get_rigid_rotation(best)
            menu = MTMenu(pos=(touch.x, touch.y), color=(.2, .2, .2, .5), rotation=angle)
            self.parent.add_widget(menu)


if __name__ == '__main__':
    import os

    # Create and fill gesture database
    gdb = GestureDatabase()
    gesture_add_default(gdb)

    # Create background window
    w = getWindow()
    w.wallpaper = os.path.join(os.path.dirname(__file__), 'data', 'wallpaper.jpg')
    w.wallpaper_position = 'strech'

    g = MTGestureDetector(gdb)
    w.add_widget(g)

    runTouchApp()

########NEW FILE########
__FILENAME__ = desktop-single
'''
Single Desktop User

A very simple desktop, made to be used by one user only.
Feature coverflow widget, xml widget and css styling.

Mathieu
'''

from os.path import join, dirname, exists
from pymt import *

current_dir = dirname(__file__)

class DesktopClose(MTButton):
    def __init__(self, **kwargs):
        super(DesktopClose, self).__init__(**kwargs)
        self.radius = kwargs['radius']

    def draw_background(self):
        if self.state == 'down':
            set_color(.8, .0, .0, .8)
        else:
            set_color(.0, .0, .0, .8)
        drawCircle(pos=self.pos, radius=self.radius)
        set_color(.7, .7, .7, .8)
        drawCircle(pos=self.pos, radius=self.radius, linewidth=1.5)

    def collide_point(self, x, y):
        return Vector(self.pos).distance((x, y)) <= self.radius

class Desktop(MTBoxLayout):
    layout_def = '''
    <MTBoxLayout orientation='"vertical"' cls='"desktop-background"'>
        <MTCoverFlow size_hint='(1, .7)' cls='"desktop-coverflow"'
            thumbnail_size='(256, 256)' cover_distance='150' id='"coverflow"'/>
        <MTAnchorLayout size_hint='(1, .3)'>
            <MTBoxLayout cls='"form"' padding='20' orientation='"vertical"'>
                <MTLabel id='"title"' label='"Unknown Title"' autosize='True'
                    cls='"desktop-title"' anchor_x='"center"'/>
                <MTLabel id='"author"' label='"Unknown Author"' autosize='True'
                    cls='"desktop-author"' anchor_x='"center"'/>
                <MTLabel id='"description"' label='"Unknown Description"' autosize='True'
                    cls='"desktop-description"' anchor_x='"center"'/>
            </MTBoxLayout>
        </MTAnchorLayout>
    </MTBoxLayout>
    '''

    def __init__(self, **kwargs):
        super(Desktop, self).__init__(**kwargs)
        self.xml = xml = XMLWidget(xml=Desktop.layout_def)
        self.xml.autoconnect(self)
        self.add_widget(self.xml.root)
        self.coverflow = xml.getById('coverflow')
        self.title = xml.getById('title')
        self.author = xml.getById('author')
        self.description = xml.getById('description')
        self.populate()

    def populate(self):
        # search plugins
        self.plugins = plugins = MTPlugins(plugin_paths=[
            join(current_dir, '..', 'apps'),
            join(current_dir, '..', 'games')
        ])
        plugins.search_plugins()

        # populate the coverflow with plugin list
        first_entry = None
        for key in plugins.list():
            plugin = plugins.get_plugin(key)
            infos = plugins.get_infos(plugin)

            icon = None
            for icon_filename in ('icon-large.png', 'icon-large.jpg',
                                  infos['icon'], 'icon.png'):
                icon = join(infos['path'], icon_filename)
                if exists(icon):
                    break
                icon = None

            # no icon ?
            if icon is None:
                print 'No icon found for', infos['title']
                continue

            # create an image button for every plugin
            button = MTImageButton(filename=icon)
            if first_entry is None:
                first_entry = button
            button.infos = infos
            button.plugin = plugin
            self.coverflow.add_widget(button)

        # display first entry
        if first_entry:
            self.show_plugin(first_entry)

    def on_coverflow_change(self, widget):
        '''Called when the coverflow widget is changed
        '''
        self.show_plugin(widget)

    def on_coverflow_select(self, widget):
        '''Called when the coverflow widget have a selection
        '''
        plugin = widget.plugin
        win = self.parent
        self.plugins.activate(plugin, self.parent)
        for pos in ((0, 0), (win.width, 0)):
            close_button = DesktopClose(radius=75, pos=pos)
            close_button.connect('on_release', curry(
                self.on_plugin_close, self.parent, plugin))
            self.parent.add_widget(close_button)
        self.parent.remove_widget(self)

    def on_plugin_close(self, win, plugin, *largs):
        '''Called when the close button is hitted
        '''
        self.plugins.deactivate(plugin, win)
        win.children.clear()
        win.add_widget(self)

    def show_plugin(self, widget):
        '''Show information about a plugin in the container
        '''
        self.title.label = widget.infos['title']
        self.author.label = widget.infos['author']
        self.description.label = widget.infos['description']

if __name__ == '__main__':
    # manual add cause of font path
    with open(join(current_dir, 'data', 'desktop-single.css')) as fd:
        css_data = fd.read() % dict(fontpath=join(current_dir, 'data', ''))
    css_add_sheet(css_data)
    runTouchApp(Desktop())

########NEW FILE########
__FILENAME__ = animation
from pymt import *
from OpenGL.GL import *

class MTSprite(MTWidget):
    def __init__(self, **kwargs):
        super(MTSprite, self).__init__(**kwargs)
        self.rotation = 0
        self.filename		= kwargs.get('filename')
        self.image     = pymt.Image(self.filename)
        self.size           = self.image.size
        self.scale = self.style.get('scale')
        self.intial_pos = self.pos

    def draw(self):
        with gx_matrix:
            glTranslated(self.x+self.width/2,self.y+self.height/2,0)
            glRotated(int(self.rotation),0,0,1)
            glTranslated(-self.x-self.width/2,-self.y-self.height/2,0)
            set_color(*self.style.get('bg-color'))
            self.scale = self.style.get('scale')
            self.image.pos  = self.pos
            self.image.scale= self.scale
            self.size = self.image.size
            self.image.draw()


    def reset(self):
        self.size = self.image.size
        self.style['scale'] = 1.0
        self.pos = self.intial_pos
        self.rotation = 0
        self.image.pos  = self.pos
        self.image.scale= self.scale


m = MTWindow()

#Set up buttons
but_layout = MTGridLayout(cols=5,rows=1)
m.add_widget(but_layout)
reset = MTButton(label="Reset",height=50)
but_layout.add_widget(reset)

simple = MTButton(label="Simple",height=50)
but_layout.add_widget(simple)

sequence = MTButton(label="Sequence",height=50)
but_layout.add_widget(sequence)

parallel = MTButton(label="Parallel",height=50)
but_layout.add_widget(parallel)

repeat_delta = MTButton(label="Repeat",height=50)
but_layout.add_widget(repeat_delta)

but_layout.x = m.width/2-but_layout.width/2 #Align button at the bottom-center


#Add Objects
greeny = MTSprite(filename="icons/greeny.png" ,pos=(100,100), style={'scale':1.0})
m.add_widget(greeny)

#Construct Animations
movX = Animation(duration=1, x=m.width/2-greeny.width/2)
movY = Animation(duration=1, y=m.height/2-greeny.height/2)
movXY = Animation(duration=1, pos=(m.width/2-greeny.width/2, m.height/2-greeny.height/2)) #Move to center
rot360 = Animation(duration=2, rotation=720)
scale = Animation(duration=1.5, scale=2)

mov_dxy = Animation(duration=0.5, pos=(50,50), type="delta")
mov_dx = Animation(duration=0.5, x=50, type="delta")
rot_d = Animation(duration=0.5, rotation=45, type="delta")

mov_x = Animation(duration=1, x=250)
rot = Animation(duration=1, rotation=15)

seq = movX + movY + rot360 + scale

pll = movX & movY & rot360 & scale

repeat_delta_anim = Repeat(mov_dx + rot_d, times=6)

#handle button press
@reset.event
def on_press(*largs):
    greeny.reset()

@simple.event
def on_press(*largs):
    greeny.do(movXY)

@sequence.event
def on_press(*largs):
    greeny.do(seq)

@parallel.event
def on_press(*largs):
    greeny.do(pll)

@repeat_delta.event
def on_press(*largs):
    greeny.do(repeat_delta_anim)

runTouchApp()

########NEW FILE########
__FILENAME__ = animation_functions
from pymt import *
from OpenGL.GL import *
import random, math

class MTSprite(MTWidget):
    def __init__(self, **kwargs):
        super(MTSprite, self).__init__(**kwargs)
        self.rotation = 0
        self.filename		= kwargs.get('filename')
        self.image     = pymt.Image(self.filename)
        self.size           = self.image.size
        self.scale = 1.0
        self.intial_pos = self.pos

    def draw(self):
        with gx_matrix:
            glTranslated(self.x+self.width/2,self.y+self.height/2,0)
            glRotated(int(self.rotation),0,0,1)
            glTranslated(-self.x-self.width/2,-self.y-self.height/2,0)
            set_color(*self.style.get('bg-color'))
            self.image.pos  = self.pos
            self.image.scale= self.scale
            self.size = self.image.size
            self.image.draw()

    def reset(self):
        self.size = self.image.size
        self.scale = 1.0
        self.pos = self.intial_pos
        self.rotation = 0
        self.image.pos  = self.pos
        self.image.scale= self.scale

w = MTWindow(style={'bg-color':(0,0,0)})
getWindow().gradient = False

objlist = [] #List of sprites

for i in range(64):
    x = int(random.uniform(100, w.width-100))
    y = int(random.uniform(100, w.height-100))
    obj = MTSprite(pos=(x,y), filename="icons/clock.png")
    objlist.append(obj)
    w.add_widget(obj)

#Set up buttons
but_layout = MTGridLayout(cols=4,rows=2)
w.add_widget(but_layout)
randomize = MTButton(label="Randomize",height=50)
but_layout.add_widget(randomize)

grid = MTButton(label="Grid",height=50)
but_layout.add_widget(grid)

circular = MTButton(label="Circular",height=50)
but_layout.add_widget(circular)

bowtie = MTButton(label="Bow Tie",height=50)
but_layout.add_widget(bowtie)

but_layout.x = w.width/2-but_layout.width/2 #Align button at the bottom-center

#handle button press
@randomize.event
def on_press(*largs):
    anim_list = []
    for i in range(64):
        x = int(random.uniform(100, w.width-100))
        y = int(random.uniform(100, w.height-100))
        anim_list.append(Animation(duration=1.5, pos=(x,y), alpha_function="ease_in_out_back"))

    i = 0
    for obj in objlist:
        obj.do(anim_list[i])
        i += 1

@grid.event
def on_press(*largs):
    anim_list = []
    for i in range(8):
        for j in range(8):
            x = j*64+100
            y = i*64+40
            anim_list.append(Animation(duration=1.5, pos=(x,y), alpha_function="ease_in_out_back"))

    i = 0
    for obj in objlist:
        obj.do(anim_list[i])
        i += 1

@circular.event
def on_press(*largs):
    anim_list = []
    for i in range(64):
        teta = math.radians(8*i)
        x = 200 * math.cos(teta)+w.width/2
        y = 200 * math.sin(teta)+w.height/2
        anim_list.append(Animation(duration=1.5, pos=(x,y), alpha_function="ease_in_out_back"))

    i = 0
    for obj in objlist:
        obj.do(anim_list[i])
        i += 1

@bowtie.event
def on_press(*largs):
    anim_list = []
    for i in range(64):
        teta = math.radians(8*i)
        x = 200 * math.cos(teta)+w.width/2
        y = 200 * math.sin(teta*2)+w.height/2
        anim_list.append(Animation(duration=1.5, pos=(x,y), alpha_function="ease_in_out_back"))

    i = 0
    for obj in objlist:
        obj.do(anim_list[i])
        i += 1

runTouchApp()
########NEW FILE########
__FILENAME__ = base_event_dispatcher
'''
Create a event dispatcher, and use it to get all event from PyMT
Without any OpenGL window created.
'''

# prevent window creation
import os

os.environ['PYMT_SHADOW_WINDOW'] = '0'
from pymt import *

# create a class to catch all events
class TouchEventListener:
    def dispatch_event(self, event_name, *arguments):
        print 'Event dispatched', event_name, 'with', arguments

# append the class to event listeners
pymt_event_listeners.append(TouchEventListener())

# start pymt subsystem
runTouchApp(slave=True)

# now you can run your application,
# and don't forget to update PyMT subsystem
while True:
    # update pymt subsystem
    getEventLoop().idle()

    # do your own thing.
    pass


########NEW FILE########
__FILENAME__ = audio
'''
Test of audio core, with event play/stop.
'''

import os
from pymt import *

# load the sound
filename = os.path.join(os.path.dirname(__file__), 'test_audio.wav')
sound = SoundLoader.load(filename)

# install callack for on_play/on_stop event
@sound.event
def on_play():
    print '-> sound started, status is', sound.status

@sound.event
def on_stop():
    print '-> sound finished, status is', sound.status
    stopTouchApp()

# start to play the sound
sound.play()

# run the application
runTouchApp()


########NEW FILE########
__FILENAME__ = camera
from pymt import *

scat = MTScatterWidget()

s = MTWidget()
c = Camera()
@s.event
def on_draw():
    c.update()
    c.draw()

scat.add_widget(s)
scat.size = (c.width, c.height)

runTouchApp(scat)

########NEW FILE########
__FILENAME__ = exceptions
# Simple exemple of exception handler
# Exeption will be catch, and set the return to PASS
# So, app will be not stopped by this.

from pymt import *

class E(ExceptionHandler):
    def handle_exception(self, inst):
        pymt_logger.exception(inst)
        return ExceptionManager.PASS

pymt_exception_manager.add_handler(E())

m = MTWindow()
t = MTButton()
@t.event
def on_press(*largs):
    print a
m.add_widget(t)
runTouchApp()

########NEW FILE########
__FILENAME__ = loader
from pymt import *

# asynchronous load the image in http
img = Loader.image('http://pymt.eu/styles/logo.png')

# add a container with the core image, and display it
runTouchApp(MTContainer(img))

########NEW FILE########
__FILENAME__ = ui_colors_cssreload
from pymt import *

css_add_file('reload.css')

b1 = MTButton(id='btn1', label='Reload CSS', pos=(100, 100))
b2 = MTButton(id='btn2', label='Button 2', pos=(250, 100))

@b1.event
def on_press(*largs):
    css_reload()

w = getWindow()
w.add_widget(b1)
w.add_widget(b2)

runTouchApp()

########NEW FILE########
__FILENAME__ = ui_dragable
from pymt import *
from random import random

window = getWindow()

# create 100 dragable object with random position and color
w, h = window.size
for i in xrange(100):
    x = random() * w
    y = random() * h
    window.add_widget(MTDragable(pos=(x, y),
        style={'bg-color': get_random_color(), 'draw-background': 1}))

runTouchApp()

########NEW FILE########
__FILENAME__ = ui_dragable_as_container
from pymt import *
from random import random

css_add_sheet('dragablelabel { draw-background: 1; }')

class DragableLabel(MTDragable):
    def __init__(self, **kwargs):
        super(DragableLabel, self).__init__()
        self.label = MTLabel(**kwargs)
        self.add_widget(self.label)

    def on_update(self):
        self.label.pos = interpolate(self.label.pos, self.pos)
        self.size = interpolate(self.size, self.label.size)
        super(DragableLabel, self).on_update()

window = getWindow()
w, h = window.size

for text in ('My dog is lazy', 'My cat is sleeping', 'Hello world'):
    # Make a label dragable
    label = DragableLabel(label=text, padding=40)

    # randomize a position
    label.center = w * random(), h * random()

    # add to window
    window.add_widget(label)

runTouchApp()


########NEW FILE########
__FILENAME__ = ui_kinetic
from pymt import *

css_add_sheet('.rect { draw-background: 1; }')

# create a kinetic object
kinetic = MTKinetic()

# add some object on kinetic place
kinetic.add_widget(MTDragable(cls='rect', style={'bg-color': (1, .2, .2, 1)}))
kinetic.add_widget(MTDragable(cls='rect', style={'bg-color': (.2, 1, .2, 1)}))
kinetic.add_widget(MTDragable(cls='rect', style={'bg-color': (.2, .2, 1, 1)}))

# run app with kinetic plane
runTouchApp(kinetic)

########NEW FILE########
__FILENAME__ = ui_klist
from pymt import *

# create a list with no possibility to move on Y axis
wlist = MTList(size=getWindow().size, do_y=False)

# create a grid layout to use inside the list
wlayout = MTGridLayout(rows=5)
wlist.add_widget(wlayout)

# create a lot of button. you should be able to click on it, and
# move the list in X axis
for x in xrange(100):
    wlayout.add_widget(MTToggleButton(label=str(x)))

runTouchApp(wlist)

########NEW FILE########
__FILENAME__ = ui_widgets_button
'''
Button example with all events in button.
'''

from pymt import *

b = MTButton(label='Push me')
@b.event
def on_press(*largs):
	print 'on_press()', b.state, largs

@b.event
def on_release(*largs):
	print 'on_release()', b.state, largs

@b.event
def on_state_change(*largs):
    print 'on_state_change()', b.state, largs

runTouchApp(b)

########NEW FILE########
__FILENAME__ = ui_widgets_buttonmatrix
from pymt import *

# create a custom 10x10 matrix, fullscreen
m = MTButtonMatrix(matrix_size=(10, 10), size_hint=(1, 1))

# create a default handler for the on_press event
def m_on_press(args):
    # extract row / column / state
    row, column, state = args
    print 'matrix change at %d x %d = %s' % (row, column, state)

# connect the handler to the widget
m.connect('on_press', m_on_press)

runTouchApp(m)

########NEW FILE########
__FILENAME__ = ui_widgets_button_align
from pymt import *

w = MTWidget()

y = 0
for halign in ('left', 'center', 'right'):
    y += 100
    x = 100
    for valign in ('top', 'center', 'bottom'):
        m = MTButton(label='%s:%s' % (halign, valign),
                     pos=(x, y), size=(150, 30),
                     anchor_x=halign, anchor_y=valign)
        x += 200
        w.add_widget(m)

runTouchApp(w)

########NEW FILE########
__FILENAME__ = ui_widgets_button_css
from pymt import *

# Create a CSS with 2 rules
additional_css = '''
.simple {
	draw-alpha-background: 0;
	draw-border: 0;
	draw-text-shadow: 1;
}

.colored {
	bg-color: rgb(68, 170, 0);
	border-radius: 20;
	border-radius-precision: .1;
	font-size: 16;
}
'''

# Add the CSS into PyMT
css_add_sheet(additional_css)

# Create different button, with one or 2 rules at the same time
v = MTBoxLayout(orientation='vertical', padding=20, spacing=20)
v.add_widget(MTButton(label='Coucou'))
v.add_widget(MTButton(label='Coucou', cls='simple'))
v.add_widget(MTButton(label='Coucou', cls='colored'))
v.add_widget(MTButton(label='Coucou', cls=('simple', 'colored')))

runTouchApp(v)

########NEW FILE########
__FILENAME__ = ui_widgets_button_toggle
from pymt import *

b = MTToggleButton(label='Push me')

@b.event
def on_press(*largs):
	print 'on_press()', b.state, largs

@b.event
def on_release(*largs):
	print 'on_release()', b.state, largs

runTouchApp(b)

########NEW FILE########
__FILENAME__ = ui_widgets_composed_colorpicker
from pymt import *
runTouchApp(MTColorPicker())

########NEW FILE########
__FILENAME__ = ui_widgets_composed_filebrowser
from pymt import *

# create the filebrowser
fb = MTFileBrowser()

# when selection will be done, it will print the selected files
@fb.event
def on_select(list):
    print list

runTouchApp(fb)

########NEW FILE########
__FILENAME__ = ui_widgets_composed_textarea
# Text area (multiline text input)
from pymt import *

text = '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin cursus bibendum blandit. Morbi semper elit eu urna sagittis id sagittis lorem viverra. Duis ac nulla nisl. Aliquam erat volutpat. Morbi sit amet nunc mi. Ut id lectus sed ipsum suscipit tincidunt vitae in leo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Praesent consectetur elit ac nunc mattis commodo. Sed pharetra tellus vel nibh sollicitudin tincidunt. Integer sed felis faucibus sapien dictum imperdiet eget quis ipsum. Nunc ut quam justo, sit amet egestas lacus.

Donec et sem in libero luctus viverra. Phasellus nec libero diam, ac ullamcorper arcu. Maecenas vitae mi diam. Pellentesque imperdiet mauris non ipsum hendrerit bibendum. Aliquam erat volutpat. Nulla vel hendrerit risus.'''

wid = MTTextArea(size=(500, 500), padding=10, label=text, font_size=10)
wid.center = getWindow().center

@wid.event
def on_text_validate():
    print 'Text have been validated:', wid.value

@wid.event
def on_text_change(text):
    print 'Text have been changed (not validated):', text

runTouchApp(wid)


########NEW FILE########
__FILENAME__ = ui_widgets_composed_textinput
# Text input widget with a switch to use hardware keyboard or not
from pymt import *

wid = MTTextInput()

@wid.event
def on_text_change(text):
    print 'Text have been changed (not validated):', text

runTouchApp(wid)

########NEW FILE########
__FILENAME__ = ui_widgets_composed_vkeyboard
from pymt import *
keyboard = MTVKeyboard()

@keyboard.event
def on_key_down(*largs):
    print 'key down:', largs

@keyboard.event
def on_key_up(*largs):
    print 'key up:', largs

@keyboard.event
def on_text_change(*largs):
    print 'text change', largs

runTouchApp(keyboard)

########NEW FILE########
__FILENAME__ = ui_widgets_composed_vkeyboardspellcheck
from pymt import *
m = MTTextInput(keyboard=MTSpellVKeyboard(), font_size=42)
 
runTouchApp(m)

########NEW FILE########
__FILENAME__ = ui_widgets_composed_vkeyboard_numerical
from pymt import *

# create a custom layout, a numerical one
class NumericKeyboardLayout(KeyboardLayout):
    ID              = 'numeric'
    TITLE           = 'Numeric keyboard'
    DESCRIPTION     = ''
    SIZE            = (4, 4)
    NORMAL_1 = [
        ('7', '7', None, 1),    ('8', '8', None, 1),    (u'9', u'9', None, 1),
        (u'\u2a2f', None, 'escape', 1),
    ]
    NORMAL_2 = [
        ('4', '4', None, 1),    ('5', '5', None, 1),    (u'6', u'6', None, 1),
    ]
    NORMAL_3 = [
        ('1', '1', None, 1),    ('2', '2', None, 1),    (u'3', u'3', None, 1),
        (u'\u232b', None, 'backspace', 1),
    ]
    NORMAL_4 = [
        ('0', '0', None, 1),    (',', ',', None, 2),
        (u'\u23ce', None, 'enter', 1)
    ]

# create a keyboard, with our custom layout
k = MTVKeyboard(layout=NumericKeyboardLayout(), size=(400, 300))

# create a instance of textinput, with this keyboard by default
m = MTTextInput(keyboard=k)

runTouchApp(m)

########NEW FILE########
__FILENAME__ = ui_widgets_container
from pymt import *
import os

# load an image
current_dir = os.path.dirname(__file__)
image = Image(os.path.join(current_dir, 'image.jpg'))

# create a scatter container, and put the image in
scatter = MTScatterContainer(image)

runTouchApp(scatter)

########NEW FILE########
__FILENAME__ = ui_widgets_coverflow
from pymt import *
from glob import glob
from OpenGL.GL import *
import os

if __name__ == '__main__':
    base_image = os.path.join(os.path.dirname(__file__),
                          '..', 'apps', 'pictures', 'images')
    coverflow = MTCoverFlow(size_hint=(1, 1),
            trigger_cover_distance=100)
    for filename in glob(os.path.join(base_image, '*.jpg')):
        button = MTImageButton(image=Loader.image(filename))
        button.title = os.path.basename(filename)
        coverflow.add_widget(button)

    @coverflow.event
    def on_change(cover):
        print 'cover changed', cover.title

    @coverflow.event
    def on_select(cover):
        print 'cover selected', cover.title

    runTouchApp(coverflow)

########NEW FILE########
__FILENAME__ = ui_widgets_flippable
from pymt import *

widget = MTFlippableWidget()
widget.add_widget(MTLabel(label='Front'), side='front')
widget.add_widget(MTLabel(label='Back'), side='back')

@widget.event
def on_touch_down(touch):
    widget.flip()

runTouchApp(widget)

########NEW FILE########
__FILENAME__ = ui_widgets_label
from pymt import *

# for our example, force drawing of background for all label
c = '''label {
    draw-background: 1;
    bg-color: rgb(0,0,255,120);
}'''
css_add_sheet(c)

# add all the label to the window
m = getWindow()

# testing autowidth/autoheight
l = MTLabel(label='Label1: PLOP Woooooooooooooooot !', font_size=24, autowidth=True, autoheight=True, pos=(200, 400))
m.add_widget(l)

# testing multiline with autowidth/autoheight
l2 = MTLabel(label='Label2: Mwhahahaha\nLabel2: :)', pos=(200, 300), autowidth=True, autoheight=True)
m.add_widget(l2)

# testing multiline + padding + align
l3 = MTLabel(label='Plop\nworld', pos=(200, 200), autosize=True, padding=10)
l4 = MTLabel(label='Plop\nworld', pos=(300, 200), autosize=True, padding=10, halign='center')
l5 = MTLabel(label='Plop\nworld', pos=(400, 200), autosize=True, padding=10, halign='right')
m.add_widget(l3)
m.add_widget(l4)
m.add_widget(l5)

runTouchApp()

########NEW FILE########
__FILENAME__ = ui_widgets_layout
import random
from pymt import *


def simple_box_layout_test():
    root = MTBoxLayout()
    root.add_widget(MTButton(label="button 1"))
    root.add_widget(MTButton(label="button 2"))
    root.add_widget(MTButton(label="button 3"))
    return root

def vertical_box_layout_test():
    root = MTBoxLayout(orientation='vertical', id='vertical', size_hint=(2.0,1.0), bg_color=(0,1,0,0.3))
    root.add_widget(MTButton(label="button 1"))
    root.add_widget(MTButton(label="button 2"))
    root.add_widget(MTButton(label="button 3"))
    return root

def size_hint_box_layout_test():
    root = MTBoxLayout(width=())
    root.add_widget(MTButton(label="button 1"))
    root.add_widget(MTButton(label="button 2"))
    root.add_widget(MTButton(label="button 3"))
    return root

def stacked_box_layout():
    root = MTBoxLayout(id='root', size_hint=(1.0,1.0),bg_color=(1,0,0,0.3))
    root.add_widget(MTButton(label="button", size_hint=(1.0, 1.0)))
    root.add_widget(simple_box_layout_test())
    root.add_widget(vertical_box_layout_test())
    root.add_widget(MTButton(label="button"))
    return root

if __name__ == '__main__':
    root = stacked_box_layout()
    runTouchApp(root)
########NEW FILE########
__FILENAME__ = ui_widgets_list
from pymt import *

# callback for the buttons
def test_button(btn, *largs):
    print 'button pressed', btn.label

# create a grid layout with 2 rows
layout = MTGridLayout(rows=2)
for x in xrange(22):
    btn = MTToggleButton(label='label%d' % x)
    btn.connect('on_press', curry(test_button, btn))
    layout.add_widget(btn)

# create a list of 400x200 size, and disable scrolling on Y axis
lst = MTList(size=(400, 200), do_y=False)
lst.add_widget(layout)

# center the list on the screen
anchor = MTAnchorLayout()
anchor.add_widget(lst)

runTouchApp(anchor)

########NEW FILE########
__FILENAME__ = ui_widgets_list_xy
from pymt import *

# callback for the buttons
def test_button(btn, *largs):
    print 'button pressed', btn.label

# create a grid layout with 2 rows
layout = MTGridLayout(rows=4)
for x in xrange(50):
    btn = MTToggleButton(label='label%d' % x)
    btn.connect('on_press', curry(test_button, btn))
    layout.add_widget(btn)

# create a list of 400x400 size
# default is on both axis
lst = MTList(size=(400, 400))
lst.add_widget(layout)

# center the list on the screen
anchor = MTAnchorLayout()
anchor.add_widget(lst)

runTouchApp(anchor)

########NEW FILE########
__FILENAME__ = ui_widgets_objectdisplay
# Simple example to show fiducial on screen
from pymt import *
runTouchApp(MTObjectDisplay())

########NEW FILE########
__FILENAME__ = ui_widgets_radial
from pymt import *

sl = MTVectorSlider(pos=getWindow().center)

@sl.event
def on_amplitude_change(value):
    print 'Slider amplitude change', value

@sl.event
def on_angle_change(value):
    print 'Slider angle change', value

@sl.event
def on_vector_change(x, y):
    print 'Slider vector change', x, y

runTouchApp(sl)

########NEW FILE########
__FILENAME__ = ui_widgets_rectangular
from pymt import *

css_add_sheet('rectangularwidget { draw-background: 1; }')

# create our root rectangular widget
root = MTRectangularWidget()

# create a rectangular widget, outside the first one
child  = MTRectangularWidget(size=(200,200), pos=(200,200))

root.add_widget(child)

runTouchApp(root)

########NEW FILE########
__FILENAME__ = ui_widgets_scatter
from pymt import *

# force background draw for scatter
css_add_sheet('''
scatterwidget {
    draw-background: 1;
}''')

# add a simple scatter
scatter = MTScatterWidget(size=(300, 300))

runTouchApp(scatter)

########NEW FILE########
__FILENAME__ = ui_widgets_scatter_children
from pymt import *

# force background draw for scatter
css_add_sheet('''
scatterwidget {
    draw-background: 1;
}''')

# add a simple scatter
scatter = MTScatterWidget(size=(300, 300), pos=(100, 100), rotation=45)

# add some children in
layout = MTBoxLayout()
layout.add_widget(MTButton(label='A1'))
layout.add_widget(MTButton(label='A2'))
scatter.add_widget(layout)

# now, the scatter is rotated, and the button too.
# it's still possible to click on the button, even
# if they are rotated too
runTouchApp(scatter)

########NEW FILE########
__FILENAME__ = ui_widgets_scatter_image
from pymt import *
import os

# just get the image
current_dir = os.path.dirname(__file__)
filename = os.path.join(current_dir, 'image.jpg')

# create 2 scatter with image
m = MTScatterImage(filename=filename, opacity=.5)
m2 = MTScatterImage(filename=filename, pos=(100, 100))

win = getWindow()
win.add_widget(m)
win.add_widget(m2)

runTouchApp()

########NEW FILE########
__FILENAME__ = ui_widgets_slider
from pymt import *

# create a slider from 0.-1. and make it change colors when pressed 
sl = MTSlider(min=0., max=1., style={'slider-color-down':(.5,1,0,1)})

@sl.event
def on_value_change(value):
    print 'Slider value change', value

runTouchApp(sl)

########NEW FILE########
__FILENAME__ = ui_widgets_slider_boundary
from pymt import *

sl = MTBoundarySlider(value=50)

@sl.event
def on_value_change(vmin, vmax):
    print 'Slider values change: ', vmin, ' - ', vmax

runTouchApp(sl)

########NEW FILE########
__FILENAME__ = ui_widgets_slider_circular
# example with a scatter plane + multiple circular slider
# add a css to see bounding box of circular slider

from pymt import *

css_add_sheet('circularslider { draw-background: 1; }')

s = MTScatterPlane()

m = MTBoxLayout(pos=(100,100))
c = MTCircularSlider(radius=100.0, rotation=200, value=50, thickness=20)
m.add_widget(c)
c2 = MTCircularSlider(radius=50.0, rotation=90, value=75)
m.add_widget(c2)
c3 = MTCircularSlider(radius=80.0, value=25, padding=8, thickness=50)
c3.value = 100
c.value = 25

c.connect('on_value_change', c2, 'value')
c.connect('on_value_change', c3, 'value')

m.add_widget(c3)
s.add_widget(m)

runTouchApp(s)

########NEW FILE########
__FILENAME__ = ui_widgets_slider_multi
from pymt import *

sl = MTMultiSlider(init_value=0.1)

@sl.event
def on_value_change(values):
    print 'Slider values change: ', values

runTouchApp(sl)

########NEW FILE########
__FILENAME__ = ui_widgets_slider_xy

from pymt import *

# create a slider from 0.-1.
sl = MTXYSlider()

@sl.event
def on_value_change(x, y):
    print 'Slider value change', x, y

runTouchApp(sl)

########NEW FILE########
__FILENAME__ = ui_widgets_xmlwidget
from pymt import *

guixml = '''<?xml version="1.0" encoding="UTF-8"?>
<MTWidget>
    <MTButton label="1" pos="(50,150)" color="(1,0,0)" />
    <MTButton label="2" pos="(250,150)" color="(0,1,0)" />
    <MTButton label="2" pos="(450,150)" color="(0,0,1)" />
    <MTWidget>
        <MTButton label="5" pos="(0,0)" color="(0,0,0)"/>
        <MTButton label="6" pos="(100,0)" color="(1,1,1)"/>
    </MTWidget>
</MTWidget>
'''

# create the gui from xml
widget = XMLWidget(xml=guixml)

# run the app from the root widget
runTouchApp(widget.root)


########NEW FILE########
__FILENAME__ = animation_gallery
import os
from pymt import *
from OpenGL.GL import *

image_fn = os.path.join(os.path.dirname(__file__), 'icons', 'greeny.png')

class MTGraph(MTKineticItem):
    def __init__(self, **kwargs):
        super(MTGraph, self).__init__(**kwargs)
        # precision of the graph in pixels
        self.precision = 50
        # margin between graph in pixels
        self.margin = 50
        # alpha functions
        self.funcname = kwargs.get('funcname')
        self.func = getattr(AnimationAlpha, self.funcname)
        # get all points for curve with the selected alpha function
        self.points = []
        for x in xrange(0, self.precision):
            progress = x / float(self.precision)
            self.points += [progress, self.func(progress)]
        # add the last one
        self.points += [1., 1.]

        # states
        self.selected = False
        self.progress = 0


    def draw(self):
        # background
        if self.selected:
            set_color(0, 0.1, 0)
        else:
            set_color(0, 0, 0)
        drawRectangle(pos=self.pos, size=self.size)
        drawLabel(label=str(self.funcname), font_size=20,
            pos=(self.x + self.width / 2., self.y + 10),
            anchor_x='center', anchor_y='bottom')

        with gx_matrix:

            m = self.margin
            w, h = self.size

            # axes
            glTranslatef(self.x + m, self.y + m, 0)
            set_color(1, 1, 1)
            drawLine((0, 0, w - m * 2, 0))
            drawLine((0, 0, 0, h - m * 2))

            # curve
            set_color(.2, .2, 1)
            glScalef(w - m * 2, h - m * 2, 0)
            drawLine(self.points, width=2)

            set_color(1, 0, 0, .6)
            drawCircle(pos=(self.progress, self.func(self.progress)),
                       radius=0.05)
            drawLine((self.progress, 0, self.progress, 1.))



class Showcase(MTWidget):
    def __init__(self, **kwargs):
        super(Showcase, self).__init__(**kwargs)
        self.list = MTKineticList(size=(300, 300),
                        deletable=False, searchable=False,
                        title='Easing functions',
                        padding_x=0, friction=1)

        self.add_widget(self.list)

        # enumerate easing function in AnimationAlpha
        for w in dir(AnimationAlpha):
            if w.startswith('_'):
                continue
            graph = MTGraph(size=(300, 300), funcname=w)
            graph.connect('on_press', curry(self.on_graph_press, graph))
            self.list.add_widget(graph)

        # create animation object
        self.object = MTContainer(Image(image_fn), pos=(400, 400))
        self.add_widget(self.object)

        # states
        self.current = None
        self.animation = None

    def on_update(self):
        w = self.get_parent_window()
        self.list.height = w.height

        # copy progression
        if self.current and self.animation:
            if self.object in self.animation.children:
                base = self.animation.children[self.object]
                self.current.progress = max(0., min(
                    base.frame_pointer / base.duration, 1.))

    def on_graph_press(self, graph, *largs):
        if self.current is not None:
            self.current.selected = False
        self.current = graph
        self.current.selected = True

        # create animation
        w = self.get_parent_window()
        f = graph.funcname
        wi = self.list.width + (w.width - self.list.width) / 2.
        h = self.object.height

        self.animation = Animation(d=1.5, f=f, pos=(wi, w.height - h * 2))

        # reset pos
        self.object.pos = (wi, h)

        # start anim
        self.object.do(self.animation)


if __name__ == '__main__':
    runTouchApp(Showcase())

########NEW FILE########
__FILENAME__ = widgets_gallery
from pymt import *

# Decoration to autodeclare screens
l_screens = []
def registerscreen(title):
    def wrap(f):
        global l_screens
        l_screens.append((title, f))
        return f
    return wrap

@registerscreen('Buttons')
def screen_button(w):
    btn = MTButton(label='Normal')
    w.add_widget(btn)

    btn = MTButton(label='Down')
    btn.state = 'down'
    w.add_widget(btn)

    btn = MTToggleButton(label='Toggle')
    w.add_widget(btn)

    btn = MTToggleButton(label='Toggle')
    btn.state = 'down'
    w.add_widget(btn)


@registerscreen('Buttons Matrix')
def screen_buttonmatrix(w):
    bmx = MTButtonMatrix(matrix_size=(10,10), size=(500, 500))
    w.add_widget(bmx)


@registerscreen('File Browser')
def screen_filebrowser(w):
    fb = MTFileBrowser()
    w.add_widget(fb)


@registerscreen('Color Picker')
def screen_colorpicker(w):
    cp = MTColorPicker()
    w.add_widget(cp)


@registerscreen('Sliders')
def screen_slider(w):
    sl = MTSlider(orientation='horizontal', value=1, size=(100, 30))
    w.add_widget(sl)

    sl = MTSlider(orientation='horizontal', value=50, size=(100, 30))
    w.add_widget(sl)

    sl = MTSlider(orientation='horizontal', value=100, size=(100, 30))
    w.add_widget(sl)

    sl = MTSlider(orientation='horizontal', value=50, value_show=True, size=(100, 30))
    w.add_widget(sl)

    sl = MTBoundarySlider(orientation='horizontal', value_min=25, value_max=75, size=(100, 30))
    w.add_widget(sl)


@registerscreen('Sliders - Multi')
def screen_multisliders(w):
    sl = MTMultiSlider()
    w.add_widget(sl)


@registerscreen('Sliders - XY')
def screen_xyslider(w):
    sl = MTXYSlider(size=(300, 300))
    w.add_widget(sl)


@registerscreen('Slider - Circular')
def screen_circularslider(w):
    sl = MTCircularSlider()
    w.add_widget(sl)


@registerscreen('Slider - Vector')
def screen_circularslider(w):
    sl = MTVectorSlider()
    w.add_widget(sl)


@registerscreen('Modal Window')
def screen_modalwindow(w):
    m = MTModalWindow()
    def close_modal(*largs):
        w.remove_widget(m)
    anchor = MTAnchorLayout()
    m.connect('on_resize', anchor, 'size')
    btn = MTButton(label='Close')
    btn.connect('on_press', close_modal)
    anchor.add_widget(btn)
    m.add_widget(anchor)
    w.add_widget(m)


@registerscreen('Modal Popup')
def screen_modalpopup(w):
    m = MTModalPopup(
        content='Here is the modal popup, with a very very long long line.',
        size=(300, 300))
    w.add_widget(m)


@registerscreen('Speech Bubble')
def screen_speechbubble(w):
    m = MTSpeechBubble(label='Hello world')
    w.add_widget(m)


@registerscreen('Kinetic List')
def screen_kineticlist(w):
    m = MTKineticList(size=(210, 200))
    for x in xrange(20):
        m.add_widget(MTKineticItem(label=str(x)))
    w.add_widget(m)

    m = MTKineticList(size=(210, 200), searchable=False, deletable=False)
    for x in xrange(20):
        m.add_widget(MTKineticItem(label=str(x)))
    w.add_widget(m)

    m = MTKineticList(size=(230, 200), searchable=False, deletable=False,
                      title=None, w_limit=2)
    for x in xrange(20):
        m.add_widget(MTKineticItem(label=str(x)))
    w.add_widget(m)


@registerscreen('Tabs')
def screen_tabs(w):
    tabs = MTTabs()
    tabs.add_widget(MTButton(label="Hello"), tab='Tab1')
    tabs.add_widget(MTButton(label="World"), tab='Tab2')
    tabs.select('Tab2')
    w.add_widget(tabs)

@registerscreen('Side Panel')
def screen_sidepanel(w):
    w = getWindow()

    panel = MTSidePanel(side='left', size=(500, 100))
    for x in xrange(5):
        panel.add_widget(MTButton(label=str(x)))
    w.add_widget(panel)

    panel = MTSidePanel(side='right', size=(500, 100))
    for x in xrange(5):
        panel.add_widget(MTButton(label=str(x)))
    w.add_widget(panel)

    panel = MTSidePanel(side='top', size=(500, 100))
    for x in xrange(5):
        panel.add_widget(MTButton(label=str(x)))
    w.add_widget(panel)

    panel = MTSidePanel(side='bottom', size=(500, 100))
    for x in xrange(5):
        panel.add_widget(MTButton(label=str(x)))
    w.add_widget(panel)

@registerscreen('Text Input')
def screen_textinput(w):
    txt = MTTextInput()
    w.add_widget(txt)

    txt = MTTextInput(size=(300, 40), padding_x=10)
    txt.value = 'Type your text here'
    w.add_widget(txt)


@registerscreen('VKeyboard')
def screen_vkeyboard(w):
    k = MTVKeyboard()
    getWindow().add_widget(k)

@registerscreen('Spell VKeyboard')
def screen_vkeyboard(w):
    k = MTSpellVKeyboard()
    getWindow().add_widget(k)



if __name__ == '__main__':
    lbox = MTBoxLayout(orientation='vertical', spacing=5, padding=5)

    current = None
    def select_screen(callback, *largs):
        w = getWindow()
        w.children = []
        w.add_widget(lbox)

        anchor = MTAnchorLayout(pos=(150, 0))
        grid = MTGridLayout(cols=3, spacing=30)
        anchor.add_widget(grid)
        w.add_widget(anchor)
        anchor.size = w.width - 150, w.height
        callback(grid)

    for name, callback in l_screens:
        btn = MTButton(label=name, size=(140, 30))
        lbox.add_widget(btn)
        btn.connect('on_press', curry(select_screen, callback))

    getWindow().add_widget(lbox)
    runTouchApp()

########NEW FILE########
__FILENAME__ = bloop
from __future__ import with_statement

# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Blop The Game'
PLUGIN_AUTHOR = 'Sharath Patali'
PLUGIN_EMAIL = 'sharath.patali@gmail.com'
PLUGIN_DESCRIPTION = 'This is a music game inspired by Bloom App.'

import os
from pymt import *
from OpenGL.GL import *
import random

class PlayArea(MTWidget):
    ''' This is a widget which spawns new bloops and also maintains and displays the scorezone widget  '''
    def __init__(self, **kwargs):
        super(PlayArea, self).__init__(**kwargs)
        self.num_bloops = 1
        self.bloop_points = 1
        self.score = ScoreZone(parent=self)
        self.add_widget(self.score)
        getClock().schedule_interval(self.generateBloop, 0.5)


    def generateBloop(self,dt):
        self.num_bloops = self.num_bloops + 1
        self.redpt = random.uniform(0, 1)
        self.greenpt = random.uniform(0, 1)
        self.bluept = random.uniform(0, 1)
        self.x = int(random.uniform(100, w.width-100))
        self.y = int(random.uniform(100, w.height-100))
        self.b = bloop(music_file=
            os.path.join('music', '%s%d.wav' % (
                random.choice('ABCDEFG'), random.randint(1,3)
            )),
            score_text=self.score,
            pos=(self.x,self.y),
            color=(self.redpt,self.greenpt,self.bluept,1)
        )
        self.add_widget(self.b)

    def show_num_bloops(self):
        return str(self.num_bloops)

    def show_bloop_points(self):
        return str(self.bloop_points)

class bloop(MTButton):
    ''' This is a bloop widget, which tells itself to play music when it is touched and animate itself  '''
    def __init__(self,**kwargs):
        super(bloop, self).__init__(**kwargs)
        kwargs.setdefault('parent', None)
        kwargs.setdefault('music_file', None)
        kwargs.setdefault('score_text', None)
        self.color = kwargs.get('color')
        self.music_file = kwargs.get('music_file')
        self.music = SoundLoader.load(filename=self.music_file)
        self.music.volume = .5
        self.radius = int(self.width/2)
        self.alpha = 0.00
        self.red = self.color[0]
        self.green = self.color[1]
        self.blue = self.color[2]
        self.score_text = kwargs.get('score_text')
        self.touched = False

        self.highlightred = self.red * 1.25
        if(self.highlightred > 1):
            self.highlightred = 1

        self.highlightblue = self.blue * 1.25
        if(self.highlightblue > 1):
            self.highlightblue = 1

        self.highlightgreen = self.green * 1.25
        if(self.highlightgreen > 1):
            self.highlightgreen = 1

        #anim = self.add_animation('fadein','alpha', 1.00, 1.0/60, 0.5)
        self.fadein = Animation(d=1.0, alpha=1.0)
        self.do(self.fadein)
        self.showing = True
        self.highlight = False

        getClock().schedule_once(self.BloopHide, 2)

        self.fadeout = Animation(d=1.0, radius=self.width+10, alpha=0.0)

    def on_touch_down(self, touch):
        if self.collide_point(touch.x, touch.y):
            if self.touched == False:
                self.parent.bloop_points = self.parent.bloop_points+1
                if self.music:
                    self.music.play()
                self.highlight = True
                self.red = self.highlightred
                self.green = self.highlightgreen
                self.blue = self.highlightblue
            self.touched = True
            self.showing = False
            self.do(self.fadeout)

    def draw(self):
        with DO(gx_matrix, gx_blending):
            if self.highlight:
                self.highlightalpha = self.alpha * 1.25
                if(self.highlightalpha > 1):
                   self.highlightalpha = 1
                glColor4f(self.highlightred, self.highlightgreen, self.highlightblue, self.highlightalpha)
                drawCircle(pos=(self.x + self.width/2,self.y + self.height/2),radius=(self.radius*1.25))
            glColor4f(self.red,self.green,self.blue,self.alpha)
            drawCircle(pos=(self.x + self.width/2,self.y + self.height/2),radius=self.radius)

    def BloopHide(self,dt):
        self.do(self.fadeout)
        self.showing = False

    def on_animation_complete(self, anim):
        if self.showing == False:
            self.parent.remove_widget(self)

class ScoreZone(MTWidget):
    ''' This is a widget is responsible for drawing and updating the score on the screen'''
    def __init__(self, **kwargs):
        kwargs.setdefault('size', (200,100))
        kwargs.setdefault('parent', None)
        super(ScoreZone, self).__init__(**kwargs)
        self.label = "1/1"
        getClock().schedule_interval(self.updateScore, .5)

    def draw(self):
        glColor4f(1,0,0,1)
        drawLabel(self.label, pos=(0,w.height-90), center=False, font_size=60,
                 bold=True, color=(1, 1, 1, .5))

    def updateScore(self,dt):
        self.label = self.parent.show_bloop_points()+"/"+self.parent.show_num_bloops()



def pymt_plugin_activate(root, ctx):
    ctx.PA = PlayArea()
    root.add_widget(ctx.PA)

def pymt_plugin_deactivate(root, ctx):
   root.remove_widget(ctx.PA)

if __name__ == '__main__':
    w = MTWindow(color=(0,0,0,1))
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = bubblebattle
# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Bubble Battle !'
PLUGIN_AUTHOR = 'Mathieu Virbel'
PLUGIN_DESCRIPTION = 'Fight the bubbles !!!!! ]:X'

from pymt import *
from OpenGL.GL import *
from random import random, randint

class Basic(MTWidget):
    def __init__(self, **kwargs):
        super(Basic, self).__init__(**kwargs)
        self.r = 30

class Enemy(Basic):
    def __init__(self, **kwargs):
        self.level = kwargs.get('level')
        super(Enemy, self).__init__(**kwargs)
        self.dx = self.level * (random() - 0.5) * 40
        self.dy = self.level * 25 + random() * self.level
        self.r = self.r - min(self.r - 1, random() * self.level)

    def draw(self):
        # backgroud
        set_color(.75, 0, 0, .5)
        drawCircle(pos=self.pos, radius=self.r)
        #border
        set_color(.90, 2, 2, .5)
        drawCircle(pos=self.pos, radius=self.r, linewidth=3)


class Barier(Basic):
    def __init__(self, **kwargs):
        super(Barier, self).__init__(**kwargs)
        self.lifetime = 3
        self.initial_lifetime = self.lifetime
        self.life = 1
        self.start = True
        self.label = MTLabel(font_size=20, font_bold=True, anchor_x='center',
                             anchor_y='center')

    def draw(self):
        # border
        linewidth = self.r - (self.lifetime / float(self.initial_lifetime) * (self.r))
        set_color(.4, .4, .75, .9)
        drawCircle(pos=self.pos, radius=self.r + 3, linewidth=linewidth + 3)
        # background
        set_color(0, 0, .75, .7)
        drawCircle(pos=self.pos, radius=self.r)
        # text
        self.label.label = str(int(self.life))
        self.label.pos = (self.pos[0]-self.label.width/2,self.pos[1]-self.label.height/2)
        self.label.draw()

    def animate(self, world):
        dt = getFrameDt()
        if self.start:
            oldlife = self.life
            self.life += dt * world.managrow
            d = int(self.life) - int(oldlife)
            if d > 0:
                if world.mana - world.manacost * d < 0:
                    self.life = oldlife
                    self.stop()
                else:
                    world.mana -= world.manacost * d
            if self.life > 5:
                self.stop()
            self.update_radius()
        else:
            self.lifetime -= dt
            if self.lifetime < 0:
                return
        return True

    def update_radius(self):
        self.r = self.life * 20

    def stop(self):
        self.start = False
        self.life = int(self.life)
        self.lifetime = self.life * self.lifetime
        self.initial_lifetime = self.lifetime
        self.update_radius()

class GameOver(MTWidget):
    def __init__(self, **kwargs):
        self.world = kwargs.get('world')
        super(GameOver, self).__init__(**kwargs)
        self.layout = MTBoxLayout(orientation='vertical', uniform_width=True,
                                  uniform_height=True, padding=100,
                                  spacing=20, invert_y=True)
        k = {'font_size': 48}
        self.text = MTLabel(label='GAME OVER', **k)
        self.textlevel = MTLabel(label='Your level is %d' % self.world.level, **k)
        self.textscore = MTLabel(label='Your score is %d' % self.world.highscore, **k)
        self.restart = MTButton(label='Restart')
        self.layout.add_widget(self.text)
        self.layout.add_widget(self.textlevel)
        self.layout.add_widget(self.textscore)
        self.layout.add_widget(self.restart)
        self.restart.push_handlers(on_press=self.handle_restart)
        self.add_widget(self.layout)

    def handle_restart(self, *largs):
        self.world.reset()
        self.parent.remove_widget(self)

    def on_touch_down(self, touch):
        super(GameOver, self).on_touch_down(touch)
        return True

    def on_touch_move(self, touch):
        super(GameOver, self).on_touch_move(touch)
        return True

    def on_touch_up(self, touch):
        super(GameOver, self).on_touch_up(touch)
        return True

    def draw(self):
        w = self.get_parent_window()
        self.layout.x = (w.width - self.layout.width) / 2.
        self.layout.y = (w.height - self.layout.height) / 2.
        set_color(0.2, 0.2, 0.2, .5)
        drawRectangle(size=w.size)

class World(MTWidget):
    def __init__(self, **kwargs):
        super(World, self).__init__(**kwargs)
        self.reset()

    def reset(self):
        self.enemies = []
        self.bariers = {}
        self.score = 0
        self.mana = 100
        self.nextspawn = 0
        self.spawnspeed = 1
        self.regenspeed = 5
        self.managrow = 3
        self.manacost = 5
        self.collidescore = 20
        self.collidemanafactor = .5
        self.levelscore = 100
        self.level = 1
        self.highscore = 0
        self.isgameover = False
        self.alphalevel = 1

    def animate(self):
        w = self.get_parent_window()
        dt = getFrameDt()
        e_delete = []
        b_delete = []

        # background
        self.alphalevel -= getFrameDt() * 3

        # animate enemies
        for e in self.enemies:
            # enemy collide on barier
            for bid in self.bariers:
                b = self.bariers[bid]
                if Vector(e.center).distance(Vector(b.center)) > e.r + b.r:
                    continue
                # collide happen !
                e_delete.append(e)
                # remove one life from barier
                b.life -= 1
                if b.life < 1:
                    b_delete.append(bid)
                b.update_radius()
                # update score + mana
                self.score += self.collidescore
                self.mana += self.manacost * self.collidemanafactor

            # advance enemy
            e.x += e.dx * dt
            e.y -= e.dy * dt

            if e.x < e.r:
                if e.dx < 0:
                    e.dx = -e.dx
                e.x = e.r + e.dx * dt
            elif e.x > w.width - e.r:
                if e.dx > 0:
                    e.dx = -e.dx
                e.x = w.width - e.r + e.dx * dt


            # enemy fall under screen
            if e.y < e.r:
                e_delete.append(e)
                self.score -= 100 * self.level + self.collidescore

        # animate barier
        for bid in self.bariers:
            b = self.bariers[bid]
            if not b.animate(self):
                b_delete.append(bid)

        # delete objects
        for e in e_delete:
            if e in self.enemies:
                self.enemies.remove(e)
        for b in b_delete:
            if b in self.bariers:
                del self.bariers[b]

    def regen(self):
        self.mana += getFrameDt() * self.regenspeed
        if self.mana > 100:
            self.mana = 100

    def spawn(self):
        self.nextspawn -= (getFrameDt() * .5) * self.spawnspeed
        if self.nextspawn < 0:
            self.nextspawn = 1.
            w = self.get_parent_window()
            x = w.width * random()
            y = w.height + 20
            self.enemies.append(Enemy(pos=(x, y), level=self.level))

    def nextlevel(self):
        if self.score > self.highscore:
            self.highscore = self.score
        if self.score < 0:
            self.gameover()
        if self.score < self.levelscore:
            return
        self.level += 1
        self.levelscore = self.levelscore * 2
        self.spawnspeed += 1
        self.regenspeed += 1
        self.managrow += 1
        self.alphalevel = 1
        self.collidescore += 2

    def gameover(self):
        self.stop()
        if not self.isgameover:
            self.isgameover = True
            self.get_parent_window().add_widget(GameOver(world=self))

    def stop(self):
        self.spawnspeed = 0
        self.regenspeed = 0

    def on_touch_down(self, touch):
        if self.mana - self.manacost <= 0:
            return
        self.mana -= self.manacost
        self.bariers[touch.id] = Barier(pos=(touch.x, touch.y))

    def on_touch_move(self, touch):
        if not touch.id in self.bariers:
            return
        self.bariers[touch.id].pos = touch.x, touch.y

    def on_touch_up(self, touch):
        if not touch.id in self.bariers:
            return
        self.bariers[touch.id].stop()

    def draw(self):
        # game
        self.spawn()
        self.animate()
        self.regen()
        self.nextlevel()

        # background
        w = self.get_parent_window()
        if self.alphalevel > 0:
            set_color(1, .4, .4, self.alphalevel)
            drawRectangle(size=w.size)

        # enemies + bariers
        for e in reversed(self.enemies):
            e.draw()
        for bid in reversed(self.bariers.keys()):
            self.bariers[bid].draw()

        # ui score
        w2 = w.width / 2.
        s = self.score / float(self.levelscore)
        set_color(.5, 0, 0, .8)
        drawRectangle(pos=(20, 20), size=((w2-40) * s, 30))
        set_color(.8, .2, .2, .8)
        drawRectangle(pos=(20, 20), size=(w2-40, 30), style=GL_LINE_LOOP)

        # ui mana
        w = self.get_parent_window()
        set_color(.1, .1, .7, .7)
        drawRectangle(pos=(w2 + 20, 20), size=((w2-40) * self.mana / 100., 30))
        set_color(.4, .4, 1, .9)
        drawRectangle(pos=(w2 + 20, 20), size=(w2-40, 30), style=GL_LINE_LOOP)

        # score
        set_color(.5, .5, .5, .5)
        drawRoundedRectangle(pos=(w2/2, w.height - 35), size=(w2, 50))
        set_color(.5, .5, .5, .5)
        drawRoundedRectangle(pos=(w2/2, w.height - 35), size=(w2, 50), style=GL_LINE_LOOP)
        label = 'Level %d ~ Score: %-5d / %5d' % (self.level, self.score, self.levelscore)
        drawLabel(label=label, pos=(w2, w.height - 15), color=(255, 255, 255, 200))

def pymt_plugin_activate(w, ctx):
    ctx.c = World()
    w.add_widget(ctx.c)

def pymt_plugin_deactivate(w, ctx):
    w.remove_widget(ctx.c)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = bubblebomb
# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Bubble-o-Bomb !'
PLUGIN_AUTHOR = 'Mathieu Virbel'
PLUGIN_DESCRIPTION = 'Secure Bubble Bomb before explosion !'

import os
from pymt import *
from OpenGL.GL import *
from random import random, randint

current_dir = os.path.dirname(__file__)

class Bomb(MTWidget):
    def __init__(self, **kwargs):
        super(Bomb, self).__init__(**kwargs)
        self.r = 30
        self.moved = False
        self.speed = 200
        self.level = kwargs.get('level')
        self.dx, self.dy = map(lambda x: randint(-self.speed, self.speed), xrange(2))
        self.lifetime = 8
        self.initial_lifetime = self.lifetime
        self.life = 1
        self.start = True
        self.saved = False
        self.color = kwargs.get('color')
        self.label = MTLabel(font_size=20, font_bold=True, anchor_x='center',
                anchor_y='center')

    def draw(self):
        # border
        linewidth = self.r - (self.lifetime / float(self.initial_lifetime) * (self.r))
        if self.color == 'red':
            set_color(.75, .4, .4, .9)
        else:
            set_color(.4, .4, .75, .9)
        drawCircle(pos=self.pos, radius=self.r + 3, linewidth=linewidth + 3)
        # background
        if self.color == 'red':
            set_color(.75, 0, 0, .7)
        else:
            set_color(0, 0, .75, .7)
        drawCircle(pos=self.pos, radius=self.r)
        # text
        self.label.label = str(int(self.lifetime+1))
        self.label.pos = (self.pos[0]-self.label.width/2,self.pos[1]-self.label.height/2)
        self.label.draw()

    def animate(self, world):
        dt = getFrameDt()
        if self.saved:
            return True
        self.lifetime -= dt
        if self.lifetime < 0:
            return
        return True

class DropBase(MTWidget):
    def __init__(self, **kwargs):
        super(DropBase, self).__init__(**kwargs)
        self.r = 100
        self.color = kwargs.get('color')

    def draw(self):
        # border
        if self.color == 'red':
            set_color(.75, .4, .4, .7)
        else:
            set_color(.4, .4, .75, .7)
        drawCircle(pos=self.pos, radius=self.r + 3, linewidth=3)
        # background
        if self.color == 'red':
            set_color(.75, 0, 0, .7)
        else:
            set_color(0, 0, .75, .7)
        drawCircle(pos=self.pos, radius=self.r)

class GameOver(MTWidget):
    def __init__(self, **kwargs):
        self.world = kwargs.get('world')
        super(GameOver, self).__init__(**kwargs)
        self.layout = MTBoxLayout(orientation='vertical', uniform_width=True,
                                  uniform_height=True, padding=100,
                                  spacing=20, invert_y=True)
        k = {'font_size': 48}
        self.text = MTLabel(label='GAME OVER', **k)
        self.textlevel = MTLabel(label='Your level is %d' % self.world.level, **k)
        self.textscore = MTLabel(label='Your score is %d' % self.world.highscore, **k)
        self.restart = MTButton(label='Restart')
        self.layout.add_widget(self.text)
        self.layout.add_widget(self.textlevel)
        self.layout.add_widget(self.textscore)
        self.layout.add_widget(self.restart)
        self.restart.push_handlers(on_press=self.handle_restart)
        self.add_widget(self.layout)

    def handle_restart(self, *largs):
        self.world.reset()
        self.parent.remove_widget(self)

    def on_touch_down(self, touch):
        super(GameOver, self).on_touch_down(touch)
        return True

    def on_touch_move(self, touch):
        super(GameOver, self).on_touch_move(touch)
        return True

    def on_touch_up(self, touch):
        super(GameOver, self).on_touch_up(touch)
        return True

    def draw(self):
        w = self.get_parent_window()
        self.layout.x = (w.width - self.layout.width) / 2.
        self.layout.y = (w.height - self.layout.height) / 2.
        set_color(0.2, 0.2, 0.2, .5)
        drawRectangle(size=w.size)

class World(MTWidget):
    def __init__(self, **kwargs):
        super(World, self).__init__(**kwargs)
        self.reset()
        self.s_gameover = SoundLoader.load(os.path.join(current_dir, 'gameover.wav'))
        self.s_touch = SoundLoader.load(os.path.join(current_dir, 'touch.wav'))
        self.s_nextlevel = SoundLoader.load(os.path.join(current_dir, 'level.wav'))
        self.s_gameover.volume = .5
        self.s_touch.volume = .5
        self.s_nextlevel.volume = .5

    def sound(self, name):
        if name == 'gameover':
            self.s_gameover.stop()
            self.s_gameover.seek(0)
            self.s_gameover.play()
        elif name == 'touch':
            self.s_touch.stop()
            self.s_touch.seek(0)
            self.s_touch.play()
        elif name == 'nextlevel':
            self.s_nextlevel.stop()
            self.s_nextlevel.seek(0)
            self.s_nextlevel.play()

    def reset(self):
        self.bomb = []
        self.touches = {}
        self.score = 0
        self.nextspawn = 0
        self.spawnspeed = 1
        self.levelscore = 10
        self.level = 1
        self.highscore = 0
        self.isgameover = False
        self.alphalevel = 1
        self.bases = (DropBase(color='red'), DropBase(color='blue'))

    def animate(self):
        if self.isgameover:
            return

        w = self.get_parent_window()
        dt = getFrameDt()

        # background
        self.alphalevel -= getFrameDt() * 3

        # animate enemies
        for b in self.bomb:
            if not b.animate(self):
                self.gameover()

            for base in self.bases:
                if Vector(b.pos).distance(Vector(base.pos)) > b.r + base.r:
                    continue
                if not b.saved:
                    b.dx = - b.dx
                    b.dy = - b.dy
                    b.x += b.dx * dt
                    b.y -= b.dy * dt

            # advance enemy
            if b.moved:
                continue

            b.x += b.dx * dt
            b.y -= b.dy * dt

            if b.x < b.r:
                if b.dx < 0:
                    b.dx = -b.dx
                b.x = b.r + b.dx * dt
            elif b.x > w.width - b.r:
                if b.dx > 0:
                    b.dx = -b.dx
                b.x = w.width - b.r + b.dx * dt
            elif b.y < b.r:
                if b.dy > 0:
                    b.dy = -b.dy
                b.y = b.r + b.dy * dt
            elif b.y > w.height - b.r:
                if b.dy < 0:
                    b.dy = -b.dy
                b.y = w.height - b.r + b.dy * dt
            elif b.saved and Vector(b.pos).distance(b.savedbase.pos) >= b.savedbase.r - b.r:
                b.dx = - b.dx
                b.dy = - b.dy
                b.x += b.dx * dt
                b.y -= b.dy * dt

    def nextlevel(self):
        if self.score > self.highscore:
            self.highscore = self.score
        if self.score < 0:
            self.gameover()
        if self.score < self.levelscore:
            return
        self.sound('nextlevel')
        self.level += 1
        self.levelscore = self.levelscore * 2
        self.spawnspeed += .5
        self.alphalevel = 1
        b_delete = [b for b in self.bomb if b.saved]
        [self.bomb.remove(b) for b in b_delete if b in self.bomb]

    def spawn(self):
        self.nextspawn -= (getFrameDt() * .5) * self.spawnspeed
        if self.nextspawn < 0:
            c = ('red', 'blue')[randint(0, 1)]
            b = Bomb(color=c, level=self.level)
            self.nextspawn = 1.
            w = self.get_parent_window()
            redo = True
            while redo:
                x = w.width * random()
                y = w.height * random()
                redo = False
                for base in self.bases:
                    if Vector(base.pos).distance(Vector(x, y)) < base.r + b.r:
                        redo = True
            b.pos = x, y
            self.bomb.append(b)

    def gameover(self):
        self.stop()
        if not self.isgameover:
            self.sound('gameover')
            self.isgameover = True
            self.get_parent_window().add_widget(GameOver(world=self))

    def stop(self):
        self.spawnspeed = 0

    def on_touch_down(self, touch):
        # search a bomb
        for b in self.bomb:
            if b.saved:
                continue
            if Vector(b.pos).distance(Vector(touch.x, touch.y)) > b.r:
                continue
            self.sound('touch')
            self.touches[touch.id] = b
            b.pos = touch.x, touch.y
            b.moved = True
            touch.grab(self)
            return True

    def on_touch_move(self, touch):
        if touch.id not in self.touches:
            return
        self.touches[touch.id].pos = touch.x, touch.y
        return True

    def on_touch_up(self, touch):
        if touch.id not in self.touches:
            return
        self.touches[touch.id].pos = touch.x, touch.y
        b = self.touches[touch.id]
        b.moved = False
        for base in self.bases:
            if Vector(b.pos).distance(Vector(base.pos)) > b.r + base.r:
                continue
            if b.color != base.color:
                self.gameover()
                return
            elif not b.saved:
                self.sound('touch')
                self.score += 1
                b.saved = True
                b.savedbase = base
                b.pos = base.pos
                return True

    def draw(self):
        w = self.get_parent_window()
        step = w.width / (1+len(self.bases))
        x = step
        for b in self.bases:
            b.pos = x, w.height / 2
            x += step

        # game
        self.spawn()
        self.animate()
        self.nextlevel()

        # background
        if self.alphalevel > 0:
            set_color(1, .4, .4, self.alphalevel)
            drawRectangle(size=w.size)

        # enemies + bariers
        for b in reversed(self.bases):
            b.draw()
        for b in reversed(self.bomb):
            b.draw()

        # score
        w2 = w.width / 2.
        set_color(.5, .5, .5, .5)
        drawRoundedRectangle(pos=(w2/2, w.height - 35), size=(w2, 50))
        set_color(.5, .5, .5, .5)
        drawRoundedRectangle(pos=(w2/2, w.height - 35), size=(w2, 50), style=GL_LINE_LOOP)
        label = 'Level %d ~ Score: %-5d / %5d' % (self.level, self.score, self.levelscore)
        drawLabel(label=label, pos=(w2, w.height - 15), color=(255, 255, 255, 200))

def pymt_plugin_activate(w, ctx):
    ctx.c = World()
    w.add_widget(ctx.c)

def pymt_plugin_deactivate(w, ctx):
    w.remove_widget(ctx.c)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = tictactoe
from pymt import *
from OpenGL.GL import *


# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'TicTacToe Game'
PLUGIN_AUTHOR = 'Thomas Hansen + Mathieu Virbel'
PLUGIN_DESCRIPTION = 'Tic Tac Toe game!'

class TTTWinner(MTWidget):
    def __init__(self, **kwargs):
        super(TTTWinner, self).__init__(**kwargs)
        self.game = kwargs.get('game')
        self.text = kwargs.get('text')

    def draw(self):
        set_color(0, 0, 0, .9)
        center=Vector(self.get_parent_window().size)/2
        drawRectangle(pos=(0, center.y-50), size=(self.get_parent_window().width, 100))
        drawLabel(label=self.text, pos=center, font_size=28)

    def on_touch_down(self, *largs):
        self.parent.remove_widget(self)
        self.game.restart()
        return True

    def on_touch_move(self, *largs):
        return True

    def on_touch_up(self, *largs):
        return True

class TTTGame(MTButtonMatrix):

    def __init__(self,**kwargs):
        kwargs.setdefault('matrix_size', (3, 3))
        super(TTTGame, self).__init__(**kwargs)
        self.player_images = (MTWidget(),MTSvg(filename='cross.svg'),MTSvg(filename='circle.svg') )
        self.player = 1
        self.done = False
        self.testpoint = (0,0)

    def restart(self):
        self.done = False
        self.player = 1
        self.testpoint = (0, 0)
        self.reset()

    def show_winner(self, text):
        popup = TTTWinner(game=self, text=text)
        self.get_parent_window().add_widget(popup)

    def select_area(self,i,j):
        self.matrix[i][j] = self.player
        winner = self.check_win()
        if winner is not None:
            self.done = True
            self.show_winner("WINNER !")
        elif self.check_full():
            self.done = True
            self.show_winner("GAME OVER :(")
        else:
            if self.player == 1:
                self.player = 2
            else:
                self.player = 1

    def on_resize(self, w, h):
        self._width, self._height = w,h

    def on_touch_down(self, touch):
        if self.done:
            return True
        i,j = self.collide_point(int(touch.x),int(touch.y))
        if self.matrix[i][j] == 0:
            self.select_area(i,j)
        else:
            pass

    def draw_tile(self, i, j):
        image = self.player_images[self.matrix[i][j]%3]
        glPushMatrix()
        glTranslatef(self.width/self.matrix_size[0]*i, self.height/self.matrix_size[1]*j,0)

        s =  (self.width/self.matrix_size[0],self.height/self.matrix_size[1])
        if self.matrix[i][j]%3 == 0:
            set_color(0.25, 0.25, 0.25)
            drawRectangle(pos=(20,20),size=(s[0]-40, s[1]-40))
        if self.matrix[i][j]%3 == 1:
            set_color(1,0,0)
            drawCircle(pos=(s[0]/2, s[1]/2), radius=s[1]/2)
        if self.matrix[i][j]%3 == 2:
            set_color(0,0,1)
            drawCircle(pos=(s[0]/2, s[1]/2), radius=s[1]/2)
        if self.matrix[i][j] > 2:
            set_color(0,1,0)
            drawCircle(pos=(s[0]/2, s[1]/2), radius=s[1]/2)

        sx, sy = s[0]/image.width,  s[1]/image.height
        set_color(1, 1, 1, .99)
        glScaled(sx,sy,1)
        image.draw()
        glPopMatrix()

    def check_row_win(self, p1, p2, p3):
        if (self.matrix[p1[0]][p1[1]] == self.player and
            self.matrix[p2[0]][p2[1]] == self.player and
            self.matrix[p3[0]][p3[1]] == self.player):
            self.matrix[p1[0]][p1[1]] = self.matrix[p2[0]][p2[1]] = self.matrix[p3[0]][p3[1]] = 3+self.player
            return True
        return False

    def check_win(self):
        if self.check_row_win((0,0),(1,0), (2,0)):
            return (0, 0)
        if self.check_row_win((0,1),(1,1), (2,1)):
            return (0, 1)
        if self.check_row_win((0,2),(1,2), (2,2)):
            return (0, 2)
        if self.check_row_win((0,0),(0,1), (0,2)):
            return (0, 0)
        if self.check_row_win((1,0),(1,1), (1,2)):
            return (1, 0)
        if self.check_row_win((2,0),(2,1), (2,2)):
            return (2, 0)
        if self.check_row_win((0,0),(1,1), (2,2)):
            return (0, 0)
        if self.check_row_win((2,0),(1,1), (0,2)):
            return (0, 0)
        return None

    def check_full(self):
        full = 0
        for x in range(0, self.matrix_size[0]):
            for y in range(0, self.matrix_size[1]):
                if self.matrix[x][y] == 0:
                    full += 1
        if full == 0:
            return True
        return False

def pymt_plugin_activate(w, ctx):
    ctx.game = TTTGame(size=w.size)
    w.add_widget(ctx.game)

def pymt_plugin_deactivate(w, ctx):
    w.remove_widget(ctx.game)

#start the application (inits and shows all windows)
if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = data_viewer
from pymt import *
from OpenGL.GL import *

import pickle
from pprint import *

class DataViewer(MTWidget):
    def __init__(self, datafile):
        MTWidget.__init__(self)
        f = open(datafile)
        self.data = pickle.load(f)
        f.close()


    def draw(self):
        glPushMatrix()
        #glScaled(0.5,0.5,1.0)

        first_t = self.data['start_time']
        last_t = self.data['stop_time']
        #print first_t, last_t

        time_frame = (first_t, last_t)

        for touchID in self.data['touch_event_log']:
            timekey = lambda x: x['t']


            p1 = (0,0)
            p2 = (0,0)
            last_pos = (0,0)

            starts_at = self.data['touch_event_log'][touchID][0]['t']
            ends_at = self.data['touch_event_log'][touchID][-1]['t']

            if not (starts_at > time_frame[0] and ends_at < time_frame[1]):
                print touchID, starts_at, ends_at, time_frame
                continue
            for e in self.data['touch_event_log'][touchID]:
                t = (e['t'] - first_t)/(last_t -first_t)
                #print e['t']
                #tt = (e['t'] - self.data['touch_event_log'][touchID][0]['t'])/(self.data['touch_event_log'][touchID][-1]['t'] - self.data['touch_event_log'][touchID][0]['t'])
                #t = tt
                if e['type'] != 'down':
                    p2 = (e['x'], e['y'])
                    #glColor3d(0, tt, tt)
                    glColor3d(1-t, 1-t, t)
                    drawLine(p1 + p2, width=1)
                    p1 = (e['x'], e['y'])


                if e['type'] == 'down':
                    p1 = (e['x'], e['y'])
                    glColor3d(1-t, 1-t, t)
                    drawCircle(p1, radius=8)
                    last_pos = p1

                if e['type'] == 'up':
                    glColor3d(1-t, 1-t, t)
                    angle = Vector.angle(Vector(*last_pos),Vector(0,1) )
                    glPushMatrix()
                    glTranslated(p1[0], p1[1], 0)
                    if p1[0] < last_pos[0]:
                        glRotated(-angle, 0,0,1)
                    else:
                        glRotated(angle, 0,0,1)
                    drawTriangle(pos=(0,0), w=10, h=15)
                    glPopMatrix()
        glPopMatrix()

w = MTWindow()
w.color=(0,0,0,0)
w.add_widget(DataViewer('touch_25.pkl'))
runTouchApp()

########NEW FILE########
__FILENAME__ = graph
from __future__ import with_statement
from random import randint
from OpenGL.GL import *
from OpenGL.GLU import *

from pymt import *


vertex_dl = GlDisplayList()
def drawVertex(x,y):
    global vertex_dl
    with gx_matrix:
        glTranslated(x,y, 0)
        if not vertex_dl.is_compiled():
            with vertex_dl:
                set_color(1.0,1.0,1.0,0.99)
                gluDisk(gluNewQuadric(), 0, 25, 32,1)
                glScaled(0.75,0.75,1.0)
                set_color(0.2,0.6,0.2,.99)
                gluDisk(gluNewQuadric(), 0, 25, 32,1)
        vertex_dl.draw()

collision_dl = GlDisplayList()
def drawCollision(x,y):
    global collision_dl
    with gx_matrix:
        glTranslated(x,y-5, 0)
        if not collision_dl.is_compiled():
            with collision_dl:
                set_color(1.0,0.0,0.0, 0.3)
                drawTriangle(pos=(0,0),w=20,h=20)
        collision_dl.draw()


def point_inside_line_segment(point, p1, p2):
       minx = min(p1.x, p2.x)
       miny = min(p1.y, p2.y)
       maxx = max(p1.x, p2.x)
       maxy = max(p1.y, p2.y)
       #print minx, maxx, miny, maxy, point.x, point.y
       if point.x > minx and point.x < maxx and point.y > miny and point.y < maxy:
              return True

class Graph:
       def __init__(self, num_verts=12, displaySize=(640,480)):
              self.verts = []
              for i in range(num_verts):
                     x = randint(100,displaySize[0]-100)*1.0
                     y = randint(100,displaySize[1]-100)*1.0
                     self.verts.append([x,y])

              self.edges = [ [self.verts[i], self.verts[(i+1)%num_verts]] for i in range(num_verts) ]
              self.collisions = []
              self.is_solved()

       def is_solved(self):
              self.collisions = []
              for e1 in self.edges:
                     for e2 in self.edges:
                            if  e1 != e2:
                                   p1,p2,p3,p4 = Vector(*e1[0]), Vector(*e1[1]), Vector(*e2[0]), Vector(*e2[1])
                                   intersection = Vector.line_intersection( p1,p2,p3,p4 )
                                   if intersection is None:
                                       continue
                                   if (Vector.distance(intersection, p1) > 0.2 and
                                       Vector.distance(intersection, p2) > 0.2 and
                                       Vector.distance(intersection, p3) > 0.2 and
                                       Vector.distance(intersection, p4) > 0.2 and
                                       point_inside_line_segment(intersection, p1,p2) and
                                       point_inside_line_segment(intersection, p3,p4)):
                                          self.collisions.append(intersection)
              return len(self.collisions) == 0

       def draw(self):
              #self.is_solved()
              for e in self.edges:
                     set_color(1,1,1,.99)
                     drawLine((e[0][0],e[0][1], e[1][0],e[1][1]), width=12.0)
                     set_color(0.3,0.6,0.3)
                     drawLine((e[0][0],e[0][1], e[1][0],e[1][1]), width=6.0)
              for v in self.verts:
                     drawVertex(v[0],v[1])
              for c in self.collisions:
                     drawCollision(c.x,c.y)

       #returns the vertex at the position, None if no vertex there
       def collideVerts(self, x,y, regionSize=40):
              for v in self.verts:
                     dx = abs(x - v[0])
                     dy = abs(y - v[1])
                     if (dx < regionSize and dy < regionSize):
                         return v
              return None


if __name__ == "__main__":
	print "this is an implementation file only used by untabgle.py"

########NEW FILE########
__FILENAME__ = untangle
from __future__ import with_statement

# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Untangle Game'
PLUGIN_AUTHOR = 'Thomas Hansen'
PLUGIN_EMAIL = 'thomas.hansen@gmail.com'
PLUGIN_DESCRIPTION = 'Untangle game !'

from pymt import *
from graph import *
from OpenGL.GL import *
from OpenGL.GLU import *

import time
import pickle

"""
I use the EventLogger and TrialLogger classes to record all the touch input, so that I can visualize/analyze the user interacitons for some user studies I am working on.
They have absolutly nothing to do with the Graph untabgle game, i case anyone is trying to read this to learn pymt.
"""
class EventLogger(MTWidget):
    def __init__(self):
        MTWidget.__init__(self)
        self.touches = {}
        self.enabled = False


    def start(self):
        self.enabled = True
        self.start_time = time.time()

    def stop(self):
        self.enabled = False
        self.stop_time = time.time()

    def clear(self):
        self.touches = {}

    def on_touch_down(self, touch):
        if self.enabled:
            event = {'type':'down', 'id':touch.id, 'x':touch.x, 'y':touch.y, 't':time.time() }
            self.touches[touch.id] = [event,]

    def on_touch_up(self, touch):
        if self.enabled and touch.id in self.touches:
            event = {'type':'up', 'id':touch.id, 'x':touch.x, 'y':touch.y, 't':time.time() }
            self.touches[touch.id].append(event)

    def on_touch_move(self, touch):
        if self.enabled and touch.id in self.touches:
            event = {'type':'move', 'id':touch.id, 'x':touch.x, 'y':touch.y, 't':time.time() }
            self.touches[touch.id].append(event)


class TrialLogger(EventLogger):
    def __init__(self, widget):
        EventLogger.__init__(self)
        self.widget = widget
        widget.parent.add_widget(self)
        self.widget_start = None


    def start(self):
        self.graph_start = pickle.dumps([self.widget.g.verts, self.widget.g.edges])
        self.start_time = time.time()
        self.enabled = True



    def save(self,filename):
        self.stop()
        self.graph_stop = pickle.dumps([self.widget.g.verts, self.widget.g.edges])
        self.stop_time = time.time()
        f = open(filename,'wb')
        data = {
            'graph_start' : self.graph_start,
            'graph_stop' : self.graph_stop,
                        'start_time': self.start_time,
                        'stop_time': self.stop_time,
            'touch_event_log': self.touches,
            }
        pickle.dump(data, f)
        f.close()


class NewGameMenu(MTBoxLayout):
    def __init__(self, window, **kwargs):
        kwargs.setdefault('size_hint', (None, None))
        super(NewGameMenu, self).__init__(**kwargs)
        self.window = window
        self.trial_num = 0

        b1 = MTButton(label="10 Vertices", size=(200,100))
        b1.push_handlers(on_release=curry(self.startNewGame, 10))
        self.add_widget(b1)

        b1 = MTButton(label="15 Vertices", size=(200,100))
        b1.push_handlers(on_release=curry(self.startNewGame, 15))
        self.add_widget(b1)

        b1 = MTButton(label="20 Vertices", size=(200,100))
        b1.push_handlers(on_release=curry(self.startNewGame, 20))
        self.add_widget(b1)

        b1 = MTButton(label="25 Vertices", size=(200,100))
        b1.push_handlers(on_release=curry(self.startNewGame, 25))
        self.add_widget(b1)

        self.graph = None
        self.start_time = None
        self.stop_time = None

    def on_update(self):
        super(NewGameMenu, self).on_update()
        self.center = self.get_parent_window().center

    def draw(self):
        if self.start_time and self.stop_time:
            set_color(0,0,0,0.5)
            drawRectangle(size=self.window.size)

            duration = str(self.stop_time - self.start_time)[:4] + " sec"
            glColor4f(0.5,1,0.5,1)
            drawLabel("Untangled!", pos=(self.x+425, self.y+240), font_size=64)
            glColor4f(0.7,0.7,0.7,1)
            drawLabel("time: "+duration+"  moves: "+str(self.num_moves), pos=(self.x+425, self.y+150), font_size=50)

    def startNewGame(self, numVerts, *largs):
        if self.graph:
            self.window.remove_widget(self.graph)
        self.graph = GraphUI(size=numVerts, w=self.window, menu=self)

        self.window.add_widget(self.graph)

        self.trial_num += 1
        self.log = TrialLogger(self.graph)
        self.log.start()

        self.window.remove_widget(self)
        self.start_time = time.time()


class GraphUI(MTWidget):
    def __init__(self, size=15, w=None, menu=None):
        MTWidget.__init__(self)
        self.menu = menu
        self.g = Graph(size,displaySize=w.size)
        self.touch2vertex = {}
        self.num_moves = 0
        self.done = False
        self.num_moves_since_check = 0 #if we try to solve on every move event things get slow

    def draw(self):
        self.g.draw()
        if not self.done:
            w = self.get_parent_window()
            glColor4f(0.7,0.7,0.7,1)
            duration = time.time() - self.menu.start_time
            label = 'Time: %4.1f - Moves: %d' % (duration, self.num_moves)
            drawLabel(label, pos=(w.center[0], 30), font_size=30)

    def on_touch_down(self, touch):
        if self.done:
            return
        touchedVertex = self.g.collideVerts(touch.x,touch.y)
        if touchedVertex: self.touch2vertex[touch.id] = touchedVertex

    def on_touch_up(self, touch):
        if self.done:
            return
        self.num_moves +=1
        if self.touch2vertex.has_key(touch.id):
            del self.touch2vertex[touch.id]
        if self.g.is_solved():
            #self.g = Graph(15,displaySize=w.size)
            self.done = True
            self.menu.log.stop()
            self.menu.log.save('trial_'+str(self.menu.trial_num)+'.pkl')
            self.menu.stop_time =  time.time()
            self.menu.num_moves = self.num_moves
            self.parent.add_widget(self.menu)

    def on_touch_move(self, touch):
        if self.done:
            return
        if self.touch2vertex.has_key(touch.id):
                    self.touch2vertex[touch.id][0] = touch.x
                    self.touch2vertex[touch.id][1] = touch.y
        self.num_moves_since_check += 1
        if self.num_moves_since_check%4 == 0:
            #self.g.is_solved()
            self.num_moves_since_check = 0


def pymt_plugin_activate(w, ctx):
    #ctx.log = TrialLogger(ctx.graph)
    ctx.menu = NewGameMenu(w, pos=(w.width/2 -425, w.height/2))
    w.add_widget(ctx.menu)

def pymt_plugin_deactivate(w, ctx):
    try:
        w.remove_widget(ctx.menu)
    except:
        pass
    #ctx.log.save('data.pkl')


if __name__ == '__main__':
    #init our window
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)


########NEW FILE########
__FILENAME__ = wang
'''
Wang game, by Mathieu Virbel <tito@bankiz.org>
Thanks for Math to sponc game (from libavg.de)
and http://zoonek.free.fr/LaTeX/Triangle/index.shtml

Lot of things can be optimized, it's just a raw version working
after some hours of arithemic.
'''

from pymt import *
from copy import copy
import random
import math
import os

# PYMT Plugin integration
IS_PYMT_PLUGIN = True
PLUGIN_TITLE = 'Wang game'
PLUGIN_AUTHOR = 'Mathieu Virbel'
PLUGIN_DESCRIPTION = 'Play on Pong with multitouch !'

current_dir = os.path.dirname(__file__)

def in_between(val, b1, b2):
    return ((b1 >= val and val >= b2) or (b1 <= val and val <= b2))

def angle(o, a1, a2):
    return (a1 - o).angle(a2 - o)

def perp(l, m):
    P, Q = l.points
    pa = P.y - Q.y
    pb = Q.x - P.x
    pc = P.x * (Q.y-P.y) - P.y * (Q.x-P.x)
    za = -pb
    zb = copy(pa)
    zc = pb * m.x - pa * m.y
    if zb == 0:
        return
    return Line(Vector(200, -(za * 200 + zc) / zb),
                Vector(100, -(za * 100 + zc) / zb))

class Line(object):
    def __init__(self, p1, p2):
        self.points = (p1, p2)

    def get_angle(self):
        v = self.points[1] - self.points[0]
        angle = math.atan2(v.x, v.y)
        if angle < 0:
            angle += math.pi * 2.
        return angle

    def get_normal(self):
        return self.get_angle() + math.pi / 2.

    def collide(self, line):
        a = self.points[0].x
        b = self.points[0].y
        c = self.points[1].x - a
        d = self.points[1].y - b
        e = line.points[0].x
        f = line.points[0].y
        g = line.points[1].x - e
        h = line.points[1].y - f

        dem = g * d - c * h
        if dem == 0: # parallel
            return False

        s = (a * d + f * c - b * c - e * d) / dem
        x = e + s * g
        y = f + s * h
        return Vector(x, y)

    def clash(self, line):
        ka, kb = self.points
        la, lb = line.points

        p = self.collide(line)
        if not p:
            return False

        if in_between(p.x, ka.x, kb.x) and \
           in_between(p.x, la.x, lb.x) and \
           in_between(p.y, ka.y, kb.y) and \
           in_between(p.y, la.y, lb.y):
            return p

        return False

    def length(self):
        ka, kb = self.points
        return ka.distance(kb)

    def is_hard(self):
        return True

    def on_clash(self, object, position):
        if self.is_hard():
            object.dobounce(self)
        return False

    def in_between(self, p):
        ka, kb = self.points
        return in_between(p.x, ka.x, kb.x) and in_between(p.y, ka.y, kb.y)


class Bat(MTWidget):
    def __init__(self, **kwargs):
        super(Bat, self).__init__(**kwargs)
        self.bpos = (0, 0)
        self.a = Vector(kwargs.get('a'))
        self.b = Vector(kwargs.get('b'))

    def _get_a(self):
        return Vector(self.pos)
    def _set_a(self, value):
        self.pos = value
    a = property(_get_a, _set_a)

    def _get_b(self):
        return Vector(self.bpos)
    def _set_b(self, value):
        self.bpos = value
    b = property(_get_b, _set_b)

    def _get_line(self):
        return Line(self.a, self.b)
    line = property(_get_line)

    def draw(self):
        set_color(1, 1, 1)
        drawLine((self.a.x, self.a.y, self.b.x, self.b.y), width=5.)


class Ball(MTWidget):
    def __init__(self, **kwargs):
        super(Ball, self).__init__(**kwargs)
        self.game = kwargs.get('game')
        self.debugline = []
        self.debug = False
        self.sprite = Image.load(os.path.join(current_dir, 'ball.png'))
        self.reset()

    def reset(self):
        self.radius = 30
        self.speed = 150
        self.v = Vector(random.random() * 2 - 1,
                        random.random() * 2 - 1).normalize()

    def update(self, dt):
        w = self.get_parent_window()
        pos = Vector(*self.pos)
        dir = self.v * dt * self.speed
        next = pos + dir
        bline = Line(pos, next)

        if self.debug:
            self.debugline = []

        for bat in self.game.bats:

            # search perpendicular line
            p = Vector(*next)
            l = perp(bat.line, p)
            if not l:
                continue

            # get the collision point between bat and perpendicular
            cl = bat.line.collide(l)
            if not cl:
                continue

            # if the collision point is on bat, go !
            if not bat.line.in_between(cl):
                continue

            # DEBUG: show the perpendicular line.
            if self.debug:
                self.debugline.append(((0, 0, 1), [cl.x, cl.y, p.x, p.y]))

            # get the collision point between bat and direction
            c = bat.line.collide(bline)
            if not c:
                return

            # DEBUG: draw the direction vector
            if self.debug:
                self.debugline.append(((0, 1, 0), [c.x, c.y, p.x, p.y]))

            # prepare rotation of direction
            rot = angle(p, cl, c)
            rot = 180 + 2 * rot

            # DEBUG: show the future direction vector
            if self.debug:
                v = self.v.rotate(rot).normalize() * self.radius * 2
                self.debugline.append(((1, 0, 0), [p.x + v.x, p.y + v.y, p.x, p.y]))

            # if distance between perpendicular collision point
            # and bat is < radius, we got a collision
            dist = cl.distance(p)
            if dist > self.radius:
                continue

            # speedup ?
            self.speedup(bat.line.length() / Wang.BAT_LENGTH_MAX)

            # rotate direction.
            self.v = self.v.rotate(rot)

            # new next
            dir = self.v * dt * self.speed
            next = pos + dir

        # bounds
        if next.x < -self.radius:
            self.game.winB()
        if next.x > w.width + self.radius:
            self.game.winA()
        if next.y < self.radius:
            next.y = self.radius
            self.v.y = -self.v.y
        if next.y > w.height - self.radius:
            next.y = w.height - self.radius
            self.v.y = -self.v.y

        self.pos = next

    def draw(self):
        set_color(1, 1, 1)
        self.sprite.x = self.x - self.sprite.width / 2.
        self.sprite.y = self.y - self.sprite.height / 2.
        self.sprite.draw()

        for color, line in self.debugline:
            set_color(*color)
            drawLine(line)

    def speedup(self, f):
        if f <= 0:
            return
        self.speed = 100 + min(80 / f, 400)

class MenuItem(MTButton):
    def __init__(self, **kwargs):
        super(MenuItem, self).__init__(**kwargs)
        self.radius = kwargs.get('radius')
        self.color = kwargs.get('color')

    def collide_point(self, x, y):
        w = self.get_parent_window()
        w2 = w.width / 2.
        return Vector(*self.pos).distance(Vector(x, y)) < self.radius

    def draw(self):
        w = self.get_parent_window()
        w2 = w.width / 2.
        self.x = w2
        set_color(*self.color)
        drawCircle(pos=self.pos, radius=self.radius)
        drawCircle(pos=self.pos, radius=self.radius, linewidth=5)
        self.label_obj.x, self.label_obj.y = self.pos
        self.label_obj.draw()


class Menu(MTWidget):
    def __init__(self, **kwargs):
        super(Menu, self).__init__(**kwargs)
        self.radius = kwargs.get('radius')
        self.game = kwargs.get('game')
        self.menuitems = []
        self.do_show = False

    def collide_point(self, x, y):
        w = self.get_parent_window()
        w2 = w.width / 2.
        return Vector(w2, 0).distance(Vector(x, y)) < self.radius

    def _press_reset(self, *largs):
        self.game.reset(score=True)

    def _press_speed_add(self, *largs):
        self.game.speed += 1
        if self.game.speed > 10:
            self.game.speed = 10

    def _press_speed_del(self, *largs):
        self.game.speed -= 1
        if self.game.speed < 1:
            self.game.speed = 1

    def _press_ball_add(self, *largs):
        self.game.generate_ball()

    def _press_ball_del(self, *largs):
        self.game.remove_ball()

    def _press_menu(self, *largs):
        self.do_show = not self.do_show
        for c in self.menuitems:
            c.visible = self.do_show
        self.game.pause = self.do_show

    def create_ui(self):
        w = self.get_parent_window()
        w2 = w.width / 2.

        self.menu = MenuItem(color=(.2, .2, .2, .7), radius=40,
                            pos=(w2, 0))
        self.menu.push_handlers(on_press=self._press_menu)
        self.add_widget(self.menu)

        btn = MenuItem(label='Restart', color=(.7, 0, 0, .7),
                       radius=40, pos=(w2, 100), visible=False)
        btn.push_handlers(on_press=self._press_reset)
        self.menuitems.append(btn)
        btn = MenuItem(label='Ball +1', color=(0, .7, 0, .7),
                       radius=40, pos=(w2, 200), visible=False)
        btn.push_handlers(on_press=self._press_ball_add)
        self.menuitems.append(btn)
        btn = MenuItem(label='Ball -1', color=(0, 0, .7, .7),
                       radius=40, pos=(w2, 300), visible=False)
        btn.push_handlers(on_press=self._press_ball_del)
        self.menuitems.append(btn)
        btn = MenuItem(label='Speed +1', color=(0, .7, 0, .7),
                       radius=40, pos=(w2, 400), visible=False)
        btn.push_handlers(on_press=self._press_speed_add)
        self.menuitems.append(btn)
        btn = MenuItem(label='Speed -1', color=(0, 0, .7, .7),
                       radius=40, pos=(w2, 500), visible=False)
        btn.push_handlers(on_press=self._press_speed_del)
        self.menuitems.append(btn)

        for btn in self.menuitems:
            self.add_widget(btn)

    def draw(self):
        if len(self.menuitems) == 0:
            self.create_ui()
        if not self.do_show:
            return
        w = self.get_parent_window()
        w2 = w.width / 3.
        w3 = w.width / 3.
        h2 = w.height / 2.
        self.menu.pos = (w2, 0)
        drawLabel('Speed x%d' % self.game.speed,
                  font_size=42, pos=(w3 - 100, h2 - 50),
                  color=(1, 1, 1))
        drawLabel('Balls %d' % len(self.game.balls),
                  font_size=42, pos=(w3 - 100, h2),
                  color=(1, 1, 1))


class Wang(MTWidget):

    BAT_LENGTH_MAX = 350

    def __init__(self, **kwargs):
        super(Wang, self).__init__(**kwargs)
        self.balls = []
        self.balls.append(Ball(pos=(100, 100), game=self))
        for ball in self.balls:
            self.add_widget(ball)

        self.labelA = MTLabel(label='0', font_size=48, autoheight=True)
        self.labelB = MTLabel(label='0', font_size=48, autoheight=True)
        self._scoreA = 0
        self._scoreB = 0
        self.side = 0
        self.pause = False
        self.need_reset = True
        self.speed = 1
        self.menu = Menu(radius=40, game=self)
        self.add_widget(self.menu)

    def _get_scoreA(self):
        return self._scoreA
    def _get_scoreB(self):
        return self._scoreB
    def _set_scoreA(self, value):
        self._scoreA = value
        self.labelA.label = str(value)
    def _set_scoreB(self, value):
        self._scoreB = value
        self.labelB.label = str(value)
    scoreA = property(_get_scoreA, _set_scoreA)
    scoreB = property(_get_scoreB, _set_scoreB)

    def generate_ball(self):
        if len(self.balls) >= 20:
            return
        ball = Ball(pos=(100, 100), game=self)
        self.balls.append(ball)
        self.add_widget(ball)
        self.reset()

    def remove_ball(self):
        if len(self.balls) < 2:
            return
        ball = self.balls.pop()
        self.remove_widget(ball)
        self.reset()

    def reset(self, score=False):
        self.need_reset = False
        self.bats = []
        self.batsid = []
        if score:
            self.scoreA = 0
            self.scoreB = 0
        self.side = (self.side + 1) % 2
        w = self.get_parent_window()
        for ball in self.balls:
            ball.reset()
            ball.y = w.height / 2.
            if self.side == 0:
                ball.x = w.width / 3.
            else:
                ball.x = (w.width / 3.) * 2.

    def on_update(self):
        dt = getFrameDt() * self.speed
        if self.pause:
            dt = 0
        w = self.get_parent_window()
        w2 = w.width / 2.

        if self.need_reset:
            self.reset()

        # update bats
        self.bats = []
        self.batsid = []
        touches = getCurrentTouches()
        for a in touches:
            for b in touches[1:]:
                if a == b:
                    continue
                apos = Vector(self.to_widget(*a.pos))
                bpos = Vector(self.to_widget(*b.pos))
                if Vector(apos).distance(bpos) > 400:
                    continue
                aside, bside = 0, 0
                if apos.x > w2:
                    aside = 1
                if bpos.x > w2:
                    bside = 1
                if aside != bside:
                    continue
                if (apos, bpos) in self.batsid:
                    continue
                if (bpos, apos) in self.batsid:
                    continue
                self.bats.append(Bat(a=apos, b=bpos))
                self.batsid.append((apos, bpos))

        for ball in self.balls:
            ball.update(dt)

    def drawUI(self):
        w = self.get_parent_window()
        w2 = w.width / 2.
        s = w.height / 20.

        # middle line
        set_color(1, 1, 1)
        for x in xrange(0, w.height, int(s * 2)):
            drawLine([w2, x, w2, x + s], width=5)

        # top / bottom line
        drawLine([0, 0, w.width, 0], width=5)
        drawLine([0, w.height, w.width, w.height], width=5)

        # draw scores
        self.labelA.x = w2 - self.labelA.width - 10
        self.labelA.y = w.height - self.labelA.height - 10
        self.labelB.x = w2 + 10
        self.labelB.y = w.height - self.labelB.height - 10
        self.labelA.draw()
        self.labelB.draw()

    def winA(self):
        self.scoreA += 1
        self.need_reset = True

    def winB(self):
        self.scoreB += 1
        self.need_reset = True

    def draw(self):
        set_color(0)
        drawRectangle(size=getWindow().size)

        self.drawUI()

        # draw
        for ball in self.balls:
            ball.draw()
        for bat in self.bats:
            bat.draw()

def pymt_plugin_activate(w, ctx):
    ctx.wang = Wang()
    w.add_widget(ctx.wang)

def pymt_plugin_deactivate(w, ctx):
    w.remove_widget(ctx.wang)

if __name__ == '__main__':
    w = MTWindow()
    ctx = MTContext()
    pymt_plugin_activate(w, ctx)
    runTouchApp()
    pymt_plugin_deactivate(w, ctx)

########NEW FILE########
__FILENAME__ = launcher-multi
#!/usr/bin/env python

import subprocess, sys, os
desktop_dir = os.path.join(os.path.dirname(__file__), 'desktop')
proc = subprocess.Popen([sys.executable, 'desktop-multi.py'] + sys.argv[1:],
                        cwd=desktop_dir)
proc.wait()

########NEW FILE########
__FILENAME__ = launcher-single
#!/usr/bin/env python

import subprocess, sys, os
desktop_dir = os.path.join(os.path.dirname(__file__), 'desktop')
proc = subprocess.Popen([sys.executable, 'desktop-single.py'] + sys.argv[1:],
                        cwd=desktop_dir)
proc.wait()

########NEW FILE########
__FILENAME__ = kinetic
from pymt import *

def print_me(*largs):
	print 'CLICKED ON', largs[0].label

mms = MTWindow()
w = MTScatterWidget(size=(500, 500))
mms.add_widget(w)

# uncomment if you want a horizontal kinetic list
#k = MTKineticList(pos=(20, 20), size=(400, 400), h_limit=2, w_limit=0, do_x=True, do_y=False)
k = MTKineticList(pos=(50,50), size=(400, 400), w_limit=3)
w.add_widget(k)

d = range(0, 20)
for x in d:
    item = MTKineticItem(label=str(x),deletable=True)
    item.push_handlers(on_press=curry(print_me, item))
    k.add_widget(item)

runTouchApp()

########NEW FILE########
__FILENAME__ = kineticimage
from pymt import *
import glob, os

k = MTKineticList(size=getWindow().size, friction=1, do_x=True,
                  h_limit=4, do_y=False, title=None, deletable=False,
                  searchable=False, w_limit=0)

# search file in image directory
pattern = os.path.join(os.path.dirname(__file__), 'images', '*.png')
for x in xrange(10):
    for filename in glob.glob(pattern):
        item = MTKineticImage(image=Loader.image(filename))
        k.add_widget(item)

runTouchApp(k)

########NEW FILE########
__FILENAME__ = labelanchor
from pymt import *

layout = MTGridLayout(cols=3)

size = (200, 200)
text = 'Hello World\nAnchor X: %s\nAnchor Y: %s'
style = {'bg-color': (0, .2, 0, 1), 'draw-background': 1}

for anchor_x in ('left', 'center', 'right'):
    for anchor_y in ('top', 'middle', 'bottom'):
        label = MTLabel(label=text % (anchor_x, anchor_y), size=size,
                anchor_x=anchor_x, anchor_y=anchor_y,
                halign=anchor_x, valign=anchor_y,
                style=style)
        layout.add_widget(label)

runTouchApp(layout)

########NEW FILE########
__FILENAME__ = label_fade
from pymt import *

w = getWindow()
m = MTLabel(label='Welcome', pos=w.center, color=(1., 0, 0, 1.), font_size=12., anchor_x='center', anchor_y='middle')
m.do(Animation(duration=5, color=(0, 1., 0, 0), font_size=88.))

runTouchApp(m)

########NEW FILE########
__FILENAME__ = modalpopup
from pymt import *

m = MTWindow()

# create a simple popup
p = MTModalPopup(title='Hello World', content='I hope you will like it !')
m.add_widget(p)

runTouchApp()


########NEW FILE########
__FILENAME__ = modalwindow
from pymt import *

m = MTWindow()

# a back button, you will be unable to click on him
# cause the modal window will take all events
back = MTButton(label='Try to click me', pos=(200, 200))

# create a modal window
mw = MTModalWindow()

# add a button to close modal window
mb = MTButton(label='Close Modal')
@mb.event
def on_press(*largs):
	global mw
	m.remove_widget(mw)
mw.add_widget(mb)

# add back button
m.add_widget(back)

# add modal window
m.add_widget(mw)

runTouchApp()

########NEW FILE########
__FILENAME__ = multiplescatter
from pymt import *

class MyWidget(MTWidget):
	def __init__(self, **kwargs):
		super(MyWidget, self).__init__(**kwargs)

	def on_draw(self):
		for w in self.children:
			w.dispatch_event('on_draw')
		c = self.children[-1].children[-1]
		cwinpos = c.to_window(*c.pos)
		set_color(0, 1, 0, 1)
		drawLine((0, 0, cwinpos[0], cwinpos[1]))

		set_color(0, 0, 1, 1)
		drawLine((0, 0, c.x, c.y))

w = MTWindow()
root = MyWidget()
s1 = MTScatterWidget(style={'bg-color': (1, 0, 0, 1)}, size=(200, 200))
s2 = MTScatterWidget(style={'bg-color': (1, 1, 0, 1)})
s1.add_widget(s2)
root.add_widget(s1)
w.add_widget(root)
print ''
print 'Blue line represent the (0, 0) -> scatter.pos (invalid in this case)'
print 'Green line represent the (0, 0) -> scatter position for window (valid)'
print ''
runTouchApp()

########NEW FILE########
__FILENAME__ = popup
from pymt import *

m = MTWindow()

p = MTPopup(title='Example with kinetic', label_submit='Select')
k = MTKineticList(size=(400, 300), searchable=False, deletable=False, title=None)
k.add_widget(MTKineticItem(label='test1'))
k.add_widget(MTKineticItem(label='test2'))
k.add_widget(MTKineticItem(label='blehlazkdjalzidj'))
k.add_widget(MTKineticItem(label='blehlazkdjalzidj'))
k.add_widget(MTKineticItem(label='blehlazkdjalzidj'))
k.add_widget(MTKineticItem(label='blehlazkdjalzidj'))
p.add_widget(k)
m.add_widget(p)

runTouchApp()

########NEW FILE########
__FILENAME__ = stencil
# Just a test with stacking stencil.
# InnerWindow use stencil for clipping content draw
# And Kinetic too.

# Scatter plane is here to test that stacking with different matrix
# transformation will work too.

from pymt import *

mms = MTWindow()
w = MTInnerWindow(size=(600, 600))
mms.add_widget(w)

p = MTScatterPlane()
k = MTKineticList(pos=(20, 20), size=(400, 400), w_limit=3)
p.add_widget(k)
w.add_widget(p)

d = range(0, 10)
for x in d:
    item = MTKineticItem(label=str(x))
    k.add_widget(item)

runTouchApp()

########NEW FILE########
__FILENAME__ = stencilcontainer
from pymt import *
sb = MTStencilContainer(size=(200, 200))
s = MTStencilContainer(size=(50, 50))
s.add_widget(MTLabel(label="XXXXXXXXXX", pos=(100, 100), font_size=16))
s.add_widget(MTLabel(label="XXXXXXXXXXXXXXXXXXXXXXXXXXXXX", pos=(150, 50), font_size=16))
s.add_widget(MTLabel(label="XXXXXXXXXXXXXXXXXXXXXXXXXXXXX", pos=(100, 150), font_size=16))
s.add_widget(MTLabel(label="XXXXXXXXXXXXXXXXXXXXXXXXXXXXX", pos=(0, 0), font_size=16))
sb.add_widget(s)
w = MTWindow()
w.add_widget(sb)
runTouchApp()


########NEW FILE########
__FILENAME__ = accelerate
'''
Accelerate: wrapper around _accelerate module, written in cython.

This module increase internal performance of PyMT. User should not use directly
this module. It's designed to enhance performance of :

    * event dispatching (EventDispatcher class)
    * event traversal (Widget class, on_update and on_draw)
    * collide method (Widget class, collide_point)

Accelerate module use cython, and is activated by default, if cython is
correctly installed. Please refer to http://www.cython.org/ about how
to install cython on your environment.

You can control the usage of accelerate module with env variable ::

    PYMT_USE_ACCELERATE

If the env is set to 0, the module will be deactivated.
'''

__all__ = ('accelerate', )

from pymt import pymt_options, pymt_logger

#: Accelerate module (None mean that the module is not available)
accelerate = None

# try to use cython is available
if pymt_options.get('use_accelerate'):
    try:
        import pymt.c_ext.c_accelerate as accelerate
        pymt_logger.info('Core: Using accelerate module')
    except ImportError, e:
        pymt_logger.warning('Core: Accelerate module not available <%s>' % e)
        pymt_logger.warning('Core: Execute "python setup.py build_ext '
                            '--inplace"')
else:
    pymt_logger.info('Core: Accelerate module disabled by user')


########NEW FILE########
__FILENAME__ = base
'''
Base: Main event loop, provider creation, window management...
'''

__all__ = (
    'pymt_usage',
    'runTouchApp', 'stopTouchApp',
    'getFrameDt', 'getCurrentTouches',
    'getEventLoop',
    'pymt_event_listeners', 'touch_event_listeners',
    'pymt_providers',
    'getWindow', 'setWindow'
)

import pymt
import sys
import os
from pymt.logger import pymt_logger
from pymt.exceptions import pymt_exception_manager, ExceptionManager
from pymt.clock import getClock
from pymt.input import TouchFactory, pymt_postproc_modules

# private vars
touch_list              = []
pymt_window             = None
pymt_providers          = []
pymt_evloop             = None
frame_dt                = 0.01 # non-zero value to prevent user zero division

#: List of event listeners
pymt_event_listeners    = []

#: .. deprecated:: 0.5
#:      This symbol have been renamed to pymt_event_listeners 
touch_event_listeners   = pymt_event_listeners

def getFrameDt():
    '''Return the last delta between old and new frame.'''
    return frame_dt

def getCurrentTouches():
    '''Return the list of all current touches'''
    return touch_list

def getWindow():
    '''Return the MTWindow'''
    return pymt_window

def setWindow(win):
    '''Set current PyMT window
    .. warning::
        Use it only if you know what you are doing !
    '''
    global pymt_window
    pymt_window = win

def getEventLoop():
    '''Return the default TouchEventLoop object'''
    return pymt_evloop

class TouchEventLoop(object):
    '''Main event loop. This loop handle update of input + dispatch event
    '''
    def __init__(self):
        super(TouchEventLoop, self).__init__()
        self.quit = False
        self.input_events = []
        self.postproc_modules = []
        self.status = 'idle'

    def start(self):
        '''Must be call only one time before run().
        This start all configured input providers.'''
        self.status = 'started'
        for provider in pymt_providers:
            provider.start()

    def close(self):
        '''Exit from the main loop, and stop all configured
        input providers.'''
        self.quit = True
        self.stop()
        self.status = 'closed'

    def stop(self):
        '''Stop all input providers'''
        #stop in reverse order that we started them!! (liek push pop),
        #very important becasue e.g. wm_touch and WM_PEN both store
        #old window proc and teh restore, if order is messed big problem
        #happens, crashing badly without error
        for provider in reversed(pymt_providers):
            provider.stop()
        self.status = 'stopped'

    def add_postproc_module(self, mod):
        '''Add a postproc input module (DoubleTap, RetainTouch are default)'''
        self.postproc_modules.append(mod)

    def remove_postproc_module(self, mod):
        '''Remove a postproc module'''
        if mod in self.postproc_modules:
            self.postproc_modules.remove(mod)

    def post_dispatch_input(self, event, touch):
        '''This function is called by dispatch_input() when we want to dispatch
        a input event. The event is dispatched into all listeners, and if
        grabbed, it's dispatched through grabbed widgets'''
        # update available list
        if event == 'down':
            touch_list.append(touch)
        elif event == 'up':
            if touch in touch_list:
                touch_list.remove(touch)

        # dispatch to listeners
        if not touch.grab_exclusive_class:
            for listener in pymt_event_listeners:
                if event == 'down':
                    listener.dispatch_event('on_touch_down', touch)
                elif event == 'move':
                    listener.dispatch_event('on_touch_move', touch)
                elif event == 'up':
                    listener.dispatch_event('on_touch_up', touch)

        # dispatch grabbed touch
        touch.grab_state = True
        for _wid in touch.grab_list[:]:

            # it's a weakref, call it!
            wid = _wid()
            if wid is None:
                # object is gone, stop.
                touch.grab_list.remove(_wid)
                continue

            root_window = wid.get_root_window()
            if wid != root_window and root_window is not None:
                touch.push()
                w, h = root_window.system_size
                touch.scale_for_screen(w, h, rotation=root_window.rotation)
                parent = wid.parent
                # and do to_local until the widget
                try:
                    if parent:
                        touch.apply_transform_2d(parent.to_widget)
                    else:
                        touch.apply_transform_2d(wid.to_widget)
                        touch.apply_transform_2d(wid.to_parent)
                except AttributeError:
                    # when using innerwindow, an app have grab the touch
                    # but app is removed. the touch can't access
                    # to one of the parent. (ie, self.parent will be None)
                    # and BAM the bug happen.
                    touch.pop()
                    continue

            touch.grab_current = wid

            if event == 'down':
                # don't dispatch again touch in on_touch_down
                # a down event are nearly uniq here.
                # wid.dispatch_event('on_touch_down', touch)
                pass
            elif event == 'move':
                wid.dispatch_event('on_touch_move', touch)
            elif event == 'up':
                wid.dispatch_event('on_touch_up', touch)

            touch.grab_current = None

            if wid != root_window and root_window is not None:
                touch.pop()
        touch.grab_state = False

    def _dispatch_input(self, event, touch):
        ev = (event, touch)
        # remove the save event for the touch if exist
        if ev in self.input_events[:]:
            self.input_events.remove(ev)
        self.input_events.append(ev)

    def dispatch_input(self):
        '''Called by idle() to read events from input providers,
        pass event to postproc, and dispatch final events'''
        # first, aquire input events
        for provider in pymt_providers:
            provider.update(dispatch_fn=self._dispatch_input)

        # execute post-processing modules
        for mod in self.postproc_modules:
            self.input_events = mod.process(events=self.input_events)

        # real dispatch input
        for event, touch in self.input_events:
            self.post_dispatch_input(event=event, touch=touch)

        self.input_events = []

    def idle(self):
        '''This function is called every frames. By default :
        * it "tick" the clock to the next frame
        * read all input and dispatch event
        * dispatch on_update + on_draw + on_flip on window
        '''
        # update dt
        global frame_dt
        frame_dt = getClock().tick()

        # read and dispatch input from providers
        self.dispatch_input()

        if pymt_window:
            pymt_window.dispatch_events()
            pymt_window.dispatch_event('on_update')
            pymt_window.dispatch_event('on_draw')
            pymt_window.dispatch_event('on_flip')

        # don't loop if we don't have listeners !
        if len(pymt_event_listeners) == 0:
            self.exit()
            return False

        return self.quit

    def run(self):
        '''Main loop'''
        while not self.quit:
            self.idle()
        self.exit()

    def exit(self):
        '''Close the main loop, and close the window'''
        self.close()
        if pymt_window:
            pymt_window.close()


def pymt_usage():
    '''PyMT Usage: %s [OPTION...] ::

        -h, --help                  prints this mesage
        -f, --fullscreen            force run in fullscreen
        -k, --fake-fullscreen       force run in 'fake' fullscreen (no border mode)
        -a, --auto-fullscreen       force run in 'auto' fullscreen (no resolution change)
        -w, --windowed              force run in window
        -p, --provider id:provider[,options] add a provider (eg: ccvtable1:tuio,192.168.0.1:3333)
        -F, --fps                   show fps in window
        -m mod, --module=mod        activate a module (use "list" to get available module)
        -r, --rotation              rotate the window (0, 90, 180, 270)
        -s, --save                  save current PyMT configuration
        --size=640x480              size of window

    '''
    print pymt_usage.__doc__ % (os.path.basename(sys.argv[0]))


def _run_mainloop():
    '''If user haven't create a window, this is the executed mainloop'''
    while True:
        try:
            pymt_evloop.run()
            stopTouchApp()
            break
        except BaseException, inst:
            # use exception manager first
            r = pymt_exception_manager.handle_exception(inst)
            if r == ExceptionManager.RAISE:
                stopTouchApp()
                raise
            else:
                pass


def runTouchApp(widget=None, slave=False):
    '''Static main function that starts the application loop.
    You got some magic things, if you are using argument like this :

    :Parameters:
        `<empty>`
            To make dispatching work, you need at least one
            input listener. If not, application will leave.
            (MTWindow act as an input listener)

        `widget`
            If you pass only a widget, a MTWindow will be created,
            and your widget will be added on the window as the root
            widget.

        `slave`
            No event dispatching are done. This will be your job.

        `widget + slave`
            No event dispatching are done. This will be your job, but
            we are trying to get the window (must be created by you before),
            and add the widget on it. Very usefull for embedding PyMT
            in another toolkit. (like Qt, check pymt-designed)

    '''

    global pymt_evloop

    # Ok, we got one widget, and we are not in slave mode
    # so, user don't create the window, let's create it for him !
    ### Not needed, since we always create window ?!
    #if not slave and widget:
    #    global pymt_window
    #    from ui.window import MTWindow
    #    pymt_window = MTWindow()

    # Instance all configured input
    for key, value in pymt.pymt_config.items('input'):
        pymt_logger.debug('Base: Create provider from %s' % (str(value)))

        # split value
        args = str(value).split(',', 1)
        if len(args) == 1:
            args.append('')
        provider_id, args = args
        provider = TouchFactory.get(provider_id)
        if provider is None:
            pymt_logger.warning('Base: Unknown <%s> provider' % \
                                str(provider_id))
            continue

        # create provider
        p = provider(key, args)
        if p:
            pymt_providers.append(p)

    pymt_evloop = TouchEventLoop()

    # add postproc modules
    for mod in pymt_postproc_modules.values():
        pymt_evloop.add_postproc_module(mod)

    # add main widget
    if widget and getWindow():
        getWindow().add_widget(widget)

    # start event loop
    pymt_logger.info('Base: Start application main loop')
    pymt_evloop.start()

    # we are in a slave mode, don't do dispatching.
    if slave:
        return

    # in non-slave mode, they are 2 issues
    #
    # 1. if user created a window, call the mainloop from window.
    #    This is due to glut, it need to be called with
    #    glutMainLoop(). Only FreeGLUT got a gluMainLoopEvent().
    #    So, we are executing the dispatching function inside
    #    a redisplay event.
    #
    # 2. if no window is created, we are dispatching event lopp
    #    ourself (previous behavior.)
    #
    try:
        if pymt_window is None:
            _run_mainloop()
        else:
            pymt_window.mainloop()
    finally:
        stopTouchApp()

def stopTouchApp():
    '''Stop the current application by leaving the main loop'''
    if pymt_evloop is None:
        return
    if pymt_evloop.status != 'started':
        return
    pymt_logger.info('Base: Leaving application in progress...')
    pymt_evloop.close()

########NEW FILE########
__FILENAME__ = baseobject
'''
Base object: object with position and size attributes, with helpers
'''

__all__ = ('BaseObject', )

class BaseObject(object):
    '''Represent a object with position and size information'''

    __slots__ = ('_size', '_pos')

    def __init__(self, **kwargs):
        kwargs.setdefault('size', (0, 0))
        kwargs.setdefault('pos', (0, 0))
        super(BaseObject, self).__init__()
        self._size  = kwargs.get('size')
        self._pos   = kwargs.get('pos')

    def _get_size(self):
        return self._size
    def _set_size(self, size):
        if self._size == size:
            return False
        self._size = size
        return True
    size = property(_get_size, _set_size,
                    doc='Object size (width, height)')

    def _get_width(self):
        return self._size[0]
    def _set_width(self, w):
        if self._size[0] == w:
            return False
        self._size = (w, self._size[1])
        return True
    width = property(_get_width, _set_width,
                     doc='Object width')

    def _get_height(self):
        return self._size[1]
    def _set_height(self, h):
        if self._size[1] == h:
            return False
        self._size = (self._size[0], h)
        return True
    height = property(_get_height, _set_height,
                      doc='Object height')

    def _get_pos(self):
        return self._pos
    def _set_pos(self, pos):
        if pos == self._pos:
            return False
        self._pos = tuple(pos)
        return True
    pos = property(_get_pos, _set_pos,
                   doc='Object position (x, y)')

    def _get_x(self):
        return self._pos[0]
    def _set_x(self, x):
        if x == self.pos[0]:
            return False
        self._pos = (x, self.y)
        return True
    x = property(_get_x, _set_x,
                 doc = 'Object X position')

    def _get_y(self):
        return self._pos[1]
    def _set_y(self, y):
        if y == self.pos[1]:
            return False
        self._pos = (self.x, y)
        return True
    y = property(_get_y, _set_y,
                 doc = 'Object Y position')

    def _get_center(self):
        x, y = self._pos
        w, h = self._size
        return (x + w / 2., y + h / 2.)
    def _set_center(self, center):
        cx, cy = center
        w, h = self._size
        return self._set_pos((cx - w / 2., cy - h / 2.))
    center = property(_get_center, _set_center,
                      doc='Object center (cx, cy)')


    #helpfull getter setter for corners and right/top side
    def _get_top(self):
        return self.y + self.height
    def _set_top(self, top):
        self.y = top - self.height
    top = property(_get_top, _set_top,
                   doc='y coordinate of top (y + height)')

    def _get_right(self):
        return self.x+self.width
    def _set_right(self, right):
        self.x = right - self.width
    right = property(_get_right, _set_right,
                     doc='x coordinate of rigth side (x + width)')

    def _get_topleft(self):
        return (self.x, self.top)
    def _set_topleft(self, topleft):
        self.x = topleft[0]
        self.top = topleft[1]
    topleft = property(_get_topleft, _set_topleft,
                       doc='coordinate of topleft (x, y+height)')

    def _get_centerleft(self):
        return (self.x, self.y + self.height / 2.)
    def _set_centerleft(self, centerleft):
        self.pos = (centerleft[0], centerleft[1] - self.height / 2.)
    centerleft = property(_get_centerleft, _set_centerleft,
                          doc='coordinate of centerleft (x, y + height / 2)')

    def _get_topcenter(self):
        return (self.x+self.width/2., self.y+self.height)
    def _set_topcenter(self, topcenter):
        self.pos = (topcenter[0] - self.width / 2., topcenter[1] - self.height)
    topcenter = property(_get_topcenter, _set_topcenter,
                         doc='coordinate of topcenter (x+width/2, y+height)')

    def _get_bottomcenter(self):
        return (self.x+self.width/2., self.y)
    def _set_bottomcenter(self, bottomcenter):
        self.pos = (bottomcenter[0]-self.width/2., bottomcenter[1])
    bottomcenter = property(_get_bottomcenter, _set_bottomcenter,
                            doc='coordinate of bottomcenter (x+width/2, y)')

    def _get_topright(self):
        return (self.right, self.top)
    def _set_topright(self, topright):
        self.right = topright[0]
        self.top = topright[1]
    topright = property(_get_topright, _set_topright,
                        doc='coordinate of topright (x+width, y+height)')

    def _get_centerright(self):
        return (self.right, self.y+self.height/2.)
    def _set_centerright(self, centerright):
        self.right = centerright[0]
        self.y = centerright[1] - self.height/2.0
    centerright = property(_get_centerright, _set_centerright,
                           doc='coordinate of centerright (x+width, y+height/2)')

    def _get_bottomright(self):
        return (self.right, self.y)
    def _set_bottomright(self, bottomright):
        self.right = bottomright[0]
        self.y = bottomright[1] - self.height
    bottomright = property(_get_bottomright, _set_bottomright,
                           doc='coordinate of bottomright (x+width, y')


    def update(self):
        '''Placeholder to update the object'''
        pass

    def draw(self):
        '''Placeholder to draw the object'''
        pass

########NEW FILE########
__FILENAME__ = cache
'''
Cache Manager: cache object and delete them automaticly

How to use the cache ::
    # register a new Cache
    Cache.register('mycache', limit=10, timeout=5)

    # create an object + id
    label = 'objectid'
    instance = MTLabel(label=label)
    Cache.append('mycache', label, instance)

    # retreive the object later
    instance = Cache.get('mycache', label)

If the instance is NULL, the cache may have trash it, because you've
not used the label since 5 seconds, and you've reach the limit.
'''

__all__ = ('Cache', )

from pymt.logger import pymt_logger
from pymt.clock import getClock

class Cache(object):
    '''Cache, a manager to cache object'''

    _categories = {}
    _objects = {}

    @staticmethod
    def register(category, limit=None, timeout=None):
        '''Register a new category in cache, with limit

        :Parameters:
            `category` : str
                Identifier of the category
            `limit` : int (optionnal)
                Maximum number of object in the cache.
                If None, no limit is applied.
            `timeout` : double (optionnal)
                Time to delete the object when it's not used.
                if None, no timeout is applied.
        '''
        Cache._categories[category] = {
            'limit': limit,
            'timeout': timeout
        }
        Cache._objects[category] = {}
        pymt_logger.debug('Cache: register <%s> with limit=%s, timeout=%ss' %
            (category, str(limit), str(timeout)))

    @staticmethod
    def append(category, key, obj, timeout=None):
        '''Add a new object in the cache.

        :Parameters:
            `category` : str
                Identifier of the category
            `key` : str
                Uniq identifier of the object to store
            `obj` : object
                Object to store in cache
            `timeout` : double (optionnal)
                Custom time to delete the object if it's not used.
        '''
        try:
            cat = Cache._categories[category]
        except KeyError:
            pymt_logger.warning('Cache: category <%s> not exist' % category)
            return
        timeout = timeout or cat['timeout']
        # FIXME: activate purge when limit is hit
        #limit = cat['limit']
        #if limit is not None and len(Cache._objects[category]) >= limit:
        #    Cache._purge_oldest(category)
        Cache._objects[category][key] = {
            'object': obj,
            'timeout': timeout,
            'lastaccess': getClock().get_time(),
            'timestamp': getClock().get_time()
        }

    @staticmethod
    def get(category, key, default=None):
        '''Get a object in cache.

        :Parameters:
            `category` : str
                Identifier of the category
            `key` : str
                Uniq identifier of the object to store
            `default` : anything, default to None
                Default value to be returned if key is not found
        '''
        try:
            Cache._objects[category][key]['lastaccess'] = getClock().get_time()
            return Cache._objects[category][key]['object']
        except Exception:
            return default

    @staticmethod
    def get_timestamp(category, key, default=None):
        '''Get the object timestamp in cache.

        :Parameters:
            `category` : str
                Identifier of the category
            `key` : str
                Uniq identifier of the object to store
            `default` : anything, default to None
                Default value to be returned if key is not found
        '''
        try:
            return Cache._objects[category][key]['timestamp']
        except Exception:
            return default

    @staticmethod
    def get_lastaccess(category, key, default=None):
        '''Get the object last access time in cache.

        :Parameters:
            `category` : str
                Identifier of the category
            `key` : str
                Uniq identifier of the object to store
            `default` : anything, default to None
                Default value to be returned if key is not found
        '''
        try:
            return Cache._objects[category][key]['lastaccess']
        except Exception:
            return default

    @staticmethod
    def remove(category, key=None):
        '''Purge the cache

        :Parameters:
            `category` : str (optionnal)
                Identifier of the category
            `key` : str (optionnal)
                Uniq identifier of the object to store
        '''
        try:
            if key is not None:
                del Cache._objects[category][key]
            else:
                Cache._objects[category] = {}
        except Exception:
            pass

    @staticmethod
    def _purge_oldest(category, maxpurge=1):
        print 'PURGE', category
        import heapq
        heap_list = []
        for key in Cache._objects[category]:
            obj = Cache._objects[category][key]
            if obj['lastaccess'] == obj['timestamp']:
                continue
            heapq.heappush(heap_list, (obj['lastaccess'], key))
            print '<<<', obj['lastaccess']
        n = 0
        while n < maxpurge:
            try:
                lastaccess, key = heapq.heappop(heap_list)
                print '=>', key, lastaccess, getClock().get_time()
            except Exception:
                return
            del Cache._objects[category][key]


    @staticmethod
    def _purge_by_timeout(dt):

        curtime = getClock().get_time()

        for category in Cache._objects:

            timeout = Cache._categories[category]['timeout']
            if timeout is not None and dt > timeout:
                # XXX got a lag ! that may be because the frame take lot of
                # time to draw. and the timeout is not adapted to the current
                # framerate. So, increase the timeout by two.
                # ie: if the timeout is 1 sec, and framerate go to 0.7, newly
                # object added will be automaticly trashed.
                timeout *= 2
                Cache._categories[category]['timeout'] = timeout
                continue

            for key in Cache._objects[category].keys()[:]:

                lastaccess  = Cache._objects[category][key]['lastaccess']
                objtimeout  = Cache._objects[category][key]['timeout']

                # take the object timeout if available
                if objtimeout is not None:
                    timeout = objtimeout

                # no timeout, cancel
                if timeout is None:
                    continue

                if curtime - lastaccess > timeout:
                    del Cache._objects[category][key]

    @staticmethod
    def print_usage():
        '''Print the cache usage on the console'''
        print 'Cache usage :'
        for category in Cache._categories:
            print ' * %s : %d / %s, timeout=%s' % (
                category.capitalize(),
                len(Cache._objects[category]),
                str(Cache._categories[category]['limit']),
                str(Cache._categories[category]['timeout'])
            )

# install the schedule clock for purging
getClock().schedule_interval(Cache._purge_by_timeout, 1)

########NEW FILE########
__FILENAME__ = clock
'''
Clock: a clock with scheduled events

You can add new event like this ::

    def my_callback(dt):
        pass

    # call my_callback every 0.5 seconds
    getClock().schedule_interval(my_callback, 0.5)

    # call my_callback in 5 seconds
    getClock().schedule_once(my_callback, 5)

If the callback return False, the schedule will be removed.
'''

__all__ =  ('Clock', 'getClock')

import time
from pymt.weakmethod import WeakMethod

class _Event(object):

    def __init__(self, loop, callback, timeout, starttime):
        self.loop = loop
        self.callback = WeakMethod(callback)
        self.timeout = timeout
        self._last_dt = starttime
        self._dt = 0.

    def do(self, dt):
        if self.callback.is_dead():
            return False
        self.callback()(dt)

    def tick(self, curtime):
        # timeout happen ?
        if curtime - self._last_dt < self.timeout:
            return True

        # calculate current timediff for this event
        self._dt = curtime - self._last_dt
        self._last_dt = curtime

        # call the callback
        if self.callback.is_dead():
            return False
        ret = self.callback()(self._dt)

        # if it's a once event, don't care about the result
        # just remove the event
        if not self.loop:
            return False

        # if user return an explicit false,
        # remove the event
        if ret == False:
            return False

        return True


class Clock(object):
    '''A clock object, that support events'''
    __slots__ = ('_dt', '_last_fps_tick', '_last_tick', '_fps',
            '_fps_counter', '_events')

    def __init__(self):
        self._dt = 0
        self._last_tick = time.time()
        self._fps = 0
        self._fps_counter = 0
        self._last_fps_tick = None
        self._events = []

    def tick(self):
        '''Advance clock to the next step. Must be called every frame.
        The default clock have the tick() function called by PyMT'''
        # tick the current time
        current = time.time()
        self._dt = current - self._last_tick
        self._fps_counter += 1
        self._last_tick = current

        # calculate fps things
        if self._last_fps_tick == None:
            self._last_fps_tick = current
        elif current - self._last_fps_tick > 1:
            self._fps = self._fps_counter / float(current - self._last_fps_tick)
            self._last_fps_tick = current
            self._fps_counter = 0

        # process event
        self._process_events()

        return self._dt

    def get_fps(self):
        '''Get the current FPS calculated by the clock'''
        return self._fps

    def get_time(self):
        '''Get the last tick made by the clock'''
        return self._last_tick

    def schedule_once(self, callback, timeout=0):
        '''Schedule an event in <timeout> seconds'''
        event = _Event(False, callback, timeout, self._last_tick)
        self._events.append(event)
        return event

    def schedule_interval(self, callback, timeout):
        '''Schedule a event to be call every <timeout> seconds'''
        event = _Event(True, callback, timeout, self._last_tick)
        self._events.append(event)
        return event

    def unschedule(self, callback):
        '''Remove a previous schedule event'''
        self._events = [x for x in self._events if x.callback() != callback]

    def _process_events(self):
        for event in self._events[:]:
            if event.tick(self._last_tick) == False:
                # event may be already removed by the callback
                if event in self._events:
                    self._events.remove(event)


# create a default clock
_default_clock = Clock()

# make it available
def getClock():
    '''Return the clock instance used by PyMT'''
    return _default_clock


########NEW FILE########
__FILENAME__ = config
'''
Config: base for PyMT configuration file
'''

__all__ = ('pymt_config', )

from ConfigParser import ConfigParser
import sys
import os
from pymt.logger import pymt_logger
from pymt import pymt_home_dir, pymt_config_fn, logger

# Version number of current configuration format
PYMT_CONFIG_VERSION = 16

#: PyMT configuration object
pymt_config = None

if not 'PYMT_DOC_INCLUDE' in os.environ:

    #
    # Read, analyse configuration file
    # Support upgrade of older config file version
    #

    class PyMTConfigParser(ConfigParser):
        def setdefault(self, section, option, value):
            if self.has_option(section, option):
                return
            self.set(section, option, value)

        def getdefault(self, section, option, defaultvalue):
            if not self.has_section(section):
                return defaultvalue
            if not self.has_option(section, option):
                return defaultvalue
            return self.getint(section, option)

        def adddefaultsection(self, section):
            if self.has_section(section):
                return
            self.add_section(section)

        def write(self):
            with open(pymt_config_fn, 'w') as fd:
                ConfigParser.write(self, fd)

    # Create default configuration
    pymt_config = PyMTConfigParser()

    # Read config file if exist
    if os.path.exists(pymt_config_fn):
        try:
            pymt_config.read(pymt_config_fn)
        except Exception, e:
            pymt_logger.exception('Core: error while reading local'
                                  'configuration')

    pymt_config_version = pymt_config.getdefault('pymt', 'config_version', 0)

    # Add defaults section
    pymt_config.adddefaultsection('pymt')
    pymt_config.adddefaultsection('keyboard')
    pymt_config.adddefaultsection('graphics')
    pymt_config.adddefaultsection('input')
    pymt_config.adddefaultsection('dump')
    pymt_config.adddefaultsection('modules')
    pymt_config.adddefaultsection('widgets')

    # Upgrade default configuration until having the current version
    need_save = False
    if pymt_config_version != PYMT_CONFIG_VERSION:
        pymt_logger.warning('Config: Older configuration version detected'
                            '(%d instead of %d)' % (
                            pymt_config_version, PYMT_CONFIG_VERSION))
        pymt_logger.warning('Config: Upgrading configuration in progress.')
        need_save = True

    while pymt_config_version < PYMT_CONFIG_VERSION:
        pymt_logger.debug('Config: Upgrading from %d' % pymt_config_version)

        # Versionning introduced in version 0.4.
        if pymt_config_version == 0:

            pymt_config.setdefault('pymt', 'show_fps', '0')
            pymt_config.setdefault('pymt', 'log_level', 'info')
            pymt_config.setdefault('pymt', 'double_tap_time', '250')
            pymt_config.setdefault('pymt', 'double_tap_distance', '20')
            pymt_config.setdefault('pymt', 'enable_simulator', '1')
            pymt_config.setdefault('pymt', 'ignore', '[]')
            pymt_config.setdefault('keyboard', 'layout', 'qwerty')
            pymt_config.setdefault('graphics', 'fbo', 'hardware')
            pymt_config.setdefault('graphics', 'fullscreen', '0')
            pymt_config.setdefault('graphics', 'width', '640')
            pymt_config.setdefault('graphics', 'height', '480')
            pymt_config.setdefault('graphics', 'vsync', '1')
            pymt_config.setdefault('graphics', 'display', '-1')
            pymt_config.setdefault('graphics', 'line_smooth', '1')
            pymt_config.setdefault('dump', 'enabled', '0')
            pymt_config.setdefault('dump', 'prefix', 'img_')
            pymt_config.setdefault('dump', 'format', 'jpeg')
            pymt_config.setdefault('input', 'default', 'tuio,0.0.0.0:3333')
            pymt_config.setdefault('input', 'mouse', 'mouse')

            # activate native input provider in configuration
            if sys.platform == 'darwin':
                pymt_config.setdefault('input', 'mactouch', 'mactouch')
            elif sys.platform == 'win32':
                pymt_config.setdefault('input', 'wm_touch', 'wm_touch')
                pymt_config.setdefault('input', 'wm_pen', 'wm_pen')

        elif pymt_config_version == 1:
            # add retain postproc configuration
            pymt_config.setdefault('pymt', 'retain_time', '0')
            pymt_config.setdefault('pymt', 'retain_distance', '50')

        elif pymt_config_version == 2:
            # add show cursor
            pymt_config.setdefault('graphics', 'show_cursor', '1')

        elif pymt_config_version == 3:
            # add multisamples
            pymt_config.setdefault('graphics', 'multisamples', '2')

        elif pymt_config_version == 4:
            # remove mouse simulator
            pymt_config.remove_option('pymt', 'enable_simulator')

        elif pymt_config_version == 5:
            # add fixccv
            pymt_config.setdefault('pymt', 'fixccv', '0')

        elif pymt_config_version == 6:
            # add log_file format
            pymt_config.setdefault('pymt', 'log_enable', '1')
            pymt_config.setdefault('pymt', 'log_dir', 'logs')
            pymt_config.setdefault('pymt', 'log_name', 'pymt_%y-%m-%d_%_.txt')

        elif pymt_config_version == 7:
            # add option to turn off pyOpenGL Error Checking
            pymt_config.setdefault('pymt', 'gl_error_check', '1')

        elif pymt_config_version == 8:
            pymt_config.setdefault('pymt', 'jitter_distance', '0')
            pymt_config.setdefault('pymt', 'jitter_ignore_devices',
                                   'mouse,mactouch,')

        elif pymt_config_version == 9:
            pymt_config.setdefault('widgets', 'keyboard_type', 'virtual')

        elif pymt_config_version == 10:
            pymt_config.setdefault('widgets', 'list_friction', '10')
            pymt_config.setdefault('widgets', 'list_friction_bound', '20')
            pymt_config.setdefault('widgets', 'list_trigger_distance', '5')

        elif pymt_config_version == 11:
            pymt_config.setdefault('graphics', 'window_icon', os.path.join(pymt_home_dir, 'icon', 'pymt32.png') )

        elif pymt_config_version == 12:
            # default configuration for keyboard repeatition
            pymt_config.setdefault('keyboard', 'repeat_delay', '300')
            pymt_config.setdefault('keyboard', 'repeat_rate', '30')

        elif pymt_config_version == 13:
            # add possibility to set the position of windows
            pymt_config.setdefault('graphics', 'position', 'auto')
            pymt_config.setdefault('graphics', 'top', '0')
            pymt_config.setdefault('graphics', 'left', '0')

        elif pymt_config_version == 14:
            # ability to change maximum FPS
            pymt_config.setdefault('graphics', 'fps', '0')

        elif pymt_config_version == 15:
            # ability to rotate the window
            pymt_config.setdefault('graphics', 'rotation', '0')

        else:
            # for future.
            break

        # Pass to the next version
        pymt_config_version += 1

# Said to pymt_config that we've upgrade to latest version.
    pymt_config.set('pymt', 'config_version', PYMT_CONFIG_VERSION)

# Now, activate log file
    if pymt_config.getint('pymt', 'log_enable'):
        logger.pymt_logfile_activated = True

# If no configuration exist, write the default one.
    if not os.path.exists(pymt_config_fn) or need_save:
        try:
            pymt_config.write()
        except Exception, e:
            pymt_logger.exception('Core: error while saving default configuration file')

########NEW FILE########
__FILENAME__ = audio_gstreamer
'''
AudioGstreamer: implementation of Sound with GStreamer
'''

try:
    import pygst
    if not hasattr(pygst, '_gst_already_checked'):
        pygst.require('0.10')
        pygst._gst_already_checked = True
    import gst
except:
    raise

from . import Sound, SoundLoader
import os
import sys
from pymt.logger import pymt_logger

# install the gobject iteration
from pymt.support import install_gobject_iteration
install_gobject_iteration()

class SoundGstreamer(Sound):
    @staticmethod
    def extensions():
        return ('wav', 'ogg', 'mp3', )

    def __init__(self, **kwargs):
        self._data = None
        super(SoundGstreamer, self).__init__(**kwargs)

    def __del__(self):
        if self._data is not None:
            self._data.set_state(gst.STATE_NULL)

    def _on_gst_message(self, bus, message):
        t = message.type
        if t == gst.MESSAGE_EOS:
            self._data.set_state(gst.STATE_NULL)
            self.stop()
        elif t == gst.MESSAGE_ERROR:
            self._data.set_state(gst.STATE_NULL)
            err, debug = message.parse_error()
            pymt_logger.error('AudioGstreamer: %s' % err)
            pymt_logger.debug(str(debug))
            self.stop()

    def play(self):
        if not self._data:
            return
        self._data.set_state(gst.STATE_PLAYING)
        super(SoundGstreamer, self).play()

    def stop(self):
        if not self._data:
            return
        self._data.set_state(gst.STATE_NULL)
        super(SoundGstreamer, self).stop()

    def load(self):
        self.unload()
        if self.filename is None:
            return

        slash = ''
        if sys.platform in ('win32', 'cygwin'):
            slash = '/'

        if self.filename[0] == '/':
            filepath = 'file://' + slash + self.filename
        else:
            filepath = 'file://' + slash + os.path.join(os.getcwd(), self.filename)

        self._data = gst.element_factory_make('playbin2', 'player')
        fakesink = gst.element_factory_make('fakesink', 'fakesink')
        self._data.set_property('video-sink', fakesink)
        bus = self._data.get_bus()
        bus.add_signal_watch()
        bus.connect('message', self._on_gst_message)

        self._data.set_property('uri', filepath)
        self._data.set_state(gst.STATE_READY)

    def unload(self):
        self.stop()
        self._data = None

    def seek(self, position):
        if self._data is None:
            return
        self._data.seek_simple(gst.FORMAT_TIME, gst.SEEK_FLAG_SKIP,
                               position / 1000000000.)

    def _get_volume(self):
        if self._data is not None:
            self._volume = self._data.get_property('volume')
        return super(SoundGstreamer, self)._get_volume()

    def _set_volume(self, volume):
        if self._data is not None:
            self._data.set_property('volume', volume)
        return super(SoundGstreamer, self)._set_volume(volume)

SoundLoader.register(SoundGstreamer)

########NEW FILE########
__FILENAME__ = audio_pygame
'''
AudioPygame: implementation of Sound with Pygame
'''

__all__ = ('SoundPygame', )

import pymt
from . import Sound, SoundLoader

try:
    import pygame
except:
    raise

# init pygame sound
pygame.mixer.pre_init(44100, -16, 2, 1024)
pygame.mixer.init()
pygame.mixer.set_num_channels(32)

class SoundPygame(Sound):

    # XXX we don't set __slots__ here, to automaticly add
    # a dictionnary. We need that to be able to use weakref for
    # SoundPygame object. Otherwise, it failed with:
    # TypeError: cannot create weak reference to 'SoundPygame' object
    # We use our clock in play() method.
    #__slots__ = ('_data', '_channel')

    @staticmethod
    def extensions():
        return ('wav', 'ogg', )

    def __init__(self, **kwargs):
        self._data = None
        self._channel = None
        super(SoundPygame, self).__init__(**kwargs)

    def _check_play(self, dt):
        if self._channel is None:
            return False
        if self._channel.get_busy():
            return
        self.stop()
        return False

    def play(self):
        if not self._data:
            return
        self._channel = self._data.play()
        # schedule event to check if the sound is still playing or not
        pymt.getClock().schedule_interval(self._check_play, 0.1)
        super(SoundPygame, self).play()

    def stop(self):
        if not self._data:
            return
        self._data.stop()
        # ensure we don't have anymore the callback
        pymt.getClock().unschedule(self._check_play)
        self._channel = None
        super(SoundPygame, self).stop()

    def load(self):
        self.unload()
        if self.filename is None:
            return
        self._data = pygame.mixer.Sound(self.filename)

    def unload(self):
        self.stop()
        self._data = None

    def seek(self, position):
        # Unable to seek in pygame...
        pass

    def _get_volume(self):
        if self._data is not None:
            self._volume = self._data.get_volume()
        return super(SoundPygame, self)._get_volume()

    def _set_volume(self, volume):
        if self._data is not None:
            self._data.set_volume(volume)
        return super(SoundPygame, self)._set_volume(volume)

SoundLoader.register(SoundPygame)

########NEW FILE########
__FILENAME__ = camera_gstreamer
'''
GStreamer Camera: Implement CameraBase with GStreamer
'''

__all__ = ('CameraGStreamer', )

import pymt
from . import CameraBase
from OpenGL.GL import GL_RGB

try:
    import pygst
    if not hasattr(pygst, '_gst_already_checked'):
        pygst.require('0.10')
        pygst._gst_already_checked = True
    import gst
except:
    raise

# install the gobject iteration
from pymt.support import install_gobject_iteration
install_gobject_iteration()

class CameraGStreamer(CameraBase):
    '''Implementation of CameraBase using GStreamer

    :Parameters:
        `video_src` : str, default is 'v4l2src'
            Other tested options are: 'dc1394src' for firewire
            dc camera (e.g. firefly MV). Any gstreamer video source
            should potentially work.
            Theoretically a longer string using "!" can be used
            describing the first part of a gstreamer pipeline.
    '''

    def __init__(self, **kwargs):
        kwargs.setdefault('video_src', 'v4l2src')
        self._pipeline = None
        self._camerasink = None
        self._decodebin = None
        self._texturesize = None
        super(CameraGStreamer, self).__init__(**kwargs)

    def init_camera(self):
        # TODO: This does not work when camera resolution is resized at runtime...
        # there must be some other way to release the camera?
        if self._pipeline:
            self._pipeline = None

        GL_CAPS = 'video/x-raw-rgb,red_mask=(int)0xff0000,green_mask=(int)0x00ff00,blue_mask=(int)0x0000ff'
        self._pipeline = gst.parse_launch('%s ! decodebin name=decoder ! ffmpegcolorspace ! appsink name=camerasink emit-signals=True caps=%s' % (self.video_src, GL_CAPS) )
        self._camerasink = self._pipeline.get_by_name('camerasink')
        self._camerasink.connect('new-buffer', self._gst_new_buffer)
        self._decodebin = self._pipeline.get_by_name('decoder')

        if self._camerasink and not self.stopped:
            self.start()

    def _gst_new_buffer(self, *largs):
        self._format = GL_RGB
        frame = self._camerasink.emit('pull-buffer')
        if frame is None:
            return
        self._buffer = frame.data
        if self._texturesize is None:
            # try to get the camera image size
            for x in self._decodebin.src_pads():
                for cap in x.get_caps():
                    self._texturesize = (cap['width'], cap['height'])
                    return

    def start(self):
        self.stopped = False
        self._pipeline.set_state(gst.STATE_PLAYING)

    def stop(self):
        self.stopped = True
        self._pipeline.set_state(gst.STATE_PAUSED)

    def update(self):
        if self._buffer is None:
            return
        self._copy_to_gpu()
        if self._texture is None and self._texturesize is not None:
            w, h = self._texturesize
            self._texture = pymt.Texture.create(w, h, format=GL_RGB)
            self._texture.flip_vertical()

########NEW FILE########
__FILENAME__ = camera_opencv
'''
OpenCV Camera: Implement CameraBase with OpenCV
'''

#
# TODO: make usage of thread or multiprocess
#

__all__ = ('CameraOpenCV', )

import pymt
from . import CameraBase
from OpenGL.GL import GL_BGR_EXT

try:
    import opencv as cv
    import opencv.highgui as hg
except:
    raise

class CameraOpenCV(CameraBase):
    '''Implementation of CameraBase using OpenCV

    :Parameters:
        `video_src` : int, default is 0
            Index of OpenCV camera to use (0 mean default camera)
    '''

    def __init__(self, **kwargs):
        # override the default source of video
        kwargs.setdefault('video_src', 0)

        self._device = None

        super(CameraOpenCV, self).__init__(**kwargs)

    def init_camera(self):
        # create the device
        self._device = hg.cvCreateCameraCapture(self.video_src)

        try:
            # try first to set resolution
            cv.hg(self._device, cv.CV_CAP_PROP_FRAME_WIDTH,
                              self.resolution[0])
            cv.hg(self._device, cv.CV_CAP_PROP_FRAME_HEIGHT,
                              self.resolution[1])

            # and get frame to check if it's ok
            frame  = hg.cvQueryFrame(self._device)
            if not int(frame.width) == self.resolution[0]:
                raise Exception('OpenCV: Resolution not supported')

        except:
            # error while setting resolution
            # fallback on default one
            w = int(hg.cvGetCaptureProperty(self._device,
                    hg.CV_CAP_PROP_FRAME_WIDTH))
            h = int(hg.cvGetCaptureProperty(self._device,
                    hg.CV_CAP_PROP_FRAME_HEIGHT))
            frame  = hg.cvQueryFrame(self._device)
            pymt.pymt_logger.warning(
                'OpenCV: Camera resolution %s not possible! Defaulting to %s.' %
                (self.resolution, (w, h)))

            # set resolution to default one
            self._resolution = (w, h)

        # create texture !
        self._texture = pymt.Texture.create(*self._resolution)
        self._texture.flip_vertical()

        if not self.stopped:
            self.start()

    def update(self):
        if self.stopped:
            return
        try:
            frame = hg.cvQueryFrame(self._device)
            self._format = GL_BGR_EXT
            self._buffer = frame.imageData
            self._copy_to_gpu()
        except:
            pymt.pymt_logger.exception('OpenCV: Couldn\'t get image from Camera')


########NEW FILE########
__FILENAME__ = camera_videocapture
'''
VideoCapture Camera: Implement CameraBase with VideoCapture
'''

#
# TODO: make usage of thread or multiprocess
#

__all__ = ('CameraVideoCapture', )

import pymt
from . import CameraBase
from OpenGL.GL import GL_BGR

try:
    from VideoCapture import Device
except:
    raise

class CameraVideoCapture(CameraBase):
    '''Implementation of CameraBase using VideoCapture

    :Parameters:
        `video_src` : int, default is 0
            Index of VideoCapture camera to use (0 mean default camera)
    '''

    def __init__(self, **kwargs):
        # override the default source of video
        kwargs.setdefault('video_src', 0)
        self._device = None
        super(CameraVideoCapture, self).__init__(**kwargs)
        self._format = GL_BGR

    def init_camera(self):
        # create the device
        self._device = Device(devnum=self.video_src, showVideoWindow=0)
        # set resolution
        try:
            self._device.setResolution(self.resolution[0], self.resolution[1])
        except:
            raise Exception('VideoCapture: Resolution not supported')

    def update(self):
        data, camera_width, camera_height = self._device.getBuffer()
        if self._texture is None:
            # first update, resize if necessary
            self.size = camera_width, camera_height
            # and create texture
            self._texture = pymt.Texture.create(camera_width, camera_height,
                                                format=GL_BGR)

        # update buffer
        self._buffer = data
        self._copy_to_gpu()

########NEW FILE########
__FILENAME__ = clipboard_dummy
'''
Clipboard Dummy: internal implementation without using system
'''

__all__ = ('ClipboardDummy', )

from . import ClipboardBase

class ClipboardDummy(ClipboardBase):
    def __init__(self):
        super(ClipboardDummy, self).__init__()
        self._data = dict()
        self._data['text/plain'] = None
        self._data['application/data'] = None

    def get(self, mimetype='text/plain'):
        return self._data.get(mimetype, None)

    def put(self, data, mimetype='text/plain'):
        self._data[mimetype] = data

    def get_types(self):
        return self._data.keys()


########NEW FILE########
__FILENAME__ = clipboard_pygame
'''
Clipboard Pygame: implementation of clipboard using pygame.scrap.
'''

__all__ = ('ClipboardPygame', )

import sys
from . import ClipboardBase

if sys.platform not in ('win32', 'cygwin'):
    raise SystemError('unsupported platform for pygame clipboard')

try:
    import pygame
    import pygame.scrap
except:
    raise

class ClipboardPygame(ClipboardBase):
    _is_init = False
    def init(self):
        if ClipboardPygame._is_init:
            return
        pygame.scrap.init()
        ClipboardPygame._is_init = True

    def get(self, mimetype='text/plain'):
        self.init()
        return pygame.scrap.get(mimetype)

    def put(self, data, mimetype='text/plain'):
        self.init()
        pygame.scrap.put(mimetype, data)

    def get_types(self):
        self.init()
        return pygame.scrap.get_types()


########NEW FILE########
__FILENAME__ = img_pil
'''
PIL: PIL image loader
'''

__all__ = ('ImageLoaderPIL', )

try:
    from PIL import Image
except:
    raise

import pymt
from . import ImageLoaderBase, ImageData, ImageLoader

# Use PIL to load image.
class ImageLoaderPIL(ImageLoaderBase):
    '''Image loader based on PIL library'''

    @staticmethod
    def extensions():
        '''Return accepted extension for this loader'''
        # retrieve from http://www.pythonware.com/library/pil/handbook/index.htm
        return ('bmp', 'bufr', 'cur', 'dcx', 'eps', 'fits', 'fl', 'fpx', 'gbr',
                'gd', 'gif', 'grib', 'hdf5', 'ico', 'im', 'imt', 'iptc', 'jpeg',
                'jpg', 'mcidas', 'mic', 'mpeg', 'msp', 'palm', 'pcd', 'pcx', 'pdf',
                'pixar', 'png', 'ppm', 'psd', 'sgi', 'spider', 'tga', 'tiff',
                'wal', 'wmf', 'xbm', 'xpm', 'xv')

    def load(self, filename):
        pymt.pymt_logger.debug('Image: Load <%s>' % filename)
        try:
            im = Image.open(filename)
        except:
            pymt.pymt_logger.warning('Image: Unable to load image <%s>' % filename)
            raise

        # image loader work only with rgb/rgba image
        if im.mode not in ('RGB', 'RGBA'):
            try:
                imc = im.convert('RGBA')
            except:
                pymt.pymt_logger.warning(
                    'Image: Unable to convert image <%s> to RGBA (was %s)' %
                    (filename, im.mode))
                raise
            im = imc

        # image are not in the good direction, flip !
        im = im.transpose(Image.FLIP_TOP_BOTTOM)

        # update internals
        self.filename = filename

        return ImageData(im.size[0], im.size[1],
            im.mode, im.tostring())

# register
ImageLoader.register(ImageLoaderPIL)

########NEW FILE########
__FILENAME__ = img_pygame
'''
Pygame: Pygame image loader
'''

__all__ = ('ImageLoaderPygame', )

import pymt
from . import ImageLoaderBase, ImageData, ImageLoader

try:
    import pygame
except:
    raise

class ImageLoaderPygame(ImageLoaderBase):
    '''Image loader based on PIL library'''

    @staticmethod
    def extensions():
        '''Return accepted extension for this loader'''
        # under macosx, i got with "pygame.error: File is not a Windows BMP
        # file". documentation said: The image module is a required dependency
        # of Pygame, but it only optionally supports any extended file formats.
        # By default it can only load uncompressed BMP image
        if pygame.image.get_extended() == 0:
            return ('bmp', )
        # retrieve from http://www.pygame.org/docs/ref/image.html
        return ('jpg', 'png', 'gif', 'bmp', 'pcx', 'tga', 'tiff', 'tif', 'lbm',
               'pbm', 'ppm', 'xpm')

    def load(self, filename):
        pymt.pymt_logger.debug('Image: Load <%s>' % filename)
        try:
            im = pygame.image.load(filename)
        except:
            pymt.pymt_logger.warning('Image: Unable to load image <%s>' % filename)
            raise

        mode = ''
        if im.get_bytesize() == 3:
            mode = 'RGB'
        elif im.get_bytesize() == 4:
            mode = 'RGBA'

        # image loader work only with rgb/rgba image
        if mode not in ('RGB', 'RGBA'):
            try:
                imc = im.convert(32)
                mode = 'RGBA'
            except:
                pymt.pymt_logger.warning(
                    'Image: Unable to convert image <%s> to RGBA (was %s)' %
                    filename, im.mode)
                raise
            im = imc

        # update internals
        self.filename = filename
        data = pygame.image.tostring(im, mode, True)
        return ImageData(im.get_width(), im.get_height(),
            mode, data)


# register
ImageLoader.register(ImageLoaderPygame)

########NEW FILE########
__FILENAME__ = spelling_enchant
'''
Enchant Spelling: Implements spelling backend based on enchant.
'''


import enchant

from pymt.core.spelling import SpellingBase, NoSuchLangError


class SpellingEnchant(SpellingBase):
    '''
    Spelling backend based on the enchant library.
    '''
    def __init__(self, language=None):
        self._language = None
        super(SpellingEnchant, self).__init__(language)

    def select_language(self, language):
        try:
            self._language = enchant.Dict(language)
        except enchant.DictNotFoundError:
            raise NoSuchLangError('No language for "%s" provided by the enchant ' % (language, ) + \
                                  'backend')

    def list_languages(self):
        # Note: We do NOT return enchant.list_dicts because that also returns
        #       the enchant dict objects and not only the language identifiers.
        return enchant.list_languages()

    def check(self, word):
        if not word:
            return None
        return self._language.check(word)

    def suggest(self, fragment):
        suggestions = self._language.suggest(fragment)
        # Don't show suggestions that are invalid
        suggestions = [s.decode('utf-8') for s in suggestions if self.check(s)]
        return suggestions


########NEW FILE########
__FILENAME__ = spelling_osxappkit
'''
AppKit Spelling: Implements spelling backend based on OSX's spellchecking
                 features provided by the ApplicationKit.

                 NOTE:
                    Requires pyobjc and setuptools to be installed!
                    `sudo easy_install pyobjc setuptools`

                 Developers should read:
                    http://developer.apple.com/mac/library/documentation/Cocoa/Conceptual/SpellCheck/SpellCheck.html
                    http://developer.apple.com/cocoa/pyobjc.html
'''


from AppKit import NSSpellChecker, NSMakeRange

from pymt.core.spelling import SpellingBase, NoSuchLangError


class SpellingOSXAppKit(SpellingBase):
    '''
    Spelling backend based on OSX's spelling features provided by AppKit.
    '''
    def __init__(self, language=None):
        self._language = NSSpellChecker.alloc().init()
        super(SpellingOSXAppKit, self).__init__(language)

    def select_language(self, language):
        success = self._language.setLanguage_(language)
        if not success:
            raise NoSuchLangError('No language for "%s" provided by the OSX ' % (language, ) + \
                                  'AppKit backend.')

    def list_languages(self):
        return list(self._language.availableLanguages())

    def check(self, word):
        # TODO Implement this!
        #      NSSpellChecker provides several functions that look like what we
        #      need, but they're a) slooow and b) return a strange result. Might
        #      be a snow leopard bug. Have to test further.
        #      See: http://paste.pocoo.org/show/217968/
        if not word:
            return None
        raise NotImplementedError('check() not currently supported by the OSX AppKit backend')

    def suggest(self, fragment):
        l = self._language
        # XXX Both ways below work on OSX 10.6. It has not been tested on any
        #     other version, but it should work.
        try:
            # This is deprecated as of OSX 10.6, hence the try-except
            return list(l.guessesForWord_(fragment))
        except AttributeError:
            # From 10.6 onwards you're supposed to do it like this:
            checkrange = NSMakeRange(0, len(fragment))
            guesses = l.guessesForWordRange_inString_language_inSpellDocumentWithTag_(
                        checkrange, fragment, l.language(), 0)
            # Right, this was much easier, Apple! :-)
            return list(guesses)


########NEW FILE########
__FILENAME__ = svg_squirtle
'''
SVG: Squirtle SVG image loader
'''

__all__ = ('SvgLoaderSquirtle', )

import pymt
from pymt.core.svg import SvgBase, SvgLoader
from pymt.lib import squirtle

class SvgSquirtle(SvgBase):
    '''Svg loader based on squirtle library'''

    @staticmethod
    def extensions():
        '''Return accepted extension for this loader'''
        return ('svg',)

    def load(self, filename):
        '''loads a squirtle svg object from teh filename'''
        pymt.pymt_logger.debug('SVG: Load <%s>' % filename)
        try:
            svg = squirtle.SVG(filename)
        except:
            pymt.pymt_logger.warning('SVG: Unable to load SVG file <%s>' %
                                     filename)
            raise
        return svg

    def draw(self):
        self.svg_data.draw(0, 0)

# register
SvgLoader.register(SvgSquirtle)


########NEW FILE########
__FILENAME__ = markup
'''
MarkupLabel: Handle drawing of text with markup
'''

__all__ = ('MarkupLabel', )

import pymt
from pymt.parser import parse_color
from pymt.logger import pymt_logger
import re
from . import Label, LabelBase

# We need to do this trick when documentation is generated
MarkupLabelBase = Label
if Label is None:
    MarkupLabelBase = LabelBase

class MarkupLabel(MarkupLabelBase):
    '''Markup text label.

    Markup is defined as tag with []. Example of markup text :

        [b]Hello [color=ff0000]world[/b][/color]

    Available markups tags :
        * [b][/b] : bold
        * [i][/i] : italic
        * [font=<str>][/font] : font name
        * [size=<integer>][/size] : size
        * [color=#<color>][/color] : text color
    '''
    def __init__(self, *largs, **kwargs):
        self._style_stack = {}
        super(MarkupLabel, self).__init__(*largs, **kwargs)

    @property
    def markup(self):
        s = re.split('(\[.*?\])', self.label)
        s = [x for x in s if x != '']
        return s

    def _push_style(self, k):
        if not k in self._style_stack:
            self._style_stack[k] = []
        self._style_stack[k].append(self.options[k])

    def _pop_style(self, k):
        if len(self._style_stack[k]) == 0:
            pymt_logger.warning('Label: pop style stack without push')
            return
        v = self._style_stack[k].pop()
        self.options[k] = v

    def render(self, real=False):
        w, h = 0, 0
        x, y = 0, 0
        lw, lh = 0, 0
        nl = False
        if real:
            self._render_begin()

        for item in self.markup:
            if item == '[b]':
                self._push_style('bold')
                self.options['bold'] = True
            elif item == '[/b]':
                self._pop_style('bold')
            elif item == '[i]':
                self._push_style('italic')
                self.options['italic'] = True
            elif item == '[/i]':
                self._pop_style('italic')
            elif item.startswith('[size='):
                size = int(item[6:-1])
                self._push_style('font_size')
                self.options['font_size'] = size
            elif item == '[/size]':
                self._pop_style('font_size')
            elif item.startswith('[color='):
                color = parse_color(item[7:-1])
                self._push_style('color')
                self.options['color'] = color
            elif item == '[/color]':
                self._pop_style('color')
            elif item.startswith('[font='):
                fontname = item[6:-1]
                self._push_style('font_name')
                self.options['font_name'] = fontname
            elif item == '[/font]':
                self._pop_style('font_name')
            else:
                args = x, y, w, h, lw, lh, nl
                args = self.render_label(real, item, args)
                x, y, w, h, lw, lh, nl = args

        if not real:
            # was only the first pass
            # return with/height
            w = int(max(w, 1))
            h = int(max(h, 1))
            return w, h

        # get data from provider
        data = self._render_end()
        assert(data)

        # create texture is necessary
        if self.texture is None:
            self.texture = pymt.Texture.create(*self.size)
            self.texture.flip_vertical()
        elif self.width > self.texture.width or self.height > self.texture.height:
            self.texture = pymt.Texture.create(*self.size)
            self.texture.flip_vertical()
        else:
            self.texture = self.texture.get_region(0, 0, self.width, self.height)

        # update texture
        self.texture.blit_data(data)

    def render_label(self, real, label, args):
        x, y, w, h, lw, lh, nl = args
        uw, uh = self.usersize

        # precalculate id/name
        if not self.fontid in self._cache_glyphs:
            self._cache_glyphs[self.fontid] = {}
        cache = self._cache_glyphs[self.fontid]

        if not real:
            # verify that each glyph have size
            glyphs = list(set(label))
            for glyph in glyphs:
                if not glyph in cache:
                    cache[glyph] = self.get_extents(glyph)

        # first, split lines
        glyphs = []
        lines = []
        _x, _y = x, y
        for word in re.split(r'( |\n)', label):

            if word == '':
                continue

            # calculate the word width
            ww, wh = 0, 0
            for glyph in word:
                gw, gh = cache[glyph]
                ww += gw
                wh = max(gh, wh)

            # is the word fit on the uw ?
            if ww > uw:
                lines.append(((ww, wh), word))
                lw = lh = x = 0
                continue

            # get the maximum height for this line
            lh = max(wh, lh)

            # is the word fit on the line ?
            if (word == '\n' or x + ww > uw) and lw != 0:

                # no, push actuals glyph
                lines.append(((lw, lh), glyphs))
                glyphs = []

                # reset size
                lw = lh = x = 0

                # new line ? don't render
                if word == '\n':
                    continue

            # advance the width
            lw += ww
            x  += ww
            lh = max(wh, lh)
            glyphs += list(word)

        # got some char left ?
        if lw != 0:
            lines.append(((lw, lh), glyphs))

        if not real:
            h = sum([size[1] for size, glyphs in lines])
            w = uw
        else:
            # really render now.
            x, y = _x, _y
            for i in xrange(len(lines)):
                size, glyphs = lines[i]
                for glyph in glyphs:
                    lw, lh = cache[glyph]
                    self._render_text(glyph, x, y)
                    x += lw
                if i < len(lines) - 1:
                    y += size[1]
                    x = 0

        return (x, y, w, h, lw, lh, nl)


########NEW FILE########
__FILENAME__ = text_cairo
'''
Text Cairo: Draw text with cairo
'''

__all__ = ('LabelCairo', )

import pymt
from . import LabelBase

try:
    import cairo
except:
    raise

FONT_EXTENTS_ASCENT_IDX         = 0
FONT_EXTENTS_DESCENT_IDX        = 1
FONT_EXTENTS_HEIGHT_IDX         = 2
FONT_EXTENTS_MAX_X_ADVANCE_IDX  = 3
FONT_EXTENTS_MAX_Y_ADVANCE_IDX  = 4

TEXT_EXTENTS_X_BEARING_IDX      = 0
TEXT_EXTENTS_Y_BEARING_IDX      = 1
TEXT_EXTENTS_WIDTH_IDX          = 2
TEXT_EXTENTS_HEIGHT_IDX         = 3
TEXT_EXTENTS_X_ADVANCE_IDX      = 4
TEXT_EXTENTS_Y_ADVANCE_IDX      = 5

# used for fetching extends before creature image surface
cairo_default_surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)
cairo_default_context = cairo.Context(cairo_default_surface)

class LabelCairo(LabelBase):
    def _select_font(self, context):
        italic = cairo.FONT_SLANT_NORMAL
        bold = cairo.FONT_WEIGHT_NORMAL
        fontsize = self.options['font_size'] * 1.333
        fontname = self.options['font_name'].split(',')[0]
        if self.options['bold']:
            bold = cairo.FONT_WEIGHT_BOLD
        if self.options['italic']:
            italic = cairo.FONT_SLANT_ITALIC

        context.select_font_face(fontname, italic, bold)
        context.set_font_size(fontsize)
        font_options = context.get_font_options()
        font_options.set_hint_style(cairo.HINT_STYLE_FULL)
        context.set_font_options(font_options)

        # get maximum height for font
        font_extents = context.font_extents()
        self._font_extents = font_extents
        self._height = \
            self._font_extents[FONT_EXTENTS_DESCENT_IDX] + \
            self._font_extents[FONT_EXTENTS_ASCENT_IDX]

    def get_extents(self, text):
        self._select_font(cairo_default_context)
        extents = cairo_default_context.text_extents(text)
        return (extents[4], self._height)

    def _render_begin(self):
        # create a surface, context, font...
        self._cairo_surface = cairo.ImageSurface(
                cairo.FORMAT_ARGB32, *self.size)
        self._cairo_context = cairo.Context(self._cairo_surface)

        self._select_font(self._cairo_context)

    def _render_text(self, text, x, y):
        color = map(lambda x: x * 255, self.options['color'])
        self._cairo_context.set_source_rgba(*color)
        self._cairo_context.move_to(x,
            y + self._font_extents[FONT_EXTENTS_ASCENT_IDX])
        self._cairo_context.show_text(text)

    def _render_end(self):
        data = pymt.ImageData(self.width, self.height,
            'RGBA', buffer(self._cairo_surface.get_data())[:])

        del self._cairo_surface
        del self._cairo_context

        return data

########NEW FILE########
__FILENAME__ = text_pil
'''
Text PIL: Draw text with PIL
'''

__all__ = ('LabelPIL', )

try:
    from PIL import Image, ImageFont, ImageDraw
except:
    raise

import pymt
import os
from . import LabelBase

# used for fetching extends before creature image surface
default_font = ImageFont.load_default()

class LabelPIL(LabelBase):
    _cache = {}
    def _select_font(self):
        fontsize = int(self.options['font_size'] * 1.333)
        fontname = self.options['font_name'].split(',')[0]
        id = '%s.%s' % (unicode(fontname), unicode(fontsize))
        if not id in self._cache:
            filename = os.path.join(pymt.pymt_data_dir, 'DejaVuSans.ttf')
            font = ImageFont.truetype(filename, fontsize)
            self._cache[id] = font

        return self._cache[id]

    def get_extents(self, text):
        font = self._select_font()
        w, h = font.getsize(text)
        return w, h

    def _render_begin(self):
        # create a surface, context, font...
        self._pil_im = Image.new('RGBA', self.size)
        self._pil_draw = ImageDraw.Draw(self._pil_im)

    def _render_text(self, text, x, y):
        color = tuple(map(lambda x: int(x * 255), self.options['color']))
        self._pil_draw.text((int(x), int(y)), text, font=self._select_font(), fill=color)

    def _render_end(self):
        data = pymt.ImageData(self.width, self.height,
            self._pil_im.mode, self._pil_im.tostring())

        del self._pil_im
        del self._pil_draw

        return data

########NEW FILE########
__FILENAME__ = text_pygame
'''
Text Pygame: Draw text with pygame
'''

__all__ = ('LabelPygame', )

import pymt
from . import LabelBase

try:
    import pygame
except:
    raise

pygame_cache = {}

# init pygame font
pygame.font.init()

class LabelPygame(LabelBase):
    def _get_font_id(self):
        return '|'.join([unicode(self.options[x]) for x \
            in ('font_size', 'font_name', 'bold', 'italic')])

    def _get_font(self):
        id = self._get_font_id()
        if id not in pygame_cache:
            # try first the file if it's a filename
            fontobject = None
            fontname = self.options['font_name']
            ext = fontname.split('.')[-1]
            if ext.lower() == 'ttf':
                # fontobject
                fontobject = pygame.font.Font(fontname,
                                int(self.options['font_size'] * 1.333))

            # fallback to search a system font
            if fontobject is None:
                # try to search the font
                font = pygame.font.match_font(
                    self.options['font_name'].replace(' ', ''),
                    bold=self.options['bold'],
                    italic=self.options['italic'])

                # fontobject
                fontobject = pygame.font.Font(font,
                                int(self.options['font_size'] * 1.333))
            pygame_cache[id] = fontobject

        return pygame_cache[id]

    def get_extents(self, text):
        font = self._get_font()
        w, h = font.size(text)
        return w, h

    def _render_begin(self):
        self._pygame_surface = pygame.Surface(self.size, pygame.SRCALPHA, 32)
        self._pygame_surface.fill((0, 0, 0, 0))

    def _render_text(self, text, x, y):
        font = self._get_font()
        color = [min(255, c * 255) for c in self.options['color']]
        color = color[2], color[1], color[0]
        text = font.render(text, 1, color)
        self._pygame_surface.blit(text, (x, y), None, pygame.BLEND_RGBA_ADD)

    def _render_end(self):
        data = pymt.ImageData(self.width, self.height,
            'RGBA', buffer(self._pygame_surface.get_buffer())[:])

        del self._pygame_surface

        return data

########NEW FILE########
__FILENAME__ = video_gstreamer
'''
VideoGStreamer: implementation of VideoBase with GStreamer
'''

try:
    import pygst
    if not hasattr(pygst, '_gst_already_checked'):
        pygst.require('0.10')
        pygst._gst_already_checked = True
    import gst
except:
    raise

import threading
import pymt
from . import VideoBase
from pymt.graphx import drawTexturedRectangle, set_color, drawRectangle
from OpenGL.GL import GL_RGB
from gst.extend import discoverer

# install the gobject iteration
from pymt.support import install_gobject_iteration
install_gobject_iteration()

class VideoGStreamer(VideoBase):
    '''VideoBase implementation using GStreamer (http://gstreamer.freedesktop.org/)
    '''

    __slots__ = ('_pipeline', '_decoder', '_videosink', '_colorspace',
                 '_videosize', '_buffer_lock', '_audiosink', '_volumesink',
                 '_is_audio', '_is_video', '_do_load', '_pipeline_canplay')

    def __init__(self, **kwargs):
        self._pipeline      = None
        self._decoder       = None
        self._videosink     = None
        self._colorspace    = None
        self._audiosink     = None
        self._volumesink    = None
        self._is_audio      = None
        self._is_video      = None
        self._do_load       = None
        self._pipeline_canplay = False
        self._buffer_lock   = threading.Lock()
        self._videosize     = (0, 0)
        super(VideoGStreamer, self).__init__(**kwargs)

    def _do_eos(self):
        # reset to start for next play
        self._pipeline.seek_simple(
            gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH, 0)
        self.dispatch_event('on_eos')
        super(VideoGStreamer, self)._do_eos()

    def stop(self):
        self._wantplay = False
        if self._pipeline is None:
            return
        self._pipeline.set_state(gst.STATE_PAUSED)
        self._state = ''
        super(VideoGStreamer, self).stop()

    def play(self):
        self._wantplay = True
        if self._pipeline is None:
            return
        self._pipeline.set_state(gst.STATE_PAUSED)
        super(VideoGStreamer, self).play()
        self._state = ''

    def unload(self):
        if self._pipeline is None:
            return
        self._pipeline.set_state(gst.STATE_NULL)
        self._pipeline.get_state() # block until the null is ok
        self._pipeline      = None
        self._decoder       = None
        self._videosink     = None
        self._texture       = None
        self._audiosink     = None
        self._volumesink    = None
        self._is_audio      = None
        self._is_video      = None
        self._do_load       = None
        self._pipeline_canplay = False
        self._state         = ''

    def load(self):
        # ensure that nothing is loaded before.
        self.unload()

        def discovered(d, is_media):
            self._is_audio = d.is_audio
            self._is_video = d.is_video
            self._do_load  = True

        # discover the media
        d = discoverer.Discoverer(self._filename)
        d.connect('discovered', discovered)
        d.discover()

    def _on_gst_message(self, bus, message):
        if message.type == gst.MESSAGE_ASYNC_DONE:
            self._pipeline_canplay = True
        elif message.type == gst.MESSAGE_EOS:
            self._do_eos()

    def _really_load(self):
        # create the pipeline
        self._pipeline = gst.Pipeline()

        # create bus
        bus = self._pipeline.get_bus()
        bus.add_signal_watch()
        bus.enable_sync_message_emission()
        bus.connect('message', self._on_gst_message)

        # hardcoded to check which decoder is better
        if self._filename.split(':')[0] in ('http', 'https', 'file'):
            # network decoder
            self._decoder = gst.element_factory_make('uridecodebin', 'decoder')
            self._decoder.set_property('uri', self._filename)
            self._decoder.connect('pad-added', self._gst_new_pad)
            self._pipeline.add(self._decoder)
        else:
            # local decoder
            filesrc = gst.element_factory_make('filesrc')
            filesrc.set_property('location', self._filename)
            self._decoder = gst.element_factory_make('decodebin', 'decoder')
            self._decoder.connect('new-decoded-pad', self._gst_new_pad)
            self._pipeline.add(filesrc, self._decoder)
            gst.element_link_many(filesrc, self._decoder)

        # create colospace information
        self._colorspace = gst.element_factory_make('ffmpegcolorspace')

        # will extract video/audio
        caps_str = 'video/x-raw-rgb,red_mask=(int)0xff0000,green_mask=(int)0x00ff00,blue_mask=(int)0x0000ff'
        caps = gst.Caps(caps_str)
        self._videosink = gst.element_factory_make('appsink', 'videosink')
        self._videosink.set_property('emit-signals', True)
        self._videosink.set_property('caps', caps)
        self._videosink.set_property('drop', True)
        self._videosink.set_property('render-delay', 1000000000)
        self._videosink.set_property('max-lateness', 1000000000)
        self._videosink.connect('new-buffer', self._gst_new_buffer)
        self._audiosink = gst.element_factory_make('autoaudiosink', 'audiosink')
        self._volumesink = gst.element_factory_make('volume', 'volume')

        # connect colorspace -> appsink
        if self._is_video:
            self._pipeline.add(self._colorspace, self._videosink)
            gst.element_link_many(self._colorspace, self._videosink)

        if self._is_audio:
            self._pipeline.add(self._audiosink, self._volumesink)
            gst.element_link_many(self._volumesink, self._audiosink)

        # set to paused, for loading the file, and get the size information.
        self._pipeline.set_state(gst.STATE_PAUSED)

        # be sync if asked
        if self._async == False:
            self._pipeline.get_state()

    def seek(self, percent):
        if not self._pipeline:
            return
        self._pipeline.seek_simple(
            gst.FORMAT_PERCENT,
            gst.SEEK_FLAG_FLUSH,
            percent)

    def _gst_new_pad(self, dbin, pad, *largs):
        # a new pad from decoder ?
        # if it's a video, connect decoder -> colorspace
        c = pad.get_caps().to_string()
        try:
            if c.startswith('video'):
                dbin.link(self._colorspace)
            elif c.startswith('audio'):
                dbin.link(self._volumesink)
        except:
            pass

    def _gst_new_buffer(self, appsink):
        # new buffer is comming, pull it.
        with self._buffer_lock:
            self._buffer = appsink.emit('pull-buffer')

    def _get_position(self):
        if self._videosink is None:
            return 0
        try:
            return self._videosink.query_position(gst.FORMAT_TIME)[0] / 1000000000.
        except:
            return 0

    def _get_duration(self):
        if self._videosink is None:
            return 0
        try:
            return self._videosink.query_duration(gst.FORMAT_TIME)[0] / 1000000000.
        except:
            return 0

    def _get_volume(self):
        if self._audiosink is not None:
            self._volume = self._volumesink.get_property('volume')
        else:
            self._volume = 1.
        return self._volume

    def _set_volume(self, volume):
        if self._audiosink is not None:
            self._volumesink.set_property('volume', volume)
            self._volume = volume

    def update(self):
        if self._do_load:
            self._really_load()
            self._do_load = False

        # no video sink ?
        if self._videosink is None:
            return

        # get size information first to create the texture
        if self._texture is None:
            for i in self._decoder.src_pads():
                cap = i.get_caps()[0]
                structure_name = cap.get_name()
                if structure_name.startswith('video') and cap.has_key('width'):
                    self._videosize = self.size = (cap['width'], cap['height'])
                    self._texture = pymt.Texture.create(
                        self._videosize[0], self._videosize[1], format=GL_RGB)
                    self._texture.flip_vertical()

        # no texture again ?
        if self._texture is None:
            return

        # ok, we got a texture, user want play ?
        if self._wantplay and self._pipeline_canplay:
            self._pipeline.set_state(gst.STATE_PLAYING)
            self._state = 'playing'
            self._wantplay = False

        # update needed ?
        with self._buffer_lock:
            if self._buffer is not None:
                self._texture.blit_buffer(self._buffer.data,
                                          size=self._videosize,
                                          format=GL_RGB)
                self._buffer = None

    def draw(self):
        if self._texture:
            set_color(*self.color)
            drawTexturedRectangle(texture=self._texture, pos=self.pos, size=self.size)
        else:
            set_color(0, 0, 0)
            drawRectangle(pos=self.pos, size=self.size)

########NEW FILE########
__FILENAME__ = video_pyglet

'''
VideoPyglet: implementation of VideoBase with Pyglet
'''

try:
    import pyglet
except:
    raise

import pymt
from OpenGL.GL import glDisable, GL_BLEND
from . import VideoBase


#have to set these before importing pyglet.gl
#otherwise pyglet creates a seperate gl context and fails on error checks becasue we use pygame window
pyglet.options['shadow_window'] = False
pyglet.options['debug_gl'] = False
import pyglet.gl

#another pyglet fix, because pyglet has a bugfix which is a bad hacked,
#it checks for context._workaround_unpack_row_length..but we're using the implicit context form pyglet or glut window
#this means we cant have a pyglet window provider though! if we do, this will break pyglet window context
class FakePygletContext:
    _workaround_unpack_row_length = False
pyglet.gl.current_context = FakePygletContext()





class VideoPyglet(VideoBase):
    '''VideoBase implementation using Pyglet
    '''

    def unload(self):
        self.player = None
        self._source = None
        self._fbo = None

    def load(self):
        self.unload() #make sure we unload an resources

        #load media file and set size of video
        self._source = source = pyglet.media.load(self._filename)
        self._format = self._source.video_format
        self.size = (self._format.width, self._format.height)

        #load pyglet player and have it play teh video we loaded
        self._player = None
        self._player = pyglet.media.Player()
        self._player.queue(self._source)
        self.play()
        self.stop()

        #we have to keep track of tie ourselves..at least its the only way i can get pyglet player to restart,
        #_player.time does not get reset when you do seek(0) for soe reason, and is read only
        self.time = self._player.time

    def update(self):
        if self._source.duration  - self.time < 0.1 : #we are at the end
            self.seek(0)
        if self.state == 'playing':
            self.time += pymt.getFrameDt() #keep track of time into video
            self._player.dispatch_events(pymt.getFrameDt()) #required by pyglet video if not in pyglet window

    def stop(self):
        self._player.pause()
        super(VideoPyglet, self).stop()

    def play(self):
        self._player.play()
        super(VideoPyglet, self).play()

    def seek(self, percent):
        t = self._source.duration*percent
        self.time = t
        self._player.seek(t)
        self.stop()

    def _get_position(self):
        if self._player:
            return self.time

    def _get_duration(self):
        if self._source:
            return self._source.duration

    def _get_volume(self):
        if self._player:
            return self._player.volume
        return 0

    def _set_volume(self, volume):
        if self._player:
            self._player.volume = volume

    def draw(self):
        if self._player.get_texture():
            glDisable(GL_BLEND) #dont know why this is needed...but it gets very dark otherwise, even if i set color
            self._player.get_texture().blit(*self.pos)



########NEW FILE########
__FILENAME__ = event
'''Event: Event dispatch framework.

All objects that produce events in pyglet implement `EventDispatcher`,
providing a consistent interface for registering and manipulating event
handlers.  A commonly used event dispatcher is `pyglet.window.Window`.

Event types
===========

For each event dispatcher there is a set of events that it dispatches; these
correspond with the type of event handlers you can attach.  Event types are
identified by their name, for example, ''on_resize''.  If you are creating a
new class which implements `EventDispatcher`, you must call
`EventDispatcher.register_event_type` for each event type.

Attaching event handlers
========================

An event handler is simply a function or method.  You can attach an event
handler by setting the appropriate function on the instance::

    def on_resize(width, height):
        # ...
    dispatcher.on_resize = on_resize

There is also a convenience decorator that reduces typing::

    @dispatcher.event
    def on_resize(width, height):
        # ...

You may prefer to subclass and override the event handlers instead::

    class MyDispatcher(DispatcherClass):
        def on_resize(self, width, height):
            # ...

Event handler stack
===================

When attaching an event handler to a dispatcher using the above methods, it
replaces any existing handler (causing the original handler to no longer be
called).  Each dispatcher maintains a stack of event handlers, allowing you to
insert an event handler "above" the existing one rather than replacing it.

There are two main use cases for "pushing" event handlers:

* Temporarily intercepting the events coming from the dispatcher by pushing a
  custom set of handlers onto the dispatcher, then later "popping" them all
  off at once.
* Creating "chains" of event handlers, where the event propogates from the
  top-most (most recently added) handler to the bottom, until a handler
  takes care of it.

Use `EventDispatcher.push_handlers` to create a new level in the stack and
attach handlers to it.  You can push several handlers at once::

    dispatcher.push_handlers(on_resize, on_key_press)

If your function handlers have different names to the events they handle, use
keyword arguments::

    dispatcher.push_handlers(on_resize=my_resize,
                             on_key_press=my_key_press)

After an event handler has processed an event, it is passed on to the
next-lowest event handler, unless the handler returns `EVENT_HANDLED`, which
prevents further propogation.

To remove all handlers on the top stack level, use
`EventDispatcher.pop_handlers`.

Note that any handlers pushed onto the stack have precedence over the
handlers set directly on the instance (for example, using the methods
described in the previous section), regardless of when they were set.
For example, handler ``foo`` is called before handler ``bar`` in the following
example::

    dispatcher.push_handlers(on_resize=foo)
    dispatcher.on_resize = bar

Dispatching events
==================

pyglet uses a single-threaded model for all application code.  Event
handlers are only ever invoked as a result of calling
EventDispatcher.dispatch_events`.

It is up to the specific event dispatcher to queue relevant events until they
can be dispatched, at which point the handlers are called in the order the
events were originally generated.

This implies that your application runs with a main loop that continously
updates the application state and checks for new events::

    while True:
        dispatcher.dispatch_events()
        # ... additional per-frame processing

Not all event dispatchers require the call to ``dispatch_events``; check with
the particular class documentation.

'''
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
#
# Note: this class is not comming from pyglet, but heavily copy/pasted
# handlers management at start of coding.
# Lot of kudos to Alex Holkner !
#

__all__ = ('EventDispatcher', )

import inspect
import types
from pymt.weakmethod import WeakMethod
from pymt.baseobject import BaseObject
from pymt.logger import pymt_logger

class EventDispatcher(BaseObject):
    '''Generic event dispatcher interface.

    See the module docstring for usage.
    '''

    __slots__ = ('_event_types', '_event_stack')

    def __init__(self, **kwargs):
        super(EventDispatcher, self).__init__(**kwargs)
        self._event_types = []
        self._event_stack = None

    @property
    def event_types(self):
        '''List of event types available'''
        return self._event_types

    def unregister_event_type(self, event_type):
        '''Remove an event types from the available list'''
        if event_type in self._event_types:
            self._event_types.remove(event_type)

    def register_event_type(self, event_type):
        '''Register an event type with the dispatcher.

        Registering event types allows the dispatcher to validate event
        handler names as they are attached, and to search attached objects for
        suitable handlers.

        :Parameters:
            `name` : str
                Name of the event to register.

        '''
        if not hasattr(self, event_type):
            raise Exception('Missing default handler <%s> in <%s>' % (
                            event_type, self.__class__.__name__))
        if not event_type in self._event_types:
            self._event_types.append(event_type)

    def push_handlers(self, *args, **kwargs):
        '''Push a level onto the top of the handler stack, then attach zero or
        more event handlers.

        If keyword arguments are given, they name the event type to attach.
        Otherwise, a callable's `__name__` attribute will be used.  Any other
        object may also be specified, in which case it will be searched for
        callables with event names.
        '''
        # Create event stack if necessary
        if self._event_stack is None:
            self._event_stack = []

        # Place dict full of new handlers at beginning of stack
        self._event_stack.insert(0, {})
        self.set_handlers(*args, **kwargs)

    def remove_handler(self, name, handler):
        '''Remove a single event handler.

        The given event handler is removed from the first handler stack frame
        it appears in.  The handler must be the exact same callable as passed
        to `set_handler`, `set_handlers` or `push_handlers`; and the name
        must match the event type it is bound to.

        No error is raised if the event handler is not set.

        :Parameters:
            `name` : str
                Name of the event type to remove.
            `handler` : callable
                Event handler to remove.
        '''
        if self._event_stack is None:
            return
        for frame in self._event_stack:
            try:
                if frame[name]() == handler:
                    del frame[name]
                    break
            except KeyError:
                pass

    def remove_handlers(self, *args, **kwargs):
        '''Remove event handlers from the event stack.

        See `push_handlers` for the accepted argument types.  All handlers
        are removed from the first stack frame that contains any of the given
        handlers.  No error is raised if any handler does not appear in that
        frame, or if no stack frame contains any of the given handlers.

        If the stack frame is empty after removing the handlers, it is
        removed from the stack.  Note that this interferes with the expected
        symmetry of `push_handlers` and `pop_handlers`.
        '''
        handlers = list(self._get_handlers(args, kwargs))

        # Find the first stack frame containing any of the handlers
        def find_frame():
            if self._event_stack is None:
                return
            for frame in self._event_stack:
                for name, handler in handlers:
                    try:
                        if frame[name]() == handler:
                            return frame
                    except KeyError:
                        pass
        frame = find_frame()

        # No frame matched; no error.
        if not frame:
            return

        # Remove each handler from the frame.
        for name, handler in handlers:
            try:
                if frame[name]() == handler:
                    del frame[name]
            except KeyError:
                pass

    def _get_handlers(self, args, kwargs):
        '''Implement handler matching on arguments for set_handlers and
        remove_handlers.
        '''
        for obj in args:
            if inspect.isroutine(obj):
                # Single magically named function
                name = obj.__name__
                if name not in self._event_types:
                    raise Exception('Unknown event "%s"' % name)
                yield name, obj
            else:
                # Single instance with magically named methods
                for name in dir(obj):
                    if name in self._event_types:
                        yield name, getattr(obj, name)
        for name, handler in kwargs.iteritems():
            # Function for handling given event (no magic)
            if name not in self._event_types:
                raise Exception('Unknown event "%s"' % name)
            yield name, handler

    def set_handlers(self, *args, **kwargs):
        '''Attach one or more event handlers to the top level of the handler
        stack.

        See `push_handlers` for the accepted argument types.
        '''
        # Create event stack if necessary
        if self._event_stack is None:
            self._event_stack = [{}]

        for name, handler in self._get_handlers(args, kwargs):
            self.set_handler(name, handler)

    def set_handler(self, name, handler):
        '''Attach a single event handler.

        :Parameters:
            `name` : str
                Name of the event type to attach to.
            `handler` : callable
                Event handler to attach.

        '''
        # Create event stack if necessary
        if self._event_stack is None:
            self._event_stack = [{}]

        self._event_stack[0][name] = WeakMethod(handler)

    def dispatch_event(self, event_type, *args):
        '''Dispatch a single event to the attached handlers.

        The event is propogated to all handlers from from the top of the stack
        until one returns `EVENT_HANDLED`.  This method should be used only by
        `EventDispatcher` implementors; applications should call
        the ``dispatch_events`` method.

        :Parameters:
            `event_type` : str
                Name of the event.
            `args` : sequence
                Arguments to pass to the event handler.

        '''
        # unknown event type
        if event_type not in self._event_types:
            return

        # search handler stack for matching event handlers
        _event_stack = self._event_stack
        if _event_stack is not None:
            for frame in _event_stack:
                wkhandler = frame.get(event_type, None)
                if wkhandler is None:
                    continue
                handler = wkhandler()
                if handler is None:
                    del frame[wkhandler]
                    continue
                try:
                    if handler(*args):
                        return True
                except TypeError:
                    self._raise_dispatch_exception(event_type, args, handler)

        # a instance always have a event handler, don't check it with hasattr.
        try:
            # call event
            if getattr(self, event_type)(*args):
                return True
        except TypeError:
            self._raise_dispatch_exception(
                event_type, args, getattr(self, event_type))

    def _raise_dispatch_exception(self, event_type, args, handler):
        # A common problem in applications is having the wrong number of
        # arguments in an event handler.  This is caught as a TypeError in
        # dispatch_event but the error message is obfuscated.
        #
        # Here we check if there is indeed a mismatch in argument count,
        # and construct a more useful exception message if so.  If this method
        # doesn't find a problem with the number of arguments, the error
        # is re-raised as if we weren't here.

        if not hasattr(handler, 'im_func'):
            raise
        if not isinstance(handler.im_func, types.FunctionType):
            raise

        n_args = len(args)

        # Inspect the handler
        handler_args, handler_varargs, _, handler_defaults = \
            inspect.getargspec(handler)
        n_handler_args = len(handler_args)

        # Remove "self" arg from handler if it's a bound method
        if inspect.ismethod(handler) and handler.im_self:
            n_handler_args -= 1

        # Allow *args varargs to overspecify arguments
        if handler_varargs:
            n_handler_args = max(n_handler_args, n_args)

        # Allow default values to overspecify arguments
        if (n_handler_args > n_args and
            handler_defaults and
            n_handler_args - len(handler_defaults) <= n_args):
            n_handler_args = n_args

        if n_handler_args != n_args:
            if inspect.isfunction(handler) or inspect.ismethod(handler):
                descr = '%s at %s:%d' % (
                    handler.func_name,
                    handler.func_code.co_filename,
                    handler.func_code.co_firstlineno)
            else:
                descr = repr(handler)

            raise TypeError(
                '%s event was dispatched with %d arguments, but '
                'handler %s has an incompatible function signature' %
                (event_type, len(args), descr))
        else:
            raise

    def event(self, *args):
        """
        A convenience decorator for event handlers.

        There are two ways to use this decorator. The first is to bind onto a
        defined event method::

            @a.event
            def on_event(self, *args):
                # ...

        Optionally, it can pass the event type as an argument and bind to an
        arbitrary function provided that function has the correct parameters::

            @a.event('on_event')
            def foobar(self, *args):
                # ...

        """
        if len(args) == 0: # @a.event()
            def decorator(func):
                name = func.__name__
                self.set_handler(name, func)
                return func
            return decorator
        elif inspect.isroutine(args[0]): # @a.event
            func = args[0]
            name = func.__name__
            self.set_handler(name, func)
            return args[0]
        elif isinstance(args[0], basestring): # @a.event('on_event')
            name = args[0]
            def decorator(func):
                self.set_handler(name, func)
                return func
            return decorator

    def connect(self, p1, w2, p2=None, func=lambda x: x):
        '''Connect events to a widget property'''
        def lambda_connect(*largs):
            if type(p2) in (tuple, list):
                if len(largs) != len(p2):
                    pymt_logger.exception('Widget: cannot connect with'
                                          'different size')
                    raise
                for p in p2:
                    if p is None:
                        continue
                    w2.__setattr__(p, type(w2.__getattribute__(p))(
                        func(largs[p2.index(p)])))
            else:
                dtype = type(w2.__getattribute__(p2))
                try:
                    if len(largs) == 1:
                        w2.__setattr__(p2, dtype(func(*largs)))
                    else:
                        w2.__setattr__(p2, dtype(func(largs)))
                except Exception:
                    pymt_logger.exception('Widget: cannot connect with'
                                          'different size')
                    raise
        if p2 is None:
            self.push_handlers(**{p1: w2})
        else:
            self.push_handlers(**{p1: lambda_connect})

# install acceleration
try:
    from pymt.accelerate import accelerate
    if accelerate is not None:
        EventDispatcher.dispatch_event = types.MethodType(
            accelerate.eventdispatcher_dispatch_event, None, EventDispatcher)
except ImportError, e:
    pymt_logger.warning('Event: Unable to use accelerate module <%s>' % e)

########NEW FILE########
__FILENAME__ = exceptions
'''
Exception Manager: add/remove handler for exception in application
'''

__all__ = ('pymt_exception_manager', 'ExceptionHandler', 'ExceptionManager')

class ExceptionHandler:
    '''Base handler that catch exception in runTouchApp().
    You can derivate and use it like this ::

        class E(ExceptionHandler):
            def handle_exception(self, inst):
                pymt_logger.exception(inst)
                return ExceptionManager.PASS

        pymt_exception_manager.add_handler(E())

    All exceptions will be set to PASS, and loggued to console !
    '''
    def __init__(self):
        pass

    def handle_exception(self, exception):
        '''Handle one exception, default return ExceptionManager.STOP'''
        return ExceptionManager.RAISE

class ExceptionManager:
    '''ExceptionManager manage exceptions handlers.'''

    RAISE   = 0
    PASS    = 1

    def __init__(self):
        self.handlers = []
        self.policy = ExceptionManager.RAISE

    def add_handler(self, cls):
        '''Add a new exception handler in the stack'''
        if not cls in self.handlers:
            self.handlers.append(cls)

    def remove_handler(self, cls):
        '''Remove a exception handler from the stack'''
        if cls in self.handlers:
            self.handlers.remove(cls)

    def handle_exception(self, inst):
        '''Called when an exception happend in runTouchApp() main loop'''
        ret = self.policy
        for handler in self.handlers:
            r = handler.handle_exception(inst)
            if r == ExceptionManager.PASS:
                ret = r
        return ret

#: PyMT Exception Manager instance
pymt_exception_manager = ExceptionManager()

########NEW FILE########
__FILENAME__ = geometry
'''
Geometry: facilities functions for geometry calculations
'''
__all__ = ('circumcircle', 'minimum_bounding_circle')

from pymt.vector import Vector

def circumcircle(a, b, c):
    '''
    Computes the circumcircle of a triangel defined by a,b,c
    see: http://en.wikipedia.org/wiki/Circumscribed_circle#Circumscribed_circles_of_triangles
    
    :Parameters:
        `a` : iterable
            the 1. point of the triangle
        `b` : iterable
            the 2. point of the triangle
        `c` : iterable
            the 3. point of the triangle
        
    :Return:
        A Circle that defined the tuple :
            * The first element in the returned touple is the center (tuple x,y)
            * The second the radius (float)
    '''
    P = Vector(a[0], a[1])
    Q = Vector(b[0], b[1])
    R = Vector(c[0], c[1])

    mPQ = (P+Q)*.5
    mQR = (Q+R)*.5
    
    numer = -(-mPQ.y*R.y + mPQ.y*Q.y + mQR.y*R.y - mQR.y*Q.y \
              -mPQ.x*R.x + mPQ.x*Q.x + mQR.x*R.x - mQR.x*Q.x)
    denom =  (-Q.x*R.y + P.x*R.y - P.x*Q.y + Q.y*R.x - P.y*R.x + P.y*Q.x)
    
    t = numer/denom
    
    cx  = -t * (Q.y - P.y) + mPQ.x
    cy  =  t * (Q.x - P.x) + mPQ.y
    
    return ((cx, cy), (P - (cx, cy)).length())
    
    
def minimum_bounding_circle(points):
    '''
    Returns the minimum bounding circle for a set of points
    
    For a description of the problem being solved see http://en.wikipedia.org/wiki/Smallest_circle_problem
    The function uses Applet's Algorithm Algorithm, worst case teh runtime is O(h^3 *n), where h= number of points in teh convex hull of the set of points. But it runs in linear time in almost all real world cases.
    see: http://www.personal.kent.edu/~rmuhamma/Compgeometry/MyCG/CG-Applets/Center/centercli.htm
    
    :Parameters:
        `points` : iterable
            A list of points (2 tuple with x,y coordinates)

    :Return:
        A Circle that defined the tuple :
            * The first element in the returned touple is the center (tuple x,y)
            * The second the radius (float)
    '''
    points = [Vector(p[0], p[1]) for p in points]
    
    if len(points) == 1:
        return (points[0].x, points[0].y), 0.0
        
    if len(points) == 2:
        p1, p2 = points
        return (p1+p2)*.5, ((p1-p2)*.5).length()

    # determine a point P with the smallest y value
    P = min(points, key=lambda p:p.y)
    
    # find a point Q such that the angle of the line segment
    # PQ with the x axis is minimal
    def x_axis_angle(q):
        if q == P:
            return 1e10 # max val if teh same, to skip
        return abs( (q - P).angle((1, 0)) ) 
    Q = min(points, key=x_axis_angle)
    
    for p in points:
        # find R such that angle PRQ is minimal
        def angle_pq(r):
            if r in (P, Q):
                return 1e10 # max val if teh same, to skip
            return abs(  (r - P).angle(r - Q) )
        R = min(points, key=angle_pq)

        # check for case 1 (angle PRQ is obtuse), the circle is determined
        # by two points, P and Q. radius = |(P-Q)/2|, center = (P+Q)/2
        if angle_pq(R) > 90.0:
            return (P+Q)*.5, ((P-Q)*.5).length()
        
        # if angle RPQ is obtuse, make P = R, and try again
        if abs((R-P).angle(Q-P)) > 90:
            P = R
            continue
    
        # if angle PQR is obtuse, make Q = R, and try again
        if abs((P-Q).angle(R-Q)) > 90:
            Q = R
            continue
   
        # all angles were acute..we just need teh circle through the
        # two points furthest apart!
        break
    
    # find teh circumcenter for triangle given by P,Q,R
    return circumcircle(P, Q, R)
   
    

########NEW FILE########
__FILENAME__ = gesture
'''
Gesture: Base for gesture recognition.

You can easily use these class to create
new gesture, and compare them ! ::

    from pymt import *

    # Create a gesture
    g = Gesture()
    g.add_stroke(point_list=[(1,1), (3,4), (2,1)])
    g.normalize()

    # Add him to database
    gdb = GestureDatabase()
    gdb.add_gesture(g)

    # And for the next gesture, try to find him !
    g2 = Gesture()
    # ...
    gdb.find(g2)
'''

__all__ = ('Gesture', 'GestureDatabase', 'GesturePoint', 'GestureStroke')

import math
from pymt.vector import Vector

class GestureDatabase(object):
    '''Class to handle a gesture database.'''
    def __init__(self):
        self.db = []

    def add_gesture(self, gesture):
        '''Add a new gesture in database'''
        self.db.append(gesture)

    def find(self, gesture, minscore=0.9, rotation_invariant=True):
        '''Find current gesture in database'''
        if not gesture:
            return

        best = None
        bestscore = minscore
        for g in self.db:
            score = g.get_score(gesture, rotation_invariant)
            if score < bestscore:
                continue
            bestscore = score
            best = g
        if not best:
            return
        return (bestscore, best)

    def gesture_to_str(self, gesture):
        '''Convert a gesture into a unique string'''
        from cStringIO import StringIO
        import pickle, base64, zlib
        io = StringIO()
        p = pickle.Pickler(io)
        p.dump(gesture)
        data = base64.b64encode(zlib.compress(io.getvalue(), 9))
        return data

    def str_to_gesture(self, data):
        '''Convert a unique string to a gesture'''
        from cStringIO import StringIO
        import pickle, base64, zlib
        io = StringIO(zlib.decompress(base64.b64decode(data)))
        p = pickle.Unpickler(io)
        gesture = p.load()
        return gesture


class GesturePoint:
    def __init__(self, x, y):
        '''Stores the x,y coordinates of a point in the gesture'''
        self.x = float(x)
        self.y = float(y)

    def scale(self, factor):
        ''' Scales the point by the given factor '''
        self.x *= factor
        self.y *= factor
        return self

    def __repr__(self):
        return 'Mouse_point: %f,%f' % (self.x, self.y)

class GestureStroke:
    ''' Gestures can be made up of multiple strokes '''
    def __init__(self):
        ''' A stroke in the gesture '''
        self.points = list()
        self.screenpoints = list()

    # These return the min and max coordinates of the stroke
    @property
    def max_x(self):
        if len(self.points) == 0:
            return 0
        return max(self.points, key = lambda pt: pt.x).x
    @property
    def min_x(self):
        if len(self.points) == 0:
            return 0
        return min(self.points, key = lambda pt: pt.x).x
    @property
    def max_y(self):
        if len(self.points) == 0:
            return 0
        return max(self.points, key = lambda pt: pt.y).y
    @property
    def min_y(self):
        if len(self.points) == 0:
            return 0
        return min(self.points, key = lambda pt: pt.y).y

    def add_point(self, x, y):
        '''
        add_point(x=x_pos, y=y_pos)
        Adds a point to the stroke
        '''
        self.points.append(GesturePoint(x, y))
        self.screenpoints.append((x, y))

    def scale_stroke(self, scale_factor):
        '''
        scale_stroke(scale_factor=float)
        Scales the stroke down by scale_factor
        '''
        self.points = map(lambda pt: pt.scale(scale_factor), self.points)

    def points_distance(self, point1, point2):
        '''
        points_distance(point1=GesturePoint, point2=GesturePoint)
        Returns the distance between two GesturePoint
        '''
        x = point1.x - point2.x
        y = point1.y - point2.y
        return math.sqrt(x*x + y*y)

    def stroke_length(self, point_list=None):
        '''
        stroke_length([point_list])
        Finds the length of the stroke. If a point list is given, finds the length of that list
        '''
        if point_list is None:
            point_list = self.points
        gesture_length = 0.0
        if len(point_list) <= 1: # If there is only one point -> no length
            return gesture_length
        for i in xrange(len(point_list)-1):
            gesture_length += self.points_distance(
                point_list[i], point_list[i+1])
        return gesture_length

    def normalize_stroke(self, sample_points = 32):
        '''
        normalize_stroke([sample_points=int])
        Normalizes strokes so that every stroke has a standard number of points. Returns True if
        stroke is normalized, False if it can't be normalized. sample_points control the resolution of the stroke
        '''
        # If there is only one point or the length is 0, don't normalize
        if len(self.points) <= 1 or self.stroke_length(self.points) == 0.0:
            return False

        # Calculate how long each point should be in the stroke
        target_stroke_size = self.stroke_length(self.points) / \
                             float(sample_points)
        new_points = list()
        new_points.append(self.points[0])

        # We loop on the points
        prev = self.points[0]
        src_distance = 0.0
        dst_distance = target_stroke_size
        for curr in self.points[1:]:
            d = self.points_distance( prev, curr )
            if d > 0:
                prev = curr
                src_distance = src_distance+d

                # The new point need to be inserted into the
                # segment [prev, curr]
                while dst_distance < src_distance:
                    x_dir = curr.x - prev.x
                    y_dir = curr.y - prev.y
                    ratio = (src_distance-dst_distance)/d
                    to_x = x_dir * ratio + prev.x
                    to_y = y_dir * ratio + prev.y
                    new_points.append(GesturePoint(to_x, to_y))
                    dst_distance = self.stroke_length(self.points) / \
                            float(sample_points) * len(new_points)

        # If this happens, we are into troubles...
        if not len(new_points) == sample_points:
            raise ValueError('Invalid number of strokes points; got '
                             '%d while it should be %d' % 
                             (len(new_points), sample_points))

        self.points = new_points
        return True

    def center_stroke(self, offset_x, offset_y):
        '''Centers the stroke by offseting the points'''
        for point in self.points:
            point.x -= offset_x
            point.y -= offset_y

class Gesture:
    '''
    A python implementation of a gesture recognition algorithm by Oleg Dopertchouk
    http://www.gamedev.net/reference/articles/article2039.asp

    Implemented by Jeiel Aranal (chemikhazi@gmail.com), released into the public domain
    '''

    # Tolerance for evaluation using the '==' operator
    DEFAULT_TOLERANCE = 0.1

    def __init__(self, tolerance=None):
        '''
        Gesture([tolerance=float])
        Creates a new gesture with an optional matching tolerance value
        '''
        self.width = 0.
        self.height = 0.
        self.gesture_product = 0.
        self.strokes = list()
        if tolerance is None:
            self.tolerance = Gesture.DEFAULT_TOLERANCE
        else:
            self.tolerance = tolerance

    def _scale_gesture(self):
        ''' Scales down the gesture to a unit of 1 '''
        # map() creates a list of min/max coordinates of the strokes
        # in the gesture and min()/max() pulls the lowest/highest value
        min_x = min(map(lambda stroke: stroke.min_x, self.strokes))
        max_x = max(map(lambda stroke: stroke.max_x, self.strokes))
        min_y = min(map(lambda stroke: stroke.min_y, self.strokes))
        max_y = max(map(lambda stroke: stroke.max_y, self.strokes))
        x_len = max_x - min_x
        self.width = x_len
        y_len = max_y - min_y
        self.height = y_len
        scale_factor = max(x_len, y_len)
        if scale_factor <= 0.0:
            return False
        scale_factor = 1.0/scale_factor
        for stroke in self.strokes:
            stroke.scale_stroke(scale_factor)
        return True

    def _center_gesture(self):
        ''' Centers the Gesture,Point of the gesture '''
        total_x = 0.0
        total_y = 0.0
        total_points = 0

        for stroke in self.strokes:
            # adds up all the points inside the stroke
            stroke_y = reduce(lambda total, pt: total + pt.y, stroke.points, 0.0)
            stroke_x = reduce(lambda total, pt: total + pt.x, stroke.points, 0.0)
            total_y += stroke_y
            total_x += stroke_x
            total_points += len(stroke.points)
        if total_points == 0:
            return False
        # Average to get the offset
        total_x /= total_points
        total_y /= total_points
        # Apply the offset to the strokes
        for stroke in self.strokes:
            stroke.center_stroke(total_x, total_y)
        return True

    def add_stroke(self, point_list=None):
        '''
        add_stroke([point_list=list])
        Adds a stroke to the gesture and returns the Stroke instance
        Optional point_list argument is a list of the mouse points for the stroke
        '''
        self.strokes.append(GestureStroke())
        if isinstance(point_list, list) or isinstance(point_list, tuple):
            for point in point_list:
                if isinstance(point, GesturePoint):
                    self.strokes[-1].points.append(point)
                elif isinstance(point, list) or isinstance(point, tuple):
                    if len(point) < 2 or len(point) > 2:
                        raise ValueError("A stroke entry should only have 2 values")
                    self.strokes[-1].add_point(point[0], point[1])
                else:
                    raise TypeError("The point list should either be tuples of x and y or a list of GesturePoint")
        elif point_list is not None:
            raise ValueError("point_list should be a tuple/list")
        return self.strokes[-1]

    def normalize(self, stroke_samples=32):
        ''' Runs the gesture normalization algorithm and calculates the dot product with self '''
        if not self._scale_gesture() or not self._center_gesture():
            self.gesture_product = False
            return False
        for stroke in self.strokes:
            stroke.normalize_stroke(stroke_samples)
        self.gesture_product = self.dot_product(self)

    def get_rigid_rotation(self, dstpts):
        '''
        Extract the rotation to apply to a group of points to minimize the
        distance to a second group of points. The two groups of points are
        assumed to be centered. This is a simple version that just pick
        an angle based on the first point of the gesture.
        '''
        if len(self.strokes) < 1 or len(self.strokes[0].points) < 1:
            return 0
        if len(dstpts.strokes) < 1 or len(dstpts.strokes[0].points) < 1:
            return 0
        target = Vector( [dstpts.strokes[0].points[0].x, dstpts.strokes[0].points[0].y]  )
        source = Vector( [self.strokes[0].points[0].x, self.strokes[0].points[0].y] )
        return source.angle(target)

    def dot_product(self, comparison_gesture):
        ''' Calculates the dot product of the gesture with another gesture '''
        if len(comparison_gesture.strokes) != len(self.strokes):
            return -1
        if getattr(comparison_gesture, 'gesture_product', True) is False or getattr(self, 'gesture_product', True) is False:
            return -1
        dot_product = 0.0
        for stroke_index, (my_stroke, cmp_stroke) in enumerate( zip(self.strokes, comparison_gesture.strokes) ):
            for pt_index, (my_point, cmp_point) in enumerate( zip(my_stroke.points, cmp_stroke.points) ):
                dot_product += my_point.x * cmp_point.x + my_point.y * cmp_point.y
        return dot_product

    def rotate( self, angle ):
        g = Gesture()
        for stroke in self.strokes:
            tmp = []
            for j in stroke.points:
                v = Vector([j.x, j.y]).rotate(angle)
                tmp.append( v )
            g.add_stroke( tmp )
        g.gesture_product = g.dot_product(g)
        return g

    def get_score(self, comparison_gesture, rotation_invariant=True):
        ''' Returns the matching score of the gesture against another gesture '''
        if isinstance(comparison_gesture, Gesture):
            if rotation_invariant:
                # get orientation
                angle = self.get_rigid_rotation( comparison_gesture )

                # rotate the gesture to be in the same frame.
                comparison_gesture = comparison_gesture.rotate( angle )

            # this is the normal "orientation" code.
            score = self.dot_product(comparison_gesture)
            if score <= 0:
                return score
            score /= math.sqrt(self.gesture_product * comparison_gesture.gesture_product)
            return score

    def __eq__(self, comparison_gesture):
        ''' Allows easy comparisons between gesture instances '''
        if isinstance(comparison_gesture, Gesture):
            # If the gestures don't have the same number of strokes, its definitely not the same gesture
            score = self.get_score(comparison_gesture)
            if score > (1.0 - self.tolerance) and score < (1.0 + self.tolerance):
                return True
            else:
                return False
        else:
            return NotImplemented

    def __ne__(self, comparison_gesture):
        result = self.__eq__(comparison_gesture)
        if result is NotImplemented:
            return result
        else:
            return not result
    def __lt__(self, comparison_gesture):
        raise TypeError("Gesture cannot be evaluated with <")
    def __gt__(self, comparison_gesture):
        raise TypeError("Gesture cannot be evaluated with >")
    def __le__(self, comparison_gesture):
        raise TypeError("Gesture cannot be evaluated with <=")
    def __ge__(self, comparison_gesture):
        raise TypeError("Gesture cannot be evaluated with >=")

########NEW FILE########
__FILENAME__ = bezier
'''
Bezier: handle curve based on bezier path


A bezier path can be constructed like this ::

    path = BezierPath()
    # start the path
    path.path_begin(x, y)
    # add a point with x1/y1, x2/y2 as control point
    path.path_curve_to(x1, y1, x2, y2, x, y)
    # repeat this multiple time... until
    # path.path_curve_to(...)
    # close the path
    path.path_close()
    # and draw !
    path.draw()


You can also provide a point list, and directly create a path ::

    points = (startx, starty,
              controlx1, controly1, controlx2, controly2, pointx1, pointx2,
              # ... repeat
    )

    path = BezierPath(path=points)
    path.draw()


'''

__all__ = ('BezierPath', )

from pymt.graphx.statement import GlDisplayList, gx_begin
from pymt.logger import pymt_logger
from pymt.graphx.draw import drawLine
from OpenGL.GL import glVertex2f
from OpenGL.GLU import gluNewTess, gluTessNormal, gluTessProperty, \
    gluTessBeginPolygon, gluTessBeginContour, gluTessEndContour, \
    gluTessEndPolygon, gluTessCallback, gluErrorString, gluTessVertex, \
    GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_NONZERO, GLU_TESS_VERTEX, \
    GLU_TESS_BEGIN, GLU_TESS_END, GLU_TESS_ERROR


class BezierPath(object):
    '''Create a line based on bezier equation, or a shape using GLU tess.

    :Parameters:
        `filled` : boolean, default to False
            Create a filled bezier shape
        `path` : list, default to None
            Create a path directly from points. See up description for more
            information about the format used in path.
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('filled', False)
        kwargs.setdefault('path', None)

        self._tess                  = None
        self._filled_path           = None
        self._dl                    = GlDisplayList()
        self._path                  = []
        self._bezier_coefficients   = []
        self._bezier_points         = 10
        self._contructing           = False

        super(BezierPath, self).__init__()

        self.filled                 = kwargs.get('filled')
        self.x, self.y              = 0, 0

        if kwargs.get('path'):
            self.calculate_from_bezier_path(kwargs.get('path'))

    def path_begin(self, x, y):
        '''Start a new bezier path'''
        self._path = [x, y]
        self.x, self.y = x, y

    def path_end(self):
        '''End the current bezier path'''
        self._path += self._path[0:2]
        self.reset()

    def path_curve_to(self, x1, y1, x2, y2, x, y):
        '''Add a control point into bezier path'''
        if not self._bezier_coefficients:
            for i in xrange(self._bezier_points + 1):
                t = float(i) / self._bezier_points
                t0 = (1 - t) ** 3
                t1 = 3 * t * (1 - t) ** 2
                t2 = 3 * t ** 2 * (1 - t)
                t3 = t ** 3
                self._bezier_coefficients.append([t0, t1, t2, t3])
        for i, t in enumerate(self._bezier_coefficients):
            px = t[0] * self.x + t[1] * x1 + t[2] * x2 + t[3] * x
            py = t[0] * self.y + t[1] * y1 + t[2] * y2 + t[3] * y
            self._path += px, py
        self.x, self.y = px, py
        self.reset()

    def calculate_from_bezier_path(self, points):
        '''Create a new path from a list of control points'''
        self.path_begin(points[0], points[1])
        for i in xrange(2, len(points), 6):
            x1, y1, x2, y2, x, y = points[i:i+6]
            self.path_curve_to(x1, y1, x2, y2, x, y)
        self.path_end()
        self.reset()

    def draw_filled_path(self):
        for style, points in self.filled_path:
            with gx_begin(style):
                for x, y in zip(points[::2], points[1::2]):
                    glVertex2f(x, y)

    def draw(self):
        '''Draw the path on screen (filled or line)'''
        if not self._dl.is_compiled():
            with self._dl:
                if self.filled:
                    self.draw_filled_path()
                else:
                    drawLine(self.path)
        self._dl.draw()

    def reset(self):
        '''Reset the display list cache'''
        self._dl.clear()

    def _get_path(self):
        return self._path
    path = property(_get_path, doc='''Return the calculated path in format (x,y,x,y...)''')

    def _get_filled_path(self):
        if self._filled_path:
            return self._filled_path

        self._tess = gluNewTess()
        gluTessNormal(self._tess, 0, 0, 1)
        gluTessProperty(self._tess, GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_NONZERO)

        tess_list = []

        def tess_vertex(vertex):
            self._tess_shape += list(vertex[0:2])

        def tess_begin(which):
            self._tess_style = which
            self._tess_shape = []

        def tess_end():
            tess_list.append((self._tess_style, self._tess_shape))

        def tess_error(code):
            err = gluErrorString(code)
            pymt_logger.warning('BezierPath: GLU Tesselation Error: %s' % str(err))

        gluTessCallback(self._tess, GLU_TESS_VERTEX, tess_vertex)
        gluTessCallback(self._tess, GLU_TESS_BEGIN, tess_begin)
        gluTessCallback(self._tess, GLU_TESS_END, tess_end)
        gluTessCallback(self._tess, GLU_TESS_ERROR, tess_error)

        gluTessBeginPolygon(self._tess, None)
        gluTessBeginContour(self._tess)
        for x, y in zip(self._path[::2], self._path[1::2]):
            v_data = (x, y, 0)
            gluTessVertex(self._tess, v_data, v_data)
        gluTessEndContour(self._tess)
        gluTessEndPolygon(self._tess)

        self._filled_path = tess_list
        return tess_list
    filled_path = property(_get_filled_path,
                    doc='''Return the filled shape in format ((gl style, (x,y,x,y...)),...)''')


########NEW FILE########
__FILENAME__ = colors
'''
Colors: manipulate colors
'''

__all__ = ('set_color', )

from OpenGL.GL import GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_BLEND, \
        glEnable, glDisable, glBlendFunc, glColor3f, glColor4f
from pymt.utils import get_color_from_hex

def set_color(*colors, **kwargs):
    '''Define current color to be used (as float values between 0 and 1) ::

        set_color(1, 0, 0, 1)
        drawLabel('Hello', pos=(100, 0))
        set_color(0, 1, 0, 1)
        drawLabel('World', pos=(200, 0))

    .. Note:
        Blending is activated if alpha value != 1

    :Parameters:
        `*colors` : list
            Can have 3 or 4 float value (between 0 and 1)
        `sfactor` : opengl factor, default to GL_SRC_ALPHA
            Default source factor to be used if blending is activated
        `dfactor` : opengl factor, default to GL_ONE_MINUS_SRC_ALPHA
            Default destination factor to be used if blending is activated
        `blend` : boolean, default to None
            Set True if you really want to activate blending, even
            if the alpha color is 1 (mean no blending in theory)
    '''

    kwargs.setdefault('sfactor', GL_SRC_ALPHA)
    kwargs.setdefault('dfactor', GL_ONE_MINUS_SRC_ALPHA)
    kwargs.setdefault('blend', None)
    force_blend = kwargs['blend'] == True
    if len(colors) == 1:
        if type(colors[0]) in (unicode, str):
            colors = get_color_from_hex(colors[0])
        else:
            colors = (colors[0], colors[0], colors[0])
    if len(colors) == 4:
        glColor4f(*colors)
        if colors[3] == 1 and not force_blend:
            glDisable(GL_BLEND)
        else:
            glEnable(GL_BLEND)
            glBlendFunc(kwargs.get('sfactor'), kwargs.get('dfactor'))
    if len(colors) == 3:
        glColor3f(*colors)
        if force_blend:
            glEnable(GL_BLEND)
            glBlendFunc(kwargs.get('sfactor'), kwargs.get('dfactor'))
        else:
            glDisable(GL_BLEND)


########NEW FILE########
__FILENAME__ = css
'''
CSS: Draw shapes with css attributes !
'''

__all__ = ('drawCSSRectangle', )

import os
from pymt.graphx.draw import drawRectangleAlpha, drawRectangle, \
        drawRoundedRectangle, drawRoundedRectangleAlpha
from pymt.graphx.colors import set_color
from pymt.cache import Cache
from pymt.graphx.statement import GlDisplayList, gx_color
from OpenGL.GL import GL_LINE_BIT, GL_LINE_LOOP, \
        glPushAttrib, glPopAttrib, glLineWidth

if not 'PYMT_DOC' in os.environ:
    Cache.register('pymt.cssrect', limit=100, timeout=60)


def drawCSSRectangle(pos=(0, 0), size=(100, 100), style=dict(), prefix=None, state=None):
    '''Draw a rectangle with CSS
    
    :Parameters:
        `state`: if a certain state string is passed, we will use styles with this postifx instead.
            for example:  style[bg-color] and style[bg-color-down] are both set.
            if state == "down", we wil use bg-color-down instead of bg-color

    :Styles:
        * alpha-background (color)
        * border-radius (float)
        * border-radius-precision (float)
        * border-width (float)
        * draw-alpha-background (bool)
        * draw-background (bool)
        * draw-border (bool)

    '''

    bg_image = style.get('bg-image-'+str(state))
    if not bg_image:
        bg_image = style.get('bg-image')

    # Check if we have a cached version
    cache_id = '%s:%s:%s:%s:%s' % (pos, size, style, prefix, state)
    cache = Cache.get('pymt.cssrect', cache_id)
    if cache:
        cache.draw()
        if bg_image:
            bg_image.size = size
            bg_image.pos = pos
            bg_image.draw()
        return


    # lets use the ones for given state,
    # and ignore the regular ones if the state ones are there
    if state:
        state = "-" + state
        newstyle = {}
        overwrites = []
        for s in style:
            if state in s:
                overwrite  = s.replace(state, '')
                newstyle[overwrite] = style[s]
                overwrites.append(overwrite)
            if s not in overwrites:
                newstyle[s] = style[s]
        style = newstyle

    # hack to remove prefix in style
    if prefix is not None:
        prefix += '-'
        newstyle = {}
        for k in style:
            newstyle[k] = style[k]
        for k in style:
            if prefix in k:
                newstyle[k.replace(prefix, '')] = style[k]
        style = newstyle

    style.setdefault('border-width', 1.5)
    style.setdefault('border-radius', 0)
    style.setdefault('border-radius-precision', .1)
    style.setdefault('draw-border', 0)
    style.setdefault('draw-background', 1)
    style.setdefault('draw-alpha-background', 0)
    style.setdefault('alpha-background', (1, 1, .5, .5))

    k = { 'pos': pos, 'size': size }

    new_cache = GlDisplayList()
    with new_cache:

        if state:
            set_color(*style['bg-color']) #hack becasue old widgets set this themselves

        linewidth = style.get('border-width')

        bordercolor = None
        if 'border-color' in style:
            bordercolor = style['border-color']

        if style['border-radius'] > 0:
            k.update({
                'radius': style['border-radius'],
                'precision': style['border-radius-precision']
            })
            if style['draw-background']:
                drawRoundedRectangle(**k)
            if style['draw-border']:
                if linewidth:
                    glPushAttrib(GL_LINE_BIT)
                    glLineWidth(linewidth)
                if bordercolor:
                    with gx_color(*bordercolor):
                        drawRoundedRectangle(style=GL_LINE_LOOP, **k)
                else:
                    drawRoundedRectangle(style=GL_LINE_LOOP, **k)
                if linewidth:
                    glPopAttrib()
            if style['draw-alpha-background']:
                drawRoundedRectangleAlpha(alpha=style['alpha-background'], **k)
        else:
            if style['draw-background']:
                drawRectangle(**k)
            if style['draw-border']:
                if linewidth:
                    glPushAttrib(GL_LINE_BIT)
                    glLineWidth(linewidth)
                if bordercolor:
                    with gx_color(*bordercolor):
                        drawRectangle(style=GL_LINE_LOOP, **k)
                else:
                    drawRectangle(style=GL_LINE_LOOP, **k)
                if linewidth:
                    glPopAttrib()
            if style['draw-alpha-background']:
                drawRectangleAlpha(alpha=style['alpha-background'], **k)


    # if the drawCSSRectangle is already inside a display list
    # compilation will not happen, but drawing yes.
    # so, store only if a cache is created !
    if new_cache.is_compiled():
        Cache.append('pymt.cssrect', cache_id, new_cache)
        new_cache.draw()

    if bg_image:
        bg_image.size = size
        bg_image.pos = pos
        bg_image.draw()

########NEW FILE########
__FILENAME__ = draw
'''
Draw: primitive drawing
'''

__all__ = (
    'drawLabel', 'drawRoundedRectangle',
    'drawCircle', 'drawPolygon',
    'drawTriangle', 'drawRectangle',
    'drawTexturedRectangle', 'drawLine',
    'drawRectangleAlpha', 'drawRoundedRectangleAlpha',
    'drawSemiCircle', 'drawStippledCircle',
    'getLastLabel', 'getLabel',
)

import os
import math
import pymt
from pymt.cache import Cache
from pymt.vector import Vector
from OpenGL.GL import *
from OpenGL.GLU import gluNewQuadric, gluDisk, gluPartialDisk
from pymt.graphx.paint import *
from pymt.graphx.statement import *
from pymt.graphx.colors import *

try:
    import pymt.c_ext.c_graphx as c_graphx
    pymt.pymt_logger.info('Graphx: Using accelerate graphx module')
except ImportError, e:
    c_graphx = None
    pymt.pymt_logger.warning('Extensions: c_graphx not available: <%s>' % e)

# create a cache for label
_temp_label = None
if not 'PYMT_DOC' in os.environ:
    Cache.register('pymt.label', timeout=1., limit=1000)

def _make_point_list(points):
    t = type(points)
    if not t in (tuple, list):
        raise Exception('Point list must be tuple or list of' +
                        'coordinates or points(tuple/list of 2D coords)')
    if type(points[0]) in (tuple, list, Vector):
        return [coord for point in points for coord in point]
    else:
        return list(points)

def getLabel(label, **kwargs):
    '''Get a cached label object

    :Parameters:
        `label`: str
            Text to be draw
        `font_size`: int, default to 12
            Font size of label
        `center`: bool, default to True
            Indicate if pos is center or left-right of label

    getLabel() support all parameters from the Core label. Check `LabelBase`
    class to known all availables parameters.

    Used by drawLabel()
    '''
    kwargs.setdefault('markup', False)
    kwargs.setdefault('font_size', 12)
    kwargs.setdefault('center', True)
    if kwargs.get('center'):
        kwargs.setdefault('anchor_x', 'center')
        kwargs.setdefault('anchor_y', 'center')
    else:
        kwargs.setdefault('anchor_x', 'left')
        kwargs.setdefault('anchor_y', 'bottom')
    del kwargs['center']

    # create an uniq id for this label
    id = '%s##%s' % (label, str(kwargs))

    # get or store
    obj = Cache.get('pymt.label', id)
    if not obj:
        if kwargs.get('markup'):
            obj = pymt.MarkupLabel(label, **kwargs)
        else:
            obj = pymt.Label(label, **kwargs)
        if 'nocache' not in kwargs:
            Cache.append('pymt.label', id, obj)

    return obj

def drawLabel(label, pos=(0,0), **kwargs):
    '''Draw a label on the window.

    :Parameters:
        `label`: str
            Text to be draw
        `pos`: tuple, default to (0, 0)
            Position of text
        `font_size`: int, default to 12
            Font size of label
        `center`: bool, default to True
            Indicate if pos is center or left-right of label

    If you want to get the label object, use getLastLabel()
    just after your drawLabel().
    '''
    global _temp_label
    _temp_label = getLabel(label, **kwargs)
    _temp_label.x, _temp_label.y = pos
    _temp_label.draw()
    return _temp_label.content_size

def getLastLabel():
    global _temp_label
    return _temp_label

def drawRoundedRectangle(pos=(0,0), size=(100,50), radius=5, color=None,
                         linewidth=0, precision=0.5, style=GL_POLYGON,
                         corners=(True, True, True, True)):
    '''Draw a rounded rectangle

    :Parameters:
        `pos`: tuple, default to (0, 0)
            Position of rectangle
        `size`: tuple, default to (100, 50)
            Size of rectangle
        `radius`: int, default to 5
            Radius of corner
        `color`: tuple, default to None
            Color to be passed to set_color()
        `linewidth`: float (default to current linewidth)
            Line with of border
        `precision`: float, default to 0.5
            Precision of corner angle
        `style`: opengl begin, default to GL_POLYGON
            Style of the rounded rectangle (try GL_LINE_LOOP)
        `corners`: tuple of bool, default to (True, True, True, True)
            Indicate if round must be draw for each corners
            starting to bottom-left, bottom-right, top-right, top-left
    '''
    x, y = pos
    w, h = size

    if color:
        set_color(*color)

    # use accelerate version
    '''
    if c_graphx:
        c_graphx.drawRoundedRectangle()
        return
    '''

    if size[0] < radius * 2:
        radius = size[0] / 2
    if size[1] < radius * 2:
        radius = size[1] / 2

    if linewidth > 0:
        glPushAttrib(GL_LINE_BIT)
        glLineWidth(linewidth)

    with gx_begin(style):

        if corners[1]:
            glVertex2f(x + radius, y)
            glVertex2f(x + w-radius, y)
            t = math.pi * 1.5
            while t < math.pi * 2:
                sx = x + w - radius + math.cos(t) * radius
                sy = y + radius + math.sin(t) * radius
                glVertex2f(sx, sy)
                t += precision
        else:
            glVertex2f(x + w, y)

        if corners[2]:
            glVertex2f(x + w, y + radius)
            glVertex2f(x + w, y + h - radius)
            t = 0
            while t < math.pi * 0.5:
                sx = x + w - radius + math.cos(t) * radius
                sy = y + h -radius + math.sin(t) * radius
                glVertex2f(sx, sy)
                t += precision
        else:
            glVertex2f(x + w, y + h)

        if corners[3]:
            glVertex2f(x + w -radius, y + h)
            glVertex2f(x + radius, y + h)
            t = math.pi * 0.5
            while t < math.pi:
                sx = x  + radius + math.cos(t) * radius
                sy = y + h - radius + math.sin(t) * radius
                glVertex2f(sx, sy)
                t += precision
        else:
            glVertex2f(x, y + h)

        if corners[0]:
            glVertex2f(x, y + h - radius)
            glVertex2f(x, y + radius)
            t = math.pi
            while t < math.pi * 1.5:
                sx = x + radius + math.cos(t) * radius
                sy = y + radius + math.sin(t) * radius
                glVertex2f (sx, sy)
                t += precision
        else:
            glVertex2f(x, y)

    if linewidth > 0:
        glPopAttrib()


def drawCircle(pos=(0,0), radius=1.0, linewidth=0):
    '''Draw a simple circle

    :Parameters:
        `pos`: tuple, default to (0, 0)
            Position of circle
        `radius`: float, default to 1.0
            Radius of circle
    '''
    x, y = pos[0], pos[1]
    with gx_matrix:
        glTranslatef(x, y, 0)
        glScalef(radius, radius, 1.0)
        if linewidth > 0:
            gluDisk(gluNewQuadric(), 1-linewidth/float(radius), 1, 32,1)
        else:
            gluDisk(gluNewQuadric(), 0, 1, 32,1)

def drawPolygon(points, style=GL_POLYGON, linewidth=0):
    '''Draw polygon from points list

    :Parameters:
        `points`: list
            List of points, length must be power of 2. (x,y,x,y...)
        `style`: opengl begin, default to GL_POLYGON
            Default type to draw (will be passed to glBegin)
            can also be string ::

                'fill' == 'GL_POLYGON' == GL_POLYGON
                'line' == 'GL_LINE_LOOP' == GL_LINE_LOOP

        `linewidth`: int, defaults to current OpenGL state. 
            Sets the linewidth if drawign style is a line based one
    '''
    if isinstance(style, basestring):
        if style in ('fill', 'GL_POLYGON'):
            style = GL_POLYGON
        if style in ('line', 'GL_LINE_LOOP'):
            style = GL_LINE_LOOP
        else:
            raise Exception("Invalid style argument for drawPolygon method, try 'fill', 'GL_POLYGON', 'line', or 'GL_LINE_LOOP'")

    points = _make_point_list(points)

    # use accelerate version
    if c_graphx:
        c_graphx.drawPolygon(style, points, linewidth)
        return

    if linewidth > 0:
        glPushAttrib(GL_LINE_BIT)
        glLineWidth(linewidth)
    with gx_begin(style):
        for x, y in zip(points[::2], points[1::2]):
            glVertex2f(x, y)
    if linewidth > 0:
        glPopAttrib()


def drawTriangle(pos, w, h, style=GL_POLYGON, linewidth=0):
    '''Draw one triangle

    :Parameters:
        `pos`: tuple
            Position of triangle
        `w`: int
            Width of triangle
        `h`: int
            Height of triangle
        `style`: opengl begin, default to GL_POLYGON
            Default type to draw (will be passed to glBegin)
            can also be string ::

                'fill' == 'GL_POLYGON' == GL_POLYGON
                'line' == 'GL_LINE_LOOP' == GL_LINE_LOOP

        `linewidth`: int, defaults to current OpenGL state.
            Sets the linewidth if drawign style is a line based one
    '''
    points = [pos[0]-w/2, pos[1], pos[0]+w/2, pos[1], pos[0], pos[1]+h]
    drawPolygon(points, style, linewidth)

def drawRectangle(pos=(0,0), size=(1.0,1.0), style=GL_QUADS):
    '''Draw a simple rectangle

    :Parameters:
        `pos`: tuple, default to (0, 0)
            Position of rectangle
        `size`: tuple, default to (1.0, 1.0)
            Size of rectangle
        `style`: opengl begin, default to GL_QUADS
            Style of rectangle (try GL_LINE_LOOP)
    '''
    # use accelerated version
    if c_graphx:
        c_graphx.drawRectangle(style, pos[0], pos[1], size[0], size[1])
        return

    with gx_begin(style):
        glVertex2f(pos[0], pos[1])
        glVertex2f(pos[0] + size[0], pos[1])
        glVertex2f(pos[0] + size[0], pos[1] + size[1])
        glVertex2f(pos[0], pos[1] + size[1])

def drawTexturedRectangle(texture, pos=(0,0), size=(1.0,1.0),
                          tex_coords=None, color_coords=None):
    '''Draw a rectangle with a texture.
    The rectangle is drawed from bottom-left, bottom-right, top-right, top-left.

    :Parameters:
        `texture`: Texture
            Texture object, created with Texture().
        `pos`: tuple, default to (0, 0)
            Position of rectangle
        `size`: tuple, default to (1.0, 1.0)
            Size of rectangle
        `tex_coords`: list, default to None
            Contain a list of UV coords to use. If None, texture UV coordinates
            will be used.
        `color_coords`: list, default to None
            Specify a color for each vertex. The format is 4 colors tuples in a
            list.
    '''
    # initialize texcoords
    tex_coords_def = (0.0,0.0, 1.0,0.0, 1.0,1.0, 0.0,1.0)

    # if texture is provided, use it
    if texture:
        stmt = gx_texture(texture)
        stmt.bind()
        if type(texture) in (pymt.Texture, pymt.TextureRegion) \
            and tex_coords is None:
            tex_coords = texture.tex_coords

    # if tex_coords is provided, use it
    if tex_coords is None:
        tex_coords = tex_coords_def

    coords = ( pos[0], pos[1],
            pos[0] + size[0], pos[1],
            pos[0] + size[0], pos[1] + size[1],
            pos[0], pos[1] + size[1])

    if color_coords:
        with gx_begin(GL_QUADS):
            glColor4f(*color_coords[0])
            glTexCoord2f(tex_coords[0], tex_coords[1])
            glVertex2f(coords[0], coords[1])
            glColor4f(*color_coords[1])
            glTexCoord2f(tex_coords[2], tex_coords[3])
            glVertex2f(coords[2], coords[3])
            glColor4f(*color_coords[2])
            glTexCoord2f(tex_coords[4], tex_coords[5])
            glVertex2f(coords[4], coords[5])
            glColor4f(*color_coords[3])
            glTexCoord2f(tex_coords[6], tex_coords[7])
            glVertex2f(coords[6], coords[7])
    else:
        if c_graphx:
            x, y = pos
            w, h = size
            c_graphx.drawTexturedRectangle(x, y, w, h, *tex_coords)
        else:
            with gx_begin(GL_QUADS):
                glTexCoord2f(tex_coords[0], tex_coords[1])
                glVertex2f(coords[0], coords[1])
                glTexCoord2f(tex_coords[2], tex_coords[3])
                glVertex2f(coords[2], coords[3])
                glTexCoord2f(tex_coords[4], tex_coords[5])
                glVertex2f(coords[4], coords[5])
                glTexCoord2f(tex_coords[6], tex_coords[7])
                glVertex2f(coords[6], coords[7])

    # release texture
    if texture:
        stmt.release()

def drawLine(points, width=None, colors=[]):
    '''Draw a line

    :Parameters:
        `points`: list
            List of corresponding coordinates representing the points that the
            line comprises, like [x1, y1, x2, y2]. Hence, len(points) must be
            a power of 2.
        `width`: float, defaults to 5.0
            Default width of line
        `colors`: list of tuples, defaults to []
            If you want to draw colors between the points of the line (with blending),
            this list has to be populated with r,g,b values for each point.
            E.g.: drawLine([0, 0, 200, 200], colors=[1., 0, 0, 0, 1., 0])
            Turned off by default.
    '''
    style = GL_LINES
    points = _make_point_list(points)
    l = len(points)
    if l < 4:
        return
    elif l > 4:
        style = GL_LINE_STRIP

    if width is not None:
        glPushAttrib(GL_LINE_BIT)
        glLineWidth(width)

    with DO(gx_attrib(GL_COLOR_BUFFER_BIT), gx_begin(style)):
        if colors:
            for x, y, r, g, b in zip(points[::2], points[1::2],
                                     colors[::3], colors[1::3], colors[2::3]):
                glColor3f(r, g, b)
                glVertex2f(x, y)
        else:
            for x, y in zip(points[::2], points[1::2]):
                glVertex2f(x, y)

    if width is not None:
        glPopAttrib()

def drawRoundedRectangleAlpha(pos=(0,0), size=(100,50), radius=5, alpha=(1,1,1,1),
                         precision=0.5, style=GL_TRIANGLE_FAN):
    '''Draw a rounded rectangle alpha layer.

    :Parameters:
        `pos`: tuple, default to (0, 0)
            Position of rectangle
        `size`: tuple, default to (100, 50)
            Size of rectangle
        `radius`: int, default to 5
            Radius of corner
        `alpha`: list, default to (1, 1, 1, 1)
            Alpha to set in each corner (top, right, bottom, left)
        `precision`: float, default to 0.5
            Precision of corner angle
        `style`: opengl begin, default to GL_POLYGON
            Style of the rounded rectangle (try GL_LINE_LOOP)
    '''
    x, y = pos
    w, h = size

    if size[0] < radius * 2:
        radius = size[0] / 2
    if size[1] < radius * 2:
        radius = size[1] / 2

    midalpha = 0
    for a in alpha:
        midalpha += a
    midalpha /= len(alpha)

    c0 = (1,1,1,midalpha)
    c1 = (1,1,1,alpha[0]) #topleft
    c2 = (1,1,1,alpha[2]) #bottomleft
    c3 = (1,1,1,alpha[1]) #topright
    c4 = (1,1,1,alpha[3]) #bottomright

    with DO(gx_alphablending, gx_begin(style)):

        glColor4f(*c0)
        glVertex2f(x + w/2, y + h/2)
        glColor4f(*c1)
        glVertex2f(x + radius, y)
        glColor4f(*c3)
        glVertex2f(x + w-radius, y)
        t = math.pi * 1.5
        while t < math.pi * 2:
            sx = x + w - radius + math.cos(t) * radius
            sy = y + radius + math.sin(t) * radius
            glVertex2f(sx, sy)
            t += precision

        glVertex2f(x + w, y + radius)
        glColor4f(*c4)
        glVertex2f(x + w, y + h - radius)
        t = 0
        while t < math.pi * 0.5:
            sx = x + w - radius + math.cos(t) * radius
            sy = y + h -radius + math.sin(t) * radius
            glVertex2f(sx, sy)
            t += precision

        glVertex2f(x + w -radius, y + h)
        glColor4f(*c2)
        glVertex2f(x + radius, y + h)
        t = math.pi * 0.5
        while t < math.pi:
            sx = x  + radius + math.cos(t) * radius
            sy = y + h - radius + math.sin(t) * radius
            glVertex2f(sx, sy)
            t += precision

        glVertex2f(x, y + h - radius)
        glColor4f(*c1)
        glVertex2f(x, y + radius)
        t = math.pi
        while t < math.pi * 1.5:
            sx = x + radius + math.cos(t) * radius
            sy = y + radius + math.sin(t) * radius
            glVertex2f (sx, sy)
            t += precision
        glVertex2f(x + radius, y)

def drawRectangleAlpha(pos=(0,0), size=(1.0,1.0), alpha=(1,1,1,1), style=GL_QUADS):
    '''Draw an rectangle alpha layer.

    :Parameters:
        `pos`: tuple, default to (0, 0)
            Position of rectangle
        `size`: tuple, default to (1.0, 1.0)
            Size of rectangle
        `alpha`: list, default to (1, 1, 1, 1)
            Alpha to set in each corner (top, right, bottom, left)
        `style`: opengl begin, default to GL_QUADS
            Style of rectangle (try GL_LINE_LOOP)
    '''
    # use accelerated version
    if c_graphx:
        x, y = pos
        w, h = size
        a0, a1, a2, a3 = alpha
        c_graphx.drawRectangleAlpha(style, x, y, w, h, a0, a1, a2, a3)
        return

    with DO(gx_alphablending, gx_begin(style)):
        glColor4f(1, 1, 1, alpha[0])
        glVertex2f(pos[0], pos[1])
        glColor4f(1, 1, 1, alpha[1])
        glVertex2f(pos[0] + size[0], pos[1])
        glColor4f(1, 1, 1, alpha[2])
        glVertex2f(pos[0] + size[0], pos[1] + size[1])
        glColor4f(1, 1, 1, alpha[3])
        glVertex2f(pos[0], pos[1] + size[1])

def drawSemiCircle(pos=(0,0), inner_radius=100, outer_radius=120, slices=32, loops=1, start_angle=0, sweep_angle=360):
    '''Draw a semi-circle. You can choose the start angle,
    and the ending angle (from 0 to 360), and the inner/outer radius !

    :Parameters:
        `pos`: tuple, default to (0, 0)
            Center position of the circle
        `inner_radius`: int, default to 100
            Radius of the inner circle
        `outer_radius`: int, default to 120
            Radius of the outer circle
        `slices`: int, default to 32
            Precision of circle drawing
        `start_angle`: int, default to 0
            Angle to start drawing
        `sweep_angle`: int, default to 360
            Angle to finish drawing
    '''
    with gx_matrix:
        glTranslatef(pos[0], pos[1], 0)
        gluPartialDisk(gluNewQuadric(), inner_radius, outer_radius, slices, loops, start_angle, sweep_angle)

def drawStippledCircle(pos=(0,0), inner_radius=200, outer_radius=400, segments=10):
    '''
    Draw a stippled circle. A stippled circle consists of several equally-sized
    segments, with a gap between every two segments. The gap is the size of a
    segment. The circle's position and thickness can be specified.

    :Parameters:
        `pos`: tuple, default to (0, 0)
            Center position of the circle
        `inner_radius`: int, default to 100
            Radius of the inner circle
        `outer_radius`: int, default to 120
            Radius of the outer circle
        `segments`: int, defaults to 10
            Number of visible segments
    '''
    angle_delta = (360/segments)/2
    current_angle = 0
    quadric = gluNewQuadric()
    with gx_matrix:
        glTranslatef(pos[0], pos[1], 0)
        for i in range(segments):
            next_angle = current_angle + angle_delta
            gluPartialDisk(quadric, inner_radius, outer_radius, 32, 1, current_angle, angle_delta)
            # For the stipple effect, leave a part of the Disk out
            current_angle = next_angle + angle_delta

########NEW FILE########
__FILENAME__ = fbo
'''
Fbo: abstraction to use hardware/software FrameBuffer object
'''

__all__ = (
    'Fbo', 'HardwareFbo', 'SoftwareFbo',
    'UnsupportedFboException'
)

import os
import re
import OpenGL
import pymt
from OpenGL.GL import GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, \
        GL_VIEWPORT_BIT, GL_TEXTURE_2D, GL_COLOR_ATTACHMENT0_EXT, \
        GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT, GL_DEPTH_ATTACHMENT_EXT, \
        GL_BACK, GL_RGBA, GL_UNSIGNED_BYTE, GL_STENCIL_TEST, \
        GL_STENCIL_BUFFER_BIT, \
        glClear, glClearColor, glPushAttrib, glPopAttrib, \
        glViewport, glReadBuffer, glReadPixels, glCopyTexSubImage2D, \
        glDrawPixels, glDisable
from OpenGL.GL.EXT.framebuffer_object import GL_FRAMEBUFFER_EXT, \
        GL_FRAMEBUFFER_COMPLETE_EXT, GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT, \
        GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT, \
        GL_FRAMEBUFFER_UNSUPPORTED_EXT, \
        GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT, \
        GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT, \
        GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT, \
        GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT, \
        glGenFramebuffersEXT, glGenRenderbuffersEXT, \
        glBindFramebufferEXT, glBindRenderbufferEXT, \
        glDeleteRenderbuffersEXT, glDeleteFramebuffersEXT, \
        glCheckFramebufferStatusEXT, glFramebufferRenderbufferEXT, \
        glRenderbufferStorageEXT, glFramebufferTexture2DEXT
from pymt.graphx.colors import set_color
from pymt.graphx.draw import drawTexturedRectangle, set_texture, get_texture_id

# for a specific bug in 3.0.0, about deletion of framebuffer.
OpenGLversion = tuple(int(re.match('^(\d+)', i).groups()[0]) for i in OpenGL.__version__.split('.'))
try:
    import numpy
    have_numpy = True
except ImportError:
    have_numpy = False


class UnsupportedFboException(Exception):
    pass

class AbstractFbo(object):
    '''Abstraction of Framebuffer implementation.
    It's a framebuffer you can use to draw temporary things,
    and use it as a texture.

    .. note::
        You cannot use this class, use Fbo alias.

    .. warning::
        Depend of implementation, texture can be a TextureRegion, or a long.

    :Parameters:
        `clear_color` : tuple, default to (0, 0, 0, 0)
            Color to apply when clearing the texture
        `size` : tuple, default to (1024, 1024)
            Size of FBO
        `push_viewport` : bool, default to False
            Indicate if viewport must be pushed
        `with_depthbuffer` : bool, default to True
            Indicate if depthbuffer must be applied
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('clear_color', (0, 0, 0, 0))
        kwargs.setdefault('size', (1024, 1024))
        kwargs.setdefault('push_viewport', False)
        kwargs.setdefault('with_depthbuffer', True)

        self.clear_color        = kwargs.get('clear_color')
        self.size               = kwargs.get('size')
        self.with_depthbuffer   = kwargs.get('with_depthbuffer')
        self.push_viewport      = kwargs.get('push_viewport')
        self._is_bind           = False

        # create texture
        self.texture            = pymt.Texture.create(self.size[0], self.size[1])

        # get real size (can be the same)
        if isinstance(self.texture, pymt.TextureRegion):
            self.realsize = self.texture.owner.width, self.texture.owner.height
        elif isinstance(self.texture, pymt.Texture):
            self.realsize = self.texture.width, self.texture.height
        else:
            raise 'Unknown type(self.texture). Please send a bug report on pymt dev.'

    def bind(self):
        '''Activate writing on Framebuffer. All next call will be done on it.'''
        self._is_bind = True

    def release(self):
        '''Deactivate writing on Framebuffer. Back to normal mode.'''
        self._is_bind = False

    def clear(self):
        '''Clear framebuffer.

        .. warning::
            Must be called inside bind()/release() of FBO !
        '''
        assert(self._is_bind == True)

        glClearColor(*self.clear_color)
        if self.with_depthbuffer:
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        else:
            glClear(GL_COLOR_BUFFER_BIT)

    def __enter__(self):
        self.bind()

    def __exit__(self, type, value, traceback):
        self.release()


class HardwareFbo(AbstractFbo):
    '''OpenGL Framebuffer, hardware implementation.

    .. warning::
        It's not supported by all hardware, use with care !

    '''
    fbo_stack = [0]

    gl_fbo_errors = {
        GL_FRAMEBUFFER_COMPLETE_EXT:
            'Framebuffer complete.',
        GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT:
            'Framebuffer incomplete: Attachment is NOT complete.',
        GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT:
            'Framebuffer incomplete: No image is attached to FBO.',
        GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
            'Framebuffer incomplete: Attached images have different dimensions.',
        GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
            'Framebuffer incomplete: Color attached images have different internal formats.',
        GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT:
            'Framebuffer incomplete: Draw buffer.',
        GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT:
            'Framebuffer incomplete: Read buffer.',
        GL_FRAMEBUFFER_UNSUPPORTED_EXT:
            'Unsupported by FBO implementation.',
    }

    def __init__(self, **kwargs):
        super(HardwareFbo, self).__init__(**kwargs)
        self.framebuffer    = None
        self.depthbuffer    = None

        set_texture(self.texture)

        self.framebuffer = glGenFramebuffersEXT(1)
        glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, self.framebuffer)
        if self.framebuffer == 0:
            raise 'Failed to initialize framebuffer'

        if self.with_depthbuffer:
            self.depthbuffer = glGenRenderbuffersEXT(1)
            glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, self.depthbuffer)
            glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT,
                                     self.realsize[0], self.realsize[1])
            glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0)
            glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,
                                         GL_RENDERBUFFER_EXT, self.depthbuffer)

        glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
                GL_TEXTURE_2D, get_texture_id(self.texture), 0)

        # check the fbo status
        status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT)
        if status != GL_FRAMEBUFFER_COMPLETE_EXT:
            pymt.pymt_logger.error('Fbo: Error in framebuffer activation')
            pymt.pymt_logger.error('Fbo: Details: HardwareFbo size=%s, realsize=%s, format=GL_RGBA' % (
                str(self.size), str(self.realsize)))
            if status in HardwareFbo.gl_fbo_errors:
                pymt.pymt_logger.error('Fbo: Details: %s (%d)' % (HardwareFbo.gl_fbo_errors[status], status))
            else:
                pymt.pymt_logger.error('Fbo: Details: Unknown error (%d)' % status)

            pymt.pymt_logger.error('Fbo: ')
            pymt.pymt_logger.error('Fbo: You cannot use Hardware FBO.')
            pymt.pymt_logger.error('Fbo: Please change the configuration to use Software FBO.')
            pymt.pymt_logger.error('Fbo: You can use the pymt-config tools, or edit the configuration to set:')
            pymt.pymt_logger.error('Fbo: ')
            pymt.pymt_logger.error('Fbo: [graphics]')
            pymt.pymt_logger.error('Fbo: fbo = software')
            pymt.pymt_logger.error('Fbo: ')

            raise UnsupportedFboException()

        # unbind framebuffer
        glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0)

    def __del__(self):
        # if application is closed, symbol may be not available anymore
        # so, prevent failure, instead of having an exception !
        if not bool(glDeleteRenderbuffersEXT):
            return
        # XXX deletion of framebuffer failed with PyOpenGL 3.0.0
        # Closed bug : http://sourceforge.net/tracker/index.php?func=detail&aid=2727274&group_id=5988&atid=105988
        # So, we must test the version, and use numpy array instead.
        if OpenGLversion <= (3, 0, 1) and have_numpy:
            glDeleteFramebuffersEXT(1, numpy.array(self.framebuffer))
            if self.with_depthbuffer:
                glDeleteRenderbuffersEXT(1, numpy.array(self.depthbuffer))
        else:
            # XXX Should work, but not tested.
            glDeleteFramebuffersEXT(1, self.framebuffer)
            if self.with_depthbuffer:
                glDeleteRenderbuffersEXT(1, self.depthbuffer)

    def bind(self):
        super(HardwareFbo, self).bind()
        HardwareFbo.fbo_stack.append(self.framebuffer)
        glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, self.framebuffer)
        if self.push_viewport:
            glPushAttrib(GL_VIEWPORT_BIT)
            glViewport(0, 0, self.size[0], self.size[1])

    def release(self):
        if self.push_viewport:
            glPopAttrib()
        HardwareFbo.fbo_stack.pop()
        glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, HardwareFbo.fbo_stack[-1])
        super(HardwareFbo, self).release()


class SoftwareFbo(AbstractFbo):
    '''OpenGL Framebuffer, software implementation.

    .. warning::
        Poor performance, but you can use it in hardware don't support real
        Fbo extensions...

    '''
    def __init__(self, **kwargs):
        super(SoftwareFbo, self).__init__(**kwargs)
        self.pixels = None

    def bind(self):
        super(SoftwareFbo, self).bind()

        # Save current buffer
        w = pymt.getWindow()
        glReadBuffer(GL_BACK)
        self.pixels = glReadPixels(0, 0, w.width, w.height, GL_RGBA, GL_UNSIGNED_BYTE)

        # Push current attrib
        glPushAttrib(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_TEST | GL_STENCIL_BUFFER_BIT)
        glDisable(GL_STENCIL_TEST)

        # Save viewport if asked
        if self.push_viewport:
            glPushAttrib(GL_VIEWPORT_BIT)
            glViewport(0, 0, self.size[0], self.size[1])

        # Draw old Framebuffer
        set_color(1, 1, 1)
        drawTexturedRectangle(self.texture, size=self.size)

        # Slower solution, but no alpha problem
        #set_texture(self.texture)
        #pixels = glGetTexImage(self.texture.target, 0, GL_RGBA, GL_UNSIGNED_BYTE)
        #glDrawPixels(self.realsize[0], self.realsize[1], GL_RGBA, GL_UNSIGNED_BYTE, pixels)

    def release(self):
        # Restore viewport
        if self.push_viewport:
            glPopAttrib()

        # Copy current buffer into fbo texture
        set_texture(self.texture, target=GL_TEXTURE_2D)
        glReadBuffer(GL_BACK)
        glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, self.size[0], self.size[1])

        # Restore old buffer
        w = pymt.getWindow()
        glDrawPixels(w.width, w.height, GL_RGBA, GL_UNSIGNED_BYTE, self.pixels)

        glPopAttrib()

        super(SoftwareFbo, self).release()

class AutoselectFbo(object):
    fbo_class = None
    def __new__(cls, *largs, **kwargs):
        return AutoselectFbo.fbo_class(*largs, **kwargs)

#: Fbo wrapper to the best FBO available on system
Fbo = AutoselectFbo

if 'PYMT_DOC' not in os.environ:

    def __pymt_configure_fbo():

        from pymt import pymt_config

        # decide what to use
        fbo_config = pymt_config.get('graphics', 'fbo')

        if fbo_config == 'force-hardware':
            pymt.pymt_logger.debug('Fbo: Forcing hardware Framebuffer')
            AutoselectFbo.fbo_class = HardwareFbo
        elif fbo_config == 'hardware' and bool(glGenFramebuffersEXT):
            pymt.pymt_logger.debug('Fbo: Use hardware Framebuffer')
            AutoselectFbo.fbo_class = HardwareFbo
        elif fbo_config == 'software':
            pymt.pymt_logger.debug('Fbo: Use software Framebuffer')
            AutoselectFbo.fbo_class = SoftwareFbo
        else:
            pymt_config.set('graphics', 'fbo', 'software')
            pymt.pymt_logger.debug('Fbo: Falling back to software Framebuffer!!')
            AutoselectFbo.fbo_class = SoftwareFbo

    from pymt import pymt_register_post_configuration
    pymt_register_post_configuration(__pymt_configure_fbo)

########NEW FILE########
__FILENAME__ = paint
'''
Paint: brush, texturing...
'''

__all__ = (
    # settings
    'set_brush', 'set_brush_size',
    'set_texture', 'get_texture_id', 'get_texture_target',
    # draw
    'paintLine',
)

import pymt
from math import sqrt
from OpenGL.GL import GL_POINTS, GL_TEXTURE_2D, GL_SRC_ALPHA, \
        GL_ONE_MINUS_SRC_ALPHA, GL_POINT_SPRITE_ARB, GL_COORD_REPLACE_ARB, \
        GL_TRUE, glPointSize, glVertex2f, glBindTexture, glTexEnvi
from pymt.graphx.statement import gx_enable, gx_begin, DO, GlBlending

__brushs_cache   = dict()
__brush_filename = ''
__brush_texture  = None
__brush_size     = 10

def set_brush(sprite, size=None):
    '''Define the brush to use for paint* functions

    :Parameters:
        `sprite` : string
            Filename of image brush
        `size` : int, default to None
            Size of brush
    '''
    global __brush_size, __brush_filename, __brush_texture
    if size:
        __brush_size = size
    if not sprite in __brushs_cache:
        point_sprite_img = pymt.Image.load(sprite)
        __brush_texture = point_sprite_img.texture
        __brushs_cache[sprite] = __brush_texture
    __brush_filename = sprite
    __brush_texture = __brushs_cache[sprite]

def set_brush_size(size):
    '''Define the size of current brush

    :Parameters:
        `size` : int
            Size of brush
    '''
    global __brush_size
    __brush_size = size


def get_texture_id(texture):
    '''Return the openid of texture'''
    if isinstance(texture, pymt.TextureRegion):
        return texture.owner.id
    elif isinstance(texture, pymt.Texture):
        return texture.id
    else:
        return texture

def get_texture_target(texture):
    '''Return the target of texture. If none, return GL_TEXTURE_2D'''
    if isinstance(texture, pymt.TextureRegion):
        return texture.owner.target
    elif isinstance(texture, pymt.Texture):
        return texture.target
    else:
        return GL_TEXTURE_2D

def set_texture(texture, target=None):
    '''Same as glBindTexture, except he can take integer/long or
    Texture/TextureRegion'''
    if target is None:
        target = get_texture_target(texture)
    glBindTexture(target, get_texture_id(texture))

def paintLine(points, numsteps=None, **kwargs):
    '''Paint a line with current brush
    ::

        set_brush("mybrush.png", 10)
        paintLine((0, 0, 20, 50))
        paintLine((1, 2, 1, 5, 4, 6, 8, 7))

    '''
    if not __brush_texture:
        pymt.pymt_logger.warning('Graphx: No brush set to paint line, abort')
        return
    if len(points) % 2 == 1:
        raise Exception('Points list must be a pair length number (not impair)')
    kwargs.setdefault('sfactor', GL_SRC_ALPHA)
    kwargs.setdefault('dfactor', GL_ONE_MINUS_SRC_ALPHA)
    blending = GlBlending(sfactor=kwargs.get('sfactor'),
                          dfactor=kwargs.get('dfactor'))
    with DO(blending, gx_enable(GL_POINT_SPRITE_ARB),
            gx_enable(__brush_texture.target)):

        # prepare env
        set_texture(__brush_texture.id, target=__brush_texture.target)
        glTexEnvi(GL_POINT_SPRITE_ARB, GL_COORD_REPLACE_ARB, GL_TRUE)
        glPointSize(__brush_size)

        # initialize outputList
        outputList = []

        # extract 4 points each 2 points
        for x1, y1, x2, y2 in zip(points[::2], points[1::2],
                                  points[2::2], points[3::2]):

            # calculate vector and distance
            dx, dy = x2 - x1, y2 - y1
            dist = sqrt(dx * dx + dy * dy)

            # determine step
            steps = numsteps
            if steps is None:
                steps = max(1, int(dist) / 4)

            # construct pointList
            for i in xrange(steps):
                outputList.extend([x1 + dx * (float(i) / steps),
                                   y1 + dy * (float(i) / steps)])

        # draw !
        if len(outputList) < 2:
            return
        with gx_begin(GL_POINTS):
            for x, y in zip(outputList[::2], outputList[1::2]):
                glVertex2f(x, y)

########NEW FILE########
__FILENAME__ = shader
'''
Shader: abstract compilation and usage
'''

__all__ = ('ShaderException', 'Shader')

from pymt.logger import pymt_logger
#from ctypes import *
from OpenGL.GL import GL_VERTEX_SHADER, GL_FRAGMENT_SHADER, \
        glCreateProgram, glGetUniformLocation, glUniform1i, \
        glUniform1f, glLinkProgram, glCreateShader, glUseProgram, \
        glAttachShader, glCompileShader, glShaderSource, \
        glGetProgramInfoLog, glGetShaderInfoLog


class ShaderException(Exception):
    '''Exception launched by shader in error case'''
    pass

class Shader(object):
    '''Create a vertex or fragment shader

    :Parameters:
        `vertex_source` : string, default to None
            Source code for vertex shader
        `fragment_source` : string, default to None
            Source code for fragment shader
    '''
    def __init__(self, vertex_source=None, fragment_source=None):
        self.program = glCreateProgram()

        if vertex_source:
            self.vertex_shader = self.create_shader(
                vertex_source, GL_VERTEX_SHADER)
            glAttachShader(self.program, self.vertex_shader)

        if fragment_source:
            self.fragment_shader = self.create_shader(
                fragment_source, GL_FRAGMENT_SHADER)
            glAttachShader(self.program, self.fragment_shader)

        glLinkProgram(self.program)
        message = self.get_program_log(self.program)
        if message:
            pymt_logger.debug('Shader: shader program message: %s' % message)

    def create_shader(self, source, shadertype):
        shader = glCreateShader(shadertype)
        # PyOpenGL bug ? He's waiting for a list of string, not a string
        # on some card, it failed :)
        if isinstance(source, basestring):
            source = [source]
        glShaderSource(shader, source)
        glCompileShader(shader)
        message = self.get_shader_log(shader)
        if message:
            pymt_logger.debug('Shader: shader message: %s' % message)
        return shader

    def set_uniform_f(self, name, value):
        location = glGetUniformLocation(self.program, name)
        glUniform1f(location, value)

    def set_uniform_i(self, name, value):
        location = glGetUniformLocation(self.program, name)
        glUniform1i(location, value)

    def __setitem__(self, name, value):
        """pass a variable to the shader"""
        if isinstance(value, float):
            self.set_uniform_f(name, value)
        elif isinstance(value, int):
            self.set_uniform_i(name, value)
        else:
            raise TypeError('Only single floats and ints are supported so far')

    def use(self):
        '''Use the shader'''
        glUseProgram(self.program)

    def stop(self):
        '''Stop using the shader'''
        glUseProgram(0)

    def get_shader_log(self, shader):
        '''Return the shader log'''
        return self.get_log(shader, glGetShaderInfoLog)

    def get_program_log(self, shader):
        '''Return the program log'''
        return self.get_log(shader, glGetProgramInfoLog)

    def get_log(self, obj, func):
        value = func(obj)
        return value


########NEW FILE########
__FILENAME__ = statement
'''
Statements: OpenGL statement for the "with" keyword

Save and restore the matrix ::

    with gx_matrix:
        glTranslatef(55, 34, 0)
        # draw stuff
    # here, the matrix will be restored as previous state

Modify a display list (compiled OpenGL operations) ::

    dl = GlDisplayList()
    with dl:
        # draw stuff
    # here you can call the display list
    dl.draw()

Bind a texture and draw with OpenGL ::

    with DO(gx_texture(my_texture), gx_begin(GL_TRIANGLE_FAN)):
        # call multiple time glVertex2f()

Save and restore the color after drawing ::

    set_color(1, 0, 0) # color is red.
    with gx_color(0, 1, 0):
        # here the color is green
        # draw stuff
        pass
    # here the color is restored back to red
'''

__all__ = (
    # class for with statement
    'DO',
    'GlDisplayList', 'GlBlending',
    'GlMatrix', 'GlEnable', 'GlBegin',
    'GlAttrib', 'GlColor', 'GlTexture',
    # aliases
    'gx_blending', 'gx_alphablending',
    'gx_matrix', 'gx_matrix_identity',
    'gx_enable', 'gx_begin',
    'gx_attrib', 'gx_color',
    'gx_texture', 'gx_blending_replace'
)

import pymt
from OpenGL.GL import GL_COMPILE, GL_COMPILE_AND_EXECUTE, \
        GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_BLEND, GL_MODELVIEW, \
        GL_COLOR_BUFFER_BIT, GL_ENABLE_BIT, GL_TEXTURE_2D, GL_DST_COLOR, \
        GL_ONE, GL_ZERO, \
        glEnable, glDisable, glGenLists, glNewList, glEndList, glCallList, \
        glBlendFunc, glMatrixMode, glPushMatrix, glLoadIdentity, glPopAttrib, \
        glPushMatrix, glPopAttrib, glColor3f, glColor4f, glBindTexture, \
        glPopMatrix, glBegin, glEnd, glPushAttrib

gl_displaylist_generate = False
class GlDisplayList:
    '''Abstraction to opengl display-list usage. Here is an example of usage
    ::

        dl = GlDisplayList()
        with dl:
            # do draw function, like drawLabel etc...
        dl.draw()


    :Parameters:
        `mode` : str, default to 'compile'
            If mode is 'execute', the code in with will be also compiled + executed.
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('mode', 'compile')
        self.dl = glGenLists(1)
        self.compiled = False
        self.do_compile = True
        self.mode = GL_COMPILE
        if 'execute' in kwargs.get('mode'):
            self.mode = GL_COMPILE_AND_EXECUTE

    def __enter__(self):
        self.start()

    def __exit__(self, extype, value, traceback):
        self.stop()

    def start(self):
        '''Start recording GL operation'''
        global gl_displaylist_generate
        if gl_displaylist_generate:
            self.do_compile = False
        else:
            gl_displaylist_generate = True
            self.do_compile = True
            glNewList(self.dl, self.mode)

    def stop(self):
        '''Stop recording GL operation'''
        global gl_displaylist_generate
        if self.do_compile:
            glEndList()
            self.compiled = True
            gl_displaylist_generate = False

    def clear(self):
        '''Clear compiled flag'''
        self.compiled = False

    def is_compiled(self):
        '''Return compiled flag'''
        return self.compiled

    def draw(self):
        '''Call the list only if it's compiled'''
        if not self.compiled:
            return
        glCallList(self.dl)

class DO:
    '''A way to do multiple action in with statement
    ::

        with DO(stmt1, stmt2):
            print 'something'

    '''
    def __init__(self, *args):
        self.args = args

    def __enter__(self):
        for item in self.args:
            item.__enter__()

    def __exit__(self, extype, value, traceback):
        for item in reversed(self.args):
            item.__exit__(extype, value, traceback)


class GlBlending:
    '''Abstraction to use blending ! Don't use directly this class.
    We've got an alias you can use ::

        with gx_blending:
            # do draw function
    '''
    def __init__(self, sfactor=GL_SRC_ALPHA, dfactor=GL_ONE_MINUS_SRC_ALPHA):
        self.sfactor = sfactor
        self.dfactor = dfactor

    def __enter__(self):
        glEnable(GL_BLEND)
        glBlendFunc(self.sfactor, self.dfactor)

    def __exit__(self, extype, value, traceback):
        glDisable(GL_BLEND)

class GlMatrix:
    '''Statement of glPushMatrix/glPopMatrix, designed to be use with
    "with" keyword.

    Alias: gx_matrix, gx_matrix_identity ::

        with gx_matrix:
            # do draw function

        with gx_matrix_identity:
            # do draw function
    '''
    def __init__(self, matrixmode=GL_MODELVIEW, do_loadidentity=False):
        self.do_loadidentity = do_loadidentity
        self.matrixmode = matrixmode

    def __enter__(self):
        glMatrixMode(self.matrixmode)
        glPushMatrix()
        if self.do_loadidentity:
            glLoadIdentity()

    def __exit__(self, extype, value, traceback):
        glMatrixMode(self.matrixmode)
        glPopMatrix()

class GlEnable:
    '''Statement of glEnable/glDisable, designed to be use with "with" keyword.

    Alias: gx_enable.
    '''
    def __init__(self, flag):
        self.flag = flag

    def __enter__(self):
        glEnable(self.flag)

    def __exit__(self, extype, value, traceback):
        glDisable(self.flag)

gx_enable = GlEnable

class GlBegin:
    '''Statement of glBegin/glEnd, designed to be use with "with" keyword

    Alias: gx_begin.
    '''
    def __init__(self, flag):
        self.flag = flag

    def __enter__(self):
        glBegin(self.flag)

    def __exit__(self, extype, value, traceback):
        glEnd()

class GlAttrib:
    '''Statement of glPushAttrib/glPopAttrib, designed to be use with
    "with" keyword

    Alias: gx_attrib.
    '''
    def __init__(self, flag):
        self.flag = flag

    def __enter__(self):
        glPushAttrib(self.flag)

    def __exit__(self, extype, value, traceback):
        glPopAttrib()

class GlColor:
    '''Statement of glPushAttrib/glPopAttrib on COLOR BUFFER + color,
    designed to be use with "with" keyword

    Alias: gx_color.
    '''
    def __init__(self, r, g, b, a=None):
        if a is None:
            self.color = (r, g, b)
        else:
            self.color = (r, g, b, a)

    def __enter__(self):
        glPushAttrib(GL_COLOR_BUFFER_BIT)
        if len(self.color) == 3:
            glColor3f(*self.color)
        else:
            glColor4f(*self.color)

    def __exit__(self, extype, value, traceback):
        glPopAttrib()

class GlTexture:
    '''Statement of setting a texture

    Alias: gx_texture.
    '''
    def __init__(self, texture):
        self.texture = texture

    def __enter__(self):
        self.bind()

    def __exit__(self, extype, value, traceback):
        self.release()

    def bind(self):
        '''Bind the texture on the current context / texture unit'''
        target = self.get_target()
        glPushAttrib(GL_ENABLE_BIT)
        glEnable(target)
        glBindTexture(target, self.get_id())

    def release(self):
        '''Release the current attribute from the binded texture'''
        glPopAttrib()

    def get_id(self):
        '''Return the GL id of texture'''
        if isinstance(self.texture, pymt.TextureRegion):
            return self.texture.owner.id
        elif isinstance(self.texture, pymt.Texture):
            return self.texture.id
        else:
            return self.texture

    def get_target(self):
        '''Get the GL target of the texture'''
        if isinstance(self.texture, pymt.TextureRegion):
            return self.texture.owner.target
        elif isinstance(self.texture, pymt.Texture):
            return self.texture.target
        else:
            return GL_TEXTURE_2D

#
# Aliases
#

#: Alias to GlBlending(sfactor=GL_DST_COLOR, dfactor=GL_ONE_MINUS_SRC_ALPHA)
gx_alphablending = GlBlending(sfactor=GL_DST_COLOR,
                              dfactor=GL_ONE_MINUS_SRC_ALPHA)
#: Repalce the content with the source content
gx_blending_replace = GlBlending(sfactor=GL_ONE, dfactor=GL_ZERO)
#: Alias to GlAttrib
gx_attrib = GlAttrib
#: Alias to GlBegin
gx_begin = GlBegin
#: Alias to GlBlending()
gx_blending = GlBlending()
#: Alias to GlColor
gx_color = GlColor
#: Alias to GlMatrix()
gx_matrix = GlMatrix()
#: Alias to GlMatrix(do_loadidentity=True)
gx_matrix_identity = GlMatrix(do_loadidentity=True)
#: Alias to GlTexture
gx_texture = GlTexture


########NEW FILE########
__FILENAME__ = stencil
'''
Stencil: use stencil for mask drawing

Usage ::

    with gx_stencil:
        # change viewport
        # draw stuff

'''

__all__ = (
    # stencil
    'GlStencil', 'gx_stencil',
    'stencilPush', 'stencilPop', 'stencilUse',
)

from OpenGL.GL import GL_STENCIL_BUFFER_BIT, GL_STENCIL_TEST, \
        GL_NEVER, GL_INCR, GL_MODELVIEW_MATRIX, GL_EQUAL, GL_KEEP, \
        glColorMask, glPushAttrib, glPopAttrib, glIsEnabled, \
        glEnable, glStencilOp, glStencilFunc, \
        glClear, glClearStencil, glMultMatrixf, glGetFloatv
from pymt.graphx.statement import gx_matrix_identity, GlDisplayList

### Stencil usage
__stencil_stack       = 0
__stencil_stack_dl    = []
__stencil_stack_view  = []
def stencilGetStackLevel():
    return __stencil_stack

def stencilPush():
    '''Create a new stack in stencil stack.
    All the next draw will be done in stencil buffer until
    stencilUse() will be called.'''
    global __stencil_stack
    glPushAttrib(GL_STENCIL_BUFFER_BIT | GL_STENCIL_TEST)

    # enable stencil test if not yet enabled
    if not glIsEnabled(GL_STENCIL_TEST):
        glClearStencil(0)
        glClear(GL_STENCIL_BUFFER_BIT)
        glEnable(GL_STENCIL_TEST)

    # increment the draw buffer
    glStencilFunc(GL_NEVER, 0x0, 0x0)
    glStencilOp(GL_INCR, GL_INCR, GL_INCR)
    glColorMask(0, 0, 0, 0)

    # save model view
    m = glGetFloatv(GL_MODELVIEW_MATRIX)
    __stencil_stack_view.append(m)

    # start recording GL operation
    dl = GlDisplayList()
    dl.start()
    __stencil_stack_dl.append(dl)

    __stencil_stack += 1

def stencilPop():
    '''Pop out the last stack from stencil stack'''
    global __stencil_stack
    glPopAttrib()
    __stencil_stack -= 1

    # remove current stencil stack
    __stencil_stack_dl.pop()
    __stencil_stack_view.pop()

    # replay stencil stack from the start
    # only if it's enabled
    if not glIsEnabled(GL_STENCIL_TEST):
        return

    # clear stencil
    glClearStencil(0)
    glClear(GL_STENCIL_BUFFER_BIT)

    # increment the draw buffer
    glStencilFunc(GL_NEVER, 0x0, 0x0)
    glStencilOp(GL_INCR, GL_INCR, GL_INCR)
    glColorMask(0, 0, 0, 0)

    # replay all gl operation
    for idx in xrange(__stencil_stack):
        dl = __stencil_stack_dl[idx]
        view = __stencil_stack_view[idx]
        with gx_matrix_identity:
            glMultMatrixf(view)
            dl.draw()

    # draw inner content only when stencil match the buffer
    glColorMask(1, 1, 1, 1)
    glStencilFunc(GL_EQUAL, __stencil_stack, __stencil_stack)
    glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP)

def stencilUse():
    '''Switch from stencil draw to color draw.
    Now, all drawing will be done on color buffer,
    using latest stencil stack.
    '''
    # stop recording gl operation
    __stencil_stack_dl[__stencil_stack-1].stop()
    __stencil_stack_dl[__stencil_stack-1].draw()

    # draw inner content only when stencil match the buffer
    glColorMask(1, 1, 1, 1)
    glStencilFunc(GL_EQUAL, __stencil_stack, __stencil_stack)
    glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP)

class GlStencil:
    '''Statement of stencilPush/stencilPop, designed to be use with
    "with" keyword.

    Alias: gx_stencil.
    '''
    def __init__(self):
        pass

    def __enter__(self):
        stencilPush()

    def __exit__(self, type, value, traceback):
        stencilPop()

#: Alias to GlStencil()
gx_stencil = GlStencil()

########NEW FILE########
__FILENAME__ = factory
'''
Touch Factory: Factory of touch providers.
'''

__all__ = ('TouchFactory', )

class TouchFactory:
    '''Touch factory is a class who register all availables input factories.
    If you create a new input factory, don't forget to register it ::

        TouchFactory.register('myproviderid', MyInputProvider)

    '''
    __providers__ = {}

    @staticmethod
    def register(name, classname):
        '''Register a input provider in the database'''
        TouchFactory.__providers__[name] = classname

    @staticmethod
    def list():
        '''Get a list of all providers availables'''
        return TouchFactory.__providers__

    @staticmethod
    def get(name):
        '''Get a provider class from provider id'''
        if name in TouchFactory.__providers__:
            return TouchFactory.__providers__[name]
        return None

########NEW FILE########
__FILENAME__ = dejitter
'''
Dejitter: Prevent blob jittering.

A problem that is often faced (esp. in optical MT setups) is that of
jitterish BLOBs caused by bad camera characteristics. With this module
you can get rid of that jitter. You just define a threshold
`jitter_distance` in your config, and all touch movements that move
the touch by less than the jitter distance are considered 'bad'
movements caused by jitter and will be discarded.
'''

__all__ = ('InputPostprocDejitter', )

from pymt.config import pymt_config

class InputPostprocDejitter(object):
    '''
    Get rid of jitterish BLOBs.
    Example ::

        [pymt]
        jitter_distance = 0.004
        jitter_ignore_devices = mouse,mactouch

    :Configuration:
        `jitter_distance`: float
            A float in range 0-1.
        `jitter_ignore_devices`: string
            A comma-seperated list of device identifiers that
            should not be processed by dejitter (because they're
            very precise already).
    '''
    def __init__(self):
        self.jitterdist = pymt_config.getfloat('pymt', 'jitter_distance')
        ignore_devices = pymt_config.get('pymt', 'jitter_ignore_devices')
        self.ignore_devices = ignore_devices.split(',')
        self.last_touches = {}

    def taxicab_distance(self, p, q):
        # Get the taxicab/manhattan/citiblock distance for efficiency reasons
        return abs(p[0]-q[0]) + abs(p[1]-q[1])

    def process(self, events):
        if not self.jitterdist:
            return events
        processed = []
        for type, touch in events:
            if touch.device in self.ignore_devices:
                processed.append((type, touch))
                continue
            if type == 'down':
                self.last_touches[touch.id] = touch.spos
            if type == 'up':
                del self.last_touches[touch.id]
            if type != 'move':
                processed.append((type, touch))
                continue
            # Check whether the touch moved more than the jitter distance
            last_spos = self.last_touches[touch.id]
            dist = self.taxicab_distance(last_spos, touch.spos)
            if dist > self.jitterdist:
                # Only if the touch has moved more than the jitter dist we take
                # it into account and dispatch it. Otherwise suppress it.
                self.last_touches[touch.id] = touch.spos
                processed.append((type, touch))
        return processed

########NEW FILE########
__FILENAME__ = doubletap
'''
Double Tap: search touch for a double tap
'''

__all__ = ('InputPostprocDoubleTap', )

from pymt.config import pymt_config
from pymt.vector import Vector
from pymt.clock import getClock

class InputPostprocDoubleTap(object):
    '''
    InputPostProcDoubleTap is a post-processor to check if a touch is a double tap or not.
    Double tap can be configured in the PyMT config file ::

        [pymt]
            double_tap_time = 250
            double_tap_distance = 20

    Distance parameter is in 0-1000, and time is in millisecond.
    '''
    def __init__(self):
        self.double_tap_distance = pymt_config.getint('pymt', 'double_tap_distance') / 1000.0
        self.double_tap_time = pymt_config.getint('pymt', 'double_tap_time') / 1000.0
        self.touches = {}

    def find_double_tap(self, ref):
        '''Find a double tap touch within self.touches.
        The touch must be not a previous double tap, and the distance must be
        ok'''
        for touchid in self.touches:
            if ref.uid == touchid:
                continue
            type, touch = self.touches[touchid]
            if type != 'up':
                continue
            if touch.is_double_tap:
                continue
            distance = Vector.distance(
                Vector(ref.sx, ref.sy),
                Vector(touch.osxpos, touch.osypos))
            if distance > self.double_tap_distance:
                continue
            touch.double_tap_distance = distance
            return touch
        return None


    def process(self, events):
        # first, check if a touch down have a double tap
        for type, touch in events:
            if type == 'down':
                touch_double_tap = self.find_double_tap(touch)
                if touch_double_tap:
                    touch.is_double_tap = True
                    touch.double_tap_time = touch.time_start - touch_double_tap.time_start
                    touch.double_tap_distance = touch_double_tap.double_tap_distance

            # add the touch internaly
            self.touches[touch.uid] = (type, touch)

        # second, check if up-touch is timeout for double tap
        time_current = getClock().get_time()
        for touchid in self.touches.keys()[:]:
            type, touch = self.touches[touchid]
            if type != 'up':
                continue
            if time_current - touch.time_start < self.double_tap_time:
                continue
            del self.touches[touchid]

        return events

########NEW FILE########
__FILENAME__ = ignorelist
'''
Ignore list: ignore touch in some part on screen
'''

__all__ = ('InputPostprocIgnoreList', )

from pymt.config import pymt_config
from pymt.utils import strtotuple

class InputPostprocIgnoreList(object):
    '''
    InputPostprocIgnoreList is a post-processor who remove touch in ignore list.
    Ignore list can be configured in the PyMT config file ::

        [pymt]
        # Format: [(xmin, ymin, xmax, ymax), ...]
        ignore = [(0.1, 0.1, 0.15, 0.15)]

    Ignore list coordinate are in 0-1, not in the screen width/height.
    '''
    def __init__(self):
        self.ignore_list = strtotuple(pymt_config.get('pymt', 'ignore'))

    def collide_ignore(self, touch):
        x, y = touch.sx, touch.sy
        for l in self.ignore_list:
            xmin, ymin, xmax, ymax = l
            if x > xmin and x < xmax and y > ymin and y < ymax:
                return True

    def process(self, events):
        if not len(self.ignore_list):
            return events
        for type, touch in events:
            if type != 'down':
                continue
            if self.collide_ignore(touch):
                touch.userdata['__ignore__'] = True
        return [(type, touch) for type, touch in events \
                if not '__ignore__' in touch.userdata]

########NEW FILE########
__FILENAME__ = retaintouch
'''
Retain Touch: reuse touch to counter finger lost behavior
'''

__all__ = ('InputPostprocRetainTouch', )

from pymt.config import pymt_config
from pymt.vector import Vector
import time

class InputPostprocRetainTouch(object):
    '''
    InputPostprocRetainTouch is a post-processor to delay the 'up' event of a
    touch, to reuse it under certains conditions. This module is designed to
    prevent finger lost on some hardware/setup.

    Retain touch can be configured in the PyMT config file ::

        [pymt]
            retain_time = 100
            retain_distance = 50

    Distance parameter is in 0-1000, and time is in millisecond.
    '''
    def __init__(self):
        self.timeout = pymt_config.getint('pymt', 'retain_time') / 1000.0
        self.distance = pymt_config.getint('pymt', 'retain_distance') / 1000.0
        self._available = []
        self._links = {}

    def process(self, events):
        # check if module is disabled
        if self.timeout == 0:
            return events

        d = time.time()
        for type, touch in events[:]:
            if type == 'up':
                events.remove((type, touch))
                if touch.uid in self._links:
                    selection = self._links[touch.uid]
                    selection.userdata['__retain_time'] = d
                    self._available.append(selection)
                    del self._links[touch.uid]
                else:
                    touch.userdata['__retain_time'] = d
                    self._available.append(touch)
            elif type == 'move':
                if touch.uid in self._links:
                    selection = self._links[touch.uid]
                    selection.x = touch.x
                    selection.y = touch.y
                    selection.sx = touch.sx
                    selection.sy = touch.sy
                    events.remove((type, touch))
                    events.append((type, selection))
                else:
                    pass
            elif type == 'down':
                # new touch, found the nearest one
                selection = None
                selection_distance = 99999
                for touch2 in self._available:
                    touch_distance = Vector(touch2.spos).distance(touch.spos)
                    if touch_distance > self.distance:
                        continue
                    if touch2.__class__ != touch.__class__:
                        continue
                    if touch_distance < selection_distance:
                        # eligible for continuation
                        selection_distance = touch_distance
                        selection = touch2
                if selection is None:
                    continue

                self._links[touch.uid] = selection
                self._available.remove(selection)
                events.remove((type, touch))

        for touch in self._available[:]:
            t = touch.userdata['__retain_time']
            if d - t > self.timeout:
                self._available.remove(touch)
                events.append(('up', touch))

        return events

########NEW FILE########
__FILENAME__ = provider
'''
Touch Provider: Abstract class for a provider
'''

__all__ = ('TouchProvider', )

class TouchProvider(object):

    def __init__(self, device, args):
        self.device = device
        if self.__class__ == TouchProvider:
            raise NotImplementedError, 'class TouchProvider is abstract'

    def start(self):
        pass

    def stop(self):
        pass

    def update(self, dispatch_fn):
        pass

########NEW FILE########
__FILENAME__ = hidinput
'''
HIDInput: Native support of HID input from linux kernel

Support start from 2.6.32-ubuntu, or 2.6.34.

To configure HIDInput, put in your configuration ::

    [input]
    # devicename = hidinput,/dev/input/eventXX
    # example with Stantum MTP4.3" screen
    stantum = hidinput,/dev/input/event2

.. note::
    You must have read access to the input event.

You have the possibility to use custom range for some X, Y and pressure value.
On some drivers, the range reported is invalid.
To fix that, you can add one of theses options on the argument line :

* invert_x : 1 to invert X axis
* invert_y : 1 to invert Y axis
* min_position_x : X minimum
* max_position_x : X maximum
* min_position_y : Y minimum
* max_position_y : Y maximum
* min_pressure : pressure minimum
* max_pressure : pressure maximum

For example, on Asus T101M, the touchscreen report a range from 0-4095 for X and
Y value, but real value are in a range from 0-32768. You can put it on
configuration ::

    [input]
    t101m = hidinput,/dev/input/event7,max_position_x=32768,max_position_y=32768

'''

__all__ = ('HIDInputTouchProvider', 'HIDTouch')

import os
from pymt.input.touch import Touch
from pymt.input.shape import TouchShapeRect

class HIDTouch(Touch):
    def depack(self, args):
        self.sx = args['x']
        self.sy = args['y']
        self.profile = ['pos']
        if 'size_w' in args and 'size_h' in args:
            self.shape = TouchShapeRect()
            self.shape.width = args['size_w']
            self.shape.height = args['size_h']
            self.profile.append('shape')
        if 'pressure' in args:
            self.pressure = args['pressure']
            self.profile.append('pressure')
        super(HIDTouch, self).depack(args)

    def __str__(self):
        return '<HIDTouch id=%d pos=(%f, %f) device=%s>' % (self.id, self.sx, self.sy, self.device)

if 'PYMT_DOC' in os.environ:
    # documentation hack
    HIDInputTouchProvider = None

else:
    import threading
    import collections
    import struct
    import fcntl
    from pymt.input.provider import TouchProvider
    from pymt.input.factory import TouchFactory
    from pymt.logger import pymt_logger

    #
    # This part is taken from linux-source-2.6.32/include/linux/input.h
    #

    # Event types
    EV_SYN		    = 0x00
    EV_KEY		    = 0x01
    EV_REL		    = 0x02
    EV_ABS		    = 0x03
    EV_MSC		    = 0x04
    EV_SW		    = 0x05
    EV_LED		    = 0x11
    EV_SND		    = 0x12
    EV_REP		    = 0x14
    EV_FF		    = 0x15
    EV_PWR		    = 0x16
    EV_FF_STATUS    = 0x17
    EV_MAX		    = 0x1f
    EV_CNT		    = (EV_MAX+1)

    KEY_MAX			= 0x2ff

    # Synchronization events
    SYN_REPORT		= 0
    SYN_CONFIG		= 1
    SYN_MT_REPORT	= 2

    # Misc events
    MSC_SERIAL	    = 0x00
    MSC_PULSELED    = 0x01
    MSC_GESTURE	    = 0x02
    MSC_RAW		    = 0x03
    MSC_SCAN	    = 0x04
    MSC_MAX		    = 0x07
    MSC_CNT		    = (MSC_MAX+1)

    ABS_MT_TOUCH_MAJOR  = 0x30	# Major axis of touching ellipse
    ABS_MT_TOUCH_MINOR  = 0x31	# Minor axis (omit if circular)
    ABS_MT_WIDTH_MAJOR  = 0x32	# Major axis of approaching ellipse
    ABS_MT_WIDTH_MINOR  = 0x33	# Minor axis (omit if circular)
    ABS_MT_ORIENTATION  = 0x34	# Ellipse orientation
    ABS_MT_POSITION_X   = 0x35	# Center X ellipse position
    ABS_MT_POSITION_Y   = 0x36	# Center Y ellipse position
    ABS_MT_TOOL_TYPE    = 0x37	# Type of touching device
    ABS_MT_BLOB_ID	    = 0x38	# Group a set of packets as a blob
    ABS_MT_TRACKING_ID  = 0x39	# Unique ID of initiated contact
    ABS_MT_PRESSURE		= 0x3a	# Pressure on contact area

    # some ioctl base (with 0 value)
    EVIOCGNAME = 2147501318
    EVIOCGBIT = 2147501344
    EVIOCGABS = 2149074240

    # sizeof(struct input_event)
    struct_input_event_sz = struct.calcsize('LLHHi')
    struct_input_absinfo_sz = struct.calcsize('iiiiii')
    sz_l = struct.calcsize('Q')

    class HIDInputTouchProvider(TouchProvider):

        options = ('min_position_x', 'max_position_x',
                   'min_position_y', 'max_position_y',
                   'min_pressure', 'max_pressure',
                   'invert_x', 'invert_y')

        def __init__(self, device, args):
            super(HIDInputTouchProvider, self).__init__(device, args)
            self.input_fn = None
            self.default_ranges = dict()

            # split arguments
            args = args.split(',')
            if not args:
                pymt_logger.error('HIDInput: No filename pass to HIDInput configuration')
                pymt_logger.error('HIDInput: Use /dev/input/event0 for example')
                return None

            # read filename
            self.input_fn = args[0]
            pymt_logger.info('HIDInput: Read event from <%s>' % self.input_fn)

            # read parameters
            for arg in args[1:]:
                if arg == '':
                    continue
                arg = arg.split('=')

                # ensure it's a key = value
                if len(arg) != 2:
                    pymt_logger.error('HIDInput: invalid parameter %s, not in key=value format.' % arg)
                    continue

                # ensure the key exist
                key, value = arg
                if key not in HIDInputTouchProvider.options:
                    pymt_logger.error('HIDInput: unknown %s option' % key)
                    continue

                # ensure the value
                try:
                    self.default_ranges[key] = int(value)
                except ValueError:
                    pymt_logger.error('HIDInput: invalid value %s for option %s' % (key, value))
                    continue

                # all good!
                pymt_logger.info('HIDInput: Set custom %s to %d' % (key, int(value)))


        def start(self):
            if self.input_fn is None:
                return
            self.uid = 0
            self.queue = collections.deque()
            self.thread = threading.Thread(
                target=self._thread_run,
                kwargs=dict(
                    queue=self.queue,
                    input_fn=self.input_fn,
                    device=self.device,
                    default_ranges=self.default_ranges
                ))
            self.thread.daemon = True
            self.thread.start()

        def _thread_run(self, **kwargs):
            input_fn = kwargs.get('input_fn')
            queue = kwargs.get('queue')
            device = kwargs.get('device')
            drs = kwargs.get('default_ranges').get
            touches = {}
            touches_sent = []
            point = {}
            l_points = []

            # prepare some vars to get limit of some component
            range_min_position_x    = 0
            range_max_position_x    = 2048
            range_min_position_y    = 0
            range_max_position_y    = 2048
            range_min_pressure      = 0
            range_max_pressure      = 255
            invert_x                = int(bool(drs('invert_x', 0)))
            invert_y                = int(bool(drs('invert_y', 0)))

            def process(points):
                actives = [args['id'] for args in points]
                for args in points:
                    tid = args['id']
                    try:
                        touch = touches[tid]
                        if touch.sx == args['x'] and touch.sy == args['y']:
                            continue
                        touch.move(args)
                        if tid not in touches_sent:
                            queue.append(('down', touch))
                            touches_sent.append(tid)
                        queue.append(('move', touch))
                    except KeyError:
                        touch = HIDTouch(device, tid, args)
                        touches[touch.id] = touch

                for tid in touches.keys()[:]:
                    if tid not in actives:
                        touch = touches[tid]
                        if tid in touches_sent:
                            queue.append(('up', touch))
                            touches_sent.remove(tid)
                        del touches[tid]

            def normalize(value, vmin, vmax):
                return (value - vmin) / float(vmax - vmin)

            # open the input
            fd = open(input_fn, 'rb')

            # get the controler name (EVIOCGNAME)
            device_name = fcntl.ioctl(fd, EVIOCGNAME + (256 << 16), " " * 256).split('\x00')[0]
            pymt_logger.info('HIDTouch: using <%s>' % device_name)

            # get abs infos
            bit = fcntl.ioctl(fd, EVIOCGBIT + (EV_MAX << 16), ' ' * sz_l)
            bit, = struct.unpack('Q', bit)
            for x in xrange(EV_MAX):
                # preserve this, we may want other things than EV_ABS
                if x != EV_ABS:
                    continue
                # EV_ABS available for this device ?
                if (bit & (1 << x)) == 0:
                    continue
                # ask abs info keys to the devices
                sbit = fcntl.ioctl(fd, EVIOCGBIT + x + (KEY_MAX << 16), ' ' * sz_l)
                sbit, = struct.unpack('Q', sbit)
                for y in xrange(KEY_MAX):
                    if (sbit & (1 << y)) == 0:
                        continue
                    absinfo = fcntl.ioctl(fd, EVIOCGABS + y +
                                          (struct_input_absinfo_sz << 16),
                                          ' ' * struct_input_absinfo_sz)
                    abs_value, abs_min, abs_max, abs_fuzz, \
                        abs_flat, abs_res = struct.unpack('iiiiii', absinfo)
                    if y == ABS_MT_POSITION_X:
                        range_min_position_x = drs('min_position_x', abs_min)
                        range_max_position_x = drs('max_position_x', abs_max)
                        pymt_logger.info('HIDTouch: ' +
                            '<%s> range position X is %d - %d' % (
                            device_name, abs_min, abs_max))
                    elif y == ABS_MT_POSITION_Y:
                        range_min_position_y = drs('min_position_y', abs_min)
                        range_max_position_y = drs('max_position_y', abs_max)
                        pymt_logger.info('HIDTouch: ' +
                            '<%s> range position Y is %d - %d' % (
                            device_name, abs_min, abs_max))
                    elif y == ABS_MT_PRESSURE:
                        range_min_pressure = drs('min_pressure', abs_min)
                        range_max_pressure = drs('max_pressure', abs_max)
                        pymt_logger.info('HIDTouch: ' +
                            '<%s> range pressure is %d - %d' % (
                            device_name, abs_min, abs_max))

            # read until the end
            while fd:

                data = fd.read(struct_input_event_sz)
                if len(data) < struct_input_event_sz:
                    break

                # extract each event
                for i in xrange(len(data) / struct_input_event_sz):
                    ev = data[i * struct_input_event_sz:]

                    # extract timeval + event infos
                    tv_sec, tv_usec, ev_type, ev_code, ev_value = \
                            struct.unpack('LLHHi', ev[:struct_input_event_sz])

                    # sync event
                    if ev_type == EV_SYN:
                        if ev_code == SYN_MT_REPORT:
                            if 'id' not in point:
                                continue
                            l_points.append(point)
                        elif ev_code == SYN_REPORT:
                            process(l_points)
                            l_points = []

                    elif ev_type == EV_MSC and ev_code in (MSC_RAW, MSC_SCAN):
                        pass

                    else:
                        # compute multitouch track
                        if ev_code == ABS_MT_TRACKING_ID:
                            point = {}
                            point['id'] = ev_value
                        elif ev_code == ABS_MT_POSITION_X:
                            val = normalize(ev_value,
                                range_min_position_x, range_max_position_x)
                            if invert_x:
                                val = 1. - val
                            point['x'] = val
                        elif ev_code == ABS_MT_POSITION_Y:
                            val = 1. - normalize(ev_value,
                                range_min_position_y, range_max_position_y)
                            if invert_y:
                                val = 1. - val
                            point['y'] = val
                        elif ev_code == ABS_MT_ORIENTATION:
                            point['orientation'] = ev_value
                        elif ev_code == ABS_MT_BLOB_ID:
                            point['blobid'] = ev_value
                        elif ev_code == ABS_MT_PRESSURE:
                            point['pressure'] = normalize(ev_value,
                                range_min_pressure, range_max_pressure)
                        elif ev_code == ABS_MT_TOUCH_MAJOR:
                            point['size_w'] = ev_value
                        elif ev_code == ABS_MT_TOUCH_MINOR:
                            point['size_h'] = ev_value

        def update(self, dispatch_fn):
            # dispatch all event from threads
            try:
                while True:
                    event_type, touch = self.queue.popleft()
                    dispatch_fn(event_type, touch)
            except:
                pass


    TouchFactory.register('hidinput', HIDInputTouchProvider)

########NEW FILE########
__FILENAME__ = linuxwacom
'''
LinuxWacom: Native support of Wacom tablet from linuxwacom driver

To configure LinuxWacom, put in your configuration ::

    [input]
    pen = linuxwacom,/dev/input/event2,mode=pen
    finger = linuxwacom,/dev/input/event3,mode=touch

.. note::
    You must have read access to the input event.

You have the possibility to use custom range for some X, Y and pressure value.
On some drivers, the range reported is invalid.
To fix that, you can add one of theses options on the argument line :

* invert_x : 1 to invert X axis
* invert_y : 1 to invert Y axis
* min_position_x : X minimum
* max_position_x : X maximum
* min_position_y : Y minimum
* max_position_y : Y maximum
* min_pressure : pressure minimum
* max_pressure : pressure maximum
'''

__all__ = ('LinuxWacomTouchProvider', 'LinuxWacomTouch')

import os
from pymt.input.touch import Touch
from pymt.input.shape import TouchShapeRect

class LinuxWacomTouch(Touch):
    def depack(self, args):
        self.sx = args['x']
        self.sy = args['y']
        self.profile = ['pos']
        if 'size_w' in args and 'size_h' in args:
            self.shape = TouchShapeRect()
            self.shape.width = args['size_w']
            self.shape.height = args['size_h']
            self.profile.append('shape')
        if 'pressure' in args:
            self.pressure = args['pressure']
            self.profile.append('pressure')
        super(LinuxWacomTouch, self).depack(args)

    def __str__(self):
        return '<LinuxWacomTouch id=%d pos=(%f, %f) device=%s>' % (self.id, self.sx, self.sy, self.device)

if 'PYMT_DOC' in os.environ:
    # documentation hack
    LinuxWacomTouchProvider = None

else:
    import threading
    import collections
    import struct
    import fcntl
    from pymt.input.provider import TouchProvider
    from pymt.input.factory import TouchFactory
    from pymt.logger import pymt_logger

    #
    # This part is taken from linux-source-2.6.32/include/linux/input.h
    #

    # Event types
    EV_SYN		    = 0x00
    EV_KEY		    = 0x01
    EV_REL		    = 0x02
    EV_ABS		    = 0x03
    EV_MSC		    = 0x04
    EV_SW		    = 0x05
    EV_LED		    = 0x11
    EV_SND		    = 0x12
    EV_REP		    = 0x14
    EV_FF		    = 0x15
    EV_PWR		    = 0x16
    EV_FF_STATUS    = 0x17
    EV_MAX		    = 0x1f
    EV_CNT		    = (EV_MAX+1)

    KEY_MAX			= 0x2ff

    # Synchronization events
    SYN_REPORT		= 0
    SYN_CONFIG		= 1
    SYN_MT_REPORT	= 2

    # Misc events
    MSC_SERIAL	    = 0x00
    MSC_PULSELED    = 0x01
    MSC_GESTURE	    = 0x02
    MSC_RAW		    = 0x03
    MSC_SCAN	    = 0x04
    MSC_MAX		    = 0x07
    MSC_CNT		    = (MSC_MAX+1)

    ABS_X               = 0x00
    ABS_Y               = 0x01
    ABS_PRESSURE        = 0x18
    ABS_MISC            = 0x28  # if 0, it's touch up
    ABS_MT_TOUCH_MAJOR  = 0x30	# Major axis of touching ellipse
    ABS_MT_TOUCH_MINOR  = 0x31	# Minor axis (omit if circular)
    ABS_MT_WIDTH_MAJOR  = 0x32	# Major axis of approaching ellipse
    ABS_MT_WIDTH_MINOR  = 0x33	# Minor axis (omit if circular)
    ABS_MT_ORIENTATION  = 0x34	# Ellipse orientation
    ABS_MT_POSITION_X   = 0x35	# Center X ellipse position
    ABS_MT_POSITION_Y   = 0x36	# Center Y ellipse position
    ABS_MT_TOOL_TYPE    = 0x37	# Type of touching device
    ABS_MT_BLOB_ID	    = 0x38	# Group a set of packets as a blob
    ABS_MT_TRACKING_ID  = 0x39	# Unique ID of initiated contact
    ABS_MT_PRESSURE		= 0x3a	# Pressure on contact area

    # some ioctl base (with 0 value)
    EVIOCGNAME = 2147501318
    EVIOCGBIT = 2147501344
    EVIOCGABS = 2149074240

    # sizeof(struct input_event)
    struct_input_event_sz = struct.calcsize('LLHHi')
    struct_input_absinfo_sz = struct.calcsize('iiiiii')
    sz_l = struct.calcsize('Q')

    class LinuxWacomTouchProvider(TouchProvider):

        options = ('min_position_x', 'max_position_x',
                   'min_position_y', 'max_position_y',
                   'min_pressure', 'max_pressure',
                   'invert_x', 'invert_y')

        def __init__(self, device, args):
            super(LinuxWacomTouchProvider, self).__init__(device, args)
            self.input_fn = None
            self.default_ranges = dict()
            self.mode = 'touch'

            # split arguments
            args = args.split(',')
            if not args:
                pymt_logger.error('LinuxWacom: No filename pass to LinuxWacom configuration')
                pymt_logger.error('LinuxWacom: Use /dev/input/event0 for example')
                return None

            # read filename
            self.input_fn = args[0]
            pymt_logger.info('LinuxWacom: Read event from <%s>' % self.input_fn)

            # read parameters
            for arg in args[1:]:
                if arg == '':
                    continue
                arg = arg.split('=')

                # ensure it's a key = value
                if len(arg) != 2:
                    pymt_logger.error('LinuxWacom: invalid parameter %s, not in key=value format.' % arg)
                    continue

                # ensure the key exist
                key, value = arg
                if key == 'mode':
                    self.mode = value
                    continue

                if key not in LinuxWacomTouchProvider.options:
                    pymt_logger.error('LinuxWacom: unknown %s option' % key)
                    continue

                # ensure the value
                try:
                    self.default_ranges[key] = int(value)
                except ValueError:
                    pymt_logger.error('LinuxWacom: invalid value %s for option %s' % (key, value))
                    continue

                # all good!
                pymt_logger.info('LinuxWacom: Set custom %s to %d' % (key, int(value)))
            pymt_logger.info('LinuxWacom: mode is <%s>' % self.mode)


        def start(self):
            if self.input_fn is None:
                return
            self.uid = 0
            self.queue = collections.deque()
            self.thread = threading.Thread(
                target=self._thread_run,
                kwargs=dict(
                    queue=self.queue,
                    input_fn=self.input_fn,
                    device=self.device,
                    default_ranges=self.default_ranges
                ))
            self.thread.daemon = True
            self.thread.start()

        def _thread_run(self, **kwargs):
            input_fn = kwargs.get('input_fn')
            queue = kwargs.get('queue')
            device = kwargs.get('device')
            drs = kwargs.get('default_ranges').get
            touches = {}
            touches_sent = []
            point = {}
            l_points = {}

            # prepare some vars to get limit of some component
            range_min_position_x    = 0
            range_max_position_x    = 2048
            range_min_position_y    = 0
            range_max_position_y    = 2048
            range_min_pressure      = 0
            range_max_pressure      = 255
            invert_x                = int(bool(drs('invert_x', 0)))
            invert_y                = int(bool(drs('invert_y', 0)))
            reset_touch             = False

            def process(points):
                actives = points.keys()
                for args in points.itervalues():
                    tid = args['id']
                    try:
                        touch = touches[tid]
                    except KeyError:
                        touch = LinuxWacomTouch(device, tid, args)
                        touches[touch.id] = touch
                    if touch.sx == args['x'] and touch.sy == args['y'] and tid in touches_sent:
                        continue
                    touch.move(args)
                    if tid not in touches_sent:
                        queue.append(('down', touch))
                        touches_sent.append(tid)
                    queue.append(('move', touch))

                for tid in touches.keys()[:]:
                    if tid not in actives:
                        touch = touches[tid]
                        if tid in touches_sent:
                            queue.append(('up', touch))
                            touches_sent.remove(tid)
                        del touches[tid]

            def normalize(value, vmin, vmax):
                return (value - vmin) / float(vmax - vmin)

            # open the input
            fd = open(input_fn, 'rb')

            # get the controler name (EVIOCGNAME)
            device_name = fcntl.ioctl(fd, EVIOCGNAME + (256 << 16), " " * 256).split('\x00')[0]
            pymt_logger.info('LinuxWacomTouch: using <%s>' % device_name)

            # get abs infos
            bit = fcntl.ioctl(fd, EVIOCGBIT + (EV_MAX << 16), ' ' * sz_l)
            bit, = struct.unpack('Q', bit)
            for x in xrange(EV_MAX):
                # preserve this, we may want other things than EV_ABS
                if x != EV_ABS:
                    continue
                # EV_ABS available for this device ?
                if (bit & (1 << x)) == 0:
                    continue
                # ask abs info keys to the devices
                sbit = fcntl.ioctl(fd, EVIOCGBIT + x + (KEY_MAX << 16), ' ' * sz_l)
                sbit, = struct.unpack('Q', sbit)
                for y in xrange(KEY_MAX):
                    if (sbit & (1 << y)) == 0:
                        continue
                    absinfo = fcntl.ioctl(fd, EVIOCGABS + y +
                                          (struct_input_absinfo_sz << 16),
                                          ' ' * struct_input_absinfo_sz)
                    abs_value, abs_min, abs_max, abs_fuzz, \
                        abs_flat, abs_res = struct.unpack('iiiiii', absinfo)
                    if y == ABS_X:
                        range_min_position_x = drs('min_position_x', abs_min)
                        range_max_position_x = drs('max_position_x', abs_max)
                        pymt_logger.info('LinuxWacomTouch: ' +
                            '<%s> range position X is %d - %d' % (
                            device_name, abs_min, abs_max))
                    elif y == ABS_Y:
                        range_min_position_y = drs('min_position_y', abs_min)
                        range_max_position_y = drs('max_position_y', abs_max)
                        pymt_logger.info('LinuxWacomTouch: ' +
                            '<%s> range position Y is %d - %d' % (
                            device_name, abs_min, abs_max))
                    elif y == ABS_PRESSURE:
                        range_min_pressure = drs('min_pressure', abs_min)
                        range_max_pressure = drs('max_pressure', abs_max)
                        pymt_logger.info('LinuxWacomTouch: ' +
                            '<%s> range pressure is %d - %d' % (
                            device_name, abs_min, abs_max))

            # read until the end
            point = {}
            changed = False
            touch_id = 0
            touch_x = 0
            touch_y = 0
            touch_pressure = 0
            while fd:

                data = fd.read(struct_input_event_sz)
                if len(data) < struct_input_event_sz:
                    break

                # extract each event
                for i in xrange(len(data) / struct_input_event_sz):
                    ev = data[i * struct_input_event_sz:]

                    # extract timeval + event infos
                    tv_sec, tv_usec, ev_type, ev_code, ev_value = \
                            struct.unpack('LLHHi', ev[:struct_input_event_sz])

                    if ev_type == EV_SYN and ev_code == SYN_REPORT:
                        if touch_id in l_points:
                            p = l_points[touch_id]
                        else:
                            p = dict()
                            l_points[touch_id] = p
                        p['id'] = touch_id
                        if reset_touch is False:
                            p['x'] = touch_x
                            p['y'] = touch_y
                            p['pressure'] = touch_pressure
                        if self.mode == 'pen' and touch_pressure == 0 and not reset_touch:
                            del l_points[touch_id]
                        if changed:
                            if not 'x' in p:
                                reset_touch = False
                                continue
                            process(l_points)
                            changed = False
                        if reset_touch:
                            l_points.clear()
                            reset_touch = False
                            process(l_points)
                        point = {}
                    elif ev_type == EV_MSC and ev_code == MSC_SERIAL:
                        touch_id = ev_value
                    elif ev_type == EV_ABS and ev_code == ABS_X:
                        val = normalize(ev_value,
                            range_min_position_x, range_max_position_x)
                        if invert_x:
                            val = 1. - val
                        touch_x = val
                        changed = True
                    elif ev_type == EV_ABS and ev_code == ABS_Y:
                        val = 1. - normalize(ev_value,
                            range_min_position_y, range_max_position_y)
                        if invert_y:
                            val = 1. - val
                        touch_y = val
                        changed = True
                    elif ev_type == EV_ABS and ev_code == ABS_PRESSURE:
                        touch_pressure = normalize(ev_value,
                            range_min_pressure, range_max_pressure)
                        changed = True
                    elif ev_type == EV_ABS and ev_code == ABS_MISC:
                        if ev_value == 0:
                            reset_touch = True

        def update(self, dispatch_fn):
            # dispatch all event from threads
            try:
                while True:
                    event_type, touch = self.queue.popleft()
                    dispatch_fn(event_type, touch)
            except:
                pass


    TouchFactory.register('linuxwacom', LinuxWacomTouchProvider)

########NEW FILE########
__FILENAME__ = mactouch
'''
MacTouch: Native support of MultitouchSupport framework for MacBook (MaxOSX platform)
'''

__all__ = ('MacTouchProvider', )

import ctypes
import threading
import collections
import os
from pymt.input.provider import TouchProvider
from pymt.input.factory import TouchFactory
from pymt.input.touch import Touch
from pymt.input.shape import TouchShapeRect

if 'PYMT_DOC' not in os.environ:
	CFArrayRef = ctypes.c_void_p
	CFMutableArrayRef = ctypes.c_void_p
	CFIndex = ctypes.c_long

	MultitouchSupport = ctypes.CDLL('/System/Library/PrivateFrameworks/MultitouchSupport.framework/MultitouchSupport')

	CFArrayGetCount = MultitouchSupport.CFArrayGetCount
	CFArrayGetCount.argtypes = [CFArrayRef]
	CFArrayGetCount.restype = CFIndex

	CFArrayGetValueAtIndex = MultitouchSupport.CFArrayGetValueAtIndex
	CFArrayGetValueAtIndex.argtypes = [CFArrayRef, CFIndex]
	CFArrayGetValueAtIndex.restype = ctypes.c_void_p

	MTDeviceCreateList = MultitouchSupport.MTDeviceCreateList
	MTDeviceCreateList.argtypes = []
	MTDeviceCreateList.restype = CFMutableArrayRef

	class MTPoint(ctypes.Structure):
		_fields_ = [('x', ctypes.c_float),
					('y', ctypes.c_float)]

	class MTVector(ctypes.Structure):
		_fields_ = [('position', MTPoint),
					('velocity', MTPoint)]

	class MTData(ctypes.Structure):
		_fields_ = [
		  ('frame', ctypes.c_int),
		  ('timestamp', ctypes.c_double),
		  ('identifier', ctypes.c_int),
		  ('state', ctypes.c_int),  # Current state (of unknown meaning).
		  ('unknown1', ctypes.c_int),
		  ('unknown2', ctypes.c_int),
		  ('normalized', MTVector),  # Normalized position and vector of
									 # the touch (0 to 1).
		  ('size', ctypes.c_float),  # The area of the touch.
		  ('unknown3', ctypes.c_int),
		  # The following three define the ellipsoid of a finger.
		  ('angle', ctypes.c_float),
		  ('major_axis', ctypes.c_float),
		  ('minor_axis', ctypes.c_float),
		  ('unknown4', MTVector),
		  ('unknown5_1', ctypes.c_int),
		  ('unknown5_2', ctypes.c_int),
		  ('unknown6', ctypes.c_float),
		]

	MTDataRef = ctypes.POINTER(MTData)

	MTContactCallbackFunction = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, MTDataRef,
		ctypes.c_int, ctypes.c_double, ctypes.c_int)

	MTDeviceRef = ctypes.c_void_p

	MTRegisterContactFrameCallback = MultitouchSupport.MTRegisterContactFrameCallback
	MTRegisterContactFrameCallback.argtypes = [MTDeviceRef, MTContactCallbackFunction]
	MTRegisterContactFrameCallback.restype = None

	MTDeviceStart = MultitouchSupport.MTDeviceStart
	MTDeviceStart.argtypes = [MTDeviceRef, ctypes.c_int]
	MTDeviceStart.restype = None

else:
	MTContactCallbackFunction = lambda x: None


class MacTouch(Touch):
    '''Touch representing a contact point on touchpad. Support pos and shape
    profile'''

    def depack(self, args):
        self.shape = TouchShapeRect()
        self.sx, self.sy = args[0], args[1]
        self.shape.width = args[2]
        self.shape.height = args[2]
        self.profile = ('pos', 'shape')
        super(MacTouch, self).depack(args)

    def __str__(self):
        return '<MacTouch id=%d pos=(%f, %f) device=%s>' % (self.id, self.sx, self.sy, self.device)

_instance = None

class MacTouchProvider(TouchProvider):

    def __init__(self, *largs, **kwargs):
        global _instance
        if _instance is not None:
            raise Exception('Only one MacTouch provider is allowed.')
        _instance = self
        super(MacTouchProvider, self).__init__(*largs, **kwargs)

    def start(self):
        # global uid
        self.uid = 0
        # touches will be per devices
        self.touches = {}
        # lock needed to access on uid
        self.lock = threading.Lock()
        # event queue to dispatch in main thread
        self.queue = collections.deque()

        # ok, listing devices, and attach !
        devices = MultitouchSupport.MTDeviceCreateList()
        num_devices = CFArrayGetCount(devices)
        print 'num_devices =', num_devices
        for i in xrange(num_devices):
            device = CFArrayGetValueAtIndex(devices, i)
            print 'device #%d: %016x' % (i, device)
            # create touch dict for this device
            data_id = str(device)
            self.touches[data_id] = {}
            # start !
            MTRegisterContactFrameCallback(device, self._mts_callback)
            MTDeviceStart(device, 0)

    def update(self, dispatch_fn):
        # dispatch all event from threads
        try:
            while True:
                event_type, touch = self.queue.popleft()
                dispatch_fn(event_type, touch)
        except:
            pass

    def stop(self):
        # i don't known how to stop it...
        pass

    @MTContactCallbackFunction
    def _mts_callback(device, data_ptr, n_fingers, timestamp, frame):
        global _instance
        devid = str(device)

        # XXX create live touch, we get one case that
        # the device announced by macosx don't match the device
        # in _mts_callback....
        if not devid in _instance.touches:
            _instance.touches[devid] = {}

        touches = _instance.touches[devid]
        actives = []

        for i in xrange(n_fingers):
            # get pointer on data
            data = data_ptr[i]

            # add this touch as an active touch
            actives.append(data.identifier)

            # extract identifier
            data_id = data.identifier

            # prepare argument position
            args = (data.normalized.position.x, data.normalized.position.y, data.size)

            if not data_id in touches:
                # increment uid
                _instance.lock.acquire()
                _instance.uid += 1
                # create a touch
                touch = MacTouch(_instance.device, _instance.uid, args)
                _instance.lock.release()
                # create event
                _instance.queue.append(('down', touch))
                # store touch
                touches[data_id] = touch
            else:
                touch = touches[data_id]
                # check if he really moved
                if data.normalized.position.x == touch.sx and \
                   data.normalized.position.y == touch.sy:
                       continue
                touch.move(args)
                _instance.queue.append(('move', touch))

        # delete old touchs
        for tid in touches.keys()[:]:
            if tid not in actives:
                touch = touches[tid]
                _instance.queue.append(('up', touch))
                del touches[tid]

        return 0

TouchFactory.register('mactouch', MacTouchProvider)


########NEW FILE########
__FILENAME__ = mouse
'''
Mouse: Mouse provider implementation

On linux system, mouse provider can be annoying when used with another
multitouch provider (hidinput or mtdev.). Mouse can conflict with them: a single
touch can generate one event from mouse provider and from multitouch provider.

To avoid this behavior, you can activate the "disable_on_activity" token in
mouse. Then, if they are any touch active from another provider, the mouse will
be discarded. Put in your configuration ::

    [input]
    mouse = mouse,disable_on_activity

'''

__all__ = ('MouseTouchProvider', )

from collections import deque
from pymt.logger import pymt_logger
from pymt.base import getCurrentTouches
from pymt.input.provider import TouchProvider
from pymt.input.factory import TouchFactory
from pymt.input.touch import Touch

class MouseTouch(Touch):
    def depack(self, args):
        self.sx, self.sy = args
        super(MouseTouch, self).depack(args)

class MouseTouchProvider(TouchProvider):
    __handlers__ = {}

    def __init__(self, device, args):
        super(MouseTouchProvider, self).__init__(device, args)
        self.waiting_event = deque()
        self.window = None
        self.touches = {}
        self.counter = 0
        self.current_drag = None
        self.alt_touch = None
        self.disable_on_activity = False

        # split arguments
        args = args.split(',')
        for arg in args:
            if arg == '':
                continue
            elif arg == 'disable_on_activity':
                self.disable_on_activity = True
            else:
                pymt_logger.error('Mouse: unknown parameter <%s>' % arg)

    def start(self):
        '''Start the mouse provider'''
        pass

    def stop(self):
        '''Stop the mouse provider'''
        pass

    def test_activity(self):
        if not self.disable_on_activity:
            return False
        # trying to get if we currently have other touch than us
        # discard touches generated from kinetic
        touches = getCurrentTouches()
        for touch in touches:
            # discard all kinetic touch
            if touch.__class__.__name__ == 'KineticTouch':
                continue
            # not our instance, stop mouse
            if touch.__class__ != MouseTouch:
                return True
        return False

    def find_touch(self, x, y):
        factor = 10. / self.window.system_size[0]
        for t in self.touches.itervalues():
            if abs(x-t.sx) < factor and abs(y-t.sy) < factor:
                return t
        return False

    def create_touch(self, rx, ry, is_double_tap):
        self.counter += 1
        id = 'mouse' + str(self.counter)
        self.current_drag = cur = MouseTouch(self.device, id=id, args=[rx, ry])
        cur.is_double_tap = is_double_tap
        self.touches[id] = cur
        self.waiting_event.append(('down', cur))
        return cur

    def remove_touch(self, cur):
        if cur.id not in self.touches:
            return
        del self.touches[cur.id]
        self.waiting_event.append(('up', cur))

    def on_mouse_motion(self, x, y, modifiers):
        width, height = self.window.system_size
        rx = x / float(width)
        ry = 1. - y / float(height)
        if self.current_drag:
            cur = self.current_drag
            cur.move([rx, ry])
            self.waiting_event.append(('move', cur))
        elif self.alt_touch is not None and 'alt' not in modifiers:
            # alt just released ?
            is_double_tap = 'shift' in modifiers
            self.create_touch(rx, ry, is_double_tap)
        return True

    def on_mouse_press(self, x, y, button, modifiers):
        if self.test_activity():
            return
        width, height = self.window.system_size
        rx = x / float(width)
        ry = 1. - y / float(height)
        newTouch = self.find_touch(rx, ry)
        if newTouch:
            self.current_drag = newTouch
        else:
            is_double_tap = 'shift' in modifiers
            cur = self.create_touch(rx, ry, is_double_tap)
            if 'alt' in modifiers:
                self.alt_touch = cur
                self.current_drag = None
        return True

    def on_mouse_release(self, x, y, button, modifiers):
        width, height = self.window.system_size
        rx = x / float(width)
        ry = 1. - y / float(height)
        cur = self.find_touch(rx, ry)
        if button == 'left' and cur and not ('ctrl' in modifiers):
            self.remove_touch(cur)
            self.current_drag = None
        if self.alt_touch:
            self.remove_touch(self.alt_touch)
            self.alt_touch = None
        return True

    def update(self, dispatch_fn):
        '''Update the mouse provider (pop event from the queue)'''
        if not self.window:
            from pymt.base import getWindow
            self.window = getWindow()
            if self.window:
                self.window.push_handlers(
                    on_mouse_move=self.on_mouse_motion,
                    on_mouse_down=self.on_mouse_press,
                    on_mouse_up=self.on_mouse_release
                )
        if not self.window:
            return
        try:
            while True:
                event = self.waiting_event.popleft()
                dispatch_fn(*event)
        except Exception, e:
            pass

# registers
TouchFactory.register('mouse', MouseTouchProvider)

########NEW FILE########
__FILENAME__ = mtdev
'''
MTDev: Native support of Multitouch device on Linux, using libmtdev.

Mtdev project is a part of Ubuntu Maverick multitouch architecture.
You can read more on http://wiki.ubuntu.com/Multitouch

To configure MTDev, it's preferable to use probesysfs providers.
Check :py:class:`~pymt.input.providers.probesysfs` for more information.

Otherwise, you can put in your configuration ::

    [input]
    # devicename = hidinput,/dev/input/eventXX
    acert230h = mtdev,/dev/input/event2

.. note::
    You must have read access to the input event.

You have the possibility to use custom range for some X, Y and pressure value.
On some drivers, the range reported is invalid.
To fix that, you can add one of theses options on the argument line :

* invert_x : 1 to invert X axis
* invert_y : 1 to invert Y axis
* min_position_x : X minimum
* max_position_x : X maximum
* min_position_y : Y minimum
* max_position_y : Y maximum
* min_pressure : pressure minimum
* max_pressure : pressure maximum
* min_touch_major : width shape minimum
* max_touch_major : width shape maximum
* min_touch_minor : width shape minimum
* max_touch_minor : height shape maximum
'''

__all__ = ('MTDTouchProvider', 'MTDTouch')

import os
from pymt.input.touch import Touch
from pymt.input.shape import TouchShapeRect

class MTDTouch(Touch):
    def depack(self, args):
        self.sx = args['x']
        self.sy = args['y']
        self.profile = ['pos']
        if 'size_w' in args and 'size_h' in args:
            self.shape = TouchShapeRect()
            self.shape.width = args['size_w']
            self.shape.height = args['size_h']
            self.profile.append('shape')
        if 'pressure' in args:
            self.pressure = args['pressure']
            self.profile.append('pressure')
        super(MTDTouch, self).depack(args)

    def __str__(self):
        return '<MTDTouch id=%d pos=(%f, %f) device=%s>' % (self.id, self.sx, self.sy, self.device)

if 'PYMT_DOC' in os.environ:

    # documentation hack
    MTDTouchProvider = None

else:
    import threading
    import collections
    from pymt.lib.mtdev import Device, \
            MTDEV_TYPE_EV_ABS, MTDEV_CODE_SLOT, MTDEV_CODE_POSITION_X, \
            MTDEV_CODE_POSITION_Y, MTDEV_CODE_PRESSURE, \
            MTDEV_CODE_TOUCH_MAJOR, MTDEV_CODE_TOUCH_MINOR, \
            MTDEV_CODE_TRACKING_ID, MTDEV_ABS_POSITION_X, \
            MTDEV_ABS_POSITION_Y, MTDEV_ABS_TOUCH_MINOR, \
            MTDEV_ABS_TOUCH_MAJOR
    from pymt.input.provider import TouchProvider
    from pymt.input.factory import TouchFactory
    from pymt.logger import pymt_logger

    class MTDTouchProvider(TouchProvider):

        options = ('min_position_x', 'max_position_x',
                   'min_position_y', 'max_position_y',
                   'min_pressure', 'max_pressure',
                   'min_touch_major', 'max_touch_major',
                   'min_touch_minor', 'min_touch_major',
                   'invert_x', 'invert_y')

        def __init__(self, device, args):
            super(MTDTouchProvider, self).__init__(device, args)
            self._device = None
            self.input_fn = None
            self.default_ranges = dict()

            # split arguments
            args = args.split(',')
            if not args:
                pymt_logger.error('MTD: No filename pass to MTD configuration')
                pymt_logger.error('MTD: Use /dev/input/event0 for example')
                return None

            # read filename
            self.input_fn = args[0]
            pymt_logger.info('MTD: Read event from <%s>' % self.input_fn)

            # read parameters
            for arg in args[1:]:
                if arg == '':
                    continue
                arg = arg.split('=')

                # ensure it's a key = value
                if len(arg) != 2:
                    pymt_logger.error('MTD: invalid parameter %s, not in key=value format.' % arg)
                    continue

                # ensure the key exist
                key, value = arg
                if key not in MTDTouchProvider.options:
                    pymt_logger.error('MTD: unknown %s option' % key)
                    continue

                # ensure the value
                try:
                    self.default_ranges[key] = int(value)
                except ValueError:
                    pymt_logger.error('MTD: invalid value %s for option %s' % (key, value))
                    continue

                # all good!
                pymt_logger.info('MTD: Set custom %s to %d' % (key, int(value)))

        def start(self):
            if self.input_fn is None:
                return
            self.uid = 0
            self.queue = collections.deque()
            self.thread = threading.Thread(
                target=self._thread_run,
                kwargs=dict(
                    queue=self.queue,
                    input_fn=self.input_fn,
                    device=self.device,
                    default_ranges=self.default_ranges
                ))
            self.thread.daemon = True
            self.thread.start()

        def _thread_run(self, **kwargs):
            input_fn = kwargs.get('input_fn')
            queue = kwargs.get('queue')
            device = kwargs.get('device')
            drs = kwargs.get('default_ranges').get
            touches = {}
            touches_sent = []
            point = {}
            l_points = {}

            def process(points):
                for args in points:
                    tid = args['id']
                    try:
                        touch = touches[tid]
                    except KeyError:
                        touch = MTDTouch(device, tid, args)
                        touches[touch.id] = touch
                    touch.move(args)
                    action = 'move'
                    if tid not in touches_sent:
                        action = 'down'
                        touches_sent.append(tid)
                    if 'delete' in args:
                        action = 'up'
                        del args['delete']
                        del touches[touch.id]
                        touches_sent.remove(tid)
                    queue.append((action, touch))

            def normalize(value, vmin, vmax):
                return (value - vmin) / float(vmax - vmin)

            # open mtdev device
            _fn = self.input_fn
            _slot = 0
            _device = Device(_fn)
            _changes = set()

            # prepare some vars to get limit of some component
            ab = _device.get_abs(MTDEV_ABS_POSITION_X)
            range_min_position_x    = drs('min_position_x', ab.minimum)
            range_max_position_x    = drs('max_position_x', ab.maximum)
            pymt_logger.info('MTD: <%s> range position X is %d - %d' %
                             (_fn, range_min_position_x, range_max_position_x))

            ab = _device.get_abs(MTDEV_ABS_POSITION_Y)
            range_min_position_y    = drs('min_position_y', ab.minimum)
            range_max_position_y    = drs('max_position_y', ab.maximum)
            pymt_logger.info('MTD: <%s> range position Y is %d - %d' %
                             (_fn, range_min_position_y, range_max_position_y))

            ab = _device.get_abs(MTDEV_ABS_TOUCH_MAJOR)
            range_min_major         = drs('min_touch_major', ab.minimum)
            range_max_major         = drs('max_touch_major', ab.maximum)
            pymt_logger.info('MTD: <%s> range touch major is %d - %d' %
                             (_fn, range_min_major, range_max_major))

            ab = _device.get_abs(MTDEV_ABS_TOUCH_MINOR)
            range_min_minor         = drs('min_touch_minor', ab.minimum)
            range_max_minor         = drs('max_touch_minor', ab.maximum)
            pymt_logger.info('MTD: <%s> range touch minor is %d - %d' %
                             (_fn, range_min_minor, range_max_minor))

            range_min_pressure      = drs('min_pressure', 0)
            range_max_pressure      = drs('max_pressure', 255)
            pymt_logger.info('MTD: <%s> range pressure is %d - %d' %
                             (_fn, range_min_pressure, range_max_pressure))

            invert_x                = int(bool(drs('invert_x', 0)))
            invert_y                = int(bool(drs('invert_y', 0)))
            pymt_logger.info('MTD: <%s> axes invertion: X is %d, Y is %d' %
                             (_fn, invert_x, invert_y))

            while _device:
                # idle as much as we can.
                while _device.idle(1000):
                    continue

                # got data, read all without redoing idle
                while True:
                    data = _device.get()
                    if data is None:
                        break

                    # set the working slot
                    if data.type == MTDEV_TYPE_EV_ABS and \
                       data.code == MTDEV_CODE_SLOT:
                        _slot = data.value
                        continue

                    # fill the slot
                    if not _slot in l_points:
                        l_points[_slot] = dict()
                    point = l_points[_slot]
                    ev_value = data.value
                    ev_code = data.code
                    if ev_code == MTDEV_CODE_POSITION_X:
                        val = normalize(ev_value,
                            range_min_position_x, range_max_position_x)
                        if invert_x:
                            val = 1. - val
                        point['x'] = val
                    elif ev_code == MTDEV_CODE_POSITION_Y:
                        val = 1. - normalize(ev_value,
                            range_min_position_y, range_max_position_y)
                        if invert_y:
                            val = 1. - val
                        point['y'] = val
                    elif ev_code == MTDEV_CODE_PRESSURE:
                        point['pressure'] = normalize(ev_value,
                            range_min_pressure, range_max_pressure)
                    elif ev_code == MTDEV_CODE_TOUCH_MAJOR:
                        point['size_w'] = normalize(ev_value,
                            range_min_major, range_max_major)
                    elif ev_code == MTDEV_CODE_TOUCH_MINOR:
                        point['size_h'] = normalize(ev_value,
                            range_min_minor, range_max_minor)
                    elif ev_code == MTDEV_CODE_TRACKING_ID:
                        if ev_value == -1:
                            point['delete'] = True
                        else:
                            point['id'] = ev_value
                    else:
                        # unrecognized command, ignore.
                        continue
                    _changes.add(_slot)

                # push all changes
                if _changes:
                    process([l_points[x] for x in _changes])
                    _changes.clear()

        def update(self, dispatch_fn):
            # dispatch all event from threads
            try:
                while True:
                    event_type, touch = self.queue.popleft()
                    dispatch_fn(event_type, touch)
            except:
                pass


    TouchFactory.register('mtdev', MTDTouchProvider)

########NEW FILE########
__FILENAME__ = probesysfs
'''
Probe sysfs: Create input entry for each Multitouch hardware found (linux only).

Thanks to Marc Tardif for the probing code, used from scan-for-mt-device script.

The device discovery is done by this provider. However, the reading of input can
be made by 2 other providers: hidinput or mtdev. mtdev is used prior to
hidinput. For more information about mtdev, check
:py:class:`~pymt.input.providers.mtdev`.

Here is an example of auto creation ::

    [input]
    # using mtdev
    device_%(name)s = probesysfs,provider=mtdev
    # using hidinput
    device_%(name)s = probesysfs,provider=hidinput
    # using mtdev with a match on name
    device_%(name)s = probesysfs,provider=mtdev,match=acer

    # using hidinput with custom parameters to hidinput
    %(name)s = probesysfs,provider=hidinput,param=min_pressure=1,param=max_pressure=99

ProbeSysfs module will enumerate hardware from /sys/class/input device, and
configure hardware with ABS_MT_POSITION_X capability.
'''

__all__ = ('ProbeSysfsHardwareProbe', )

import os

if 'PYMT_DOC' in os.environ:

    ProbeSysfsHardwareProbe = None

else:
    import pymt
    import sys
    import re
    from glob import glob
    from subprocess import Popen, PIPE
    from pymt.logger import pymt_logger
    from pymt.input.provider import TouchProvider
    from pymt.input.factory import TouchFactory

    # See linux/input.h
    ABS_MT_POSITION_X = 0x35

    class Input(object):

        def __init__(self, path):
            self.path = path

        @property
        def device(self):
            base = os.path.basename(self.path)
            return os.path.join("/dev", "input", base)

        @property
        def name(self):
            path = os.path.join(self.path, "device", "name")
            return read_line(path)

        def get_capabilities(self):
            path = os.path.join(self.path, "device", "capabilities", "abs")
            line = read_line(path)
            capabilities = []
            long_bit = getconf("LONG_BIT")
            for i, word in enumerate(line.split(" ")):
                word = int(word, 16)
                subcapabilities = [bool(word & 1<<i) for i in range(long_bit)]
                capabilities[:0] = subcapabilities

            return capabilities

        def has_capability(self, capability):
            capabilities = self.get_capabilities()
            return len(capabilities) > capability and capabilities[capability]


    def getconf(var):
        output = Popen(["getconf", var], stdout=PIPE).communicate()[0]
        return int(output)

    def get_inputs(path):
        event_glob = os.path.join(path, "event*")
        for event_path in glob(event_glob):
            yield Input(event_path)

    def read_line(path):
        f = open(path)
        try:
            return f.readline().strip()
        finally:
            f.close()

    class ProbeSysfsHardwareProbe(TouchProvider):

        def __new__(self, device, args):
            # hack to not return an instance of this provider.
            # :)
            instance = super(ProbeSysfsHardwareProbe, self).__new__(self)
            instance.__init__(device, args)

        def __init__(self, device, args):
            super(ProbeSysfsHardwareProbe, self).__init__(device, args)
            self.provider = 'mtdev'
            self.match = None
            self.input_path = '/sys/class/input'
            self.args = []

            args = args.split(',')
            for arg in args:
                if arg == '':
                    continue
                arg = arg.split('=', 1)
                # ensure it's a key = value
                if len(arg) != 2:
                    pymt_logger.error('ProbeSysfs: invalid parameters %s, not'
                                      ' key=value format' % arg)
                    continue

                key, value = arg
                if key == 'match':
                    self.match = value
                elif key == 'provider':
                    self.provider = value
                elif key == 'param':
                    self.args.append(value)
                else:
                    pymt_logger.error('ProbeSysfs: unknown %s option' % key)
                    continue

            self.probe()

        def probe(self):
            inputs = get_inputs(self.input_path)
            inputs = [x for x in inputs if x.has_capability(ABS_MT_POSITION_X)]
            for device in inputs:
                pymt_logger.info('ProbeSysfs: found device: %s at %s' % (
                                 device.name, device.device))

                # must ignore ?
                if self.match:
                    if not re.match(self.match, device.name, re.IGNORECASE):
                        pymt_logger.warning('ProbeSysfs: device not match the'
                                            ' rule in config, ignoring.')
                        continue

                devicename = self.device % dict(name=device.device.split(os.path.sep)[-1])

                provider = TouchFactory.get(self.provider)
                if provider is None:
                    pymt_logger.info('ProbeSysfs: unable to found provider %s' %
                                     self.provider)
                    pymt_logger.info('ProbeSysfs: fallback on hidinput')
                    provider = TouchFactory.get('hidinput')
                if provider is None:
                    pymt_logger.critical('ProbeSysfs: no input provider found'
                                         ' to handle this device !')
                    continue

                instance = provider(devicename, '%s,%s' % (device.device,
                                                           ','.join(self.args)))
                if instance:
                    pymt.pymt_providers.append(instance)



    TouchFactory.register('probesysfs', ProbeSysfsHardwareProbe)

########NEW FILE########
__FILENAME__ = tuio
'''
Tuio: TUIO input provider implementation
'''

__all__ = ('TuioTouchProvider', 'Tuio2dCurTouch', 'Tuio2dObjTouch')

import osc
from collections import deque
from pymt.input.provider import TouchProvider
from pymt.input.factory import TouchFactory
from pymt.input.touch import Touch
from pymt.input.shape import TouchShapeRect
from pymt.logger import pymt_logger

class TuioTouchProvider(TouchProvider):
    '''Tuio provider listen to a socket, and handle part of OSC message

        * /tuio/2Dcur
        * /tuio/2Dobj

    Tuio provider can be configured with the `[`input`]` configuration ::

        [input]
        # name = tuio,<ip>:<port>
        multitouchtable = tuio,192.168.0.1:3333

    You can easily handle new tuio path by extending the providers like this ::

        # Create a class to handle the new touch type
        class TuioNEWPATHTouch(Touch):
            def __init__(self, id, args):
                super(TuioNEWPATHTouch, self).__init__(id, args)

            def depack(self, args):
                # Write here the depack function of args.
                # for a simple x, y, value, you can do this :
                if len(args) == 2:
                    self.sx, self.sy = args
                    self.profile = ('pos', )
                self.sy = 1 - self.sy
                super(TuioNEWPATHTouch, self).depack(args)

        # Register it to tuio touch provider
        TuioTouchProvider.register('/tuio/NEWPATH', TuioNEWPATHTouch)
    '''

    __handlers__ = {}

    def __init__(self, device, args):
        super(TuioTouchProvider, self).__init__(device, args)
        args = args.split(',')
        if len(args) <= 0:
            pymt_logger.error('Tuio: Invalid configuration for TUIO provider')
            pymt_logger.error('Tuio: Format must be ip:port (eg. 127.0.0.1:3333)')
            pymt_logger.error('Tuio: Actual TUIO configuration is <%s>' % (str(','.join(args))))
            return None
        ipport = args[0].split(':')
        if len(ipport) != 2:
            pymt_logger.error('Tuio: Invalid configuration for TUIO provider')
            pymt_logger.error('Tuio: Format must be ip:port (eg. 127.0.0.1:3333)')
            pymt_logger.error('Tuio: Actual TUIO configuration is <%s>' % (str(','.join(args))))
            return None
        self.ip, self.port = args[0].split(':')
        self.port = int(self.port)
        self.handlers = {}
        self.oscid = None
        self.tuio_event_q = deque()
        self.touches = {}

    @staticmethod
    def register(oscpath, classname):
        '''Register a new path to handle in tuio provider'''
        TuioTouchProvider.__handlers__[oscpath] = classname

    @staticmethod
    def unregister(oscpath, classname):
        '''Unregister a new path to handle in tuio provider'''
        if oscpath in TuioTouchProvider.__handlers__:
            del TuioTouchProvider.__handlers__[oscpath]

    @staticmethod
    def create(oscpath, **kwargs):
        '''Create a touch from a tuio path'''
        if oscpath not in TuioTouchProvider.__handlers__:
            raise Exception('Unknown %s touch path' % oscpath)
        return TuioTouchProvider.__handlers__[oscpath](**kwargs)

    def start(self):
        '''Start the tuio provider'''
        self.oscid = osc.listen(self.ip, self.port)
        for oscpath in TuioTouchProvider.__handlers__:
            self.touches[oscpath] = {}
            osc.bind(self.oscid, self._osc_tuio_cb, oscpath)

    def stop(self):
        '''Stop the tuio provider'''
        osc.dontListen(self.oscid)

    def update(self, dispatch_fn):
        '''Update the tuio provider (pop event from the queue)'''

        # deque osc queue
        osc.readQueue(self.oscid)

        # read the Queue with event
        while True:
            try:
                value = self.tuio_event_q.pop()
            except IndexError:
                # queue is empty, we're done for now
                return
            self._update(dispatch_fn, value)

    def _osc_tuio_cb(self, *incoming):
        message = incoming[0]
        oscpath, types, args = message[0], message[1], message[2:]
        self.tuio_event_q.appendleft([oscpath, args, types])

    def _update(self, dispatch_fn, value):
        oscpath, args, types = value
        command = args[0]

        # verify commands
        if command not in ['alive', 'set']:
            return

        # move or create a new touch
        if command == 'set':
            id = args[1]
            if id not in self.touches[oscpath]:
                # new touch
                touch = TuioTouchProvider.__handlers__[oscpath](self.device, id, args[2:])
                self.touches[oscpath][id] = touch
                dispatch_fn('down', touch)
            else:
                # update a current touch
                touch = self.touches[oscpath][id]
                touch.move(args[2:])
                dispatch_fn('move', touch)

        # alive event, check for deleted touch
        if command == 'alive':
            alives = args[1:]
            to_delete = []
            for id in self.touches[oscpath]:
                if not id in alives:
                    # touch up
                    touch = self.touches[oscpath][id]
                    if not touch in to_delete:
                        to_delete.append(touch)

            for touch in to_delete:
                dispatch_fn('up', touch)
                del self.touches[oscpath][touch.id]

class TuioTouch(Touch):
    '''Abstraction for TUIO touch.

    Depending of the tracker, the TuioTouch object support
    multiple profiles as :

        * fiducial : name markerid, property .fid
        * position : name pos, property .x, .y
        * angle : name angle, property .a
        * velocity vector : name mov, property .X, .Y
        * rotation velocity : name rot, property .A
        * motion acceleration : name motacc, property .m
        * rotation acceleration : name rotacc, property .r
    '''
    __attrs__ = ('a', 'b', 'c', 'X', 'Y', 'Z', 'A', 'B', 'C', 'm', 'r')

    def __init__(self, device, id, args):
        super(TuioTouch, self).__init__(device, id, args)
        # Default argument for TUIO touches
        self.a = 0.0
        self.b = 0.0
        self.c = 0.0
        self.X = 0.0
        self.Y = 0.0
        self.Z = 0.0
        self.A = 0.0
        self.B = 0.0
        self.C = 0.0
        self.m = 0.0
        self.r = 0.0

    angle = property(lambda self: self.a)
    mot_accel = property(lambda self: self.m)
    rot_accel = property(lambda self: self.r)
    xmot = property(lambda self: self.X)
    ymot = property(lambda self: self.Y)
    zmot = property(lambda self: self.Z)

class Tuio2dCurTouch(TuioTouch):
    '''A 2dCur TUIO touch.'''
    def __init__(self, device, id, args):
        super(Tuio2dCurTouch, self).__init__(device, id, args)

    def depack(self, args):
        if len(args) < 5:
            self.sx, self.sy = map(float, args[0:2])
            self.profile = ('pos', )
        elif len(args) == 5:
            self.sx, self.sy, self.X, self.Y, self.m = map(float, args[0:5])
            self.Y = -self.Y
            self.profile = ('pos', 'mov', 'motacc')
        else:
            self.sx, self.sy, self.X, self.Y, self.m, width, height = map(float, args[0:7])
            self.Y = -self.Y
            self.profile = ('pos', 'mov', 'motacc', 'shape')
            if self.shape is None:
                self.shape = TouchShapeRect()
            self.shape.width = width
            self.shape.height = height
        self.sy = 1 - self.sy
        super(Tuio2dCurTouch, self).depack(args)


class Tuio2dObjTouch(TuioTouch):
    '''A 2dObj TUIO object.
    '''
    def __init__(self, device, id, args):
        super(Tuio2dObjTouch, self).__init__(device, id, args)

    def depack(self, args):
        if len(args) < 5:
            self.sx, self.sy = args[0:2]
            self.profile = ('pos', )
        elif len(args) == 9:
            self.fid, self.sx, self.sy, self.a, self.X, self.Y, self.A, self.m, self.r = args[0:9]
            self.Y = -self.Y
            self.profile = ('markerid', 'pos', 'angle', 'mov', 'rot', 'motacc', 'rotacc')
        else:
            self.fid, self.sx, self.sy, self.a, self.X, self.Y, self.A, self.m, self.r, width, height = args[0:11]
            self.Y = -self.Y
            self.profile = ('markerid', 'pos', 'angle', 'mov', 'rot', 'rotacc',
                            'acc', 'shape')
            if self.shape is None:
                self.shape = TouchShapeRect()
                self.shape.width = width
                self.shape.height = height
        self.sy = 1 - self.sy
        super(Tuio2dObjTouch, self).depack(args)

# registers
TuioTouchProvider.register('/tuio/2Dcur', Tuio2dCurTouch)
TuioTouchProvider.register('/tuio/2Dobj', Tuio2dObjTouch)
TouchFactory.register('tuio', TuioTouchProvider)

########NEW FILE########
__FILENAME__ = wm_common
'''
WM_Touch/WM_Pen: common definitions for both input providers

This file provide common definition of some const used for WM_Touch / WM_Pen
'''

WM_MOUSEFIRST    = 512
WM_MOUSEMOVE     = 512
WM_LBUTTONDOWN   = 513
WM_LBUTTONUP     = 514
WM_LBUTTONDBLCLK = 515
WM_RBUTTONDOWN   = 516
WM_RBUTTONUP     = 517
WM_RBUTTONDBLCLK = 518
WM_MBUTTONDOWN   = 519
WM_MBUTTONUP     = 520
WM_MBUTTONDBLCLK = 521
WM_MOUSEWHEEL    = 522
WM_MOUSELAST     = 522

WM_TOUCH         = 576
TOUCHEVENTF_MOVE = 1
TOUCHEVENTF_DOWN = 2
TOUCHEVENTF_UP   = 4

PEN_OR_TOUCH_SIGNATURE = 0xFF515700
PEN_OR_TOUCH_MASK      = 0xFFFFFF00
PEN_EVENT_TOUCH_MASK   = 0x80

WM_TABLET_QUERYSYSTEMGESTURE       = 0x000002CC
TABLET_DISABLE_PRESSANDHOLD        = 0x00000001
TABLET_DISABLE_PENTAPFEEDBACK      = 0x00000008
TABLET_DISABLE_PENBARRELFEEDBACK   = 0x00000010
TABLET_DISABLE_TOUCHUIFORCEON      = 0x00000100
TABLET_DISABLE_TOUCHUIFORCEOFF     = 0x00000200
TABLET_DISABLE_TOUCHSWITCH         = 0x00008000
TABLET_DISABLE_FLICKS              = 0x00010000
TABLET_ENABLE_FLICKSONCONTEXT      = 0x00020000
TABLET_ENABLE_FLICKLEARNINGMODE    = 0x00040000
TABLET_DISABLE_SMOOTHSCROLLING     = 0x00080000
TABLET_DISABLE_FLICKFALLBACKKEYS   = 0x00100000
GWL_WNDPROC = -4


QUERYSYSTEMGESTURE_WNDPROC = (
    TABLET_DISABLE_PRESSANDHOLD       |
    TABLET_DISABLE_PENTAPFEEDBACK     |
    TABLET_DISABLE_PENBARRELFEEDBACK  |
    TABLET_DISABLE_SMOOTHSCROLLING     |
    TABLET_DISABLE_FLICKFALLBACKKEYS  |
    TABLET_DISABLE_TOUCHSWITCH        |
    TABLET_DISABLE_FLICKS
)

########NEW FILE########
__FILENAME__ = wm_pen
'''
WM_PEN: Support of WM_PEN message (Window platform)
'''

__all__ = ('WM_PenProvider', 'WM_Pen')

import os
from pymt.input.providers.wm_common import PEN_OR_TOUCH_SIGNATURE, \
        PEN_OR_TOUCH_MASK, GWL_WNDPROC, WM_MOUSEMOVE, WM_LBUTTONUP, \
        WM_LBUTTONDOWN, WM_TABLET_QUERYSYSTEMGESTURE, \
        QUERYSYSTEMGESTURE_WNDPROC, PEN_EVENT_TOUCH_MASK
from pymt.input.touch import Touch

class WM_Pen(Touch):
    '''Touch representing the WM_Pen event. Support pos profile'''
    def depack(self, args):
        self.sx, self.sy = args[0], args[1]
        super(WM_Pen, self).depack(args)

    def __str__(self):
        return '<WMPen id:%d uid:%d pos:%s device:%s>' % (self.id, self.uid, str(self.spos), self.device)

if 'PYMT_DOC' in os.environ:
    # documentation hack
    WM_PenProvider = None

else:
    from collections import deque
    from ctypes import wintypes, Structure, windll, byref, c_int16, \
            c_int, c_long, WINFUNCTYPE
    from pymt.input.provider import TouchProvider
    from pymt.input.factory import TouchFactory

    WNDPROC = WINFUNCTYPE(c_long, c_int, c_int, c_int, c_int)

    class RECT(Structure):
        _fields_ = [
        ('left',   wintypes.ULONG ),
        ('top',    wintypes.ULONG ),
        ('right',  wintypes.ULONG ),
        ('bottom', wintypes.ULONG )
        ]

        x = property(lambda self: self.left)
        y = property(lambda self: self.top)
        w = property(lambda self: self.right-self.left)
        h = property(lambda self: self.bottom-self.top)
    win_rect = RECT()


    class WM_PenProvider(TouchProvider):

        def _is_pen_message(self, msg):
            info = windll.user32.GetMessageExtraInfo()
            if (info & PEN_OR_TOUCH_MASK) == PEN_OR_TOUCH_SIGNATURE: # its a touch or a pen
                if not info & PEN_EVENT_TOUCH_MASK:
                    return True

        def _pen_handler(self, msg, wParam, lParam):
            if msg not in (WM_LBUTTONDOWN, WM_MOUSEMOVE, WM_LBUTTONUP):
                return

            windll.user32.GetClientRect(self.hwnd, byref(win_rect))
            x = c_int16(lParam & 0xffff).value / float(win_rect.w)
            y = c_int16(lParam >> 16).value / float(win_rect.h)
            y = abs(1.0 - y)

            if msg == WM_LBUTTONDOWN:
                self.pen_events.appendleft(('down', x, y))
                self.pen_status = True

            if msg == WM_MOUSEMOVE and self.pen_status:
                self.pen_events.appendleft(('move', x, y))

            if msg == WM_LBUTTONUP:
                self.pen_events.appendleft(('up', x, y))
                self.pen_status = False

        def _pen_wndProc( self, hwnd, msg, wParam, lParam ):
            if msg == WM_TABLET_QUERYSYSTEMGESTURE:
                return QUERYSYSTEMGESTURE_WNDPROC
            if self._is_pen_message(msg):
                self._pen_handler(msg, wParam, lParam)
                return 1
            else:
                return windll.user32.CallWindowProcW(self.old_windProc, hwnd, msg, wParam, lParam)

        def start(self):
            self.uid = 0
            self.pen = None
            self.pen_status = None
            self.pen_events = deque()

            self.hwnd = windll.user32.GetActiveWindow()

            # inject our own wndProc to handle messages before window manager does
            self.new_windProc = WNDPROC(self._pen_wndProc)
            self.old_windProc = windll.user32.SetWindowLongW(
                self.hwnd,
                GWL_WNDPROC,
                self.new_windProc
            )

        def update(self, dispatch_fn):
            while True:

                try:
                    type, x, y = self.pen_events.pop()
                except:
                    break

                if  type == 'down':
                    self.uid += 1
                    self.pen = WM_Pen(self.device, self.uid, [x, y])
                if  type == 'move':
                    self.pen.move([x, y])

                dispatch_fn(type, self.pen)

        def stop(self):
            self.pen = None
            windll.user32.SetWindowLongW(
                self.hwnd,
                GWL_WNDPROC,
                self.old_windProc
            )

    TouchFactory.register('wm_pen', WM_PenProvider)

########NEW FILE########
__FILENAME__ = wm_touch
'''
WM_TOUCH: Support of WM_TOUCH message (Window platform)
'''

__all__ = ('WM_TouchProvider', 'WM_Touch')

import os
from pymt.input.providers.wm_common import WM_TABLET_QUERYSYSTEMGESTURE, \
        GWL_WNDPROC, QUERYSYSTEMGESTURE_WNDPROC, WM_TOUCH, WM_MOUSEMOVE, \
        WM_MOUSELAST, PEN_OR_TOUCH_MASK, PEN_OR_TOUCH_SIGNATURE, \
        PEN_EVENT_TOUCH_MASK, TOUCHEVENTF_UP, TOUCHEVENTF_DOWN, \
        TOUCHEVENTF_MOVE
from pymt.input.touch import Touch
from pymt.input.shape import TouchShapeRect

class WM_Touch(Touch):
    '''Touch representing the WM_Touch event. Support pos, shape and size profiles'''
    __attrs__ = ('size', )
    def depack(self, args):
        self.shape = TouchShapeRect()
        self.sx, self.sy = args[0], args[1]
        self.shape.width = args[2][0]
        self.shape.height = args[2][1]
        self.size = self.shape.width * self.shape.height
        self.profile = ('pos', 'shape', 'size')

        super(WM_Touch, self).depack(args)

    def __str__(self):
        return '<WMTouch id:%d uid:%d pos:%s device:%s>' % (self.id, self.uid, str(self.spos), self.device)

if 'PYMT_DOC' in os.environ:
    # documentation hack
    WM_TouchProvider = None

else:
    from ctypes import wintypes, windll, WINFUNCTYPE, c_long, c_int, \
            Structure, pointer, sizeof, byref
    from collections import deque
    from pymt.input.provider import TouchProvider
    from pymt.input.factory import TouchFactory

    # check availability of RegisterTouchWindow
    if not hasattr(windll.user32, 'RegisterTouchWindow'):
        raise Exception('Unsupported Window version')

    WNDPROC = WINFUNCTYPE(c_long, c_int, c_int, c_int, c_int)

    class TOUCHINPUT(Structure):
        _fields_ = [
            ('x',wintypes.LONG),
            ('y',wintypes.LONG),
            ('pSource',wintypes.HANDLE),
            ('id',wintypes.DWORD),
            ('flags',wintypes.DWORD),
            ('mask',wintypes.DWORD),
            ('time',wintypes.DWORD),
            ('extraInfo',wintypes.ULONG ),
            ('size_x',wintypes.DWORD),
            ('size_y',wintypes.DWORD)
        ]

        def size(self):
            return (self.size_x, self.size_y)

        def screen_x(self):
            return self.x/100.0

        def screen_y(self):
            return self.y/100.0

        def _event_type(self):
            if self.flags & TOUCHEVENTF_MOVE:
                return 'move'
            if self.flags & TOUCHEVENTF_DOWN:
                return 'down'
            if self.flags & TOUCHEVENTF_UP:
                return 'up'
        event_type = property(_event_type)


    class RECT(Structure):
        _fields_ = [
            ('left',   wintypes.ULONG ),
            ('top',    wintypes.ULONG ),
            ('right',  wintypes.ULONG ),
            ('bottom', wintypes.ULONG )
        ]

        x = property(lambda self: self.left)
        y = property(lambda self: self.top)
        w = property(lambda self: self.right-self.left)
        h = property(lambda self: self.bottom-self.top)


    class WM_TouchProvider(TouchProvider):

        def start(self):
            self.touch_events = deque()
            self.touches = {}
            self.uid = 0

            # get window handle, and register to recive WM_TOUCH messages
            self.hwnd = windll.user32.GetActiveWindow()
            windll.user32.RegisterTouchWindow(self.hwnd, 1)

            # inject our own wndProc to handle messages before window manager does
            self.new_windProc = WNDPROC(self._touch_wndProc)
            self.old_windProc = windll.user32.SetWindowLongW(
                self.hwnd,
                GWL_WNDPROC,
                self.new_windProc
            )


        def update(self, dispatch_fn):
            win_rect = RECT()
            windll.user32.GetWindowRect(self.hwnd, byref(win_rect))

            while True:
                try:
                    t = self.touch_events.pop()
                except:
                    break

                # adjust x,y to window coordinates (0.0 to 1.0)
                x = (t.screen_x()-win_rect.x)/float(win_rect.w)
                y = 1.0 - (t.screen_y()-win_rect.y)/float(win_rect.h)

                # actually dispatch input
                if t.event_type == 'down':
                    self.uid += 1
                    self.touches[t.id] = WM_Touch(self.device,
                                                  self.uid, [x, y, t.size()])
                    dispatch_fn('down', self.touches[t.id] )

                if t.event_type == 'move' and self.touches.has_key(t.id):
                    self.touches[t.id].move([x, y, t.size()])
                    dispatch_fn('move', self.touches[t.id] )

                if t.event_type == 'up'  and self.touches.has_key(t.id):
                    self.touches[t.id].move([x, y, t.size()])
                    dispatch_fn('up', self.touches[t.id] )
                    del self.touches[t.id]


        def stop(self):
            windll.user32.UnregisterTouchWindow(self.hwnd)
            self.new_windProc = windll.user32.SetWindowLongW(
                self.hwnd,
                GWL_WNDPROC,
                self.old_windProc
            )


        # we inject this wndProc into our main window, to process
        # WM_TOUCH and mouse messages before the window manager does
        def _touch_wndProc( self, hwnd, msg, wParam, lParam ):
            done = False
            if msg == WM_TABLET_QUERYSYSTEMGESTURE:
                return QUERYSYSTEMGESTURE_WNDPROC

            if msg == WM_TOUCH:
                done = self._touch_handler(msg, wParam, lParam)

            if msg >= WM_MOUSEMOVE and msg <= WM_MOUSELAST:
                done = self._mouse_handler(msg, wParam, lParam)

            if not done:
                return windll.user32.CallWindowProcW( self.old_windProc, hwnd, msg, wParam, lParam)
            return 1


        # this on pushes WM_TOUCH messages onto our event stack
        def _touch_handler(self, msg, wParam, lParam):
            touches = (TOUCHINPUT * wParam)()
            windll.user32.GetTouchInputInfo(wintypes.HANDLE(lParam),
                                            wParam,
                                            pointer(touches),
                                            sizeof(TOUCHINPUT))
            for i in xrange(wParam):
                self.touch_events.appendleft(touches[i])
            return True


        # filter fake mouse events, because touch and stylus also make mouse events
        def _mouse_handler(self, msg, wparam, lParam):
            info = windll.user32.GetMessageExtraInfo()
            if (info & PEN_OR_TOUCH_MASK) == PEN_OR_TOUCH_SIGNATURE: # its a touch or a pen
                if info & PEN_EVENT_TOUCH_MASK:
                    return True


    TouchFactory.register('wm_touch', WM_TouchProvider)

########NEW FILE########
__FILENAME__ = shape
'''
Touch Shape: Represent the shape of the touch
'''

__all__ = ('TouchShape', 'TouchShapeRect')

class TouchShape(object):
    '''Abstract class for all implementation of a shape'''
    pass

class TouchShapeRect(TouchShape):
    '''Represent a rectangle shape.'''
    __slots__ = ['width', 'height']

    def __init__(self):
        super(TouchShapeRect, self).__init__()
        self.width = 0
        self.height = 0


########NEW FILE########
__FILENAME__ = touch
'''
Touch: Base for all touch objects


Every touch in PyMT derives from the abstract Touch class.
A touch can have more or less attributes, depending on the provider.
For example, the TUIO provider can give you a lot of information about the touch,
like position, acceleration, width/height of the shape and so on.
Another provider might just give you x/y coordinates and pressure.

We call these attributes "capabilities". Every touch indicates its
capabilities in its "profile" property.
A profile is just a simple list with strings, containing for example:

    * pos (property x, y)
    * pos3d (property x, y, z)
    * mov (tuio/property X, Y)
    * mov3d (tuio/property X, Y, Z)
    * dim (tuio/property w, h)
    * dim3d (tuio/property w, h, d)
    * markerid (tuio/property i (fid property))
    * sessionid (tuio/property s (id property))
    * angle (tuio/property a)
    * angle3D (tuio/property a, b, c)
    * rotacc (tuio/property A)
    * rotacc3d (tuio/property A, B, C)
    * motacc (tuio/property m)
    * shape (property shape)
    * kinetic
    * ... and others could be added by new classes

If you're only interested in a certain kind of touches, check the profile::

    def on_touch_down(self, touch):
        if 'markerid' not in touch.profile:
            # not a fiducial, not interesting
            return

'''

__all__ = ('Touch', )

import weakref
from inspect import isroutine
from copy import copy
from pymt.utils import SafeList
from pymt.clock import getClock
from pymt.vector import Vector


class TouchMetaclass(type):
    def __new__(mcs, name, bases, attrs):
        __attrs__ = []
        for base in bases:
            if hasattr(base, '__attrs__'):
                __attrs__.extend(base.__attrs__)
        if '__attrs__' in attrs:
            __attrs__.extend(attrs['__attrs__'])
        attrs['__attrs__'] = tuple(__attrs__)
        return super(TouchMetaclass, mcs).__new__(mcs, name, bases, attrs)


class Touch(object):
    '''Abstract class to represent a touch, and support TUIO 1.0 definition.

    :Parameters:
        `id` : str
            uniq ID of the touch
        `args` : list
            list of parameters, passed to depack() function
    '''

    __metaclass__ = TouchMetaclass
    __uniq_id = 0
    __attrs__ = \
        ('device', 'attr',
         'id', 'sx', 'sy', 'sz', 'profile',
         'x', 'y', 'z', 'shape',
         'dxpos', 'dypos', 'dzpos',
         'oxpos', 'oypos', 'ozpos',
         'dsxpos', 'dsypos', 'dszpos',
         'osxpos', 'osypos', 'oszpos',
         'time_start', 'is_double_tap',
         'double_tap_time', 'userdata')

    def __init__(self, device, id, args):
        if self.__class__ == Touch:
            raise NotImplementedError, 'class Touch is abstract'

        # Uniq ID
        Touch.__uniq_id += 1
        self.uid = Touch.__uniq_id
        self.device = device

        # For push/pop
        self.attr = []
        self.default_attrs = (
            'x', 'y', 'z',
            'dxpos', 'dypos', 'dzpos',
            'oxpos', 'oypos', 'ozpos')

        # For grab
        self.grab_list = SafeList()
        self.grab_exclusive_class = None
        self.grab_state = False
        self.grab_current = None

        # TUIO definition
        self.id = id
        self.sx = 0.0
        self.sy = 0.0
        self.sz = 0.0
        self.profile = ('pos', )

        # new parameters
        self.x = 0.0
        self.y = 0.0
        self.z = 0.0
        self.shape = None
        self.dxpos = None
        self.dypos = None
        self.dzpos = None
        self.oxpos = None
        self.oypos = None
        self.ozpos = None
        self.dsxpos = None
        self.dsypos = None
        self.dszpos = None
        self.osxpos = None
        self.osypos = None
        self.oszpos = None
        self.time_start = getClock().get_time()
        self.is_double_tap = False
        self.double_tap_time = 0
        self.userdata = {}

        self.depack(args)

    def depack(self, args):
        '''Depack `args` into attributes in class'''
        if self.dsxpos is None:
            self.dsxpos = self.osxpos = self.sx
            self.dsypos = self.osypos = self.sy
            self.dszpos = self.oszpos = self.sz

    def grab(self, class_instance, exclusive=False):
        '''Grab a touch. You can grab a touch if you absolutly want to receive
        on_touch_move() and on_touch_up(), even if the touch is not dispatched
        by your parent ::

            def on_touch_down(self, touch):
                touch.grab(self)

            def on_touch_move(self, touch):
                if touch.grab_current == self:
                    # i receive my grabbed touch
                else:
                    # it's a normal touch

            def on_touch_up(self, touch):
                if touch.grab_current == self:
                    # i receive my grabbed touch, i must ungrab it !
                    touch.ungrab(self)
                else:
                    # it's a normal touch

        '''
        if self.grab_exclusive_class is not None:
            raise Exception('Cannot grab the touch, touch are exclusive')
        class_instance = weakref.ref(class_instance)
        if exclusive:
            self.grab_exclusive_class = class_instance
        self.grab_list.append(class_instance)

    def ungrab(self, class_instance):
        '''Ungrab a previous grabbed touch'''
        class_instance = weakref.ref(class_instance)
        if self.grab_exclusive_class == class_instance:
            self.grab_exclusive_class = None
        if class_instance in self.grab_list:
            self.grab_list.remove(class_instance)

    def move(self, args):
        '''Move the touch to another position.'''
        self.dxpos = self.x
        self.dypos = self.y
        self.dzpos = self.z
        self.dsxpos = self.sx
        self.dsypos = self.sy
        self.dszpos = self.sz
        self.depack(args)

    def scale_for_screen(self, w, h, p=None, rotation=0):
        '''Scale position for the screen'''
        sx, sy = self.sx, self.sy
        if rotation == 0:
            self.x = sx * float(w)
            self.y = sy * float(h)
        elif rotation == 90:
            sx, sy = sy, 1-sx
            self.x = sx * float(h)
            self.y = sy * float(w)
        elif rotation == 180:
            sx, sy = 1-sx, 1-sy
            self.x = sx * float(w)
            self.y = sy * float(h)
        elif rotation == 270:
            sx, sy = 1-sy, sx
            self.x = sx * float(h)
            self.y = sy * float(w)

        if p:
            self.z = self.sz * float(p)
        if self.oxpos is None:
            self.dxpos = self.oxpos = self.x
            self.dypos = self.oypos = self.y
            self.dzpos = self.ozpos = self.z

    def push(self, attrs=None):
        '''Push attributes values in `attrs` in the stack'''
        if attrs is None:
            attrs = self.default_attrs
        values = [getattr(self, x) for x in attrs]
        self.attr.append((attrs, values))

    def pop(self):
        '''Pop attributes values from the stack'''
        attrs, values = self.attr.pop()
        for i in xrange(len(attrs)):
            setattr(self, attrs[i], values[i])

    def apply_transform_2d(self, transform):
        '''Apply a transformation on x, y, dxpos, dypos, oxpos, oypos'''
        self.x, self.y = transform(self.x, self.y)
        self.dxpos, self.dypos = transform(self.dxpos, self.dypos)
        self.oxpos, self.oypos = transform(self.oxpos, self.oypos)

    def copy_to(self, to):
        '''Copy some attribute to another touch object.'''
        for attr in self.__attrs__:
            to.__setattr__(attr, copy(self.__getattribute__(attr)))

    def __str__(self):
        classname = str(self.__class__).split('.')[-1].replace('>', '').replace('\'', '')
        return '<%s spos=%s pos=%s>' % (classname, str(self.spos), str(self.pos))

    def distance(self, other_touch):
        return Vector(self.pos).distance(other_touch.pos)

    def __repr__(self):
        out = []
        for x in dir(self):
            v = getattr(self, x)
            if x[0] == '_':
                continue
            if isroutine(v):
                continue
            out.append('%s="%s"' % (x, v))
        return '<%s %s>' % (
            self.__class__.__name__,
            ' '.join(out)
        )

    # facility
    @property
    def pos(self):
        '''Return position of the touch in the screen coordinate
        system (self.x, self.y)'''
        return self.x, self.y

    @property
    def dpos(self):
        '''Return previous position of the touch in the
        screen coordinate system (self.dxpos, self.dypos)'''
        return self.dxpos, self.dypos

    @property
    def opos(self):
        '''Return the initial position of the touch in the screen
        coordinate system (self.oxpos, self.oypos)'''
        return self.oxpos, self.oypos

    @property
    def spos(self):
        '''Return the position in the 0-1 coordinate system
        (self.sx, self.sy)'''
        return self.sx, self.sy

    # compatibility bridge
    xpos = property(lambda self: self.x)
    ypos = property(lambda self: self.y)
    blobID = property(lambda self: self.id)

########NEW FILE########
__FILENAME__ = mtdev
'''
python-mtdev - Python binding to the mtdev library (MIT license)

The mtdev library transforms all variants of kernel MT events to the
slotted type B protocol. The events put into mtdev may be from any MT
device, specifically type A without contact tracking, type A with
contact tracking, or type B with contact tracking. See the kernel
documentation for further details.

'''

import os
from ctypes import cdll, Structure, c_ulong, c_int, c_ushort, \
                   c_void_p, pointer, POINTER, byref

# load library
libmtdev = cdll.LoadLibrary('libmtdev.so.1')

# from linux/input.h
MTDEV_CODE_SLOT          = 0x2f  # MT slot being modified
MTDEV_CODE_TOUCH_MAJOR   = 0x30    # Major axis of touching ellipse
MTDEV_CODE_TOUCH_MINOR   = 0x31    # Minor axis (omit if circular)
MTDEV_CODE_WIDTH_MAJOR   = 0x32    # Major axis of approaching ellipse
MTDEV_CODE_WIDTH_MINOR   = 0x33    # Minor axis (omit if circular)
MTDEV_CODE_ORIENTATION   = 0x34    # Ellipse orientation
MTDEV_CODE_POSITION_X    = 0x35    # Center X ellipse position
MTDEV_CODE_POSITION_Y    = 0x36    # Center Y ellipse position
MTDEV_CODE_TOOL_TYPE     = 0x37    # Type of touching device
MTDEV_CODE_BLOB_ID       = 0x38    # Group a set of packets as a blob
MTDEV_CODE_TRACKING_ID   = 0x39    # Unique ID of initiated contact
MTDEV_CODE_PRESSURE      = 0x3a    # Pressure on contact area
MTDEV_CODE_ABS_X		 = 0x00
MTDEV_CODE_ABS_Y		 = 0x01
MTDEV_CODE_ABS_Z		 = 0x02
MTDEV_CODE_BTN_DIGI		        = 0x140
MTDEV_CODE_BTN_TOOL_PEN		    = 0x140
MTDEV_CODE_BTN_TOOL_RUBBER		= 0x141
MTDEV_CODE_BTN_TOOL_BRUSH		= 0x142
MTDEV_CODE_BTN_TOOL_PENCIL		= 0x143
MTDEV_CODE_BTN_TOOL_AIRBRUSH	= 0x144
MTDEV_CODE_BTN_TOOL_FINGER		= 0x145
MTDEV_CODE_BTN_TOOL_MOUSE		= 0x146
MTDEV_CODE_BTN_TOOL_LENS		= 0x147
MTDEV_CODE_BTN_TOUCH		    = 0x14a
MTDEV_CODE_BTN_STYLUS		    = 0x14b
MTDEV_CODE_BTN_STYLUS2		    = 0x14c
MTDEV_CODE_BTN_TOOL_DOUBLETAP	= 0x14d
MTDEV_CODE_BTN_TOOL_TRIPLETAP	= 0x14e
MTDEV_CODE_BTN_TOOL_QUADTAP	    = 0x14f	# Four fingers on trackpad

MTDEV_TYPE_EV_ABS        = 0x03
MTDEV_TYPE_EV_SYN        = 0x00
MTDEV_TYPE_EV_KEY        = 0x01
MTDEV_TYPE_EV_REL        = 0x02
MTDEV_TYPE_EV_ABS        = 0x03
MTDEV_TYPE_EV_MSC        = 0x04
MTDEV_TYPE_EV_SW         = 0x05
MTDEV_TYPE_EV_LED        = 0x11
MTDEV_TYPE_EV_SND        = 0x12
MTDEV_TYPE_EV_REP        = 0x14
MTDEV_TYPE_EV_FF         = 0x15
MTDEV_TYPE_EV_PWR        = 0x16
MTDEV_TYPE_EV_FF_STATUS  = 0x17

MTDEV_ABS_TRACKING_ID	= 9
MTDEV_ABS_POSITION_X	= 5
MTDEV_ABS_POSITION_Y	= 6
MTDEV_ABS_TOUCH_MAJOR	= 0
MTDEV_ABS_TOUCH_MINOR	= 1
MTDEV_ABS_WIDTH_MAJOR	= 2
MTDEV_ABS_WIDTH_MINOR	= 3
MTDEV_ABS_ORIENTATION	= 4
MTDEV_ABS_SIZE          = 11

class timeval(Structure):
    _fields_ = [
        ('tv_sec', c_ulong),
        ('tv_usec', c_ulong)
    ]

class input_event(Structure):
    _fields_ = [
        ('time', timeval),
        ('type', c_ushort),
        ('code', c_ushort),
        ('value', c_int)
    ]

class input_absinfo(Structure):
    _fields_ = [
        ('value', c_int),
        ('minimum', c_int),
        ('maximum', c_int),
        ('fuzz', c_int),
        ('flat', c_int),
        ('resolution', c_int)
    ]

class mtdev_caps(Structure):
    _fields_ = [
        ('has_mtdata', c_int),
        ('has_slot', c_int),
        ('has_abs', c_int * MTDEV_ABS_SIZE),
        ('slot', input_absinfo),
        ('abs', input_absinfo * MTDEV_ABS_SIZE)
    ]

class mtdev(Structure):
    _fields_ = [
        ('caps', mtdev_caps),
        ('state', c_void_p)
    ]

# binding
mtdev_open = libmtdev.mtdev_open
mtdev_open.argtypes = [POINTER(mtdev), c_int]
mtdev_get = libmtdev.mtdev_get
mtdev_get.argtypes = [POINTER(mtdev), c_int, POINTER(input_event), c_int]
mtdev_idle = libmtdev.mtdev_idle
mtdev_idle.argtypes = [POINTER(mtdev), c_int, c_int]
mtdev_close = libmtdev.mtdev_close
mtdev_close.argtypes = [POINTER(mtdev)]


class Device:
    def __init__(self, filename):
        self._filename = filename
        self._fd = -1
        self._device = mtdev()

        self._fd = os.open(filename, os.O_NONBLOCK | os.O_RDONLY)
        ret = mtdev_open(pointer(self._device), self._fd)
        if ret != 0:
            os.close(self._fd)
            self._fd = -1
            raise Exception('Unable to open device')

    def close(self):
        '''Close the mtdev converter
        '''
        if self._fd == -1:
            return
        mtdev_close(POINTER(self._device))
        os.close(self._fd)
        self._fd = -1

    def idle(self, ms):
        '''Check state of kernel device
        
        :Parameters:
            `ms` : int
                Number of milliseconds to wait for activity

        :Return:
            Return True if the device is idle, i.e, there are no fetched events
            in the pipe and there is nothing to fetch from the device.
        '''
        if self._fd == -1:
            raise Exception('Device closed')
        return bool(mtdev_idle(pointer(self._device), self._fd, ms))


    def get(self):
        if self._fd == -1:
            raise Exception('Device closed')
        ev = input_event()
        if mtdev_get(pointer(self._device), self._fd, byref(ev), 1) <= 0:
            return None
        return ev

    def has_mtdata(self):
        '''Return True if the device has multitouch data.
        '''
        if self._fd == -1:
            raise Exception('Device closed')
        return bool(self._device.caps.has_mtdata)

    def has_slot(self):
        '''Return True if the device has slot information.
        '''
        if self._fd == -1:
            raise Exception('Device closed')
        return bool(self._device.caps.has_slot)

    def has_abs(self, index):
        '''Return True if the device has abs data.

        :Parameters:
            `index` : int
                One of const starting with a name ABS_MT_
        '''
        if self._fd == -1:
            raise Exception('Device closed')
        if index < 0 or index >= MTDEV_ABS_SIZE:
            raise IndexError('Invalid index')
        return bool(self._device.caps.has_abs[index])

    def get_max_abs(self):
        '''Return the maximum number of abs information available.
        '''
        return MTDEV_ABS_SIZE

    def get_slot(self):
        '''Return the slot data.
        '''
        if self._fd == -1:
            raise Exception('Device closed')
        if self._device.caps.has_slot == 0:
            return
        return self._device.caps.slot

    def get_abs(self, index):
        '''Return the abs data.

        :Parameters:
            `index` : int
                One of const starting with a name ABS_MT_
        '''
        if self._fd == -1:
            raise Exception('Device closed')
        if index < 0 or index >= MTDEV_ABS_SIZE:
            raise IndexError('Invalid index')
        return self._device.caps.abs[index]



########NEW FILE########
__FILENAME__ = OSC
#!/usr/bin/python
#
# Open SoundControl for Python
# Copyright (C) 2002 Daniel Holth, Clinton McChesney
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# For questions regarding this module contact
# Daniel Holth <dholth@stetson.edu> or visit
# http://www.stetson.edu/~ProctoLogic/
#
# Changelog:
# 15 Nov. 2001:
#   Removed dependency on Python 2.0 features.
#   - dwh
# 13 Feb. 2002:
#   Added a generic callback handler.
#   - dwh

import socket
import struct
import math
import sys
import string
import pprint


def hexDump(bytes):
    """Useful utility; prints the string in hexadecimal"""
    for i in range(len(bytes)):
        sys.stdout.write("%2x " % (ord(bytes[i])))
        if (i+1) % 8 == 0:
            print repr(bytes[i-7:i+1])

    if(len(bytes) % 8 != 0):
        print string.rjust("", 11), repr(bytes[i-len(bytes)%8:i+1])


class OSCMessage:
    """Builds typetagged OSC messages."""
    def __init__(self):
        self.address  = ""
        self.typetags = ","
        self.message  = ""

    def setAddress(self, address):
        self.address = address

    def setMessage(self, message):
        self.message = message

    def setTypetags(self, typetags):
        self.typetags = typetags

    def clear(self):
        self.address  = ""
        self.clearData()

    def clearData(self):
        self.typetags = ","
        self.message  = ""

    def append(self, argument, typehint = None):
        """Appends data to the message,
        updating the typetags based on
        the argument's type.
        If the argument is a blob (counted string)
        pass in 'b' as typehint."""

        if typehint == 'b':
            binary = OSCBlob(argument)
        else:
            binary = OSCArgument(argument)

        self.typetags = self.typetags + binary[0]
        self.rawAppend(binary[1])

    def rawAppend(self, data):
        """Appends raw data to the message.  Use append()."""
        self.message = self.message + data

    def getBinary(self):
        """Returns the binary message (so far) with typetags."""
        address  = OSCArgument(self.address)[1]
        typetags = OSCArgument(self.typetags)[1]
        return address + typetags + self.message

    def __repr__(self):
        return self.getBinary()

def readString(data):
    length   = string.find(data,"\0")
    nextData = int(math.ceil((length+1) / 4.0) * 4)
    return (data[0:length], data[nextData:])


def readBlob(data):
    length   = struct.unpack(">i", data[0:4])[0]
    nextData = int(math.ceil((length) / 4.0) * 4) + 4
    return (data[4:length+4], data[nextData:])


def readInt(data):
    if(len(data)<4):
        print "Error: too few bytes for int", data, len(data)
        rest = data
        integer = 0
    else:
        integer = struct.unpack(">i", data[0:4])[0]
        rest    = data[4:]

    return (integer, rest)



def readLong(data):
    """Tries to interpret the next 8 bytes of the data
    as a 64-bit signed integer."""
    high, low = struct.unpack(">ll", data[0:8])
    big = (long(high) << 32) + low
    rest = data[8:]
    return (big, rest)


def readDouble(data):
    """Tries to interpret the next 8 bytes of the data
    as a 64-bit double float."""
    floater = struct.unpack(">d", data[0:8])
    big = float(floater[0])
    rest = data[8:]
    return (big, rest)



def readFloat(data):
    if(len(data)<4):
        print "Error: too few bytes for float", data, len(data)
        rest = data
        float = 0
    else:
        float = struct.unpack(">f", data[0:4])[0]
        rest  = data[4:]

    return (float, rest)


def OSCBlob(next):
    """Convert a string into an OSC Blob,
    returning a (typetag, data) tuple."""

    if type(next) == type(""):
        length = len(next)
        padded = math.ceil((len(next)) / 4.0) * 4
        binary = struct.pack(">i%ds" % (padded), length, next)
        tag    = 'b'
    else:
        tag    = ''
        binary = ''

    return (tag, binary)


def OSCArgument(next):
    """Convert some Python types to their
    OSC binary representations, returning a
    (typetag, data) tuple."""

    if type(next) == type(""):
        OSCstringLength = math.ceil((len(next)+1) / 4.0) * 4
        binary  = struct.pack(">%ds" % (OSCstringLength), next)
        tag = "s"
    elif type(next) == type(42.5):
        binary  = struct.pack(">f", next)
        tag = "f"
    elif type(next) == type(13):
        binary  = struct.pack(">i", next)
        tag = "i"
    else:
        binary  = ""
        tag = ""

    return (tag, binary)


def parseArgs(args):
    """Given a list of strings, produces a list
    where those strings have been parsed (where
    possible) as floats or integers."""
    parsed = []
    for arg in args:
        print arg
        arg = arg.strip()
        interpretation = None
        try:
            interpretation = float(arg)
            if string.find(arg, ".") == -1:
                interpretation = int(interpretation)
        except:
            # Oh - it was a string.
            interpretation = arg
            pass
        parsed.append(interpretation)
    return parsed



def decodeOSC(data):
    """Converts a typetagged OSC message to a Python list."""
    table = { "i" : readInt, "f" : readFloat, "s" : readString, "b" : readBlob, "d" : readDouble }
    decoded = []
    address,  rest = readString(data)
    typetags = ""

    if address == "#bundle":
        time, rest = readLong(rest)
#       decoded.append(address)
#       decoded.append(time)
        while len(rest)>0:
            length, rest = readInt(rest)
            decoded.append(decodeOSC(rest[:length]))
            rest = rest[length:]

    elif len(rest) > 0:
        typetags, rest = readString(rest)
        decoded.append(address)
        decoded.append(typetags)
        if typetags[0] == ",":
            for tag in typetags[1:]:
                value, rest = table[tag](rest)
                decoded.append(value)
        else:
            print "Oops, typetag lacks the magic ,"

    return decoded


class CallbackManager:
    """This utility class maps OSC addresses to callables.

    The CallbackManager calls its callbacks with a list
    of decoded OSC arguments, including the address and
    the typetags as the first two arguments."""

    def __init__(self):
        self.callbacks = {}
        self.add(self.unbundler, "#bundle")

    def handle(self, data, source = None):
        """Given OSC data, tries to call the callback with the
        right address."""
        decoded = decodeOSC(data)
        self.dispatch(decoded, source)

    def dispatch(self, message, source = None):
        """Sends decoded OSC data to an appropriate calback"""
        try:
            if type(message[0]) == str :
                # got a single message
                address = message[0]
                self.callbacks[address](message, source)

            elif type(message[0]) == list :
                # smells like nested messages
                for msg in message :
                    self.dispatch(msg, source)

        except KeyError, e:
            # address not found
            print 'address %s not found ' % address
            pprint.pprint(message)
        except IndexError, e:
            print 'got malformed OSC message'
            pass
        except None, e:
            print "Exception in", address, "callback :", e

        return

    def add(self, callback, name):
        """Adds a callback to our set of callbacks,
        or removes the callback with name if callback
        is None."""
        if callback == None:
            del self.callbacks[name]
        else:
            self.callbacks[name] = callback

    def unbundler(self, messages):
        """Dispatch the messages in a decoded bundle."""
        # first two elements are #bundle and the time tag, rest are messages.
        for message in messages[2:]:
            self.dispatch(message)








if __name__ == "__main__":
    hexDump("Welcome to the OSC testing program.")
    print
    message = OSCMessage()
    message.setAddress("/foo/play")
    message.append(44)
    message.append(11)
    message.append(4.5)
    message.append("the white cliffs of dover")
    hexDump(message.getBinary())

    print "Making and unmaking a message.."

    strings = OSCMessage()
    strings.append("Mary had a little lamb")
    strings.append("its fleece was white as snow")
    strings.append("and everywhere that Mary went,")
    strings.append("the lamb was sure to go.")
    strings.append(14.5)
    strings.append(14.5)
    strings.append(-400)

    raw  = strings.getBinary()

    hexDump(raw)

    print "Retrieving arguments..."
    data = raw
    for i in range(6):
        text, data = readString(data)
        print text

    number, data = readFloat(data)
    print number

    number, data = readFloat(data)
    print number

    number, data = readInt(data)
    print number

    hexDump(raw)
    print decodeOSC(raw)
    print decodeOSC(message.getBinary())

    print "Testing Blob types."

    blob = OSCMessage()
    blob.append("","b")
    blob.append("b","b")
    blob.append("bl","b")
    blob.append("blo","b")
    blob.append("blob","b")
    blob.append("blobs","b")
    blob.append(42)

    hexDump(blob.getBinary())

    print decodeOSC(blob.getBinary())

    def printingCallback(*stuff):
        sys.stdout.write("Got: ")
        for i in stuff:
            sys.stdout.write(str(i) + " ")
        sys.stdout.write("\n")

    print "Testing the callback manager."

    c = CallbackManager()
    c.add(printingCallback, "/print")

    c.handle(message.getBinary())
    message.setAddress("/print")
    c.handle(message.getBinary())

    print1 = OSCMessage()
    print1.setAddress("/print")
    print1.append("Hey man, that's cool.")
    print1.append(42)
    print1.append(3.1415926)

    c.handle(print1.getBinary())

    bundle = OSCMessage()
    bundle.setAddress("")
    bundle.append("#bundle")
    bundle.append(0)
    bundle.append(0)
    bundle.append(print1.getBinary(), 'b')
    bundle.append(print1.getBinary(), 'b')

    bundlebinary = bundle.message

    print "sending a bundle to the callback manager"
    c.handle(bundlebinary)

########NEW FILE########
__FILENAME__ = oscAPI
'''    simpleOSC 0.2
    ixi software - July, 2006
    www.ixi-software.net

    simple API  for the Open SoundControl for Python (by Daniel Holth, Clinton
    McChesney --> pyKit.tar.gz file at http://wiretap.stetson.edu)
    Documentation at http://wiretap.stetson.edu/docs/pyKit/

    The main aim of this implementation is to provide with a simple way to deal
    with the OSC implementation that makes life easier to those who don't have
    understanding of sockets or programming. This would not be on your screen without the help
    of Daniel Holth.

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    Thanks for the support to Buchsenhausen, Innsbruck, Austria.
'''

import OSC
import socket, os, time, errno, sys
from threading import Lock
from pymt.logger import pymt_logger
try:
    # multiprocessing support is not good on window
    if sys.platform in ('win32', 'cygwin'):
        raise
    use_multiprocessing = True
    from multiprocessing import Process, Queue, Value
    import multiprocessing.synchronize
    pymt_logger.info('OSC: using <multiprocessing> for socket')
except:
    use_multiprocessing = False
    from threading import Thread
    pymt_logger.info('OSC: using <thread> for socket')

# globals
outSocket      = 0
oscThreads     = {}
oscLock        = Lock()

if use_multiprocessing:
    def _readQueue(thread_id=None):
        global oscThreads
        for id in oscThreads:
            if thread_id is not None:
                if id != thread_id:
                    continue
            thread = oscThreads[id]
            try:
                while True:
                    message = thread.queue.get_nowait()
                    thread.addressManager.handle(message)
            except:
                pass

    class _OSCServer(Process):
        def __init__(self, **kwargs):
            self.addressManager = OSC.CallbackManager()
            self.queue = Queue()
            Process.__init__(self, args=(self.queue,))
            self.daemon     = True
            self._isRunning = Value('b', True)
            self._haveSocket= Value('b', False)

        def _queue_message(self, message):
            self.queue.put(message)

        def _get_isRunning(self):
            return self._isRunning.value
        def _set_isRunning(self, value):
            self._isRunning.value = value
        isRunning = property(_get_isRunning, _set_isRunning)

        def _get_haveSocket(self):
            return self._haveSocket.value
        def _set_haveSocket(self, value):
            self._haveSocket.value = value
        haveSocket = property(_get_haveSocket, _set_haveSocket)
else:
    def _readQueue(thread_id=None):
        pass

    class _OSCServer(Thread):
        def __init__(self, **kwargs):
            Thread.__init__(self)
            self.addressManager = OSC.CallbackManager()
            self.daemon     = True
            self.isRunning  = True
            self.haveSocket = False

        def _queue_message(self, message):
            self.addressManager.handle(message)


def init() :
    '''instantiates address manager and outsocket as globals
    '''
    assert('Not used anymore')


def bind(oscid, func, oscaddress):
    '''bind given oscaddresses with given functions in address manager
    '''
    global oscThreads
    thread = oscThreads.get(oscid, None)
    if thread is None:
        assert('Unknown thread')
    thread.addressManager.add(func, oscaddress)


def sendMsg(oscAddress, dataArray=[], ipAddr='127.0.0.1', port=9000) :
    '''create and send normal OSC msgs
        defaults to '127.0.0.1', port 9000
    '''
    oscLock.acquire()
    outSocket.sendto( createBinaryMsg(oscAddress, dataArray),  (ipAddr, port))
    oscLock.release()


def createBundle():
    '''create bundled type of OSC messages
    '''
    b = OSC.OSCMessage()
    b.address = ""
    b.append("#bundle")
    b.append(0)
    b.append(0)
    return b


def appendToBundle(bundle, oscAddress, dataArray):
    '''create OSC mesage and append it to a given bundle
    '''
    bundle.append( createBinaryMsg(oscAddress, dataArray),  'b')


def sendBundle(bundle, ipAddr='127.0.0.1', port=9000) :
    '''convert bundle to a binary and send it
    '''
    oscLock.acquire()
    outSocket.sendto(bundle.message, (ipAddr, port))
    oscLock.release()


def createBinaryMsg(oscAddress, dataArray):
    '''create and return general type binary OSC msg
    '''
    m = OSC.OSCMessage()
    m.address = oscAddress

    for x in dataArray:
        m.append(x)

    return m.getBinary()

def readQueue(thread_id=None):
    '''Read queues from all threads, and dispatch message.
    This must be call in the main thread.

    You can pass the thread id to deque message from a specific thread.
    This id is returned from the listen() function'''
    return _readQueue(thread_id)


################################ receive osc from The Other.

class OSCServer(_OSCServer):
    def __init__(self, **kwargs):
        kwargs.setdefault('ipAddr', '127.0.0.1')
        kwargs.setdefault('port', 9001)
        super(OSCServer, self).__init__()
        self.ipAddr     = kwargs.get('ipAddr')
        self.port       = kwargs.get('port')

    def run(self):
        self.haveSocket = False
        # create socket
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

        # fix trouble if python leave without cleaning well the socket
        # not needed under windows, he can reuse addr even if the socket
        # are in fin2 or wait state.
        if os.name in ['posix', 'mac'] and hasattr(socket, 'SO_REUSEADDR'):
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        # try to bind the socket, retry if necessary
        while not self.haveSocket and self.isRunning:
            try :
                self.socket.bind((self.ipAddr, self.port))
                self.socket.settimeout(0.5)
                self.haveSocket = True

            except socket.error, e:
                error, message = e.args

                # special handle for EADDRINUSE
                if error == errno.EADDRINUSE:
                    pymt_logger.error('OSC: Address %s:%i already in use, retry in 2 second' % (self.ipAddr, self.port))
                else:
                    pymt_logger.exception(e)
                self.haveSocket = False

                # sleep 2 second before retry
                time.sleep(2)

        pymt_logger.info('OSC: listening for Tuio on %s:%i' % (self.ipAddr, self.port))

        while self.isRunning:
            try:
                message = self.socket.recv(65535)
                self._queue_message(message)
            except Exception, e:
                if type(e) == socket.timeout:
                    continue
                pymt_logger.error('OSC: Error in Tuio recv()')
                pymt_logger.exception(e)
                return 'no data arrived'

def listen(ipAddr='127.0.0.1', port=9001):
    '''Creates a new thread listening to that port
    defaults to ipAddr='127.0.0.1', port 9001
    '''
    global oscThreads
    id = '%s:%d' % (ipAddr, port)
    if id in oscThreads:
        return
    pymt_logger.debug('OSC: Start thread <%s>' % id)
    oscThreads[id] = OSCServer(ipAddr=ipAddr, port=port)
    oscThreads[id].start()
    return id


def dontListen(id = None):
    '''closes the socket and kills the thread
    '''
    global oscThreads
    if id and id in oscThreads:
        ids = [id]
    else:
        ids = oscThreads.keys()
    for id in ids:
        #oscThreads[id].socket.close()
        pymt_logger.debug('OSC: Stop thread <%s>' % id)
        oscThreads[id].isRunning = False
        oscThreads[id].join()
        pymt_logger.debug('OSC: Stop thread <%s> finished' % id)
        del oscThreads[id]

if __name__ == '__main__':
    # example of how to use oscAPI
    init()
    listen() # defaults to "127.0.0.1", 9001
    import time
    time.sleep(5)

    # add addresses to callback manager
    def printStuff(msg):
        '''deals with "print" tagged OSC addresses
        '''
        print "printing in the printStuff function ", msg
        print "the oscaddress is ", msg[0]
        print "the value is ", msg[2]

    bind(printStuff, "/test")

    #send normal msg, two ways
    sendMsg("/test", [1, 2, 3], "127.0.0.1", 9000)
    sendMsg("/test2", [1, 2, 3]) # defaults to "127.0.0.1", 9000
    sendMsg("/hello") # defaults to [], "127.0.0.1", 9000

    # create and send bundle, to ways to send
    bundle = createBundle()
    appendToBundle(bundle, "/testing/bundles", [1, 2, 3])
    appendToBundle(bundle, "/testing/bundles", [4, 5, 6])
    sendBundle(bundle, "127.0.0.1", 9000)
    sendBundle(bundle) # defaults to "127.0.0.1", 9000

    dontListen()  # finally close the connection bfore exiting or program


########NEW FILE########
__FILENAME__ = squirtle
'''Squirtle mini-library for SVG rendering in Pyglet.

Example usage:
    import squirtle
    my_svg = squirtle.SVG('filename.svg')
    my_svg.draw(100, 200, angle=15)

'''

__all__ = ('SVG', 'setup_gl')

from OpenGL.GL import GL_BLEND, GL_LINE_SMOOTH, GL_SRC_ALPHA, \
        GL_ONE_MINUS_SRC_ALPHA, GL_COMPILE, GL_TRIANGLES, GL_LINES, \
        GL_TRIANGLE_FAN, GL_TRIANGLE_STRIP, \
        glEnable, glGenLists, glNewList, glEndList, glPushMatrix, \
        glPopMatrix, glTranslatef, glRotatef, glScalef, glCallList, \
        glBegin, glEnd, glColor4ub, glVertex3f, glBlendFunc
from OpenGL.GLU import GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_NONZERO, \
        GLU_TESS_VERTEX, GLU_TESS_BEGIN, GLU_TESS_END, GLU_TESS_ERROR, \
        GLU_TESS_COMBINE, \
        gluTessNormal, gluTessProperty, gluNewTess, gluTessCallback, \
        gluTessBeginContour, gluTessEndContour, gluTessBeginPolygon, \
        gluTessEndPolygon, gluTessVertex, gluErrorString
from xml.etree.cElementTree import parse
import re
import math
try:
    # get the faster one
    from cStringIO import StringIO
except ImportError:
    # fallback to the default one
    from StringIO import StringIO
from pymt.logger import pymt_logger

BEZIER_POINTS = 10
CIRCLE_POINTS = 24
TOLERANCE = 0.001
def setup_gl():
    """Set various pieces of OpenGL state for better rendering of SVG.

    """
    
    glEnable(GL_LINE_SMOOTH)
    glEnable(GL_BLEND)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

def parse_list(string):
    return re.findall("([A-Za-z]|-?[0-9]+\.?[0-9]*(?:e-?[0-9]*)?)", string)

def parse_style(string):
    sdict = {}
    for item in string.split(';'):
        if ':' in item:
            key, value = item.split(':')
            sdict[key] = value
    return sdict

colormap = {
    # X11 colour table (from "CSS3 module: Color working draft"), with
    # gray/grey spelling issues fixed.  This is a superset of HTML 4.0
    # colour names used in CSS 1.
    'aliceblue': '#f0f8ff',
    'antiquewhite': '#faebd7',
    'aqua': '#00ffff',
    'aquamarine': '#7fffd4',
    'azure': '#f0ffff',
    'beige': '#f5f5dc',
    'bisque': '#ffe4c4',
    'black': '#000000',
    'blanchedalmond': '#ffebcd',
    'blue': '#0000ff',
    'blueviolet': '#8a2be2',
    'brown': '#a52a2a',
    'burlywood': '#deb887',
    'cadetblue': '#5f9ea0',
    'chartreuse': '#7fff00',
    'chocolate': '#d2691e',
    'coral': '#ff7f50',
    'cornflowerblue': '#6495ed',
    'cornsilk': '#fff8dc',
    'crimson': '#dc143c',
    'cyan': '#00ffff',
    'darkblue': '#00008b',
    'darkcyan': '#008b8b',
    'darkgoldenrod': '#b8860b',
    'darkgray': '#a9a9a9',
    'darkgrey': '#a9a9a9',
    'darkgreen': '#006400',
    'darkkhaki': '#bdb76b',
    'darkmagenta': '#8b008b',
    'darkolivegreen': '#556b2f',
    'darkorange': '#ff8c00',
    'darkorchid': '#9932cc',
    'darkred': '#8b0000',
    'darksalmon': '#e9967a',
    'darkseagreen': '#8fbc8f',
    'darkslateblue': '#483d8b',
    'darkslategray': '#2f4f4f',
    'darkslategrey': '#2f4f4f',
    'darkturquoise': '#00ced1',
    'darkviolet': '#9400d3',
    'deeppink': '#ff1493',
    'deepskyblue': '#00bfff',
    'dimgray': '#696969',
    'dimgrey': '#696969',
    'dodgerblue': '#1e90ff',
    'firebrick': '#b22222',
    'floralwhite': '#fffaf0',
    'forestgreen': '#228b22',
    'fuchsia': '#ff00ff',
    'gainsboro': '#dcdcdc',
    'ghostwhite': '#f8f8ff',
    'gold': '#ffd700',
    'goldenrod': '#daa520',
    'gray': '#808080',
    'grey': '#808080',
    'green': '#008000',
    'greenyellow': '#adff2f',
    'honeydew': '#f0fff0',
    'hotpink': '#ff69b4',
    'indianred': '#cd5c5c',
    'indigo': '#4b0082',
    'ivory': '#fffff0',
    'khaki': '#f0e68c',
    'lavender': '#e6e6fa',
    'lavenderblush': '#fff0f5',
    'lawngreen': '#7cfc00',
    'lemonchiffon': '#fffacd',
    'lightblue': '#add8e6',
    'lightcoral': '#f08080',
    'lightcyan': '#e0ffff',
    'lightgoldenrodyellow': '#fafad2',
    'lightgreen': '#90ee90',
    'lightgray': '#d3d3d3',
    'lightgrey': '#d3d3d3',
    'lightpink': '#ffb6c1',
    'lightsalmon': '#ffa07a',
    'lightseagreen': '#20b2aa',
    'lightskyblue': '#87cefa',
    'lightslategray': '#778899',
    'lightslategrey': '#778899',
    'lightsteelblue': '#b0c4de',
    'lightyellow': '#ffffe0',
    'lime': '#00ff00',
    'limegreen': '#32cd32',
    'linen': '#faf0e6',
    'magenta': '#ff00ff',
    'maroon': '#800000',
    'mediumaquamarine': '#66cdaa',
    'mediumblue': '#0000cd',
    'mediumorchid': '#ba55d3',
    'mediumpurple': '#9370db',
    'mediumseagreen': '#3cb371',
    'mediumslateblue': '#7b68ee',
    'mediumspringgreen': '#00fa9a',
    'mediumturquoise': '#48d1cc',
    'mediumvioletred': '#c71585',
    'midnightblue': '#191970',
    'mintcream': '#f5fffa',
    'mistyrose': '#ffe4e1',
    'moccasin': '#ffe4b5',
    'navajowhite': '#ffdead',
    'navy': '#000080',
    'oldlace': '#fdf5e6',
    'olive': '#808000',
    'olivedrab': '#6b8e23',
    'orange': '#ffa500',
    'orangered': '#ff4500',
    'orchid': '#da70d6',
    'palegoldenrod': '#eee8aa',
    'palegreen': '#98fb98',
    'paleturquoise': '#afeeee',
    'palevioletred': '#db7093',
    'papayawhip': '#ffefd5',
    'peachpuff': '#ffdab9',
    'peru': '#cd853f',
    'pink': '#ffc0cb',
    'plum': '#dda0dd',
    'powderblue': '#b0e0e6',
    'purple': '#800080',
    'red': '#ff0000',
    'rosybrown': '#bc8f8f',
    'royalblue': '#4169e1',
    'saddlebrown': '#8b4513',
    'salmon': '#fa8072',
    'sandybrown': '#f4a460',
    'seagreen': '#2e8b57',
    'seashell': '#fff5ee',
    'sienna': '#a0522d',
    'silver': '#c0c0c0',
    'skyblue': '#87ceeb',
    'slateblue': '#6a5acd',
    'slategray': '#708090',
    'slategrey': '#708090',
    'snow': '#fffafa',
    'springgreen': '#00ff7f',
    'steelblue': '#4682b4',
    'tan': '#d2b48c',
    'teal': '#008080',
    'thistle': '#d8bfd8',
    'tomato': '#ff6347',
    'turquoise': '#40e0d0',
    'violet': '#ee82ee',
    'wheat': '#f5deb3',
    'white': '#ffffff',
    'whitesmoke': '#f5f5f5',
    'yellow': '#ffff00',
    'yellowgreen': '#9acd32',
}


def parse_color(c, default=None):
    if not c:
        return default
    if c == 'none':
        return None
    if c[0] == '#': c = c[1:]
    if c.startswith('url(#'):
        return c[5:-1]
    try:
        if str(c) in colormap:
            c = colormap[str(c)][1:]
            r = int(c[0:2], 16)
            g = int(c[2:4], 16)
            b = int(c[4:6], 16)
        elif len(c) == 6:
            r = int(c[0:2], 16)
            g = int(c[2:4], 16)
            b = int(c[4:6], 16)
        elif len(c) == 3:
            r = int(c[0], 16) * 17
            g = int(c[1], 16) * 17
            b = int(c[2], 16) * 17
        else:
            pymt_logger.exception('Squirtle: incorrect length for color %s' % str(c))
        return [r, g, b, 255]
    except Exception, ex:
        pymt_logger.exception('Squirtle: exception parsing color %s' % str(c))
        return None

class Matrix(object):
    def __init__(self, string=None):
        self.values = [1, 0, 0, 1, 0, 0] #Identity matrix seems a sensible default
        if isinstance(string, str):
            if string.startswith('matrix('):
                self.values = [float(x) for x in parse_list(string[7:-1])]
            elif string.startswith('translate('):
                x, y = [float(x) for x in parse_list(string[10:-1])]
                self.values = [1, 0, 0, 1, x, y]
            elif string.startswith('scale('):
                sx, sy = [float(x) for x in parse_list(string[6:-1])]
                self.values = [sx, 0, 0, sy, 0, 0]
        elif string is not None:
            self.values = list(string)

    def __call__(self, other):
        return (self.values[0]*other[0] + self.values[2]*other[1] + self.values[4],
                self.values[1]*other[0] + self.values[3]*other[1] + self.values[5])

    def inverse(self):
        d = float(self.values[0]*self.values[3] - self.values[1]*self.values[2])
        return Matrix([self.values[3]/d, -self.values[1]/d, -self.values[2]/d, self.values[0]/d,
                       (self.values[2]*self.values[5] - self.values[3]*self.values[4])/d,
                       (self.values[1]*self.values[4] - self.values[0]*self.values[5])/d])

    def __mul__(self, other):
        a, b, c, d, e, f = self.values
        u, v, w, x, y, z = other.values
        return Matrix([a*u + c*v, b*u + d*v, a*w + c*x, b*w + d*x, a*y + c*z + e, b*y + d*z + f])

class TriangulationError(Exception):
    """Exception raised when triangulation of a filled area fails. For internal use only.

    """
    pass

class GradientContainer(dict):
    def __init__(self, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self.callback_dict = {}

    def call_me_on_add(self, callback, grad_id):
        '''The client wants to know when the gradient with id grad_id gets
        added.  So store this callback for when that happens.
        When the desired gradient is added, the callback will be called
        with the gradient as the first and only argument.
        '''
        cblist = self.callback_dict.get(grad_id, None)
        if cblist == None:
            cblist = [callback]
            self.callback_dict[grad_id] = cblist
            return
        cblist.append(callback)

    def update(self, *args, **kwargs):
        raise NotImplementedError('update not done for GradientContainer')

    def __setitem__(self, key, val):
        dict.__setitem__(self, key, val)
        callbacks = self.callback_dict.get(key, [])
        for callback in callbacks:
            callback(val)


class Gradient(object):
    def __init__(self, element, svg):
        self.element = element
        self.stops = {}
        for e in element.getiterator():
            if e.tag.endswith('stop'):
                style = parse_style(e.get('style', ''))
                color = parse_color(e.get('stop-color'))
                if 'stop-color' in style:
                    color = parse_color(style['stop-color'])
                color[3] = int(float(e.get('stop-opacity', '1')) * 255)
                if 'stop-opacity' in style:
                    color[3] = int(float(style['stop-opacity']) * 255)
                self.stops[float(e.get('offset'))] = color
        self.stops = sorted(self.stops.items())
        self.svg = svg
        self.inv_transform = Matrix(element.get('gradientTransform')).inverse()

        inherit = self.element.get('{http://www.w3.org/1999/xlink}href')
        parent = None
        delay_params = False
        if inherit:
            parent_id = inherit[1:]
            parent = self.svg.gradients.get(parent_id, None)
            if parent == None:
                self.svg.gradients.call_me_on_add(self.tardy_gradient_parsed, parent_id)
                delay_params = True
                return
        if not delay_params:
            self.get_params(parent)

    def interp(self, pt):
        if not self.stops: return [255, 0, 255, 255]
        t = self.grad_value(self.inv_transform(pt))
        if t < self.stops[0][0]:
            return self.stops[0][1]
        for n, top in enumerate(self.stops[1:]):
            bottom = self.stops[n]
            if t <= top[0]:
                u = bottom[0]
                v = top[0]
                alpha = (t - u)/(v - u)
                return [int(x[0] * (1 - alpha) + x[1] * alpha) for x in zip(bottom[1], top[1])]
        return self.stops[-1][1]

    def get_params(self, parent):
        for param in self.params:
            v = None
            if parent:
                v = getattr(parent, param, None)
            my_v = self.element.get(param)
            if my_v:
                v = float(my_v)
            if v:
                setattr(self, param, v)

    def tardy_gradient_parsed(self, gradient):
        self.get_params(gradient)

class LinearGradient(Gradient):
    params = ['x1', 'x2', 'y1', 'y2', 'stops']
    def grad_value(self, pt):
        return ((pt[0] - self.x1)*(self.x2 - self.x1) + (pt[1] - self.y1)*(self.y2 - self.y1)) / ((self.x1 - self.x2)**2 + (self.y1 - self.y2)**2)

class RadialGradient(Gradient):
    params = ['cx', 'cy', 'r', 'stops']

    def grad_value(self, pt):
        return math.sqrt((pt[0] - self.cx) ** 2 + (pt[1] - self.cy) ** 2)/self.r

class SVG(object):
    """Opaque SVG image object.

    Users should instantiate this object once for each SVG file they wish to
    render.

    """

    _tess = None
    _disp_list_cache = {}
    def __init__(self, filename, anchor_x=0, anchor_y=0, bezier_points=BEZIER_POINTS, circle_points=CIRCLE_POINTS, rawdata=None):
        """Creates an SVG object from a .svg or .svgz file.

            `filename`: str
                The name of the file to be loaded.
            `anchor_x`: float
                The horizontal anchor position for scaling and rotations. Defaults to 0. The symbolic
                values 'left', 'center' and 'right' are also accepted.
            `anchor_y`: float
                The vertical anchor position for scaling and rotations. Defaults to 0. The symbolic
                values 'bottom', 'center' and 'top' are also accepted.
            `bezier_points`: int
                The number of line segments into which to subdivide Bezier splines. Defaults to 10.
            `circle_points`: int
                The number of line segments into which to subdivide circular and elliptic arcs.
                Defaults to 10.
            `rawdata`: string
                Raw data string (you need to set a fake filename for cache anyway)
                Defaults to None.
        """
        self._tess = gluNewTess()
        gluTessNormal(self._tess, 0, 0, 1)
        gluTessProperty(self._tess, GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_NONZERO)

        self.filename = filename
        self.rawdata = rawdata
        self.bezier_points = bezier_points
        self.circle_points = circle_points
        self.bezier_coefficients = []
        self.gradients = GradientContainer()
        self.generate_disp_list()
        self.anchor_x = anchor_x
        self.anchor_y = anchor_y

    def _set_anchor_x(self, anchor_x):
        self._anchor_x = anchor_x
        if self._anchor_x == 'left':
            self._a_x = 0
        elif self._anchor_x == 'center':
            self._a_x = self.width * .5
        elif self._anchor_x == 'right':
            self._a_x = self.width
        else:
            self._a_x = self._anchor_x

    def _get_anchor_x(self):
        return self._anchor_x

    anchor_x = property(_get_anchor_x, _set_anchor_x)

    def _set_anchor_y(self, anchor_y):
        self._anchor_y = anchor_y
        if self._anchor_y == 'bottom':
            self._a_y = 0
        elif self._anchor_y == 'center':
            self._a_y = self.height * .5
        elif self._anchor_y == 'top':
            self._a_y = self.height
        else:
            self._a_y = self.anchor_y

    def _get_anchor_y(self):
        return self._anchor_y

    anchor_y = property(_get_anchor_y, _set_anchor_y)

    def generate_disp_list(self):
        if (self.filename, self.bezier_points) in self._disp_list_cache:
            self.disp_list, self.width, self.height = self._disp_list_cache[self.filename, self.bezier_points]
        else:
            if self.rawdata != None:
                f = StringIO(self.rawdata)
            else:
                if open(self.filename, 'rb').read(3) == '\x1f\x8b\x08': #gzip magic numbers
                    import gzip
                    f = gzip.open(self.filename, 'rb')
                else:
                    f = open(self.filename, 'rb')
            self.tree = parse(f)
            self.parse_doc()
            self.disp_list = glGenLists(1)
            glNewList(self.disp_list, GL_COMPILE)
            self.render_slowly()
            glEndList()
            self._disp_list_cache[self.filename, self.bezier_points] = (self.disp_list, self.width, self.height)

    def draw(self, x, y, z=0, angle=0, scale=1):
        """Draws the SVG to screen.

        :Parameters
            `x` : float
                The x-coordinate at which to draw.
            `y` : float
                The y-coordinate at which to draw.
            `z` : float
                The z-coordinate at which to draw. Defaults to 0. Note that z-ordering may not
                give expected results when transparency is used.
            `angle` : float
                The angle by which the image should be rotated (in degrees). Defaults to 0.
            `scale` : float
                The amount by which the image should be scaled, either as a float, or a tuple
                of two floats (xscale, yscale).

        """
        glPushMatrix()
        glTranslatef(x, y, z)
        if angle:
            glRotatef(angle, 0, 0, 1)
        if scale != 1:
            try:
                glScalef(scale[0], scale[1], 1)
            except TypeError:
                glScalef(scale, scale, 1)
        if self._a_x or self._a_y:
            glTranslatef(-self._a_x, -self._a_y, 0)
        glCallList(self.disp_list)
        glPopMatrix()

    def render_slowly(self):
        self.n_tris = 0
        self.n_lines = 0
        for path, stroke, tris, fill, transform in self.paths:
            if tris:
                self.n_tris += len(tris)/3
                if isinstance(fill, str):
                    g = self.gradients[fill]
                    fills = [g.interp(x) for x in tris]
                else:
                    fills = [fill for x in tris]
                #pyglet.graphics.draw(len(tris), GL_TRIANGLES,
                #                     ('v3f', sum((x + [0] for x in tris), [])),
                #                     ('c3B', sum(fills, [])))
                glBegin(GL_TRIANGLES)
                for vtx, clr in zip(tris, fills):
                    vtx = transform(vtx)
                    glColor4ub(*clr)
                    glVertex3f(vtx[0], vtx[1], 0)
                glEnd()
            if path:
                for loop in path:
                    self.n_lines += len(loop) - 1
                    loop_plus = []
                    for i in xrange(len(loop) - 1):
                        loop_plus += [loop[i], loop[i+1]]
                    if isinstance(stroke, str):
                        g = self.gradients[stroke]
                        strokes = [g.interp(x) for x in loop_plus]
                    else:
                        strokes = [stroke for x in loop_plus]
                    #pyglet.graphics.draw(len(loop_plus), GL_LINES,
                    #                     ('v3f', sum((x + [0] for x in loop_plus), [])),
                    #                     ('c3B', sum((stroke for x in loop_plus), [])))
                    glBegin(GL_LINES)
                    for vtx, clr in zip(loop_plus, strokes):
                        vtx = transform(vtx)
                        glColor4ub(*clr)
                        glVertex3f(vtx[0], vtx[1], 0)
                    glEnd()
    def parse_float(self, txt):
        if txt.endswith('px'):
            return float(txt[:-2])
        else:
            return float(txt)


    def parse_doc(self):
        self.paths = []
        self.width = self.parse_float(self.tree._root.get("width", '0'))
        self.height = self.parse_float(self.tree._root.get("height", '0'))
        if self.height:
            self.transform = Matrix([1, 0, 0, -1, 0, self.height])
        else:
            x, y, w, h = (self.parse_float(x) for x in parse_list(self.tree._root.get("viewBox")))
            self.transform = Matrix([1, 0, 0, -1, -x, h + y])
            self.height = h
            self.width = w
        self.opacity = 1.0
        for e in self.tree._root.getchildren():
            try:
                self.parse_element(e)
            except Exception, ex:
                pymt_logger.exception('Squirtle: exception while parsing element %s' % e)
                raise

    def parse_element(self, e):
        default = object()
        self.fill = parse_color(e.get('fill'), default)
        self.stroke = parse_color(e.get('stroke'), default)
        oldopacity = self.opacity
        self.opacity *= float(e.get('opacity', 1))
        fill_opacity = float(e.get('fill-opacity', 1))
        stroke_opacity = float(e.get('stroke-opacity', 1))

        oldtransform = self.transform
        self.transform = self.transform * Matrix(e.get('transform'))

        style = e.get('style')
        if style:
            sdict = parse_style(style)
            if 'fill' in sdict:
                self.fill = parse_color(sdict['fill'])
            if 'fill-opacity' in sdict:
                fill_opacity *= float(sdict['fill-opacity'])
            if 'stroke' in sdict:
                self.stroke = parse_color(sdict['stroke'])
            if 'stroke-opacity' in sdict:
                stroke_opacity *= float(sdict['stroke-opacity'])
        if self.fill == default:
            self.fill = [0, 0, 0, 255]
        if self.stroke == default:
            self.stroke = [0, 0, 0, 0]
        if isinstance(self.stroke, list):
            self.stroke[3] = int(self.opacity * stroke_opacity * self.stroke[3])
        if isinstance(self.fill, list):
            self.fill[3] = int(self.opacity * fill_opacity * self.fill[3])
        if isinstance(self.stroke, list) and self.stroke[3] == 0: self.stroke = self.fill #Stroked edges antialias better

        if e.tag.endswith('path'):
            pathdata = e.get('d', '')
            pathdata = re.findall("([A-Za-z]|-?[0-9]+\.?[0-9]*(?:e-?[0-9]*)?)", pathdata)

            def pnext():
                return (float(pathdata.pop(0)), float(pathdata.pop(0)))

            self.new_path()
            while pathdata:
                opcode = pathdata.pop(0)
                if opcode == 'M':
                    self.set_position(*pnext())
                elif opcode == 'C':
                    self.curve_to(*(pnext() + pnext() + pnext()))
                elif opcode == 'c':
                    mx = self.x
                    my = self.y
                    x1, y1 = pnext()
                    x2, y2 = pnext()
                    x, y = pnext()

                    self.curve_to(mx + x1, my + y1, mx + x2, my + y2, mx + x, my + y)
                elif opcode == 'S':
                    self.curve_to(2 * self.x - self.last_cx, 2 * self.y - self.last_cy, *(pnext() + pnext()))
                elif opcode == 's':
                    mx = self.x
                    my = self.y
                    x1, y1 = 2 * self.x - self.last_cx, 2 * self.y - self.last_cy
                    x2, y2 = pnext()
                    x, y = pnext()

                    self.curve_to(x1, y1, mx + x2, my + y2, mx + x, my + y)
                elif opcode == 'A':
                    rx, ry = pnext()
                    phi = float(pathdata.pop(0))
                    large_arc = int(pathdata.pop(0))
                    sweep = int(pathdata.pop(0))
                    x, y = pnext()
                    self.arc_to(rx, ry, phi, large_arc, sweep, x, y)
                elif opcode in 'zZ':
                    self.close_path()
                elif opcode == 'L':
                    self.line_to(*pnext())
                elif opcode == 'l':
                    x, y = pnext()
                    self.line_to(self.x + x, self.y + y)
                elif opcode == 'H':
                    x = float(pathdata.pop(0))
                    self.line_to(x, self.y)
                elif opcode == 'h':
                    x = float(pathdata.pop(0))
                    self.line_to(self.x + x, self.y)
                elif opcode == 'V':
                    y = float(pathdata.pop(0))
                    self.line_to(self.x, y)
                elif opcode == 'v':
                    y = float(pathdata.pop(0))
                    self.line_to(self.x, self.y + y)
                else:
                    self.warn("Unrecognised opcode: " + opcode)
            self.end_path()
        elif e.tag.endswith('rect'):
            x = 0
            y = 0
            if 'x' in e.keys():
                x = float(e.get('x'))
            if 'y' in e.keys():
                y = float(e.get('y'))
            h = float(e.get('height'))
            w = float(e.get('width'))
            self.new_path()
            self.set_position(x, y)
            self.line_to(x+w,y)
            self.line_to(x+w,y+h)
            self.line_to(x,y+h)
            self.line_to(x,y)
            self.end_path()
        elif e.tag.endswith('polyline') or e.tag.endswith('polygon'):
            pathdata = e.get('points')
            pathdata = re.findall("(-?[0-9]+\.?[0-9]*(?:e-?[0-9]*)?)", pathdata)
            def pnext():
                return (float(pathdata.pop(0)), float(pathdata.pop(0)))
            self.new_path()
            while pathdata:
                self.line_to(*pnext())
            if e.tag.endswith('polygon'):
                self.close_path()
            self.end_path()
        elif e.tag.endswith('line'):
            x1 = float(e.get('x1'))
            y1 = float(e.get('y1'))
            x2 = float(e.get('x2'))
            y2 = float(e.get('y2'))
            self.new_path()
            self.set_position(x1, y1)
            self.line_to(x2, y2)
            self.end_path()
        elif e.tag.endswith('circle'):
            cx = float(e.get('cx'))
            cy = float(e.get('cy'))
            r = float(e.get('r'))
            self.new_path()
            for i in xrange(self.circle_points):
                theta = 2 * i * math.pi / self.circle_points
                self.line_to(cx + r * math.cos(theta), cy + r * math.sin(theta))
            self.close_path()
            self.end_path()
        elif e.tag.endswith('ellipse'):
            cx = float(e.get('cx'))
            cy = float(e.get('cy'))
            rx = float(e.get('rx'))
            ry = float(e.get('ry'))
            self.new_path()
            for i in xrange(self.circle_points):
                theta = 2 * i * math.pi / self.circle_points
                self.line_to(cx + rx * math.cos(theta), cy + ry * math.sin(theta))
            self.close_path()
            self.end_path()
        elif e.tag.endswith('linearGradient'):
            self.gradients[e.get('id')] = LinearGradient(e, self)
        elif e.tag.endswith('radialGradient'):
            self.gradients[e.get('id')] = RadialGradient(e, self)
        for c in e.getchildren():
            try:
                self.parse_element(c)
            except Exception, ex:
                pymt_logger.exception('Squirtle: exception while parsing element %s' % c)
                raise
        self.transform = oldtransform
        self.opacity = oldopacity

    def new_path(self):
        self.x = 0
        self.y = 0
        self.close_index = 0
        self.path = []
        self.loop = []
    def close_path(self):
        self.loop.append(self.loop[0][:])
        self.path.append(self.loop)
        self.loop = []
    def set_position(self, x, y):
        self.x = x
        self.y = y
        self.loop.append([x,y])

    def arc_to(self, rx, ry, phi, large_arc, sweep, x, y):
        # This function is made out of magical fairy dust
        # http://www.w3.org/TR/2003/REC-SVG11-20030114/implnote.html#ArcImplementationNotes
        x1 = self.x
        y1 = self.y
        x2 = x
        y2 = y
        cp = math.cos(phi)
        sp = math.sin(phi)
        dx = .5 * (x1 - x2)
        dy = .5 * (y1 - y2)
        x_ = cp * dx + sp * dy
        y_ = -sp * dx + cp * dy
        r2 = (((rx * ry)**2 - (rx * y_)**2 - (ry * x_)**2)/
	      ((rx * y_)**2 + (ry * x_)**2))
        if r2 < 0: r2 = 0
        r = math.sqrt(r2)
        if large_arc == sweep:
            r = -r
        cx_ = r * rx * y_ / ry
        cy_ = -r * ry * x_ / rx
        cx = cp * cx_ - sp * cy_ + .5 * (x1 + x2)
        cy = sp * cx_ + cp * cy_ + .5 * (y1 + y2)
        def angle(u, v):
            a = math.acos((u[0]*v[0] + u[1]*v[1]) / math.sqrt((u[0]**2 + u[1]**2) * (v[0]**2 + v[1]**2)))
            sgn = 1 if u[0]*v[1] > u[1]*v[0] else -1
            return sgn * a

        psi = angle((1,0), ((x_ - cx_)/rx, (y_ - cy_)/ry))
        delta = angle(((x_ - cx_)/rx, (y_ - cy_)/ry),
                      ((-x_ - cx_)/rx, (-y_ - cy_)/ry))
        if sweep and delta < 0: delta += math.pi * 2
        if not sweep and delta > 0: delta -= math.pi * 2
        n_points = max(int(abs(self.circle_points * delta / (2 * math.pi))), 1)

        for i in xrange(n_points + 1):
            theta = psi + i * delta / n_points
            ct = math.cos(theta)
            st = math.sin(theta)
            self.line_to(cp * rx * ct - sp * ry * st + cx,
                         sp * rx * ct + cp * ry * st + cy)

    def curve_to(self, x1, y1, x2, y2, x, y):
        if not self.bezier_coefficients:
            for i in xrange(self.bezier_points+1):
                t = float(i)/self.bezier_points
                t0 = (1 - t) ** 3
                t1 = 3 * t * (1 - t) ** 2
                t2 = 3 * t ** 2 * (1 - t)
                t3 = t ** 3
                self.bezier_coefficients.append([t0, t1, t2, t3])
        self.last_cx = x2
        self.last_cy = y2
        for i, t in enumerate(self.bezier_coefficients):
            px = t[0] * self.x + t[1] * x1 + t[2] * x2 + t[3] * x
            py = t[0] * self.y + t[1] * y1 + t[2] * y2 + t[3] * y
            self.loop.append([px, py])

        self.x, self.y = px, py

    def line_to(self, x, y):
        self.set_position(x, y)

    def end_path(self):
        self.path.append(self.loop)
        if self.path:
            path = []
            for orig_loop in self.path:
                if not orig_loop: continue
                loop = [orig_loop[0]]
                for pt in orig_loop:
                    if (pt[0] - loop[-1][0])**2 + (pt[1] - loop[-1][1])**2 > TOLERANCE:
                        loop.append(pt)
                path.append(loop)
            self.paths.append((path if self.stroke else None, self.stroke,
                               self.triangulate(path) if self.fill else None, self.fill,
                               self.transform))
        self.path = []

    def triangulate(self, looplist):
        tlist = []
        self.curr_shape = []

        def vertexCallback(vertex):
            self.curr_shape.append(list(vertex[0:2]))

        def beginCallback(which):
            self.tess_style = which

        def endCallback():
            if self.tess_style == GL_TRIANGLE_FAN:
                c = self.curr_shape.pop(0)
                p1 = self.curr_shape.pop(0)
                while self.curr_shape:
                    p2 = self.curr_shape.pop(0)
                    tlist.extend([c, p1, p2])
                    p1 = p2
            elif self.tess_style == GL_TRIANGLE_STRIP:
                p1 = self.curr_shape.pop(0)
                p2 = self.curr_shape.pop(0)
                while self.curr_shape:
                    p3 = self.curr_shape.pop(0)
                    tlist.extend([p1, p2, p3])
                    p1 = p2
                    p2 = p3
            elif self.tess_style == GL_TRIANGLES:
                tlist.extend(self.curr_shape)
            else:
                pymt_logger.warning('Squirtle: Unrecognised tesselation style: %d' % (self.tess_style,))
            self.tess_style = None
            self.curr_shape = []

        def errorCallback(code):
            err = gluErrorString(code)
            pymt_logger.warning('Squirtle: GLU Tesselation Error: ' + err)

        def combineCallback(coords, vertex_data, weights):
            return (coords[0], coords[1], coords[2])

        gluTessCallback(self._tess, GLU_TESS_VERTEX, vertexCallback)
        gluTessCallback(self._tess, GLU_TESS_BEGIN, beginCallback)
        gluTessCallback(self._tess, GLU_TESS_END, endCallback)
        gluTessCallback(self._tess, GLU_TESS_ERROR, errorCallback)
        gluTessCallback(self._tess, GLU_TESS_COMBINE, combineCallback)

        data_lists = []
        for vlist in looplist:
            d_list = []
            for x, y in vlist:
                v_data = (x, y, 0)
                found = False
                for x2, y2, z2 in d_list:
                    d = math.sqrt((x - x2) ** 2 + (y - y2) ** 2)
                    if d < 0.0000001:
                        # XXX we've found a coordinate nearly the same as an other
                        # coordinate. this is the "COMBINE" case of GLU tesslation
                        # But on my PyOpenGL version, i got the "need combine
                        # callback" error, and i'm unable to get ride of it until
                        # the wrong vertex is removed.
                        found = True
                        break
                if found:
                    continue
                d_list.append(v_data)
            data_lists.append(d_list)
        gluTessBeginPolygon(self._tess, None)
        for d_list in data_lists:
            gluTessBeginContour(self._tess)
            for v_data in reversed(d_list):
                gluTessVertex(self._tess, v_data, v_data)
            gluTessEndContour(self._tess)
        gluTessEndPolygon(self._tess)
        return tlist

    def warn(self, message):
        pymt_logger.warning('Squirtle: svg parser on %s: %s' % (self.filename, message))

########NEW FILE########
__FILENAME__ = transformations
# -*- coding: utf-8 -*-
# transformations.py

# Copyright (c) 2006, Christoph Gohlke
# Copyright (c) 2006-2010, The Regents of the University of California
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
# * Neither the name of the copyright holders nor the names of any
#   contributors may be used to endorse or promote products derived
#   from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""Homogeneous Transformation Matrices and Quaternions.

A library for calculating 4x4 matrices for translating, rotating, reflecting,
scaling, shearing, projecting, orthogonalizing, and superimposing arrays of
3D homogeneous coordinates as well as for converting between rotation matrices,
Euler angles, and quaternions. Also includes an Arcball control object and
functions to decompose transformation matrices.

:Authors:
  `Christoph Gohlke <http://www.lfd.uci.edu/~gohlke/>`__,
  Laboratory for Fluorescence Dynamics, University of California, Irvine

:Version: 2010.05.10

Requirements
------------

* `Python 2.6 or 3.1 <http://www.python.org>`__
* `Numpy 1.4 <http://numpy.scipy.org>`__
* `transformations.c 2010.04.10 <http://www.lfd.uci.edu/~gohlke/>`__
  (optional implementation of some functions in C)

Notes
-----

The API is not stable yet and is expected to change between revisions.

This Python code is not optimized for speed. Refer to the transformations.c
module for a faster implementation of some functions.

Documentation in HTML format can be generated with epydoc.

Matrices (M) can be inverted using numpy.linalg.inv(M), concatenated using
numpy.dot(M0, M1), or used to transform homogeneous coordinates (v) using
numpy.dot(M, v) for shape (4, \*) "point of arrays", respectively
numpy.dot(v, M.T) for shape (\*, 4) "array of points".

Use the transpose of transformation matrices for OpenGL glMultMatrixd().

Calculations are carried out with numpy.float64 precision.

Vector, point, quaternion, and matrix function arguments are expected to be
"array like", i.e. tuple, list, or numpy arrays.

Return types are numpy arrays unless specified otherwise.

Angles are in radians unless specified otherwise.

Quaternions w+ix+jy+kz are represented as [w, x, y, z].

A triple of Euler angles can be applied/interpreted in 24 ways, which can
be specified using a 4 character string or encoded 4-tuple:

  *Axes 4-string*: e.g. 'sxyz' or 'ryxy'

  - first character : rotations are applied to 's'tatic or 'r'otating frame
  - remaining characters : successive rotation axis 'x', 'y', or 'z'

  *Axes 4-tuple*: e.g. (0, 0, 0, 0) or (1, 1, 1, 1)

  - inner axis: code of axis ('x':0, 'y':1, 'z':2) of rightmost matrix.
  - parity : even (0) if inner axis 'x' is followed by 'y', 'y' is followed
    by 'z', or 'z' is followed by 'x'. Otherwise odd (1).
  - repetition : first and last axis are same (1) or different (0).
  - frame : rotations are applied to static (0) or rotating (1) frame.

References
----------

(1)  Matrices and transformations. Ronald Goldman.
     In "Graphics Gems I", pp 472-475. Morgan Kaufmann, 1990.
(2)  More matrices and transformations: shear and pseudo-perspective.
     Ronald Goldman. In "Graphics Gems II", pp 320-323. Morgan Kaufmann, 1991.
(3)  Decomposing a matrix into simple transformations. Spencer Thomas.
     In "Graphics Gems II", pp 320-323. Morgan Kaufmann, 1991.
(4)  Recovering the data from the transformation matrix. Ronald Goldman.
     In "Graphics Gems II", pp 324-331. Morgan Kaufmann, 1991.
(5)  Euler angle conversion. Ken Shoemake.
     In "Graphics Gems IV", pp 222-229. Morgan Kaufmann, 1994.
(6)  Arcball rotation control. Ken Shoemake.
     In "Graphics Gems IV", pp 175-192. Morgan Kaufmann, 1994.
(7)  Representing attitude: Euler angles, unit quaternions, and rotation
     vectors. James Diebel. 2006.
(8)  A discussion of the solution for the best rotation to relate two sets
     of vectors. W Kabsch. Acta Cryst. 1978. A34, 827-828.
(9)  Closed-form solution of absolute orientation using unit quaternions.
     BKP Horn. J Opt Soc Am A. 1987. 4(4):629-642.
(10) Quaternions. Ken Shoemake.
     http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf
(11) From quaternion to matrix and back. JMP van Waveren. 2005.
     http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm
(12) Uniform random rotations. Ken Shoemake.
     In "Graphics Gems III", pp 124-132. Morgan Kaufmann, 1992.
(13) Quaternion in molecular modeling. CFF Karney.
     J Mol Graph Mod, 25(5):595-604
(14) New method for extracting the quaternion from a rotation matrix.
     Itzhack Y Bar-Itzhack, J Guid Contr Dynam. 2000. 23(6): 1085-1087.

Examples
--------

>>> alpha, beta, gamma = 0.123, -1.234, 2.345
>>> origin, xaxis, yaxis, zaxis = (0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)
>>> I = identity_matrix()
>>> Rx = rotation_matrix(alpha, xaxis)
>>> Ry = rotation_matrix(beta, yaxis)
>>> Rz = rotation_matrix(gamma, zaxis)
>>> R = concatenate_matrices(Rx, Ry, Rz)
>>> euler = euler_from_matrix(R, 'rxyz')
>>> numpy.allclose([alpha, beta, gamma], euler)
True
>>> Re = euler_matrix(alpha, beta, gamma, 'rxyz')
>>> is_same_transform(R, Re)
True
>>> al, be, ga = euler_from_matrix(Re, 'rxyz')
>>> is_same_transform(Re, euler_matrix(al, be, ga, 'rxyz'))
True
>>> qx = quaternion_about_axis(alpha, xaxis)
>>> qy = quaternion_about_axis(beta, yaxis)
>>> qz = quaternion_about_axis(gamma, zaxis)
>>> q = quaternion_multiply(qx, qy)
>>> q = quaternion_multiply(q, qz)
>>> Rq = quaternion_matrix(q)
>>> is_same_transform(R, Rq)
True
>>> S = scale_matrix(1.23, origin)
>>> T = translation_matrix((1, 2, 3))
>>> Z = shear_matrix(beta, xaxis, origin, zaxis)
>>> R = random_rotation_matrix(numpy.random.rand(3))
>>> M = concatenate_matrices(T, R, Z, S)
>>> scale, shear, angles, trans, persp = decompose_matrix(M)
>>> numpy.allclose(scale, 1.23)
True
>>> numpy.allclose(trans, (1, 2, 3))
True
>>> numpy.allclose(shear, (0, math.tan(beta), 0))
True
>>> is_same_transform(R, euler_matrix(axes='sxyz', *angles))
True
>>> M1 = compose_matrix(scale, shear, angles, trans, persp)
>>> is_same_transform(M, M1)
True

"""

from __future__ import division, print_function

import sys
import os
import warnings
import math

import numpy


def identity_matrix():
    """Return 4x4 identity/unit matrix.

    >>> I = identity_matrix()
    >>> numpy.allclose(I, numpy.dot(I, I))
    True
    >>> numpy.sum(I), numpy.trace(I)
    (4.0, 4.0)
    >>> numpy.allclose(I, numpy.identity(4, dtype=numpy.float64))
    True

    """
    return numpy.identity(4, dtype=numpy.float64)


def translation_matrix(direction):
    """Return matrix to translate by direction vector.

    >>> v = numpy.random.random(3) - 0.5
    >>> numpy.allclose(v, translation_matrix(v)[:3, 3])
    True

    """
    M = numpy.identity(4)
    M[:3, 3] = direction[:3]
    return M


def translation_from_matrix(matrix):
    """Return translation vector from translation matrix.

    >>> v0 = numpy.random.random(3) - 0.5
    >>> v1 = translation_from_matrix(translation_matrix(v0))
    >>> numpy.allclose(v0, v1)
    True

    """
    return numpy.array(matrix, copy=False)[:3, 3].copy()


def reflection_matrix(point, normal):
    """Return matrix to mirror at plane defined by point and normal vector.

    >>> v0 = numpy.random.random(4) - 0.5
    >>> v0[3] = 1.0
    >>> v1 = numpy.random.random(3) - 0.5
    >>> R = reflection_matrix(v0, v1)
    >>> numpy.allclose(2., numpy.trace(R))
    True
    >>> numpy.allclose(v0, numpy.dot(R, v0))
    True
    >>> v2 = v0.copy()
    >>> v2[:3] += v1
    >>> v3 = v0.copy()
    >>> v2[:3] -= v1
    >>> numpy.allclose(v2, numpy.dot(R, v3))
    True

    """
    normal = unit_vector(normal[:3])
    M = numpy.identity(4)
    M[:3, :3] -= 2.0 * numpy.outer(normal, normal)
    M[:3, 3] = (2.0 * numpy.dot(point[:3], normal)) * normal
    return M


def reflection_from_matrix(matrix):
    """Return mirror plane point and normal vector from reflection matrix.

    >>> v0 = numpy.random.random(3) - 0.5
    >>> v1 = numpy.random.random(3) - 0.5
    >>> M0 = reflection_matrix(v0, v1)
    >>> point, normal = reflection_from_matrix(M0)
    >>> M1 = reflection_matrix(point, normal)
    >>> is_same_transform(M0, M1)
    True

    """
    M = numpy.array(matrix, dtype=numpy.float64, copy=False)
    # normal: unit eigenvector corresponding to eigenvalue -1
    l, V = numpy.linalg.eig(M[:3, :3])
    i = numpy.where(abs(numpy.real(l) + 1.0) < 1e-8)[0]
    if not len(i):
        raise ValueError("no unit eigenvector corresponding to eigenvalue -1")
    normal = numpy.real(V[:, i[0]]).squeeze()
    # point: any unit eigenvector corresponding to eigenvalue 1
    l, V = numpy.linalg.eig(M)
    i = numpy.where(abs(numpy.real(l) - 1.0) < 1e-8)[0]
    if not len(i):
        raise ValueError("no unit eigenvector corresponding to eigenvalue 1")
    point = numpy.real(V[:, i[-1]]).squeeze()
    point /= point[3]
    return point, normal


def rotation_matrix(angle, direction, point=None):
    """Return matrix to rotate about axis defined by point and direction.

    >>> R = rotation_matrix(math.pi/2.0, [0, 0, 1], [1, 0, 0])
    >>> numpy.allclose(numpy.dot(R, [0, 0, 0, 1]), [ 1., -1.,  0.,  1.])
    True
    >>> angle = (random.random() - 0.5) * (2*math.pi)
    >>> direc = numpy.random.random(3) - 0.5
    >>> point = numpy.random.random(3) - 0.5
    >>> R0 = rotation_matrix(angle, direc, point)
    >>> R1 = rotation_matrix(angle-2*math.pi, direc, point)
    >>> is_same_transform(R0, R1)
    True
    >>> R0 = rotation_matrix(angle, direc, point)
    >>> R1 = rotation_matrix(-angle, -direc, point)
    >>> is_same_transform(R0, R1)
    True
    >>> I = numpy.identity(4, numpy.float64)
    >>> numpy.allclose(I, rotation_matrix(math.pi*2, direc))
    True
    >>> numpy.allclose(2., numpy.trace(rotation_matrix(math.pi/2,
    ...                                                direc, point)))
    True

    """
    sina = math.sin(angle)
    cosa = math.cos(angle)
    direction = unit_vector(direction[:3])
    # rotation matrix around unit vector
    R = numpy.array(((cosa, 0.0,  0.0),
                     (0.0,  cosa, 0.0),
                     (0.0,  0.0,  cosa)), dtype=numpy.float64)
    R += numpy.outer(direction, direction) * (1.0 - cosa)
    direction *= sina
    R += numpy.array((( 0.0,         -direction[2],  direction[1]),
                      ( direction[2], 0.0,          -direction[0]),
                      (-direction[1], direction[0],  0.0)),
                     dtype=numpy.float64)
    M = numpy.identity(4)
    M[:3, :3] = R
    if point is not None:
        # rotation not around origin
        point = numpy.array(point[:3], dtype=numpy.float64, copy=False)
        M[:3, 3] = point - numpy.dot(R, point)
    return M


def rotation_from_matrix(matrix):
    """Return rotation angle and axis from rotation matrix.

    >>> angle = (random.random() - 0.5) * (2*math.pi)
    >>> direc = numpy.random.random(3) - 0.5
    >>> point = numpy.random.random(3) - 0.5
    >>> R0 = rotation_matrix(angle, direc, point)
    >>> angle, direc, point = rotation_from_matrix(R0)
    >>> R1 = rotation_matrix(angle, direc, point)
    >>> is_same_transform(R0, R1)
    True

    """
    R = numpy.array(matrix, dtype=numpy.float64, copy=False)
    R33 = R[:3, :3]
    # direction: unit eigenvector of R33 corresponding to eigenvalue of 1
    l, W = numpy.linalg.eig(R33.T)
    i = numpy.where(abs(numpy.real(l) - 1.0) < 1e-8)[0]
    if not len(i):
        raise ValueError("no unit eigenvector corresponding to eigenvalue 1")
    direction = numpy.real(W[:, i[-1]]).squeeze()
    # point: unit eigenvector of R33 corresponding to eigenvalue of 1
    l, Q = numpy.linalg.eig(R)
    i = numpy.where(abs(numpy.real(l) - 1.0) < 1e-8)[0]
    if not len(i):
        raise ValueError("no unit eigenvector corresponding to eigenvalue 1")
    point = numpy.real(Q[:, i[-1]]).squeeze()
    point /= point[3]
    # rotation angle depending on direction
    cosa = (numpy.trace(R33) - 1.0) / 2.0
    if abs(direction[2]) > 1e-8:
        sina = (R[1, 0] + (cosa-1.0)*direction[0]*direction[1]) / direction[2]
    elif abs(direction[1]) > 1e-8:
        sina = (R[0, 2] + (cosa-1.0)*direction[0]*direction[2]) / direction[1]
    else:
        sina = (R[2, 1] + (cosa-1.0)*direction[1]*direction[2]) / direction[0]
    angle = math.atan2(sina, cosa)
    return angle, direction, point


def scale_matrix(factor, origin=None, direction=None):
    """Return matrix to scale by factor around origin in direction.

    Use factor -1 for point symmetry.

    >>> v = (numpy.random.rand(4, 5) - 0.5) * 20.0
    >>> v[3] = 1.0
    >>> S = scale_matrix(-1.234)
    >>> numpy.allclose(numpy.dot(S, v)[:3], -1.234*v[:3])
    True
    >>> factor = random.random() * 10 - 5
    >>> origin = numpy.random.random(3) - 0.5
    >>> direct = numpy.random.random(3) - 0.5
    >>> S = scale_matrix(factor, origin)
    >>> S = scale_matrix(factor, origin, direct)

    """
    if direction is None:
        # uniform scaling
        M = numpy.array(((factor, 0.0,    0.0,    0.0),
                         (0.0,    factor, 0.0,    0.0),
                         (0.0,    0.0,    factor, 0.0),
                         (0.0,    0.0,    0.0,    1.0)), dtype=numpy.float64)
        if origin is not None:
            M[:3, 3] = origin[:3]
            M[:3, 3] *= 1.0 - factor
    else:
        # nonuniform scaling
        direction = unit_vector(direction[:3])
        factor = 1.0 - factor
        M = numpy.identity(4)
        M[:3, :3] -= factor * numpy.outer(direction, direction)
        if origin is not None:
            M[:3, 3] = (factor * numpy.dot(origin[:3], direction)) * direction
    return M


def scale_from_matrix(matrix):
    """Return scaling factor, origin and direction from scaling matrix.

    >>> factor = random.random() * 10 - 5
    >>> origin = numpy.random.random(3) - 0.5
    >>> direct = numpy.random.random(3) - 0.5
    >>> S0 = scale_matrix(factor, origin)
    >>> factor, origin, direction = scale_from_matrix(S0)
    >>> S1 = scale_matrix(factor, origin, direction)
    >>> is_same_transform(S0, S1)
    True
    >>> S0 = scale_matrix(factor, origin, direct)
    >>> factor, origin, direction = scale_from_matrix(S0)
    >>> S1 = scale_matrix(factor, origin, direction)
    >>> is_same_transform(S0, S1)
    True

    """
    M = numpy.array(matrix, dtype=numpy.float64, copy=False)
    M33 = M[:3, :3]
    factor = numpy.trace(M33) - 2.0
    try:
        # direction: unit eigenvector corresponding to eigenvalue factor
        l, V = numpy.linalg.eig(M33)
        i = numpy.where(abs(numpy.real(l) - factor) < 1e-8)[0][0]
        direction = numpy.real(V[:, i]).squeeze()
        direction /= vector_norm(direction)
    except IndexError:
        # uniform scaling
        factor = (factor + 2.0) / 3.0
        direction = None
    # origin: any eigenvector corresponding to eigenvalue 1
    l, V = numpy.linalg.eig(M)
    i = numpy.where(abs(numpy.real(l) - 1.0) < 1e-8)[0]
    if not len(i):
        raise ValueError("no eigenvector corresponding to eigenvalue 1")
    origin = numpy.real(V[:, i[-1]]).squeeze()
    origin /= origin[3]
    return factor, origin, direction


def projection_matrix(point, normal, direction=None,
                      perspective=None, pseudo=False):
    """Return matrix to project onto plane defined by point and normal.

    Using either perspective point, projection direction, or none of both.

    If pseudo is True, perspective projections will preserve relative depth
    such that Perspective = dot(Orthogonal, PseudoPerspective).

    >>> P = projection_matrix((0, 0, 0), (1, 0, 0))
    >>> numpy.allclose(P[1:, 1:], numpy.identity(4)[1:, 1:])
    True
    >>> point = numpy.random.random(3) - 0.5
    >>> normal = numpy.random.random(3) - 0.5
    >>> direct = numpy.random.random(3) - 0.5
    >>> persp = numpy.random.random(3) - 0.5
    >>> P0 = projection_matrix(point, normal)
    >>> P1 = projection_matrix(point, normal, direction=direct)
    >>> P2 = projection_matrix(point, normal, perspective=persp)
    >>> P3 = projection_matrix(point, normal, perspective=persp, pseudo=True)
    >>> is_same_transform(P2, numpy.dot(P0, P3))
    True
    >>> P = projection_matrix((3, 0, 0), (1, 1, 0), (1, 0, 0))
    >>> v0 = (numpy.random.rand(4, 5) - 0.5) * 20.0
    >>> v0[3] = 1.0
    >>> v1 = numpy.dot(P, v0)
    >>> numpy.allclose(v1[1], v0[1])
    True
    >>> numpy.allclose(v1[0], 3.0-v1[1])
    True

    """
    M = numpy.identity(4)
    point = numpy.array(point[:3], dtype=numpy.float64, copy=False)
    normal = unit_vector(normal[:3])
    if perspective is not None:
        # perspective projection
        perspective = numpy.array(perspective[:3], dtype=numpy.float64,
                                  copy=False)
        M[0, 0] = M[1, 1] = M[2, 2] = numpy.dot(perspective-point, normal)
        M[:3, :3] -= numpy.outer(perspective, normal)
        if pseudo:
            # preserve relative depth
            M[:3, :3] -= numpy.outer(normal, normal)
            M[:3, 3] = numpy.dot(point, normal) * (perspective+normal)
        else:
            M[:3, 3] = numpy.dot(point, normal) * perspective
        M[3, :3] = -normal
        M[3, 3] = numpy.dot(perspective, normal)
    elif direction is not None:
        # parallel projection
        direction = numpy.array(direction[:3], dtype=numpy.float64, copy=False)
        scale = numpy.dot(direction, normal)
        M[:3, :3] -= numpy.outer(direction, normal) / scale
        M[:3, 3] = direction * (numpy.dot(point, normal) / scale)
    else:
        # orthogonal projection
        M[:3, :3] -= numpy.outer(normal, normal)
        M[:3, 3] = numpy.dot(point, normal) * normal
    return M


def projection_from_matrix(matrix, pseudo=False):
    """Return projection plane and perspective point from projection matrix.

    Return values are same as arguments for projection_matrix function:
    point, normal, direction, perspective, and pseudo.

    >>> point = numpy.random.random(3) - 0.5
    >>> normal = numpy.random.random(3) - 0.5
    >>> direct = numpy.random.random(3) - 0.5
    >>> persp = numpy.random.random(3) - 0.5
    >>> P0 = projection_matrix(point, normal)
    >>> result = projection_from_matrix(P0)
    >>> P1 = projection_matrix(*result)
    >>> is_same_transform(P0, P1)
    True
    >>> P0 = projection_matrix(point, normal, direct)
    >>> result = projection_from_matrix(P0)
    >>> P1 = projection_matrix(*result)
    >>> is_same_transform(P0, P1)
    True
    >>> P0 = projection_matrix(point, normal, perspective=persp, pseudo=False)
    >>> result = projection_from_matrix(P0, pseudo=False)
    >>> P1 = projection_matrix(*result)
    >>> is_same_transform(P0, P1)
    True
    >>> P0 = projection_matrix(point, normal, perspective=persp, pseudo=True)
    >>> result = projection_from_matrix(P0, pseudo=True)
    >>> P1 = projection_matrix(*result)
    >>> is_same_transform(P0, P1)
    True

    """
    M = numpy.array(matrix, dtype=numpy.float64, copy=False)
    M33 = M[:3, :3]
    l, V = numpy.linalg.eig(M)
    i = numpy.where(abs(numpy.real(l) - 1.0) < 1e-8)[0]
    if not pseudo and len(i):
        # point: any eigenvector corresponding to eigenvalue 1
        point = numpy.real(V[:, i[-1]]).squeeze()
        point /= point[3]
        # direction: unit eigenvector corresponding to eigenvalue 0
        l, V = numpy.linalg.eig(M33)
        i = numpy.where(abs(numpy.real(l)) < 1e-8)[0]
        if not len(i):
            raise ValueError("no eigenvector corresponding to eigenvalue 0")
        direction = numpy.real(V[:, i[0]]).squeeze()
        direction /= vector_norm(direction)
        # normal: unit eigenvector of M33.T corresponding to eigenvalue 0
        l, V = numpy.linalg.eig(M33.T)
        i = numpy.where(abs(numpy.real(l)) < 1e-8)[0]
        if len(i):
            # parallel projection
            normal = numpy.real(V[:, i[0]]).squeeze()
            normal /= vector_norm(normal)
            return point, normal, direction, None, False
        else:
            # orthogonal projection, where normal equals direction vector
            return point, direction, None, None, False
    else:
        # perspective projection
        i = numpy.where(abs(numpy.real(l)) > 1e-8)[0]
        if not len(i):
            raise ValueError(
                "no eigenvector not corresponding to eigenvalue 0")
        point = numpy.real(V[:, i[-1]]).squeeze()
        point /= point[3]
        normal = - M[3, :3]
        perspective = M[:3, 3] / numpy.dot(point[:3], normal)
        if pseudo:
            perspective -= normal
        return point, normal, None, perspective, pseudo


def clip_matrix(left, right, bottom, top, near, far, perspective=False):
    """Return matrix to obtain normalized device coordinates from frustrum.

    The frustrum bounds are axis-aligned along x (left, right),
    y (bottom, top) and z (near, far).

    Normalized device coordinates are in range [-1, 1] if coordinates are
    inside the frustrum.

    If perspective is True the frustrum is a truncated pyramid with the
    perspective point at origin and direction along z axis, otherwise an
    orthographic canonical view volume (a box).

    Homogeneous coordinates transformed by the perspective clip matrix
    need to be dehomogenized (devided by w coordinate).

    >>> frustrum = numpy.random.rand(6)
    >>> frustrum[1] += frustrum[0]
    >>> frustrum[3] += frustrum[2]
    >>> frustrum[5] += frustrum[4]
    >>> M = clip_matrix(perspective=False, *frustrum)
    >>> numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0])
    array([-1., -1., -1.,  1.])
    >>> numpy.dot(M, [frustrum[1], frustrum[3], frustrum[5], 1.0])
    array([ 1.,  1.,  1.,  1.])
    >>> M = clip_matrix(perspective=True, *frustrum)
    >>> v = numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0])
    >>> v / v[3]
    array([-1., -1., -1.,  1.])
    >>> v = numpy.dot(M, [frustrum[1], frustrum[3], frustrum[4], 1.0])
    >>> v / v[3]
    array([ 1.,  1., -1.,  1.])

    """
    if left >= right or bottom >= top or near >= far:
        raise ValueError("invalid frustrum")
    if perspective:
        if near <= _EPS:
            raise ValueError("invalid frustrum: near <= 0")
        t = 2.0 * near
        M = ((-t/(right-left), 0.0, (right+left)/(right-left), 0.0),
             (0.0, -t/(top-bottom), (top+bottom)/(top-bottom), 0.0),
             (0.0, 0.0, -(far+near)/(far-near), t*far/(far-near)),
             (0.0, 0.0, -1.0, 0.0))
    else:
        M = ((2.0/(right-left), 0.0, 0.0, (right+left)/(left-right)),
             (0.0, 2.0/(top-bottom), 0.0, (top+bottom)/(bottom-top)),
             (0.0, 0.0, 2.0/(far-near), (far+near)/(near-far)),
             (0.0, 0.0, 0.0, 1.0))
    return numpy.array(M, dtype=numpy.float64)


def shear_matrix(angle, direction, point, normal):
    """Return matrix to shear by angle along direction vector on shear plane.

    The shear plane is defined by a point and normal vector. The direction
    vector must be orthogonal to the plane's normal vector.

    A point P is transformed by the shear matrix into P" such that
    the vector P-P" is parallel to the direction vector and its extent is
    given by the angle of P-P'-P", where P' is the orthogonal projection
    of P onto the shear plane.

    >>> angle = (random.random() - 0.5) * 4*math.pi
    >>> direct = numpy.random.random(3) - 0.5
    >>> point = numpy.random.random(3) - 0.5
    >>> normal = numpy.cross(direct, numpy.random.random(3))
    >>> S = shear_matrix(angle, direct, point, normal)
    >>> numpy.allclose(1.0, numpy.linalg.det(S))
    True

    """
    normal = unit_vector(normal[:3])
    direction = unit_vector(direction[:3])
    if abs(numpy.dot(normal, direction)) > 1e-6:
        raise ValueError("direction and normal vectors are not orthogonal")
    angle = math.tan(angle)
    M = numpy.identity(4)
    M[:3, :3] += angle * numpy.outer(direction, normal)
    M[:3, 3] = -angle * numpy.dot(point[:3], normal) * direction
    return M


def shear_from_matrix(matrix):
    """Return shear angle, direction and plane from shear matrix.

    >>> angle = (random.random() - 0.5) * 4*math.pi
    >>> direct = numpy.random.random(3) - 0.5
    >>> point = numpy.random.random(3) - 0.5
    >>> normal = numpy.cross(direct, numpy.random.random(3))
    >>> S0 = shear_matrix(angle, direct, point, normal)
    >>> angle, direct, point, normal = shear_from_matrix(S0)
    >>> S1 = shear_matrix(angle, direct, point, normal)
    >>> is_same_transform(S0, S1)
    True

    """
    M = numpy.array(matrix, dtype=numpy.float64, copy=False)
    M33 = M[:3, :3]
    # normal: cross independent eigenvectors corresponding to the eigenvalue 1
    l, V = numpy.linalg.eig(M33)
    i = numpy.where(abs(numpy.real(l) - 1.0) < 1e-4)[0]
    if len(i) < 2:
        raise ValueError("no two linear independent eigenvectors found %s" % l)
    V = numpy.real(V[:, i]).squeeze().T
    lenorm = -1.0
    for i0, i1 in ((0, 1), (0, 2), (1, 2)):
        n = numpy.cross(V[i0], V[i1])
        l = vector_norm(n)
        if l > lenorm:
            lenorm = l
            normal = n
    normal /= lenorm
    # direction and angle
    direction = numpy.dot(M33 - numpy.identity(3), normal)
    angle = vector_norm(direction)
    direction /= angle
    angle = math.atan(angle)
    # point: eigenvector corresponding to eigenvalue 1
    l, V = numpy.linalg.eig(M)
    i = numpy.where(abs(numpy.real(l) - 1.0) < 1e-8)[0]
    if not len(i):
        raise ValueError("no eigenvector corresponding to eigenvalue 1")
    point = numpy.real(V[:, i[-1]]).squeeze()
    point /= point[3]
    return angle, direction, point, normal


def decompose_matrix(matrix):
    """Return sequence of transformations from transformation matrix.

    matrix : array_like
        Non-degenerative homogeneous transformation matrix

    Return tuple of:
        scale : vector of 3 scaling factors
        shear : list of shear factors for x-y, x-z, y-z axes
        angles : list of Euler angles about static x, y, z axes
        translate : translation vector along x, y, z axes
        perspective : perspective partition of matrix

    Raise ValueError if matrix is of wrong type or degenerative.

    >>> T0 = translation_matrix((1, 2, 3))
    >>> scale, shear, angles, trans, persp = decompose_matrix(T0)
    >>> T1 = translation_matrix(trans)
    >>> numpy.allclose(T0, T1)
    True
    >>> S = scale_matrix(0.123)
    >>> scale, shear, angles, trans, persp = decompose_matrix(S)
    >>> scale[0]
    0.123
    >>> R0 = euler_matrix(1, 2, 3)
    >>> scale, shear, angles, trans, persp = decompose_matrix(R0)
    >>> R1 = euler_matrix(*angles)
    >>> numpy.allclose(R0, R1)
    True

    """
    M = numpy.array(matrix, dtype=numpy.float64, copy=True).T
    if abs(M[3, 3]) < _EPS:
        raise ValueError("M[3, 3] is zero")
    M /= M[3, 3]
    P = M.copy()
    P[:, 3] = 0, 0, 0, 1
    if not numpy.linalg.det(P):
        raise ValueError("matrix is singular")

    scale = numpy.zeros((3, ), dtype=numpy.float64)
    shear = [0, 0, 0]
    angles = [0, 0, 0]

    if any(abs(M[:3, 3]) > _EPS):
        perspective = numpy.dot(M[:, 3], numpy.linalg.inv(P.T))
        M[:, 3] = 0, 0, 0, 1
    else:
        perspective = numpy.array((0, 0, 0, 1), dtype=numpy.float64)

    translate = M[3, :3].copy()
    M[3, :3] = 0

    row = M[:3, :3].copy()
    scale[0] = vector_norm(row[0])
    row[0] /= scale[0]
    shear[0] = numpy.dot(row[0], row[1])
    row[1] -= row[0] * shear[0]
    scale[1] = vector_norm(row[1])
    row[1] /= scale[1]
    shear[0] /= scale[1]
    shear[1] = numpy.dot(row[0], row[2])
    row[2] -= row[0] * shear[1]
    shear[2] = numpy.dot(row[1], row[2])
    row[2] -= row[1] * shear[2]
    scale[2] = vector_norm(row[2])
    row[2] /= scale[2]
    shear[1:] /= scale[2]

    if numpy.dot(row[0], numpy.cross(row[1], row[2])) < 0:
        scale *= -1
        row *= -1

    angles[1] = math.asin(-row[0, 2])
    if math.cos(angles[1]):
        angles[0] = math.atan2(row[1, 2], row[2, 2])
        angles[2] = math.atan2(row[0, 1], row[0, 0])
    else:
        #angles[0] = math.atan2(row[1, 0], row[1, 1])
        angles[0] = math.atan2(-row[2, 1], row[1, 1])
        angles[2] = 0.0

    return scale, shear, angles, translate, perspective


def compose_matrix(scale=None, shear=None, angles=None, translate=None,
                   perspective=None):
    """Return transformation matrix from sequence of transformations.

    This is the inverse of the decompose_matrix function.

    Sequence of transformations:
        scale : vector of 3 scaling factors
        shear : list of shear factors for x-y, x-z, y-z axes
        angles : list of Euler angles about static x, y, z axes
        translate : translation vector along x, y, z axes
        perspective : perspective partition of matrix

    >>> scale = numpy.random.random(3) - 0.5
    >>> shear = numpy.random.random(3) - 0.5
    >>> angles = (numpy.random.random(3) - 0.5) * (2*math.pi)
    >>> trans = numpy.random.random(3) - 0.5
    >>> persp = numpy.random.random(4) - 0.5
    >>> M0 = compose_matrix(scale, shear, angles, trans, persp)
    >>> result = decompose_matrix(M0)
    >>> M1 = compose_matrix(*result)
    >>> is_same_transform(M0, M1)
    True

    """
    M = numpy.identity(4)
    if perspective is not None:
        P = numpy.identity(4)
        P[3, :] = perspective[:4]
        M = numpy.dot(M, P)
    if translate is not None:
        T = numpy.identity(4)
        T[:3, 3] = translate[:3]
        M = numpy.dot(M, T)
    if angles is not None:
        R = euler_matrix(angles[0], angles[1], angles[2], 'sxyz')
        M = numpy.dot(M, R)
    if shear is not None:
        Z = numpy.identity(4)
        Z[1, 2] = shear[2]
        Z[0, 2] = shear[1]
        Z[0, 1] = shear[0]
        M = numpy.dot(M, Z)
    if scale is not None:
        S = numpy.identity(4)
        S[0, 0] = scale[0]
        S[1, 1] = scale[1]
        S[2, 2] = scale[2]
        M = numpy.dot(M, S)
    M /= M[3, 3]
    return M


def orthogonalization_matrix(lengths, angles):
    """Return orthogonalization matrix for crystallographic cell coordinates.

    Angles are expected in degrees.

    The de-orthogonalization matrix is the inverse.

    >>> O = orthogonalization_matrix((10., 10., 10.), (90., 90., 90.))
    >>> numpy.allclose(O[:3, :3], numpy.identity(3, float) * 10)
    True
    >>> O = orthogonalization_matrix([9.8, 12.0, 15.5], [87.2, 80.7, 69.7])
    >>> numpy.allclose(numpy.sum(O), 43.063229)
    True

    """
    a, b, c = lengths
    angles = numpy.radians(angles)
    sina, sinb, _ = numpy.sin(angles)
    cosa, cosb, cosg = numpy.cos(angles)
    co = (cosa * cosb - cosg) / (sina * sinb)
    return numpy.array((
        ( a*sinb*math.sqrt(1.0-co*co),  0.0,    0.0, 0.0),
        (-a*sinb*co,                    b*sina, 0.0, 0.0),
        ( a*cosb,                       b*cosa, c,   0.0),
        ( 0.0,                          0.0,    0.0, 1.0)),
        dtype=numpy.float64)


def superimposition_matrix(v0, v1, scaling=False, usesvd=True):
    """Return matrix to transform given vector set into second vector set.

    v0 and v1 are shape (3, \*) or (4, \*) arrays of at least 3 vectors.

    If usesvd is True, the weighted sum of squared deviations (RMSD) is
    minimized according to the algorithm by W. Kabsch [8]. Otherwise the
    quaternion based algorithm by B. Horn [9] is used (slower when using
    this Python implementation).

    The returned matrix performs rotation, translation and uniform scaling
    (if specified).

    >>> v0 = numpy.random.rand(3, 10)
    >>> M = superimposition_matrix(v0, v0)
    >>> numpy.allclose(M, numpy.identity(4))
    True
    >>> R = random_rotation_matrix(numpy.random.random(3))
    >>> v0 = ((1,0,0), (0,1,0), (0,0,1), (1,1,1))
    >>> v1 = numpy.dot(R, v0)
    >>> M = superimposition_matrix(v0, v1)
    >>> numpy.allclose(v1, numpy.dot(M, v0))
    True
    >>> v0 = (numpy.random.rand(4, 100) - 0.5) * 20.0
    >>> v0[3] = 1.0
    >>> v1 = numpy.dot(R, v0)
    >>> M = superimposition_matrix(v0, v1)
    >>> numpy.allclose(v1, numpy.dot(M, v0))
    True
    >>> S = scale_matrix(random.random())
    >>> T = translation_matrix(numpy.random.random(3)-0.5)
    >>> M = concatenate_matrices(T, R, S)
    >>> v1 = numpy.dot(M, v0)
    >>> v0[:3] += numpy.random.normal(0.0, 1e-9, 300).reshape(3, -1)
    >>> M = superimposition_matrix(v0, v1, scaling=True)
    >>> numpy.allclose(v1, numpy.dot(M, v0))
    True
    >>> M = superimposition_matrix(v0, v1, scaling=True, usesvd=False)
    >>> numpy.allclose(v1, numpy.dot(M, v0))
    True
    >>> v = numpy.empty((4, 100, 3), dtype=numpy.float64)
    >>> v[:, :, 0] = v0
    >>> M = superimposition_matrix(v0, v1, scaling=True, usesvd=False)
    >>> numpy.allclose(v1, numpy.dot(M, v[:, :, 0]))
    True

    """
    v0 = numpy.array(v0, dtype=numpy.float64, copy=False)[:3]
    v1 = numpy.array(v1, dtype=numpy.float64, copy=False)[:3]

    if v0.shape != v1.shape or v0.shape[1] < 3:
        raise ValueError("vector sets are of wrong shape or type")

    # move centroids to origin
    t0 = numpy.mean(v0, axis=1)
    t1 = numpy.mean(v1, axis=1)
    v0 = v0 - t0.reshape(3, 1)
    v1 = v1 - t1.reshape(3, 1)

    if usesvd:
        # Singular Value Decomposition of covariance matrix
        u, s, vh = numpy.linalg.svd(numpy.dot(v1, v0.T))
        # rotation matrix from SVD orthonormal bases
        R = numpy.dot(u, vh)
        if numpy.linalg.det(R) < 0.0:
            # R does not constitute right handed system
            R -= numpy.outer(u[:, 2], vh[2, :]*2.0)
            s[-1] *= -1.0
        # homogeneous transformation matrix
        M = numpy.identity(4)
        M[:3, :3] = R
    else:
        # compute symmetric matrix N
        xx, yy, zz = numpy.sum(v0 * v1, axis=1)
        xy, yz, zx = numpy.sum(v0 * numpy.roll(v1, -1, axis=0), axis=1)
        xz, yx, zy = numpy.sum(v0 * numpy.roll(v1, -2, axis=0), axis=1)
        N = ((xx+yy+zz, 0.0, 0.0, 0.0),
             (yz-zy, xx-yy-zz, 0.0, 0.0),
             (zx-xz, xy+yx, -xx+yy-zz, 0.0),
             (xy-yx, zx+xz, yz+zy, -xx-yy+zz))
        # quaternion: eigenvector corresponding to most positive eigenvalue
        l, V = numpy.linalg.eigh(N)
        q = V[:, numpy.argmax(l)]
        q /= vector_norm(q)  # unit quaternion
        # homogeneous transformation matrix
        M = quaternion_matrix(q)

    # scale: ratio of rms deviations from centroid
    if scaling:
        v0 *= v0
        v1 *= v1
        M[:3, :3] *= math.sqrt(numpy.sum(v1) / numpy.sum(v0))

    # translation
    M[:3, 3] = t1
    T = numpy.identity(4)
    T[:3, 3] = -t0
    M = numpy.dot(M, T)
    return M


def euler_matrix(ai, aj, ak, axes='sxyz'):
    """Return homogeneous rotation matrix from Euler angles and axis sequence.

    ai, aj, ak : Euler's roll, pitch and yaw angles
    axes : One of 24 axis sequences as string or encoded tuple

    >>> R = euler_matrix(1, 2, 3, 'syxz')
    >>> numpy.allclose(numpy.sum(R[0]), -1.34786452)
    True
    >>> R = euler_matrix(1, 2, 3, (0, 1, 0, 1))
    >>> numpy.allclose(numpy.sum(R[0]), -0.383436184)
    True
    >>> ai, aj, ak = (4.0*math.pi) * (numpy.random.random(3) - 0.5)
    >>> for axes in _AXES2TUPLE.keys():
    ...    R = euler_matrix(ai, aj, ak, axes)
    >>> for axes in _TUPLE2AXES.keys():
    ...    R = euler_matrix(ai, aj, ak, axes)

    """
    try:
        firstaxis, parity, repetition, frame = _AXES2TUPLE[axes]
    except (AttributeError, KeyError):
        _ = _TUPLE2AXES[axes]
        firstaxis, parity, repetition, frame = axes

    i = firstaxis
    j = _NEXT_AXIS[i+parity]
    k = _NEXT_AXIS[i-parity+1]

    if frame:
        ai, ak = ak, ai
    if parity:
        ai, aj, ak = -ai, -aj, -ak

    si, sj, sk = math.sin(ai), math.sin(aj), math.sin(ak)
    ci, cj, ck = math.cos(ai), math.cos(aj), math.cos(ak)
    cc, cs = ci*ck, ci*sk
    sc, ss = si*ck, si*sk

    M = numpy.identity(4)
    if repetition:
        M[i, i] = cj
        M[i, j] = sj*si
        M[i, k] = sj*ci
        M[j, i] = sj*sk
        M[j, j] = -cj*ss+cc
        M[j, k] = -cj*cs-sc
        M[k, i] = -sj*ck
        M[k, j] = cj*sc+cs
        M[k, k] = cj*cc-ss
    else:
        M[i, i] = cj*ck
        M[i, j] = sj*sc-cs
        M[i, k] = sj*cc+ss
        M[j, i] = cj*sk
        M[j, j] = sj*ss+cc
        M[j, k] = sj*cs-sc
        M[k, i] = -sj
        M[k, j] = cj*si
        M[k, k] = cj*ci
    return M


def euler_from_matrix(matrix, axes='sxyz'):
    """Return Euler angles from rotation matrix for specified axis sequence.

    axes : One of 24 axis sequences as string or encoded tuple

    Note that many Euler angle triplets can describe one matrix.

    >>> R0 = euler_matrix(1, 2, 3, 'syxz')
    >>> al, be, ga = euler_from_matrix(R0, 'syxz')
    >>> R1 = euler_matrix(al, be, ga, 'syxz')
    >>> numpy.allclose(R0, R1)
    True
    >>> angles = (4.0*math.pi) * (numpy.random.random(3) - 0.5)
    >>> for axes in _AXES2TUPLE.keys():
    ...    R0 = euler_matrix(axes=axes, *angles)
    ...    R1 = euler_matrix(axes=axes, *euler_from_matrix(R0, axes))
    ...    if not numpy.allclose(R0, R1): print(axes, "failed")

    """
    try:
        firstaxis, parity, repetition, frame = _AXES2TUPLE[axes.lower()]
    except (AttributeError, KeyError):
        _ = _TUPLE2AXES[axes]
        firstaxis, parity, repetition, frame = axes

    i = firstaxis
    j = _NEXT_AXIS[i+parity]
    k = _NEXT_AXIS[i-parity+1]

    M = numpy.array(matrix, dtype=numpy.float64, copy=False)[:3, :3]
    if repetition:
        sy = math.sqrt(M[i, j]*M[i, j] + M[i, k]*M[i, k])
        if sy > _EPS:
            ax = math.atan2( M[i, j],  M[i, k])
            ay = math.atan2( sy,       M[i, i])
            az = math.atan2( M[j, i], -M[k, i])
        else:
            ax = math.atan2(-M[j, k],  M[j, j])
            ay = math.atan2( sy,       M[i, i])
            az = 0.0
    else:
        cy = math.sqrt(M[i, i]*M[i, i] + M[j, i]*M[j, i])
        if cy > _EPS:
            ax = math.atan2( M[k, j],  M[k, k])
            ay = math.atan2(-M[k, i],  cy)
            az = math.atan2( M[j, i],  M[i, i])
        else:
            ax = math.atan2(-M[j, k],  M[j, j])
            ay = math.atan2(-M[k, i],  cy)
            az = 0.0

    if parity:
        ax, ay, az = -ax, -ay, -az
    if frame:
        ax, az = az, ax
    return ax, ay, az


def euler_from_quaternion(quaternion, axes='sxyz'):
    """Return Euler angles from quaternion for specified axis sequence.

    >>> angles = euler_from_quaternion([0.99810947, 0.06146124, 0, 0])
    >>> numpy.allclose(angles, [0.123, 0, 0])
    True

    """
    return euler_from_matrix(quaternion_matrix(quaternion), axes)


def quaternion_from_euler(ai, aj, ak, axes='sxyz'):
    """Return quaternion from Euler angles and axis sequence.

    ai, aj, ak : Euler's roll, pitch and yaw angles
    axes : One of 24 axis sequences as string or encoded tuple

    >>> q = quaternion_from_euler(1, 2, 3, 'ryxz')
    >>> numpy.allclose(q, [0.435953, 0.310622, -0.718287, 0.444435])
    True

    """
    try:
        firstaxis, parity, repetition, frame = _AXES2TUPLE[axes.lower()]
    except (AttributeError, KeyError):
        _ = _TUPLE2AXES[axes]
        firstaxis, parity, repetition, frame = axes

    i = firstaxis + 1
    j = _NEXT_AXIS[i+parity-1] + 1
    k = _NEXT_AXIS[i-parity] + 1

    if frame:
        ai, ak = ak, ai
    if parity:
        aj = -aj

    ai /= 2.0
    aj /= 2.0
    ak /= 2.0
    ci = math.cos(ai)
    si = math.sin(ai)
    cj = math.cos(aj)
    sj = math.sin(aj)
    ck = math.cos(ak)
    sk = math.sin(ak)
    cc = ci*ck
    cs = ci*sk
    sc = si*ck
    ss = si*sk

    quaternion = numpy.empty((4, ), dtype=numpy.float64)
    if repetition:
        quaternion[0] = cj*(cc - ss)
        quaternion[i] = cj*(cs + sc)
        quaternion[j] = sj*(cc + ss)
        quaternion[k] = sj*(cs - sc)
    else:
        quaternion[0] = cj*cc + sj*ss
        quaternion[i] = cj*sc - sj*cs
        quaternion[j] = cj*ss + sj*cc
        quaternion[k] = cj*cs - sj*sc
    if parity:
        quaternion[j] *= -1

    return quaternion


def quaternion_about_axis(angle, axis):
    """Return quaternion for rotation about axis.

    >>> q = quaternion_about_axis(0.123, (1, 0, 0))
    >>> numpy.allclose(q, [0.99810947, 0.06146124, 0, 0])
    True

    """
    quaternion = numpy.zeros((4, ), dtype=numpy.float64)
    quaternion[1] = axis[0]
    quaternion[2] = axis[1]
    quaternion[3] = axis[2]
    qlen = vector_norm(quaternion)
    if qlen > _EPS:
        quaternion *= math.sin(angle/2.0) / qlen
    quaternion[0] = math.cos(angle/2.0)
    return quaternion


def quaternion_matrix(quaternion):
    """Return homogeneous rotation matrix from quaternion.

    >>> M = quaternion_matrix([0.99810947, 0.06146124, 0, 0])
    >>> numpy.allclose(M, rotation_matrix(0.123, (1, 0, 0)))
    True
    >>> M = quaternion_matrix([1, 0, 0, 0])
    >>> numpy.allclose(M, identity_matrix())
    True
    >>> M = quaternion_matrix([0, 1, 0, 0])
    >>> numpy.allclose(M, numpy.diag([1, -1, -1, 1]))
    True

    """
    q = numpy.array(quaternion[:4], dtype=numpy.float64, copy=True)
    nq = numpy.dot(q, q)
    if nq < _EPS:
        return numpy.identity(4)
    q *= math.sqrt(2.0 / nq)
    q = numpy.outer(q, q)
    return numpy.array((
        (1.0-q[2, 2]-q[3, 3],     q[1, 2]-q[3, 0],     q[1, 3]+q[2, 0], 0.0),
        (    q[1, 2]+q[3, 0], 1.0-q[1, 1]-q[3, 3],     q[2, 3]-q[1, 0], 0.0),
        (    q[1, 3]-q[2, 0],     q[2, 3]+q[1, 0], 1.0-q[1, 1]-q[2, 2], 0.0),
        (                0.0,                 0.0,                 0.0, 1.0)
        ), dtype=numpy.float64)


def quaternion_from_matrix(matrix, isprecise=False):
    """Return quaternion from rotation matrix.

    If isprecise=True, the input matrix is assumed to be a precise rotation
    matrix and a faster algorithm is used.

    >>> q = quaternion_from_matrix(identity_matrix(), True)
    >>> numpy.allclose(q, [1., 0., 0., 0.])
    True
    >>> q = quaternion_from_matrix(numpy.diag([1., -1., -1., 1.]))
    >>> numpy.allclose(q, [0, 1, 0, 0]) or numpy.allclose(q, [0, -1, 0, 0])
    True
    >>> R = rotation_matrix(0.123, (1, 2, 3))
    >>> q = quaternion_from_matrix(R, True)
    >>> numpy.allclose(q, [0.9981095, 0.0164262, 0.0328524, 0.0492786])
    True
    >>> R = [[-0.545, 0.797, 0.260, 0], [0.733, 0.603, -0.313, 0],
    ...      [-0.407, 0.021, -0.913, 0], [0, 0, 0, 1]]
    >>> q = quaternion_from_matrix(R)
    >>> numpy.allclose(q, [0.19069, 0.43736, 0.87485, -0.083611])
    True
    >>> R = [[0.395, 0.362, 0.843, 0], [-0.626, 0.796, -0.056, 0],
    ...      [-0.677, -0.498, 0.529, 0], [0, 0, 0, 1]]
    >>> q = quaternion_from_matrix(R)
    >>> numpy.allclose(q, [0.82336615, -0.13610694, 0.46344705, -0.29792603])
    True
    >>> R = random_rotation_matrix()
    >>> q = quaternion_from_matrix(R)
    >>> is_same_transform(R, quaternion_matrix(q))
    True

    """
    M = numpy.array(matrix, dtype=numpy.float64, copy=False)[:4, :4]
    if isprecise:
        q = numpy.empty((4, ), dtype=numpy.float64)
        t = numpy.trace(M)
        if t > M[3, 3]:
            q[0] = t
            q[3] = M[1, 0] - M[0, 1]
            q[2] = M[0, 2] - M[2, 0]
            q[1] = M[2, 1] - M[1, 2]
        else:
            i, j, k = 1, 2, 3
            if M[1, 1] > M[0, 0]:
                i, j, k = 2, 3, 1
            if M[2, 2] > M[i, i]:
                i, j, k = 3, 1, 2
            t = M[i, i] - (M[j, j] + M[k, k]) + M[3, 3]
            q[i] = t
            q[j] = M[i, j] + M[j, i]
            q[k] = M[k, i] + M[i, k]
            q[3] = M[k, j] - M[j, k]
        q *= 0.5 / math.sqrt(t * M[3, 3])
    else:
        m00 = M[0, 0]
        m01 = M[0, 1]
        m02 = M[0, 2]
        m10 = M[1, 0]
        m11 = M[1, 1]
        m12 = M[1, 2]
        m20 = M[2, 0]
        m21 = M[2, 1]
        m22 = M[2, 2]
        # symmetric matrix K
        K = numpy.array(((m00-m11-m22, 0.0, 0.0, 0.0),
                         (m01+m10, m11-m00-m22, 0.0, 0.0),
                         (m02+m20, m12+m21, m22-m00-m11, 0.0),
                         (m21-m12, m02-m20, m10-m01, m00+m11+m22)))
        K /= 3.0
        # quaternion is eigenvector of K that corresponds to largest eigenvalue
        l, V = numpy.linalg.eigh(K)
        q = V[[3, 0, 1, 2], numpy.argmax(l)]

    if q[0] < 0.0:
        q *= -1.0
    return q


def quaternion_multiply(quaternion1, quaternion0):
    """Return multiplication of two quaternions.

    >>> q = quaternion_multiply([4, 1, -2, 3], [8, -5, 6, 7])
    >>> numpy.allclose(q, [28, -44, -14, 48])
    True

    """
    w0, x0, y0, z0 = quaternion0
    w1, x1, y1, z1 = quaternion1
    return numpy.array((
        -x1*x0 - y1*y0 - z1*z0 + w1*w0,
         x1*w0 + y1*z0 - z1*y0 + w1*x0,
        -x1*z0 + y1*w0 + z1*x0 + w1*y0,
         x1*y0 - y1*x0 + z1*w0 + w1*z0), dtype=numpy.float64)


def quaternion_conjugate(quaternion):
    """Return conjugate of quaternion.

    >>> q0 = random_quaternion()
    >>> q1 = quaternion_conjugate(q0)
    >>> q1[0] == q0[0] and all(q1[1:] == -q0[1:])
    True

    """
    return numpy.array((quaternion[0], -quaternion[1],
                       -quaternion[2], -quaternion[3]), dtype=numpy.float64)


def quaternion_inverse(quaternion):
    """Return inverse of quaternion.

    >>> q0 = random_quaternion()
    >>> q1 = quaternion_inverse(q0)
    >>> numpy.allclose(quaternion_multiply(q0, q1), [1, 0, 0, 0])
    True

    """
    return quaternion_conjugate(quaternion) / numpy.dot(quaternion, quaternion)


def quaternion_real(quaternion):
    """Return real part of quaternion.

    >>> quaternion_real([3.0, 0.0, 1.0, 2.0])
    3.0

    """
    return quaternion[0]


def quaternion_imag(quaternion):
    """Return imaginary part of quaternion.

    >>> quaternion_imag([3.0, 0.0, 1.0, 2.0])
    [0.0, 1.0, 2.0]

    """
    return quaternion[1:4]


def quaternion_slerp(quat0, quat1, fraction, spin=0, shortestpath=True):
    """Return spherical linear interpolation between two quaternions.

    >>> q0 = random_quaternion()
    >>> q1 = random_quaternion()
    >>> q = quaternion_slerp(q0, q1, 0.0)
    >>> numpy.allclose(q, q0)
    True
    >>> q = quaternion_slerp(q0, q1, 1.0, 1)
    >>> numpy.allclose(q, q1)
    True
    >>> q = quaternion_slerp(q0, q1, 0.5)
    >>> angle = math.acos(numpy.dot(q0, q))
    >>> numpy.allclose(2.0, math.acos(numpy.dot(q0, q1)) / angle) or \
        numpy.allclose(2.0, math.acos(-numpy.dot(q0, q1)) / angle)
    True

    """
    q0 = unit_vector(quat0[:4])
    q1 = unit_vector(quat1[:4])
    if fraction == 0.0:
        return q0
    elif fraction == 1.0:
        return q1
    d = numpy.dot(q0, q1)
    if abs(abs(d) - 1.0) < _EPS:
        return q0
    if shortestpath and d < 0.0:
        # invert rotation
        d = -d
        q1 *= -1.0
    angle = math.acos(d) + spin * math.pi
    if abs(angle) < _EPS:
        return q0
    isin = 1.0 / math.sin(angle)
    q0 *= math.sin((1.0 - fraction) * angle) * isin
    q1 *= math.sin(fraction * angle) * isin
    q0 += q1
    return q0


def random_quaternion(rand=None):
    """Return uniform random unit quaternion.

    rand: array like or None
        Three independent random variables that are uniformly distributed
        between 0 and 1.

    >>> q = random_quaternion()
    >>> numpy.allclose(1.0, vector_norm(q))
    True
    >>> q = random_quaternion(numpy.random.random(3))
    >>> len(q.shape), q.shape[0]==4
    (1, True)

    """
    if rand is None:
        rand = numpy.random.rand(3)
    else:
        assert len(rand) == 3
    r1 = numpy.sqrt(1.0 - rand[0])
    r2 = numpy.sqrt(rand[0])
    pi2 = math.pi * 2.0
    t1 = pi2 * rand[1]
    t2 = pi2 * rand[2]
    return numpy.array((numpy.cos(t2)*r2,
                        numpy.sin(t1)*r1,
                        numpy.cos(t1)*r1,
                        numpy.sin(t2)*r2), dtype=numpy.float64)


def random_rotation_matrix(rand=None):
    """Return uniform random rotation matrix.

    rnd: array like
        Three independent random variables that are uniformly distributed
        between 0 and 1 for each returned quaternion.

    >>> R = random_rotation_matrix()
    >>> numpy.allclose(numpy.dot(R.T, R), numpy.identity(4))
    True

    """
    return quaternion_matrix(random_quaternion(rand))


class Arcball(object):
    """Virtual Trackball Control.

    >>> ball = Arcball()
    >>> ball = Arcball(initial=numpy.identity(4))
    >>> ball.place([320, 320], 320)
    >>> ball.down([500, 250])
    >>> ball.drag([475, 275])
    >>> R = ball.matrix()
    >>> numpy.allclose(numpy.sum(R), 3.90583455)
    True
    >>> ball = Arcball(initial=[1, 0, 0, 0])
    >>> ball.place([320, 320], 320)
    >>> ball.setaxes([1,1,0], [-1, 1, 0])
    >>> ball.setconstrain(True)
    >>> ball.down([400, 200])
    >>> ball.drag([200, 400])
    >>> R = ball.matrix()
    >>> numpy.allclose(numpy.sum(R), 0.2055924)
    True
    >>> ball.next()

    """

    def __init__(self, initial=None):
        """Initialize virtual trackball control.

        initial : quaternion or rotation matrix

        """
        self._axis = None
        self._axes = None
        self._radius = 1.0
        self._center = [0.0, 0.0]
        self._vdown = numpy.array([0, 0, 1], dtype=numpy.float64)
        self._constrain = False

        if initial is None:
            self._qdown = numpy.array([1, 0, 0, 0], dtype=numpy.float64)
        else:
            initial = numpy.array(initial, dtype=numpy.float64)
            if initial.shape == (4, 4):
                self._qdown = quaternion_from_matrix(initial)
            elif initial.shape == (4, ):
                initial /= vector_norm(initial)
                self._qdown = initial
            else:
                raise ValueError("initial not a quaternion or matrix")

        self._qnow = self._qpre = self._qdown

    def place(self, center, radius):
        """Place Arcball, e.g. when window size changes.

        center : sequence[2]
            Window coordinates of trackball center.
        radius : float
            Radius of trackball in window coordinates.

        """
        self._radius = float(radius)
        self._center[0] = center[0]
        self._center[1] = center[1]

    def setaxes(self, *axes):
        """Set axes to constrain rotations."""
        if axes is None:
            self._axes = None
        else:
            self._axes = [unit_vector(axis) for axis in axes]

    def setconstrain(self, constrain):
        """Set state of constrain to axis mode."""
        self._constrain = constrain == True

    def getconstrain(self):
        """Return state of constrain to axis mode."""
        return self._constrain

    def down(self, point):
        """Set initial cursor window coordinates and pick constrain-axis."""
        self._vdown = arcball_map_to_sphere(point, self._center, self._radius)
        self._qdown = self._qpre = self._qnow

        if self._constrain and self._axes is not None:
            self._axis = arcball_nearest_axis(self._vdown, self._axes)
            self._vdown = arcball_constrain_to_axis(self._vdown, self._axis)
        else:
            self._axis = None

    def drag(self, point):
        """Update current cursor window coordinates."""
        vnow = arcball_map_to_sphere(point, self._center, self._radius)

        if self._axis is not None:
            vnow = arcball_constrain_to_axis(vnow, self._axis)

        self._qpre = self._qnow

        t = numpy.cross(self._vdown, vnow)
        if numpy.dot(t, t) < _EPS:
            self._qnow = self._qdown
        else:
            q = [numpy.dot(self._vdown, vnow), t[0], t[1], t[2]]
            self._qnow = quaternion_multiply(q, self._qdown)

    def next(self, acceleration=0.0):
        """Continue rotation in direction of last drag."""
        q = quaternion_slerp(self._qpre, self._qnow, 2.0+acceleration, False)
        self._qpre, self._qnow = self._qnow, q

    def matrix(self):
        """Return homogeneous rotation matrix."""
        return quaternion_matrix(self._qnow)


def arcball_map_to_sphere(point, center, radius):
    """Return unit sphere coordinates from window coordinates."""
    v = numpy.array(((point[0] - center[0]) / radius,
                     (center[1] - point[1]) / radius,
                     0.0), dtype=numpy.float64)
    n = v[0]*v[0] + v[1]*v[1]
    if n > 1.0:
        v /= math.sqrt(n)  # position outside of sphere
    else:
        v[2] = math.sqrt(1.0 - n)
    return v


def arcball_constrain_to_axis(point, axis):
    """Return sphere point perpendicular to axis."""
    v = numpy.array(point, dtype=numpy.float64, copy=True)
    a = numpy.array(axis, dtype=numpy.float64, copy=True)
    v -= a * numpy.dot(a, v)  # on plane
    n = vector_norm(v)
    if n > _EPS:
        if v[2] < 0.0:
            v *= -1.0
        v /= n
        return v
    if a[2] == 1.0:
        return numpy.array([1, 0, 0], dtype=numpy.float64)
    return unit_vector([-a[1], a[0], 0])


def arcball_nearest_axis(point, axes):
    """Return axis, which arc is nearest to point."""
    point = numpy.array(point, dtype=numpy.float64, copy=False)
    nearest = None
    mx = -1.0
    for axis in axes:
        t = numpy.dot(arcball_constrain_to_axis(point, axis), point)
        if t > mx:
            nearest = axis
            mx = t
    return nearest


# epsilon for testing whether a number is close to zero
_EPS = numpy.finfo(float).eps * 4.0

# axis sequences for Euler angles
_NEXT_AXIS = [1, 2, 0, 1]

# map axes strings to/from tuples of inner axis, parity, repetition, frame
_AXES2TUPLE = {
    'sxyz': (0, 0, 0, 0), 'sxyx': (0, 0, 1, 0), 'sxzy': (0, 1, 0, 0),
    'sxzx': (0, 1, 1, 0), 'syzx': (1, 0, 0, 0), 'syzy': (1, 0, 1, 0),
    'syxz': (1, 1, 0, 0), 'syxy': (1, 1, 1, 0), 'szxy': (2, 0, 0, 0),
    'szxz': (2, 0, 1, 0), 'szyx': (2, 1, 0, 0), 'szyz': (2, 1, 1, 0),
    'rzyx': (0, 0, 0, 1), 'rxyx': (0, 0, 1, 1), 'ryzx': (0, 1, 0, 1),
    'rxzx': (0, 1, 1, 1), 'rxzy': (1, 0, 0, 1), 'ryzy': (1, 0, 1, 1),
    'rzxy': (1, 1, 0, 1), 'ryxy': (1, 1, 1, 1), 'ryxz': (2, 0, 0, 1),
    'rzxz': (2, 0, 1, 1), 'rxyz': (2, 1, 0, 1), 'rzyz': (2, 1, 1, 1)}

_TUPLE2AXES = dict((v, k) for k, v in _AXES2TUPLE.items())


def vector_norm(data, axis=None, out=None):
    """Return length, i.e. eucledian norm, of ndarray along axis.

    >>> v = numpy.random.random(3)
    >>> n = vector_norm(v)
    >>> numpy.allclose(n, numpy.linalg.norm(v))
    True
    >>> v = numpy.random.rand(6, 5, 3)
    >>> n = vector_norm(v, axis=-1)
    >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=2)))
    True
    >>> n = vector_norm(v, axis=1)
    >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1)))
    True
    >>> v = numpy.random.rand(5, 4, 3)
    >>> n = numpy.empty((5, 3), dtype=numpy.float64)
    >>> vector_norm(v, axis=1, out=n)
    >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1)))
    True
    >>> vector_norm([])
    0.0
    >>> vector_norm([1.0])
    1.0

    """
    data = numpy.array(data, dtype=numpy.float64, copy=True)
    if out is None:
        if data.ndim == 1:
            return math.sqrt(numpy.dot(data, data))
        data *= data
        out = numpy.atleast_1d(numpy.sum(data, axis=axis))
        numpy.sqrt(out, out)
        return out
    else:
        data *= data
        numpy.sum(data, axis=axis, out=out)
        numpy.sqrt(out, out)


def unit_vector(data, axis=None, out=None):
    """Return ndarray normalized by length, i.e. eucledian norm, along axis.

    >>> v0 = numpy.random.random(3)
    >>> v1 = unit_vector(v0)
    >>> numpy.allclose(v1, v0 / numpy.linalg.norm(v0))
    True
    >>> v0 = numpy.random.rand(5, 4, 3)
    >>> v1 = unit_vector(v0, axis=-1)
    >>> v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=2)), 2)
    >>> numpy.allclose(v1, v2)
    True
    >>> v1 = unit_vector(v0, axis=1)
    >>> v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=1)), 1)
    >>> numpy.allclose(v1, v2)
    True
    >>> v1 = numpy.empty((5, 4, 3), dtype=numpy.float64)
    >>> unit_vector(v0, axis=1, out=v1)
    >>> numpy.allclose(v1, v2)
    True
    >>> list(unit_vector([]))
    []
    >>> list(unit_vector([1.0]))
    [1.0]

    """
    if out is None:
        data = numpy.array(data, dtype=numpy.float64, copy=True)
        if data.ndim == 1:
            data /= math.sqrt(numpy.dot(data, data))
            return data
    else:
        if out is not data:
            out[:] = numpy.array(data, copy=False)
        data = out
    length = numpy.atleast_1d(numpy.sum(data*data, axis))
    numpy.sqrt(length, length)
    if axis is not None:
        length = numpy.expand_dims(length, axis)
    data /= length
    if out is None:
        return data


def random_vector(size):
    """Return array of random doubles in the half-open interval [0.0, 1.0).

    >>> v = random_vector(10000)
    >>> numpy.all(v >= 0.0) and numpy.all(v < 1.0)
    True
    >>> v0 = random_vector(10)
    >>> v1 = random_vector(10)
    >>> numpy.any(v0 == v1)
    False

    """
    return numpy.random.random(size)


def inverse_matrix(matrix):
    """Return inverse of square transformation matrix.

    >>> M0 = random_rotation_matrix()
    >>> M1 = inverse_matrix(M0.T)
    >>> numpy.allclose(M1, numpy.linalg.inv(M0.T))
    True
    >>> for size in range(1, 7):
    ...     M0 = numpy.random.rand(size, size)
    ...     M1 = inverse_matrix(M0)
    ...     if not numpy.allclose(M1, numpy.linalg.inv(M0)): print(size)

    """
    return numpy.linalg.inv(matrix)


def concatenate_matrices(*matrices):
    """Return concatenation of series of transformation matrices.

    >>> M = numpy.random.rand(16).reshape((4, 4)) - 0.5
    >>> numpy.allclose(M, concatenate_matrices(M))
    True
    >>> numpy.allclose(numpy.dot(M, M.T), concatenate_matrices(M, M.T))
    True

    """
    M = numpy.identity(4)
    for i in matrices:
        M = numpy.dot(M, i)
    return M


def is_same_transform(matrix0, matrix1):
    """Return True if two matrices perform same transformation.

    >>> is_same_transform(numpy.identity(4), numpy.identity(4))
    True
    >>> is_same_transform(numpy.identity(4), random_rotation_matrix())
    False

    """
    matrix0 = numpy.array(matrix0, dtype=numpy.float64, copy=True)
    matrix0 /= matrix0[3, 3]
    matrix1 = numpy.array(matrix1, dtype=numpy.float64, copy=True)
    matrix1 /= matrix1[3, 3]
    return numpy.allclose(matrix0, matrix1)


def _import_module(module_name, warn=True, prefix='_py_', ignore='_'):
    """Try import all public attributes from module into global namespace.

    Existing attributes with name clashes are renamed with prefix.
    Attributes starting with underscore are ignored by default.

    Return True on successful import.

    """
    sys.path.append(os.path.dirname(__file__))
    sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'c_ext'))
    try:
        module = __import__(module_name)
    except ImportError:
        sys.path.pop()
        if warn:
            warnings.warn("failed to import module " + module_name)
    else:
        sys.path.pop()
        for attr in dir(module):
            if ignore and attr.startswith(ignore):
                continue
            if prefix:
                if attr in globals():
                    globals()[prefix + attr] = globals()[attr]
                elif warn:
                    warnings.warn("no Python implementation of " + attr)
            globals()[attr] = getattr(module, attr)
        return True


_import_module('_transformations')
matrix_multiply = numpy.dot

# Documentation in HTML format can be generated with Epydoc
__docformat__ = "restructuredtext en"

if __name__ == "__main__":
    import doctest
    import random
    numpy.set_printoptions(suppress=True, precision=5)
    doctest.testmod()

########NEW FILE########
__FILENAME__ = loader
'''
Loader: asynchronous loader, easily extensible.

This is the Asynchronous Loader. You can use it to load an image
and use it, even if data are not yet available. You must specify a default
loading image for using a such loader ::

    from pymt import *
    image = Loader.image('mysprite.png')

You can also load image from url ::

    image = Loader.image('http://mysite.com/test.png')

If you want to change the default loading image, you can do ::

    Loader.loading_image = Image('another_loading.png')

'''

__all__ = ('Loader', 'LoaderBase', 'ProxyImage')

from pymt import pymt_data_dir
from pymt.logger import pymt_logger
from pymt.clock import getClock
from pymt.cache import Cache
from pymt.utils import SafeList
from pymt.core.image import ImageLoader, Image
from pymt.event import EventDispatcher
from abc import ABCMeta, abstractmethod

import time
import collections
import os

# Register a cache for loader
Cache.register('pymt.loader', limit=500, timeout=60)

class ProxyImage(Image, EventDispatcher):
    '''Image returned by the Loader.image() function.

    :Properties:
        `loaded`: bool, default to False
            It can be True if the image is already cached

    :Events:
        `on_load`
            Fired when the image is loaded and changed
    '''
    def __init__(self, arg, **kwargs):
        kwargs.setdefault('loaded', False)
        super(ProxyImage, self).__init__(arg, **kwargs)
        self.loaded = kwargs.get('loaded')
        self.register_event_type('on_load')

    def on_load(self):
        pass


class LoaderBase(object):
    '''Common base for Loader and specific implementation.
    By default, Loader will be the best available loader implementation.

    The _update() function is called every 1 / 25.s or each frame if we have
    less than 25 FPS.
    '''

    __metaclass__ = ABCMeta

    def __init__(self):

        self._loading_image = None
        self._error_image = None

        self._q_load  = collections.deque()
        self._q_done  = collections.deque()
        self._client  = SafeList()
        self._running = False
        self._start_wanted = False

        getClock().schedule_interval(self._update, 1 / 25.)

    def __del__(self):
        try:
            getClock().unschedule(self._update)
        except Exception:
            pass

    @property
    def loading_image(self):
        '''Image used for loading (readonly)'''
        if not self._loading_image:
            loading_png_fn = os.path.join(pymt_data_dir, 'loader.png')
            self._loading_image = ImageLoader.load(filename=loading_png_fn)
        return self._loading_image

    @property
    def error_image(self):
        '''Image used for error (readonly)'''
        if not self._error_image:
            error_png_fn = os.path.join(pymt_data_dir, 'error.png')
            self._error_image = ImageLoader.load(filename=error_png_fn)
        return self._error_image

    @abstractmethod
    def start(self):
        '''Start the loader thread/process'''
        self._running = True

    @abstractmethod
    def run(self, *largs):
        '''Main loop for the loader.'''
        pass

    @abstractmethod
    def stop(self):
        '''Stop the loader thread/process'''
        self._running = False

    def _load(self, parameters):
        '''(internal) Loading function, called by the thread.
        Will call _load_local() if the file is local,
        or _load_urllib() if the file is on Internet'''

        filename, load_callback, post_callback = parameters
        proto = filename.split(':', 1)[0]
        if load_callback is not None:
            data = load_callback(filename)
        elif proto in ('http', 'https', 'ftp'):
            data = self._load_urllib(filename)
        else:
            data = self._load_local(filename)

        if post_callback:
            data = post_callback(data)

        self._q_done.append((filename, data))

    def _load_local(self, filename):
        '''(internal) Loading a local file'''
        return ImageLoader.load(filename)

    def _load_urllib(self, filename):
        '''(internal) Loading a network file. First download it, save it to a
        temporary file, and pass it to _load_local()'''
        import urllib2, tempfile
        data = None
        try:
            suffix = '.%s'  % (filename.split('.')[-1])
            _out_osfd, _out_filename = tempfile.mkstemp(
                    prefix='pymtloader', suffix=suffix)

            # read from internet
            fd = urllib2.urlopen(filename)
            idata = fd.read()
            fd.close()

            # write to local filename
            os.write(_out_osfd, idata)
            os.close(_out_osfd)

            # load data
            data = self._load_local(_out_filename)
        except Exception:
            pymt_logger.exception('Failed to load image <%s>' % filename)
            return self.error_image
        finally:
            os.unlink(_out_filename)

        return data

    def _update(self, *largs):
        '''(internal) Check if a data is loaded, and pass to the client'''
        # want to start it ?
        if self._start_wanted:
            if not self._running:
                self.start()
            self._start_wanted = False

        while True:
            try:
                filename, data = self._q_done.pop()
            except IndexError:
                return

            # create the image
            image = data#ProxyImage(data)
            Cache.append('pymt.loader', filename, image)

            # update client
            for c_filename, client in self._client[:]:
                if filename != c_filename:
                    continue
                # got one client to update
                client.image = image
                client.loaded = True
                client.dispatch_event('on_load')
                self._client.remove((c_filename, client))

    def image(self, filename, load_callback=None, post_callback=None):
        '''Load a image using loader. A Proxy image is returned
        with a loading image ::

            img = Loader.image(filename)
            # img will be a ProxyImage.
            # You'll use it the same as an Image class.
            # Later, when the image is really loaded,
            # the loader will change the img.image property
            # to the new loaded image

        '''
        data = Cache.get('pymt.loader', filename)
        if data not in (None, False):
            # found image
            return ProxyImage(data,
                    loading_image=self.loading_image,
                    loaded=True)

        client = ProxyImage(self.loading_image,
                    loading_image=self.loading_image)
        self._client.append((filename, client))

        if data is None:
            # if data is None, this is really the first time
            self._q_load.append((filename, load_callback, post_callback))
            Cache.append('pymt.loader', filename, False)
            self._start_wanted = True
        else:
            # already queued for loading
            pass

        return client

#
# Loader implementation
#

if 'PYMT_DOC' in os.environ:

    Loader = None

else:

    #
    # Try to use pygame as our first choice for loader
    #

    try:
        import pygame

        class LoaderPygame(LoaderBase):
            def __init__(self):
                super(LoaderPygame, self).__init__()
                self.worker = None

            def start(self):
                super(LoaderPygame, self).start()
                self.worker = pygame.threads.WorkerQueue()
                self.worker.do(self.run)

            def stop(self):
                super(LoaderPygame, self).stop()
                self.worker.stop()

            def run(self, *largs):
                while self._running:
                    try:
                        parameters = self._q_load.pop()
                    except:
                        time.sleep(0.1)
                        continue
                    self.worker.do(self._load, parameters)

        Loader = LoaderPygame()
        pymt_logger.info('Loader: using <pygame> as thread loader')

    except:

        #
        # Default to the clock loader
        #

        class LoaderClock(LoaderBase):
            '''Loader implementation using a simple Clock()'''
            def start(self):
                super(LoaderClock, self).start()
                getClock().schedule_interval(self.run, 0.0001)

            def stop(self):
                super(LoaderClock, self).stop()
                getClock().unschedule(self.run)

            def run(self, *largs):
                try:
                    parameters = self._q_load.pop()
                except IndexError:
                    return
                self._load(parameters)

        Loader = LoaderClock()
        pymt_logger.info('Loader: using <clock> as thread loader')


########NEW FILE########
__FILENAME__ = logger
'''
Logger: the PyMT logger

Fifferents level are available :
    - debug
    - info
    - warning
    - error
    - critical

Examples of usage ::

    from pymt.logger import pymt_logger
    pymt_logger.notice('This is a notice')
    pymt_logger.debug('This is a notice')

    try:
        raise Exception('bleh')
    except Exception, e
        pymt_logger.exception(e)


By default, logger log also in a file, with the according configuration token ::

    [pymt]
    # will be stored in a "logs" directory in pymt home
    log_dir = logs
    # name of the log, according to time.strftime format
    # the %_ will be incremented from 0 to 10000 if the first
    # part of name already exist
    log_name = pymt_%y-%m-%d_%_.txt
    # activate or deactivate logs
    log_enable = 1

'''

import logging
import os
import sys
import random

__all__ = ('pymt_logger', 'LOG_LEVELS', 'COLORS', 'pymt_logger_history',
           'pymt_logfile_activated')

pymt_logfile_activated = False

BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8)

#These are the sequences need to get colored ouput
RESET_SEQ = "\033[0m"
COLOR_SEQ = "\033[1;%dm"
BOLD_SEQ = "\033[1m"

def formatter_message(message, use_color=True):
    if use_color:
        message = message.replace("$RESET", RESET_SEQ).replace("$BOLD", BOLD_SEQ)
    else:
        message = message.replace("$RESET", "").replace("$BOLD", "")
    return message

COLORS = {
    'WARNING': YELLOW,
    'INFO': GREEN,
    'DEBUG': CYAN,
    'CRITICAL': RED,
    'ERROR': RED
}

LOG_LEVELS = {
    'debug': logging.DEBUG,
    'info': logging.INFO,
    'warning': logging.WARNING,
    'error': logging.ERROR,
    'critical': logging.CRITICAL
}

class FileHandler(logging.Handler):
    history = []
    filename = 'log.txt'
    fd = None

    def purge_logs(self, directory):
        '''Purge log is called randomly, to prevent log directory to be filled
        by lot and lot of log files.
        You've a chance of 1 on 20 to fire a purge log.
        '''
        if random.randint(0, 20) != 0:
            return

        # Use config ?
        maxfiles = 100

        print 'Purge log fired. Analysing...'
        join = os.path.join
        unlink = os.unlink

        # search all log files
        l = map(lambda x: join(directory, x), os.listdir(directory))
        if len(l) > maxfiles:
            # get creation time on every files
            l = zip(l, map(os.path.getctime, l))

            # sort by date
            l.sort(cmp=lambda x, y: cmp(x[1], y[1]))

            # get the oldest (keep last maxfiles)
            l = l[:-maxfiles]
            print 'Purge %d log files' % len(l)

            # now, unlink every files in the list
            for filename in l:
                unlink(filename[0])

        print 'Purge finished !'


    def _configure(self):
        import pymt, time
        log_dir = pymt.pymt_config.get('pymt', 'log_dir')
        log_name = pymt.pymt_config.get('pymt', 'log_name')

        _dir = pymt.pymt_home_dir
        if len(log_dir) and log_dir[0] == '/':
            _dir = log_dir
        else:
            _dir = os.path.join(_dir, log_dir)
            if not os.path.exists(_dir):
                os.mkdir(_dir)

        self.purge_logs(_dir)

        pattern = log_name.replace('%_', '@@NUMBER@@')
        pattern = os.path.join(_dir, time.strftime(pattern))
        n = 0
        while True:
            filename = pattern.replace('@@NUMBER@@', str(n))
            if not os.path.exists(filename):
                break
            n += 1
            if n > 10000: # prevent maybe flooding ?
                raise Exception('Too many logfile, remove them')

        FileHandler.filename = filename
        FileHandler.fd = open(filename, 'w')

        pymt.pymt_logger.info('Logger: Record log in %s' % filename)

    def _write_message(self, record):
        if FileHandler.fd in (None, False):
            return

        FileHandler.fd.write('[%-18s] %s\n' % (record.levelname, record.msg))
        FileHandler.fd.flush()

    def emit(self, message):
        if not pymt_logfile_activated:
            FileHandler.history += [message]
            return

        if FileHandler.fd is None:
            try:
                self._configure()
            except Exception:
                # deactivate filehandler...
                FileHandler.fd = False
                pymt_logger.exception('Error while activating FileHandler logger')
                return
            for _message in FileHandler.history:
                self._write_message(_message)

        self._write_message(message)


class HistoryHandler(logging.Handler):
    history = []
    def emit(self, message):
        HistoryHandler.history = [message] + HistoryHandler.history[:100]

class ColoredFormatter(logging.Formatter):
    def __init__(self, msg, use_color=True):
        logging.Formatter.__init__(self, msg)
        self.use_color = use_color

    def format(self, record):
        # XXX Hack to not show the fucking traceback for Numeric handler
        # Lot of people are complaining with that. Now we did.
        if 'Unable to load registered array format handler' in record.msg:
            if record.args and record.args[0] == 'numeric':
                return
        try:
            msg = record.msg.split(':', 1)
            if len(msg) == 2:
                record.msg = '[%-8s]%s' % (msg[0], msg[1])
        except:
            pass
        levelname = record.levelname
        if self.use_color and levelname in COLORS:
            levelname_color = COLOR_SEQ % (30 + COLORS[levelname]) + levelname + RESET_SEQ
            record.levelname = levelname_color
        return logging.Formatter.format(self, record)

class ColoredLogger(logging.Logger):
    use_color = True
    if os.name == 'nt':
        use_color = False

    FORMAT = '[%(levelname)-18s] %(message)s'
    COLOR_FORMAT = formatter_message(FORMAT, use_color)

    def __init__(self, name):
        logging.Logger.__init__(self, name, logging.DEBUG)
        color_formatter = ColoredFormatter(self.COLOR_FORMAT,
                                           use_color=self.use_color)
        console = logging.StreamHandler()
        console.setFormatter(color_formatter)

        # Use the custom handler instead of streaming one.
        if hasattr(sys, '_pymt_logging_handler'):
            self.addHandler(getattr(sys, '_pymt_logging_handler'))
        else:
            self.addHandler(console)
        self.addHandler(HistoryHandler())
        self.addHandler(FileHandler())
        return

logging.setLoggerClass(ColoredLogger)

#: PyMT default logger instance
pymt_logger = logging.getLogger('PyMT')

#: PyMT history handler
pymt_logger_history = HistoryHandler


########NEW FILE########
__FILENAME__ = closeapp
'''
CloseApp: Close an application with one finger
'''

from pymt import MTWidget, getFrameDt, getCurrentTouches, Vector, set_color
from pymt import stopTouchApp, gx_matrix, drawSemiCircle, getClock

class CloseApp(MTWidget):
    def __init__(self, **kwargs):
        super(CloseApp, self).__init__(**kwargs)
        self.dt = 0
        self.closetouches = {}

    def do_close(self):
        stopTouchApp()

    def on_update(self):
        self.bring_to_front()

    def draw(self):
        t = getClock().get_time()
        touches = getCurrentTouches()

        # draw closed touches
        to_delete = []
        ids = [touch.id for touch in touches]
        for id in self.closetouches:
            if not id in ids:
                to_delete.append(id)
                continue
            touch = self.closetouches[id]
            value = ((t - touch.time_start) - 1) / 2.
            if value > 1:
                self.do_close()
                return
            set_color(1, 1, 1, .7)
            drawSemiCircle(pos=(touch.x, touch.y), inner_radius=30, outer_radius=50, slices=64, sweep_angle=value*360)

        # delete old touches
        for id in to_delete:
            del self.closetouches[id]

        # search
        for touch in touches:
            if 'closeapp.invalid_for_close' in touch.userdata:
                continue
            # distance < 20
            if Vector(touch.osxpos, touch.osypos).distance(Vector(touch.sx, touch.sy)) > 0.015:
                # flag
                touch.userdata['closeapp.invalid_for_close'] = True
                if touch.id in self.closetouches:
                    del self.closetouches[touch.id]
                return
            # 1s minimum
            if t - touch.time_start < 1:
                if touch.id in self.closetouches:
                    del self.closetouches[touch.id]
                return
            # check corner screen
            if touch.sx < .75 or touch.sy < .75:
                if touch.id in self.closetouches:
                    del self.closetouches[touch.id]
                return
            # add touches to closed touches
            self.closetouches[touch.id] = touch

def start(win, ctx):
    ctx.w = CloseApp()
    win.add_widget(ctx.w)

def stop(win, ctx):
    win.remove_widget(ctx.w)

########NEW FILE########
__FILENAME__ = feedback
'''
FeedBack: A global feedback effect (aka Surface)
'''

from pymt import *
import os

if not 'PYMT_DOC' in os.environ:
    particle_fn = os.path.join(pymt_data_dir, 'particle2.png')
    ring_fn = os.path.join(pymt_data_dir, 'ring.png')
    ring_img = Image(ring_fn)
    ring_img.anchor_x = ring_img.width / 2
    ring_img.anchor_y = ring_img.height / 2

class GlobalFeedbackTouch(MTWidget):
    def __init__(self, **kwargs):
        super(GlobalFeedbackTouch, self).__init__(**kwargs)

        # max times of a move position (after that, it will be deleted)
        self.maxtimemove = .1

        # minimum time before the nomove particle appear
        self.mintimenomove = 1

        # maximum moves available
        self.maxmoves = 20

        # prepare list of moves
        self.timer = 0
        self.moves = []
        self.moves.append([self.x, self.y, self.maxtimemove])

    def on_move(self, x, y):

        # reset nomove timer
        self.timer = 0

        # append a new move in list
        self.moves.append([x, y, self.maxtimemove])
        if len(self.moves) > self.maxmoves:
            self.moves = self.moves[1:]

    def draw(self):
        # advance nomove timer
        self.timer += getFrameDt()

        # nomove timeout, show it !
        if self.timer > self.mintimenomove:
            alpha = min(0.9, (self.timer - self.mintimenomove) * 4)
            set_color(1, 1, 1, alpha)
            set_brush(particle_fn, size=alpha * 50)
            paintLine((self.x, self.y, self.x + 1, self.y + 1))

        # show moves
        move_to_delete = []
        have_first = False
        ox, oy = 0, 0
        alphastep = 1.0 / max(1, len(self.moves))
        alpha = 0

        # prepare brush
        set_brush(particle_fn, size=5)

        # show all moves
        for idx in xrange(0, len(self.moves)):

            # decrease timeout
            self.moves[idx][2] -= getFrameDt()
            x, y, timer = self.moves[idx]

            # move timeout, delete it
            if timer < 0:
                move_to_delete.append(idx)
                continue

            # save the first move to draw line
            if not have_first:
                have_first = True
                ox, oy = x, y
                continue

            # calcute steps for having a nice line
            numsteps = max(20, int(Vector(ox, oy).distance(Vector(x, y)))/20)

            # draw the line !
            set_color(1, 1, 1, alpha)
            paintLine((ox, oy, x, y), numsteps=10)

            # prepare next move
            ox, oy = x, y
            alpha += alphastep

class GlobalFeedback(MTWidget):
    def __init__(self, **kwargs):
        super(GlobalFeedback, self).__init__(**kwargs)
        self.touches = {}
        self.rings = []

    def on_draw(self):
        alivetouches = []
        for touch in getCurrentTouches():
            if 'kinetic' in touch.profile and touch.mode == 'spinning':
                continue
            alivetouches.append(touch.id)
            if touch.id not in self.touches:
                self.touches[touch.id] = GlobalFeedbackTouch(pos=(touch.x, touch.y))
                self.add_widget(self.touches[touch.id])
                newsprite = Image(ring_img, pos=touch.pos, opacity=0.75, scale=0.10)
                self.rings.append(newsprite)
            else:
                self.touches[touch.id].pos = (touch.x, touch.y)

        touchestodel = []

        for touchid in self.touches:
            if touchid not in alivetouches:
                touchestodel.append(touchid)

        for id in touchestodel:
            self.remove_widget(self.touches[id])
            del self.touches[id]

        # Uncomment the line below to always see feedback.
        self.bring_to_front()
        super(GlobalFeedback, self).on_draw()

    def draw(self):
        rings_to_delete = []
        for i in xrange(0, len(self.rings)):
            ring = self.rings[i]
            ring.draw()
            ring.opacity -= getFrameDt() * 1.5
            ring.scale += getFrameDt() * 2
            if ring.opacity <= 0:
                rings_to_delete.append(ring)
        for ring in rings_to_delete:
            self.rings.remove(ring)


def start(win, ctx):
    ctx.w = GlobalFeedback()
    win.add_widget(GlobalFeedback())

def stop(win, ctx):
    win.remove_widget(ctx.w)

########NEW FILE########
__FILENAME__ = heatmap
'''
Create/fill an heatmap in database
'''

from pymt import MTWidget, pymt_logger
import sys
import os
import sqlite3

class HeatMap(MTWidget):
    def __init__(self, **kwargs):
        super(HeatMap, self).__init__(**kwargs)
        self.appname = sys.argv[0]
        if self.appname == '':
            self.appname = 'python'
        elif self.appname[-3:] == '.py':
            self.appname = self.appname[:-3]
        self.filename = 'heatmap-%s.db' % self.appname
        self.db = sqlite3.connect(self.filename)
        try:
            self.db.execute('''
                CREATE TABLE heatmap (
                    x NUMERIC,
                    y NUMERIC,
                    time NUMERIC
                )
            ''')
            self.db.commit()
            pymt_logger.info('Heatmap: Create new database for heatmap in %s' % self.filename)
        except sqlite3.OperationalError:
            pymt_logger.info('Heatmap: Fill heatmap database in %s' % self.filename)

    def on_touch_down(self, touch):
        self.db.execute('''
            INSERT INTO heatmap
            VALUES (%f, %f, %f)
        ''' % (touch.sx, touch.sy, touch.time_start))
        self.db.commit()

    def on_update(self):
        self.bring_to_front()


def start(win, ctx):
    ctx.w = HeatMap()
    win.add_widget(ctx.w)

def stop(win, ctx):
    win.remove_widget(ctx.w)

########NEW FILE########
__FILENAME__ = keybinding
'''
Use keyboard to do some action
'''

__all__ = ('start', 'stop')

import sys
import logging
from pymt.cache import Cache
from pymt.clock import getClock
from pymt.base import getWindow
from pymt.graphx import drawRectangle, drawLabel, set_color, drawLine, drawCircle
from pymt.logger import pymt_logger_history, pymt_logger
from pymt.ui.colors import css_reload
from pymt.ui.widgets import *

_toggle_state = ''

def toggle(id):
    global _toggle_state
    if _toggle_state == id:
        _toggle_state = ''
    else:
        _toggle_state = id
    if _toggle_state == '':
        return

def _can_fullscreen():
    return sys.platform not in ('win32', 'darwin', 'cygwin', 'freebsd7')

def _screenshot():
    import os
    import pygame
    from OpenGL.GL import glReadBuffer, glReadPixels, GL_RGB, GL_UNSIGNED_BYTE, GL_FRONT
    win = getWindow()
    glReadBuffer(GL_FRONT)
    data = glReadPixels(0, 0, win.width, win.height, GL_RGB, GL_UNSIGNED_BYTE)
    surface = pygame.image.fromstring(str(buffer(data)), win.size, 'RGB', True)
    filename = None
    for i in xrange(9999):
        path = os.path.join(os.getcwd(), 'screenshot%04d.jpg' % i)
        if not os.path.exists(path):
            filename = path
            break
    if filename:
        try:
            pygame.image.save(surface, filename)
            pymt_logger.info('KeyBinding: Screenshot saved at %s' % filename)
        except:
            pymt_logger.exception('KeyBinding: Unable to take a screenshot')
    else:
        pymt_logger.warning('KeyBinding: Unable to take screenshot, no more slot available')

def _on_draw():
    global _toggle_state
    if _toggle_state == '':
        return

    win = getWindow()

    #
    # Show HELP screen
    #
    if _toggle_state == 'help':

        # draw the usual window
        win.on_draw()

        # make background more black
        set_color(0, 0, 0, .8)
        drawRectangle(size=win.size)

        # prepare calculation
        w2 = win.width / 2.
        h2 = win.height / 2.
        y = 0
        k = {'font_size': 20}
        ydiff = 25

        # draw help
        drawLabel('PyMT Keybinding',
                  pos=(w2, win.height - 100), font_size=40)
        drawLabel('Press F1 to leave help',
                  pos=(w2, win.height - 160), font_size=12)
        drawLabel('FPS is %.3f' % getClock().get_fps(),
                  pos=(w2, win.height - 180), font_size=12)
        drawLabel('F1 - Show Help',
                  pos=(w2, h2), **k)
        y += ydiff
        drawLabel('F2 - Show FPS (%s)' % str(win.show_fps),
                  pos=(w2, h2 - y), **k)
        y += ydiff
        drawLabel('F3 - Show Cache state',
                  pos=(w2, h2 - y), **k)
        y += ydiff
        drawLabel('F4 - Show Calibration screen',
                  pos=(w2, h2 - y), **k)
        if _can_fullscreen():
            y += ydiff
            drawLabel('F5 - Toggle fullscreen',
                      pos=(w2, h2 - y), **k)
        y += ydiff
        drawLabel('F6 - Show log',
                  pos=(w2, h2 - y), **k)
        y += ydiff
        drawLabel('F7 - Reload CSS',
                  pos=(w2, h2 - y), **k)
        y += ydiff
        drawLabel('F8 - Show widget tree',
                  pos=(w2, h2 - y), **k)
        y += ydiff
        drawLabel('F9 - Rotate the screen (%d)' % win.rotation,
                  pos=(w2, h2 - y), **k)
        y += ydiff
        drawLabel('F12 - Screenshot',
                  pos=(w2, h2 - y), **k)

        return True

    #
    # Draw cache state
    #
    elif _toggle_state == 'cachestat':
        # draw the usual window
        win.on_draw()

        # make background more black
        set_color(0, 0, 0, .8)
        drawRectangle(size=win.size)

        y = 0
        for x in Cache._categories:
            y += 25
            cat = Cache._categories[x]
            count = 0
            usage = '-'
            limit = cat['limit']
            timeout = cat['timeout']
            try:
                count = len(Cache._objects[x])
            except:
                pass
            try:
                usage = 100 * count / limit
            except:
                pass
            args = (x, usage, count, limit, timeout)
            drawLabel('%s: usage=%s%% count=%d limit=%s timeout=%s' % args,
                      pos=(20, 20 + y), font_size=20, center=False, nocache=True)

        return True

    #
    # Draw calibration screen
    #
    elif _toggle_state == 'calibration':
        step = 8
        ratio = win.height / float(win.width)
        stepx = win.width / step
        stepy = win.height / int(step * ratio)

        # draw black background
        set_color(0, 0, 0)
        drawRectangle(size=win.size)

        # draw lines
        set_color(1, 1, 1)
        for x in xrange(0, win.width, stepx):
            drawLine((x, 0, x, win.height))
        for y in xrange(0, win.height, stepy):
            drawLine((0, y, win.width, y))

        # draw circles
        drawCircle(pos=(win.width / 2., win.height / 2.),
                   radius=win.width / step, linewidth = 2.)
        drawCircle(pos=(win.width / 2., win.height / 2.),
                   radius=(win.width / step) * 2, linewidth = 2.)
        drawCircle(pos=(win.width / 2., win.height / 2.),
                   radius=(win.width / step) * 3, linewidth = 2.)

        return True


    #
    # Draw calibration screen 2 (colors)
    #
    elif _toggle_state == 'calibration2':

        # draw black background
        set_color(0, 0, 0)
        drawRectangle(size=win.size)

        # gray
        step = 25
        stepx = (win.width - 100) / step
        stepy = stepx * 2
        sizew = stepx * step
        sizeh = stepy * step
        w2 = win.width / 2.
        h2 = win.height / 2.
        for _x in xrange(step):
            x = w2 - sizew / 2. + _x * stepx
            drawLabel(chr(65+_x), pos=(x + stepx / 2., h2 + 190))
            c = _x / float(step)

            # grey
            set_color(c, c, c)
            drawRectangle(pos=(x, h2 + 100), size=(stepx, stepy))

            # red
            set_color(c, 0, 0)
            drawRectangle(pos=(x, h2 + 80 - stepy), size=(stepx, stepy))

            # green
            set_color(0, c, 0)
            drawRectangle(pos=(x, h2 + 60 - stepy * 2), size=(stepx, stepy))

            # blue
            set_color(0, 0, c)
            drawRectangle(pos=(x, h2 + 40 - stepy * 3), size=(stepx, stepy))
        return True


    #
    # Draw log screen
    #
    elif _toggle_state == 'log':

        # draw the usual window
        win.on_draw()

        # make background more black
        set_color(0, 0, 0, .8)
        drawRectangle(size=win.size)


        # calculation
        w2 = win.width / 2.
        h2 = win.height / 2.
        k = {'font_size': 11, 'center': False}
        y = win.height - 20
        y = h2
        max = int((h2 / 20))
        levels = {
            logging.DEBUG:    ('DEBUG', (.4,.4,1)),
            logging.INFO:     ('INFO', (.4,1,.4)),
            logging.WARNING:  ('WARNING', (1,1,.4)),
            logging.ERROR:    ('ERROR', (1,.4,.4)),
            logging.CRITICAL: ('CRITICAL', (1,.4,.4)),
        }

        # draw title
        drawLabel('PyMT logger',
                  pos=(w2, win.height - 100), font_size=40)

        # draw logs
        for log in reversed(pymt_logger_history.history[:max]):
            levelname, color = levels[log.levelno]
            msg = log.message.split('\n')[0]
            x = 10
            s = drawLabel('[', pos=(x, y), **k)
            x += s[0]
            s = drawLabel(levelname, pos=(x, y), color=color, **k)
            x += s[0]
            s = drawLabel(']', pos=(x, y), **k)
            x += s[0]
            drawLabel(msg, pos=(100, y), **k)
            y -= 20
        return True



class SceneGraphNode(MTBoxLayout):
    def __init__(self, **kwargs):
        kwargs['invert'] = True
        super(SceneGraphNode, self).__init__(**kwargs)

        self.widget = kwargs['node']
        self.selected = False

        self.child_layout = MTBoxLayout(size_hint=(None, None), spacing=10, orientation="vertical")
        for c in self.widget.children:
            self.child_layout.add_widget(SceneGraphNode(node=c, size_hint=(None, None)))
        self.add_widget(self.child_layout)

        self.node_btn = MTToggleButton(label=str(self.widget.__class__.__name__), size=(150,30))
        self.title = MTAnchorLayout(size_hint=(None, None), size=(200,self.child_layout.height))
        self.title.add_widget(self.node_btn)
        self.add_widget(self.title)

        self.node_btn.connect('on_release',self.select)

    def draw(self):
        if self.selected:
            set_color(1,0,0,0.3)
            drawRectangle(self.to_widget(*self.widget.pos), self.widget.size)

        set_color(1,.3,0)
        for c in self.child_layout.children:
            drawLine((self.node_btn.centerright,c.node_btn.centerleft), width=2)

    def select(self, *args):
        self.selected = not self.selected

    def add_new_widget(self, *args):
        new_widget = MTButton(label="I'm new!!!")
        self.widget.add_widget(new_widget)
        self.child_layout.add_widget(SceneGraphNode(node=new_widget, size_hint=(None, None)))
        self.title.size=(200,self.child_layout.height)

    def print_props(self, *args):
        for prop in self.widget.__dict__:
            if not prop.startswith("_"):
                print prop, ":", getattr(self.widget, prop)



_scene_graph_modal_layover = None
def toggle_scene_graph():
    global _scene_graph_modal_layover
    win = getWindow()
    if _scene_graph_modal_layover:
        win.remove_widget(_scene_graph_modal_layover)
        _scene_graph_modal_layover = None
        return
    else:
        scene_graph = SceneGraphNode(node=win.children[0], size_hint=(None, None))
        plane = MTScatterPlane(do_rotation=False)
        plane.add_widget(scene_graph)
        _scene_graph_modal_layover = MTModalWindow()
        _scene_graph_modal_layover.add_widget(plane)
        win.add_widget(_scene_graph_modal_layover)



def _on_keyboard_handler(key, scancode, unicode):
    if key is None:
        return
    win = getWindow()
    if key == 282: # F1
        toggle('help')
    elif key == 283: # F2
        win.show_fps = not win.show_fps
    elif key == 284: # F3
        toggle('cachestat')
    elif key == 285: # F4
        # rotating between calibration screen
        if _toggle_state == 'calibration':
            toggle('calibration2')
        elif _toggle_state == 'calibration2':
            toggle('')
        else:
            toggle('calibration')
    elif key == 286 and _can_fullscreen(): # F5
        win.toggle_fullscreen()
    elif key == 287: # F6
        toggle('log')
    elif key == 288: # F7
        css_reload()
    elif key == 289: # F8
        toggle_scene_graph()
    elif key == 290: # F9
        win.rotation = win.rotation + 90
    elif key == 293:
        _screenshot()


def start(win, ctx):
    win.push_handlers(on_keyboard=_on_keyboard_handler)
    win.push_handlers(on_draw=_on_draw)

def stop(win, ctx):
    win.remove_handlers(on_keyboard=_on_keyboard_handler)
    win.remove_handlers(on_draw=_on_draw)

########NEW FILE########
__FILENAME__ = mjpegserver
'''
Stream the PyMT video inside MJPEG HTTP server

:Configuration:
    `ip` : str, default to ''
        By default, server will listen on all ips availables
    `port` : int, default to 8000
        TCP Port to listen
    `fps` : int, default to 20
        Fix a FPS to try to have the same FPS on the whole video
    `size` : str, default to ''
        If the image must be resized, set size to "320x240" for example

'''
#
# Developper note
#
# Double lock is needed if we don't want the sensation about laggy video
# The deal is, if we don't lock the screen, you got more FPS on OpenGL than
# streaming (and that would be good.) Except that since it's not synced,
# video look laggy.
# Double-lock was just the faster solution to do right now :)
#

import os
import pymt
import threading
import time
import StringIO
import random
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
from OpenGL.GL import glReadBuffer, glReadPixels, GL_RGB, GL_UNSIGNED_BYTE, GL_FRONT
from pymt.utils import curry

if 'PYMT_DOC' not in os.environ:
	from PIL import Image

lock_current    = threading.Lock()
sem_current     = threading.Semaphore(0)
sem_next        = threading.Semaphore(1)
img_current     = None
connected       = False

def keep_running():
    return True

class MjpegHttpRequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        global connected, sem_next
        try:
            connected = True
            self._stream_video()
        finally:
            connected = False
            # to prevent that app hang
            sem_next.release()
            pymt.pymt_logger.info(
                'MjpegServer: Client %s:%d disconnect' % self.client_address)

    def _stream_video(self):
        global img_current

        lfps        = []
        dt          = 0
        frames      = 0
        fps_wanted  = self.server.config.get('fps')
        if fps_wanted == '':
            fps_wanted = 0
        fps_wanted = float(fps_wanted)
        if fps_wanted <= 1:
            fps_wanted = 0
        else:
            fps_wanted = 1 / fps_wanted
        size        = self.server.config.get('size')
        if size == '':
            size = None
        else:
            size = map(int, size.split('x'))

        pymt.pymt_logger.info(
            'MjpegServer: Client %s:%d connected' % self.client_address)

        self.send_response(200, 'OK')
        self.boundary = 'pymt-mjpegserver-boundary-%d' % (random.randint(1, 9999999))
        self.send_header('Server', 'PyMT MjpegServer')
        self.send_header('Content-type', 'multipart/x-mixed-replace; boundary=%s' % self.boundary)
        self.end_headers()

        # don't accept connection until the window is created
        # XXX really needed ?
        while not pymt.getWindow():
            time.sleep(0.1)
        win = pymt.getWindow()

        dt = dt_current = dt_old = time.time()
        while keep_running():

            # SYNC START
            sem_current.acquire()

            with lock_current:
                im = Image.fromstring('RGB', win.size, img_current)
                img_current = None

            sem_next.release()
            # SYNC END

            buf = StringIO.StringIO()
            if size:
                im = im.resize(size)
            im = im.transpose(Image.FLIP_TOP_BOTTOM)
            im.save(buf, format='JPEG')
            jpeg = buf.getvalue()

            self.wfile.write('--%s\r\n' % self.boundary)
            self.wfile.write('Content-Type: image/jpeg\r\n')
            self.wfile.write('Content-Length: %d\r\n\r\n' % len(jpeg))
            self.wfile.write(jpeg)

            dt_old = dt_current
            dt_current = time.time()

            d = dt_current - dt_old
            if d < fps_wanted:
                time.sleep(d)

            frames += 1
            if dt_current - dt > 2.:
                fps = frames / (dt_current - dt)
                lfps.append(fps)
                x = sum(lfps) / len(lfps)
                pymt.pymt_logger.debug('MjpegServer: current FPS is %.1f, average is %.1f' % (fps, x))
                dt = dt_current
                frames = 0

class MjpegServerThread(threading.Thread):
    def __init__(self, config):
        super(MjpegServerThread, self).__init__()
        self.config = config

    def run(self):
        server_address = (self.config.get('ip'), int(self.config.get('port')))
        httpd = HTTPServer(server_address, MjpegHttpRequestHandler)
        httpd.config = self.config
        pymt.pymt_logger.info('MjpegServer: Listen to %s:%d' % server_address)
        while keep_running():
            httpd.handle_request()

def window_flip_and_save():
    global img_current
    win = pymt.getWindow()

    with lock_current:
        if not connected:
            return

    sem_next.acquire()

    with lock_current:
        glReadBuffer(GL_FRONT)
        data = glReadPixels(0, 0, win.width, win.height, GL_RGB, GL_UNSIGNED_BYTE)
        img_current = str(buffer(data))

    sem_current.release()

def start(win, ctx):
    win.push_handlers(on_flip=window_flip_and_save)

    ctx.config.setdefault('ip', '')
    ctx.config.setdefault('port', '8000')
    ctx.config.setdefault('fps', '')
    ctx.config.setdefault('size', '')

    ctx.server = MjpegServerThread(ctx.config)
    ctx.server.daemon = True
    ctx.server.start()

def stop(win, ctx):
    win.remove_handlers(on_flip=window_flip_and_save)

########NEW FILE########
__FILENAME__ = recordvideo
'''
Record the opengl output into a video
'''

import os
if 'PYMT_DOC' not in os.environ:
	import pygame
	import pymt
	from OpenGL.GL import glReadBuffer, glReadPixels, GL_RGB, GL_UNSIGNED_BYTE, GL_FRONT
	from pymt.utils import curry

	dump_prefix    = pymt.pymt_config.get('dump', 'prefix')
	dump_format    = pymt.pymt_config.get('dump', 'format')
	dump_idx       = 0

def window_flip_and_save():
    global dump_idx
    win = pymt.getWindow()
    glReadBuffer(GL_FRONT)
    data = glReadPixels(0, 0, win.width, win.height, GL_RGB, GL_UNSIGNED_BYTE)
    surface = pygame.image.fromstring(str(buffer(data)), win.size, 'RGB', True)
    filename = '%s%05d.%s' % (dump_prefix, dump_idx, dump_format)
    pygame.image.save(surface, filename)
    dump_idx += 1

def start(win, ctx):
    win.push_handlers(on_flip=window_flip_and_save)

def stop(win, ctx):
    win.remove_handlers(on_flip=window_flip_and_save)

########NEW FILE########
__FILENAME__ = sleep
'''
Sleep: reduce FPS when no activity is detected.

Temporary solution to sleep any PyMT application if nobody touch the screen.
This could have a bad impact when reading video or audio. It's not suitable for
everyone, it's just a temporary solution.

Sleep module check every frame if they are any touches activities. When no
activity is made from an amount of time, sleep module will introduce a sleep()
call after each frame renderer. More the sleep will be high, more the FPS will
decrease, more your CPU will be not used.

Sleep module need 2 lists: ramp and sleep. For example ::

    [modules]
    sleep = ramp=5:10:20:30:60:180,sleep=.03:.1:.2:.5:1.:5.

For a ramp of 5s, 10s, 20s, 30s, 50s, 180s, the sleep time will be .03s, .1s,
.2s, .5s, 1., 5.
With this default ramp/sleep, after 5s of inactivity, FPS will be 1/0.03 =
33 FPS. After 10s, FPS will be 1/.1 = 10 FPS...

During the sleep phase, touch cannot wake up the module. But the module will be
reseted.
'''

from pymt.logger import pymt_logger
from time import time, sleep

class Sleep(object):
    def __init__(self, config, win):
        super(Sleep, self).__init__()
        self.timer_no_activity = time()
        self.win = win
        self.step = -1

        # take configuration
        ramp = config.get('ramp').split(':')
        sleep = config.get('sleep').split(':')
        if len(ramp) != len(sleep):
            raise ValueError('Sleep: Invalid ramp/sleep: list size is not the same')
        self.ramp = map(float, ramp)
        self.sleep = map(float, sleep)
        pymt_logger.debug('Sleep: ramp is %s' % str(self.ramp))
        pymt_logger.debug('Sleep: sleep is %s' % str(self.sleep))

    def start(self):
        win = self.win
        win.connect('on_touch_down', self.got_activity)
        win.connect('on_touch_move', self.got_activity)
        win.connect('on_touch_up', self.got_activity)
        win.connect('on_flip', self.do_check)

    def stop(self):
        win = self.win
        win.remove_handler('on_touch_down', self.got_activity)
        win.remove_handler('on_touch_move', self.got_activity)
        win.remove_handler('on_touch_up', self.got_activity)
        win.remove_handler('on_flip', self.do_check)

    def got_activity(self, *largs, **kwargs):
        self.timer_no_activity = time()

    def do_check(self, *largs, **kwargs):
        timer = time() - self.timer_no_activity
        step = -1
        for x in self.ramp:
            if timer >= x:
                step += 1
        if self.step != step:
            if step == -1:
                pymt_logger.info('Sleep: activity detected, wake up.')
            else:
                pymt_logger.info('Sleep: %ds inactivity detected. Reduce FPS to '
                                 '%.4f' % (self.ramp[step], 1. / float(self.sleep[step])))
            self.step = step
        if step >= 0:
            sleep(self.sleep[step])

def start(win, ctx):
    ctx.config.setdefault('ramp', '5:10:20:30:60:180')
    ctx.config.setdefault('sleep', '.03:.1:.2:.5:1.:5.')
    ctx.sleep = Sleep(ctx.config, win)
    ctx.sleep.start()

def stop(win, ctx):
    ctx.sleep.stop()
    del ctx.sleep

########NEW FILE########
__FILENAME__ = touchinfo
'''
Get all informations of a touch
'''

from pymt import MTWidget, MTSpeechBubble, getCurrentTouches

class TouchInfos(MTWidget):
    def __init__(self, **kwargs):
        super(TouchInfos, self).__init__(**kwargs)
        self.bubbles = {}

    def text_info(self, touch):
        infos = []
        infos.append('ID: %s' % (str(touch.id)))
        infos.append('UID: %s' % (str(touch.uid)))
        infos.append('Class: %s' % str(touch.__class__.__name__))
        infos.append('Raw pos: (%.3f, %.3f)' % (touch.sx, touch.sy))
        infos.append('Scr Pos: (%d, %d)' % (touch.xpos, touch.ypos))
        if hasattr(touch, 'xmot'):
            infos.append('Mot: (%.2f, %.2f)' % (touch.xmot, touch.ymot))
        infos.append('Double Tap: %s' % (touch.is_double_tap))
        infos.append('Device: %s' % (touch.device))
        return "\n".join(infos)

    def on_update(self):
        self.bring_to_front()

    def draw(self):
        bubbles = self.bubbles
        get = self.bubbles.get
        info = self.text_info
        current = getCurrentTouches()
        for touch in current:
            uid = touch.uid
            bubble = get(uid, None)
            if not bubble:
                bubble = MTSpeechBubble(
                    size=(150, 100), color=(0, 0, 0, 1), font_size=9)
                self.bubbles[uid] = bubble
            bubble.pos = touch.pos
            bubble.label = info(touch)
            bubble.dispatch_event('on_draw')

        alive = [x.uid for x in current]
        for uid in bubbles.keys()[:]:
            if uid not in alive:
                del bubbles[uid]

def start(win, ctx):
    ctx.w = TouchInfos()
    win.add_widget(ctx.w)

def stop(win, ctx):
    win.remove_widget(ctx.w)

########NEW FILE########
__FILENAME__ = touchring
'''
Show a circle under all touchs
'''

import os
from pymt import MTWidget, set_color, getCurrentTouches, pymt_data_dir, Image

if not 'PYMT_DOC' in os.environ:
    ring_fn = os.path.join(pymt_data_dir, 'ring.png')
    ring_img = Image(ring_fn)
    ring_img.scale = .30
    ring_img.anchor_x = ring_img.width / 2
    ring_img.anchor_y = ring_img.height / 2

class TouchRing(MTWidget):
    def __init__(self, **kwargs):
        super(TouchRing, self).__init__(**kwargs)

    def on_update(self):
        self.bring_to_front()

    def draw(self):
        color = self.style.get('color')
        ring_img.color = color
        for touch in getCurrentTouches():
            alpha = color[3]
            if 'kinetic' in touch.profile:
                alpha = .2

            # draw touch
            ring_img.opacity = alpha
            ring_img.pos = touch.pos
            ring_img.draw()

def start(win, ctx):
    ctx.w = TouchRing()
    win.add_widget(ctx.w)

def stop(win, ctx):
    win.remove_widget(ctx.w)

########NEW FILE########
__FILENAME__ = obj
'''
Obj: handle 3D mesh from the OBJ format file.

OBJ is a geometry definition file, adopted by many vendor graphics.
To known more about the format, check http://en.wikipedia.org/wiki/Obj
'''

__all__ = ('OBJ', 'Material', 'MaterialGroup', 'Mesh')

import os
from pymt.logger import pymt_logger
from pymt.core.image import Image
from OpenGL.GL import GL_FRONT_AND_BACK, GL_DIFFUSE, GL_AMBIENT, GL_SPECULAR, \
        GL_SHININESS, GL_AMBIENT_AND_DIFFUSE, GL_COLOR_MATERIAL, GLfloat, \
        GL_BACK, GL_CULL_FACE, GL_CLIENT_VERTEX_ARRAY_BIT, GL_EMISSION, \
        GL_CURRENT_BIT, GL_ENABLE_BIT, GL_LIGHTING_BIT, GL_COMPILE, \
        GL_T2F_N3F_V3F, GL_TRIANGLES, GL_LIGHT0, GL_LIGHTING, GL_DEPTH_TEST, \
        GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_AMBIENT, GL_REPEAT, \
        glEnable, glDisable, glPushClientAttrib, glPushAttrib, \
        glPopClientAttrib, glPopAttrib, glInterleavedArrays, glDrawArrays, \
        glNewList, glEndList, glCullFace, glMaterialfv, glColorMaterial, \
        glCallList, glGenLists, glMaterialf, glLightfv, glLightModelfv, \
        glColor3f

class Material(object):
    '''
    Material class to handle attribute like light (ambient, diffuse, specular,
    emmission, shininess), opacity, texture...
    '''
    diffuse = [.8, .8, .8]
    ambient = [.2, .2, .2]
    specular = [0., 0., 0.]
    emission = [0., 0., 0.]
    shininess = 0.
    opacity = 1.
    texture = None

    def __init__(self, name):
        self.name = name

    def apply(self, face=GL_FRONT_AND_BACK):
        '''Apply the material on current context'''
        if self.texture:
            self.texture.enable()
            self.texture.bind()
            glEnable(GL_COLOR_MATERIAL)

        glMaterialfv(face, GL_DIFFUSE, self.diffuse + [self.opacity])
        glMaterialfv(face, GL_AMBIENT, self.ambient + [self.opacity])
        glMaterialfv(face, GL_SPECULAR, self.specular + [self.opacity])
        glMaterialfv(face, GL_EMISSION, self.emission + [self.opacity])
        glMaterialf(face, GL_SHININESS, self.shininess)
        glColorMaterial(face, GL_AMBIENT_AND_DIFFUSE)

    def unapply(self):
        if self.texture:
            self.texture.disable()
            glDisable(GL_COLOR_MATERIAL)

class MaterialGroup(object):
    '''
    Groups of material
    '''
    def __init__(self, material):
        self.material = material

        # Interleaved array of floats in GL_T2F_N3F_V3F format
        self.vertices = []
        self.array = None

class Mesh(object):
    '''
    Class to store a mesh in T2F_N3F_V3F format.
    '''
    def __init__(self, name):
        self.name = name
        self.groups = []

        # Display list, created only if compile() is called, but used
        # automatically by draw()
        self.list = None

    def draw(self):
        '''Draw the mesh on screen (using display list if compiled)'''
        if self.list:
            glCallList(self.list)
            return

        glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
        glPushAttrib(GL_CURRENT_BIT | GL_ENABLE_BIT | GL_LIGHTING_BIT)
        glEnable(GL_CULL_FACE)
        glCullFace(GL_BACK)
        for group in self.groups:
            if group.material:
                group.material.apply()
            if group.array is None:
                if group.material and group.material.texture:
                    if group.material.texture.rectangle:
                        # texture is a rectangle texture
                        # that's mean we need to adjust the range of texture
                        # coordinate from original 0-1 to 0-width/0-height
                        group.vertices[0::8] = map(
                            lambda x: x * group.material.texture.width,
                            group.vertices[0::8]
                        )
                        group.vertices[1::8] = map(
                            lambda x: x * group.material.texture.height,
                            group.vertices[1::8]
                        )
                group.array = (GLfloat * len(group.vertices))(*group.vertices)
                group.triangles = len(group.vertices) / 8
            glInterleavedArrays(GL_T2F_N3F_V3F, 0, group.array)
            glDrawArrays(GL_TRIANGLES, 0, group.triangles)
            if group.material:
                group.material.unapply()
        glPopAttrib()
        glPopClientAttrib()

    def compile(self):
        '''Compile the mesh in display list'''
        if self.list:
            return
        gllist = glGenLists(1)
        glNewList(gllist, GL_COMPILE)
        self.draw()
        glEndList()
        self.list = gllist


class OBJ:
    '''3D object representation.

    :Parameters:
        `filename` : string
            Filename of object
        `file` : File object, default to None
            Use file instead of filename if possible
        `path` : string, default to None
            Use custom path for material
        `compat` : bool, default to True
            Set to False if you want to take care yourself of the lights, depth
            test, color...
    '''
    def __init__(self, filename, file=None, path=None, compat=True):
        self.materials = {}
        self.meshes = {}        # Name mapping
        self.mesh_list = []     # Also includes anonymous meshes
        self.compat = compat

        if file is None:
            file = open(filename, 'r')

        if path is None:
            path = os.path.dirname(filename)
            self.path = path

        mesh = None
        group = None
        material = None

        vertices = [[0., 0., 0.]]
        normals = [[0., 0., 0.]]
        tex_coords = [[0., 0.]]

        for line in open(filename, 'r'):
            if line.startswith('#'):
                continue
            values = line.split()
            if not values:
                continue

            if values[0] == 'v':
                vertices.append(map(float, values[1:4]))
            elif values[0] == 'vn':
                normals.append(map(float, values[1:4]))
            elif values[0] == 'vt':
                tex_coords.append(map(float, values[1:3]))
            elif values[0] == 'mtllib':
                self.load_material_library(values[1])
            elif values[0] in ('usemtl', 'usemat'):
                material = self.materials.get(values[1], None)
                if material is None:
                    pymt_logger.warning('OBJ: Unknown material: %s' % values[1])
                if mesh is not None:
                    group = MaterialGroup(material)
                    mesh.groups.append(group)
            elif values[0] == 'o':
                mesh = Mesh(values[1])
                self.meshes[mesh.name] = mesh
                self.mesh_list.append(mesh)
                group = None
            elif values[0] == 'f':
                if mesh is None:
                    mesh = Mesh('')
                    self.mesh_list.append(mesh)
                if material is None:
                    material = Material('')
                if group is None:
                    group = MaterialGroup(material)
                    mesh.groups.append(group)

                # For fan triangulation, remember first and latest vertices
                v1 = None
                vlast = None
                for i, v in enumerate(values[1:]):
                    v_index, t_index, n_index = \
                        (map(int, [j or 0 for j in v.split('/')]) + [0, 0])[:3]
                    if v_index < 0:
                        v_index += len(vertices) - 1
                    if t_index < 0:
                        t_index += len(tex_coords) - 1
                    if n_index < 0:
                        n_index += len(normals) - 1
                    vertex = tex_coords[t_index] + \
                            normals[n_index] + \
                            vertices[v_index]

                    if i >= 3:
                        # Triangulate
                        group.vertices += v1 + vlast
                    group.vertices += vertex

                    if i == 0:
                        v1 = vertex
                    vlast = vertex

    def open_material_file(self, filename):
        '''Override for loading from archive/network etc.'''
        return open(os.path.join(self.path, filename), 'r')

    def load_material_library(self, filename):
        material = None
        file = self.open_material_file(filename)

        for line in file:
            if line.startswith('#'):
                continue
            values = line.split()
            if not values:
                continue

            if values[0] == 'newmtl':
                material = Material(values[1])
                self.materials[material.name] = material
            elif material is None:
                pymt_logger.warning('OBJ: Expected "newmtl" in %s' % filename)
                continue

            try:
                if values[0] == 'Kd':
                    material.diffuse = map(float, values[1:])
                elif values[0] == 'Ka':
                    material.ambient = map(float, values[1:])
                elif values[0] == 'Ks':
                    material.specular = map(float, values[1:])
                elif values[0] == 'Ke':
                    material.emission = map(float, values[1:])
                elif values[0] == 'Ns':
                    material.shininess = float(values[1])
                elif values[0] == 'd':
                    material.opacity = float(values[1])
                elif values[0] == 'map_Kd':
                    try:
                        filename = ' '.join(values[1:])
                        material.texture = Image(filename).texture
                        material.texture.wrap = GL_REPEAT
                    except:
                        pymt_logger.warning('OBJ: Could not load texture %s' % values[1])
                        raise
            except:
                pymt_logger.warning('OBJ: Parse error in %s.' % filename)
                raise

    def enter(self):
        if not self.compat:
            return
        glLightfv(GL_LIGHT0, GL_AMBIENT, (0, 0, 0, 1))
        glLightfv(GL_LIGHT0, GL_DIFFUSE, (.8, .8, .8, 1))
        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (.9, .9, .9))
        glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, 0)
        glEnable(GL_LIGHTING)
        glEnable(GL_LIGHT0)
        glEnable(GL_DEPTH_TEST)
        glColor3f(1, 1, 1)

    def leave(self):
        if not self.compat:
            return
        glDisable(GL_LIGHTING)
        glDisable(GL_LIGHT0)
        glDisable(GL_COLOR_MATERIAL)
        glDisable(GL_DEPTH_TEST)

    def draw(self):
        '''Draw the object on screen'''
        self.enter()
        for mesh in self.mesh_list:
            mesh.draw()
        self.leave()


########NEW FILE########
__FILENAME__ = parser
'''
Parser: default parser from string to special type

Used specially for CSS
'''

__all__ = ('parse_image', 'parse_color', 'parse_int', 'parse_float',
           'parse_string', 'parse_bool', 'parse_int2',
           'parse_float4', 'parse_filename')

import re
from pymt.logger import pymt_logger
from pymt.resources import resource_find
from pymt.core.image import Image
from pymt.core.svg import Svg

def parse_filename(filename):
    '''Parse a filename, and search inside resource if exist.
    If we haven't found it, just return the name.
    '''
    filename = parse_string(filename)
    result = resource_find(filename)
    if result is None:
        pymt_logger.error('Resource: unable to found <%s>' % filename)
    return result or filename

def parse_image(filename):
    '''Parse a filename to load an image ro svg'''
    filename = parse_filename(filename)
    if filename in (None, 'None', u'None'):
        return None
    if filename.endswith('.svg'):
        return Svg(filename)
    else:
        return Image(filename)
    raise Exception('Error trying to load image specified in css: %s' \
                    % filename)

def parse_color(text):
    '''Parse a text color to a pymt color. Format supported are :
        * rgb(r, g, b)
        * rgba(r, g, b, a)
        * #aaa
        * #rrggbb
    '''
    value = [1, 1, 1, 1]
    if text.startswith('rgb'):
        res = re.match('rgba?\((.*)\)', text)
        value = map(lambda x: int(x) / 255., re.split(',\ ?', res.groups()[0]))
        if len(value) == 3:
            value.append(1.)
    elif text.startswith('#'):
        res = text[1:]
        if len(res) == 3:
            res = ''.join(map(lambda x: x+x, res))
        value = [int(x, 16) / 255. for x in re.split(
                 '([0-9a-f]{2})', res) if x != '']
        if len(value) == 3:
            value.append(1.)
    return value

def parse_bool(text):
    '''Parse a string to a boolean'''
    if text.lower() in ('true', '1'):
        return True
    elif text.lower() in ('false', '0'):
        return False
    raise Exception('Invalid boolean: %s' % text)

def parse_string(text):
    '''Parse a string to a string (remove quotes and double-quotes)'''
    if len(text) >= 2 and text[0] in ('"', "'") and text[-1] in ('"', "'"):
        text = text[1:-1]
    return text.strip()

def parse_int2(text):
    '''Parse a string to a integer with exactly 2 number

	>>> print parse_int2("12 54")
	12, 54

    '''
    texts = [x for x in text.split(' ') if x.strip() != '']
    value = map(parse_int, texts)
    if len(value) < 1:
        raise Exception('Invalid format int2 for %s' % text)
    elif len(value) == 1:
        return [value[0], value[0]]
    elif len(value) > 2:
        raise Exception('Too much value in %s : %s' % (text, str(value)))
    return value

def parse_float4(text):
    '''Parse a string to a float with exactly 4 floats

	>>> parse_float4('54 87. 35 0')
	54, 87., 35, 0

    '''
    texts = [x for x in text.split(' ') if x.strip() != '']
    value = map(parse_float, texts)
    if len(value) < 1:
        raise Exception('Invalid format float4 for %s' % text)
    elif len(value) == 1:
        return map(lambda x: value[0], range(4))
    elif len(value) == 2:
        return [value[0], value[1], value[0], value[1]]
    elif len(value) == 3:
        # ambigous case!
        return [value[0], value[1], value[0], value[2]]
    elif len(value) > 4:
        raise Exception('Too much value in %s' % text)
    return value

parse_int = int
parse_float = float


########NEW FILE########
__FILENAME__ = plugin
'''
Plugins: basic plugins management, used for desktop examples
'''

__all__ = ('MTContext', 'MTPlugins')

import sys
import os

class MTContext(object):
    '''Context storage of a plugin'''
    def __init__(self):
        pass

class MTPlugins(object):
    '''Scan the examples directory, and extract the plugins in.'''
    def __init__(self, plugin_paths=['../examples/']):
        self.plugin_paths = plugin_paths
        self.plugins = {}
        self.plugins_loaded = False

    def update_sys_path(self):
        for path in self.plugin_paths:
            if path not in sys.path:
                sys.path.append(path)

    def search_plugins(self):
        self.update_sys_path()
        for path in self.plugin_paths:
            try:
                l = os.listdir(path)
            except:
                continue
            for plugin in l:
                if not os.path.isdir(os.path.join(path, plugin)):
                    continue
                try:
                    a = __import__(name='%s.%s' % (plugin, plugin),
                                   fromlist=plugin)
                    if not a.IS_PYMT_PLUGIN:
                        continue
                    a.__internal_path = os.path.join(path, plugin)
                    a.__internal_name = plugin
                    self.plugins[plugin] = a
                except Exception:
                    pass

    def list(self):
        '''Return a list of plugin'''
        if not self.plugins_loaded:
            self.search_plugins()
        return self.plugins

    def get_plugin(self, name):
        '''Return a module from a name'''
        return self.plugins[name]

    def get_key(self, plugin, key, default_value=''):
        try:
            return plugin.__getattribute__(key)
        except:
            return default_value

    def get_infos(self, plugin):
        '''Return a dict info from module'''
        return {
            'title': self.get_key(plugin, 'PLUGIN_TITLE'),
            'author': self.get_key(plugin, 'PLUGIN_AUTHOR'),
            'email': self.get_key(plugin, 'PLUGIN_EMAIL'),
            'description': self.get_key(plugin, 'PLUGIN_DESCRIPTION'),
            'icon': self.get_key(plugin, 'PLUGIN_ICON', '%s.png' % \
                                 plugin.__internal_name),
            'path': plugin.__internal_path
        }

    def activate(self, plugin, container):
        '''Activate a plugin'''
        ctx = MTContext()
        plugin.pymt_plugin_activate(container, ctx)

    def deactivate(self, plugin, container):
        '''Deactivate a plugin'''
        # XXX TODO: remember each context for each plugin instance !
        #ctx = MTContext()
        try:
            plugin.pymt_plugin_deactivate(container)
        except:
            pass


if __name__ == '__main__':
    a = MTPlugins()
    for plugin in a.list():
        print a.get_infos(a.get_plugin(plugin))

########NEW FILE########
__FILENAME__ = resources
'''
Resources: Search a file inside a list of paths
'''

__all__ = ('resource_find', 'resource_add_path')

from os.path import join, dirname, exists
from pymt.logger import pymt_logger
import sys

resource_paths = [
    '.',
    dirname(sys.argv[0]),
]

def resource_find(filename):
    '''Search a resource in list of paths.
    Use resource_add_path to add a custom path to search.
    '''
    if exists(filename):
        return filename
    for path in reversed(resource_paths):
        output = join(path, filename)
        if exists(output):
            return output
    return None

def resource_add_path(path):
    '''Add a custom path to search in
    '''
    if path in resource_paths:
        return
    pymt_logger.debug('Resource: add <%s> in path list' % path)
    resource_paths.append(path)


########NEW FILE########
__FILENAME__ = support
'''
Support: activate other framework/toolkit inside our event loop
'''

__all__ = ('install_gobject_iteration', )

def install_gobject_iteration():
    '''Import and install gobject context iteration inside our event loop.
    This is used as soon as gobject is used (like gstreamer)
    '''

    from pymt.clock import getClock
    import gobject
    if hasattr(gobject, '_gobject_already_installed'):
        # already installed, don't do it twice.
        return

    gobject._gobject_already_installed = True

    # get gobject mainloop / context
    loop = gobject.MainLoop()
    gobject.threads_init()
    context = loop.get_context()

    # schedule the iteration each frame
    def _gobject_iteration(*largs):
        context.iteration(False)
    getClock().schedule_interval(_gobject_iteration, 0)

########NEW FILE########
__FILENAME__ = texture
'''
Texture: abstraction to handle GL texture, and region
'''

__all__ = ('Texture', 'TextureRegion')

import os
import re
from array import array
from pymt import pymt_logger
import OpenGL
from OpenGL.GL import GL_RGBA, GL_UNSIGNED_BYTE, GL_TEXTURE_MIN_FILTER, \
        GL_TEXTURE_MAG_FILTER, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_S, \
        GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_RECTANGLE_ARB, \
        GL_CLAMP_TO_EDGE, GL_LINEAR_MIPMAP_LINEAR, GL_GENERATE_MIPMAP, \
        GL_TRUE, GL_LINEAR, GL_UNPACK_ALIGNMENT, GL_BGR, GL_BGRA, GL_RGB, \
        glEnable, glDisable, glBindTexture, glTexParameteri, glTexImage2D, \
        glTexSubImage2D, glFlush, glGenTextures, glDeleteTextures, \
        GLubyte, glPixelStorei, GL_LUMINANCE
from OpenGL.GL.NV.texture_rectangle import glInitTextureRectangleNV
from OpenGL.GL.ARB.texture_rectangle import glInitTextureRectangleARB
from OpenGL.extensions import hasGLExtension

# for a specific bug in 3.0.0, about deletion of framebuffer.
# same hack as FBO :(
OpenGLversion = tuple(int(re.match('^(\d+)', i).groups()[0]) \
                      for i in OpenGL.__version__.split('.'))
if OpenGLversion < (3, 0, 1):
    try:
        import numpy
        have_numpy = True
    except Exception:
        have_numpy = False


def _nearest_pow2(v):
    # From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
    # Credit: Sean Anderson
    v -= 1
    v |= v >> 1
    v |= v >> 2
    v |= v >> 4
    v |= v >> 8
    v |= v >> 16
    return v + 1

def _is_pow2(v):
    # http://graphics.stanford.edu/~seander/bithacks.html#DetermineIfPowerOf2
    return (v & (v - 1)) == 0

#
# Releasing texture through GC is problematic
# GC can happen in a middle of glBegin/glEnd
# So, to prevent that, call the _texture_release
# at flip time.
_texture_release_list = []
def _texture_release(*largs):
    global _texture_release_list
    for texture_id in _texture_release_list:
        # try/except are here to prevent an error like this :
        # Exception TypeError: "'NoneType' object is not callable"
        # in <bound method Texture.__del__ of <pymt.texture.Texture
        # object at 0x3a1acb0>> ignored
        #
        # It occured only when leaving the application.
        # So, maybe numpy or pyopengl is unloaded, and have weird things happen.
        #
        try:
            if OpenGLversion < (3, 0, 1) and have_numpy:
                glDeleteTextures(numpy.array(texture_id))
            else:
                glDeleteTextures(texture_id)
        except:
            pass

    # let the list to 0
    _texture_release_list = []

class Texture(object):
    '''Handle a OpenGL texture. This class can be used to create simple texture
    or complex texture based on ImageData.'''

    __slots__ = ('tex_coords', '_width', '_height', '_target', '_id', '_mipmap',
                '_gl_wrap', '_gl_min_filter', '_gl_mag_filter', '_rectangle')

    _has_bgr = None
    _has_bgr_tested = False
    _has_texture_nv = None
    _has_texture_arb = None

    def __init__(self, width, height, target, texid, mipmap=False, rectangle=False):
        self.tex_coords     = (0., 0., 1., 0., 1., 1., 0., 1.)
        self._width         = width
        self._height        = height
        self._target        = target
        self._id            = texid
        self._mipmap        = mipmap
        self._gl_wrap       = None
        self._gl_min_filter = None
        self._gl_mag_filter = None
        self._rectangle     = rectangle

    def __del__(self):
        # Add texture deletion outside GC call.
        # This case happen if some texture have been not deleted
        # before application exit...
        if _texture_release_list is not None:
            _texture_release_list.append(self.id)

    @property
    def mipmap(self):
        '''Return True if the texture have mipmap enabled (readonly)'''
        return self._mipmap

    @property
    def rectangle(self):
        '''Return True if the texture is a rectangle texture (readonly)'''
        return self._rectangle

    @property
    def id(self):
        '''Return the OpenGL ID of the texture (readonly)'''
        return self._id

    @property
    def target(self):
        '''Return the OpenGL target of the texture (readonly)'''
        return self._target

    @property
    def width(self):
        '''Return the width of the texture (readonly)'''
        return self._width

    @property
    def height(self):
        '''Return the height of the texture (readonly)'''
        return self._height

    def flip_vertical(self):
        '''Flip tex_coords for vertical displaying'''
        a, b, c, d, e, f, g, h = self.tex_coords
        self.tex_coords = (g, h, e, f, c, d, a, b)

    def get_region(self, x, y, width, height):
        '''Return a part of the texture, from (x,y) with (width,height)
        dimensions'''
        return TextureRegion(x, y, width, height, self)

    def bind(self):
        '''Bind the texture to current opengl state'''
        glBindTexture(self.target, self.id)

    def enable(self):
        '''Do the appropriate glEnable()'''
        glEnable(self.target)

    def disable(self):
        '''Do the appropriate glDisable()'''
        glDisable(self.target)

    def _get_min_filter(self):
        return self._gl_min_filter
    def _set_min_filter(self, x):
        if x == self._gl_min_filter:
            return
        self.bind()
        glTexParameteri(self.target, GL_TEXTURE_MIN_FILTER, x)
        self._gl_min_filter = x
    min_filter = property(_get_min_filter, _set_min_filter,
                          doc='''Get/set the GL_TEXTURE_MIN_FILTER property''')

    def _get_mag_filter(self):
        return self._gl_mag_filter
    def _set_mag_filter(self, x):
        if x == self._gl_mag_filter:
            return
        self.bind()
        glTexParameteri(self.target, GL_TEXTURE_MAG_FILTER, x)
        self._gl_mag_filter = x
    mag_filter = property(_get_mag_filter, _set_mag_filter,
                          doc='''Get/set the GL_TEXTURE_MAG_FILTER property''')

    def _get_wrap(self):
        return self._gl_wrap
    def _set_wrap(self, wrap):
        if wrap == self._gl_wrap:
            return
        self.bind()
        glTexParameteri(self.target, GL_TEXTURE_WRAP_S, wrap)
        glTexParameteri(self.target, GL_TEXTURE_WRAP_T, wrap)
    wrap = property(_get_wrap, _set_wrap,
                    doc='''Get/set the GL_TEXTURE_WRAP_S,T property''')

    @staticmethod
    def create(width, height, format=GL_RGBA, rectangle=False, mipmap=False):
        '''Create a texture based on size.'''
        target = GL_TEXTURE_2D
        if rectangle:
            if _is_pow2(width) and _is_pow2(height):
                rectangle = False
            else:
                rectangle = False

                try:
                    if Texture._has_texture_nv is None:
                        Texture._has_texture_nv = glInitTextureRectangleNV()
                    if Texture._has_texture_nv:
                        target = GL_TEXTURE_RECTANGLE_NV
                        rectangle = True
                except Exception:
                    pass

                try:
                    if Texture._has_texture_arb is None:
                        Texture._has_texture_arb = glInitTextureRectangleARB()
                    if not rectangle and Texture._has_texture_arb:
                        target = GL_TEXTURE_RECTANGLE_ARB
                        rectangle = True
                except Exception:
                    pass

                if not rectangle:
                    pymt_logger.debug(
                        'Texture: Missing support for rectangular texture')
                else:
                    # Can't do mipmap with rectangle texture
                    mipmap = False

        if rectangle:
            texture_width = width
            texture_height = height
        else:
            texture_width = _nearest_pow2(width)
            texture_height = _nearest_pow2(height)

        texid = glGenTextures(1)
        texture = Texture(texture_width, texture_height, target, texid,
                          mipmap=mipmap)

        texture.bind()
        texture.wrap        = GL_CLAMP_TO_EDGE
        if mipmap:
            texture.min_filter  = GL_LINEAR_MIPMAP_LINEAR
            #texture.mag_filter  = GL_LINEAR_MIPMAP_LINEAR
            glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE)
        else:
            texture.min_filter  = GL_LINEAR
            texture.mag_filter  = GL_LINEAR

        if not Texture.is_gl_format_supported(format):
            format = Texture.convert_gl_format(format)

        data = (GLubyte * texture_width * texture_height *
                Texture.gl_format_size(format))()
        glTexImage2D(target, 0, format, texture_width, texture_height, 0,
                     format, GL_UNSIGNED_BYTE, data)

        if rectangle:
            texture.tex_coords = \
                (0., 0., width, 0., width, height, 0., height)

        glFlush()

        if texture_width == width and texture_height == height:
            return texture

        return texture.get_region(0, 0, width, height)

    @staticmethod
    def create_from_data(im, rectangle=True, mipmap=False):
        '''Create a texture from an ImageData class'''

        format = Texture.mode_to_gl_format(im.mode)

        texture = Texture.create(im.width, im.height,
                                 format, rectangle=rectangle,
                                 mipmap=mipmap)
        if texture is None:
            return None

        texture.blit_data(im)

        return texture

    def blit_data(self, im, pos=(0, 0)):
        '''Replace a whole texture with a image data'''
        self.blit_buffer(im.data, size=(im.width, im.height),
                         mode=im.mode, pos=pos)

    def blit_buffer(self, buffer, size=None, mode='RGB', format=None,
                    pos=(0, 0), buffertype=GL_UNSIGNED_BYTE):
        '''Blit a buffer into a texture.

        :Parameters:
            `buffer` : str
                Image data
            `size` : tuple, default to texture size
                Size of the image (width, height)
            `mode` : str, default to 'RGB'
                Image mode, can be one of RGB, RGBA, BGR, BGRA
            `format` : glconst, default to None
                if format is passed, it will be used instead of mode
            `pos` : tuple, default to (0, 0)
                Position to blit in the texture
            `buffertype` : glglconst, default to GL_UNSIGNED_BYTE
                Type of the data buffer
        '''
        if size is None:
            size = self.size
        if format is None:
            format = self.mode_to_gl_format(mode)
        target = self.target
        glBindTexture(target, self.id)
        glEnable(target)

        # activate 1 alignement, of window failed on updating weird size
        glPixelStorei(GL_UNPACK_ALIGNMENT, 1)

        # need conversion ?
        pdata, format = self._convert_buffer(buffer, format)

        # transfer the new part of texture
        glTexSubImage2D(target, 0, pos[0], pos[1],
                        size[0], size[1], format,
                        buffertype, pdata)

        glFlush()
        glDisable(target)

    @staticmethod
    def has_bgr():
        if not Texture._has_bgr_tested:
            pymt_logger.warning('Texture: BGR/BGRA format is not supported by'
                                'your graphic card')
            pymt_logger.warning('Texture: Software conversion will be done to'
                                'RGB/RGBA')
            Texture._has_bgr = hasGLExtension('GL_EXT_bgra')
            Texture._has_bgr_tested = True
        return Texture._has_bgr

    @staticmethod
    def is_gl_format_supported(format):
        if format in (GL_BGR, GL_BGRA):
            return not Texture.has_bgr()
        return True

    @staticmethod
    def convert_gl_format(format):
        if format == GL_BGR:
            return GL_RGB
        elif format == GL_BGRA:
            return GL_RGBA
        return format

    def _convert_buffer(self, data, format):
        # check if format is supported by user
        ret_format = format
        ret_buffer = data

        # BGR / BGRA conversion not supported by hardware ?
        if not Texture.is_gl_format_supported(format):
            if format == GL_BGR:
                ret_format = GL_RGB
                a = array('b', data)
                a[0::3], a[2::3] = a[2::3], a[0::3]
                ret_buffer = a.tostring()
            elif format == GL_BGRA:
                ret_format = GL_RGBA
                a = array('b', data)
                a[0::4], a[2::4] = a[2::4], a[0::4]
                ret_buffer = a.tostring()
            else:
                pymt_logger.critical('Texture: non implemented'
                                     '%s texture conversion' % str(format))
                raise Exception('Unimplemented texture conversion for %s' %
                                str(format))
        return ret_buffer, ret_format

    @property
    def size(self):
        return (self.width, self.height)

    @staticmethod
    def mode_to_gl_format(format):
        if format == 'RGBA':
            return GL_RGBA
        elif format == 'BGRA':
            return GL_BGRA
        elif format == 'BGR':
            return GL_BGR
        else:
            return GL_RGB

    @staticmethod
    def gl_format_size(format):
        if format in (GL_RGB, GL_BGR):
            return 3
        elif format in (GL_RGBA, GL_BGRA):
            return 4
        elif format in (GL_LUMINANCE, ):
            return 1
        raise Exception('Unsupported format size <%s>' % str(format))

    def __str__(self):
        return '<Texture size=(%d, %d)>' % self.size


class TextureRegion(Texture):
    '''Handle a region of a Texture class. Useful for non power-of-2
    texture handling.'''

    __slots__ = ('x', 'y', 'owner')

    def __init__(self, x, y, width, height, origin):
        super(TextureRegion, self).__init__(
            width, height, origin.target, origin.id)
        self.x = x
        self.y = y
        self.owner = origin

        # recalculate texture coordinate
        origin_u1 = origin.tex_coords[0]
        origin_v1 = origin.tex_coords[1]
        origin_u2 = origin.tex_coords[2]
        origin_v2 = origin.tex_coords[5]
        scale_u = origin_u2 - origin_u1
        scale_v = origin_v2 - origin_v1
        u1 = x / float(origin.width) * scale_u + origin_u1
        v1 = y / float(origin.height) * scale_v + origin_v1
        u2 = (x + width) / float(origin.width) * scale_u + origin_u1
        v2 = (y + height) / float(origin.height) * scale_v + origin_v1
        self.tex_coords = (u1, v1, u2, v1, u2, v2, u1, v2)

    def __del__(self):
        # don't use self of owner !
        pass

if 'PYMT_DOC' not in os.environ:
    from pymt.clock import getClock

    # install tick to release texture every 200ms
    getClock().schedule_interval(_texture_release, 0.2)


########NEW FILE########
__FILENAME__ = benchmark
'''
Benchmark for PyMT Framework
'''

benchmark_version = '1'

import gc
import pymt
import sys
import os
import OpenGL
import time
from OpenGL.GL import *
from random import randint, random
from pymt import *
from pymt.graphics import *
from time import clock, time, ctime

clockfn = time
if sys.platform == 'win32':
    clockfn = clock

try:
    window_size = getWindow().size
except:
    window_size = MTWindow().size

class bench_core_label:
    '''Core: label creation (10000 * 10 a-z)'''
    def __init__(self):
        labels = []
        for x in xrange(10000):
            label = map(lambda x: chr(randint(ord('a'), ord('z'))), xrange(10))
            labels.append(''.join(label))
        self.labels = labels
    def run(self):
        o = []
        for x in self.labels:
            o.append(Label(label=x))


class bench_widget_creation:
    '''Widget: creation (10000 MTWidget)'''
    def run(self):
        o = []
        for x in xrange(10000):
            o.append(MTWidget())

class bench_widget_dispatch:
    '''Widget: event dispatch (1000 on_update in 10*1000 MTWidget)'''
    def __init__(self):
        root = MTWidget()
        for x in xrange(10):
            parent = MTWidget()
            for y in xrange(1000):
                parent.add_widget(MTWidget())
            root.add_widget(parent)
        self.root = root
    def run(self):
        root = self.root
        for x in xrange(1000):
            root.dispatch_event('on_update')

class bench_graphx_line:
    '''Graphx: draw lines (5000 x/y) 1000 times'''
    def __init__(self):
        lines = []
        w, h = window_size
        for x in xrange(5000):
            lines.extend([random() * w, random() * h])
        self.lines = lines
    def run(self):
        lines = self.lines
        for x in xrange(1000):
            drawLine(lines)

class bench_graphics_line:
    '''Graphics: draw lines (5000 x/y) 1000 times'''
    def __init__(self):
        w, h = window_size
        self.canvas = Canvas()
        line = self.canvas.line()
        for x in xrange(5000):
            line.points += [random() * w, random() * h]
    def run(self):
        canvas = self.canvas
        for x in xrange(1000):
            canvas.draw()


class bench_graphx_rectangle:
    '''Graphx: draw rectangle (5000 rect) 1000 times'''
    def __init__(self):
        rects = []
        w, h = window_size
        for x in xrange(5000):
            rects.append(((random() * w, random() * h), (random() * w, random() * h)))
        self.rects = rects
    def run(self):
        rects = self.rects
        for x in xrange(1000):
            for pos, size in rects:
                drawRectangle(pos=pos, size=size)

class bench_graphics_rectangle:
    '''Graphics: draw rectangle (5000 rect) 1000 times'''
    def __init__(self):
        rects = []
        w, h = window_size
        canvas = Canvas()
        for x in xrange(5000):
            canvas.rectangle(random() * w, random() * h, random() * w, random() * h)
        self.canvas = canvas
    def run(self):
        canvas = self.canvas
        for x in xrange(1000):
            canvas.draw()

class bench_graphics_rectanglemesh:
    '''Graphics: draw rectangle in same mesh (5000 rect) 1000 times'''
    def __init__(self):
        rects = []
        w, h = window_size
        canvas = Canvas()
        mesh = canvas.graphicElement(format='vv', type='quads')
        vertex = []
        for x in xrange(50000):
            vertex.extend([random() * w, random() * h, random() * w, random() * h])
        mesh.data_v = vertex
        self.canvas = canvas
    def run(self):
        canvas = self.canvas
        for x in xrange(1000):
            canvas.draw()

class bench_graphx_roundedrectangle:
    '''Graphx: draw rounded rectangle (5000 rect) 1000 times'''
    def __init__(self):
        rects = []
        w, h = window_size
        for x in xrange(5000):
            rects.append(((random() * w, random() * h), (random() * w, random() * h)))
        self.rects = rects
    def run(self):
        rects = self.rects
        for x in xrange(1000):
            for pos, size in rects:
                drawRoundedRectangle(pos=pos, size=size)


class bench_graphics_roundedrectangle:
    '''Graphics: draw rounded rectangle (5000 rect) 1000 times'''
    def __init__(self):
        rects = []
        w, h = window_size
        canvas = Canvas()
        for x in xrange(5000):
            canvas.roundedRectangle(random() * w, random() * h, random() * w, random() * h)
        self.canvas = canvas
    def run(self):
        canvas = self.canvas
        for x in xrange(1000):
            canvas.draw()

class bench_graphx_paintline:
    '''Graphx: paint line (5000 x/y) 1000 times'''
    def __init__(self):
        lines = []
        w, h = window_size
        for x in xrange(500):
            lines.extend([random() * w, random() * h])
        self.lines = lines
        set_brush(os.path.join(pymt_data_dir, 'particle.png'))
    def run(self):
        lines = self.lines
        for x in xrange(100):
            paintLine(lines)

class bench_graphics_paintline:
    '''Graphics: paint lines (5000 x/y) 1000 times'''
    def __init__(self):
        w, h = window_size
        self.canvas = Canvas()
        texture = Image(os.path.join(pymt_data_dir, 'particle.png')).texture
        line = self.canvas.point(type='line_strip', texture=texture)
        for x in xrange(500):
            line.points += [random() * w, random() * h]
    def run(self):
        canvas = self.canvas
        for x in xrange(100):
            canvas.draw()


if __name__ == '__main__':
    report = []
    report_newline = True
    def log(s, newline=True):
        global report_newline
        if not report_newline:
            report[-1] = '%s %s' % (report[-1], s)
        else:
            report.append(s)
        if newline:
            print s
            report_newline = True
        else:
            print s,
            report_newline = False
        sys.stdout.flush()

    clock_total = 0
    benchs = locals().keys()
    benchs.sort()
    benchs = [locals()[x] for x in benchs if x.startswith('bench_')]

    log('')
    log('=' * 70)
    log('PyMT Benchmark v%s' % benchmark_version)
    log('=' * 70)
    log('')
    log('System informations')
    log('-------------------')

    log('OS platform     : %s' % sys.platform)
    log('Python EXE      : %s' % sys.executable)
    log('Python Version  : %s' % sys.version)
    log('Python API      : %s' % sys.api_version)
    try:
        log('PyMT Version    : %s' % pymt.__version__)
    except:
        log('PyMT Version    : unknown (too old)')
    log('Install path    : %s' % os.path.dirname(pymt.__file__))
    log('Install date    : %s' % ctime(os.path.getctime(pymt.__file__)))

    log('')
    log('OpenGL informations')
    log('-------------------')

    log('PyOpenGL Version: %s' % OpenGL.__version__)
    log('GL Vendor: %s' % glGetString(GL_VENDOR))
    log('GL Renderer: %s' % glGetString(GL_RENDERER))
    log('GL Version: %s' % glGetString(GL_VERSION))
    log('')

    log('Benchmark')
    log('---------')

    for x in benchs:
        # clean cache to prevent weird case
        for cat in Cache._categories:
            Cache.remove(cat)

        # force gc before next test
        gc.collect()

        log('%2d/%-2d %-60s' % (benchs.index(x)+1, len(benchs), x.__doc__), False)
        try:
            sys.stderr.write('.')
            test = x()
        except Exception, e:
            log('failed %s' % str(e))
            import traceback
            traceback.print_exc()
            continue

        clock_start = clockfn()

        try:
            sys.stderr.write('.')
            test.run()
            clock_end = clockfn() - clock_start
            log('%.6f' % clock_end)
        except Exception, e:
            log('failed %s' % str(e))
            continue

        clock_total += clock_end

    log('')
    log('Result: %.6f' % clock_total)
    log('')

try:
    getWindow().close()
except:
    pass

try:
    reply = raw_input('Do you want to send benchmark to paste.pocoo.org (Y/n) : ')
except EOFError:
    sys.exit(0)

if reply.lower().strip() in ('', 'y'):
    print 'Please wait while sending the benchmark...'

    from xmlrpclib import ServerProxy
    s = ServerProxy('http://paste.pocoo.org/xmlrpc/')
    r = s.pastes.newPaste('text', '\n'.join(report))

    print
    print
    print 'REPORT posted at http://paste.pocoo.org/show/%s/' % r
    print
    print
else:
    print 'No benchmark posted.'

########NEW FILE########
__FILENAME__ = dejitter
from pymt import *


class JitterSensor(MTWidget):
    """Explanation:
    This widget helps you to find a good jitter_distance setting for your
    specific multi-touch setup. Just follow the instructions. The amount of
    your BLOB's jitter will be measured and a fitting configuration value will be
    set in your configuration file.
    """
    def __init__(self, **kwargs):
        super(JitterSensor, self).__init__(**kwargs)
        self.margin = 5
        # The touch we want to observe
        self.touch = None
        # Here we note down all of the touches positions
        self.touchs_spositions = []
        # We need to give the user a second to get his finger into a still pos.
        # Indicate whether we're ready. We will just start with a short delay.
        self._ready = False
        # Indicate whether we finished calibration. Don't take any more touches
        # into account when done.
        self._done = False
        # When the touch is stable, get the original position
        self.original_spos = None
        self.switch_label()
        # Being lazy here. Just reuse the docstring :-)
        explanation = MTLabel(pos=(10, 10), anchor_x='left', anchor_y='top',
                              autosize=True, label=self.__doc__)
        self.add_widget(explanation)

    def switch_label(self):
        try:
            self.remove_widget(self.label)
        except AttributeError:
            # No label yet, no problem.
            pass
        if not self._ready:
            label = 'Hold down ONE finger in the red\n' + \
                    'rectangle and do not move or lift it.'
        if self.touch is not None and not self._ready:
            label = 'Now hold that finger still!'
        if self._done:
            label = 'You may now lift your finger.'
        x, y = self.pos
        self.label = MTLabel(pos=(x+self.width+5, y+self.height/2), label=label)
        self.add_widget(self.label)

    def ready(self, dt):
        # Timeout passed. We're ready!
        self._ready = True
        self.original_spos = self.touch.spos
        getClock().schedule_once(self.done, 15)

    def done(self, dt):
        self._done = True
        self.switch_label()

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            self.touch = touch
            # Wait two seconds before measuring
            getClock().schedule_once(self.ready, 0.5)
            self.switch_label()

    def on_touch_move(self, touch):
        if self.collide_point(*touch.pos) and touch is self.touch and self._ready:
            if self._done:
                return
            self.touchs_spositions.append(touch.spos)

    def on_touch_up(self, touch):
        if touch is self.touch:
            getClock().unschedule(self.ready)
            getClock().unschedule(self.done)
            maxmean = self.calculate_derivation()
            if maxmean:
                pymt_config.set('pymt', 'jitter_distance', maxmean)
                pymt_config.write()
                content = ('%f is a good jitter_distance value for you. It was '
                           'changed in your config file for you.') % (maxmean,)
            else:
                content = 'You got no BLOB jitter at all! Lucky you. :-)'
            if self._done:
                popup = MTModalPopup(title='Calibration Result',
                                     content=content, size=(200, 200))
                w.add_widget(popup)
            self.touch = None
            self.touchs_spositions = []
            self._ready = False
            self._done = False
            self.switch_label()

    def taxicab_distance(self, p, q):
        # Get the taxicab/manhattan/citiblock distance for efficiency reasons
        return abs(p[0]-q[0]) + abs(p[1]-q[1])

    def calculate_derivation(self):
        distances = []
        for spos in self.touchs_spositions:
            dist = self.taxicab_distance(self.original_spos, spos)
            distances.append(dist)
        # Get the x largest values and take the mean from those
        distances.sort()
        max_vals = distances[-4:]
        if not max_vals:
            # There has been no jitter at all! Prevent ZeroDivisionError
            maxmean = 0
        else:
            maxmean = sum(max_vals) / len(max_vals)
        return maxmean

    def draw(self):
        if self._done:
            set_color(0, 0, 0.8)
        elif self._ready:
            set_color(0, 0.8, 0)
        else:
            set_color(0.8, 0, 0)
        drawRectangle(self.pos, self.size)
        set_color(1, 1, 1)
        drawRectangle((self.x+self.margin, self.y+self.margin),
                      (self.width - 2 * self.margin, self.height - 2 * self.margin))


if __name__ == '__main__':
    size = (200, ) * 2
    w = getWindow()
    x = (w.width - size[0])/2
    y = (w.height - size[1])/2
    runTouchApp(JitterSensor(pos=(x,y), size=size))

########NEW FILE########
__FILENAME__ = doubletap
#!/usr/bin/env python

from pymt import *


class DoubleTapIndicator(MTWidget):
    def __init__(self, **kwargs):
        self.red = True
        w = getWindow()
        self.diameter = max(min(*w.size)/8., 20)
        kwargs["size"] = (self.diameter, ) * 2
        super(DoubleTapIndicator, self).__init__(**kwargs)

    def on_touch_down(self, touch):
        if touch.is_double_tap and self.collide_point(*touch.pos):
            self.red = not self.red

    def draw(self):
        if self.red:
            set_color(1, 0, 0)
        else:
            set_color(0, 0, 1)
        drawRectangle(self.pos, self.size)


class DoubleTapSettingsAdjuster(MTWidget):
    """Explanation:
    This tool can be used to adjust the doubletap settings to your liking.
    The distance that the second touch (for a doubletap) might travel (before
    both touches are considered as no doubletap) can be adjusted.
    Additionally, you can adjust the maximum time that might pass between two
    touches that you want to be considered a doubletap.
    """
    def __init__(self, **kwargs):
        super(DoubleTapSettingsAdjuster, self).__init__(**kwargs)
        self.module = m = pymt_postproc_modules["doubletap"]
        self.orig_distance = m.double_tap_distance
        self.orig_time = m.double_tap_time
        self.distance_slider = MTSlider(min=0, max=1000, value=self.orig_distance * 1000,
                                        value_show=True, orientation="horizontal")
        self.time_slider = MTSlider(min=0, max=2000, value=self.orig_time * 1000,
                                    value_show=True, orientation="horizontal")
        self.distance_slider.connect("on_value_change", self.distance_callback)
        self.time_slider.connect("on_value_change", self.time_callback)
        distlabel = MTLabel(anchor_x='left', anchor_y='bottom',
                            autosize=True, label="Maximum Distance:")
        timelabel = MTLabel(anchor_x='left', anchor_y='bottom',
                            autosize=True, label="Maximum Time:")
        touchlabel = MTLabel(anchor_x='center', anchor_y='center',
                             autosize=True, label="Test settings:")
        explanation = MTLabel(pos=(10, 10), anchor_x='left', anchor_y='top',
                              autosize=True, label=self.__doc__)
        dti = DoubleTapIndicator()
        save = MTButton(label="Save current settings", autoheight=True)
        save.connect("on_release", self.save_settings)
        reset = MTButton(label="Reset to original settings", autoheight=True)
        reset.connect("on_release", self.reset_settings)
        save.width = reset.width = dti.width = self.distance_slider.width

        self.box = MTBoxLayout(orientation="vertical", spacing=20)
        self.box.add_widget(touchlabel)
        self.box.add_widget(dti)
        self.box.add_widget(distlabel)
        self.box.add_widget(self.distance_slider)
        self.box.add_widget(timelabel)
        self.box.add_widget(self.time_slider)
        self.box.add_widget(save)
        self.box.add_widget(reset)
        w = getWindow()
        x, y = w.center
        x -= self.box.width / 2
        y -= self.box.height / 2
        self.box.pos = (x, y)
        self.add_widget(self.box)
        self.add_widget(explanation)

    def distance_callback(self, v):
        self.module.double_tap_distance = v / 1000.0
        self.module.touches = {}

    def time_callback(self, v):
        self.module.double_tap_time = v / 1000.0
        self.module.touches = {}

    def set_values(self, time, dist):
        pymt_config.set('pymt', 'double_tap_time', int(time * 1000))
        pymt_config.set('pymt', 'double_tap_distance', int(dist * 1000))
        pymt_config.write()

    def save_settings(self, touch):
        self.set_values(self.module.double_tap_time, self.module.double_tap_distance)

    def reset_settings(self, touch):
        self.set_values(self.orig_time, self.orig_distance)


if __name__ == "__main__":
    dtsa = DoubleTapSettingsAdjuster()
    runTouchApp(dtsa)

########NEW FILE########
__FILENAME__ = config
#!/usr/bin/env python

from __future__ import with_statement
from Tkinter import *
import tkMessageBox
import sys
import os
os.environ['PYMT_SHADOW_WINDOW'] = '0'
from pymt import pymt_modules, pymt_config, pymt_config_fn, curry, TouchFactory

class AutoConfig(dict):
    def __getitem__(self, name):
        if not self.__contains__(name):
            section, id = name.split('.', 1)
            value = pymt_config.get(section, id)
            var = StringVar()
            var.set(value)
            self.__setitem__(name, var)
        return super(AutoConfig, self).__getitem__(name)

master = Tk()
master.title('PyMT Configuration')
c = AutoConfig()
c_tuio_host = StringVar()
c_tuio_port = StringVar()
c_modules = StringVar()
c_screen = StringVar()
c_input = StringVar()
c_input_option = StringVar()
c_input_provider = StringVar()
c_input_devicename = StringVar()

try:
    provider = pymt_config.get('input', 'default')
    name, args = provider.split(',', 1)
    host, port = args.split(':', 1)
    c_tuio_host.set(host)
    c_tuio_port.set(port)
except:
    c_tuio_host.set('0.0.0.0')
    c_tuio_port.set('3333')

c_screen.set('%dx%d' % (pymt_config.getint('graphics', 'width'),
                        pymt_config.getint('graphics', 'height')))

# Get infos
opt_input = TouchFactory.list()
opt_fbo = ('hardware', 'software')
opt_loglevel = ('debug', 'info', 'warning', 'error')
opt_screen = (
    '320x240',
    '640x480',
    '800x600',
    '1024x768',
    '1280x720',
    '1280x1024',
    '1280x1080',
    '1400x1050',
    '1440x900',
    '1440x1080',
    '1600x1200',
    '1680x1050',
    '1920x1080',
    '1920x1200',
    '2560x1600',
)

# ================================================================
# Config functions
# ================================================================

def configuration_debug():
    for key in c:
        print key, '=', c.get(key).get()

def configuration_save():
    for key in c:
        section, name = key.split('.', 1)
        value = c.get(key).get()
        if name in ('double_tap_time', 'double_tap_distance'):
            value = int(float(value))
        pymt_config.set(section, name, value)

    # modules
    if pymt_config.has_section('modules'):
        pymt_config.remove_section('modules')
    pymt_config.add_section('modules')
    modlist = eval(c_modules.get())
    for index in map(int, e_modules_list.curselection()):
        pymt_config.set('modules', modlist[index], '')

    # screen
    width, height = c_screen.get().split('x')
    pymt_config.set('graphics', 'width', width)
    pymt_config.set('graphics', 'height', height)

    # input
    if pymt_config.has_section('input'):
        pymt_config.remove_section('input')
    pymt_config.add_section('input')
    inputlist = eval(c_input.get())
    for index in map(int, e_input_list.curselection()):
        device_id, option = inputlist[index].split('=', 1)
        pymt_config.set('input', device_id, option)

    try:
        pymt_config.write()
        tkMessageBox.showinfo('PyMT', 'Configuration saved !')
    except Exception, e:
        tkMessageBox.showwarning('PyMT', 'Unable to save default configuration : ' + str(e))


# ================================================================
# PyMT
# ================================================================

g_pymt = LabelFrame(master, text='General', padx=5, pady=5)
g_pymt.grid(row=0, column=0, sticky=W+E+N+S)

Label(g_pymt, text='Show FPS').grid(row=0)
Label(g_pymt, text='Show event stats').grid(row=1)
Label(g_pymt, text='Log level').grid(row=2)
Label(g_pymt, text='Double tap time').grid(row=3)
Label(g_pymt, text='Double tap distance').grid(row=4)
Label(g_pymt, text='Retain Time').grid(row=5)
Label(g_pymt, text='Retain Distance').grid(row=6)

e_pymt_fps = Checkbutton(g_pymt,
        variable=c['pymt.show_fps'], onvalue='1', offvalue='0')
e_pymt_eventstats = Checkbutton(g_pymt,
        variable=c['pymt.show_eventstats'], onvalue='1', offvalue='0')
e_pymt_loglevel = OptionMenu(g_pymt, c['pymt.log_level'], *opt_loglevel)
e_pymt_doubletaptime = Scale(g_pymt, from_=0, to=1000, orient=HORIZONTAL,
        variable=c['pymt.double_tap_time'])
e_pymt_doubletapdistance = Scale(g_pymt, from_=0, to=300, orient=HORIZONTAL,
        variable=c['pymt.double_tap_distance'])
e_pymt_retaintime = Entry(g_pymt, textvariable=c['pymt.retain_time'])
e_pymt_retaindistance = Entry(g_pymt, textvariable=c['pymt.retain_distance'])

e_pymt_fps.grid(row=0, column=1)
e_pymt_eventstats.grid(row=1, column=1)
e_pymt_loglevel.grid(row=2, column=1)
e_pymt_doubletaptime.grid(row=3, column=1, sticky=W+E+N+S)
e_pymt_doubletapdistance.grid(row=4, column=1, sticky=W+E+N+S)
e_pymt_retaintime.grid(row=5,column=1)
e_pymt_retaindistance.grid(row=6,column=1)

# ================================================================
# Graphics
# ================================================================

g_graphics = LabelFrame(master, text='Graphics', padx=5, pady=5)
g_graphics.grid(row=0, column=1, sticky=W+E+N+S)

Label(g_graphics, text='Fullscreen').grid(row=0)
Label(g_graphics, text='Screen').grid(row=1)
Label(g_graphics, text='Display').grid(row=2)
Label(g_graphics, text='Line smooth').grid(row=3)
Label(g_graphics, text='Vertical sync').grid(row=4)
Label(g_graphics, text='FBO').grid(row=5)
Label(g_graphics, text='Multisamples').grid(row=6)
Label(g_graphics, text='Show Cursor').grid(row=7)

e_graphics_fullscreen = Checkbutton(g_graphics,
        variable=c['graphics.fullscreen'], onvalue='1', offvalue='0')
e_graphics_screen = OptionMenu(g_graphics, c_screen, *opt_screen)
e_graphics_display = Spinbox(g_graphics, from_=-1, to=100, textvariable=c['graphics.display'])
e_graphics_line_smooth = Checkbutton(g_graphics,
        variable=c['graphics.line_smooth'], onvalue='1', offvalue='0')
e_graphics_vertical_sync = Checkbutton(g_graphics,
        variable=c['graphics.vsync'], onvalue='1', offvalue='0')
e_graphics_fbo = OptionMenu(g_graphics, c['graphics.fbo'], *opt_fbo)
e_graphics_multisamples = Entry(g_graphics, textvariable=c['graphics.multisamples'])
e_graphics_showcursor = Checkbutton(g_graphics,
        variable=c['graphics.show_cursor'], onvalue='1', offvalue='0')

e_graphics_fullscreen.grid(row=0, column=1)
e_graphics_screen.grid(row=1, column=1)
e_graphics_display.grid(row=2, column=1)
e_graphics_line_smooth.grid(row=3, column=1)
e_graphics_vertical_sync.grid(row=4, column=1)
e_graphics_fbo.grid(row=5, column=1)
e_graphics_multisamples.grid(row=6, column=1)
e_graphics_showcursor.grid(row=7, column=1)


# ================================================================
# Modules
# ================================================================

g_modules = LabelFrame(master, text='General', padx=5, pady=5)
g_modules.grid(row=1, column=1, sticky=W+E+N+S)

Label(g_modules, text='Modules').grid(row=0)

e_modules_list = Listbox(g_modules, selectmode=MULTIPLE,
    exportselection=0, listvariable=c_modules)

e_modules_list.grid(row=0, column=1)

# ================================================================
# Inputs
# ================================================================

g_input = LabelFrame(master, text='Input', padx=5, pady=5)
g_input.grid(row=1, column=0, sticky=W+E+N+S)

e_input_list = Listbox(g_input, selectmode=MULTIPLE,
    exportselection=0, listvariable=c_input)
e_input_list.grid(row=0, column=1)

Label(g_input, text='Device Name').grid(row=1)
Label(g_input, text='Provider').grid(row=2)
Label(g_input, text='Option').grid(row=3)

e_input_devicename = Entry(g_input, textvariable=c_input_devicename)
e_input_devicename.grid(row=1, column=1)

e_input_available = OptionMenu(g_input, c_input_provider, *opt_input)
e_input_available.grid(row=2, column=1)

e_input_option = Entry(g_input, textvariable=c_input_option)
e_input_option.grid(row=3, column=1)

def _input_add(*largs):
    device_id = c_input_devicename.get()
    if device_id == '':
        tkMessageBox.showerror('PyMT', 'No device name setted')
        return
    provider_name = c_input_provider.get()
    if provider_name == '':
        tkMessageBox.showerror('PyMT', 'No provider selected')
        return
    options = c_input_option.get()
    t = '%s=%s,%s' % (str(device_id), str(provider_name), str(options))
    e_input_list.insert(END, t)
    e_input_list.selection_set(eval(c_input.get()).index(t))

    c_input_devicename.set('')
    c_input_option.set('')

e_input_add = Button(g_input, text='Add input', command=_input_add)
e_input_add.grid(row=4, column=1)


# ================================================================
# Buttons
# ================================================================

btn_save = Button(master, text='Save configuration', command=configuration_save)
btn_save.grid(row=2, column=0, sticky=W+E+N+S)
btn_quit = Button(master, text='Exit', command=curry(sys.exit, 0))
btn_quit.grid(row=2, column=1, sticky=W+E+N+S)

# ================================================================
# Fill list
# ================================================================
for mod in pymt_modules.list():
    e_modules_list.insert(END, mod)
for opt in pymt_config.options('modules'):
    index = eval(c_modules.get()).index(opt)
    e_modules_list.selection_set(index)
for device_id in pymt_config.options('input'):
    line = pymt_config.get('input', device_id)
    t = '%s=%s' % (str(device_id), str(line))
    e_input_list.insert(END, t)
    e_input_list.selection_set(eval(c_input.get()).index(t))

# ================================================================
# Load configuration
# ================================================================

try:
    mainloop()
finally:
    pass

########NEW FILE########
__FILENAME__ = demo
import os
from pymt import *

particle_fn = os.path.join(pymt_data_dir, 'particle.png')

class TouchTracer(MTWidget):
    def __init__(self, **kwargs):
        super(TouchTracer, self).__init__(**kwargs)

    def on_touch_down(self, touch):
        color = get_random_color()
        touch.userdata['touchtracer.color'] = color
        touch.userdata['touchtracer.pos'] = list(touch.pos)

    def on_touch_move(self, touch):
        touch.userdata['touchtracer.pos'] += list(touch.pos)

    def draw(self):
        k      = {'anchor_y': 'bottom', 'font_size': 10}
        margin = 4
        set_brush(particle_fn)
        points = 0
        for touch in getCurrentTouches():
            set_color(*touch.userdata['touchtracer.color'])
            paintLine(touch.userdata['touchtracer.pos'], width=5)
            label = 'ID: %s\npos: (%d,%d)\nDevice: %s\nDouble Tap: %s' % (
                    touch.id, touch.pos[0], touch.pos[1],
                    touch.device, str(touch.is_double_tap))

            # draw a little box with margin
            obj = getLabel(label=label, **k)
            pos = Vector(touch.pos) + Vector(0, 10)
            lpos = pos - Vector(obj.width / 2. + margin, margin)
            lsize = Vector(obj.size) + Vector(margin * 2, margin * 2)
            set_color(.2, .2, .4)
            drawRoundedRectangle(pos=(int(lpos.x), int(lpos.y)), size=lsize)
            drawLabel(label=label, pos=pos, **k)
            points += len(touch.userdata['touchtracer.pos'])

        drawLabel(label='%d' % points, color=(.5,.5,.5), pos=(5, 5),
                  center=False)


if __name__ == '__main__':
    runTouchApp(TouchTracer())

########NEW FILE########
__FILENAME__ = designer
from designerapp.designer import run
if __name__ == '__main__':
    run()

########NEW FILE########
__FILENAME__ = designer
import sys
import os
import traceback
import os
from PyQt4 import QtCore, QtGui, QtOpenGL
from OpenGL import GL
from syntaxhighlighter import Highlighter
from cStringIO import StringIO
import logging.handlers

# Configure pymt BEFORE instance
os.environ['PYMT_SHADOW_WINDOW'] = 'False'
sys._pymt_logging_handler = logging.handlers.MemoryHandler(0)
import pymt
from pymt import pymt_logger

# don't import qtmt before pymt, otherwise, initialization will fail.
from qtmtwindow import *

class LoggerHandler:
    __slots__ = ('output', 'colors')

    def __init__(self, output):
        self.output = output
        self.colors = {
            'WARNING': '#aaaa00',
            'INFO': '#00cc00',
            'DEBUG': '#0000cc',
            'CRITICAL': '#cc0000',
            'ERROR': '#cc0000'
        }

    def format_message(self, message):
        for pattern, replace in (
            ("\n", '<br/>'),
            ("\t", '&nbsp;&nbsp;'),
            ('<', '&lt;'),
            ('>', '&gt;')):
            message = message.replace(pattern, replace)
        return message

    def handle(self, record):
        color = '#000000'
        if record.levelname in self.colors:
            color = self.colors[record.levelname]
        message = self.format_message(record.getMessage())
        html = '[<span style="color: %s">%s</span>] %s<br/><br/>' % \
            (color, record.levelname, message)
        self.appendHtml(html)

    def appendText(self, text):
        self.appendHtml(self.format_message(text) + '<br/>')

    def appendHtml(self, html):
        # ensure we are at the end
        cur = self.output.textCursor()
        cur.movePosition(cur.End)
        self.output.setTextCursor(cur)
        # insert HTML
        self.output.insertHtml(html)
        # scroll if necessary
        self.output.ensureCursorVisible()

class MainWindow(QtGui.QMainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        self.setupFileMenu()
        self.setupEditor()
        self.setupToolbar()
        self.setupMTWindow()
        self.central_widget = QtGui.QWidget()
        self.layout = QtGui.QHBoxLayout()
        self.layout.addWidget(self.editor)

        self.vlayout = QtGui.QVBoxLayout()
        self.vlayout.addWidget(self.toolbar)
        self.vlayout.addWidget(self.glWidget)
        self.vlayout.addWidget(self.console)
        self.layout.addLayout(self.vlayout)

        self.central_widget.setLayout(self.layout)
        self.setCentralWidget(self.central_widget)
        self.setWindowTitle('PyMT Designer')

        self._update_toolbar_status()

        # install logger
        self.logger = LoggerHandler(output=self.console)
        sys._pymt_logging_handler.setTarget(self.logger)

    def setupToolbar(self):
        self.toolbar = QtGui.QToolBar()
        pixrun = QtGui.QPixmap('icons/player_play.png')
        pixstop = QtGui.QPixmap('icons/player_stop.png')
        pixpause = QtGui.QPixmap('icons/player_pause.png')
        self.act_run = self.toolbar.addAction(QtGui.QIcon(pixrun), 'Run', self.run)
        self.act_pause = self.toolbar.addAction(QtGui.QIcon(pixpause), 'Pause', self.pause)
        self.act_stop = self.toolbar.addAction(QtGui.QIcon(pixstop), 'Stop', self.stop)

    def setupFileMenu(self):
        fileMenu = QtGui.QMenu("&File", self)
        pymtMenu = QtGui.QMenu("&PyMT",self)

        self.menuBar().addMenu(fileMenu)
        self.menuBar().addMenu(pymtMenu)

        fileMenu.addAction("&New...", self.newFile, "Ctrl+N")
        fileMenu.addAction("&Open...", self.openFile, "Ctrl+O")
        fileMenu.addAction("&Save", self.saveFile, "Ctrl+S")
        fileMenu.addAction("Save As", self.saveFileAs, "Ctrl+Alt+S")
        fileMenu.addAction("E&xit", QtGui.qApp.quit, "Ctrl+Q")

        pymtMenu.addAction("&Run", self.run, "Ctrl+R")


    def setupMTWindow(self):
        pymt.pymt_config.set('modules', 'touchring', '')
        self.glWidget = QTMTWindow()


    def setupEditor(self):
        font = QtGui.QFont()
        font.setFamily('Lucida')
        font.setFixedPitch(True)
        font.setPointSize(10)

        self.editor = QtGui.QTextEdit()
        self.console = QtGui.QTextEdit()
        self.console.readOnly = True
        self.console.setFont(font)
        self.editor.setFont(font)
        self.editor.setMinimumSize(500,600)
        self.highlighter = Highlighter(self.editor.document())
        self.openFile(os.path.join(os.path.dirname(__file__), 'test.py'))


    def newFile(self):
        self.editor.clear()
        self.current_file = None

    def openFile(self, path=None):
        if not path:
            path = QtGui.QFileDialog.getOpenFileName(self, "Open File",
                    '', "PyMT Files (*.py *.xml)")

        if path:
            inFile = QtCore.QFile(path)
            if inFile.open(QtCore.QFile.ReadOnly | QtCore.QFile.Text):
                text = inFile.readAll()
                text = str(text)
                self.editor.setPlainText(text)

        self.current_file = path
        self.setWindowTitle("PyMT Designer | "+path)



    def saveFile(self):
        self.saveFileAs(self.current_file)

    def saveFileAs(self, path=None):
        if not path:
            path = QtGui.QFileDialog.getSaveFileName(self, "Save File",
                    '', "PyMT Files (*.py *.xml)")

        outFile = QtCore.QFile(path)
        if outFile.open(QtCore.QFile.WriteOnly | QtCore.QFile.Text):
            outFile.write(str(self.editor.toPlainText()))
        self.current_file = path



    def pause(self):
        if self.glWidget.is_paused:
            self.glWidget.play()
        else:
            self.glWidget.pause()
        self._update_toolbar_status()

    def stop(self):
        self.glWidget.stop()
        self._update_toolbar_status()

    def run(self):
        pymt.stopTouchApp()
        buff1 = StringIO()
        buff2 = StringIO()
        stdout = sys.stdout
        stderr = sys.stderr
        sys.stdout = buff1
        sys.stderr = buff2
        self.execute_pymt_code()
        self.logger.appendText(buff1.getvalue())
        self.logger.appendText(buff2.getvalue())
        sys.stdout = stdout
        sys.stderr = stderr
        self._update_toolbar_status()

    def execute_pymt_code(self):
        oldRunApp = pymt.runTouchApp
        def designerRunTouchApp(w):
            oldRunApp(w, slave=True)
        pymt.runTouchApp = designerRunTouchApp

        try:
            self.glWidget.create_new_pymt_window()
            d = {}
            exec str(self.editor.toPlainText()) in d
            #pymt.stopTouchApp()
        except Exception as e:
            #pymt.pymt_logger.exception("Error Running PyMT Code:")
            traceback.print_exc()
        pymt.runTouchApp = oldRunApp

    def _update_toolbar_status(self):
        self.act_run.setVisible(not self.glWidget.is_running or
                                self.glWidget.is_paused)
        self.act_stop.setEnabled(self.glWidget.is_running)
        self.act_pause.setVisible(not self.act_run.isVisible())

def run():
    import sys

    app = QtGui.QApplication(sys.argv)
    window = MainWindow()
    window.resize(640, 512)
    window.show()
    sys.exit(app.exec_())

if __name__ == '__main__':
    run()

########NEW FILE########
__FILENAME__ = qtmtwindow
import sys
import math
from OpenGL.GL import *
from PyQt4 import QtOpenGL, QtGui, QtCore
from PyQt4.Qt import Qt
from pymt import BaseWindow, getEventLoop


class MTDesignerWindow(BaseWindow):
    pass

class QTMTWindow(QtOpenGL.QGLWidget):

    def __init__(self, parent=None):
        super(QTMTWindow, self).__init__(parent)
        self.runing_pymt = False
        self.pymt_window = False
        self.object = 0
        self.bg_color = QtGui.QColor(.5, .5, .5, 1.0)
        self.startTimer(40)
        self.is_running = False
        self.want_leave = False
        self.is_paused = False

    def timerEvent(self, event):
        self.update()

    def minimumSizeHint(self):
        return QtCore.QSize(640, 50)

    def sizeHint(self):
        return QtCore.QSize(800, 600)

    def paintGL(self):
        pymt_evloop = getEventLoop()
        if pymt_evloop and self.pymt_window:
            # leaving asked ?
            if self.want_leave:
                self.close_pymt_window()
                return

            # do idle only if it's not in paused
            if not self.is_paused:
                pymt_evloop.idle()
        else:
            # force bit to running = False,
            # application can leave by itself
            self.want_leave = False
            self.is_running = False
            glClearColor(0,1,0,1)
            glClear(GL_COLOR_BUFFER_BIT)

    def resizeGL(self, width, height):
        if self.pymt_window:
            self.pymt_window.size = (width, height)

    def read_mouse_properties(self, event):
        pos = event.pos()
        x,y = pos.x(), pos.y()
        button = 'left'
        if event.button == Qt.RightButton:
            button = 'right'

        self.modifiers = []
        kmods = event.modifiers()
        if kmods & Qt.ShiftModifier:
            self.modifiers.append('shift')
        if kmods & Qt.ControlModifier:
            self.modifiers.append('ctrl')
        if kmods & Qt.AltModifier:
            self.modifiers.append('alt')
        if kmods & Qt.MetaModifier:
            self.modifiers.append('meta')

        return x, y, button, self.modifiers


    def mousePressEvent(self, event):
        if self.pymt_window:
            x,y,b,m = self.read_mouse_properties(event)
            self.pymt_window.dispatch_event('on_mouse_down', x,y,b,m)


    def mouseMoveEvent(self, event):
        if self.pymt_window:
            x,y,b,m = self.read_mouse_properties(event)
            self.pymt_window.dispatch_event('on_mouse_move', x,y,m)

    def mouseReleaseEvent(self, event):
        if self.pymt_window:
            x,y,b,m = self.read_mouse_properties(event)
            self.pymt_window.dispatch_event('on_mouse_up', x,y,b,m)

    def reset(self):
        self.resizeGL(self.width(), self.height())
        self.is_running = True
        self.is_paused = False
        self.want_leave = False

    def play(self):
        self.is_paused = False

    def stop(self):
        self.want_leave = True
        self.is_running = False

    def pause(self):
        self.is_paused = True

    def close_pymt_window(self):
        if self.pymt_window:
            self.pymt_window.close()
            self.pymt_window = None

    def create_new_pymt_window(self):
        self.close_pymt_window()
        self.pymt_window = MTDesignerWindow()
        self.reset()


########NEW FILE########
__FILENAME__ = syntaxhighlighter
#!/usr/bin/env python

"""PyQt4 port of the richtext/syntaxhighlighter example from Qt v4.x"""

from PyQt4 import QtCore, QtGui


class Highlighter(QtGui.QSyntaxHighlighter):
    def __init__(self, parent=None):
        super(Highlighter, self).__init__(parent)

        keywordFormat = QtGui.QTextCharFormat()
        keywordFormat.setForeground(QtCore.Qt.darkRed)
        keywordFormat.setFontWeight(QtGui.QFont.Bold)

        keywords = ['class', 'def', 'for', 'in', 'try', 'except',
                    'and', 'del', 'is', 'raise', 'assert', 'elif',
                    'global', 'lambda', 'return', 'break', 'else',
                    'not', 'try', 'from', 'if', 'or', 'while',
                    'continue', 'exec', 'import', 'pass', 'yield',
                    'finally', 'print', 'eval']

        keywordPatterns = map(lambda x: "\\b"+x+"\\b", keywords)

        self.highlightingRules = [(QtCore.QRegExp(pattern), keywordFormat) for pattern in keywordPatterns]

        singleLineCommentFormat = QtGui.QTextCharFormat()
        singleLineCommentFormat.setForeground(QtCore.Qt.gray)
        self.highlightingRules.append((QtCore.QRegExp("#[^\n]*"), singleLineCommentFormat))

        quotationFormat = QtGui.QTextCharFormat()
        quotationFormat.setForeground(QtCore.Qt.red)
        self.highlightingRules.append((QtCore.QRegExp("\".*\""), quotationFormat))
        self.highlightingRules.append((QtCore.QRegExp("\'.*\'"), quotationFormat))


        functionFormat = QtGui.QTextCharFormat()
        #functionFormat.setFontWeight(QtGui.QFont.Bold)
        functionFormat.setForeground(QtCore.Qt.blue)
        self.highlightingRules.append((QtCore.QRegExp("\\b[A-Za-z0-9_]+(?=\\()"),
                functionFormat))


        classFormat = QtGui.QTextCharFormat()
        classFormat.setForeground(QtCore.Qt.magenta)
        classFormat.setFontWeight(QtGui.QFont.Bold)
        self.highlightingRules.append((QtCore.QRegExp("\\bMT[A-Za-z]+\\b"),classFormat))





        self.commentStartExpression = QtCore.QRegExp("\"\"\"")
        self.commentEndExpression = QtCore.QRegExp("\"\"\"")
        self.multiLineCommentFormat = QtGui.QTextCharFormat()
        self.multiLineCommentFormat.setForeground(QtCore.Qt.darkGreen)


    def highlightBlock(self, text):
        for pattern, format in self.highlightingRules:
            expression = QtCore.QRegExp(pattern)
            index = expression.indexIn(text)
            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

        self.setCurrentBlockState(0)

        startIndex = 0
        if self.previousBlockState() != 1:
            startIndex = self.commentStartExpression.indexIn(text)

        while startIndex >= 0:
            endIndex = self.commentEndExpression.indexIn(text, startIndex)

            if endIndex == -1:
                self.setCurrentBlockState(1)
                commentLength = len(text) - startIndex
            else:
                commentLength = endIndex - startIndex + self.commentEndExpression.matchedLength()

            self.setFormat(startIndex, commentLength,
                    self.multiLineCommentFormat)
            startIndex = self.commentStartExpression.indexIn(text,
                    startIndex + commentLength);



########NEW FILE########
__FILENAME__ = test
from pymt import *

#some basic widgets
slider = MTSlider(orientation="horizontal")
button = MTButton(label="Reset")
label  = MTLabel(label="Label Text", font_size=20)

#some event handling using connect
slider.connect("on_value_change", label, "label")

#some event handling using custom event handler function
def reset(*args):
   label.label = "Label Text"
button.push_handlers(on_press=reset)

#create a root wodget and add our example widgets to it
root = MTBoxLayout(orientation="vertical")
root.add_widgets(slider, button, label)

#run the application
runTouchApp(root)

########NEW FILE########
__FILENAME__ = dump
'''
Dump tool to have a possibility to log all what we want from user
If they have any troubles with debugging.

Missing:
    compilation support
    acceleration support
'''

import os
import sys
import time
from ConfigParser import ConfigParser
from StringIO import StringIO
from xmlrpclib import ServerProxy
import OpenGL
from OpenGL.GL import *

os.environ['PYMT_SHADOW_WINDOW'] = '0'
import pymt
from pymt import *
from pymt.logger import pymt_logger_history

report = []

def title(t):
    report.append('')
    report.append('=' * 80)
    report.append(t)
    report.append('=' * 80)
    report.append('')

# ----------------------------------------------------------
# Start output debugging
# ----------------------------------------------------------

title('Global')
report.append('OS platform     : %s' % sys.platform)
report.append('Python EXE      : %s' % sys.executable)
report.append('Python Version  : %s' % sys.version)
report.append('Python API      : %s' % sys.api_version)
report.append('PyMT Version    : %s' % pymt.__version__)
report.append('Install path    : %s' % os.path.dirname(pymt.__file__))
report.append('Install date    : %s' % time.ctime(os.path.getctime(pymt.__file__)))

title('OpenGL')
w = MTWindow()
report.append('PyOpenGL Version: %s' % OpenGL.__version__)
report.append('GL Vendor: %s' % glGetString(GL_VENDOR))
report.append('GL Renderer: %s' % glGetString(GL_RENDERER))
report.append('GL Version: %s' % glGetString(GL_VERSION))
ext = glGetString(GL_EXTENSIONS)
if ext is None:
    report.append('GL Extensions: %s' % ext)
else:
    report.append('GL Extensions:')
    for x in ext.split():
        report.append('\t%s' % x)
w.close()

title('Libraries')
def testimport(libname):
    try:
        l = __import__(libname)
        report.append('%-20s exist' % libname)
    except ImportError, e:
        report.append('%-20s is missing' % libname)
for x in (
    'gst',
    'pygame',
    'pygame.midi',
    'numpy',
    'OpenGL',
    'OpenGL.GL',
    'OpenGL.GLU',
    'pymt.ext.accelerate',
    'pyglet',
    'videocapture',
    'squirtle',
    'PIL',
    'cairo',
    'opencv',
    'opencv.cv',
    'opencv.highgui',
    ):
    testimport(x)

title('Core selection')
report.append('Audio  = %s' % SoundLoader._classes)
report.append('Camera = %s' % Camera)
report.append('Image  = %s' % ImageLoader.loaders)
report.append('Text   = %s' % Label)
report.append('Video  = %s' % Video)
report.append('Window = %s' % MTWindow)

title('Configuration')
s = StringIO()
ConfigParser.write(pymt_config, s)
report.extend(s.getvalue().split('\n'))

title('Input availability')
for x in TouchFactory.list():
    report.append(x)

title('Log')
for x in pymt_logger_history.history:
    report.append(x.message)

title('Environ')
for k, v in os.environ.iteritems():
    report.append('%s = %s' % (k, v))

title('Options')
for k, v in pymt_options.iteritems():
    report.append('%s = %s' % (k, v))


report = '\n'.join(report)

print report
print
print

try:
    reply = raw_input('Do you accept to send report to paste.pocoo.org (Y/n) : ')
except EOFError:
    sys.exit(0)

if reply.lower().strip() in ('', 'y'):
    print 'Please wait while sending the report...'

    s = ServerProxy('http://paste.pocoo.org/xmlrpc/')
    r = s.pastes.newPaste('text', report)

    print
    print
    print 'REPORT posted at http://paste.pocoo.org/show/%s/' % r
    print
    print
else:
    print 'No report posted.'

# On windows system, the console leave directly after the end
# of the dump. That's not cool if we want get report url
raw_input('Enter any key to leave.')

########NEW FILE########
__FILENAME__ = dumpinput
from pymt import *

class DumpListener(EventDispatcher):
    def __init__(self):
        super(DumpListener, self).__init__()
        self.register_event_type('on_touch_down')
        self.register_event_type('on_touch_move')
        self.register_event_type('on_touch_up')

    def on_touch_down(self, touch):
        print 'DOWN - ', repr(touch)

    def on_touch_move(self, touch):
        print 'MOVE - ', repr(touch)

    def on_touch_up(self, touch):
        print 'UP - ', repr(touch)


touch_event_listeners.append(DumpListener())

# will run with empty window
runTouchApp()

########NEW FILE########
__FILENAME__ = build
import os, sys, shutil, shlex, re
from urllib import urlretrieve
from subprocess import Popen, PIPE
from distutils.cmd import Command





class OSXPortableBuild(Command):
    description = "custom build command that builds portable osx package"
    user_options = [
        ('dist-dir=', None,
         "path of dist directory to use for building portable pymt, the resulting disk image will be output to this driectory. defaults to cwd."),
        ('deps-url=', None,
         "url of binary dependancies for portable pymt package default: http://pymt.googlecode.com/files/portable-deps-osx.zip"),
        ('no-cext', None,
         "flag to disable building of c extensions")
    ]

    def initialize_options(self):
        self.dist_dir = None
        self.deps_url = None
        self.no_cext = None

    def finalize_options(self):
        if not self.deps_url:
            self.deps_url = 'http://pymt.googlecode.com/files/portable-deps-osx.zip'
        if not self.dist_dir:
            self.dist_dir =  os.getcwd()

        self.src_dir = os.path.dirname(sys.modules['__main__'].__file__)
        self.dist_name = self.distribution.get_fullname() # e.g. PyMT-0.5 (name and verison passed to setup())
        self.build_dir =  os.path.join(self.dist_dir, self.dist_name+'-osx-build')



    def run(self):
        print "---------------------------------"
        print "Building PyMT Portable for OSX"
        print "---------------------------------"

        print "\nPreparing Build..."
        print "---------------------------------------"
        if os.path.exists(self.build_dir):
            print "*Cleaning old build dir"
            shutil.rmtree(self.build_dir, ignore_errors=True)
        print "*Creating build directory:"
        print " "+self.build_dir
        os.makedirs(self.build_dir)


        print "\nGetting binary dependencies..."
        print "---------------------------------------"
        print "*Downloading:", self.deps_url
        #report_hook is called every time a piece of teh file is downloaded to print progress
        def report_hook(block_count, block_size, total_size):
            p = block_count*block_size*100.0/total_size
            print "\b\b\b\b\b\b\b\b\b", "%06.2f"%p +"%",
        print " Progress: 000.00%",
        urlretrieve(self.deps_url, #location of binary dependencioes needed for portable pymt
                    os.path.join(self.build_dir,'deps.zip'), #tmp file to store teh archive
                    reporthook=report_hook)
        print " [Done]"


        print "*Extracting binary dependencies..."
        #using osx sysetm command, becasue python zipfile cant handle the hidden files in teh archive
        Popen(['unzip', os.path.join(self.build_dir,'deps.zip')], cwd=self.build_dir, stdout=PIPE).communicate()

        print "\nPutting pymt into portable environment"
        print "---------------------------------------"
        print "*Building pymt source distribution"
        sdist_cmd = [sys.executable, #path to python.exe
                     os.path.join(self.src_dir,'setup.py'), #path to setup.py
                     'sdist', #make setup.py create a src distribution
                     '--dist-dir=%s'%self.build_dir] #put it into build folder
        Popen(sdist_cmd, stdout=PIPE).communicate()


        print "*Placing pymt source distribution in portable context"
        src_dist = os.path.join(self.build_dir,self.dist_name)
        #using osx sysetm command, becasue python zipfile cant handle the hidden files in teh archive
        Popen(['tar', 'xfv', src_dist+'.tar.gz'], cwd=self.build_dir, stdout=PIPE, stderr=PIPE).communicate()
        if self.no_cext:
            print "*Skipping C Extension build (either --no_cext or --no_mingw option set)"
        else:
            print "*Compiling C Extensions inplace for portable distribution"
            cext_cmd = [sys.executable, #path to python.exe
                        'setup.py',
                        'build_ext', #make setup.py create a src distribution
                        '--inplace'] #do it inplace
            #this time it runs teh setup.py inside the source distribution
            #thats has been generated inside the build dir (to generate ext
            #for teh target, instead of the source were building from)
            Popen(cext_cmd, cwd=src_dist, stdout=PIPE, stderr=PIPE).communicate()



        print "\nFinalizing Application Bundle"
        print "---------------------------------------"
        print "*Copying launcher script into the app bundle"
        script_target = os.path.join(self.build_dir, 'portable-deps-osx', 'PyMT.app', 'Contents', 'Resources', 'script')
        script = os.path.join(src_dist,'pymt','tools','packaging','osx', 'pymt.sh')
        shutil.copy(script, script_target)

        print "*Moving examples out of app bundle to be included in disk image"
        examples_target = os.path.join(self.build_dir, 'portable-deps-osx', 'examples')
        examples = os.path.join(src_dist,'examples')
        shutil.move(examples, examples_target)

        print "*Moving newly build pymt distribution into app bundle"
        pymt_target = os.path.join(self.build_dir, 'portable-deps-osx', 'PyMT.app', 'Contents', 'Resources', 'pymt')
        shutil.move(src_dist, pymt_target)

        print "*Removing intermediate file"
        os.remove(os.path.join(self.build_dir,'deps.zip'))
        os.remove(os.path.join(self.build_dir,src_dist+'.tar.gz'))
        shutil.rmtree(os.path.join(self.build_dir,'__MACOSX'), ignore_errors=True)


        #contents of portable-deps-osx, are now ready to go into teh disk image
        dmg_dir = os.path.join(self.build_dir, 'portable-deps-osx')
        vol_name = "PyMT"

        print "\nCreating disk image for distribution"
        print "---------------------------------------"
        print "\nCreating intermediate DMG disk image: temp.dmg"
        print "*checking how much space is needed for disk image..."
        du_cmd = 'du -sh %s'%dmg_dir
        du_out = Popen(shlex.split(du_cmd), stdout=PIPE).communicate()[0]
        size, unit = re.search('(\d+)(.*)\s+/.*', du_out).group(1,2)
        print "  build needs at least %s%s." % (size, unit)

        size = int(size)+10
        print "*allocating %d%s for temp.dmg (volume name:%s)" % (size, unit, vol_name)
        create_dmg_cmd = 'hdiutil create -srcfolder %s -volname %s -fs HFS+ \
                         -fsargs "-c c=64,a=16,e=16" -format UDRW -size %d%s temp.dmg' \
                         % (dmg_dir, vol_name, size+10, unit)
        Popen(shlex.split(create_dmg_cmd), cwd=self.build_dir).communicate()

        print "*mounting intermediate disk image:"
        mount_cmd = 'hdiutil attach -readwrite -noverify -noautoopen "temp.dmg"'
        Popen(shlex.split(mount_cmd), cwd=self.build_dir, stdout=PIPE).communicate()

        print "*running Apple Script to configure DMG layout properties:"
        dmg_config_script = """
           tell application "Finder"
             tell disk "%s"
                   open

                   set current view of container window to icon view
                   set toolbar visible of container window to false
                   set statusbar visible of container window to false
                   set the bounds of container window to {300,100,942,582}
                   set theViewOptions to the icon view options of container window
                   set arrangement of theViewOptions to not arranged
                   set icon size of theViewOptions to 72
                   set background picture of theViewOptions to file ".background:pymtdmg.png"
                   make new alias file at container window to POSIX file "/Applications" with properties {name:"Applications"}
                   set position of item "PyMT" of container window to {150, 130}
                   set position of item "Applications" of container window to {500, 130}
                   set position of item "examples" of container window to {575, 400}
                   set position of item "Readme.txt" of container window to {475, 400}
                   set position of item "make-symlinks" of container window to {375, 400}
                   close
                   open
                   update without registering applications
                   delay 2
                   eject
             end tell
           end tell
        """ % vol_name
        print Popen(['osascript'], cwd=self.build_dir, stdin=PIPE, stdout=PIPE).communicate(dmg_config_script)[0]


        print "\nCreating final disk image"

        print "*unmounting intermediate disk image"
        umount_cmd = 'hdiutil detach /Volumes/%s' % vol_name
        Popen(shlex.split(umount_cmd), cwd=self.build_dir, stdout=PIPE).communicate()

        print "*compressing and finalizing disk image"
        convert_cmd = 'hdiutil convert "temp.dmg" -format UDZO -imagekey zlib-level=9 -o %s.dmg' % os.path.join(self.dist_dir,vol_name)
        Popen(shlex.split(convert_cmd), cwd=self.build_dir, stdout=PIPE).communicate()

        print "*Writing disk image, and cleaning build directory"
        shutil.rmtree(self.build_dir, ignore_errors=True)

########NEW FILE########
__FILENAME__ = build
import os, sys, shutil
import zipfile
from zipfile import ZipFile
from urllib import urlretrieve
from subprocess import Popen, PIPE
from distutils.cmd import Command


def zip_directory(dir, zip_file):
    zip = ZipFile(zip_file, 'w', compression=zipfile.ZIP_DEFLATED)
    root_len = len(os.path.abspath(dir))
    for root, dirs, files in os.walk(dir):
        archive_root = os.path.abspath(root)[root_len:]
        for f in files:
            fullpath = os.path.join(root, f)
            archive_name = os.path.join(archive_root, f)
            zip.write(fullpath, archive_name, zipfile.ZIP_DEFLATED)
    zip.close()


class WindowsPortableBuild(Command):
    description = "custom build command that builds portable win32 package"
    user_options = [
        ('dist-dir=', None,
         "path of dist directory to use for building portable pymt, the end result will be output to this driectory. default to cwd."),
        ('deps-url=', None,
         "url of binary dependancies for portable pymt package default: http://pymt.googlecode.com/files/portable-deps-win32.zip"),
        ('no-cext', None,
         "flag to disable building of c extensions"),
        ('no-mingw', None,
         "flag to disable bundling of mingw compiler for compiling c/cython extensions")
    ]

    def initialize_options(self):
        self.dist_dir = None
        self.deps_url = None
        self.no_cext = None
        self.no_mingw = None

    def finalize_options(self):
        if not self.deps_url:
            self.deps_url = 'http://pymt.googlecode.com/files/portable-deps-win32.zip'
        if not self.dist_dir:
            self.dist_dir =  os.getcwd()

        self.src_dir = os.path.dirname(sys.modules['__main__'].__file__)
        self.dist_name = self.distribution.get_fullname() # e.g. PyMT-0.5 (name and verison passed to setup())
        self.build_dir =  os.path.join(self.dist_dir, self.dist_name+'-w32')



    def run(self):
        print "---------------------------------"
        print "Building PyMT Portable for Win 32"
        print "---------------------------------"


        print "\nPreparing Build..."
        print "---------------------------------------"
        if os.path.exists(self.build_dir):
            print "*Cleaning old build dir"
            shutil.rmtree(self.build_dir, ignore_errors=True)
        print "*Creating build directory:"
        print " "+self.build_dir
        os.makedirs(self.build_dir)


        print "\nGetting binary dependencies..."
        print "---------------------------------------"
        print "*Downloading:", self.deps_url
        #report_hook is called every time a piece of teh file is downloaded to print progress
        def report_hook(block_count, block_size, total_size):
            p = block_count*block_size*100.0/total_size
            print "\b\b\b\b\b\b\b\b\b", "%06.2f"%p +"%",
        print " Progress: 000.00%",
        urlretrieve(self.deps_url, #location of binary dependencioes needed for portable pymt
                    os.path.join(self.build_dir,'deps.zip'), #tmp file to store teh archive
                    reporthook=report_hook)
        print " [Done]"


        print "*Extracting binary dependencies..."
        zf = ZipFile(os.path.join(self.build_dir,'deps.zip'))
        zf.extractall(self.build_dir)
        zf.close()
        if self.no_mingw:
            print "*Excluding MinGW from portable distribution (--no-mingw option is set)"
            shutil.rmtree(os.path.join(self.build_dir, 'MinGW'), ignore_errors=True)


        print "\nPutting pymt into portable environment"
        print "---------------------------------------"
        print "*Building pymt source distribution"
        sdist_cmd = [sys.executable, #path to python.exe
                     os.path.join(self.src_dir,'setup.py'), #path to setup.py
                     'sdist', #make setup.py create a src distribution
                     '--dist-dir=%s'%self.build_dir] #put it into build folder
        Popen(sdist_cmd, stdout=PIPE, stderr=PIPE).communicate()


        print "*Placing pymt source distribution in portable context"
        src_dist = os.path.join(self.build_dir,self.dist_name)
        zf = ZipFile(src_dist+'.zip')
        zf.extractall(self.build_dir)
        zf.close()
        if self.no_mingw or self.no_cext:
            print "*Skipping C Extension build (either --no_cext or --no_mingw option set)"
        else:
            print "*Compiling C Extensions inplace for portable distribution"
            cext_cmd = [sys.executable, #path to python.exe
                        'setup.py',
                        'build_ext', #make setup.py create a src distribution
                        '--inplace'] #do it inplace
            #this time it runs teh setup.py inside the source distribution
            #thats has been generated inside the build dir (to generate ext
            #for teh target, instead of the source were building from)
            Popen(cext_cmd, cwd=src_dist, stdout=PIPE, stderr=PIPE).communicate()


        print "\nFinalizing pymt portable distribution..."
        print "---------------------------------------"
        print "*Copying scripts and resources"
        #copy launcher script and readme to portable root dir/build dir
        pymt_bat = os.path.join(src_dist,'pymt','tools','packaging','win32', 'pymt.bat')
        shutil.copy(pymt_bat, os.path.join(self.build_dir, 'pymt.bat'))
        readme = os.path.join(src_dist,'pymt','tools','packaging','win32', 'README.txt')
        shutil.copy(readme, os.path.join(self.build_dir, 'README.txt'))
        #rename pymt directory to "pymt"
        os.rename(src_dist, os.path.join(self.build_dir,'pymt'))

        print "*Removing intermediate file"
        os.remove(os.path.join(self.build_dir,'deps.zip'))
        os.remove(os.path.join(self.build_dir,src_dist+'.zip'))

        print "*Compressing portable distribution target"
        target = os.path.join(self.dist_dir, self.dist_name+"-w32.zip")
        zip_directory(self.build_dir, target)
        print "*Writing target:", target
        print "*Removing build dir"
        shutil.rmtree(self.build_dir, ignore_errors=True)

########NEW FILE########
__FILENAME__ = animation
'''
Animation package: handle animation with ease in PyMT

Animation
=========

This is an Animation Framework, using which you can animate any
property of an object over a provided duration. You can even animate
CSS property.

Simple Animation
----------------

Example of a widget ::

    widget = SomeWidget()
    animobj = Animation(duration=5,x=100,
                        style={'bg-color':(1.0,1.0,1.0,1.0)})
    widget.do (animobj)

You create a animation class object and pass the object into the widget
that you would like to animate, the object will be animated from its
current state to the state specified in the animation object.

You can also use animate() method of the Animation class to animate
the widget ::

    animobj.animate(widget)

You can also pass multiple widgets, to animate the same way ::

    # solution 1
    animobj.animate(widget1, widget2)

    # solution 2
    widget1.do(animobj)
    widget2.do(animobj)


Complex Animations
------------------

You can sequence several animations together ::

    anim1 = Animation(duration=1, x=100)
    anim2 = Animation(duration=2, y = 200)
    anim3 = Animation(duration=1, rotation = 60)

    anim_xyrot = anim1 + anim2 + anim3

    widget.do(anim_xyrot)

This is execute the animations sequentially, "+" is used to execute them
sequentially. First the widget will move to x=100 in 1 sec then it will
move to y=200 in secs and finally rotate clockwise 60 Degress in 1 sec.

You can also run several animations parallel ::

    anim1 = Animation(duration=1, x=100)
    anim2 = Animation(duration=2, y = 200)
    anim3 = Animation(duration=1, rotation = 60)

    anim_xyrot = anim1 & anim2 & anim3

    widget.do(anim_xyrot)

This will execute all the animations on the properties togather.
"&" operator is used to run them parallel
'''

__all__ = ('AnimationAlpha', 'Animation', 'Repeat', 'Delay')

import math
import types
from copy import deepcopy, copy
from pymt.clock import getClock
from pymt.event import EventDispatcher

class AnimationBase(object):
    # This is the base animation object class. Everytime a do or animate
    #  method is called a new animobject is created.
    def __init__(self,**kwargs):
        self.widget = kwargs.get('widget')
        self.params = kwargs.get('key_args')
        self._duration =  float(self.params['duration'])
        self.animator = kwargs.get('animator')

        if 'alpha_function' in self.params:
            f = type(self.params['alpha_function'])
            if f in (types.FunctionType, types.LambdaType):
                f = self.params['alpha_function']
            else:
                f = getattr(AnimationAlpha, self.params['alpha_function'])
        else:
            f = AnimationAlpha.linear
        self.alpha_function = f

        if 'generate_event' in self.params.keys():
            self.generate_event = self.params['generate_event']
        else:
            self.generate_event = True

        self._frame_pointer = 0.0
        self._progress = 0.0
        self._running = False

    def _get_value_from(self, prop):
        if hasattr(self.widget, prop):
            return self.widget.__getattribute__(prop)
        return self.widget.__dict__[prop]

    def _set_value_from(self, value, prop):
        if hasattr(self.widget, prop):
            kwargs = {}
            attr = getattr(self.widget, prop)
            try:
                if type(attr) == dict and type(value) == dict:
                    for k, v in value.iteritems():
                        attr[k] = v
                else:
                    self.widget.__setattr__(prop, value, **kwargs)
            except:
                self.widget.__setattr__(prop, value)
        else:
            self.widget.__dict__[prop] = value

    def update(self, t):
        '''Updates the properties of the widget based on the progress
          pointer t
        '''
        for prop in self._prop_list:
            vstart, vend =  self._prop_list[prop]
            value = self._calculate_attribute_value(vstart, vend, t)
            self._set_value_from(value, prop)

    def _calculate_attribute_value(self, vstart, vend, t):
        '''A recursive function to calculate the resultant value of property.'''
        value = None
        # we handle recursively tuple and list
        if type(vstart) in (tuple, list):

            assert(type(vend) in (tuple, list))
            assert(len(vstart) == len(vend))

            value = []
            for x in range(len(vstart)):
                result = self._calculate_attribute_value(vstart[x], vend[x], t)
                value.append(type(vstart[x])(result))

        elif isinstance(vstart, dict):
                assert(isinstance(vstart, dict))
                assert(len(vstart) == len(vend))
                value = {}
                for item in vstart:
                    result = self._calculate_attribute_value(vstart[item], vend[item], t)
                    value[item]= type(vstart[item])(result)
                return value
		# try to do like a normal value
        else:
            value = type(vstart)(vstart * (1. - t) + vend * t )

        return value

    def start(self):
        '''Starts animating the AnimationBase Object'''
        if not self._running:
            self._running = True
            getClock().schedule_interval(self._next_frame, 0)

    def stop(self):
        '''Stops animating the AnimationBase Object'''
        if self._running:
            self._running = False
            if isinstance(self.animator, ParallelAnimation):
                self.animator.stop(self.widget, animobj=self)
            else:
                self.animator.stop(self.widget)
            return False

    def pause(self):
        #not yet implemented
        pass

    def _next_frame(self,dt):
        '''Calculate the progress of animation and the frame location
          pointers. This function also decides when to stop the animation.
        '''
        if self._frame_pointer <= self._duration and self._running:
            self._frame_pointer += dt
            self._progress = self._frame_pointer/self._duration
            if self._progress > 1.0:
                self._progress = 1.0
            self.update(self.alpha_function(self._progress))
            return True
        else:
            self.stop()
            return False

    @property
    def running(self):
        return self._running

    @property
    def frame_pointer(self):
        '''Returns the current progress of the animation.
          Ranges from (0.0 to duration)
        '''
        return self._frame_pointer

    @property
    def duration(self):
        '''Returns the animation duration'''
        return self._duration

    def _repopulate_attrib(self, widget):
        '''This function is used by Sequencer to repopluate the properties
           list based on current status of the widget.
        '''
        self.widget = widget
        prop_keys = {}
        for prop in self._prop_list:
            prop_keys[prop] = self._prop_list[prop][1]
        self._prop_list = {}
        for prop in prop_keys:
            cval = self._get_value_from(prop)
            if type(cval) in (tuple, list):
                self._prop_list[prop] = (cval, prop_keys[prop])
        for prop in prop_keys:
            cval = self._get_value_from(prop)
            if type(cval) in (tuple, list):
                self._prop_list[prop] = (cval, prop_keys[prop])
            elif isinstance(cval, dict):
                #contruct a temp dict of only required keys
                temp_dict = {}
                for each_key in prop_keys[prop]:
                    temp_dict[each_key] = cval[each_key]
                self._prop_list[prop] = (temp_dict, prop_keys[prop])
            else:
                self._prop_list[prop] = (cval,prop_keys[prop])

class AbsoluteAnimationBase(AnimationBase):
    #Animation Objects of sort MoveTo, RotateTo etc depend on this class
    def __init__(self,**kwargs):
        super(AbsoluteAnimationBase, self).__init__(**kwargs)
        self._prop_list = {}
        for item in self.params:
            if item not in ('duration', 'anim1', 'anim2', 'generate_event',
                            'single_event', 'type', 'alpha_function', 'd', 'f'):
                self._prop_list[item] = self.params[item]

        for prop in self._prop_list:
            cval = self._get_value_from(prop)
            if type(cval) in (tuple, list):
                self._prop_list[prop] = (cval, self._prop_list[prop])
            elif isinstance(cval, dict):
                #contruct a temp dict of only required keys
                temp_dict = {}
                for each_key in self._prop_list[prop]:
                    temp_dict[each_key] = cval[each_key]
                self._prop_list[prop] = (temp_dict, self._prop_list[prop])
            else:
                self._prop_list[prop] = (cval,self._prop_list[prop])

        #Store state values for repeating
        self._initial_state = deepcopy(self._prop_list)

    def reset(self):
        #repeating a absolute animation doesnt make sense atleast for now
        pass

class DeltaAnimationBase(AnimationBase):
    #Animation Objects of sort MoveBy, RotateBy etc depend on this class
    def __init__(self,**kwargs):
        super(DeltaAnimationBase, self).__init__(**kwargs)
        self._prop_list = {}
        for item in self.params:
            if item not in ('duration', 'anim1', 'anim2', 'generate_event',
                            'single_event', 'type', 'alpha_function', 'd', 'f'):
                self._prop_list[item] = self.params[item]

        #save proplist for repeatation
        self._saved_prop_list = {}
        self._saved_prop_list = deepcopy(self._prop_list)

        for prop in self._prop_list:
            cval = self._get_value_from(prop)
            if type(cval) in (tuple, list):
                self._prop_list[prop] = (cval, self._update_list(cval , self._prop_list[prop]))
            elif isinstance(cval, dict):
                #contruct a temp dict of only required keys
                temp_dict = {}
                for each_key in self._prop_list[prop]:
                    temp_dict[each_key] = cval[each_key]
                self._prop_list[prop] = (temp_dict, self._update_dict(temp_dict, self._prop_list[prop]))
            else:
                self._prop_list[prop] = (cval,cval+self._prop_list[prop])

    def reset(self):
        '''used by Repeater to reset the property list'''
        self._frame_pointer = 0.0
        self._progress = 0.0
        self._running = False
        for prop in self._saved_prop_list:
            cval = self._get_value_from(prop)
            if type(cval) in (tuple, list):
                self._prop_list[prop] = (cval, self._update_list(cval, self._saved_prop_list[prop]))
            elif isinstance(cval, dict):
                #contruct a temp dict of only required keys
                temp_dict = {}
                for each_key in self._saved_prop_list[prop]:
                    temp_dict[each_key] = cval[each_key]
                self._prop_list[prop] = (temp_dict,  self._update_dict(temp_dict, self._saved_prop_list[prop]))
            else:
                self._prop_list[prop] = (cval,cval+self._saved_prop_list[prop])

    def _update_list(self, ip_list, op_list):
        '''Used by reset function to update a list type data'''
        temp_list = []
        for i in range(0, len(ip_list)):
            temp_list.append(ip_list[i]+op_list[i])
        return  temp_list

    def _update_dict(self, ip_dict, op_dict):
        '''Used by reset function to update a dict type data'''
        temp_dict = {}
        for key in ip_dict.iterkeys():
            if type(ip_dict[key]) in (tuple, list):
                temp_dict[key] = self._update_list(ip_dict[key], op_dict[key])
            else:
                temp_dict[key] = ip_dict[key]+op_dict[key]
        return  temp_dict

class Animation(EventDispatcher):
    '''Animation Class is used to animate any widget. You pass duration of
    animation and the property that has to be animated in that duration.

    Usage ::

        widget = SomeWidget()
        animobj = Animation(duration=5, x=100,
                            style={'bg-color':(1.0,1.0,1.0,1.0)})
        widget.do(animobj)

    :Parameters:
        `duration` or `d`: float, default to 1
            Number of seconds you want the animation to execute.
        `generate_event` : bool, default to True
            Generate on_animation_complete event at the end of the
            animation
        `type` : str, default to absolute
            Specifies what type of animation we are defining, Absolute
            or Delta
        `alpha_function` or `f`: str, default to AnimationAlpha.linear
            Specifies which kind of time variation function to use

    :Events:
        `on_start`
            Fired when animation starts
        `on_complete`
            Fired when animation completes

    '''
    def __init__(self,**kwargs):
        super(Animation, self).__init__()
        kwargs.setdefault('type', 'absolute')

        if 'd' in kwargs and 'duration' in kwargs:
            raise Exception('d and duration are in Animation(), use only one.')
        if 'f' in kwargs and 'alpha_function' in kwargs:
            raise Exception('f and alpha_function are in Animation(), use only one.')

        if 'd' in kwargs:
            kwargs['duration'] = kwargs['d']
            del kwargs['d']
        if 'duration' in kwargs:
            self._duration = kwargs.get('duration')
        else:
            self._duration = 1.0
        kwargs['duration'] = self._duration

        if 'f' in kwargs:
            kwargs['alpha_function'] = kwargs['f']
            del kwargs['f']

        self.children = {}
        self.params = kwargs
        self._animation_type = kwargs.get('type')

        self.register_event_type('on_start')
        self.register_event_type('on_complete')

    def start(self, widget):
        '''Starts animating the widget. This function should not be used
          by the user directly. Users have to use do() method of the
          widget to animate.
        '''
        animobj = self.children[widget]
        animobj.start()
        self.dispatch_event('on_start', widget)
        return animobj

    def stop(self, widget):
        '''Stops animating the widget and raises a event.'''
        if self.children[widget].generate_event:
            widget.dispatch_event('on_animation_complete', self)
            self.dispatch_event('on_complete', widget)
        self._del_child(widget)

    def pause(self):
        pass

    def reset(self, widget):
        '''Calls AnimationBase objects reset function.'''
        self.children[widget].reset()

    def set_widget(self, widgetx):
        '''Creates a new animationBase object and sets the widget to it for
        animation. This is a internal function and should not be used by user.

        :Parameters:
            `widget` : MTWidget, default is None
                Indicates which widget is to be set.

        '''
        if widgetx in self.children.keys():
            return False
        else:
            if self._animation_type == 'absolute':
                new_animobj = AbsoluteAnimationBase(widget=widgetx, key_args=self.params, animator=self)
            else:
                new_animobj = DeltaAnimationBase(widget=widgetx, key_args=self.params, animator=self)
            self.children[widgetx] = new_animobj
            return True

    def animate(self, *largs):
        '''Animate the widgets specified as parameters to this method.

        :Parameters:
            `widget` : Widget
                A Widget or a group of widgets separated by comma ","
        '''
        for widget in largs:
            self.set_widget(widget)
            self.start(widget)

    def _del_child(self,child):
        '''Deletes a child from the list'''
        del self.children[child]

    def _return_params(self):
        '''Returns the animation parameters.'''
        return self.params

    def _repopulate_attrib(self, widget):
        '''Calls calls repopulate function of the animationBase object'''
        self.children[widget]._repopulate_attrib(widget)

    def _set_params(self, key, value):
        '''reset the value for the params list'''
        self.params[key] = value

    def __add__(self, animation):
        return SequenceAnimation(anim1=self, anim2=animation)

    def __and__(self, animation):
        return ParallelAnimation(anim1=self, anim2=animation)

    def on_start(self, widget):
        pass

    def on_complete(self, widget):
        pass

class ComplexAnimation(Animation):
    # Base class for complex animations like sequences and parallel
    # animations
    def __init__(self, **kwargs):
        super(ComplexAnimation, self).__init__(**kwargs)
        kwargs.setdefault('single_event', False)
        self.single_event = kwargs.get('single_event')
        self.animations = []
        anim1 = kwargs.get('anim1')
        anim2 = kwargs.get('anim2')
        if type(anim1) in (tuple, list):
            for anim in anim1:
                self.animations.append(anim)
        else:
            self.animations.append(anim1)
        self.animations.append(anim2)

    def set_widget(self, widgetx):
        '''Used by complex animations like Parallel and Sequential to set
          widgets to its child animations
        '''
        for animation in self.animations:
            try:
                if animation.children[widgetx].running():
                    return False
            except:
                continue
        for animation in self.animations:
            if animation._animation_type == 'absolute':
                new_animobj = AbsoluteAnimationBase(widget=widgetx, key_args=animation.params, animator=self)
            else:
                new_animobj = DeltaAnimationBase(widget=widgetx, key_args=animation.params, animator=self)
            animation.children[widgetx] = new_animobj
        return True

    def generate_single_event(self, value):
        '''If a user wants to generate only one event for the entire complex
        animation he can use this function.

        :Parameters:
            `value` : bool
                True or False value
        '''
        self.single_event = value

class SequenceAnimation(ComplexAnimation):
    #A class for sequential type animation
    def __init__(self, **kwargs):
        super(SequenceAnimation, self).__init__(**kwargs)
        self.anim_counter = 0

    def start(self, widget):
        '''Starts the sequential animation'''
        if self.anim_counter == 0:
            self.dispatch_event('on_start', widget)
        if self.anim_counter >= len(self.animations):
            self.anim_counter = 0
            self.dispatch_event('on_complete', widget)
            if self.single_event:
                widget.dispatch_event('on_animation_complete', self)
            return
        current_anim = self.animations[self.anim_counter]
        current_anim.start(widget)
        return self

    def stop(self, widget = None):
        '''Stops the sequential animation'''
        if widget == None:
            widget = self.animations[self.anim_counter].children.keys()[0]
        if self.animations[self.anim_counter].children[widget].generate_event and not self.single_event:
            widget.dispatch_event('on_animation_complete', self)
        #self.animations[self.anim_counter]._del_child(widget)
        self.anim_counter += 1
        if self.anim_counter < len(self.animations):
            self.animations[self.anim_counter]._repopulate_attrib(widget)
        self.start(widget)

    def reset(self, widget):
        '''Resets the sequential animation'''
        self.anim_counter = 0
        for animation in self.animations:
            animation.reset(widget)

    def __add__(self, animation):
        '''Operator overloading + symbol is overloaded'''
        return SequenceAnimation(anim1=self.animations, anim2=animation)


class ParallelAnimation(ComplexAnimation):
    #A class for Parallel type animation
    def __init__(self, **kwargs):
        super(ParallelAnimation, self).__init__(**kwargs)
        self.dispatch_counter = 0

    def start(self, widget):
        '''Starts the parallel animation'''
        if self.dispatch_counter == 0:
            self.dispatch_event('on_start', widget)
        for animation in self.animations:
            animation.start(widget)
        return self

    def stop(self, widget = None, animobj = None):
        '''Stops the parallel animation'''
        if widget == None:
            widget = self.animations[self.dispatch_counter].children.keys()[0]

        if animobj == None:
            animobj = self.animations[self.dispatch_counter].children[widget]

        self.dispatch_counter += 1        
        if self.dispatch_counter == len(self.animations):
            self.dispatch_event('on_complete', widget)
            if self.single_event:
                widget.dispatch_event('on_animation_complete', self)
            self.dispatch_counter = 0
            return

        if animobj.generate_event and not self.single_event:
            widget.dispatch_event('on_animation_complete', self)

    def reset(self, widget):
        '''Resets the parallel animation'''
        self.dispatch_counter = 0
        for animation in self.animations:
            animation.reset(widget)

    def __and__(self, animation):
        '''Operator overloading & symbol is overloaded'''
        return ParallelAnimation(anim1=self.animations, anim2=animation)


#Controller Classes

class Repeat(EventDispatcher):
    '''Repeat Controller class is used to repeat a particular animations. It
    repeats n times as specified or repeats indefinately if number of times
    to repeat is not specified. Repeat class is useful only for delta
    animations.

    Usage ::

        widget = SomeWidget()
        animobj = Animation(duration=5, x=100,
                            style={'bg-color':(1.0,1.0,1.0,1.0)})
        rept = Repeat(animobj, times=5) #Repeats 5 times
        rept_n = Repeat(animobj) #Repeats indefinately

    :Parameters:
        `times` : integer, default to infinity
            Number of times to repeat the Animation

    :Events:
        `on_start`
            Fired when animation starts
        `on_complete`
            Fired when animation completes
        `on_repeat`
            Fired on every repetition. It also returns what is the current
            repetition count.

    '''
    def __init__(self, animation, **kwargs):
        super(Repeat, self).__init__()
        kwargs.setdefault('times', -1)
        self.animations = animation
        self.single_event = True
        self._repeat_counter = 0
        self._times = kwargs.get('times')
        self.register_event_type('on_start')
        self.register_event_type('on_repeat')
        self.register_event_type('on_complete')
        @self.animations.event
        def on_complete(widget):
            self.repeat(widget)

    def set_widget(self, widgetx):
        '''Called by the widget to set the widget which has to be animated'''
        self.animations.set_widget(widgetx)
        return True

    def start(self, widget):
        '''Starts the animation'''
        if self._repeat_counter == 0:
            self.dispatch_event('on_start', widget)
        self.animations.start(widget)

    def stop(self,widget):
        '''Stops the animation'''
        widget.dispatch_event('on_animation_complete', self)
        self.dispatch_event('on_complete', widget)
        self._repeat_counter = 0
        if not (isinstance(self.animations, ParallelAnimation) or isinstance(self.animations, SequenceAnimation)):
            self.animations._del_child(widget)

    def repeat(self, widget):
        '''Internal function used by the Repeat controller to check for
          repetitions
        '''
        self._repeat_counter += 1
        self.dispatch_event('on_repeat', widget , self._repeat_counter)
        if self._times == -1:
            self.animations.reset(widget)
            self.start(widget)
        elif self._repeat_counter < self._times:
            self.animations.reset(widget)
            self.start(widget)
        else:
            self.stop(widget)

    def on_start(self, widget):
        pass

    def on_complete(self, widget):
        pass

    def on_repeat(self, widget, count):
        pass

class Delay(Animation):
    '''Delay class is used to introduce delay in your animations.
    You can provide the duration in your animation class creation

    Usage ::

        widget = SomeWidget()
        moveX = Animation(duration=5, x=100,
                          style={'bg-color':(1.0,1.0,1.0,1.0)})
        delay5 = Delay(duration=5)
        animobj = delay5 + moveX
        # This will wait for 5 secs and then start animating moveX

    :Parameters:
        `duration` : float, default to 1
            Number of seconds you want delay.

    '''
    def __init__(self, **kwargs):
        super(Delay, self).__init__(**kwargs)
        self._duration = kwargs.get('duration')


class AnimationAlpha(object):
    '''Collection of animation function, to be used with Animation object.
        Easing Functions ported into PyMT from Clutter Project
        http://www.clutter-project.org/docs/clutter/stable/ClutterAlpha.html
    '''
    @staticmethod
    def linear(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#linear'''
        return progress

    @staticmethod
    def ease_in_quad(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_quad'''
        return progress * progress

    @staticmethod
    def ease_out_quad(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_out_quad'''
        return -1.0 * progress * (progress - 2.0)

    @staticmethod
    def ease_in_out_quad(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_out_quad'''
        p = progress * 2
        if p < 1 :
           return 0.5 * p * p
        p -= 1.0
        return -0.5 * (p * (p - 2.0) - 1.0)

    @staticmethod
    def ease_in_cubic(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_cubic'''
        return progress * progress * progress

    @staticmethod
    def ease_out_cubic(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_out_cubic'''
        p = progress - 1.0
        return p * p * p + 1.0

    @staticmethod
    def ease_in_out_cubic(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_out_cubic'''
        p = progress * 2
        if p < 1 :
            return 0.5 * p * p * p
        p -= 2
        return 0.5 * (p * p * p + 2.0)

    @staticmethod
    def ease_in_quart(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_quart'''
        return progress * progress * progress * progress

    @staticmethod
    def ease_out_quart(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_out_quart'''
        p = progress - 1.0
        return -1.0 * (p * p * p * p - 1.0);

    @staticmethod
    def ease_in_out_quart(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_out_quart'''
        p = progress * 2
        if p < 1 :
            return 0.5 * p * p * p * p
        p -= 2
        return -0.5 * (p * p * p * p - 2.0)

    @staticmethod
    def ease_in_quint(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_quint'''
        return progress * progress * progress * progress * progress

    @staticmethod
    def ease_out_quint(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_out_quint'''
        p = progress - 1.0
        return p * p * p * p * p + 1.0;

    @staticmethod
    def ease_in_out_quint(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_out_quint'''
        p = progress * 2
        if p < 1 :
            return 0.5 * p * p * p * p * p
        p -= 2.0
        return 0.5 * (p * p * p * p * p + 2.0)

    @staticmethod
    def ease_in_sine(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_sine'''
        return -1.0 * math.cos(progress * (math.pi/2.0)) + 1.0

    @staticmethod
    def ease_out_sine(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_out_sine'''
        return math.sin(progress * (math.pi/2.0))

    @staticmethod
    def ease_in_out_sine(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_out_sine'''
        return -0.5 * (math.cos(math.pi * progress) - 1.0)

    @staticmethod
    def ease_in_expo(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_expo'''
        if progress == 0:
            return 0.0
        return math.pow(2, 10 * (progress - 1.0))

    @staticmethod
    def ease_out_expo(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_out_expo'''
        if progress == 1.0:
            return 1.0
        return  -math.pow(2, -10 * progress) + 1.0

    @staticmethod
    def ease_in_out_expo(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_out_expo'''
        if progress == 0:
            return 0.0
        if progress == 1.:
            return 1.0
        p = progress * 2
        if p < 1:
            return 0.5 * math.pow(2, 10 * (p - 1.0))
        p -= 1.0
        return 0.5 * (-math.pow(2, -10 * p) + 2.0)

    @staticmethod
    def ease_in_circ(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_circ'''
        return -1.0 * (math.sqrt(1.0 - progress * progress) - 1.0)

    @staticmethod
    def ease_out_circ(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_out_circ'''
        p = progress - 1.0
        return math.sqrt(1.0 - p * p)

    @staticmethod
    def ease_in_out_circ(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_out_circ'''
        p = progress * 2
        if p < 1:
            return -0.5 * (math.sqrt(1.0 - p * p) - 1.0)
        p -= 2.0
        return 0.5 * (math.sqrt(1.0 - p * p) + 1.0)

    @staticmethod
    def ease_in_elastic(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_elastic'''
        p = .3
        s = p / 4.0
        q = progress
        if q == 1:
            return 1.0
        q -= 1.0
        return -(math.pow(2, 10 * q) * math.sin((q - s) * (2 * math.pi) / p))

    @staticmethod
    def ease_out_elastic(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_out_elastic'''
        p = .3
        s = p / 4.0
        q = progress
        if q == 1:
            return 1.0
        return math.pow(2, -10 * q) * math.sin ((q - s) * (2 * math.pi) / p) + 1.0

    @staticmethod
    def ease_in_out_elastic(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_out_elastic'''
        p = .3 * 1.5
        s = p / 4.0
        q = progress * 2
        if q == 2:
            return 1.0
        if q < 1:
            q -= 1.0;
            return -.5 * (math.pow(2, 10 * q) * math.sin((q - s) * (2.0 *math.pi) / p));
        else:
            q -= 1.0;
            return math.pow(2, -10 * q) * math.sin((q - s) * (2.0 * math.pi) / p) * .5 + 1.0;

    @staticmethod
    def ease_in_back(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_back'''
        return progress * progress * ((1.70158 + 1.0) * progress - 1.70158)

    @staticmethod
    def ease_out_back(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_out_back'''
        p = progress - 1.0
        return p * p * ((1.70158 + 1) * p + 1.70158) + 1.0

    @staticmethod
    def ease_in_out_back(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_out_back'''
        p = progress * 2.
        s = 1.70158 * 1.525
        if p < 1:
            return 0.5 * (p * p * ((s + 1.0) * p - s))
        p -= 2.0
        return 0.5 * (p * p * ((s + 1.0) * p + s) + 2.0)

    @staticmethod
    def _ease_out_bounce_internal(t, d):
        p = t / d
        if p < (1.0 / 2.75):
            return 7.5625 * p * p
        elif p < (2.0 / 2.75):
            p -= (1.5 / 2.75)
            return 7.5625 * p * p + .75
        elif p < (2.5 / 2.75):
            p -= (2.25 / 2.75)
            return 7.5625 * p * p + .9375
        else:
            p -= (2.625 / 2.75)
            return 7.5625 * p * p + .984375

    @staticmethod
    def _ease_in_bounce_internal(t, d):
        return 1.0 - AnimationAlpha._ease_out_bounce_internal(d - t, d)

    @staticmethod
    def ease_in_bounce(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_bounce'''
        return AnimationAlpha._ease_in_bounce_internal(progress, 1.)

    @staticmethod
    def ease_out_bounce(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_out_bounce'''
        return AnimationAlpha._ease_out_bounce_internal(progress, 1.)

    @staticmethod
    def ease_in_out_bounce(progress):
        '''See documentation at http://pymt.eu/wiki/DevGuide/EasingFunctions#ease_in_out_bounce'''
        p = progress * 2
        if p < 1.:
            return AnimationAlpha._ease_in_bounce_internal(progress * 2.0, 1.) * 0.5
        return AnimationAlpha._ease_out_bounce_internal(progress * 2.0 - 1., 1.) * 0.5 + 1.0 * 0.5

########NEW FILE########
__FILENAME__ = colors
'''
Colors: css & themes

Currently, the default css is included in this file.
You can easily extend the default style by create a css file
in your ~/.pymt/user.css.

Exemple of user.css ::

    * {
        /* increase the font-size of every widget */
        font-size: 18;
    }

.. warning::

    Only class name of widget is currently use to search CSS.

We cannot describe how to style every widget in this class.
If you want to known which attribute is needed to style a widget,
please look on the widget documentation.
'''

__all__ = (
    'css_get_style', 'get_truncated_classname',
    'pymt_sheet', 'css_add_sheet', 'css_add_file', 'css_get_widget_id',
    'css_register_state', 'css_add_keyword', 'css_register_prefix',
    'css_reload'
)

from pymt.logger import pymt_logger
from pymt.cache import Cache
from pymt.resources import resource_add_path
from pymt.parser import parse_color, parse_image, parse_float4, \
        parse_float, parse_bool, parse_int, parse_int2, parse_string, \
        parse_filename
from pymt import pymt_data_dir, pymt_home_dir
import os
import sys
import shutil
import logging
import re
import weakref

# Register CSS cache
Cache.register('pymt.css', limit=500, timeout=60)

#: Instance of the CSS sheet
pymt_sheet = None

#: State allowed to CSS rules (bg-color[-state] for eg)
pymt_css_states = ['-down', '-move', '-dragging', '-active', '-error',
                   '-validated', '-syskey']

#: Prefix allowed to CSS rules
pymt_css_prefix = ['key-', 'slider-', 'title-', 'cursor-', 'selection-']

# Privates vars for reload features
_css_sources = []
_css_widgets = set()

# Auto conversion from css to a special type.
css_keyword_convert = {
    'color':                    parse_color,
    'bg-color':                 parse_color,
    'bg-color-full':            parse_color,
    'font-size':                parse_int,
    'font-name':                parse_filename,
    'font-weight':              parse_string,
    'font-color':               parse_color,
    'border-image':             parse_filename,
    'border-image-width':       parse_float4,
    'border-width':             parse_float,
    'border-radius':            parse_int,
    'border-radius-precision':  parse_float,
    'border-color':             parse_color,
    'slider-color':             parse_color,
    'touch-color':              parse_color,
    'draw-background':          parse_bool,
    'draw-text-shadow':         parse_bool,
    'draw-border':              parse_bool,
    'draw-border-image':        parse_bool,
    'draw-alpha-background':    parse_bool,
    'text-shadow-color':        parse_color,
    'text-shadow-position':     parse_int2,
    'alpha-background':         parse_float4,
    'item-color':               parse_color,
    'item-selected':            parse_color,
    'padding':                  parse_int2,
    'slider-border-radius':     parse_int,
    'slider-border-radius-precision': parse_float,
    'slider-alpha-background':  parse_float4,
    'slider-draw-background':   parse_bool,
    'draw-slider-border':       parse_bool,
    'draw-slider-alpha-background': parse_bool,
    'key-border-radius':        parse_int,
    'key-border-radius-precision': parse_float,
    'key-alpha-background':     parse_float4,
    'key-draw-background':      parse_bool,
    'key-border-color':         parse_color,
    'draw-key-border':          parse_bool,
    'draw-key-alpha-background': parse_bool,
    'vector-color':             parse_color,
    'title-color':              parse_color,
    'title-border-radius':      parse_int,
    'title-border-radius-precision': parse_float,
    'title-alpha-background':   parse_float4,
    'title-draw-background':    parse_bool,
    'draw-title-border':        parse_bool,
    'draw-title-alpha-background': parse_bool,
    'margin':                   parse_float4,
    'key-color':                parse_color,
    'syskey-color':             parse_color,
    'scrollbar-size':           parse_float,
    'scrollbar-margin':         parse_float4,
    'scrollbar-color':          parse_color,
    'bg-image':                 parse_image,
    'selected-color':           parse_color,
}

class CSSSheet(object):
    def __init__(self):
        self._rule = ''
        self._content = ''
        self._state = 'rule'
        self._css = {}

    def reset(self):
        self._rule = ''
        self._content = ''
        self._state = 'rule'
        self._css = {}

    def parse_text(self, text):
        '''Parse a CSS text, and inject in the current sheet'''
        # remove comment
        def _comment_remover(text):
            def replacer(match):
                s = match.group(0)
                if s.startswith('/'):
                    return ""
                else:
                    return s
            pattern = re.compile(
                r'//.*?$|/\*.*?\*/|\'(?:\\.|[^\\\'])*\'|"(?:\\.|[^\\"])*"',
                re.DOTALL | re.MULTILINE
            )
            return re.sub(pattern, replacer, text)

        text = _comment_remover(text)
        self._rule = ''
        for line in text.split('\n'):
            self._parse_line(line)

    def _parse_line(self, line):
        '''Parse a line, and inject into rules or content, depend on current
        parser state'''
        if self._state == 'rule':
            r = line.split('{', 1)
            self._rule += ',' + r[0]
            if len(r) != 1:
                self._state = 'content'
                self._parse_line(r[1])

        elif self._state == 'content':
            r = line.split('}', 1)
            self._content += ';' + r[0]
            if len(r) != 1:
                self._push(self._rule, self._content)
                self._rule = ''
                self._content = ''
                self._state = 'rule'
                self._parse_line(r[1])

    def _push(self, rulestr, contentstr):
        '''Push a rules/contents into our sheet'''
        def extract(v):
            sname, svalue = v.split(':')
            name = sname.strip()
            value = svalue.strip()
            if name not in css_keyword_convert:
                # searching for a state
                for state in pymt_css_states:
                    if name.endswith(state):
                        name = name[:-len(state)]
                        break
                # searching for a prefix
                for prefix in pymt_css_prefix:
                    if name.startswith(prefix):
                        name = name[len(prefix):]
                        break
            if name in css_keyword_convert:
                try:
                    value = css_keyword_convert[name](value)
                except Exception:
                    pymt_logger.exception(
                        'Error while convert %s: %s' % (name, value))
            return sname.strip(), value

        rules = [x.strip() for x in rulestr.split(',') if x.strip() != '']
        keys = [extract(x.strip()) for x in contentstr.split(';') if x.strip() != '']
        for rule in rules:
            if rule in self._css:
                self._css[rule].update(dict(keys[:]))
            else:
                self._css[rule] = dict(keys[:])

    def get_style(self, widget):
        '''Return the style of a widget'''
        widget_classes = get_widget_parents(widget)
        widget_classes.append('*')
        styles = {}

        # 
        # TODO rework this part to match
        # #<objectid>  uniq
        # <objectname> uniq
        # .<class>     multiple
        #

        # match <objectname>
        for cls in reversed(widget_classes):
            for r, v in self._css.iteritems():
                if r == cls:
                    styles.update(v)

        # match .<classname>
        widget_cls = widget.cls
        if type(widget_cls) in (unicode, str):
            widget_cls = [widget.cls]
        if type(widget_cls) in (list, tuple):
            for kcls in widget_cls:
                cls = '.%s' % kcls
                if cls in self._css:
                    styles.update(self._css[cls])

                # match <objectname>.<classname>
                for name in reversed(widget_classes):
                    lcls = '%s%s' % (name, cls)
                    for r, v in self._css.iteritems():
                        if r == lcls:
                            styles.update(v)

        # match #<objectname>
        if hasattr(widget, 'id') and widget.id is not None:
            widgetid = '#%s' % widget.id
            if widgetid in self._css:
                styles.update(self._css[widgetid])

        return styles

def get_truncated_classname(name):
    '''Return the css-ized name of a class
    (remove the MT prefix, and all in lowercase)'''
    if name.startswith('MT'):
        name = name[2:]
    return name.lower()

widgets_parents = {}
def get_widget_parents(widget):
    parent = [widget.__class__]
    if not widget.__class__ in widgets_parents:
        widget_classes = list()
        while parent and len(parent):
            # take only the first parent...
            widget_classes.append(get_truncated_classname(parent[0].__name__))
            # don't back too far
            if parent[0].__name__ in ['MTWidget', 'MTWindow']:
                break
            parent = parent[0].__bases__
        widgets_parents[widget.__class__] = widget_classes
    return widgets_parents[widget.__class__]

def css_get_widget_id(widget):
    '''Return the css id of a widget'''
    if not hasattr(widget, 'cls'):
        widget.__setattr__('cls', '')
    cls = widget.cls
    if type(cls) in (tuple, list):
        cls = '.'.join(cls)
    cid = ''
    if hasattr(widget, 'id') and widget.id:
        cid = '#%s#' % getattr(widget, 'id')
    idwidget = cid + str(widget.__class__) + ':' + cls
    return idwidget

def css_get_style(widget):
    '''Return a dict() with all the style for the widget.

    :Parameters:
        `widget`: class
            Widget to search CSS
    '''

    global pymt_sheet

    ref = weakref.ref(widget)
    if not ref in _css_widgets:
        _css_widgets.add(ref)

    idwidget = css_get_widget_id(widget)
    styles = Cache.get('pymt.css', idwidget)
    if styles is not None:
        return styles

    styles = pymt_sheet.get_style(widget)
    Cache.append('pymt.css', idwidget, styles)
    return styles

def css_add_sheet(text, _reload=False):
    '''Add a css text to use.
    Example ::

        mycss = '#buttonA { bg-color: rgba(255, 127, 0, 127); }'
        css_add_sheet(mycss)

    '''
    pymt_sheet.parse_text(text)
    if not _reload:
        _css_sources.append((css_add_sheet, (text, )))

def css_add_file(cssfile, _reload=False):
    '''Add a css file to use.
    Adds all the css rules in the given file to the pymt css rule set being
    used ::

        css_add_sheet(cssfile)

    '''
    resource_add_path(os.path.dirname(cssfile))
    with open(cssfile, 'r') as fd:
        pymt_sheet.parse_text(fd.read())
    if not _reload:
        _css_sources.append((css_add_file, (cssfile, )))

def css_register_state(name):
    '''Register a new state'''
    pymt_css_states.append('-%s' % name)

def css_register_prefix(name):
    '''Register a new prefix'''
    pymt_css_prefix.append('%s-' % name)

def css_add_keyword(keyword, convertfunc):
    '''Add a new keyword to be autoconverted when reading CSS.
    Convert function can be found in parser.py'''
    css_keyword_convert[keyword] = convertfunc

def css_reload():
    pymt_logger.debug('CSS: Reloading CSS in progress')
    pymt_sheet.reset()
    for callback, args in _css_sources[:]:
        callback(*args, _reload=True)
    Cache.remove('pymt.css')
    for r in _css_widgets.copy():
        o = r()
        if o is None:
            _css_widgets.remove(r)
            continue
        o.reload_css()
    pymt_logger.info('CSS: CSS Reloaded')

# Autoload the default css + user css
if 'PYMT_DOC' not in os.environ:
    # Add default CSSheet
    pymt_sheet = CSSSheet()
    css_add_file(os.path.join(pymt_data_dir, 'default.css'))

    # Add user css if exist
    css_filename = os.path.join(pymt_home_dir, 'user.css')
    if os.path.exists(css_filename):
        css_add_file(css_filename)


if __name__ == '__main__':
    from pymt import MTWidget, css_get_style, MTWindow
    w = MTWidget()
    print w
    print css_get_style(widget=w)
    w = MTWindow()
    print w
    print css_get_style(widget=w)

########NEW FILE########
__FILENAME__ = factory
'''
Factory: all widgets are registered through this factory

It is needed for external instance, like XMLWidget.
'''

__all__ = ('MTWidgetFactory', )

class MTWidgetFactory(object):
    '''Widget factory. Designed to register all the PyMT widget,
    and get them from a limited context (like eval)
    '''

    _widgets = {}

    @staticmethod
    def register(widgetname, widgetclass):
        '''Add a widget into our database'''
        if not widgetname in MTWidgetFactory._widgets:
            MTWidgetFactory._widgets[widgetname] = widgetclass

    @staticmethod
    def get(widgetname):
        '''Get a widget from database'''
        if widgetname in MTWidgetFactory._widgets:
            return MTWidgetFactory._widgets[widgetname]
        raise Exception('Widget %s are not known in MTWidgetFactory' % widgetname)



########NEW FILE########
__FILENAME__ = button
'''
Button package: implement different type of button
'''

__all__ = ('MTButton', 'MTToggleButton', 'MTImageButton')

import pymt
import weakref
from pymt.graphx import GlDisplayList, set_color, gx_blending, drawCSSRectangle
from pymt.utils import SafeList
from pymt.ui.widgets.label import MTLabel

class MTButton(MTLabel):
    '''MTButton is a button implementation using MTLabel

    :Parameters:
        `label` : string, default is ''
            Label of button
        `anchor_x` : string, default to 'center'
            Horizontal alignment of label inside button (left, center, right)
        `anchor_y` : string, default to 'center'
            Vertical alignment of label inside button (bottom, center, top)
        `multiline` : bool, default is False
            Indicate if button is a multiline button

    :Styles:
        .. note::
            All the css attributes can be postfixed with the state of the
            button. It will only work with attributes used for background.
            For example ::

                `bg-color` for normal state
                `bg-color-down` for down state

        `bg-color` : color
            Background color of the button
        `color` : color
            color of the text/label on teh button
        `font-name` : str
            Name of font to use
        `font-size` : int
            Size of font in pixel
        `font-style` : str
            Style of font, can be "bold", "italic" or "bolditalic"
        `draw-border` : bool
            Indicate if the border must be drawed or not
        `border-radius` : int
            Size of radius in pixel
        `border-radius-precision` : float
            Precision of the radius drawing (1 mean no precision)
        `draw-text-shadow` : bool
            Indicate if the text shadow must be drawed
        `text-shadow-color` : color
            Color of the text shadow
        `text-shadow-position` : x y
            Relative position of shadow text
        `draw-alpha-background` : bool
            Indicate if the alpha background must be drawed

    :Events:
        `on_state_change` : (state string "down" or "normal", )
            Fired when the state of the button change
        `on_press` (touch object, )
            Fired when the button are pressed (not released)
        `on_release` (touch object, )
            Fired when the button are released
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('autosize', False)
        kwargs.setdefault('autowidth', False)
        kwargs.setdefault('autoheight', False)
        kwargs.setdefault('anchor_x', 'center')
        kwargs.setdefault('anchor_y', 'center')
        kwargs.setdefault('halign', 'center')
        kwargs.setdefault('valign', 'center')
        # FIXME, would be nice to suppress it !
        kwargs.setdefault('size', (100, 100))
        self._state         = 'normal'
        self._state_color   = 'color'
        self._current_touch = None

        super(MTButton, self).__init__(**kwargs)

        self.register_event_type('on_press')
        self.register_event_type('on_release')
        self.register_event_type('on_state_change')

    def on_press(self, *largs):
        pass

    def on_release(self, *largs):
        pass

    def on_state_change(self, *largs):
        pass

    def on_touch_down(self, touch):
        if not self.collide_point(touch.x, touch.y):
            return False
        if self._current_touch is not None:
            return False
        self._current_touch = touch
        self.state = 'down'
        self.dispatch_event('on_press', touch)
        touch.grab(self)
        return True

    def on_touch_move(self, touch):
        # take the grabbed touch for us.
        if not touch.grab_current == self:
            return False
        return True

    def on_touch_up(self, touch):
        if not touch.grab_current == self:
            return False
        touch.ungrab(self)
        self._current_touch = None
        self.state = 'normal'
        if self.collide_point(*touch.pos):
            self.dispatch_event('on_release', touch)
        return True

    def _get_state(self):
        return self._state
    def _set_state(self, state):
        if self._state == state:
            return False
        self._state = state
        self._state_color = 'color-%s' % state
        if not self._state_color in self.style:
            self.style[self._state_color] = self.style['color']
        self.dispatch_event('on_state_change', state)
        return True
    state = property(_get_state, _set_state,
                     doc='Sets the state of the button, "normal" or "down"')

    def update_label(self):
        pass

    def draw_background(self):
        set_color(*self.style.get('bg-color'))
        drawCSSRectangle(pos=self.pos, size=self.size, style=self.style,
                         state=self.state)

    def draw_label(self, dx=0, dy=0):
        style = self.style
        kwargs = self.kwargs

        if style['draw-text-shadow']:
            tx, ty = style['text-shadow-position']
            kwargs['color'] = style['text-shadow-color']
            super(MTButton, self).draw_label(dx + tx, dy + ty)
            kwargs['color'] = style['color']

        # set color to state color if exist
        kwargs['color'] = style[self._state_color]
        super(MTButton, self).draw_label(dx, dy)


class MTToggleButton(MTButton):
    '''Toggle button implementation, based on MTButton

    :Parameters:
        `group`: str, default to None
            Name of the selection group. If the button have the same groupname
            as other, when his state will be down, all other button will have up
            state.
    '''
    _groups = {}
    def __init__(self, **kwargs):
        kwargs.setdefault('group', None)
        super(MTToggleButton, self).__init__(**kwargs)

        # add the widget to the group if exist.
        self._group = kwargs.get('group')
        if self._group is not None:
            if not self._group in self._groups:
                MTToggleButton._groups[self._group] = SafeList()
            ref = weakref.ref(self)
            MTToggleButton._groups[self._group].append(ref)

    def on_touch_down(self, touch):
        if not self.collide_point(touch.x, touch.y):
            return False
        if self.state == 'down':
            self.state = 'normal'
        else:
            self._reset_group()
            self.state = 'down'
        self.dispatch_event('on_press', touch)
        touch.grab(self)
        return True

    def on_touch_up(self, touch):
        if not touch.grab_current == self:
            return False
        touch.ungrab(self)
        self.state = self.state
        if self.collide_point(*touch.pos):
            self.dispatch_event('on_release', touch)
        return True

    @property
    def group(self):
        '''Return the group of a toggle button'''
        return self._group

    @staticmethod
    def get_widgets(groupname):
        '''Return all widgets in a group'''
        if groupname not in MTToggleButton._groups:
            return []
        return MTToggleButton._groups[groupname]

    @staticmethod
    def get_selected_widgets(groupname):
        '''Return all widgets selected in a group'''
        g = MTToggleButton.get_widgets(groupname)
        return [x() for x in g if x() is not None and x().state == 'down']

    def _set_state(self, x):
        if not super(MTToggleButton, self)._set_state(x):
            return
        self._reset_group()
        self._state = x
        if self._group is None:
            return
        if not self.get_selected_widgets(self.group):
            self._state = 'down'
    state = property(MTButton._get_state, _set_state)

    def _reset_group(self):
        # set all button do 'normal' state
        if self._group is None:
            return
        g = MTToggleButton._groups[self._group]
        for ref in g[:]:
            obj = ref()
            if obj is None:
                g.remove(ref)
                continue
            if obj is self:
                continue

            # change private state, and launch event to be sure.
            if obj._state != 'normal':
                obj._state = 'normal'
                obj.dispatch_event('on_state_change', 'normal')


class MTImageButton(MTButton):
    '''MTImageButton is a enhanced MTButton
    that draw an image instead of a text.

    :Parameters:
        `filename` : str
            Filename of image
        `image` : Image
            Instead of giving a filename, give a Image object
        `scale` : float, default is 1.0
            Scaling of image, default is 100%, ie 1.0
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('scale', 1.0)
        kwargs.setdefault('filename', None)
        kwargs.setdefault('image', None)
        if kwargs.get('filename') is None and kwargs.get('image') is None:
            raise Exception('No filename or image given to MTImageButton')

        super(MTImageButton, self).__init__(**kwargs)
        self.image          = kwargs.get('image')
        self.scale          = kwargs.get('scale')
        self.filename       = kwargs.get('filename')
        self.size           = self.image.size

    def _get_filename(self):
        return self._filename
    def _set_filename(self, filename):
        self._filename = filename
        if filename:
            self.image = pymt.Image(self.filename)
    filename = property(_get_filename, _set_filename)

    def draw(self):
        self.image.pos      = self.pos
        self.image.scale    = self.scale
        s                   = self.image.size
        self.size           = s[0] * self.scale, s[1] * self.scale
        self.image.draw()

########NEW FILE########
__FILENAME__ = buttonmatrix
'''
Button matrix: a lightweight and optimized grid of buttons
'''

__all__ = ('MTButtonMatrix', )

from OpenGL.GL import glTranslatef
from pymt.graphx import set_color, drawRectangle, gx_matrix
from pymt.ui.widgets.widget import MTWidget

class MTButtonMatrix(MTWidget):
    '''ButtonMatrix is a lightweight Grid of buttons/tiles
      collide_point returns which matrix element was hit
      draw_tile(i,j) draws the  tile @ matrix position (i,j)

    :Parameters:
        `matrix_size` : tuple, default to (3, 3)
            Matrix size
        `border` : int, default to 5
            Size of border
        `buttoncolor` : color, default to (.2, .2, .2, 1)
            Color of background
        `downcolor` : color, default to (0, .5, 1, 1)
            Color when the button is pushed

    :Events:
        `on_value_change` (matrix)
            Returns the whole matrix and a button is touched
        `on_press` (row,column,state)
            Returns the state and cell position of a button when touched
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('matrix_size', (3, 3))
        kwargs.setdefault('border', 5)
        kwargs.setdefault('buttoncolor', (0.5, 0.5, 0.5, 1))
        kwargs.setdefault('downcolor', (0, 0.5, 1, 1))
        super(MTButtonMatrix, self).__init__(**kwargs)

        self.register_event_type('on_value_change')
        self.register_event_type('on_press')

        self._matrix_size = kwargs.get('matrix_size')
        self.border = kwargs.get('border')
        self.buttoncolor = kwargs.get('buttoncolor')
        self.downcolor = kwargs.get('downcolor')
        self.matrix = [[0 for i in range(self._matrix_size[1])]
                       for j in range(self._matrix_size[0])]
        self.last_tile = 0

    def on_press(self, *largs):
        pass

    def on_value_change(self, matrix):
        pass

    def reset(self):
        self.matrix = [[0 for i in range(self._matrix_size[1])]
                       for j in range(self._matrix_size[0])]

    def _get_matrix_size(self):
        return self._matrix_size
    def _set_matrix_size(self, size):
        self._matrix_size = size
        self.matrix = [[0 for i in range(self._matrix_size[1])]
                       for j in range(self._matrix_size[0])]
    matrix_size = property(_get_matrix_size, _set_matrix_size,
                           doc='Return size of matrix')

    def draw_tile(self, i, j):
        if self.matrix[i][j] == 0:
            set_color(*self.buttoncolor)
        if self.matrix[i][j]:
            set_color(*self.downcolor)

        with gx_matrix:
            glTranslatef(self.width / self._matrix_size[0] * i + self.x,
                         self.height / self._matrix_size[1] * j + self.y,
                         0)
            s =  (self.width / self._matrix_size[0] - self.border,
                  self.height / self._matrix_size[1] - self.border)
            drawRectangle(size=s)


    def draw(self):
        for i in range (self._matrix_size[0]):
            for j in range (self._matrix_size[1]):
                self.draw_tile(i, j)


    def collide_point(self, x, y):
        i = (x - self.x)/(self.width/self._matrix_size[0])
        j = (y - self.y)/(self.height/self._matrix_size[1])
        if i >= self._matrix_size[0] or j >= self._matrix_size[1]:
            return False # returns false if the click is not within the widget
        if i < 0 or j < 0:
            return False
        else:
            return (int(i), int(j))

    def on_touch_down(self, touch):
        if self.collide_point(touch.x, touch.y):
            i, j = self.collide_point(touch.x, touch.y)
            if self.matrix[i][j]:
                self.matrix[i][j] = 0
            else:
                self.matrix[i][j] = 1
            self.dispatch_event('on_value_change', self.matrix)
            self.dispatch_event('on_press', (i, j, self.matrix[i][j]))
            self.last_tile = (i, j)

    def on_touch_move(self, touch):
        if self.collide_point(touch.x, touch.y) != self.last_tile:
           self.on_touch_down(touch)

########NEW FILE########
__FILENAME__ = circularslider
'''
Circular Slider: Using this you can make circularly shaped sliders
'''


__all__ = ('MTCircularSlider', 'RangeException')

from OpenGL.GL import glTranslatef, glRotatef
from pymt.graphx import drawSemiCircle, gx_matrix, set_color
from pymt.vector import Vector
from pymt.ui.widgets.widget import MTWidget
from math import cos, sin, radians

class RangeException(Exception):
    pass

class MTCircularSlider(MTWidget):
    '''MTCircularSlider is an implementation of a circular scrollbar using
    MTWidget.

    .. warning::
        The widget is drawed from his center. Cause of that, the size of the
        widget will be automaticly adjusted from the radius of the slider.
        Eg: if you ask for a radius=100, the widget size will be 200x200

    :Parameters:
        `min` : int, default is 0
            Minimum value of slider
        `max` : int, default is 100
            Maximum value of slider
        `sweep_angle` : int, default is 90
            The anglular length of the slider you want.
        `value` : int, default is `min`
            Default value of slider
        `thickness` : int, default is 40
            Thickness of the slider
        `radius` : int, default is 200
            Radius of the slider
        `rotation` : int, default is 0
            Start rotation of circle
        `padding` : int
            Padding of content

    :Styles:
        `slider-color` : color
            Color of the slider
        `bg-color` : color
            Background color of the slider

    :Events:
        `on_value_change`
            Fired when slider value is changed
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('min', 0)
        kwargs.setdefault('max', 100)
        kwargs.setdefault('radius', 200)
        kwargs.setdefault('thickness', 40)
        kwargs.setdefault('padding', 3)
        kwargs.setdefault('sweep_angle', 90)
        kwargs.setdefault('rotation', 0)

        have_size = 'size' in kwargs

        super(MTCircularSlider, self).__init__(**kwargs)

        # register event
        self.register_event_type('on_value_change')

        # privates
        self._last_touch    = (0, 0)
        self._slider_angle  = 0.

        self.radius         = kwargs.get('radius')
        self.rotation       = kwargs.get('rotation')
        self.thickness      = kwargs.get('thickness')
        self.padding        = kwargs.get('padding')
        self.sweep_angle    = kwargs.get('sweep_angle')
        self.min            = kwargs.get('min')
        self.max            = kwargs.get('max')

        # calculate radius line, needed for collision
        self._radius_line   = self.radius * sin(radians(self.rotation)), \
                              self.radius * cos(radians(self.rotation))

        # adjust size
        if not have_size:
            self.size       = self.radius * 2, self.radius * 2

        # set value
        self._value         = 0
        self.value          = self.min
        if kwargs.get('value'):
            self.value      = kwargs.get('value')

    def collide_point(self, x, y):
        #A algorithm to find the whether a touch is within a semi ring
        cx, cy = self.center
        point_dist = Vector(self.center).distance((x, y))
        point_angle = Vector(self._radius_line).angle((x - cx, y - cy))
        if point_angle < 0:
            point_angle = 360. + point_angle
        if 0 < point_angle > self.sweep_angle:
            return False
        return self.radius - self.thickness < point_dist <= self.radius

    def on_value_change(self, value):
        pass

    def on_touch_down(self, touch):
        if self.collide_point(touch.x, touch.y):
            touch.userdata['pymt.circularslider'] = self
            self._calculate_angle(*touch.pos)
            return True

    def on_touch_move(self, touch):
        if touch.userdata.get('pymt.circularslider') is self:
            self._calculate_angle(*touch.pos)
            return True

    def _calculate_angle(self, x, y):
        cx, cy = self.center
        self._last_touch = x - cx, y - cy 
        angle = Vector(self._radius_line).angle(self._last_touch)
        if angle < 0:
            angle += 360
        try:
            self.value = angle * (self.max - self.min) / \
                         self.sweep_angle + self.min
            self._slider_angle = angle
        except RangeException:
            pass
        self.dispatch_event('on_value_change', self._value)

    def draw(self):
        super(MTCircularSlider, self).draw()

        # faster calculation if we remove dot
        x, y = self.center
        p = 0, 0
        r = self.radius
        t = self.thickness
        s = self.sweep_angle
        padding = self.padding

        with gx_matrix:
            set_color(*self.style.get('bg-color'))
            glTranslatef(x, y, 0)
            glRotatef(-self.rotation, 0, 0, 1)
            drawSemiCircle(p, r - t, r, 32, 1, 0, s)
            set_color(*self.style.get('slider-color'))
            drawSemiCircle(p, r - t + padding, r - padding,
                           32, 1, 0, self._slider_angle)

    def _get_value(self):
        return self._value
    def _set_value(self, value):
        value = float(value)
        if self.min < value > self.max:
            raise RangeException('Invalid value, not in range min/max')
        self._slider_angle = value / 100. * self.sweep_angle
        self._value = value / 100. * self.max
    value = property(_get_value, _set_value,
        doc='Sets the current value of the slider')

########NEW FILE########
__FILENAME__ = colorpick
'''
Color picker: a simple color picker with 3 slider
'''

__all__ = ('MTColorPicker', )

from pymt.graphx import set_color, drawRectangle, GlDisplayList, \
        drawCSSRectangle
from pymt.ui.widgets.layout import MTBoxLayout
from pymt.ui.widgets.scatter import MTScatterWidget
from pymt.ui.widgets.slider import MTSlider

class MTColorPicker(MTScatterWidget):
    '''MTColorPicker is a implementation of a color picker using MTWidget

    :Parameters:
        `min` : int, default is 0
            Minimum value of slider
        `max` : int, default is 255
            Maximum value of slider
        `targets` : list, default is []
            List of widget to be affected by change
        `values` : list, default is [77, 77, 77]
            Default value of slider for RGB (0-255)
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('min', 0)
        kwargs.setdefault('max', 255)
        kwargs.setdefault('values', [77, 77, 77])
        kwargs.setdefault('targets', [])
        self.dl = GlDisplayList()
        super(MTColorPicker, self).__init__(**kwargs)
        self.size = (130, 290)
        self.targets = kwargs.get('targets')
        self.sliders = [
            MTSlider(min=kwargs.get('min'), max=kwargs.get('max'),
                     size=(30, 200),  style={'slider-color': (1, 0, 0, 1)},
                     cls='colorpicker-slider'),
            MTSlider(min=kwargs.get('min'),  max=kwargs.get('max'),
                     size=(30, 200),  style={'slider-color': (0, 1, 0, 1)},
                     cls='colorpicker-slider'),
            MTSlider(min=kwargs.get('min'),  max=kwargs.get('max'),
                     size=(30, 200),  style={'slider-color': (0, 0, 1, 1)},
                     cls='colorpicker-slider')
        ]
        vbox = MTBoxLayout(spacing=10, padding=10)
        for slider in self.sliders:
            slider.value = 77
            slider.push_handlers(on_value_change=self.update_color)
            vbox.add_widget(slider)
        self.add_widget(vbox)
        self.update_color()
        self.touch_positions = {}

    def apply_css(self, styles):
        super(MTColorPicker, self).apply_css(styles)
        self.dl.clear()

    def draw(self):
        if not self.dl.is_compiled():
            with self.dl:
                set_color(*self.style['bg-color'])
                drawCSSRectangle(size=self.size, style=self.style)

                set_color(*self.current_color)
                drawRectangle(pos=(10, 220), size=(110, 60))
        self.dl.draw()

    def update_color(self, *largs):
        r = self.sliders[0].value / 255.
        g = self.sliders[1].value / 255.
        b = self.sliders[2].value / 255.
        for w in self.targets:
            w.color = (r, g, b, 1)
        self.current_color = (r, g, b, 1.0)
        self.dl.clear()

########NEW FILE########
__FILENAME__ = filebrowser
'''
File browser: a filebrowser view + a popup file browser
'''

__all__ = (
    'MTFileBrowser', 'MTFileBrowserView',
    'MTFileEntryView', 'MTFileListEntryView',
    'MTFileIconEntryView'
)

import os
import re
import pymt
from pymt.utils import curry
from pymt.loader import Loader
from pymt.graphx import drawCSSRectangle, set_color, drawLabel, getLabel
from pymt.ui.factory import MTWidgetFactory
from pymt.ui.widgets.label import MTLabel
from pymt.ui.widgets.button import MTToggleButton
from pymt.ui.widgets.composed.kineticlist import MTKineticList, MTKineticItem
from pymt.ui.widgets.composed.popup import MTPopup

# Search icons in data/icons/filetype
icons_filetype_dir = os.path.join(pymt.pymt_data_dir, 'icons', 'filetype')

class FileTypeFactory:
    '''
    FileType Factory: Maintains a Dictionary of all filetypes and its icons.
    '''

    __filetypes__ = {}

    @staticmethod
    def register(types, iconpath):
        '''If a user wants to register a new file type or replace a existing
        icon, he can use register method as follows ::

            FileTypeFactory.register(['type1','type2'],"path_to_icon")
        '''
        for ftype in types:
            FileTypeFactory.__filetypes__[ftype] = iconpath

    @staticmethod
    def list():
        '''Return all the filetypes availables'''
        return FileTypeFactory.__filetypes__

    @staticmethod
    def get(ftype):
        '''Return an image for the current type. If type is not found, this
        will return the image for 'unknown' type.'''
        if ftype in FileTypeFactory.__filetypes__:
            return FileTypeFactory.__filetypes__[ftype]
        else:
            return FileTypeFactory.__filetypes__['unknown']

class MTFileEntryView(MTKineticItem):
    '''Base view class for every file entry'''
    def __init__(self, **kwargs):
        super(MTFileEntryView, self).__init__(**kwargs)
        self.type_image = None
        self.filename   = kwargs.get('filename')
        self.browser    = kwargs.get('browser')
        self.label_txt  = kwargs.get('label')
        self.selected   = False

        self.get_image_for_filename()

    def get_image_for_filename(self):
        '''Return image for current filename'''
        if os.path.isdir(self.filename):
            self.type_image = FileTypeFactory.get('folder')
        else:
            ext = self.label_txt.split('.')[-1]
            self.type_image = FileTypeFactory.get(ext)

    def striptext(self, text, number=10):
        '''Strip a text to `number` characters, without space/tab'''
        return str(text)[:number].strip("\t ")


class MTFileListEntryView(MTFileEntryView):
    '''A list-view for file entries'''
    def __init__(self, **kwargs):
        super(MTFileListEntryView, self).__init__(**kwargs)
        self.height         = 25
        self.image          = Loader.image(self.type_image)
        self.image.scale    = 0.5
        if self.browser._w_limit is None:
            self.browser.w_limit    = 1
        self.font_size = self.style['font-size']

    def draw(self):
        pos = self.image.width, self.y
        # Max number of chars for this entry's label
        max_chars = 20
        # Simple trick to get the maximum label width for the current font size
        self.width = getLabel('W'*max_chars, font_size=self.font_size).width
        if self.selected:
            selected_color = self.style.get('selected-color', (0.4,) * 4)
            set_color(*selected_color)
            drawCSSRectangle(pos=(0, self.y), size=self.size, style=self.style)
        drawLabel(label=self.striptext(self.label_txt, max_chars),
                  pos=pos, anchor_x='left', anchor_y='bottom',
                  font_size=self.style.get('font-size'),
                  color=self.style.get('color'))
        self.image.pos = (0, self.y)
        self.image.draw()


class MTFileIconEntryView(MTFileEntryView):
    '''An icon-view for file entries'''
    def __init__(self, **kwargs):
        super(MTFileIconEntryView, self).__init__(**kwargs)
        self.size           = (80, 80)
        self.image          = Loader.image(self.type_image)
        if self.browser._w_limit is None:
            self.browser.w_limit = 4

    def draw(self):
        if self.selected:
            selected_color = self.style.get('selected-color', (0.4,) * 4)
            set_color(*selected_color)
            drawCSSRectangle(pos=self.pos, size=self.size, style=self.style)
        pos = int(self.x + self.width / 2.), int(self.y + 10)
        drawLabel(label=self.striptext(self.label_txt, 10), pos=pos)
        self.image.x        = self.x + int(self.image.width / 2) - 5
        self.image.y        = self.y + int(self.image.height / 2) - 5
        self.image.draw()


class MTFileBrowserView(MTKineticList):
    '''A base view of filebrowser. Can be plugged in any widget.

    :Parameters:
        `path` : str, default to None
            Default path to load
        `show_hidden` : bool, default to False
            Show hidden files
        `view` : class, default to MTFileIconEntryView)
            Class to use for creating a entry view
        `filters` : list, default to []
            List of regex to use for file filtering.
            Directories are not affected by filters.
        `multipleselection` : bool, default to False
            Allow multiple selection of files
        `invert_order` : bool, default to False
            Indicates whether the order the files are displayed in should be reversed

    :Events:
        `on_path_change` : (str)
            Fired when path changed
        `on_selection_change` : list of str
            Fired when selection change
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('deletable', False)
        kwargs.setdefault('searchable', False)
        kwargs.setdefault('title', None)
        kwargs.setdefault('path', None)
        kwargs.setdefault('show_hidden', False)
        kwargs.setdefault('view', MTFileIconEntryView)
        kwargs.setdefault('filters', [])
        kwargs.setdefault('multipleselection', False)

        self._w_limit = kwargs.get('w_limit', None)

        super(MTFileBrowserView, self).__init__(**kwargs)

        self.register_event_type('on_path_change')
        self.register_event_type('on_selection_change')

        self._selection     = []
        self._path          = '(invalid path)'
        self.show_hidden    = kwargs.get('show_hidden')
        self.view           = kwargs.get('view')
        self.filters        = kwargs.get('filters')
        self.multipleselection = kwargs.get('multipleselection')
        self.invert_order = kwargs.get('invert_order', False)

        # only at the end, set path to the user path
        self.path           = kwargs.get('path')

    def update(self):
        '''Update the content of view. You must call this function after
        any change of a property. (except path.)'''
        # remove all actual entries
        self.clear()
        self.selection = []

        children = []
        listfiles = os.listdir(self.path)
        listfiles.sort()

        # add each file from directory
        # only files are filtred with filters
        for name in reversed(listfiles):
            filename = os.path.join(self.path, name)

            # filter on hidden file if requested
            if not self.show_hidden:
                if name != '..' and name[0] == '.':
                    continue

            if os.path.isdir(filename):
                continue

            # filtering
            if len(self.filters):
                match = False
                for regex in self.filters:
                    if re.match(regex, name):
                        match = True
                if not match:
                    continue

            # add this file as new file.
            children.append(self.view(
                label=name, filename=filename,
                browser=self, size=self.size
            ))

        # second time, do directories
        for name in reversed(listfiles):
            filename = os.path.join(self.path, name)

            # filter on hidden file if requested
            if not self.show_hidden:
                if name != '..' and name[0] == '.':
                    continue

            if not os.path.isdir(filename):
                continue

            # add this file as new file.
            children.append(self.view(
                label=name, filename=filename,
                browser=self, size=self.size
            ))

        # add always "to parent"
        children.append(self.view(
            label='..', filename=os.path.join(self.path, '../'),
            browser=self, size=self.size
        ))

        # attach handlers
        for child in children:
            child.push_handlers(on_press=curry(self._on_file_selected, child))
            self.add_widget(child, front=self.invert_order)

    def _get_path(self):
        return self._path
    def _set_path(self, value):
        if value is None:
            return
        if value == self._path:
            return
        # get absolute path
        value = os.path.abspath(value)
        if not os.path.exists(value):
            return
        self._path = value
        # update the view
        self.update()
        # and dispatch the new path
        self.dispatch_event('on_path_change', self._path)
    path = property(_get_path, _set_path, doc='Change current path')

    def _on_file_selected(self, fileview, touch):
        # auto change for directory
        filename = fileview.filename
        if os.path.isdir(filename) and touch.is_double_tap:
            # Enter that directory
            self.path = filename
            # Forget about any selection we did before
            self.selection = []
            return

        # select file ?
        selection = self.selection[:]
        if not fileview.selected:
            if not self.multipleselection:
                for child in self.children:
                    child.selected = False
            fileview.selected = True
            if filename not in selection:
                if not self.multipleselection:
                    selection = []
                selection.append(filename)
        elif self.multipleselection:
            fileview.selected = False
            if filename in selection:
                selection.remove(filename)
        self.selection = selection

    def _get_selection(self):
        return self._selection
    def _set_selection(self, x):
        if x == self._selection:
            return
        self._selection = x
        self.dispatch_event('on_selection_change', self._selection)
    selection = property(
        _get_selection, _set_selection,
        doc='Get selected filenames')


    def on_selection_change(self, filelist):
        pass

    def on_path_change(self, path):
        pass


class MTFileBrowserToggle(MTToggleButton):
    '''Internal Button for FileBrowser'''
    def __init__(self, **kwargs):
        kwargs.setdefault('label', '')
        kwargs.setdefault('cls', 'popup-button')
        super(MTFileBrowserToggle, self).__init__(**kwargs)
        self.icon = kwargs.get('icon')

    def _set_icon(self, value):
        self.image = pymt.Image(os.path.join(
            pymt.pymt_data_dir, 'icons', value))
    icon = property(fset=_set_icon)

    def draw(self):
        super(MTFileBrowserToggle, self).draw()
        self.image.x = self.x + (self.width - self.image.width) / 2.
        self.image.y = self.y + (self.height - self.image.height) / 2.
        self.image.draw()


class MTFileBrowser(MTPopup):
    '''This Widget provides a filebrowser interface to access the files in your
    system. You can select multiple files at a time and process them together.

    :Parameters:
        `title` : str, default to 'Open a file'
            The title for what reason the filebrowser will be used
        `size` : list, default to (350, 300)
            Window size of the browser and its container
        `filters` : list, default to []
            List of regex to use for file filtering.
            Directories are not affected by filters.
        `multipleselection` : bool, default to False
            Allow multiple selection of files
        `view` : reference to subclass of MTFileEntryView
            Indicates the default view that is used to display icons and filenames
        `invert_order` : bool, default to False
            Indicates whether the order the files are displayed in should be reversed

    :Events:
        `on_select`
            This event is generated whenever the user press submit button.
            A list of files selected are also passed as a parameter to this function
    '''

    def __init__(self, **kwargs):
        kwargs.setdefault('title', 'Open a file')
        kwargs.setdefault('label_submit', 'Open')
        kwargs.setdefault('size', (350, 500))
        kwargs.setdefault('filters', [])
        kwargs.setdefault('multipleselection', False)
        kwargs.setdefault('view', MTFileIconEntryView)
        kwargs.setdefault('invert_order', False)
        kwargs.setdefault('show_toggles', True)
        super(MTFileBrowser, self).__init__(**kwargs)

        self.register_event_type('on_select')

        # Title
        self.w_path = MTLabel(label='.', autoheight=True, size=(self.width, 30),
                              color=(.7, .7, .7, .5))
        #self.add_widget(self.w_path)

        # File View
        self.view = MTFileBrowserView(size_hint=(1, 1), filters=kwargs.get('filters'),
                multipleselection=kwargs.get('multipleselection'), view=kwargs.get('view'),
                invert_order=kwargs.get('invert_order'))
        self.view.push_handlers(on_path_change=self._on_path_change)
        self.add_widget(self.view, True)

        # Update listing
        self.view.path = '.'

        # Show hidden files
        if kwargs['show_toggles']:
            self.w_hiddenfile = MTFileBrowserToggle(icon='filebrowser-hidden.png', size=(40, 40))
            self.w_hiddenfile.push_handlers(on_press=curry(self._toggle_hidden, self.w_hiddenfile))
            self.l_buttons.add_widget(self.w_hiddenfile)

            # Select view
            self.w_view = MTFileBrowserToggle(icon='filebrowser-iconview.png', size=(40, 40))
            self.w_view.push_handlers(on_press=curry(self._toggle_view, self.w_view))
            self.l_buttons.add_widget(self.w_view, True)

    def _toggle_hidden(self, btn, *largs):
        if btn.state == 'down':
            self.view.show_hidden = True
        else:
            self.view.show_hidden = False
        self.view.update()

    def _toggle_view(self, btn, *largs):
        if self.view.view is MTFileIconEntryView:
            btn.icon = 'filebrowser-iconview.png'
            self.view.view = MTFileListEntryView
        else:
            btn.icon = 'filebrowser-listview.png'
            self.view.view = MTFileIconEntryView
        self.view.update()

    def _on_path_change(self, path):
        if len(path) > int(self.size[0]/8) :
            folders = path.split(os.path.sep)
            temp_label = ''
            i = -1
            max_len = int(self.size[0]/8)-8
            while len(temp_label) < max_len:
                temp_label = folders[i] + os.path.sep + temp_label
                i -= 1
            self.w_path.label = '..' + os.path.sep + temp_label
        else:
            self.w_path.label = path

    def on_submit(self):
        self.dispatch_event('on_select', self.view.selection)
        self.reset_selection()
        if self.exit_on_submit:
            self.close()
        else:
            self.hide()

    def on_cancel(self):
        self.reset_selection()
        if self.exit_on_submit:
            self.close()
        else:
            self.hide()

    def on_select(self, filelist):
        pass

    def reset_selection(self):
        self.view.selection = []
        self.view.update()

# Register Default File types with their icons
FileTypeFactory.register(['jpg', 'jpeg'],
    os.path.join(icons_filetype_dir, 'image-jpeg.png'))
FileTypeFactory.register(['svg'],
    os.path.join(icons_filetype_dir, 'image-svg.png'))
FileTypeFactory.register(['png'],
    os.path.join(icons_filetype_dir, 'image-png.png'))
FileTypeFactory.register(['bmp'],
    os.path.join(icons_filetype_dir, 'image-bmp.png'))
FileTypeFactory.register(['mpg', 'mpeg', 'avi', 'mkv', 'flv'],
    os.path.join(icons_filetype_dir, 'video.png'))
FileTypeFactory.register(['folder'],
    os.path.join(icons_filetype_dir, 'folder.png'))
FileTypeFactory.register(['unknown'],
    os.path.join(icons_filetype_dir, 'unknown.png'))

# Register all bases widgets
MTWidgetFactory.register('MTFileBrowser', MTFileBrowser)
MTWidgetFactory.register('MTFileBrowserView', MTFileBrowserView)

########NEW FILE########
__FILENAME__ = innerwindow
'''
Inner window: a lightweight window with fullscreen and resize ability
'''

__all__ = ('MTInnerWindow', )

import os
from OpenGL.GL import glMultMatrixf
from pymt import pymt_icons_dir
from pymt.graphx import gx_matrix, drawRectangle, set_color, gx_stencil, \
        stencilUse, drawRoundedRectangle
from pymt.utils import SafeList
from pymt.ui.widgets.rectangle import MTRectangularWidget
from pymt.ui.widgets.scatter import MTScatterWidget
from pymt.ui.widgets.button import MTImageButton, MTButton
from pymt.ui.widgets.widget import MTWidget

class MTInnerWindowContainer(MTRectangularWidget):
    '''Container used to simulate a window for children of MTInnerWindow.

    .. note::
        Don't use this class directly !
    '''
    def __init__(self, **kwargs):
        super(MTInnerWindowContainer, self).__init__(**kwargs)

    def add_on_key_press(self, *largs, **kwargs):
        return self.parent.parent.get_parent_window().add_on_key_press(*largs, **kwargs)
    def remove_on_key_press(self, *largs, **kwargs):
        return self.parent.parent.get_parent_window().remove_on_key_press(*largs, **kwargs)
    def get_on_key_press(self, *largs, **kwargs):
        return self.parent.parent.get_parent_window().get_on_key_press(*largs, **kwargs)

    def add_on_text(self, *largs, **kwargs):
        return self.parent.parent.get_parent_window().add_on_text(*largs, **kwargs)
    def remove_on_text(self, *largs, **kwargs):
        return self.parent.parent.get_parent_window().remove_on_text(*largs, **kwargs)
    def get_on_text(self, *largs, **kwargs):
        return self.parent.parent.get_parent_window().get_on_text(*largs, **kwargs)

    def add_on_text_motion(self, *largs, **kwargs):
        return self.parent.parent.get_parent_window().add_on_text_motion(*largs, **kwargs)
    def remove_on_text_motion(self, *largs, **kwargs):
        return self.parent.parent.get_parent_window().remove_on_text_motion(*largs, **kwargs)
    def get_on_text_motion(self, *largs, **kwargs):
        return self.parent.parent.get_parent_window().get_on_text_motion(*largs, **kwargs)

    def add_on_text_motion_select(self, *largs, **kwargs):
        return self.parent.parent.get_parent_window().add_on_text_motion_select(*largs, **kwargs)
    def remove_on_text_motion_select(self, *largs, **kwargs):
        return self.parent.parent.get_parent_window().remove_on_text_motion_select(*largs, **kwargs)
    def get_on_text_motion_select(self, *largs, **kwargs):
        return self.parent.parent.get_parent_window().get_on_text_motion_select(*largs, **kwargs)


class MTInnerWindow(MTScatterWidget):
    '''InnerWindow are a wrapper to render an application inside another
    application, and work like a multitouch window manager. With innerwindow,
    you can move / rotate / fullscreen an application.

    Checkout the `desktop` example to check how it work !

    :Parameters:
        `control_scale`: float, default to 1.0
            Scale of controls widget. 1.0 mean 100%.

    :Styles:
        `bg-color`
            Background color of innerwindow + border
        `bg-color-move`
            Background color when only move (one touch)
        `bg-color-full`
            Background color when rotate/scale/move (multitouch)
        `border-width`
            Size of border
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('control_scale', 1.0)
        super(MTInnerWindow, self).__init__(**kwargs)
        self.container = MTInnerWindowContainer(pos=(0, 0), size=self.size)
        super(MTInnerWindow, self).add_widget(self.container)
        self.control_scale = kwargs.get('control_scale')
        self.setup_controls()

    def setup_controls(self):
        self.controls = MTWidget()
        self.controls.parent = self

        self.btn_fullscreen = MTImageButton(
            filename=pymt_icons_dir + 'fullscreen.png',
            scale=self.control_scale, cls='innerwindow-fullscreen')
        self.btn_fullscreen.push_handlers(on_release=self.fullscreen)
        self.controls.add_widget(self.btn_fullscreen)

        self.btn_close = MTImageButton(
            filename=pymt_icons_dir + 'stop.png',
            scale=self.control_scale, cls='innerwindow-close')
        self.btn_close.push_handlers(on_release=self.close)
        self.controls.add_widget(self.btn_close)

        self.update_controls()

    def fullscreen(self, *largs, **kwargs):
        root_win = self.parent.get_parent_window()

        # save state for restore
        self.old_children = root_win.children
        self.old_size = self.size

        # set new children
        root_win.children = SafeList()
        root_win.add_widget(self.container)

        btn_unfullscreen = MTButton(pos=(root_win.width-50, root_win.height-50),
                                    size=(50, 50), label='Back')
        btn_unfullscreen.push_handlers(on_release=self.unfullscreen)
        root_win.add_widget(btn_unfullscreen)
        self.size = root_win.size
        self.container.size = self.size

    def unfullscreen(self, *largs, **kwargs):
        # restore old widget
        root_win = self.parent.get_parent_window()
        root_win.children = self.old_children

        # reset container parent
        self.container.parent = self

        # set old size
        self.size = self.old_size
        self.container.size = self.size

    def close(self, touch):
        self.parent.remove_widget(self)

    def add_widget(self, w):
        self.container.add_widget(w)

    def remove_widget(self, w):
        self.container.remove_widget(w)

    def get_parent_window(self):
        return self.container

    def get_scaled_border(self):
        return self.style.get('border-width') * (1.0 / self.scale)

    def update_controls(self):
        scaled_border = self.get_scaled_border()
        center_x = self.width / 2
        center_y = - scaled_border
        for button in self.controls.children:
            button.scale = self.control_scale / self.scale
        self.btn_fullscreen.pos = \
                center_x - (self.btn_fullscreen.width) - 2, \
                center_y - (self.btn_fullscreen.height / 2)
        self.btn_close.pos = \
                center_x + 2, \
                center_y - (self.btn_close.height / 2)

    def on_touch_down(self, touch):
        touch.push()
        touch.apply_transform_2d(super(MTInnerWindow, self).to_local)
        if self.controls.dispatch_event('on_touch_down', touch):
            touch.pop()
            touch.grab(self)
            return True
        touch.pop()

        if super(MTInnerWindow, self).on_touch_down(touch):
            return True

    def on_touch_move(self, touch):
        if touch.grab_current == self:
            touch.push()
            touch.apply_transform_2d(super(MTInnerWindow, self).to_local)
            if self.controls.dispatch_event('on_touch_move', touch):
                touch.pop()
                return True
            touch.pop()
        return super(MTInnerWindow, self).on_touch_move(touch)

    def on_touch_up(self, touch):
        if touch.grab_current == self:
            touch.push()
            touch.apply_transform_2d(super(MTInnerWindow, self).to_local)
            if self.controls.dispatch_event('on_touch_up', touch):
                touch.pop()
                touch.ungrab(self)
                return True
            touch.pop()
        return super(MTInnerWindow, self).on_touch_up(touch)

    def collide_point(self, x, y):
        scaled_border = self.get_scaled_border()
        local_coords = super(MTInnerWindow, self).to_local(x, y)
        left, right = -scaled_border, self.width + scaled_border
        bottom, top = -scaled_border, self.height + scaled_border
        if local_coords[0] > left and local_coords[0] < right \
           and local_coords[1] > bottom and local_coords[1] < top:
            return True
        else:
            return False

    def draw(self):
        # select color from number of touch
        if len(self._touches) == 0:
            set_color(*self.style.get('bg-color'))
        elif len(self._touches) == 1:
            set_color(*self.style.get('bg-color-move'))
        else:
            set_color(*self.style.get('bg-color-full'))

        # draw border
        scaled_border = self.get_scaled_border()
        self.update_controls()
        drawRoundedRectangle(
            pos=(-scaled_border, -scaled_border),
            size=(self.width+scaled_border*2, self.height+scaled_border*2),
            radius=15. / self.scale
        )

        # draw control background
        control_width = self.btn_fullscreen.width + self.btn_close.width
        drawRoundedRectangle(
            pos=((self.width/2)-(scaled_border + control_width / 2), -scaled_border * 2),
            size=(scaled_border*2 + control_width, scaled_border),
            radius=15. / self.scale,
            corners=(True, True, False, False)
        )

    def on_draw(self):
        with gx_matrix:
            glMultMatrixf(self.transform_gl)

            self.draw()
            self.controls.dispatch_event('on_draw')

            # use stencil for container
            with gx_stencil:
                drawRectangle((0, 0), size=self.size)
                stencilUse()
                self.container.dispatch_event('on_draw')

    def on_move(self, x, y):
        # no move on children
        pass

    def on_resize(self, w, h):
        # no resize of children
        pass

########NEW FILE########
__FILENAME__ = kineticlist
'''
Kinetic List: Custom list with kinetic interaction
'''

__all__ = (
    'MTKineticList', 'MTKineticObject',
    'MTKineticItem', 'MTKineticImage'
)

import pymt
from pymt.config import pymt_config
from pymt.utils import boundary
from pymt.graphx import set_color, drawRectangle, drawCSSRectangle
from pymt.base import getFrameDt
from pymt.utils import SafeList
from pymt.ui.widgets.stencilcontainer import MTStencilContainer
from pymt.ui.widgets.widget import MTWidget
from pymt.ui.widgets.button import MTButton, MTToggleButton, MTImageButton
from pymt.ui.animation import Animation
from pymt.core.text import Label

class MTKineticList(MTStencilContainer):
    '''This is a kinetic container widget, that allows you to make
    a kinetic list scrolling in either direction.

    Some parameters are customizable in global configuration ::

        [widgets]
        list_friction = 10
        list_trigger_distance = 5

    :Parameters:
        `align` : string, default to 'center'
            Alignement of widget inside the row (or col). Can be
            one of 'center', 'left', 'right'
        `friction` : float, defaults to 10
            The Pseudo-friction of the pseudo-kinetic scrolling.
            Formula for friction is ::

                acceleration = 1 + friction * frame_delta_time

        `padding_x` : int, defaults to 4
            The spacing between scrolling items on the x axis
        `padding_y` : int, defaults to 4
            The spacing between scrolling items on the y axis
        `w_limit` : int, defaults to 1
            The limit of items that will appear horizontally.
            When this is set to a non-zero value the width(in
            terms of items in the kinetic list) will be w_limit,
            and the height will continually expand.
        `h_limit` : int, defaults to 0
            Exect opposite of w_limit.  If I didn't make either
            this or w_limit clear go bug xelapond
        `do_x` : bool, defaults to False
            Enable scrolling on the X axis
        `do_y` : bool, defaults to True
            Enable scrolling on the Y axis
        `title` : string, defaults to <Title Goes Here>
            Sets the title of the widget, which appears in 20
            point font at the top
        `deletable` : bool, defaults to True
            When enabled it allows you to delete children by
            entering delete mode(red button in upper left)
        `searchable` : bool, defaults to True
            When enabled it allows you to enter search mode
            and filter items
        `trigger_distance` : int, default to 3
            Maximum trigger distance to dispatch event on children
            (this mean if you move too much, trigger will not happen.)

    :Styles:
        `bg-color` : color
             Background color of the widget
        `scrollbar-size` : int
            Size of scrollbar in pixel (use 0 to disable it.)
        `scrollbar-color` : color
            Color of scrollbar
        `scrollbar-margin` : int int int int
            Margin top/right/bottom/left of scrollbar (left are not used.)

    :Events:
        `on_delete` (child)
            Fired when an item gets deleted.
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('padding_x', 4)
        kwargs.setdefault('padding_y', 4)
        kwargs.setdefault('w_limit', 1)
        kwargs.setdefault('h_limit', 0)
        kwargs.setdefault('do_x', False)
        kwargs.setdefault('do_y', True)
        kwargs.setdefault('title', 'No title')
        kwargs.setdefault('deletable', True)
        kwargs.setdefault('searchable', True)
        kwargs.setdefault('align', 'center')

        super(MTKineticList, self).__init__(**kwargs)

        self.register_event_type('on_delete')

        self._a_sinput_out  = None
        self._a_sinput_in   = None
        self.title          = Label('')
        self.sb             = None
        self.sinput         = None

        self.do_x       = kwargs.get('do_x')
        self.do_y       = kwargs.get('do_y')
        self.titletext  = kwargs.get('title')
        self.deletable  = kwargs.get('deletable')
        self.searchable = kwargs.get('searchable')
        self.padding_x  = kwargs.get('padding_x')
        self.padding_y  = kwargs.get('padding_y')
        self.w_limit    = kwargs.get('w_limit')
        self.h_limit    = kwargs.get('h_limit')
        self.align      = kwargs.get('align')
        self.trigger_distance = kwargs.get('trigger_distance',
            pymt_config.getint('widgets', 'list_trigger_distance'))
        self.friction = kwargs.get('friction',
            pymt_config.getint('widgets', 'list_friction'))

        if self.w_limit and self.h_limit:
            raise Exception('You cannot limit both axes')
        elif not(self.w_limit or self.h_limit):
            raise Exception('You must limit at least one axis')

        # How far to offset tself.deletable and he axes(used for scrolling/panning)
        self.xoffset = 0
        self.yoffset = 0
        # X and Y translation vectors for the kinetic movement
        self.vx = 0
        self.vy = 0
        # List of all children, whatever will be the search
        self.pchildren = []
        # For extra blob stats
        self.touch = {}
        # Holds widgets not a part of the scrolling(search button, etc)
        self.widgets = []
        self._last_content_size = 0
        self._scrollbar_index = 0
        self._scrollbar_size = 0

        # create the UI part.
        self._create_ui()

    def _create_ui(self):
        # Title Text
        if self.titletext is not None:
            self.title = Label(
                font_size=18,
                bold=True,
                anchor_x='center',
                anchor_y='center',
                label=self.titletext)
            self.title.x = self.width/2 + self.x
            self.title.y = self.height - 20 + self.y

        # Delete Button
        if self.deletable:
            self.db = MTToggleButton(
                label='X',
                pos=(self.x + self.width - 80, self.y + self.height - 40),
                size=(80, 40),
                cls='kineticlist-delete')
            self.db.push_handlers(on_press=self.toggle_delete)
            self.widgets.append(self.db)

        # Search Button and Input Text Area
        if self.searchable:
            self.sb = MTToggleButton(
                label='S',  #Button
                pos=(self.x, self.y + self.width - 40),
                size=(80, 40),
                cls='kineticlist-search')

            self.sb.push_handlers(on_press=self.toggle_search)
            self.sb.parent = self
            self.widgets.append(self.sb)

            self.sinput = pymt.MTTextInput(pos=
                (self.x, self.y + self.height - 40), size=(80, 40),
                style={'font-size': 20})
            self.sinput.parent = self
            self.sinput.push_handlers(on_text_change=self.apply_filter)
            self.widgets.insert(0, self.sinput)

            # Animations to hide and show the search text input box
            self._a_sinput_in = Animation(y=self.y + self.height - 40 -
                                         self.sinput.size[1], duration=0.5,
                                         f='ease_out_cubic')
            self._a_sinput_out = Animation(y=self.y + self.height -
                                          self.sinput.size[1], duration=0.5,
                                         f='ease_out_cubic')

    def on_delete(self, child):
        pass

    def clear(self):
        self.children = SafeList()
        self.pchildren = SafeList()
        self.xoffset = self.yoffset = 0

    def add_widget(self, widget, **kwargs):
        super(MTKineticList, self).add_widget(widget, **kwargs)
        self.pchildren.append(widget)

    def remove_widget(self, widget):
        super(MTKineticList, self).remove_widget(widget)
        if widget in self.pchildren:
            self.pchildren.remove(widget)
        self.dispatch_event('on_delete', widget)

    def toggle_delete(self, touch):
        '''Toggles the delete buttons on items
        Attached to the on_press handler of the delete button(self.db)
        '''
        if self.db.state == 'down':
            for child in self.children[:]:
                child.show_delete()
        else:
            for child in self.children[:]:
                child.hide_delete()

    def toggle_search(self, touch):
        '''Toggles the search area
        Attached to the on_press handler of self.sb(the green search button)
        '''
        if self.sb.state == 'down':
            self._a_sinput_in.animate(self.sinput)
        else:
            try:
                self.sinput.hide_keyboard()
            except:
                # There isn't a keyboard, so it throws a ValueError
                pass
            self.sinput.label = ''
            self._a_sinput_out.animate(self.sinput)

    def apply_filter(self, text):
        '''Applies the filter to the current children set'''
        self.search(text, 'label')
        #Move them so you don't have to scroll up to see them
        self.yoffset = self.padding_y
        self.xoffset = self.padding_x

    def filter(self, pattern, attr):
        '''Given an attribute of the children, and a pattern, return
        a list of the children with which pattern is in attr
        '''
        return filter(lambda c: pattern in str(getattr(c, attr)), self.pchildren)

    def search(self, pattern, attr):
        '''Apply a search pattern to the current set of children'''
        result = self.filter(pattern, attr)
        self.children.clear()
        for item in result:
            self.children.append(item)

    def endsearch(self):
        '''Resets the children set to the full set'''
        self.children.clear()
        for item in self.pchildren:
            self.children.append(item)

    def _get_total_width(self, items, axis):
        '''Given a list of items and an axis, return the space
        they take up(in pixels)
        '''
        total = 0
        if axis == 'width':
            for item in items:
                total += (item.width + self.padding_x)
        elif axis == 'height':
            for item in items:
                total += (item.height + self.padding_y)

        return total

    def goto_head(self):
        if not self.h_limit:
            self.yoffset = -self._get_total_width(self.children, 'height')/self.w_limit + self.size[1] - 100
        else:
            self.xoffset = self._get_total_width(self.children, 'width')/self.h_limit + self.size[0] - 100

    def do_layout(self):
        '''Apply layout to all the items'''

        t = index = 0

        # adapt value for direction
        w2          = self.width / 2.
        h2          = self.height / 2.
        inverse     = 0
        limit       = self.w_limit
        width_attr  = 'width'
        height_attr = 'height'
        xoffset     = self.xoffset
        sx          = self.x
        y           = self.y + self.yoffset
        padding_x   = self.padding_x
        padding_y   = self.padding_y

        # inverse
        if not self.w_limit:
            inverse     = 1
            limit       = self.h_limit
            width_attr  = 'height'
            height_attr = 'width'
            xoffset     = self.yoffset
            y           = self.x + self.xoffset
            padding_x   = self.padding_y
            padding_y   = self.padding_x
            w2, h2      = h2, w2
            sx          = self.y

        # calculate size of actual content
        size = 0
        for i in xrange(len(self.children)):
            if i % limit == 0:
                maxrange = min(i + limit, len(self.children))
                childrens = [self.children[z] for z in range(i, maxrange)]
                h = max((c.__getattribute__(height_attr) for c in childrens))
                size += h + padding_y
        self._last_content_size = size

        # add little padding for good looking.
        y += padding_y
        ny = y

        # recalculate position for each children
        for child in self.children[:]:

            # each row, calculate the height, advance y and reset x
            if index % limit == 0:

                # set y axis to the previous calculated position
                y = ny

                # get children in the row
                maxrange = min(t + limit, len(self.children))
                childrens = [self.children[z] for z in range(t, maxrange)]

                # take the largest height in the current row
                if len(childrens):
                    h = max((c.__getattribute__(height_attr) for c in childrens))
                else:
                    h = 0

                # prepare the y axis for next loop
                ny = y + h + padding_y

                # reset x for this row.
                if self.align == 'center':
                    x = sx + w2 + xoffset - \
                        (self._get_total_width(childrens, width_attr) / 2.)
                elif self.align == 'left':
                    x = 0
                elif self.align == 'right':
                    x = getattr(self, width_attr) - getattr(child, width_attr) - xoffset
                t += limit

            # reposition x
            if not inverse:
                child.kx = x + padding_x
                child.ky = y
            else:
                child.ky = x + padding_x
                child.kx = y
            x += child.__getattribute__(width_attr) + padding_x

            # Increment index
            index += 1

    def on_touch_down(self, touch):
        if not self.collide_point(touch.x, touch.y):
            return

        # ok, it's a touch for us. grab it !
        touch.grab(self)

        # first, check if own widget take the touch
        for w in reversed(self.widgets[:]):
            if w.on_touch_down(touch):
                return True

        # initiate kinetic movement.
        self.vx = self.vy = 0
        self.touch[touch.id] = {
            'ox': touch.x,
            'oy': touch.y,
            'xmot': 0,
            'ymot': 0,
            'travelx' : 0, #How far the blob has traveled total in the x axis
            'travely' : 0, #^
        }
        return True

    def on_touch_move(self, touch):
        # accept only grabbed touch by us
        if touch.grab_current != self:
            return

        # ok, if it's not a kinetic movement,
        # dispatch to children
        if touch.id not in self.touch:
            for w in reversed(self.widgets[:]):
                if w.on_touch_move(touch):
                    return True
            return

        # it's a kinetic movement, process it.
        t = self.touch[touch.id]
        t['xmot'] = touch.x - t['ox']
        t['ymot'] = touch.y - t['oy']
        t['ox'] = touch.x
        t['oy'] = touch.y
        t['travelx'] += abs(t['xmot'])
        t['travely'] += abs(t['ymot'])
        self.xoffset += t['xmot'] * self.do_x
        self.yoffset += t['ymot'] * self.do_y
        self.ensure_bounding()

    def on_touch_up(self, touch):
        # accept only grabbed touch by us
        if touch.grab_current != self:
            return

        # it's an up, ungrab us !
        touch.ungrab(self)

        if touch.id not in self.touch:
            for w in reversed(self.widgets[:]):
                if w.on_touch_up(touch):
                    return True
            return

        t = self.touch[touch.id]
        self.vx = t['xmot']
        self.vy = t['ymot']

        # check if we can transmit event to children
        if (self.do_x and t['travelx'] > self.trigger_distance) or \
           (self.do_y and t['travely'] > self.trigger_distance):
            return True

        # ok, the trigger distance is enough, we can dispatch event.
        # will not work if children grab the touch in down state :/
        for child in reversed(self.children[:]):
            must_break = child.dispatch_event('on_touch_down', touch)
            old_grab_current = touch.grab_current
            touch.grab_current = child
            child.dispatch_event('on_touch_up', touch)
            touch.grab_current = old_grab_current
            if must_break:
                break
        return True

    def ensure_bounding(self):
        size = float(self._last_content_size)
        if size <= 0:
            return

        self._scrollbar_size = 1
        self._scrollbar_index = 0

        if self.do_y:
            if size < self.height:
                self.yoffset = 0
            else:
                self.yoffset = boundary(self.yoffset, -size + self.height, 0)
                self._scrollbar_size = self.height / size
                self._scrollbar_index = -self.yoffset / size
        elif self.do_x:
            if size < self.width:
                self.xoffset = 0
            else:
                self.xoffset = boundary(self.xoffset, -size + self.width, 0)
                self._scrollbar_size = self.width / size
                self._scrollbar_index = -self.xoffset / size

    def process_kinetic(self):
        '''Apply kinetic movement to all the items'''
        dt = getFrameDt()
        self.vx /= 1 + (self.friction * dt)
        self.vy /= 1 + (self.friction * dt)

        self.xoffset += self.vx * self.do_x
        self.yoffset += self.vy * self.do_y

        self.ensure_bounding()

    def draw(self):
        # background
        set_color(*self.style.get('bg-color'))
        drawCSSRectangle(pos=self.pos, size=self.size, style=self.style)

        # draw children
        self.stencil_push()
        for w in self.children[:]:
            # internal update of children
            w.update()
            # optimization to draw only viewed children
            if self.do_y and (w.y + w.height < self.y or w.y > self.y + self.height):
                continue
            if self.do_x and (w.x + w.width < self.x or w.x > self.x + self.width):
                continue
            w.on_draw()
        self.stencil_pop()

        # draw widgets
        for w in self.widgets:
            w.dispatch_event('on_draw')
        # title bar
        if self.titletext is not None:
            set_color(*self.style.get('title-color'))
            w = 0
            if self.searchable:
                x = 80
                w += 80
            else:
                x = 0
            if self.deletable:
                w += 80
            drawCSSRectangle(pos=(self.x + x, self.height + self.y - 40),
                             size=(self.width - w, 40), prefix='title',
                             style=self.style)
            self.title.x = self.width/2 + self.x
            self.title.y = self.height - 20 + self.y
            self.title.draw()


        # scrollbar
        sb_size = self.style.get('scrollbar-size')
        if sb_size > 0:
            mtop, mright, mbottom, mleft = self.style.get('scrollbar-margin')
            if self.do_y:
                pos = [self.x + self.width - mright - sb_size, self.y + mbottom]
                size = [sb_size, self.height - mbottom - mtop]
                pos[1] += size[1] * self._scrollbar_index
                size[1] = size[1] * self._scrollbar_size
            elif self.do_x:
                pos = [self.x + mleft, self.y + self.height - mtop - sb_size]
                size = [self.width - mleft - mright, sb_size]
                pos[0] += size[0] * self._scrollbar_index
                size[0] = size[0] * self._scrollbar_size
            set_color(*self.style.get('scrollbar-color'))
            drawRectangle(pos=pos, size=size)

    def on_draw(self):
        if not self.visible:
            return
        self.do_layout()
        self.process_kinetic()
        self.draw()


class MTKineticObject(MTWidget):
    def __init__(self, **kwargs):
        '''Kinetic object, the base object for every child in kineticlist.

        :Parameters:
            `deletable`: bool, default to True
                Indicate if object can be deleted or not
        '''
        kwargs.setdefault('deletable', True)
        super(MTKineticObject, self).__init__(**kwargs)
        self.deletable = kwargs.get('deletable')
        self.register_event_type('on_animation_complete')
        self.push_handlers(on_animation_complete=self.on_animation_complete)

        # List of attributes that can be searched
        self.attr_search = ['label']

        # In case the widget has to move itself
        # while still having kinetic movement applied
        self.xoffset = self.yoffset = 0

        # The position values that the kinetic container edits.
        # We do this so we can break free and move ourself it necessary
        self.kx = self.ky = 0

        self.db_alpha = 0.0

        # Set to true if you want to break free from
        # the grasp of a kinetic widget
        self.free = False

        # Delete Button
        if self.deletable:
            self.db = MTButton(label='',
                size=(40, 40),
                pos=(self.x + self.width-40, self.y + self.height-40),
                style={'bg-color':(1, 0, 0, 0)}, visible=False)
            self.db.push_handlers(on_press=self._delete_callback)
            self.add_widget(self.db)

            self.a_delete = Animation(width=0, height=0,
                                      xoffset=self.kx + self.width/2,
                                      yoffset=self.ky + self.height/2,
                                      duration=0.5,
                                      f='ease_in_cubic')

        self.a_show = Animation(db_alpha=.5, duration=0.25)
        self.a_hide = Animation(db_alpha=0.0, duration=0.25)

    def show_delete(self):
        if not self.deletable:
            return
        self.db.show()
        self.a_show.animate(self)

    def hide_delete(self):
        if not self.deletable:
            return
        self.a_hide.animate(self)

    def on_animation_complete(self, anim):
        if anim == self.a_hide:
            self.db.hide()
        elif anim == self.a_delete:
            try:
                self.parent.remove_widget(self)
            except:
                pass

    def update(self):
        if not self.free:
            self.pos = self.kx + self.xoffset, self.ky + self.yoffset
        if self.deletable:
            self.db.pos = (self.x + self.width-40, self.y + self.height-40)
            self.db.style['bg-color'] = (1, 0, 0, self.db_alpha)

    def on_press(self, touch):
        if self.db.visible and self.db.on_touch_down(touch):
            return True

    def _delete_callback(self, touch):
        # So it doesn't poke out at the end(we aren't scaling it)
        self.db.hide()
        self.a_delete.animate(self)


class MTKineticItem(MTButton, MTKineticObject):
    '''The MTKineticItem is a MTKineticObject ready to be included in a MTKineticList.
    MTKineticItem have the behavior of the MTButton.

    By default, on_press event is not fired only if the button is deletable and
    visible.
    '''
    def on_press(self, touch):
        if self.deletable and self.db.visible and self.db.on_touch_down(touch):
            return True


class MTKineticImage(MTImageButton, MTKineticObject):
    '''The MTKineticImage is a MTKineticObject ready to be included in a MTKineticList.
    MTKineticImage have the behavior of the MTImageButton.

    By default, on_press event is not fired only if the button is deletable and
    visible.
    '''
    def on_press(self, touch):
        if self.deletable and self.db.visible and self.db.on_touch_down(touch):
            return True


########NEW FILE########
__FILENAME__ = modalpopup
'''
ModalPopup: a simple popup that use modal window
'''

__all__ = ('MTModalPopup', )

from pymt.ui.widgets.xmlwidget import XMLWidget
from pymt.ui.widgets.modalwindow import MTModalWindow
from pymt.graphx import set_color, drawCSSRectangle
from pymt.vector import Vector

def escape(s):
    return s.replace('"', '\\&quot;').replace('\'', '\\&quot;').replace('<', '&lt;').replace('>', '&gt;')

class MTModalPopup(MTModalWindow):
    '''A simple implementation of a popup.

    :Parameters:
        `title` : str, default is 'Information'
            Title of popup
        `content` : str, default is ''
            Content of popup
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('title', 'Information')
        kwargs.setdefault('content', '')
        kwargs.setdefault('size_hint', (1, 1))
        super(MTModalPopup, self).__init__(**kwargs)
        self.title      = kwargs.get('title')
        self.content    = kwargs.get('content')

        layout = '''
            <MTBoxLayout id='"popup"' orientation='"vertical"'
                size='%s' size_hint='(None, None)'>
                <MTLabel id='"popuptitle"' cls='"modalpopup-title"' label='"%s"'
                    size_hint='(1,None)' autosize='False' autowidth='False'
                    autoheight='False' halign='"center"' valign='"center"'
                    anchor_y='"center"' height='40'/>
                <MTLabel id='"popupcontent"' cls='"modalpopup-content"' label='"%s"'
                    size_hint='(1,1)' autosize='False' autowidth='False'
                    multiline='True'
                    autoheight='False' halign='"center"' anchor_y='"center"'/>
                <MTButton id='"popupsubmit"' cls='"modalpopup-submit"' label='"OK"'
                    size_hint='(1,None)' height='40' valign='"center"'
                    halign='"center"'/>
            </MTBoxLayout>
        ''' % (str(self.size),
               escape(self.title),
               escape(self.content))

        xml = XMLWidget(xml=layout)
        super(MTModalPopup, self).add_widget(xml.root)
        xml.autoconnect(self)
        self._xml = xml

    def on_popup_draw(self):
        self._xml.root.center = self.get_parent_window().center
        popup = self._xml.getById('popup')
        set_color(*self.style.get('bg-color-full'))
        drawCSSRectangle(
            pos=Vector(popup.pos) - (10, 10),
            size=Vector(popup.size) + (20, 20),
            style=self.style)

    def on_popupsubmit_release(self, *largs):
        self.parent.remove_widget(self)

    def add_widget(self, widget):
        raise Exception('MTModalPopup cannot have children')

########NEW FILE########
__FILENAME__ = popup
'''
Popup: tiny popup with customizable content
'''

__all__ = ('MTPopup', )

from pymt.graphx import set_color, drawCSSRectangle
from pymt.utils import curry
from pymt.ui.widgets.button import MTButton
from pymt.ui.widgets.label import MTLabel
from pymt.ui.widgets.scatter import MTScatterWidget
from pymt.ui.widgets.layout import MTBoxLayout


class MTPopup(MTScatterWidget):
    '''Popup with customizable content.

    :Parameters:
        `show_cancel`: bool, default to True
            Show/hide the cancel button
        `label_cancel`: str, default to 'Cancel'
            Change the label of cancel button
        `label_submit`: str, default to 'Ok'
            Change the label of submit button
        `title`: str, default to 'PyMT popup'
            Title of the popup (if None, no title will be added.)
        `exit_on_submit`: bool, default to 'True'
            Title of the popup (if None, no title will be added.)

    :Events:
        `on_submit`
            Fired when the popup submit button is pressed.
            In default behavior, the widget remove himself from parent.
        `on_cancel`
            Fired when the popup cancel button is pressed.
            In default behavior, the widget remove himself from parent.
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('do_scale', False)
        kwargs.setdefault('size', (400, 400))
        kwargs.setdefault('show_cancel', True)
        kwargs.setdefault('label_cancel', 'Cancel')
        kwargs.setdefault('label_submit', 'Ok')
        kwargs.setdefault('title', 'PyMT popup')
        kwargs.setdefault('exit_on_submit', True)
        super(MTPopup, self).__init__(**kwargs)

        self.register_event_type('on_submit')
        self.register_event_type('on_cancel')

        self.exit_on_submit = kwargs.get('exit_on_submit')

        # Create layouts
        self.layout = MTBoxLayout(size=self.size,  orientation='vertical')
        self.l_content = MTBoxLayout(orientation='vertical')
        self.l_buttons = MTBoxLayout(size_hint=(1, None),
                                     orientation='horizontal')

        # Titles
        if kwargs.get('title'):
            self.w_title = MTLabel(label=kwargs.get('title'),
                                   autosize=True, cls='popup-title')

        # Buttons
        self.w_submit = MTButton(label=kwargs.get('label_submit'),
                                 size_hint=(0.5, None), height=40,
                                 cls='popup-button')
        self.w_submit.push_handlers(on_release=curry(
            self._dispatch_event, 'on_submit'))
        self.l_buttons.add_widget(self.w_submit)
        if kwargs.get('show_cancel'):
            self.w_cancel = MTButton(label=kwargs.get('label_cancel'),
                                     size_hint=(0.5, None), height=40,
                                     cls='popup-button')
            self.w_cancel.push_handlers(on_release=curry(
                self._dispatch_event, 'on_cancel'))
            self.l_buttons.add_widget(self.w_cancel)

        # Connect
        if kwargs.get('title'):
            self.layout.add_widget(self.w_title)
        self.layout.add_widget(self.l_content)
        self.layout.add_widget(self.l_buttons)
        super(MTPopup, self).add_widget(self.layout)

    def _ensure_layout(self, force=False):
        while force or (self.size != self.layout.size):
            self.layout.do_layout()
            self.size = self.layout.size
            force = False

    def add_widget(self, widget, force=False):
        self.l_content.add_widget(widget)
        self._ensure_layout(force)

    def remove_widget(self, widget, force=False):
        self.l_content.remove_widget(widget)
        self._ensure_layout(force)

    def close(self):
        if self.exit_on_submit:
            self.parent.remove_widget(self)
        else:
            self.hide()

    def on_submit(self):
        self.close()

    def on_cancel(self):
        self.close()

    def _dispatch_event(self, event, *largs):
        self.dispatch_event(event)

    def draw(self):
        # draw background
        set_color(*self.style['bg-color'])
        drawCSSRectangle(size=self.size, style=self.style)

########NEW FILE########
__FILENAME__ = tabs
'''
Tabs widget: widget that provide tabs (like tabbed notebook)
'''

__all__ = ('MTTabs', )

from pymt.utils import curry
from pymt.ui.widgets.widget import MTWidget
from pymt.ui.widgets.button import MTButton
from pymt.ui.widgets.layout.boxlayout import MTBoxLayout

class MTTabs(MTWidget):
    '''Class that implement a tabbed notebook.
    When you add a widget into tabs, make sure
    they are at least one tab information ::

		tabs = MTTabs()
		w = MTWidget()
		w.tab = 'Title of tab'
		tabs.add_widget(w)

    or ::

		tabs = MTTabs()
		w = MTWidget()
		tabs.add_widget(w, tab='Title of tab')


    If you want to select a tab, use select() ::

		tabs = MTTabs()
		tabs.add_widget(MTButton(label="Hello"), tab='Tab1')
		tabs.add_widget(MTButton(label="World"), tab='Tab2')
		tabs.select('Tab2')

    .. warning::
        The position of this widget is the upper-left of the widget.
        The reason is if they are multiple tabs with multiple height,
        tabs will always moving when switching from one to another.

    '''
    def __init__(self, **kwargs):
        super(MTTabs, self).__init__(**kwargs)
        self.topbar = MTBoxLayout(orientation='horizontal')
        self.layout = MTBoxLayout(orientation='vertical', invert_y=True)
        self.layout.add_widget(self.topbar)
        super(MTTabs, self).add_widget(self.layout)
        self.current = None
        self.tabs = dict()
        self.layout.push_handlers(on_resize=self.on_layout_resize)

    def reposition(self):
        self.layout.pos = (self.x, self.y - self.layout.height)

    def on_layout_resize(self, w, h):
        self.reposition()

    def on_move(self, x, y):
        self.reposition()

    def add_widget(self, widget, tab=None):
        if tab is None:
            if not hasattr(widget, 'tab'):
                raise Exception('Widget added without tab information')
            else:
                tab = widget.tab
        button = MTButton(label=tab, size=(120, 40))
        button.tab_container = self
        button.connect('on_release', curry(self.select, tab))
        self.topbar.add_widget(button)
        self.tabs[tab] = (button, widget)

    def select(self, tab, *l):
        if tab not in self.tabs:
            return
        button, widget = self.tabs[tab]
        if self.current:
            self.layout.remove_widget(self.current, do_layout=False)
        self.layout.add_widget(widget, do_layout=False)
        self.current = widget
        self.layout.do_layout()

########NEW FILE########
__FILENAME__ = textarea
'''
TextArea: a multiline text input, based on TextInput

TextArea keystrokes :
    * shift + cursor movement: activate selection
    * ctrl + c: copy current selection into clipboard
    * ctrl + x: cut current selection into clipboard
    * ctrl + v: paste current clipboard text
    * ctrl + a: select all the text
'''

__all__ = ('MTTextArea', )

import re
from pymt.cache import Cache
from pymt.graphx import set_color, drawLine
from pymt.base import getFrameDt, getWindow
from pymt.graphx import drawRectangle
from pymt.core.text import Label
from pymt.core.clipboard import Clipboard
from pymt.utils import boundary
from pymt.ui.widgets.composed.textinput import MTTextInput

FL_IS_NEWLINE = 0x01

# add a cache, really not sure about the usage right now.
Cache.register('textarea.label', timeout=60.)

class MTTextArea(MTTextInput):
    '''A multi line text input widget

    :Parameters:
        `tab_width`: int, default to 4
            Indicate how much space should take a tabulation. 1 = size of one
            space.
    '''
    def __init__(self, **kwargs):
        self._glyph_size = {}
        self._scroll_x = 0
        self._scroll_y = 5
        self._selection = False
        self._selection_text = ''
        self._selection_from = None
        self._selection_to = None
        super(MTTextArea, self).__init__(**kwargs)

        self.tab_width = kwargs.get('tab_width', 4)


        padding = kwargs.get('padding', None)
        padding_x = kwargs.get('padding_x', None)
        padding_y = kwargs.get('padding_y', None)
        if not padding_x:
            if type(padding) in (tuple, list):
                padding_x = float(padding[0])
            elif padding is not None:
                padding_x = float(padding)
            else:
                padding_x = 0
        if not padding_y:
            if type(padding) in (tuple, list):
                padding_y = float(padding[1])
            elif padding is not None:
                padding_y = float(padding)
            else:
                padding_y = 0
        self.__padding_x = padding_x
        self.__padding_y = padding_y

        self.cursor_row = 0
        self.cursor_col = 0
        self.lines = []
        self.lines_flags = []
        self.value = kwargs.get('label') or ''
        self.buffer_size = kwargs.get('buffer_size') or 128000

    def _recalc_size(self):
        # We could do this as .size property I suppose, but then we'd
        # be calculating it all the time when .size is accessed.
        num = len(self.lines)
        if not num:
            return
        # The following two if statements ensure that the textarea remains
        # easily clickable even if there's no content.
        if self.autosize or self.autoheight:
            self.height = num * self.line_height + self.line_spacing * (num - 1)
        if (self.autosize or self.autowidth):
            self.width = max(label.content_width for label in self.line_labels)

    def _get_value(self):
        lf = self.lines_flags
        l = self.lines
        # raw version
        # out = []
        # for idx, elem in enumerate(l):
        #    if lf[idx] & FL_IS_NEWLINE:
        #        out.append('\n')
        #    out.append(elem)
        # return ''.join(out)
        # optimized version
        return ''.join([('\n' if (lf[i] & FL_IS_NEWLINE) else '') + l[i] \
                        for i in xrange(len(l))])
    def _set_value(self, text):
        old_value = self.value
        self._refresh_lines(text)
        self.cursor = self.get_cursor_from_index(len(text))
        self.cursor_fade = 0
        self._init_glyph_sizes()
        self._recalc_size()
        if old_value != self.value:
            self.dispatch_event('on_text_change', self)
    value = property(_get_value, _set_value)

    def _get_cursor(self):
        return self.cursor_col, self.cursor_row
    def _set_cursor(self, pos):
        l = self.lines
        cc, cr = pos
        self.cursor_row = cr = boundary(0, len(l) - 1, cr)
        self.cursor_col = boundary(0, len(l[cr]), cc)
        self.cursor_fade = 1
    cursor = property(_get_cursor, _set_cursor,
                      '''Get/set the (col,row) of the cursor''')

    def _refresh_lines(self, text=None):
        '''Recreate all lines / flags / labels from current value
        '''
        cursor_index = self.cursor_index
        text = text if type(text) in (str, unicode) else self.value
        self.lines, self.lines_flags = self._split_smart(text)
        self.line_labels = map(self.create_line_label, self.lines)
        self.line_height = self.line_labels[0].content_height
        self.line_spacing = 2
        self._recalc_size()
        # now, if the text change, maybe the cursor is not as the same place as
        # before. so, try to set the cursor on the good place
        self.cursor = self.get_cursor_from_index(cursor_index)

    def _tokenize(self, text):
        '''Tokenize a text string from some delimiters
        '''
        delimiters = ' ,\'".;:\n\r\t'
        oldindex = 0
        for index, char in enumerate(text):
            if char not in delimiters:
                continue
            if oldindex != index:
                yield text[oldindex:index]
            yield text[index:index+1]
            oldindex = index+1
        yield text[oldindex:]

    def _split_smart(self, text):
        '''Do a "smart" split. If autowidth or autosize is set,
        we are not doing smart split, just a split on line break.
        Otherwise, we are trying to split as soon as possible, to prevent
        overflow on the widget.
        '''
        # depend of the options, split the text on line, or word
        if self.autowidth or self.autosize:
            lines = text.split('\n')
            lines_flags = [0] + [FL_IS_NEWLINE] * (len(lines) - 1)
            return lines, lines_flags

        # no autosize, do wordwrap.
        x = flags = 0
        line = []
        lines = []
        lines_flags = []
        width = self.width - self.__padding_x * 2
        glyph_size = self.glyph_size

        # try to add each word on current line.
        for word in self._tokenize(text):
            is_newline = (word == '\n')
            w = glyph_size(word)
            # if we have more than the width, or if it's a newline,
            # push the current line, and create a new one
            if (x + w > width and line) or is_newline:
                lines.append(''.join(line))
                lines_flags.append(flags)
                flags = 0
                line = []
                x = 0
            if is_newline:
                flags |= FL_IS_NEWLINE
            else:
                x += w
                line.append(word)
        if line or flags & FL_IS_NEWLINE:
            lines.append(''.join(line))
            lines_flags.append(flags)

        return lines, lines_flags

    #
    # Selection control
    #

    def cancel_selection(self):
        '''Cancel current selection if any
        '''
        self._selection = False
        self._selection_finished = True

    def delete_selection(self):
        '''Suppress from the value current selection if any
        '''
        if not self._selection:
            return
        v = self.value
        text = v[:self._selection_from] + v[self._selection_to:]
        self.value = text
        self.cursor = self.get_cursor_from_index(self._selection_from)
        self.cancel_selection()

    def _update_selection(self, finished=False):
        '''Update selection text and order of from/to if finished is True.
        Can be call multiple time until finished=True.
        '''
        a, b = self._selection_from, self._selection_to
        if a > b:
            a, b = b, a
        self._selection_finished = finished
        self._selection_text = self.value[a:b]
        if not finished:
            self._selection = True
        else:
            self._selection_from = a
            self._selection_to = b
            self._selection = bool(len(self._selection_text))

    def _delete_line(self, idx):
        '''Delete current line, and fix cursor position
        '''
        assert(idx < len(self.lines))
        self.lines.pop(idx)
        self.lines_flags.pop(idx)
        self.line_labels.pop(idx)
        self.cursor = self.cursor

    def _set_line_text(self, line_num, text):
        '''Set current line with other text than the default one.
        '''
        self.lines[line_num] = text
        self.line_labels[line_num] = self.create_line_label(text)

    def get_line_options(self):
        '''Get or create line options, to be used for Label creation
        '''
        if not hasattr(self, '__line_options'):
            kw = self.__line_options = self.kwargs.copy()
            # Honour attributes like color.
            # XXX Currently only works once initially. Not updated if self.color is changed!
            #     What would be a proper solution?
            kw['anchor_x'] = 'left'
            kw['anchor_y'] = 'top'
            # force padding to 0, otherwise, the content width will take padding in
            # account, and the cursor display will be completly messed up
            # FIXME: handle padding ourself !
            kw['padding_x'] = 0
            kw['padding_y'] = 0
            kw['padding'] = (0, 0)
            w, h = self.size
            w -= self.__padding_x * 2
            h -= self.__padding_y * 2
            kw['viewport_size'] = (w, h)
        return self.__line_options

    def create_line_label(self, text):
        '''Create a label from a text, using line options
        '''
        ntext = text.replace('\n', '').replace('\t', ' ' * self.tab_width)
        kw = self.get_line_options()
        cid = '%s\0%s' % (ntext, str(kw))
        label = Cache.get('textarea.label', cid)
        if not label:
            label = Label(ntext, **kw)
            Cache.append('textarea.label', cid, label)
        return label

    def glyph_size(self, g):
        '''Get or add size of a glyph
        '''
        if not self._glyph_size.has_key(g):
            l = self.create_line_label(g)
            self._glyph_size[g] = l.content_width
        return self._glyph_size[g]

    def _init_glyph_sizes(self):
        '''First populate of glyph table
        '''
        # populating glyphs sizes
        for line in self.lines:
            for g in line:
                self.glyph_size(g)

    def line_at_pos(self, pos):
        '''Return the line from the current touch position
        '''
        line = int(((self.y+self.height)-pos[1])/(self.line_height+self.line_spacing))
        return max(0, min(line, len(self.lines)-1))

    def place_cursor(self, pos):
        '''Place the cursor near the touch position
        '''
        self.cursor_fade = 1
        self.cursor_row = self.line_at_pos(pos)
        text = self.lines[self.cursor_row]
        offset = 0
        cursor = 0
        while offset < (pos[0]-self.x) and cursor < len(text):
            offset += self.glyph_size(text[cursor])
            cursor += 1
        self.cursor_col = cursor

    @property
    def cursor_index(self):
        '''Return the cursor index in the text/value.
        '''
        l = self.lines
        if len(l) == 0:
            return 0
        lf = self.lines_flags
        index, cr = self.cursor
        for row in xrange(cr):
            index += len(l[row])
            if lf[row] & FL_IS_NEWLINE:
                index += 1
        if lf[cr] & FL_IS_NEWLINE:
            index += 1
        return index

    def cursor_offset(self):
        '''Get the cursor x offset on the current line
        '''
        offset = 0
        for i in xrange(self.cursor_col):
            offset += self.glyph_size(self.lines[self.cursor_row][i])
        return offset

    def get_cursor_from_index(self, index):
        '''Return the (row, col) of the cursor from text index'''
        index = boundary(0, len(self.value), index)
        if index <= 0:
            return 0, 0
        lf = self.lines_flags
        l = self.lines
        i = 0
        for row in xrange(len(l)):
            ni = i + len(l[row])
            if lf[row] & FL_IS_NEWLINE:
                ni += 1
                i += 1
            if ni >= index:
                return index - i, row
            i = ni
        return index, row

    def draw_cursor(self, x, y):
        '''Draw the cursor on the widget
        '''
        if not int(self.cursor_fade):
            return
        set_color(*self.style.get('cursor-color'))
        drawRectangle(size=(2, -self.line_height),
                      pos=(x + self.cursor_offset() - self._scroll_x, y))

    def draw_label(self):
        '''Draw the label on the widget, with taking care of scroll view and
        selection
        '''
        cursor_row = self.cursor_row
        offset = self.cursor_offset()
        dy = self.line_height + self.line_spacing

        # adjust view if the cursor is going outside the bounds
        self._scroll_x = 0
        if offset > self.width - self.__padding_x * 2:
            self._scroll_x = offset - self.width + self.__padding_x * 2
        sx = self._scroll_x

        # do the same for Y
        # this algo try to center the cursor as much as possible
        max_lines_displayed = (self.height - 2 * self.__padding_y) / dy
        max_lines_displayed = max(1, max_lines_displayed)
        if cursor_row < max_lines_displayed / 2:
            self._scroll_y = 0
        elif cursor_row > len(self.lines) - max_lines_displayed / 2:
            self._scroll_y = int(len(self.lines) - max_lines_displayed)
        else:
            self._scroll_y = int(cursor_row - max_lines_displayed / 2)

        # selection
        selection_active = self._selection

        # draw labels
        labels = self.line_labels
        is_active_input = self.is_active_input
        x = self.x + self.__padding_x
        y = self.top - self.__padding_y + (self._scroll_y * dy)
        miny = self.y + self.__padding_y
        maxy = self.top - self.__padding_y
        draw_selection = self.draw_selection
        for line_num, value in enumerate(self.lines):
            if miny <= y <= maxy:
                label = labels[line_num]
                label.viewport_pos = sx, 0
                label.pos = x, y
                if selection_active:
                    draw_selection(label, line_num)
                label.draw()
                if cursor_row == line_num and is_active_input:
                    self.draw_cursor(x, y)
            y -= dy

    def draw_selection(self, label, line_num):
        '''Draw the current selection on the widget.
        '''
        a, b = self._selection_from, self._selection_to
        if a > b:
            a, b = b, a
        s1c, s1r = self.get_cursor_from_index(a)
        s2c, s2r = self.get_cursor_from_index(b)
        if line_num < s1r or line_num > s2r:
            return
        x1 = label.x
        x2 = label.x + label.width
        y1 = label.y - self.line_height
        g = self.glyph_size
        if line_num == s1r:
            lines = self.lines[line_num]
            x1 += sum([g(x) for x in lines[:s1c]])
        if line_num == s2r:
            lines = self.lines[line_num]
            x2 = label.x + sum([g(x) for x in lines[:s2c]])
        set_color(*self.style.get('selection-color'))
        drawRectangle(pos=(x1, y1), size=(x2-x1, self.line_height))


    def on_update(self):
        super(MTTextArea, self).on_update()
        self.cursor_fade = (self.cursor_fade + getFrameDt() * 2) % 2

    def on_press(self, touch):
        if not self.is_active_input:
            self.show_keyboard()

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            self.place_cursor((touch.x - self.__padding_x,
                               touch.y + self.__padding_y))
            touch.userdata['%scursor' % self.id] = True
            self._selection_from = self.cursor_index
        return super(MTTextArea, self).on_touch_down(touch)

    def on_touch_move(self, touch):
        if touch.userdata.get('%scursor' % self.id) and \
           touch.grab_current == self:
            self.place_cursor((touch.x - self.__padding_x,
                               touch.y + self.__padding_y))
            self._selection_to = self.cursor_index
            self._update_selection()
        return super(MTTextArea, self).on_touch_move(touch)

    def on_touch_up(self, touch):
        if touch.userdata.get('%scursor' % self.id) and \
           touch.grab_current == self:
            self.place_cursor((touch.x - self.__padding_x,
                               touch.y + self.__padding_y))
            self._selection_to = self.cursor_index
            self._update_selection(True)
        self._can_deactive = False
        if super(MTTextArea, self).on_touch_up(touch):
            return True

    def _kbd_on_text_change(self, value):
        pass

    def insert_text(self, c):
        '''Insert new text on the current cursor position
        '''
        if len(self.value) >= self.buffer_size:
            return
        cc, cr = self.cursor
        ci = self.cursor_index
        text = self.lines[cr]
        new_text = text[:cc] + c + text[cc:]
        self._set_line_text(cr, new_text)
        self._refresh_lines()
        self.cursor = self.get_cursor_from_index(ci + len(c))
        self.dispatch_event('on_text_change', self)

    def do_backspace(self):
        '''Do backspace operation from the current cursor position
        '''
        cc, cr = self.cursor
        text = self.lines[cr]
        cursor_index = self.cursor_index
        if cc == 0 and cr == 0:
            return
        if cc == 0:
            text_last_line = self.lines[cr - 1]
            self._set_line_text(cr - 1, text_last_line + text)
            self._delete_line(cr)
        else:
            ch = text[cc-1]
            new_text = text[:cc-1] + text[cc:]
            self._set_line_text(cr, new_text)

        self._refresh_lines()
        self.cursor = self.get_cursor_from_index(cursor_index - 1)
        self.dispatch_event('on_text_change', self)

    def do_cursor_movement(self, action):
        '''Do a cursor movement
        (cursor_{left,right,up,down,home,end,pgup,pgdown})
        from the current cursor position
        '''
        pgmove_speed = 3
        if action == 'cursor_up':
            self.cursor_row = max(self.cursor_row - 1, 0)
            self.cursor_col = min(len(self.lines[self.cursor_row]), self.cursor_col)
        elif action == 'cursor_down':
            self.cursor_row = min(self.cursor_row + 1, len(self.lines) - 1)
            self.cursor_col = min(len(self.lines[self.cursor_row]), self.cursor_col)
        elif action == 'cursor_left':
            self.cursor = self.get_cursor_from_index(self.cursor_index - 1)
        elif action == 'cursor_right':
            self.cursor = self.get_cursor_from_index(self.cursor_index + 1)
        elif action == 'cursor_home':
            self.cursor_col = 0
        elif action == 'cursor_end':
            self.cursor_col = len(self.lines[self.cursor_row])
        elif action == 'cursor_pgup':
            self.cursor_row /= pgmove_speed
            self.cursor_col = min(len(self.lines[self.cursor_row]), self.cursor_col)
        elif action == 'cursor_pgdown':
            self.cursor_row = min((self.cursor_row + 1) * pgmove_speed, len(self.lines) - 1)
            self.cursor_col = min(len(self.lines[self.cursor_row]), self.cursor_col)

    def _kbd_on_key_down(self, key, repeat=False):
        self.cursor_fade = 1
        displayed_str, internal_str, internal_action, scale = key
        if internal_action is None:
            if self._selection:
                self.delete_selection()
            self.insert_text(displayed_str)
        elif internal_action in ('shift', 'shift_L', 'shift_R'):
            self._selection_from = self._selection_to = self.cursor_index
            self._selection = True
            self._selection_finished = False
        elif internal_action.startswith('cursor_'):
            self.do_cursor_movement(internal_action)
            if self._selection and not self._selection_finished:
                self._selection_to = self.cursor_index
                self._update_selection()
            else:
                self.cancel_selection()
        elif self._selection and internal_action in ('del', 'backspace'):
            self.delete_selection()
        elif internal_action == 'del':
            # do backspace only if we have data after our cursor
            cursor = self.cursor
            self.do_cursor_movement('cursor_right')
            if cursor != self.cursor:
                self.do_backspace()
        elif internal_action == 'backspace':
            self.do_backspace()
        elif internal_action == 'enter':
            self.insert_text('\n')
        elif internal_action == 'escape':
            self.hide_keyboard()
        if internal_action != 'escape':
            self._recalc_size()

    def _kbd_on_key_up(self, key, repeat=False):
        displayed_str, internal_str, internal_action, scale = key
        if internal_action in ('shift', 'shift_L', 'shift_R'):
            self._update_selection(True)

    def _window_on_key_down(self, key, scancode=None, unicode=None):
        if unicode and not key in self.interesting_keys.keys() + [27]:
            modifiers = getWindow().modifiers
            if 'ctrl' in modifiers:
                if key == ord('x'): # cut selection
                    Clipboard.put(self._selection_text, 'text/plain')
                    self.delete_selection()
                elif key == ord('c'): # copy selection
                    Clipboard.put(self._selection_text, 'text/plain')
                elif key == ord('v'): # paste selection
                    data = Clipboard.get('text/plain')
                    if data:
                        self.delete_selection()
                        self.insert_text(data)
                elif key == ord('a'): # select all
                    self._selection_from = 0
                    self._selection_to = len(self.value)
                    self._update_selection(True)
            else:
                if self._selection:
                    self.delete_selection()
                self.insert_text(unicode)
            self._recalc_size()
        return super(MTTextArea, self)._window_on_key_down(key, scancode, unicode)

########NEW FILE########
__FILENAME__ = textinput
'''
TextInput: a text input who instance vkeyboard if needed
'''

__all__ = ('MTTextInput', )

from pymt.logger import pymt_logger
from pymt.base import getWindow
from pymt.config import pymt_config
from pymt.graphx import set_color, drawCSSRectangle, drawLine
from pymt.core.clipboard import Clipboard
from pymt.ui.widgets.button import MTButton
from pymt.ui.animation import Animation, AnimationAlpha
from pymt.ui.widgets.composed.vkeyboard import MTVKeyboard

class MTTextInput(MTButton):
    '''
    A text input widget is a simple label widget that will pop up
    a virtual keyboard when touched any input of the virtual keyboard
    will then have effect on the TextInput widget.

    .. versionadded:: 0.5.1
        Support of scrolling textarea, controlled by `scroll` attribute. You can
        now scroll inside the text area without editing text.

    :Parameters:
        `keyboard`: MTVkeyboard object, default to None
            Use another MTVKeyboard than the default one
        `keyboard_to_root`: bool, defaults to False.
            Indicate whether the keyboard should be attached to the root
            window. If True, this will have the effect of the keyboard being
            raised above other widgets.
        `keyboard_type`: str, default to config.
            Configuration section is 'widgets', token 'keyboard_type'.
            Can be one of 'virtual' or 'real'. If real, the virtual keyboard
            will be not showed
        `password`: bool, default to False
            If True, the label will be showed with star
        `group`: str, default to random
            If the group is the same for multiple text input
            You can switch between them with TAB, and use the same keyboard.
        `switch`: bool, default to True
            If True, a switch button will be show to switch from real or virtual
            keyboard
        `scroll`: bool, default to True
            If True, the scrolling of a text area is allowed.
        `scroll_trigger`: int, default to 10
            If scrolling is detected, don't fire event to show/hide keyboard.
    :Events:
        `on_text_change` (text)
            Fired when the content of text input is changed
        `on_text_validate` ()
            Fired when the text is validate (when ENTER is hit on keyboard)
    '''
    _group_id = 0
    _group = {}

    def __init__(self, **kwargs):
        kwargs.setdefault('anchor_x', 'left')
        kwargs.setdefault('anchor_y', 'center')
        kwargs.setdefault('halign', 'left')
        kwargs.setdefault('keyboard', None)
        kwargs.setdefault('keyboard_to_root', False)
        kwargs.setdefault('group', None)
        kwargs.setdefault('switch', True)
        kwargs.setdefault('keyboard_type',
            pymt_config.get('widgets', 'keyboard_type'))

        super(MTTextInput, self).__init__(**kwargs)

        self.register_event_type('on_text_change')
        self.register_event_type('on_text_validate')

        self._scroll_x = 0
        self._can_deactive = True
        self._keyboard = kwargs.get('keyboard')
        self._is_active_input = False

        #: Boolean to activate the password mode on the textinput.
        #: If true, it will show star instead of real characters
        self.password = kwargs.get('password', False)

        #: Boolean to control the scrolling of the textinput content
        self.scroll = kwargs.get('scroll', True)

        #: If the scroll if more than scroll_trigger, no event will be
        #: dispatched, and no show/hide of keyboard.
        self.scroll_trigger = kwargs.get('scroll_trigger', 10)

        #: Keyboard type (virtual or real)
        self.keyboard_type = kwargs.get('keyboard_type')

        #: If True, the keyboard is added to root window, not to parent window.
        self.keyboard_to_root = kwargs.get('keyboard_to_root')

        # initialize group on random if nothing is set
        self._groupname = kwargs.get('group')
        if self._groupname is None:
            MTTextInput._group_id += 1
            self._groupname = 'uniqgroup%d' % MTTextInput._group_id
        # first time ? create the group
        if not self._groupname in self._group:
            self.group['keyboard'] = None
            self.group['widgets'] = []
        self.group['widgets'].append(self)

        # save original color for error
        self._notify_bg_color = self.style['bg-color']
        self._notify_bg_color_active = self.style['bg-color-active']
        self._notify_animation = None

        # switch button between vkeyboard or hardware
        self._switch = None
        if kwargs.get('switch'):
            self._switch = MTButton(
                label=kwargs.get('keyboard_type'), cls='switch-button',
                size=(60, 20), font_size=8,
                pos=(self.x + self.width - 60, self.y + self.height))

        self.interesting_keys = {8: 'backspace', 13: 'enter', 127: 'del',
                                 271: 'enter', 273: 'cursor_up', 274: 'cursor_down',
                                 275: 'cursor_right', 276: 'cursor_left',
                                 278: 'cursor_home', 279: 'cursor_end',
                                 280: 'cursor_pgup', 281: 'cursor_pgdown',
                                 303: 'shift_L', 304: 'shift_R'}

    def on_resize(self, *largs):
        if hasattr(self, '_switch'):
            self._switch.pos = self.x + self.width - 60, self.y + self.height
        return super(MTTextInput, self).on_resize(*largs)

    def _get_keyboard(self):
        if not self._keyboard:
            self._keyboard = self.group['keyboard']
            if self._keyboard is None:
                self._keyboard = MTVKeyboard()
                self.group['keyboard'] = self._keyboard
        return self._keyboard
    def _set_keyboard(self, value):
        if self._keyboard is not None:
            self._keyboard.remove_handlers(
                on_text_change=self._kbd_on_text_change,
                on_key_up=self._kbd_on_key_up,
                on_key_down=self._kbd_on_key_down
            )
        self._keyboard = value
    keyboard = property(_get_keyboard, _set_keyboard)

    def on_release(self, touch):
        if not self._can_deactive:
            return
        if self._is_active_input:
            self.hide_keyboard()
        else:
            self.show_keyboard()

    def _kbd_on_text_change(self, value):
        # reset scrolling when text is typed
        self._scroll_x = 0
        self.label = value
        self.dispatch_event('on_text_change', value)

    def _kbd_on_key_down(self, key, repeat=False):
        displayed_str, internal_str, internal_action, scale = key
        if internal_action is None:
            return
        elif internal_action == 'enter':
            self.hide_keyboard()
            self.dispatch_event('on_text_validate')
        elif internal_action == 'escape':
            self.hide_keyboard()

    def _kbd_on_key_up(self, key, repeat=False):
        pass

    def on_text_validate(self):
        pass

    def on_text_change(self, text):
        pass

    @property
    def group(self):
        '''Return information (keyboard/widget list) from the current
        group of the widget'''
        if not self._groupname in self._group:
            self._group[self._groupname] = {}
        return self._group[self._groupname]

    def notify_error(self):
        '''Call this function to make animation on background as an error
        '''
        error_color = self.style['bg-color-error']
        if self._notify_animation is not None:
            self._notify_animation.stop()
        self.style['bg-color'] = self._notify_bg_color
        self.style['bg-color-active'] = self._notify_bg_color_active
        self._notify_animation = self.do(Animation(
            style={'bg-color': error_color, 'bg-color-active': error_color},
            f=lambda x: 1 - AnimationAlpha.ease_in_out_quart(x)))

    def deactivate_group(self):
        '''Deactivate all widgets in the group'''
        for w in self.group['widgets']:
            w.hide_keyboard()

    def focus_next(self):
        '''Focus the next textinput in the list'''
        idx = (self.group['widgets'].index(self) + 1)
        idx = idx % len(self.group['widgets'])
        widget = self.group['widgets'][idx]
        widget.show_keyboard()

    def show_keyboard(self):
        '''Show the associed keyboard of this widget.'''
        if self._is_active_input:
            return
        self.deactivate_group()
        self._is_active_input = True

        # activate switch button if necessary
        if self._switch:
            self.add_widget(self._switch)

        # activate the real keyboard
        w = self.get_root_window()
        w.push_handlers(on_key_down=self._window_on_key_down,
                        on_key_up=self._window_on_key_up)

        # activate the virtual keyboard
        if self.keyboard_type == 'virtual':
            to_root = self.keyboard_to_root
            w = self.get_root_window() if to_root else self.get_parent_window()
            w.add_widget(self.keyboard)
        if self.keyboard is not None:
            self._keyboard.reset_repeat()
            self._keyboard.push_handlers(
                on_text_change=self._kbd_on_text_change,
                on_key_up=self._kbd_on_key_up,
                on_key_down=self._kbd_on_key_down
            )
            self._keyboard.text = self.label

    def hide_keyboard(self):
        '''Hide the associed keyboard of this widget.'''
        if not self._is_active_input:
            return
        if self._switch:
            self.remove_widget(self._switch)
        parent = self.keyboard.parent
        if parent is not None:
            # If keyboard type is real, the keyboard is not attached to any
            # parent widget.
            parent.remove_widget(self.keyboard)
        w = self.get_root_window()
        w.remove_handlers(on_key_down=self._window_on_key_down,
                          on_key_up=self._window_on_key_up)
        self._is_active_input = False
        if self._keyboard is not None:
            self._keyboard.reset_repeat()
            self._keyboard.remove_handlers(
                on_text_change=self._kbd_on_text_change,
                on_key_up=self._kbd_on_key_up,
                on_key_down=self._kbd_on_key_down
            )

    def _window_on_key_down(self, key, scancode=None, unicode=None):
        modifiers = getWindow().modifiers
        if key == ord('v') and 'ctrl' in modifiers:
            text = Clipboard.get('text/plain')
            if text:
                self.keyboard.text += text
            return True

        if key == 27: # escape
            self.hide_keyboard()
            return True
        elif key == 9: # tab
            self.focus_next()
            return True
        if not self.keyboard:
            return
        k = self.interesting_keys.get(key)
        if k:
            key = (None, None, k, 1)
            self.keyboard.dispatch_event('on_key_down', key)
        else:
            if unicode is not None:
                self.keyboard.text += unicode
            else:
                self.keyboard.text += chr(key)

    def _window_on_key_up(self, key, scancode=None, unicode=None):
        k = self.interesting_keys.get(key)
        if k and self.keyboard:
            key = (None, None, k, 1)
            self.keyboard.dispatch_event('on_key_up', key)

    def _get_value(self):
        return self.label
    def _set_value(self, value):
        self.label = value
    value = property(_get_value, _set_value,
        doc='Get/set the value of the label')

    def _get_keyboard_type(self):
        return self._keyboard_type
    def _set_keyboard_type(self, t):
        self.hide_keyboard()
        self._keyboard_type = t
        if self._is_active_input:
            self.show_keyboard()
    keyboard_type = property(_get_keyboard_type, _set_keyboard_type,
        doc='Get/set the keyboard type to use')

    @property
    def is_active_input(self):
        '''Return True if the input is active'''
        return self._is_active_input

    #
    # Overload the touch down/move/up for :
    #   1. handle the switch button
    #   2. be able to scroll inside the text input
    #

    def on_touch_down(self, touch):
        # check if it's the switch button that collide.
        if self._switch and self._switch.collide_point(*touch.pos):
            self.hide_keyboard()
            if self.keyboard_type == 'virtual':
                self.keyboard_type = 'real'
            else:
                self.keyboard_type = 'virtual'
            self._switch.label = self.keyboard_type
            self.show_keyboard()
            return True
        # reset scrolling when a touch is comming
        # FIXME: can be not accurate if many touch are comming.
        if self.collide_point(*touch.pos):
            self._scroll_x = 0
            self._can_deactive = True
        # and only now, dispatch as usual.
        return super(MTTextInput, self).on_touch_down(touch)

    def on_touch_move(self, touch):
        if not super(MTTextInput, self).on_touch_move(touch):
            return
        # we got a valid touch, 
        self._scroll_x += touch.dxpos - touch.x
        self._can_deactive = True
        if abs(touch.x - touch.oxpos) > self.scroll_trigger and self.scroll:
            self._can_deactive = False
        return True

    def on_touch_up(self, touch):
        if super(MTTextInput, self).on_touch_up(touch):
            if not self.is_active_input:
                self._scroll_x = 0
                self._can_deactive = True
            return True

    def draw(self):
        if self._is_active_input and self.keyboard_type == 'virtual':
            set_color(*self.style.get('bg-color'))
            kx, ky = self.keyboard.to_window(*self.keyboard.center)
            kx, ky = self.to_widget(kx, ky)
            drawLine([self.center[0], self.center[1], kx, ky])

        if self.password:
            pw = '*' * len(self.label)
            old_label = self.label
            self.label = pw
        super(MTTextInput, self).draw()
        if self.password:
            self.label = old_label

    def draw_background(self):
        set_color(*self.style.get('bg-color'))
        state = 'active' is self._is_active_input or None
        drawCSSRectangle(pos=self.pos, size=self.size,
                         style=self.style, state=state)

    def draw_label(self, dx=0, dy=0):
        # before drawing label, adjust the viewport position of the label. it's
        # a new feature that permit to draw only a part of the label.
        width = self._used_label.width - self.width
        scroll_x = self._scroll_x if self.scroll else 0
        if self.is_active_input:
            scroll_x = width + scroll_x
        if scroll_x > width:
            scroll_x = width
        if scroll_x < 0:
            scroll_x = 0
        self.viewport_pos = (scroll_x, 0)
        super(MTTextInput, self).draw_label(dx, dy)

    def on_update(self):
        super(MTTextInput, self).on_update()
        if self._switch:
            self._switch.pos = self.x + self.width - 60, self.y + self.height


########NEW FILE########
__FILENAME__ = video
'''
Video widget: provide a video container
'''

__all__ = ('MTVideo', 'MTSimpleVideo')

from pymt import pymt_icons_dir
from pymt.core.image import Image
from pymt.core.video import Video
from pymt.clock import getClock
from pymt.graphx import set_color, drawCSSRectangle
from pymt.ui.widgets.layout import MTBoxLayout
from pymt.ui.widgets.button import MTImageButton
from pymt.ui.widgets.slider import MTSlider
from pymt.ui.widgets.widget import MTWidget

class MTSimpleVideo(MTWidget):
    def __init__(self, filename, **kwargs):
        '''Provides a basic Video Widget with options on controlling the playback.
        This widget is based on the Video provider.
           * Double tap: Pause/Play
           * Two Finger Double tap: Rewind

        :Parameters:
            `autostart` : bool, default to False
                Autostart the video at instance
        '''
        kwargs.setdefault('autostart', False)

        self._touches = {}

        super(MTSimpleVideo, self).__init__(**kwargs)

        # load video
        self.player = Video(filename=filename)

        # autostart the video ?
        if kwargs.get('autostart'):
            self.player.play()

    def on_touch_down(self, touch):
        if self.collide_point(touch.x, touch.y):
            self._touches[touch.uid] = (touch.x, touch.y)
            if len(self._touches) == 2:
                if touch.is_double_tap:
                    self.player.seek(0)
            elif touch.is_double_tap:
                if self.player.state == 'playing':
                    self.player.stop()
                else:
                    self.player.play()

        return super(MTSimpleVideo, self).on_touch_down(touch)

    def on_touch_up(self, touch):
        if touch.uid in self._touches:
            del self._touches[touch.uid]
        return super(MTSimpleVideo, self).on_touch_up(touch)

    def on_update(self):
        self.size = self.player.size
        self.player.update()
        super(MTSimpleVideo, self).on_update()

    def draw(self):
        self.player.draw()
        super(MTSimpleVideo, self).draw()


class MTButtonVideo(MTImageButton):
    def draw(self):
        set_color(*self.style['bg-color'])
        drawCSSRectangle(pos=self.pos, size=self.size, style=self.style)
        self.image.color = self.style['color']
        super(MTButtonVideo, self).draw()

class MTVideo(MTSimpleVideo):
    '''MTVideo is a video player, with control buttons.
    You can use it like this ::

          video = MTVideo(filename='source_file')

    :Parameters:
        `filename` : str
            Filename of video
        `bordersize` : int, default to 10
            Border size of the video
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('bordersize', 10)

        super(MTVideo, self).__init__(**kwargs)

        self._count = 0
        self._controls = False
        self.bordersize = kwargs.get('bordersize')

        # images play/pause/mute
        self.f_play = Image(pymt_icons_dir + 'video-play.png')
        self.f_pause = Image(pymt_icons_dir + 'video-pause.png')
        self.f_vmute = Image(pymt_icons_dir + 'video-volume-mute.png')
        self.f_v100 = Image(pymt_icons_dir + 'video-volume-100.png')

        # create UI
        box = MTBoxLayout(orientation='horizontal', uniform_height=True,
                          spacing=0, padding=0)
        self._btnplay = MTButtonVideo(image=self.f_play,
                                      cls='video-toggleplay')
        self._btnmute = MTButtonVideo(image=self.f_v100,
                                      cls='video-togglemute')
        self._timeline = MTSlider(orientation='horizontal',
                                  cls='video-timeline')

        box.add_widget(self._btnplay)
        box.add_widget(self._btnmute)
        box.add_widget(self._timeline)
        self.add_widget(box)

        # link
        self._btnplay.connect('on_press', self._on_toggle_play)
        self._btnmute.connect('on_press', self._on_toggle_mute)

        self.hide_controls()

    def _on_toggle_play(self, *largs):
        if self.player.state == 'playing':
            self.player.stop()
            self._btnplay.image = self.f_pause
        else:
            self.player.play()
            self._btnplay.image = self.f_play
        return True

    def _on_toggle_mute(self, *largs):
        if self.player.volume == 1:
            self.player.volume = 0
            self._btnmute.image = self.f_vmute
        else:
            self.player.volume = 1
            self._btnmute.image = self.f_v100
        return True

    def on_update(self):
        super(MTVideo, self).on_update()
        # don't update controls if nothing is showed
        if self._controls == False:
            return
        self._timeline.width = self.width - self._btnplay.width - self._btnmute.width
        self._timeline.max = self.player.duration
        self._timeline.value = self.player.position

    def on_resize(self, w, h):
        self._timeline.width = w - 60
        return super(MTVideo, self).on_resize(w, h)

    def draw(self):
        b = self.bordersize
        b2 = b * 2
        set_color(*self.style['bg-color'])
        drawCSSRectangle((-b, -b), (self.width + b2, self.height + b2),
                              style=self.style)
        super(MTVideo, self).draw()

    def on_touch_down(self, touch):
        if self.collide_point(touch.x, touch.y):
            self.show_controls()
            self._count += 1
            getClock().schedule_once(self._try_hide_controls, 5)
        return super(MTVideo, self).on_touch_down(touch)

    def _try_hide_controls(self, *largs):
        self._count -= 1
        if self._count == 0:
            self.hide_controls()

    def show_controls(self):
        '''Makes the video controls visible'''
        self._controls = True
        for w in self.children:
            w.show()

    def hide_controls(self):
        '''Hides the video controls'''
        self._controls = False
        for w in self.children:
            w.hide()

########NEW FILE########
__FILENAME__ = vkeyboard
'''
VKeyboard: Virtual keyboard with custom layout support
'''


import os
import pymt
from pymt.base import getFrameDt
from pymt.graphx import set_color, drawCSSRectangle, drawLabel, GlDisplayList, \
        gx_matrix, getLastLabel
from pymt.clock import getClock
from pymt.utils import curry
from pymt.vector import Vector
from pymt.ui.widgets.scatter import MTScatterWidget
from pymt.ui.widgets.composed.kineticlist import MTKineticList, MTKineticItem
from OpenGL.GL import glScalef, glTranslatef

__all__ = ('MTVKeyboard', 'KeyboardLayout', 'KeyboardLayoutQWERTY',
           'KeyboardLayoutAZERTY')

class KeyboardLayout(object):
    '''Base for all Keyboard Layout'''
    ID              = 'nolayout'
    TITLE           = 'nolayout'
    DESCRIPTION     = 'nodescription'
    FONT_FILENAME   = None
    NORMAL_1 = []
    NORMAL_2 = []
    NORMAL_3 = []
    NORMAL_4 = []
    NORMAL_5 = []
    SHIFT_1 = []
    SHIFT_2 = []
    SHIFT_3 = []
    SHIFT_4 = []
    SHIFT_5 = []
    # Actual letters. No numbers or special chars or keys. Upper & lower.
    LETTERS = []

class KeyboardLayoutQWERTY(KeyboardLayout):
    '''Implementation of QWERTY Layout'''
    ID              = 'qwerty'
    TITLE           = 'Qwerty'
    DESCRIPTION     = 'A classical US Keyboard'
    SIZE            = (15, 5)
    NORMAL_1 = [
        ('`', '`', None, 1),    ('1', '1', None, 1),    ('2', '2', None, 1),
        ('3', '3', None, 1),    ('4', '4', None, 1),    ('5', '5', None, 1),
        ('6', '6', None, 1),    ('7', '7', None, 1),    ('8', '8', None, 1),
        ('9', '9', None, 1),    ('0', '0', None, 1),    ('+', '+', None, 1),
        ('=', '=', None, 1),    (u'\u232b', None, 'backspace', 2),
    ]
    NORMAL_2 = [
        (u'\u21B9', chr(0x09), None, 1.5),  ('q', 'q', None, 1),    ('w', 'w', None, 1),
        ('e', 'e', None, 1),    ('r', 'r', None, 1),    ('t', 't', None, 1),
        ('y', 'y', None, 1),    ('u', 'u', None, 1),    ('i', 'i', None, 1),
        ('o', 'o', None, 1),    ('p', 'p', None, 1),    ('{', '{', None, 1),
        ('}', '}', None, 1),    ('|', '|', None, 1.5)
    ]
    NORMAL_3 = [
        (u'\u21ea', None, 'capslock', 1.8),  ('a', 'a', None, 1),    ('s', 's', None, 1),
        ('d', 'd', None, 1),    ('f', 'f', None, 1),    ('g', 'g', None, 1),
        ('h', 'h', None, 1),    ('j', 'j', None, 1),    ('k', 'k', None, 1),
        ('l', 'l', None, 1),    (':', ':', None, 1),    ('"', '"', None, 1),
        (u'\u23ce', None, 'enter', 2.2),
    ]
    NORMAL_4 = [
        (u'\u21e7', None, 'shift_L', 2.5),  ('z', 'z', None, 1),    ('x', 'x', None, 1),
        ('c', 'c', None, 1),    ('v', 'v', None, 1),    ('b', 'b', None, 1),
        ('n', 'n', None, 1),    ('m', 'm', None, 1),    ('<', '<', None, 1),
        ('>', '>', None, 1),    ('?', '?', None, 1),    (u'\u21e7', None, 'shift_R', 2.5),
    ]
    NORMAL_5 = [
        (' ', ' ', None, 12), (u'\u2b12', None, 'layout', 1.5), (u'\u2a2f', None, 'escape', 1.5),

    ]
    SHIFT_1 = [
        ('~', '~', None, 1),    ('!', '!', None, 1),    ('@', '@', None, 1),
        ('#', '#', None, 1),    ('$', '$', None, 1),    ('%', '%', None, 1),
        ('^', '^', None, 1),    ('&', '&', None, 1),    ('*', '*', None, 1),
        ('(', '(', None, 1),    (')', ')', None, 1),    ('_', '_', None, 1),
        ('+', '+', None, 1),    (u'\u232b', None, 'backspace', 2),
    ]
    SHIFT_2 = [
        (u'\u21B9', chr(0x09), None, 1.5),  ('Q', 'Q', None, 1),    ('W', 'W', None, 1),
        ('E', 'E', None, 1),    ('R', 'R', None, 1),    ('T', 'T', None, 1),
        ('Y', 'Y', None, 1),    ('U', 'U', None, 1),    ('I', 'I', None, 1),
        ('O', 'O', None, 1),    ('P', 'P', None, 1),    ('[', '[', None, 1),
        (']', ']', None, 1),    ('?', '?', None, 1.5)
    ]
    SHIFT_3 = [
        (u'\u21ea', None, 'capslock', 1.8),  ('A', 'A', None, 1),    ('S', 'S', None, 1),
        ('D', 'D', None, 1),    ('F', 'F', None, 1),    ('G', 'G', None, 1),
        ('H', 'H', None, 1),    ('J', 'J', None, 1),    ('K', 'K', None, 1),
        ('L', 'L', None, 1),    (':', ':', None, 1),    ('"', '"', None, 1),
        (u'\u23ce', None, 'enter', 2.2),
    ]
    SHIFT_4 = [
        (u'\u21e7', None, 'shift_L', 2.5),  ('Z', 'Z', None, 1),    ('X', 'X', None, 1),
        ('C', 'C', None, 1),    ('V', 'V', None, 1),    ('B', 'B', None, 1),
        ('N', 'N', None, 1),    ('M', 'M', None, 1),    (',', ',', None, 1),
        ('.', '.', None, 1),    ('/', '/', None, 1),    (u'\u21e7', None, 'shift_R', 2.5),
    ]
    SHIFT_5 = [
        (' ', ' ', None, 12), (u'\u2b12', None, 'layout', 1.5), (u'\u2a2f', None, 'escape', 1.5),
    ]

    LETTERS = NORMAL_2[1:11] + NORMAL_3[1:10] + NORMAL_4[1:8] + \
              SHIFT_2[1:11] + SHIFT_3[1:10] + SHIFT_4[1:8]


class KeyboardLayoutAZERTY(KeyboardLayout):
    '''Implementation of AZERTY Layout'''
    ID              = 'azerty'
    TITLE           = 'Azerty'
    DESCRIPTION     = 'A French keyboard without international keys'
    SIZE            = (15, 5)
    NORMAL_1 = [
        ('@', '@', None, 1),    ('&', '&', None, 1),    (u'\xe9', u'\xe9', None, 1),
        ('"', '"', None, 1),    ('\'', '\'', None, 1),  ('(', '(', None, 1),
        ('-', '-', None, 1),    (u'\xe8', u'\xe8', None, 1),    ('_', '_', None, 1),
        (u'\xe7', u'\xe7', None, 1),    (u'\xe0', u'\xe0', None, 1),    (')', ')', None, 1),
        ('=', '=', None, 1),    (u'\u232b', None, 'backspace', 2),
    ]
    NORMAL_2 = [
        (u'\u21B9', chr(0x09), None, 1.5),  ('a', 'a', None, 1),    ('z', 'z', None, 1),
        ('e', 'e', None, 1),    ('r', 'r', None, 1),    ('t', 't', None, 1),
        ('y', 'y', None, 1),    ('u', 'u', None, 1),    ('i', 'i', None, 1),
        ('o', 'o', None, 1),    ('p', 'p', None, 1),    ('^', '^', None, 1),
        ('$', '$', None, 1),    (u'\u23ce', None, 'enter', 1.5),
    ]
    NORMAL_3 = [
        (u'\u21ea', None, 'capslock', 1.8),  ('q', 'q', None, 1),    ('s', 's', None, 1),
        ('d', 'd', None, 1),    ('f', 'f', None, 1),    ('g', 'g', None, 1),
        ('h', 'h', None, 1),    ('j', 'j', None, 1),    ('k', 'k', None, 1),
        ('l', 'l', None, 1),    ('m', 'm', None, 1),    (u'\xf9', u'\xf9', None, 1),
        ('*', '*', None, 1),    (u'\u23ce', None, 'enter', 1.2),
    ]
    NORMAL_4 = [
        (u'\u21e7', None, 'shift_L', 1.5),  ('<', '<', None, 1),    ('w', 'w', None, 1),
        ('x', 'x', None, 1),
        ('c', 'c', None, 1),    ('v', 'v', None, 1),    ('b', 'b', None, 1),
        ('n', 'n', None, 1),    (',', ',', None, 1),    (';', ';', None, 1),
        (':', ':', None, 1),    ('!', '!', None, 1),    (u'\u21e7', None, 'shift_R', 2.5),
    ]
    NORMAL_5 = [
        (' ', ' ', None, 12), (u'\u2b12', None, 'layout', 1.5), (u'\u2a2f', None, 'escape', 1.5),
    ]
    SHIFT_1 = [
        ('|', '|', None, 1),    ('1', '1', None, 1),    ('2', '2', None, 1),
        ('3', '3', None, 1),    ('4', '4', None, 1),    ('5', '5', None, 1),
        ('6', '6', None, 1),    ('7', '7', None, 1),    ('8', '8', None, 1),
        ('9', '9', None, 1),    ('0', '0', None, 1),    ('#', '#', None, 1),
        ('+', '+', None, 1),    (u'\u232b', None, 'backspace', 2),
    ]
    SHIFT_2 = [
        (u'\u21B9', chr(0x09), None, 1.5),  ('A', 'A', None, 1),    ('Z', 'Z', None, 1),
        ('E', 'E', None, 1),    ('R', 'R', None, 1),    ('T', 'T', None, 1),
        ('Y', 'Y', None, 1),    ('U', 'U', None, 1),    ('I', 'I', None, 1),
        ('O', 'O', None, 1),    ('P', 'P', None, 1),    ('[', '[', None, 1),
        (']', ']', None, 1),    (u'\u23ce', None, 'enter', 1.5),
    ]
    SHIFT_3 = [
        (u'\u21ea', None, 'capslock', 1.8),  ('Q', 'Q', None, 1),    ('S', 'S', None, 1),
        ('D', 'D', None, 1),    ('F', 'F', None, 1),    ('G', 'G', None, 1),
        ('H', 'H', None, 1),    ('J', 'J', None, 1),    ('K', 'K', None, 1),
        ('L', 'L', None, 1),    ('M', 'M', None, 1),    ('%', '%', None, 1),
        (u'\xb5', u'\xb5', None, 1),    (u'\u23ce', None, 'enter', 1.2),
    ]
    SHIFT_4 = [
        (u'\u21e7', None, 'shift_L', 1.5),  ('>', '>', None, 1),    ('W', 'W', None, 1),
        ('X', 'X', None, 1),    ('C', 'C', None, 1),    ('V', 'V', None, 1),
        ('B', 'B', None, 1),    ('N', 'N', None, 1),    ('?', '?', None, 1),
        ('.', '.', None, 1),    ('/', '/', None, 1),    (u'\xa7', u'\xa7', None, 1),
        (u'\u21e7', None, 'shift_R', 2.5),
    ]
    SHIFT_5 = [
        (' ', ' ', None, 12), (u'\u2b12', None, 'layout', 1.5), (u'\u2a2f', None, 'escape', 1.5),
    ]

    LETTERS = NORMAL_2[1:11] + NORMAL_3[1:11] + NORMAL_4[2:8] + \
              SHIFT_2[1:11] + SHIFT_3[1:11] + SHIFT_4[2:8]


class MTVKeyboard(MTScatterWidget):
    '''
    MTVKeyboard is an onscreen keyboard with multitouch support.
    Its layout is entirely customizable and you can switch between available
    layouts using a button in the bottom right of the widget.

    :Parameters:
        `layout` : KeyboardLayout object, default to None
            If None, keyboard layout will be created from configuration
            property.
        `time_lazy_update` : float, default to 0.2
            Time in seconds to force a lazy update when keyboard size changes
        `repeat` : float, default to 0.2
            Key repeat rate. 1/15. will repeat the last key 5 times per seconds
        `repeat_timeout` : float, default to 0.2
            Will start to repeat the key after 200ms

    :Events:
        `on_key_down` : key
            Fired when a key is down.
            The key contains: displayed_str, internal_str, internal_action, width
        `on_key_up` : key
            Fired when a key is up.
            The key contains: displayed_str, internal_str, internal_action, width
        `on_text_change` : text
            Fired when the internal text is changed

    List of internal actions available :

    * backspace
    * capslock
    * enter
    * escape
    * layout (to display layout list)
    * shift
    * shift_L
    * shift_R

    '''

    available_layout = []

    DEFAULT_SIZE = (700, 200)
    DEFAULT_POS = (0, 0)

    def __init__(self, **kwargs):
        kwargs.setdefault('size', MTVKeyboard.DEFAULT_SIZE)
        kwargs.setdefault('pos', MTVKeyboard.DEFAULT_POS)
        kwargs.setdefault('layout', None)
        kwargs.setdefault('time_lazy_update', .2)
        kwargs.setdefault('repeat', 1 / 15.)
        kwargs.setdefault('repeat_timeout', .2)

        self._old_scale = 0

        super(MTVKeyboard, self).__init__(**kwargs)

        self.register_event_type('on_key_down')
        self.register_event_type('on_key_up')
        self.register_event_type('on_text_change')

        self.time_lazy_update   = kwargs.get('time_lazy_update')
        self.layout             = kwargs.get('layout')
        self.container_width, self.container_height   = self.size
        self.repeat             = kwargs.get('repeat')
        self.repeat_timeout     = kwargs.get('repeat_timeout')

        # read default layout in configuration
        if self.layout is None:
            idlayout = pymt.pymt_config.get('keyboard', 'layout')
            # search layout
            for layout in MTVKeyboard.available_layout:
                if layout.ID == idlayout:
                    self.layout = layout()
                    break
            # no layout found ?
            if self.layout is None:
                pymt.pymt_logger.warning('Vkeyboard: Keyboard layout <%s> not found, fallback on QWERTY' % idlayout)
                self.layout = KeyboardLayoutQWERTY()

        self._mode              = 'NORMAL'
        self._cache             = {}
        self._current_cache     = None
        self._last_update       = 0
        self._last_update_scale = 1.
        self._need_update       = 'now'
        self._internal_text     = u''
        self._show_layout       = False
        self._active_keys       = []
        self._used_label        = []
        self._last_key_down     = []
        self._last_key_repeat   = 0
        self._last_key_repeat_timeout  = 0

        # prepare layout widget
        mtop, mright, mbottom, mleft = self.style['margin']
        self._layout_widget     = MTKineticList(
            title=None, searchable=False, deletable=False,
            size=(self.width - mleft - mright, self.height),
            pos=(mleft, 0), style={'bg-color': (.0, .0, .0, .7)},
            visible=False)
        for layout in MTVKeyboard.available_layout:
            item = MTKineticItem(label=layout.TITLE + ' - ' + layout.DESCRIPTION,
                    style={'font-size':14}, size=(self.width - mleft - mright, 40))
            item.push_handlers(on_press=curry(self.on_layout_change, layout))
            self._layout_widget.add_widget(item)
        self.add_widget(self._layout_widget)


    def on_text_change(self, *largs):
        pass


    #
    # Static methods
    #

    @staticmethod
    def add_custom_layout(layout_class):
        '''Add a custom layout class on MTVKeyboard'''
        if not layout_class in MTVKeyboard.available_layout:
            # Append layout in class
            MTVKeyboard.available_layout.append(layout_class)
            if layout_class.FONT_FILENAME != None:
                # Load custom font
                try:
                    # XXX FIXME
                    #font.add_file(layout_class.FONT_FILENAME)
                    pass
                except:
                    pymt.pymt_logger.exception('Vkeyboard: Unable to load custom font')

    #
    # Keyboard properties
    #

    def _get_text(self):
        return self._internal_text
    def _set_text(self, value):
        if value != self._internal_text:
            self._internal_text = value
            self.dispatch_event('on_text_change', value)
    text = property(_get_text, _set_text,
            doc='''Get/set text string on vkeyboard''')

    def _get_mode(self):
        return self._mode
    def _set_mode(self, value):
        if value != self._mode:
            self._need_update = 'now'
            self._mode = value
    mode = property(_get_mode, _set_mode,
            doc='''Get/set mode of vkeyboard (NORMAL, SHIFT...)''')

    #
    # Public methods
    #

    def clear(self):
        '''Clear the text'''
        self.text = u''

    def reset_repeat(self):
        '''Reset key repeat
        '''
        self._last_key_down     = []
        self._last_key_repeat   = 0
        self._last_key_repeat_timeout  = 0


    #
    # Private methods
    #

    def _lazy_update(self):
        self.container_width = int(self.width * self.scale)
        self.container_height = int(self.height * self.scale)
        self._need_update = 'lazy'
        self._last_update = getClock().get_time()

    def _update(self):
        dt = getClock().get_time() - self._last_update
        if self._need_update is None:
            return

        if self._need_update == 'now' or (self._need_update == 'lazy' and  dt >
                                         self.time_lazy_update):
            # create layout mode if not in cache
            layoutmode = '%s:%s' % (self.layout.ID, self.mode)
            if not layoutmode in self._cache:
                self._cache[layoutmode] = {'background': GlDisplayList(),
                                           'keys': GlDisplayList(),
                                           'usedlabel': []}
            self._current_cache = self._cache[layoutmode]

            # do real update
            self._do_update(mode='background')
            self._do_update(mode='keys')

            # don't update too fast next time (if it's lazy)
            self._last_update = getClock().get_time()
            self._last_update_scale = self.scale
            self._need_update = None

    def _do_update(self, mode=None):
        # we absolutly want mode to update displaylist.
        if mode not in ('background', 'keys'):
            return

        # don't update background if it's already compiled
        if mode == 'background' and self._current_cache['background'].is_compiled():
            return

        # calculate margin
        s = self.scale
        w, h = self.container_width, self.container_height
        if mode == 'background':
            s = 1.
            w, h = self.size
        mtop, mright, mbottom, mleft = map(lambda x: x * s, self.style['margin'])
        self.texsize = Vector(w - mleft - mright,
                              h - mtop - mbottom)
        kx, ky = self.layout.SIZE
        self.keysize = Vector(self.texsize.x / kx, self.texsize.y / ky)
        m = 3 * s
        x, y = 0, self.texsize.y - self.keysize.y

        # update display list
        self._current_cache['usedlabel'] = []
        with self._current_cache[mode]:

            # draw lines
            for index in xrange(1, ky + 1):
                line = self.layout.__getattribute__('%s_%d' % (self.mode, index))

                # draw keys
                for key in line:
                    displayed_str, internal_str, internal_action, scale = key
                    kw = self.keysize.x * scale

                    # don't display empty keys
                    if displayed_str is not None:
                        set_color(*self.style['key-color'])
                        if mode == 'background':
                            if internal_action is not None:
                                set_color(*self.style['syskey-color'])
                            drawCSSRectangle(
                                pos=(x+m, y+m),
                                size=(kw-m*2, self.keysize.y-m*2),
                                style=self.style, prefix='key')
                        elif mode == 'keys':
                            font_size = int(14 * s)
                            if font_size < 8:
                                font_size = 8
                            color = self.style['color']
                            if internal_action is not None:
                                color = self.style['color-syskey']
                            drawLabel(label=displayed_str,
                                    pos=(x + kw / 2., y + self.keysize.y / 2.),
                                    font_size=font_size, bold=False,
                                    font_name=self.style.get('font-name'),
                                    color=color)
                            self._current_cache['usedlabel'].append(getLastLabel())
                    # advance X
                    x += kw
                # advance Y
                y -= self.keysize.y
                x = 0

        # update completed
        self._need_update = None

    #
    # Rewrite some handle to update the widget (drawing and scalling)
    #

    def on_resize(self, w, h):
        self._lazy_update()

    def on_transform(self, *largs):
        # to lazy update only if scale change
        if self._old_scale != self.scale:
            self._old_scale = self.scale
            self._lazy_update()

    def on_layout_change(self, layout, *largs):
        self._layout_widget.visible = False
        self.layout = layout()
        self._need_update = 'now'

    def on_update(self):
        super(MTVKeyboard, self).on_update()
        self._update()

        if not len(self._last_key_down):
            return
        self._last_key_repeat_timeout -= getFrameDt()
        if self._last_key_repeat_timeout < 0:
            self._last_key_repeat -= getFrameDt()
            if self._last_key_repeat > 0:
                return
            self._last_key_repeat = self.repeat
            key = self._last_key_down[-1]
            self.dispatch_event('on_key_down', key, True)
            self.dispatch_event('on_key_up', key, True)


    def draw(self):
        # background
        set_color(*self.style['bg-color'])
        drawCSSRectangle(size=self.size, style=self.style)

        # content dynamic update
        with gx_matrix:
            glTranslatef(self.style['margin'][3], self.style['margin'][2], 0)

            # draw precalculated background
            self._current_cache['background'].draw()

            # draw active keys layer
            # +2 and -4 result of hard margin coded in _do_update (m = 3 * s)
            # we substract 1 cause of border (draw-border is activated.)
            set_color(*self.style['color-down'])
            for key, size in self._active_keys:
                x, y, w, h = size
                drawCSSRectangle(pos=(x+2, y+2), size=(w-4, h-4),
                    style=self.style, prefix='key', state='down')

            # search the good scale for current precalculated keys layer
            if self._last_update_scale == self.scale:
                s = 1. / self.scale# / self._last_update_scale
                glScalef(s, s, s)
            else:
                s = 1. / self._last_update_scale
                glScalef(s, s, s)
            self._current_cache['keys'].draw()

    def get_key_at_pos(self, x, y):
        '''Return the key + size info on the current layout, at the coordinate (x, y)'''
        mtop, mright, mbottom, mleft = self.style['margin']
        w, h = self.width - mleft - mright, self.height - mtop - mbottom
        kx, ky = self.layout.SIZE
        keysize = Vector(w / kx, h / ky)
        if x < mleft or x > self.width - mright or \
           y < mbottom or y > self.height - mtop:
            return None
        index = ky-int((y - mbottom) /
                (self.height - mtop - mbottom)
                * ky)
        line = self.layout.__getattribute__('%s_%d' % (self.mode, index))
        x -= mleft
        kx = 0
        for key in line:
            kw = keysize.x * key[3]
            if x >= kx and x < kx + kw:
                h = (self.height - mtop - mbottom) / ky
                return (key, (kx, h * (ky-index), kw, h))
            kx += kw
        return None

    def on_key_down(self, key, repeat=False):
        if repeat is False:
            if not key in self._last_key_down:
                self._last_key_down.append(key)
            self._last_key_repeat_timeout = self.repeat_timeout
            self._last_key_repeat = self.repeat
        displayed_str, internal_str, internal_action, scale = key
        if internal_action is None:
            if internal_str is not None:
                self.text += internal_str
        elif internal_action in ('capslock'):
            if self.mode == 'NORMAL':
                self.mode = 'SHIFT'
            else:
                self.mode = 'NORMAL'
            self._need_update = 'now'
            return
        elif internal_action in ('shift', 'shift_L', 'shift_R'):
            if self.mode == 'NORMAL':
                self.mode = 'SHIFT'
            else:
                self.mode = 'NORMAL'
            self._need_update = 'now'
            return
        elif internal_action in ('layout'):
            self._layout_widget.visible = True
        elif internal_action in ('backspace'):
            self.text = self.text[:-1]

    def on_key_up(self, key, repeat=False):
        if key in self._last_key_down and repeat is False:
            self._last_key_down.remove(key)
        displayed_str, internal_str, internal_action, scale = key
        if internal_action is None:
            pass
        elif internal_action in ('shift', 'shift_L', 'shift_R'):
            if self.mode == 'NORMAL':
                self.mode = 'SHIFT'
            else:
                self.mode = 'NORMAL'
            self._need_update = 'now'
            return

    def on_touch_down(self, touch):
        if not self._layout_widget.visible:
            x, y = self.to_local(touch.x, touch.y)
            keyinfo = self.get_key_at_pos(x, y)
            if keyinfo is not None:
                key, size = keyinfo
                if key not in self._active_keys:
                    touch.userdata['vkeyboard_key'] = keyinfo
                    self._active_keys.append(keyinfo)
                    self.dispatch_event('on_key_down', key)
                return True
        return super(MTVKeyboard, self).on_touch_down(touch)

    def on_touch_up(self, touch):
        if 'vkeyboard_key' in touch.userdata:
            keyinfo = touch.userdata['vkeyboard_key']
            key, size = keyinfo
            if keyinfo in self._active_keys:
                self._active_keys.remove(keyinfo)
            self.dispatch_event('on_key_up', key)
            return True
        return super(MTVKeyboard, self).on_touch_up(touch)


# Register layouts
# Don't go further if we generate documentation
if not 'PYMT_DOC' in os.environ:
    MTVKeyboard.add_custom_layout(KeyboardLayoutQWERTY)
    MTVKeyboard.add_custom_layout(KeyboardLayoutAZERTY)

########NEW FILE########
__FILENAME__ = vkeyboardspellcheck
'''
SpellVKeyboard: Virtual keyboard that provides spelling
                suggestions/corrections as you type.
'''

__all__ = ('MTSpellVKeyboard', )

from pymt.core.spelling import Spelling
from pymt.ui.factory import MTWidgetFactory
from pymt.ui.widgets.button import MTButton
from pymt.ui.widgets.layout import MTBoxLayout
from pymt.ui.widgets.composed.vkeyboard import MTVKeyboard
from pymt.utils import curry

class MTSpellVKeyboardLabel(MTButton):
    def __init__(self, **kwargs):
        super(MTSpellVKeyboardLabel, self).__init__(**kwargs)
        self.label_obj.color = (0, 0, 0, 1)
        self.size = self.label_obj.content_width, self.label_obj.content_height

class MTSpellVKeyboard(MTVKeyboard):
    '''
    The MTSpellVKeyboard augments the ordinary MTVKeyboard with spelling suggestions.
    You can use it instead of the MTVKeyboard. The only difference are the spelling
    suggestions that are shown on top of the widget. As you type, these are populated
    by suggestions from the system. To use a suggestion, simply tap it.

    :Parameters:
        `spelling` : Spelling object
            If provided, the keyboard uses this spelling instance (can be used to
            indicate which language should be used for spelling). If not provided,
            a fallback spelling instance will be created that uses the first language
            available.
    '''

    def __init__(self, **kwargs):
        super(MTSpellVKeyboard, self).__init__(**kwargs)
        self.last_word = ''
        self.spelling = kwargs.get('spelling', Spelling())
        self.suggests = []
        self.buttons = []
        self.slayout = MTBoxLayout(orientation='horizontal', spacing=10)
        self.add_widget(self.slayout)

    def _clear_suggestions(self):
        self.slayout.children.clear()

    def _add_suggestion(self, word):
        k = {'autoheight': True, 'font_size': 16}
        label = MTSpellVKeyboardLabel(label=' %s ' % word, **k)
        label.connect('on_press', curry(self._press_suggestion, word))
        self.slayout.add_widget(label)

    def _press_suggestion(self, word, *largs):
        l = len(self.last_word)
        if not l:
            return
        self.text = self.text[0:-l] + word
        self._clear_suggestions()

    def on_touch_down(self, touch):
        x, y = self.to_local(touch.x, touch.y)
        touch.push('xy')
        touch.x, touch.y = x, y
        if self.slayout.dispatch_event('on_touch_down', touch):
            touch.pop()
            return True
        touch.pop()
        return super(MTSpellVKeyboard, self).on_touch_down(touch)

    def on_text_change(self, text):
        self._clear_suggestions()
        if len(text) == 0:
            return

        l = text.replace('\r\n,.:; ', ' ')
        self.last_word = l.split(' ')[-1]
        if self.last_word == '':
            return

        self._add_suggestion(self.last_word)

        self.suggests = self.spelling.suggest(self.last_word)[:10]
        for word in self.suggests:
            self._add_suggestion(word)

    def on_update(self):
        # ensure the layout position
        self.slayout.pos = (5, self.height + 5)
        super(MTSpellVKeyboard, self).on_update()


MTWidgetFactory.register('MTSpellVKeyboard', MTSpellVKeyboard)


########NEW FILE########
__FILENAME__ = container
'''
Container: easy way to convert a simple BaseObject into a widget
'''

__all__ = ('MTContainer', 'MTScatterContainer')

from pymt.logger import pymt_logger
from pymt.ui.widgets.widget import MTWidget
from pymt.ui.widgets.scatter import MTScatterWidget

class MTContainer(MTWidget):
    '''Convert a BaseObject like into a MTWidget.

    :Parameters:
        `fit_to_parent` : bool, default to True
            set baseobject size to parent size
    '''
    def __init__(self, baseobject, **kwargs):
        kwargs.setdefault('fit_to_parent', True)
        super(MTContainer, self).__init__(**kwargs)
        self.fit_to_parent = kwargs.get('fit_to_parent')
        self.child = baseobject
        self.size = self.child.size

    def add_widget(self, widget):
        pymt_logger.warning('MTContainer: cannot add MTWidget, only take BaseObject')

    def on_parent_resize(self, w, h):
        if self.fit_to_parent:
            self.size = w, h

    def on_resize(self, w, h):
        # if our size have changed, update children
        self.child.size = w, h

    def on_update(self):
        super(MTContainer, self).on_update()
        self.child.update()

    def draw(self):
        super(MTContainer, self).draw()
        self.child.pos = self.pos
        self.child.draw()

class MTScatterContainer(MTContainer, MTScatterWidget):
    '''Convert a BaseObject like into a MTScatterWidget.'''
    def draw(self):
        # just subclass this function, don't move the object :)
        super(MTContainer, self).draw()
        self.child.draw()


########NEW FILE########
__FILENAME__ = coverflow
'''
Coverflow: a coverflow widget
'''

__all__ = ('MTCoverFlow', )

from OpenGL.GL import glRotatef, glTranslatef
from pymt.graphx import set_color, drawRectangle, drawTexturedRectangle, \
        Fbo, drawLabel
from pymt.utils import boundary, interpolate
from pymt.vector import Vector
from pymt.config import pymt_config
from pymt.ui.widgets.widget import MTWidget

class MTCoverFlow(MTWidget):
    '''A coverflow widget, that support mostly any widget in :)

    :Parameters:
        `cover_angle` : int, default to 90
            Angle to turn cover when they are displayed on the left/right side
        `cover_distance` : int, default to 400
            Distance in pixels for starting drawing left/right side from the
            current displayed cover
        `cover_spacing` : int, default to 50
            Distance in pixels between covers
        `cover_blend` : bool, default to False
            Activate background blending for the cover. If you set a background
            color, without blending, the blending will look wrong. Activate
            blending if you want to use your background color for fading or if
            you want to use a img with an alpha channel (i.e. png with transparent background)
        `cover_blend_start` : float, default 1.0
            Alpha value to use for the cover blending (0 means transparent)
        `cover_blend_stop` : float, default to 1.0
            Alpha value to use for the cover blending
        `reflection_blend` : bool, default to False
            Activate background blending for reflection. If you set a background
            color, without blending, the reflection will look wrong. Activate
            blending if you want to use your background color for fading.
        `reflection_percent` : float, default to 0.3
            Percentage of the thumbnail height to be showed. For example, if the
            thumbnail is 400 height, and reflection_percent is 0.4, only
            (0.3 * 400) pixels will be showed for reflection
        `reflection_start` : float, default 0.4
            Alpha value to use for top reflection (0 mean transparent)
        `reflection_stop` : float, default to 0
            Alpha value to use for the bottom reflection
        `thumbnail_size` : list, default to (400, 400)
            Size of a thumbnail
        `trigger_cover_distance` : int, default to 30
            Distance in pixels to trigger the switch of cover
        `trigger_distance`: int, default to 5 (list_trigger_distance in config)
            If the distance between the position of the first touch contact to
            the second position is less than the trigger_distance, a event
            'down' and 'up' are dispatched on the childrens.
            Otherwise, no event are dispatched.
            (If you move the list to much, no event will be dispatched.)
        `title_attributes` : dict, default to {}
            Attributes to pass to drawLabel
        `title_draw` : bool, default to True
            If a title attribute is found on the child, it will be drawed on
            screen
        `title_position` : int, default to -50
            Y position of title (starting from the bottom of the cover)

    :Events:
        `on_change` : widget
            Fired when the selected cover change
        `on_select` : widget
            Fired when the user "click" on the current cover
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('cover_angle', 90)
        kwargs.setdefault('cover_distance', 400)
        kwargs.setdefault('cover_spacing', 50)
        kwargs.setdefault('cover_blend', False)
        kwargs.setdefault('cover_blend_start', 1.0)
        kwargs.setdefault('cover_blend_stop', 1.0)
        kwargs.setdefault('reflection_blend', False)
        kwargs.setdefault('reflection_percent', .3)
        kwargs.setdefault('reflection_start', .4)
        kwargs.setdefault('reflection_stop', 0)
        kwargs.setdefault('thumbnail_size', (400, 400))
        kwargs.setdefault('title_attributes', {})
        kwargs.setdefault('title_draw', True)
        kwargs.setdefault('title_position', -50)
        kwargs.setdefault('trigger_cover_distance', 30)

        super(MTCoverFlow, self).__init__(**kwargs)

        self.register_event_type('on_select')
        self.register_event_type('on_change')

        self.cover_angle            = kwargs.get('cover_angle')
        self.cover_distance         = kwargs.get('cover_distance')
        self.cover_spacing          = kwargs.get('cover_spacing')
        self.cover_blend            = kwargs.get('cover_blend')
        self.cover_blend_start      = kwargs.get('cover_blend_start')
        self.cover_blend_stop       = kwargs.get('cover_blend_stop')
        self.reflection_blend       = kwargs.get('reflection_blend')
        self.reflection_percent     = kwargs.get('reflection_percent')
        self.reflection_start       = kwargs.get('reflection_start')
        self.reflection_stop        = kwargs.get('reflection_stop')
        self.thumbnail_size         = kwargs.get('thumbnail_size')
        self.title_attributes       = kwargs.get('title_attributes')
        self.title_draw             = kwargs.get('title_draw')
        self.title_position         = kwargs.get('title_position')
        self.trigger_cover_distance = kwargs.get('trigger_cover_distance')
        self.trigger_distance = kwargs.get('trigger_distance',
            pymt_config.getint('widgets', 'list_trigger_distance'))

        self._animation             = None
        self._fbo                   = Fbo(size=self.thumbnail_size)
        self._reflection_coords     = None
        self._cover_blend_coords    = None
        self._selection             = 0
        self._touch                 = None
        self._transition            = 0
        self._internal_position     = 0

    def on_touch_down(self, touch):
        if not len(self.children) or \
           self._touch or \
           not self.collide_point(*touch.pos):
            return
        # we got one touch for coverflow !
        self._touch = touch
        touch.grab(self)
        touch.userdata['coverflow.firstpos']    = touch.pos
        touch.userdata['coverflow.pos']         = touch.pos
        touch.userdata['coverflow.noclick']     = False
        return True

    def on_touch_move(self, touch):
        # accept only the touch we've got first.
        if touch.grab_current != self:
            return

        self._animation = False

        # calculate the distance between the touch and the old position
        d = touch.userdata['coverflow.pos'][0] - touch.xpos

        # cancel on-select if needed
        if abs(d) > self.trigger_distance:
            touch.userdata['coverflow.noclick'] = True

        # calculate new cover selected
        cover_distance = self.cover_distance
        len_children = len(self.children) - 1
        ipos = self._internal_position - (touch.xpos - touch.dxpos)
        ipos = boundary(ipos, 0, len_children * cover_distance)
        self._internal_position = ipos

        # calculate selection
        selection = int(round(ipos / cover_distance))
        selection = boundary(selection, 0, len_children)

        # update transition and selection
        # (will fire an event if selection have changed.)
        self._transition = ipos / cover_distance - selection
        self.selection = selection

        return True

    def on_touch_up(self, touch):
        # accept only the touch we've got first.
        if touch.grab_current != self:
            return
        touch.ungrab(self)
        self._touch = None

        # animate the transition to back to 0
        # cover will back to position in nicer way
        self._animation = True

        # launch on_select ?
        if not touch.userdata['coverflow.noclick']:
            distance = Vector(touch.userdata['coverflow.firstpos']).distance(Vector(touch.pos))
            if distance <= self.trigger_distance:
                self.dispatch_event('on_select', self.children[self._selection])
        return True

    def on_select(self, widget):
        pass

    def on_change(self, widget):
        pass

    def _get_selection(self):
        return self._selection
    def _set_selection(self, x):
        if x == self._selection:
            return
        self._selection = x
        self.dispatch_event('on_change', self.children[self._selection])
        return True
    selection = property(_get_selection, _set_selection,
            doc='''Get/set the selected children index''')

    def _get_cover_position(self, index, alpha=0):
        x2 = self.center[0]
        if index < self._selection:
            angle = self.cover_angle
            x = x2 - self.cover_distance - (self._selection - index) * self.cover_spacing
        elif index > self._selection:
            angle = 90 + (90 - self.cover_angle)
            x = x2 + self.cover_distance + (index - self._selection) * self.cover_spacing
        else:
            angle = 0
            x = x2 - self.thumbnail_size[0] / 2.
        return angle, x

    def _calculate_coords(self):
        # calculate reflection coordinate
        c1, c2 = self.reflection_start, self.reflection_stop
        cb1, cb2 = self.cover_blend_start, self.cover_blend_stop
        self._reflection_coords = (
            (c2, c2, c2, c2), (c2, c2, c2, c2),
            (c1, c1, c1, c1), (c1, c1, c1, c1))
        self._cover_blend_coords = (
            (cb2, cb2, cb2, cb2), (cb2, cb2, cb2, cb2),
            (cb1, cb1, cb1, cb1), (c1, cb1, cb1, cb1))

    def _draw_title(self, widget):
        if hasattr(widget, 'title'):
            y2 = self.center[1] - self.thumbnail_size[1] / 2.
            drawLabel(str(getattr(widget, 'title')),
                      pos=(self.center[0], y2 + self.title_position))

    def _render_cover(self, index):
        # render the children on a fbo
        child = self.children[index]
        with self._fbo:
            self._fbo.clear()
            child.dispatch_event('on_draw')

        # pre-calculate
        y2 = self.center[1] - self.thumbnail_size[1] / 2.
        angle, x = self._get_cover_position(index, 0)

        # if a transition is in way,
        # use it to calculate angle/position from
        # current position and future position
        if self._transition != 0:
            i2 = index
            if self._transition > 0:
                i2 -= 1
            elif self._transition < 0:
                i2 += 1

            i2          = min(max(-1, i2), len(self.children))
            angle2, x2  = self._get_cover_position(i2, self._transition)

            # do linear alpha
            if self._transition > 0:
                angle   += self._transition * (angle2 - angle)
                x       += self._transition * (x2 - x)
            else:
                angle   -= self._transition * (angle2 - angle)
                x       -= self._transition * (x2 - x)

        # calculate alpha coordinate
        # this is to make cover more darker on the farest side
        # and make brighter the current displayed cover

        a = 1. - .7 * (angle / 90.)
        alpha_coords = (
            (1, 1, 1, 0), (a, a, a, 0),
            (a, a, a, 0), (1, 1, 1, 0))

        # draw !
        glTranslatef(x, y2, 0)
        glRotatef(angle, 0, 1, 0)

        # draw the cover
        if self.cover_blend:
            set_color(1, blend=True)
            drawTexturedRectangle(
                texture=self._fbo.texture,
                size=self.thumbnail_size,
                color_coords=self._cover_blend_coords)
        else:
            set_color(1)
            drawTexturedRectangle(
                texture=self._fbo.texture,
                size=self.thumbnail_size,
                color_coords=alpha_coords)

        # now, for reflection, don't do matrix transformation
        # just invert texcoord + play with color
        old_texcoords = self._fbo.texture.tex_coords
        self._fbo.texture.flip_vertical()
        self._fbo.texture.tex_coords = list(self._fbo.texture.tex_coords)
        self._fbo.texture.tex_coords[1] = self.reflection_percent
        self._fbo.texture.tex_coords[3] = self.reflection_percent

        # draw reflection
        pos = (0, -self.thumbnail_size[1] * self.reflection_percent)
        size = (self.thumbnail_size[0], self.thumbnail_size[1] * self.reflection_percent)

        # activate blending with background ?
        if self.reflection_blend:
            set_color(*self.style['bg-color'])
            drawRectangle(pos=pos, size=size)
            set_color(1, 1, 1, blend=True)

        drawTexturedRectangle(
            texture=self._fbo.texture,
            pos=pos, size=size,
            color_coords=self._reflection_coords)

        # restore fbo tex_coords
        self._fbo.texture.tex_coords = old_texcoords

        # reset our position changes
        glRotatef(angle, 0, -1, 0)
        glTranslatef(-x, -y2, 0)

    def on_update(self):
        if self._animation:
            # animate transition to the nearest cover.
            # XXX fix that same as kinetic. But kinetic algo suck right now.
            self._transition = interpolate(self._transition,
                    round(self._transition), 5)

            # update also internal position, otherwise, we have a bug when
            # selecting again a cover
            self._internal_position = (self.selection + self._transition) * self.cover_distance
        self._calculate_coords()
        super(MTCoverFlow, self).on_update()

    def on_draw(self):
        # background
        set_color(*self.style['bg-color'])
        drawRectangle(pos=self.pos, size=self.size)

        if not len(self.children):
            return

        # draw left side
        for i in xrange(0, self._selection):
            self._render_cover(i)

        # draw right side in reverse order
        for i in xrange(len(self.children) - 1, self._selection, - 1):
            self._render_cover(i)

        # draw cover
        self._render_cover(self._selection)

        # draw title ?
        if self.title_draw:
            child = self.children[self._selection]
            self._draw_title(child)
    def remove_widget(self, widget):
        super(MTCoverFlow,self).remove_widget(widget)
        _len = len(self.children)
        if self._selection >=  _len:
            self._selection = _len -1
        if self._selection < 0:
            #No more children
            #Do something appropriate (maybe hide, maybe nothing)            
            pass

########NEW FILE########
__FILENAME__ = dragable
'''
Dragable widget: a moveable widget over the window
'''

__all__ = ('MTDragable', )

from pymt.ui.widgets.widget import MTWidget
from pymt.vector import Vector

class MTDragable(MTWidget):
    '''MTDragable is a moveable widget over the window'''
    def __init__(self, **kwargs):
        super(MTDragable, self).__init__(**kwargs)
        self.state = 'normal'

    def on_touch_down(self, touch):
        if self.state == 'dragging':
            return False
        if self.collide_point(touch.x, touch.y):
            self.state = 'dragging'
            touch.grab(self)
            touch.userdata['touch_offset'] = Vector(self.pos)-touch.pos
            return True

    def on_touch_move(self, touch):
        if touch.grab_current == self:
            self.pos = touch.userdata['touch_offset'] + touch.pos
            return True

    def on_touch_up(self, touch):
        if touch.grab_current == self:
            self.state = 'normal'
            touch.ungrab(self)
            return True

########NEW FILE########
__FILENAME__ = flippable
'''
Flippable Widget: A widget with 2 sides who can flip between the sides.
'''


__all__ = ('MTFlippableWidget', )

from OpenGL.GL import glTranslatef, glRotatef
from pymt.graphx import gx_matrix, drawCSSRectangle, set_color
from pymt.ui.widgets.widget import MTWidget
from pymt.ui.animation import Animation
from pymt.utils import SafeList

class MTFlippableWidget(MTWidget):
    '''This is wrapper widget using which you can make a
    widget have two sides and you can flip between the sides ::

        from pymt import *

        widget = MTFlippableWidget()
        widget.add_widget(MTLabel(label='Front'), side='front')
        widget.add_widget(MTLabel(label='Back'), side='back')

        @widget.event
        def on_touch_down(touch):
            widget.flip()

        runTouchApp(widget)

    :Parameters:
        `flipangle` : float, default to 90.
            Angle to flip back/front

    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('flipangle', 90.)
        super(MTFlippableWidget, self).__init__(**kwargs)
        self.flipangle      = kwargs.get('flipangle')

        # For flipping animations
        self.zangle         = 0
        self.side           = 'front'

        # Holds children for both sides
        self.children_front = SafeList()
        self.children_back  = SafeList()

        self._anim_current  = None
        self._anim_back     = Animation(zangle=180)
        self._anim_front    = Animation(zangle=0)

    def add_widget(self, w, side='front', front=True):
        '''Add a widget on a side.

        :Parameters:
            `front` : boolean, default is True
                Indicate if the widget must be top added or bottom added in the list.
            `side` : string, default is 'front'
                Specify which side you want to add widget.
                (can be one of 'front', 'back' or '', defaults to add to both sides)
        '''
        assert(side in ('front', 'back', ''))
        if side == 'front':
            if front:
                self.children_front.append(w)
            else:
                self.children_front.insert(0, w)
        elif side == 'back':
            if front:
                self.children_back.append(w)
            else:
                self.children_back.insert(0, w)
        else:
            self.add_widget(w, side='front', front=front)
            self.add_widget(w, side='back', front=front)

        if self.side == side:
            super(MTFlippableWidget, self).add_widget(w, front)

        try:
            w.parent = self
        except Exception:
            pass

    def draw(self):
        set_color(*self.style.get('bg-color'))
        drawCSSRectangle(pos=(0, 0), size=self.size, style=self.style)

    def _flip_children(self):
        # This has to be called exactly half way through the animation
        # so it looks like there are actually two sides'''
        if self.side == 'front':
            self.side = 'back'
            self.children.clear()
            for x in self.children_back[:]:
                super(MTFlippableWidget, self).add_widget(x)
        else:
            self.side = 'front'
            self.children.clear()
            for x in self.children_front[:]:
                super(MTFlippableWidget, self).add_widget(x)

    def _set_side(self, to):
        assert(to in ('back', 'front'))
        if to == 'back' and self.side == 'front':
            self._flip_children()
        elif to == 'front' and self.side == 'back':
            self._flip_children()

    def flip_to(self, to):
        '''Flip to the requested side ('front' or 'back')'''
        assert(to in ('back', 'front'))
        if to == 'back' and self.side == 'front':
            self.flip()
        elif to == 'front' and self.side == 'back':
            self.flip()

    def flip(self):
        '''Triggers a flipping animation'''
        if self._anim_current:
            self._anim_current.stop()
        if self.side == 'front':
            self._anim_current = self.do(self._anim_back)
        else:
            self._anim_current = self.do(self._anim_front)

    def on_update(self):
        if self.zangle < self.flipangle:
            self._set_side('front')
        else:
            self._set_side('back')
        return super(MTFlippableWidget, self).on_update()

    def on_draw(self):
        with gx_matrix:
            glTranslatef(self.x, self.y, 0)
            glTranslatef(self.width / 2, 0, 0)
            if self.side == 'front':
                glRotatef(self.zangle, 0, 1, 0)
            else:
                glRotatef(self.zangle + 180, 0, 1, 0)
            glTranslatef(-self.width / 2, 0, 0)
            super(MTFlippableWidget, self).on_draw()

########NEW FILE########
__FILENAME__ = gesturewidget
'''
Gesture widget: a widget with on_gesture event implementation
'''

__all__ = ('MTGestureWidget', )

from pymt.gesture import Gesture
from pymt.ui.widgets.widget import MTWidget

class MTGestureWidget(MTWidget):
    '''Detect a stroke, it in a Gesture and dispatch it in an event.

    :Events:
        `on_gesture` (Gesture g, Touch touch)
            Fired when a stroke is finished
    '''
    def __init__(self):
        super(MTGestureWidget, self).__init__()
        self.register_event_type('on_gesture')
        self.points = {}
        self.db = []

    def on_touch_down(self, touch):
        if not touch.id in self.points:
            self.points[touch.id] = []
        self.points[touch.id].append((touch.x, touch.y))

    def on_touch_move(self, touch):
        if not touch.id in self.points:
            return
        self.points[touch.id].append((touch.x, touch.y))

    def on_touch_up(self, touch):
        if not touch.id in self.points:
            return
        self.points[touch.id].append((touch.x, touch.y))

        # create Gesture from stroke
        g = Gesture()
        g.add_stroke(self.points[touch.id])
        g.normalize()
        g.touchID = touch.id

        # dispatch gesture
        self.dispatch_event('on_gesture', g, touch)

        # suppress points
        del self.points[touch.id]

    def on_gesture(self, gesture, touch):
        pass

########NEW FILE########
__FILENAME__ = image
'''
MTImage: MTImage displays an image on the screen that can be repositioned.
         If you want to rotate it, use MTScatterImage instead.
'''

__all__ = ('MTImage', )

from pymt.core.image import Image
from pymt.ui.factory import MTWidgetFactory
from pymt.ui.widgets.container import MTContainer


def MTImage(arg, **kwargs):
    '''
    Convenience wrapper for MTContainer(Image(...)).
    Allows to easily display an image. For a full reference on the
    parameters accepted, please refer to the documentation of the
    `Image` class:
    '''
    return MTContainer(Image(arg, **kwargs))

MTImage.__doc__ += Image.__doc__
MTWidgetFactory.register('MTImage', MTImage)


########NEW FILE########
__FILENAME__ = kinetic
'''
Kinetic: kinetic abstraction
'''

__all__ = ('MTKinetic', )

from pymt.input import Touch
from pymt.vector import Vector
from pymt.base import getFrameDt, getCurrentTouches
from pymt.utils import boundary
from pymt.ui.widgets.widget import MTWidget

class KineticTouch(Touch):
    counter = 0
    __attrs__ = ('X', 'Y')
    def __init__(self, device):
        KineticTouch.counter += 1
        tid = 'kinetic%d' % KineticTouch.counter
        self.X = 0
        self.Y = 0
        super(KineticTouch, self).__init__(device, tid, [])
        self.mode = 'controlled'

    def depack(self, args):
        if not args:
            return
        super(KineticTouch, self).depack(args)

    def kinetic(self, touch_from):
        # copy all attributes from touch to us
        touch_from.copy_to(self)
        # pop all attribute from the old touch
        # FIXME: if we activate it, it resolve some bug, but add other.
        #while self.attr: self.pop()
        # then, prepare kinetic
        self.X += (self.x - self.dxpos)
        self.Y += (self.y - self.dypos)
        if 'kinetic' not in self.profile:
            self.profile = tuple(list(self.profile) + ['kinetic'])

class MTKinetic(MTWidget):
    '''Kinetic container.
    All widgets inside this container will have the kinetic applied
    to the touches. Kinetic is applied only if an children is touched
    on on_touch_down event.

    Kinetic will enter in the game when the on_touch_up append.
    Container will continue to send on_touch_move to children, until
    the velocity Vector is under `velstop` and sending on_touch_up ::

        from pymt import *
        k = MTKinetic()
        # theses widget will have kinetic movement
        k.add_widget(MTScatterSvg(filename='sun.svg'))
        k.add_widget(MTScatterSvg(filename='cloud.svg'))
        w = MTWindow()
        w.add_widget(k)
        runTouchApp()

    :Parameters:
        `friction` : float, defaults to 10
            The Pseudo-friction of the pseudo-kinetic scrolling.
            Formula for friction is ::

                acceleration = 1 + friction * frame_delta_time

        `velstop` : float, default to 1.0
            The distance of velocity vector to stop animation
        `max_acceleration`: int, default to 50
            Maximum acceleration allowed
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('no_css', True)
        super(MTKinetic, self).__init__(**kwargs)
        self.friction   = kwargs.get('friction', 10)
        self.velstop    = kwargs.get('velstop', 1.0)
        self.max_acceleration = kwargs.get('max_acceleration', 50)
        self.touch      = {} # internals

    def on_touch_down(self, touch):
        kt  = KineticTouch(touch.device)
        kt.kinetic(touch)
        self.touch[touch.uid] = kt
        # grab the touch for not lost it !
        touch.grab(self)
        getCurrentTouches().append(kt)
        # and dispatch !
        return super(MTKinetic, self).on_touch_down(kt)

    def on_touch_move(self, touch):
        if touch.grab_current != self:
            return
        if touch.uid not in self.touch:
            return
        kt = self.touch[touch.uid]
        kt.kinetic(touch)
        ret = super(MTKinetic, self).on_touch_move(kt)

        # dispatch kt also in grab mode
        for _wid in kt.grab_list[:]:
            wid = _wid()
            if wid is None:
                kt.grab_list.remove(_wid)
                continue
            kt.push()
            kt.x, kt.y = self.to_window(kt.x, kt.y)
            kt.dxpos, kt.dypos = self.to_window(kt.dxpos, kt.dypos)
            if wid.parent:
                kt.x, kt.y = wid.parent.to_widget(kt.x, kt.y)
                kt.dxpos, kt.dypos = wid.parent.to_widget(kt.dxpos, kt.dypos)
            else:
                kt.x, kt.y = wid.to_parent(*wid.to_widget(kt.x, kt.y))
                kt.dxpos, kt.dypos = wid.to_parent(*wid.to_widget(kt.dxpos,
                                                                  kt.dypos))
            kt.grab_current = wid
            kt.grab_state   = True
            wid.dispatch_event('on_touch_move', kt)
            kt.grab_state   = False
            kt.grab_current = None
            kt.pop()
        return ret

    def on_touch_up(self, touch):
        if touch.grab_current != self:
            return
        touch.ungrab(self)
        if touch.uid not in self.touch:
            return
        ktouch = self.touch[touch.uid]
        ktouch.userdata = touch.userdata
        ktouch.mode = 'spinning'

    def process_kinetic(self):
        '''Processing of kinetic, called in draw time.'''
        dt = getFrameDt()
        todelete = []
        acceleration = self.max_acceleration

        for touchID in self.touch:
            ktouch = self.touch[touchID]
            if abs(ktouch.X) < 0.01:
                ktouch.X = 0
            else:
                ktouch.X /= 1 + (self.friction * dt)
                ktouch.X = boundary(ktouch.X, -acceleration, acceleration)
            if abs(ktouch.Y) < 0.01:
                ktouch.Y = 0
            else:
                ktouch.Y /= 1 + (self.friction * dt)
                ktouch.Y = boundary(ktouch.Y, -acceleration, acceleration)

            if ktouch.mode != 'spinning':
                continue

            # process kinetic
            event        = ''
            ktouch.dxpos = ktouch.x
            ktouch.dypos = ktouch.y
            ktouch.x    += ktouch.X
            ktouch.y    += ktouch.Y


            if Vector(ktouch.X, ktouch.Y).length() < self.velstop:
                # simulation finished
                event = 'up'
                getCurrentTouches().remove(ktouch)
                super(MTKinetic, self).on_touch_up(ktouch)
                todelete.append(touchID)
            else:
                # simulation in progress
                event = 'move'
                super(MTKinetic, self).on_touch_move(ktouch)

            # dispatch ktouch also in grab mode
            for _wid in ktouch.grab_list[:]:
                wid = _wid()
                if wid is None:
                    ktouch.grab_list.remove(_wid)
                    continue
                ktouch.push()
                ktouch.x, ktouch.y = self.to_window(*ktouch.pos)
                ktouch.dxpos, ktouch.dypos = self.to_window(*ktouch.dpos)
                if wid.parent:
                    ktouch.x, ktouch.y = wid.parent.to_widget(
                        ktouch.x, ktouch.y)
                    ktouch.dxpos, ktouch.dypos = wid.parent.to_widget(
                        ktouch.dxpos, ktouch.dypos)
                else:
                    ktouch.x, ktouch.y = wid.to_parent(
                        *wid.to_widget(ktouch.x, ktouch.y))
                    ktouch.dxpos, ktouch.dypos = wid.to_parent(
                        *wid.to_widget(ktouch.dxpos, ktouch.dypos))
                ktouch.grab_current = wid
                ktouch.grab_state   = True
                if event == 'move':
                    wid.dispatch_event('on_touch_move', ktouch)
                else:
                    # if the widget is not visible, the on_touch_up may have
                    # disabled
                    wid.register_event_type('on_touch_up')
                    wid.dispatch_event('on_touch_up', ktouch)
                ktouch.grab_state   = False
                ktouch.grab_current = None
                ktouch.pop()

        # remove finished event
        for touchID in todelete:
            del self.touch[touchID]


    def draw(self):
        self.process_kinetic()

########NEW FILE########
__FILENAME__ = klist
'''
List: a list with kinetic effect
'''

__all__ = ('MTList', 'MTListContainer')

from pymt.graphx import gx_matrix
from pymt.utils import boundary
from pymt.base import getFrameDt
from pymt.ui.widgets.widget import MTWidget
from pymt.ui.widgets.stencilcontainer import MTStencilContainer
from pymt.config import pymt_config
from OpenGL.GL import glTranslatef

#
# Split between List and ListContainer is done
# because we don't want to duplicate on_draw from
# StencilWidget
#

class MTListContainer(MTWidget):
    '''Container for MTList.

    .. warning::
        The size of this container is taken from the first children size.

    '''
    def __init__(self, **kwargs):
        super(MTListContainer, self).__init__(**kwargs)
        self.content_x = 0
        self.content_y = 0

    def on_update(self):
        super(MTListContainer, self).on_update()
        if self.children:
            self.size = self.children[0].size

    def on_draw(self):
        with gx_matrix:
            glTranslatef(self.x + self.content_x, self.y + self.content_y, 0)
            for children in self.children[:]:
                children.dispatch_event('on_draw')

class MTList(MTStencilContainer):
    '''List with kinetic. This is the replacement of old MTKineticList().
    The MTList widget are able to scroll in 2 way, and use your widgets.

    .. warning::
        The MTList have the same behavior as MTScatterWidget: coordinates of his
        children are relative to the MTList (not fixed to the screen.)


    The MTList use a Stencil container, to prevent drawing outside his size.
    Then, it use a MTListContainer to be able to scroll his content. The
    MTListContainer size is taken from the first children in the list. We
    recommend you to use a layout for the list. Check the examples at the end of
    the page about how to use your widgets inside a layout, in the MTList.

    Some parameters are customizable in global configuration ::

        [widgets]
        list_friction = 10
        list_trigger_distance = 5

    :Parameters:
        `do_x`: bool, default to True
            Allow scrolling on X axis
        `do_y`: bool, default to True
            Allow scrolling on Y axis
        `friction`: int, default to 10 (list_friction in conf)
            Friction of scrolling movement. The formula is ::

                acceleration = 1 + friction * frame_delta_time

        `friction_bound`: int, default to 10 (list_friction_bound in conf)
            Friction of scrolling movement when position are outside bounds.
        `trigger_distance`: int, default to 5 (list_trigger_distance in config)
            If the distance between the position of the first touch contact to
            the second position is less than the trigger_distance, a event
            'down' and 'up' are dispatched on the childrens.
            Otherwise, no event are dispatched.
            (If you move the list to much, no event will be dispatched.)
        `max_acceleration`: int, default to 50
            Maximum acceleration allowed when movement is calculated
    '''
    def __init__(self, **kwargs):
        super(MTList, self).__init__(**kwargs)
        self.do_x = kwargs.get('do_x', True)
        self.do_y = kwargs.get('do_y', True)
        self.trigger_distance = kwargs.get('trigger_distance',
            pymt_config.getint('widgets', 'list_trigger_distance'))
        self.friction = kwargs.get('friction',
            pymt_config.getint('widgets', 'list_friction'))
        self.friction_bound = kwargs.get('friction',
            pymt_config.getint('widgets', 'list_friction_bound'))
        self.max_acceleration = kwargs.get('max_acceleration', 50)
        self._is_controled = False
        self.content_x = 0
        self.content_y = 0
        self._vx = 0
        self._vy = 0
        self.container = MTListContainer()
        super(MTList, self).add_widget(self.container)

    def add_widget(self, *largs):
        self.container.add_widget(*largs)

    def remove_widget(self, *largs):
        self.container.remove_widget(*largs)

    def process_kinetic(self):
        dt = getFrameDt()
        friction = self.friction
        container = self.container
        cw = container.width - self.width
        ch = container.height - self.height
        cx = self.content_x
        cy = self.content_y
        vx = self._vx
        vy = self._vy

        # prevent too much calculation at idle state
        if abs(vx) < 0.01:
            vx = 0
        if abs(vy) < 0.01:
            vy = 0

        # apply friction for movement
        if vx or vy:
            vx /= 1 + (friction * dt)
            vy /= 1 + (friction * dt)
            if self._is_controled is False:
                cx -= vx * self.do_x
                cy -= vy * self.do_y

        if self._is_controled is False:
            # make the content back to origin if it's out of bounds
            # don't go back to the initial bound, but use friction to do it in a
            # smooth way.
            #
            # if the container is smaller than our width, always align to left
            # XXX should be customizable.
            #
            f = 1 + self.friction_bound * dt
            smaller = self.width > container.width
            if cx > 0 or smaller:
                cx /= f
                vx = 0
            elif cx < -cw and not smaller:
                a = (cw + cx) / f
                cx = -cw + a
                vx = 0
            smaller = self.height > container.height
            if cy > 0 or smaller:
                cy /= f
                vy = 0
            elif cy < -ch and not smaller:
                a = (ch + cy) / f
                cy = -ch + a
                vy = 0

        # update our values
        self.content_x = container.content_x = cx
        self.content_y = container.content_y = cy
        container.pos = self.pos
        self._vx = vx
        self._vy = vy

    def on_touch_down(self, touch):
        ret = self.collide_point(*touch.pos)
        if self._is_controled:
            return ret
        if ret:
            touch.userdata['list.startpos'] = self.content_x, self.content_y
            touch.grab(self)
            self._is_controled = True
            return True

    def on_touch_move(self, touch):
        if touch.grab_current is not self:
            return
        cx, cy = touch.userdata['list.startpos']
        acceleration = self.max_acceleration
        if self.do_x:
            self.content_x = touch.x - touch.oxpos + cx
            self._vx += touch.dxpos - touch.x
            self._vx = boundary(self._vx, -acceleration, acceleration)
        if self.do_y:
            self.content_y = touch.y - touch.oypos + cy
            self._vy += touch.dypos - touch.y
            self._vy = boundary(self._vy, -acceleration, acceleration)
        return True

    def on_touch_up(self, touch):
        if touch.grab_current is not self:
            return
        touch.ungrab(self)
        self._is_controled = False

        # check if we can transmit event to children
        trigger_distance = self.trigger_distance
        if (self.do_x and abs(touch.oxpos - touch.x) > trigger_distance) or \
           (self.do_y and abs(touch.oypos - touch.y) > trigger_distance):
            return True

        # ok, the trigger distance is enough, we can dispatch event.
        # will not work if children grab the touch in down state :/
        grab_current = touch.grab_current
        grab_list = touch.grab_list[:]
        touch.push()
        touch.x -= self.content_x + self.x
        touch.y -= self.content_y + self.y

        # difficult part.
        # first, we should dispatch event as base should do
        # then, in second, we must dispatch event for widgets in the grab list
        touch.grab_current = None
        for child in reversed(self.container.children[:]):
            if child.dispatch_event('on_touch_down', touch):
                break
        for child in reversed(self.container.children[:]):
            if child.dispatch_event('on_touch_up', touch):
                break

        # now, dispatch with grab_current
        # only for new grab
        for ref in [x for x in touch.grab_list if x not in grab_list]:
            # grab are weakref, check them
            child = ref()
            if child is None:
                continue
            touch.grab_current = child
            child.dispatch_event('on_touch_up', touch)

        touch.pop()
        touch.grab_current = grab_current

        return True

    def on_update(self):
        super(MTList, self).on_update()
        self.process_kinetic()

    def on_draw(self):
        super(MTList, self).draw()
        super(MTList, self).on_draw()

    def draw(self):
        pass

########NEW FILE########
__FILENAME__ = label
'''
Label: a simple text label
'''

__all__ = ('MTLabel', )

from pymt.graphx import drawLabel, set_color, drawCSSRectangle, getLabel, getLastLabel
from pymt.ui.widgets.widget import MTWidget

class MTLabel(MTWidget):
    '''A simple label ::

        label = MTLabel(label='Plop world')

    :Parameters:
        `autosize`: bool, default to False
            Update size information with label size
        `autowidth`: bool, default to False
            Update width information with the label content width
        `autoheight`: bool, default to False
            Update height information with the label content height
        `multiline`: bool, default to False
            If True, the text will be fit inside the width

    MTLabel support all parameters from the Core label. Check 
    :py:class:`~pymt.core.text.LabelBase` class to known all availables
    parameters.
    '''

    # TODO reactivate slots
    #__slots__ = ('autowidth', 'autoheight', 'autosize', 'label',
    #    '_used_label', 'kwargs', 'anchor_x', 'anchor_y')

    def __init__(self, **kwargs):
        kwargs.setdefault('markup', False)
        kwargs.setdefault('anchor_x', 'left')
        kwargs.setdefault('anchor_y', 'bottom')
        kwargs.setdefault('autowidth', False)
        kwargs.setdefault('autoheight', False)
        kwargs.setdefault('autosize', False)
        kwargs.setdefault('label', '')
        kwargs.setdefault('multiline', False)

        self.kwargs = {}

        self.multiline  = kwargs['multiline']
        self.autowidth  = kwargs['autowidth']
        self.autoheight = kwargs['autoheight']
        self.autosize   = kwargs['autosize']
        self.anchor_x   = kwargs['anchor_x']
        self.anchor_y   = kwargs['anchor_y']
        self.label      = kwargs['label']
        del kwargs['autowidth']
        del kwargs['autoheight']
        del kwargs['autosize']
        del kwargs['label']
        del kwargs['multiline']

        super(MTLabel, self).__init__(**kwargs)

        size_specified = 'size' in kwargs or 'width' in kwargs or 'height' in kwargs
        for item in ('size', 'pos'):
            if item in kwargs:
                del kwargs[item]

        if self.multiline:
            kwargs['size'] = (self.width, None)

        self.kwargs = kwargs

        # copy style to inline one (needed for css reloading)
        if 'color' in kwargs:
            self._inline_style['color'] = kwargs['color']
        if 'font_name' in kwargs:
            self._inline_style['font-name'] = kwargs['font_name']
        if 'font_size' in kwargs:
            self._inline_style['font-size'] = kwargs['font_size']
        if 'bold' in kwargs and 'italic' in kwargs and \
            kwargs['bold'] and kwargs['italic']:
            self._inline_style['font-weight'] = 'bolditalic'
        elif 'bold' in kwargs and kwargs['bold']:
            self._inline_style['font-weight'] = 'bold'
        elif 'italic' in kwargs and kwargs['italic']:
            self._inline_style['font-weight'] = 'italic'
        if 'padding' in kwargs:
            self._inline_style['padding'] = kwargs['padding']

        # update from inline
        self.apply_css(self._inline_style)

        # update this label size
        label = getLabel(label=self.label, **kwargs)
        if not size_specified:
            self.size = label.size
        self._update_size(*label.size)
        self._used_label = label

    def apply_css(self, styles):
        super(MTLabel, self).apply_css(styles)

        # transform css attribute to style one
        s = self.style
        self.color = s['color']
        self.font_name = s['font-name']
        self.font_size = s['font-size']
        self.padding = s['padding']
        self.bold = False
        self.italic = False
        if s['font-weight'] in ('bold', 'bolditalic'):
            self.bold = True
        if s['font-weight'] in ('italic', 'bolditalic'):
            self.italic = True


    @property
    def label_obj(self):
        return self._used_label

    def draw(self):
        self.draw_background()
        self.draw_label()

    def draw_label(self, dx=0, dy=0):
        '''Method to draw the label. Accept dx/dy to be added on label position.
        This can be used to draw shadow for example.'''
        # because the anchor_x/anchor_y is propagated to the drawLabel,
        # we don't care about the internal label size.
        kwargs = self.kwargs
        pos = list(self.center)
        if self.anchor_x == 'left':
            pos[0] = self.x
        elif self.anchor_x == 'right':
            pos[0] = self.x + self.width
        if self.anchor_y == 'top':
            pos[1] = self.y + self.height
        elif self.anchor_y == 'bottom':
            pos[1] = self.y

        pos[0] += dx
        pos[1] += dy

        # ensure multiline
        if self.multiline:
            kwargs['size'] = (self.width, None)

        # force autosize
        if self.autosize or self.autowidth or self.autoheight:
            if 'size' in kwargs:
                if self.autoheight:
                    kwargs['size'] = (kwargs['size'][0], None)
                else:
                    del kwargs['size']
        else:
            # FIXME: found a way to cache this information
            # and not calculate it every frame.
            w, h = self.size
            px = self._used_label.options['padding_x']
            py = self._used_label.options['padding_y']
            w -= px * 2
            h -= py * 2
            kwargs['viewport_size'] = (w, h)

        w, h = drawLabel(label=self.label, pos=pos, **kwargs)
        self._used_label = getLastLabel()
        self._update_size(w, h)

    def draw_background(self):
        '''Draw the background of the widget'''
        set_color(*self.style['bg-color'])
        drawCSSRectangle(pos=self.pos, size=self.size, style=self.style)

    def _update_size(self, w, h):
        if (self.autoheight and self.autowidth) or self.autosize:
            self.size = (w, h)
        elif self.autoheight:
            self.height = h
        elif self.autowidth:
            self.width = w

    def _get_padding_x(self):
        return self.kwargs['padding_x']
    def _set_padding_x(self, x):
        self.kwargs['padding_x'] = x
    padding_x = property(_get_padding_x, _set_padding_x)

    def _get_padding_y(self):
        return self.kwargs['padding_x']
    def _set_padding_y(self, x):
        self.kwargs['padding_y'] = x
    padding_y = property(_get_padding_y, _set_padding_y)

    def _get_padding(self):
        return self.kwargs['padding']
    def _set_padding(self, x):
        self.kwargs['padding'] = x
    padding = property(_get_padding, _set_padding)

    def _get_font_size(self):
        return self.kwargs['font_size']
    def _set_font_size(self, x):
        self.kwargs['font_size'] = x
    font_size = property(_get_font_size, _set_font_size)

    def _get_font_name(self):
        return self.kwargs['font_name']
    def _set_font_name(self, x):
        self.kwargs['font_name'] = x
    font_name = property(_get_font_name, _set_font_name)

    def _get_bold(self):
        return self.kwargs['bold']
    def _set_bold(self, x):
        self.kwargs['bold'] = x
    bold = property(_get_bold, _set_bold)

    def _get_italic(self):
        return self.kwargs['italic']
    def _set_italic(self, x):
        self.kwargs['italic'] = x
    italic = property(_get_italic, _set_italic)

    def _get_anchor_x(self):
        return self.kwargs['anchor_x']
    def _set_anchor_x(self, x):
        self.kwargs['anchor_x'] = x
    anchor_x = property(_get_anchor_x, _set_anchor_x)

    def _get_anchor_y(self):
        return self.kwargs['anchor_y']
    def _set_anchor_y(self, x):
        self.kwargs['anchor_y'] = x
    anchor_y = property(_get_anchor_y, _set_anchor_y)

    def _get_halign(self):
        return self.kwargs['halign']
    def _set_halign(self, x):
        self.kwargs['halign'] = x
    halign = property(_get_halign, _set_halign)

    def _get_valign(self):
        return self.kwargs['valign']
    def _set_valign(self, x):
        self.kwargs['valign'] = x
    valign = property(_get_valign, _set_valign)

    def _get_color(self):
        return self.kwargs['color']
    def _set_color(self, x):
        self.kwargs['color'] = x
    color = property(_get_color, _set_color)

    def _get_markup(self):
        return self.kwargs['markup']
    def _set_markup(self, x):
        self.kwargs['markup'] = x
    markup = property(_get_markup, _set_markup, doc=
        'If true, a :py:class:`~pymt.core.label.markup.MarkupLabel` will be '
        'used instead of :py:class:`~pymt.core.label.Label`'
    )

    def _get_viewport_pos(self):
        return self.kwargs['viewport_pos']
    def _set_viewport_pos(self, x):
        self.kwargs['viewport_pos'] = x
    viewport_pos = property(_get_viewport_pos, _set_viewport_pos)

    def _get_viewport_size(self):
        return self.kwargs['viewport_size']
    viewport_size = property(_get_viewport_size)

########NEW FILE########
__FILENAME__ = abstractlayout
'''
Abstract layout: layout base for implementation
'''

__all__ = ('MTAbstractLayout', )

from pymt.ui.widgets.widget import MTWidget
from pymt.ui.animation import Animation, AnimationAlpha

class MTAbstractLayout(MTWidget):
    '''Abstract layout. Base class used to implement layout.

    :Property:
        `auto_layout` : bool, default to True
            Do layout when appropriate
        `animation_type` : str, default to None
            Specifies the easing function for animating the layout when it changes.
            Default is 'None', in which case no animation is performed at all.
            Any name of a valid AnuimationAlpha function can be used to turn on animation.
        `animation_time` : int, default to 1
            specifies the duration of the animations created when changing the layout (if any).

    :Events:
        `on_layout`
            Fired when layout function have been called
    '''

    def __init__(self, **kwargs):
        if self.__class__ == MTAbstractLayout:
            raise NotImplementedError, 'class MTAbstractLayout is abstract'

        # if standard size is bigger, then stretching does work, if other
        # things are smaller than the default (100, 100)
        kwargs.setdefault('size', (1, 1))
        # layouts automatically stretch themselves if inside another layout
        kwargs.setdefault('size_hint', (1, 1))
        kwargs.setdefault('auto_layout', True)
        kwargs.setdefault('animation_type', None)
        kwargs.setdefault('animation_duration', 1)

        self._minimum_size = (1, 1)

        super(MTAbstractLayout, self).__init__(**kwargs)

        self._animation_type    = kwargs.get('animation_type')
        self.animation_duration = kwargs.get('animation_duration')
        self.auto_layout        = kwargs.get('auto_layout')
        self.need_update        = False
        self.need_update_set    = False


        self.register_event_type('on_layout')


    def _get_minimum_size(self):
        '''
        returns minimum size of layout (based on size of fixed/minimum size of children)
        '''
        return self._minimum_size
    def _set_minimum_size(self, size):
        '''
        sets teh layout minimum size property (teh layout calculates this in update_minimum_size and uses it to perform layout calculations).
        if teh widgets size (width or height) is smaller than teh minimum size, it is resized to be at least minimum size
        '''
        self._minimum_size = size
        if self.width < size[0]:
            self.width = size[0]
        if self.height < size[1]:
            self.height = size[1]
    minimum_size = property(_get_minimum_size, _set_minimum_size)

    def _set_animation_type(self, anim_type):
        if anim_type in AnimationAlpha.__dict__ :
            self._animation_type = anim_type
        else:
            raise ValueError('"%s" is not a valid animation type! See'
                             'http://pymt.eu/wiki/DevGuide/EasingFunctions'
                             'for a list of availabe easing functions!'
                             % anim_type)
    def _get_animation_type(self):
        return self._animation_type
    animation_type = property(_get_animation_type, _set_animation_type)

    def add_widget(self, widget, front=True, do_layout=None):
        super(MTAbstractLayout, self).add_widget(widget, front=front)
        self.update_minimum_size()
        if do_layout or (not do_layout and self.auto_layout):
            self.need_update = True

    def remove_widget(self, widget, do_layout=None):
        super(MTAbstractLayout, self).remove_widget(widget)
        self.need_layout = True
        if do_layout or (not do_layout and self.auto_layout):
            self.need_update = True

    def reposition_child(self, child, **kwargs):
        if self.animation_type and len(kwargs):
            kwargs['f'] = self.animation_type
            kwargs['d'] = self.animation_duration
            child.do(Animation(**kwargs))
        else:
            for prop in kwargs:
                child.__setattr__(prop, kwargs[prop])

    def get_parent_layout(self):
        return self

    def on_parent(self):
        if not self.parent:
            return

    def update_minimum_size(self):
        self.minimum_size = self.size

    def on_move(self, x, y):
        self.need_update = True

    def on_resize(self, w, h):
        self.size = max(w, self.minimum_size[0]), max(h, self.minimum_size[1])
        self.need_update = True

    def on_update(self):
        # layout must be done 2 time, in case of children
        # are changing anythign between on_update.
        # it must be done before too, to call minimum size before apply to
        # children
        if self.need_update:
            self.need_update = False
            self.update_minimum_size()
            self.do_layout()
        super(MTAbstractLayout, self).on_update()
        if self.need_update:
            self.need_update = False
            self.update_minimum_size()
            self.do_layout()

    def on_layout(self):
        pass

    def do_layout(self):
        for w in self.children:
            w.pos = self.pos
            if w.size_hint[0]:
                w.width = w.size_hint[0] * self.width
            if w.size_hint[1]:
                w.height = w.size_hint[1] * self.height


########NEW FILE########
__FILENAME__ = anchorlayout
'''
Anchor layout: Align child widget to a border or center.

Anchors its child widgtes to a certain section of the parent,
like left, top, center, rigth...
'''

__all__ = ('MTAnchorLayout', )

from pymt.ui.widgets.layout.abstractlayout import MTAbstractLayout

class MTAnchorLayout(MTAbstractLayout):
    '''MTAnchorLayout layout: anchorts the Child Widgets to a certain place in the parent widget.
        AnchorLayout does not resize children (it ignores size_hint), us a box layout, or other layout inside anchor layout instead)

    :Parameters:
        `padding` : int, default to 0
            Padding between the border and children (ignored if anchor is center!)
        `anchor_x` : str, default to 'center'
            Horizontal Anchor.  One of: 'left', 'right, or bottom', 'center'.  default is center "
        `anchor_y` : str, default to 'center'
            Vertical Anchor.  One of: 'top', 'bottom', or 'center'.  default is center "
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('padding',  0)

        super(MTAnchorLayout, self).__init__(**kwargs)

        self._anchor_x = kwargs.get('anchor_x', 'center')
        self._anchor_y = kwargs.get('anchor_y', 'center')
        self.padding  = kwargs.get('padding')


    def _get_anchor_x(self):
        return self._anchor_x
    def _set_anchor_x(self, anchor):
        if anchor in ['left', 'right', 'center']:
            self._anchor_x = anchor
            self.need_layout = True
            self.do_layout()
        else:
            raise ValueError("'%s' is not a valid anchor for horizontal(X) axis!  Allowed values are: 'center', 'left', or 'right'." % anchor)
    anchor_x = property(_get_anchor_x, _set_anchor_x,
                        doc="Horizontal Anchor.  One of: 'left', 'right', or" +
                            "'center'.  default is center ")

    def _get_anchor_y(self):
        return self._anchor_y
    def _set_anchor_y(self, anchor):
        if anchor in ['top', 'bottom', 'center']:
            self._anchor_y = anchor
            self.need_layout = True
            self.do_layout()
        else:
            raise ValueError("'%s' is not a valid anchor for vertical(Y) axis!  Allowed values are: 'center', 'top', or 'bottom'." % anchor)
    anchor_y = property(_get_anchor_y, _set_anchor_y,
                        doc="Vertical Anchor.  One of: 'top', 'bottom', or" +
                            "'center'.  default is center ")


    def do_layout(self):
        # only acces properties once, instead of every time inside loop for
        # optimization.
        _x, _y = self.pos
        width, height = self.size
        anchor_x, anchor_y = self.anchor_x, self.anchor_y
        padding = self.padding
        reposition_child = self.reposition_child

        for c in self.children:
            x, y = _x, _y
            w, h = c.size
            if c.size_hint[0]:
                w = c.size_hint[0]*width
            elif not self.size_hint[0]:
                width = max(width, c.width)
            if c.size_hint[1]:
                h = c.size_hint[1]*height
            elif not self.size_hint[1]:
                height = max(height, c.height)

            if anchor_x == 'left':
                x = x + padding
            if anchor_x == 'right':
                x = x + width - (w + padding)
            if self.anchor_x == 'center':
                x = x + (width / 2) - (w / 2)
            if anchor_y == 'bottom':
                y = y + padding
            if anchor_y == 'top':
                y = y + height - (h + padding)
            if anchor_y == 'center':
                y = y + (height / 2) - (h / 2)

            reposition_child(c, pos=(x, y), size=(w, h))

        self.size = (width, height) #might have changed inside loop
        self.dispatch_event('on_layout')

########NEW FILE########
__FILENAME__ = boxlayout
'''
Box layout: arrange widget in horizontal or vertical
'''

__all__ = ('MTBoxLayout', )

from pymt.ui.widgets.layout.abstractlayout import MTAbstractLayout

class MTBoxLayout(MTAbstractLayout):
    '''Box layout can arrange item in horizontal or vertical orientation.

    :Parameters:
        `padding` : int, default to 0
            Padding between the border and content
        `spacing` : int, default to 1
            Spacing between widgets
        `orientation` : str, default is 'horizontal'
            Orientation of widget inside layout, can be `horizontal` or `vertical`
        'invert': bool, default to False
            makes the layout do top to bottom on horizontal, or rigth to left on vertical
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('spacing', 1)
        kwargs.setdefault('padding', 0)
        kwargs.setdefault('orientation', 'horizontal')
        kwargs.setdefault('invert', False)
        if kwargs.get('orientation') not in ['horizontal', 'vertical']:
            raise Exception('Invalid orientation, only horizontal/vertical are supported')

        super(MTBoxLayout, self).__init__(**kwargs)

        self.spacing      = kwargs.get('spacing')
        self.padding      = kwargs.get('padding')
        self._orientation = kwargs.get('orientation')
        self._invert      =  kwargs.get('invert')

    def add_widget(self, widget, front=False, do_layout=None):
        if self._invert:
            front = not front
        super(MTBoxLayout, self).add_widget(widget, front, do_layout)

    def _get_orientation(self):
        return self._orientation
    def _set_orientation(self, orientation):
        if self._orientation == orientation:
            return
        elif orientation in ['horizontal', 'vertical']:
            self._orientation = orientation
            self.do_layout()
        else:
            raise ValueError("'%s' is not a valid orientation for BoxLayout!  Allowed values are: 'horizontal' and 'vertical'." % orientation)
    orientation = property(_get_orientation, _set_orientation, doc="Orientation of widget inside layout, can be `horizontal` or `vertical`")


    def update_minimum_size(self):
        '''
        Calculates the minimum size of the layout.
        In calculation, there must be a space for child widgets that have fixed
        size (size_hint == None). There must also be at least enough space for
        every child layout's minimum size (cant be too small even if size_hint
        is set)
        '''
        padding = self.padding
        padding2 = padding * 2
        spacing = self.spacing
        width = height = padding2

        if self.orientation == 'horizontal':
            width += (len(self.children) - 1) * spacing
            for w in self.children:
                shw, shh = w.size_hint
                if shw is None:
                    width += w.width
                if shh is None:
                    height = max(w.height + padding2, height)
                if isinstance(w, MTAbstractLayout):
                    _w, _h = w.minimum_size
                    if shw is not None:
                        width += _w
                    if shh is not None:
                        height = max(_h + padding2, height)

        if self.orientation == 'vertical':
            height += (len(self.children) - 1) * spacing
            for w in self.children:
                shw, shh = w.size_hint
                if shw is None:
                    width = max(w.width + padding2, width)
                if shh is None:
                    height += w.height
                if isinstance(w, MTAbstractLayout):
                    _w, _h = w.minimum_size
                    if shw is not None:
                        width = max(_w + padding2, width)
                    if shh is not None:
                        height += _h

        self.minimum_size = (width, height)


    def do_layout(self):
        # optimize layout by preventing looking at the same attribute in a loop
        reposition_child = self.reposition_child
        selfx, selfy = self.pos
        selfw, selfh = self.size
        padding = self.padding
        spacing = self.spacing
        orientation = self.orientation
        padding2 = padding * 2

        # calculate maximum space used by size_hint
        stretch_weight_x = 0.
        stretch_weight_y = 0.
        for w in self.children:
            stretch_weight_x += w.size_hint[0] or 0.0
            stretch_weight_y += w.size_hint[1] or 0.0

        if orientation == 'horizontal':
            x = y = padding
            stretch_space = max(0.0, selfw - self.minimum_size[0])
            for c in reversed(self.children):
                shw, shh = c.size_hint
                c_pos = selfx + x, selfy + y
                c_size = list(c.size)
                if shw:
                    #its sizehint * available space
                    c_size[0] = stretch_space * shw / stretch_weight_x
                    if isinstance(c, MTAbstractLayout):
                        c_size[0] += c.minimum_size[0]
                if shh:
                    c_size[1] = shh * (selfh - padding2)
                reposition_child(c, pos=c_pos, size=c_size)
                x += c_size[0] + spacing

        if orientation == 'vertical':
            x = y = padding
            stretch_space = max(0.0, selfh - self.minimum_size[1])
            for c in self.children:
                shw, shh = c.size_hint
                c_pos = selfx + x, selfy + y
                c_size = list(c.size)
                if shh:
                    c_size[1] = stretch_space * shh / stretch_weight_y
                    if isinstance(c, MTAbstractLayout):
                        c_size[1] += c.minimum_size[1]
                if shw:
                    c_size[0] = shw * (selfw - padding2)
                reposition_child(c, pos=c_pos, size=c_size)
                y += c_size[1] + spacing

        self.dispatch_event('on_layout')

########NEW FILE########
__FILENAME__ = gridlayout
'''
Grid layout: arrange widget in a grid
'''

__all__ = ('MTGridLayout', 'GridLayoutException')

from pymt.ui.widgets.layout.abstractlayout import MTAbstractLayout

class GridLayoutException(Exception):
    pass

class MTGridLayout(MTAbstractLayout):
    '''Grid layout arrange item in a matrix.

    :Parameters:
        `cols` : int, default is None
            Number of columns in grid
        `rows` : int, default is None
            Number of rows in grid
        `spacing` : int, default to 1
            Spacing between widgets
        `uniform_width` : bool, default to False
            Try to have same width for all children
        `uniform_height` : bool, default to False
            Try to have same height for all children
    '''

    def __init__(self, **kwargs):
        kwargs.setdefault('cols', None)
        kwargs.setdefault('rows', None)
        kwargs.setdefault('spacing', 1)
        kwargs.setdefault('uniform_width', False)
        kwargs.setdefault('uniform_height', False)
        #kwargs.setdefault('size_hint', (None,None))

        super(MTGridLayout, self).__init__(**kwargs)

        self.uniform_width  = kwargs.get('uniform_width')
        self.uniform_height = kwargs.get('uniform_height')
        self.cols           = kwargs.get('cols')
        self.rows           = kwargs.get('rows')
        self.spacing        = kwargs.get('spacing')
        self.size_hint = (None, None)

        if self.cols is None and self.rows is None:
            raise GridLayoutException('Need at least cols or rows restriction.')

    def get_max_widgets(self):
        if self.cols and not self.rows:
            return None
        if self.rows and not self.cols:
            return None
        return self.rows * self.cols

    def add_widget(self, widget, front=True, do_layout=None):
        smax = self.get_max_widgets()
        if smax and len(self.children) > smax:
            raise Exception('Too much children in MTGridLayout. Increase your rows/cols!')
        super(MTGridLayout, self).add_widget(widget, front=front, do_layout=do_layout)

    def update_minimum_size(self):
        current_cols = self.cols
        current_rows = self.rows
        if current_cols is None:
            current_cols = 1 + (len(self.children) / current_rows)
        elif current_rows is None:
            current_rows = 1 + (len(self.children) / current_cols)

        cols = dict(zip(xrange(current_cols), [0] * current_cols))
        rows = dict(zip(xrange(current_rows), [0] * current_rows))

        # calculate maximum size for each columns and rows
        i = 0
        max_width = max_height = 0
        for row in range(current_rows):
            for col in range(current_cols):
                if i >= len(self.children):
                    break

                #get needed size for that child
                c = self.children[i]
                w, h = c.size
                if isinstance(c, MTAbstractLayout):
                    w, h = c.minimum_size

                cols[col] = max(cols[col], w)
                self.max_col_width = max(max_width, cols[col])

                rows[row] = max(rows[row], h)
                self.max_row_height = max(max_height, rows[row])

                i = i + 1

        # consider uniform sizeing
        if self.uniform_width:
            for col in range(current_cols):
                cols[col] = self.max_col_width
        if self.uniform_height:
            for row in range(current_rows):
                rows[row] = self.max_row_height


        # calculate minimum width/height for this widget
        width = self.spacing * (len(cols) + 1)
        height = self.spacing * (len(rows) + 1)
        for i in cols:
            width += cols[i]
        for i in rows:
            height += rows[i]

        #remeber for layout
        self.col_widths  = cols
        self.row_heights = rows

        self.minimum_size = (width, height)


    def do_layout(self):
        if len(self.children) == 0:
            return


        spacing = self.spacing
        _x, _y = self.pos
        # reposition every child
        i = 0
        y = _y + spacing
        for row_height in self.row_heights.itervalues():
            x = _x + spacing
            for col_width in self.col_widths.itervalues():
                if i >= len(self.children):
                    break
                c = self.children[i]
                # special y, we inverse order of children at reposition
                c_pos = (x, self.top - row_height - (y - _y))
                c_size = list(self.children[i].size)
                if self.uniform_width or c.size_hint[0]:
                    c_size[0] = col_width * (c.size_hint[0] or 1.0)
                if self.uniform_height or c.size_hint[1]:
                    c_size[1] = row_height * (c.size_hint[1] or 1.0)
                self.reposition_child(c, pos=c_pos, size=c_size)
                i = i + 1
                x = x + col_width + spacing
            y = y + row_height + spacing

        self.dispatch_event('on_layout')

########NEW FILE########
__FILENAME__ = screenlayout
'''
ScreenLayout: display only one widget in fullscreen at time
'''

__all__ = ('MTScreenLayout', )

from pymt.ui.widgets.layout.abstractlayout import MTAbstractLayout
from pymt.ui.widgets.layout.boxlayout import MTBoxLayout
from pymt.utils import SafeList, curry
from pymt.base import getFrameDt
from pymt.graphx import set_color, drawRectangle
from pymt.ui.widgets.button import MTButton


class MTScreenLayout(MTAbstractLayout):
    '''Base class to handle a list of screen (widgets).
    One child widget is shown at a time.

    :Parameters:
        `show_tabs`: bool, default to False
            If True, show tabs (useful for debugging)
        `duration`: float, default to 1.
            Duration to switch between screen

    '''

    def __init__(self, **kwargs):
        kwargs.setdefault('show_tabs', False)
        kwargs.setdefault('duration', 1.)
        super(MTScreenLayout, self).__init__(**kwargs)
        self.screens = SafeList()
        self.screen = None
        self.previous_screen = None
        self._switch_t = 1.1
        self.duration = kwargs.get('duration')

        self.container = MTBoxLayout(orientation='vertical')
        super(MTScreenLayout, self).add_widget(self.container)

        self.tabs = self.new_tab_layout()
        self._show_tabs  = False
        self.show_tabs = kwargs.get('show_tabs', False)

    def _get_show_tabs(self):
        return self._show_tabs
    def _set_show_tabs(self, x):
        if self._show_tabs and x is False:
            self.container.remove_widget(self.tabs)
        if x and self._show_tabs is False:
            self.container.add_widget(self.tabs)
        self._show_tabs = x
    show_tabs = property(_get_show_tabs, _set_show_tabs)


    def new_tab_layout(self):
        '''called in init, to create teh layout in which all teh tabs are put.  overwrite to create custom tab layout
        (default is box layout, vertical, height=50, with horizontal stretch.)'''
        return MTBoxLayout(size_hint=(1.0, None), height=50)

    def new_tab(self, label):
        '''fucntion that returns a new tab.  return value must be of type MTButton or derive from it (must have on_press handler) if you overwrite the method.
        A Screenlayuot subclasses can overwrite this to create tabs based with own look and feel or do other custom things when a new tab is created'''
        return MTButton(label=label, size_hint=(1, 1), height=30)

    def add_widget(self, widget, tab_name=None):
        if tab_name:
            tab_btn = self.new_tab(tab_name)
            tab_btn.push_handlers(on_press=curry(self.select, widget))
            self.tabs.add_widget(tab_btn)
            if widget.id is None:
                widget.id = tab_name
        self.screens.append(widget)

    def remove_widget(self, widget):
        for btn in self.tabs.children[:]:
            if isinstance(widget, basestring):
                if btn.label == widget:
                    self.tabs.remove_widget(btn)
                    break
            elif btn.label == widget.id or (
                hasattr(widget, 'title') and btn.label == widget.title):
                self.tabs.remove_widget(btn)
                break
        if widget in self.screens:
            self.screens.remove(widget)

    def select(self, wid, *args):
        '''
        Select which screen is to be the current one.
        pass either a widget that has been added to this layout, or its id

        This function return True if the screen is selected, of False if we
        can't select the screen (non existant)
        '''
        if self.screen is not None:
            self.container.remove_widget(self.screen)
            self.previous_screen = self.screen
            self._switch_t = -1.0
        for screen in self.screens:
            if screen.id == wid or screen == wid:
                self.screen = screen
                self.container.add_widget(self.screen, do_layout=True)
                self.screen.parent = self
                return True
        return False


    def draw_transition(self, t):
        '''
        Function is called each frame while switching screens and
        responsible for drawing transition state.
        t will go from -1.0 (previous screen), to 0 (rigth in middle),
        until 1.0 (last time called before giving new screen full controll)
        '''
        set_color(*self.style['bg-color']) #from 1 to zero
        drawRectangle(pos=self.container.pos, size=self.container.size)
        r, g, b = self.style['bg-color'][0:3]
        if t < 0:
            if self.previous_screen is not None:
                self.previous_screen.dispatch_event('on_draw')
            set_color(r, g, b, 1+t) #from 1 to zero
            drawRectangle(pos=self.container.pos, size=self.container.size)
        else:
            if self.previous_screen is not None:
                self.screen.dispatch_event('on_draw')
            set_color(r, g, b, 1-t) #from 0 to one
            drawRectangle(pos=self.container.pos, size=self.container.size)

    def on_update(self):
        if not self.screen and len(self.screens):
            self.select(self.screens[0])
        super(MTScreenLayout, self).on_update()

    def on_draw(self):
        super(MTScreenLayout, self).on_draw()
        if self._switch_t < 1.0:
            if self.duration == 0:
                self._switch_t = 1.
            else:
                self._switch_t += getFrameDt() / self.duration
            self.draw_transition(self._switch_t)

########NEW FILE########
__FILENAME__ = modalwindow
'''
Modal window: stop all interaction with background widget
'''

__all__ = ('MTModalWindow', )

from pymt.graphx import set_color, drawCSSRectangle
from pymt.ui.widgets.widget import MTWidget

class MTModalWindow(MTWidget):
    '''A static window, non-movable, with a dark background.
    Ideal to add popup or some other things. ModalWindow capture
    all touchs events.
    '''
    def __init__(self, **kwargs):
        super(MTModalWindow, self).__init__(**kwargs)

    def on_touch_down(self, touch):
        super(MTModalWindow, self).on_touch_down(touch)
        return True

    def on_touch_move(self, touch):
        super(MTModalWindow, self).on_touch_move(touch)
        return True

    def on_touch_up(self, touch):
        super(MTModalWindow, self).on_touch_up(touch)
        return True

    def draw(self):
        w = self.get_parent_window()
        if not w:
            return
        self.size = w.size
        set_color(*self.style['bg-color'])
        drawCSSRectangle(size=self.size, style=self.style)

########NEW FILE########
__FILENAME__ = objectdisplay
'''
ObjectDisplay: widget that handle fiducial object, and draw them
'''

__all__ = ('MTObjectDisplay', )

from OpenGL.GL import glTranslatef, glRotatef, glVertex2f, GL_LINES
from pymt.graphx import gx_matrix, gx_begin, set_color, drawCSSRectangle
from pymt.ui.widgets.widget import MTWidget
from math import pi

class MTObjectDisplay(MTWidget):
    '''MTObjectDisplay is a widget who draw objects on table'''
    def __init__(self, **kwargs):
        super(MTObjectDisplay, self).__init__(**kwargs)
        self.objects = {}

    def on_touch_down(self, touch):
        if not 'markerid' in touch.profile:
            return
        self.objects[touch.id] = (touch.x, touch.y, -touch.a * 180. / pi)

    def on_touch_move(self, touch):
        if touch.id in self.objects:
            self.objects[touch.id] = (touch.x, touch.y, -touch.a * 180. / pi)

    def on_touch_up(self, touch):
        if touch.id in self.objects:
            del self.objects[touch.id]

    def draw(self):
        if not self.visible:
            return

        for objectID in self.objects:
            x, y, angle = self.objects[objectID]
            with gx_matrix:
                glTranslatef(x, y, 0.0)
                glRotatef(angle, 0.0, 0.0, 1.0)

                set_color(.5)
                drawCSSRectangle(
                    pos=(-0.5 * self.width, -0.5 * self.height),
                    size=(self.width, self.height),
                    style=self.style
                )

                set_color(*self.style['vector-color'])
                with gx_begin(GL_LINES):
                    glVertex2f(0., 0.)
                    glVertex2f(0., -0.5 * self.height)

########NEW FILE########
__FILENAME__ = radial
'''
Vector slider: a radial slider that provide vector manipulation
'''

from __future__ import division

__all__ = ('MTVectorSlider', )

from OpenGL.GL import GL_POLYGON, glVertex2f
from math import cos, sin, sqrt, degrees, atan, radians
from pymt.graphx import drawCircle, set_color, gx_begin
from pymt.vector import Vector
from pymt.ui.widgets.widget import MTWidget

def _get_distance(Pos1, Pos2):
    '''Get the linear distance between two points'''
    return sqrt((Pos2[0] - Pos1[0])**2 + (Pos2[1] - Pos1[1])**2)

def prot(p, d, rp=(0, 0)):
    '''Rotates a given point(p) d degrees counter-clockwise around rp'''
    d = -radians(d)
    p = list(p)
    p[0] -= rp[0]
    p[1] -= rp[1]
    np = [p[0]*cos(d) + p[1]*sin(d), -p[0]*sin(d) + p[1]*cos(d)]
    np[0] += rp[0]
    np[1] += rp[1]
    return tuple(np)

class MTVectorSlider(MTWidget):
    '''
    This is a slider that provides an arrow, and allows you to manipulate
    it just like any other vector, adjusting its angle and amplitude.

    :Parameters:
        `radius` : int, default to 200
            The radius of the whole widget

    :Events:
        `on_amplitude_change`: (amplitude)
            Fired when amplitude is changed
        `on_angle_change`: (angle)
            Fired when angle is changed
        `on_vector_change`: (amplitude, angle)
            Fired when vector is changed

    :Styles:
        `vector-color` : color
            Color of the vector
        `slider-color` : color
            Color of the triangle
        `bg-color` : color
            Background color of the slider
    '''

    def __init__(self, **kwargs):
        kwargs.setdefault('radius', 200)

        super(MTVectorSlider, self).__init__(**kwargs)

        self.radius = kwargs.get('radius')

        self.vector = Vector(self.x+self.radius, self.y)
        self.amplitude = 0
        self.angle = 0

        self.register_event_type('on_amplitude_change')
        self.register_event_type('on_angle_change')
        self.register_event_type('on_vector_change')

    def on_amplitude_change(self, *largs):
        pass

    def on_angle_change(self, *largs):
        pass

    def on_vector_change(self, *largs):
        pass

    def collide_point(self, x, y):
        '''Because this widget is a circle, and this method as
        defined in MTWidget is for a square, we have to override
        it.'''
        return _get_distance(self.pos, (x, y)) <= self.radius

    def _calc_stuff(self):
        '''Recalculated the args for the callbacks'''
        self.amplitude = self.vector.distance(self.pos)
        # Make a new vector relative to the origin
        tvec = [self.vector[0], self.vector[1]]
        tvec[0] -= self.pos[0]
        tvec[1] -= self.pos[1]

        # Incase python throws float div or div by zero exception,
        # ignore them, we will be close enough
        try:
            self.angle = degrees(atan((int(tvec[1])/int(tvec[0]))))
        except Exception:
            pass

        # Ajdust quadrants so we have 0-360 degrees
        if tvec[0] < 0 and tvec[1] > 0:
            self.angle = 90 + (90 + self.angle)
        elif tvec[0] < 0 and tvec[1] < 0:
            self.angle += 180
        elif tvec[0] > 0 and tvec[1] < 0:
            self.angle = 270 + (self.angle + 90)
        elif tvec[0] > 0 and tvec[1] > 0:
            pass

    def on_touch_down(self, touch):
        if self.collide_point(touch.x, touch.y):
            self.vector[0], self.vector[1] = touch.x, touch.y
            self._calc_stuff()

            self.dispatch_event('on_aplitude_change', self.amplitude)
            self.dispatch_event('on_angle_change', self.angle)
            self.dispatch_event('on_vector_change', self.amplitude, self.angle)

            return True
    def on_touch_move(self, touch):
        if self.collide_point(touch.x, touch.y):
            self.vector[0], self.vector[1] = touch.x, touch.y
            self._calc_stuff()

            self.dispatch_event('on_aplitude_change', self.amplitude)
            self.dispatch_event('on_angle_change', self.angle)
            self.dispatch_event('on_vector_change', self.amplitude, self.angle)

            return True

    def draw(self):
        # Background
        set_color(*self.style.get('bg-color'))
        drawCircle(self.pos, self.radius)

        # A good size for the hand, proportional to the size of the widget
        hd = self.radius / 10
        # Draw center of the hand
        set_color(*self.style.get('vector-color'))
        drawCircle(self.pos, hd)
        # Rotate the triangle so its not skewed
        l = prot((self.pos[0] - hd, self.pos[1]), self.angle-90, self.pos)
        h = prot((self.pos[0] + hd, self.pos[1]), self.angle-90, self.pos)
        # Draw triable of the hand
        with gx_begin(GL_POLYGON):
            glVertex2f(*l)
            glVertex2f(*h)
            glVertex2f(self.vector[0], self.vector[1])

if __name__ == '__main__':
    def on_vector_change(amp, ang):
        print amp, ang

    from pymt import MTWindow, runTouchApp
    w = MTWindow(fullscreen=False)
    mms = MTVectorSlider(pos=(200, 200))
    mms.push_handlers('on_vector_change', on_vector_change)
    w.add_widget(mms)
    runTouchApp()

########NEW FILE########
__FILENAME__ = rectangle
'''
Rectangle widget: draw a rectangle of his pos/size
'''

__all__ = ('MTRectangularWidget', )

from pymt.graphx import set_color, drawCSSRectangle
from pymt.ui.widgets.widget import MTWidget

class MTRectangularWidget(MTWidget):
    '''A rectangular widget that only propagates and handles
    events if the event was within its bounds.
    '''
    def __init__(self, **kwargs):
        super(MTRectangularWidget, self).__init__(**kwargs)

    def on_touch_down(self, touch):
        if self.collide_point(touch.x, touch.y):
            super(MTRectangularWidget, self).on_touch_down(touch)
            return True

    def on_touch_move(self, touch):
        if self.collide_point(touch.x, touch.y):
            super(MTRectangularWidget, self).on_touch_move(touch)
            return True

    def on_touch_up(self, touch):
        if self.collide_point(touch.x, touch.y):
            super(MTRectangularWidget, self).on_touch_up(touch)
            return True

    def draw(self):
        set_color(*self.style.get('bg-color'))
        drawCSSRectangle(pos=self.pos, size=self.size, style=self.style)

########NEW FILE########
__FILENAME__ = scatter
'''
Scatter package: provide lot of widgets based on scatter (base, svg, plane, image...)
'''

__all__ = ('MTScatterWidget', 'MTScatterSvg', 'MTScatterPlane',
           'MTScatterImage', 'MTScatter')

from numpy import ascontiguousarray
from pymt.lib.transformations import matrix_multiply, identity_matrix, \
        translation_matrix, rotation_matrix, scale_matrix, inverse_matrix
from pymt.core.image import Image
from pymt.logger import pymt_logger
from pymt.ui.widgets.svg import MTSvg
from pymt.ui.widgets.widget import MTWidget
from pymt.utils import deprecated, serialize_numpy, deserialize_numpy
from pymt.vector import Vector
from math import radians
from OpenGL.GL import glMultMatrixf
from pymt.graphx import drawCSSRectangle, set_color, gx_matrix


class MTScatter(MTWidget):
    '''MTScatter is a scatter widget based on MTWidget.
    You can scale, rotate and move with one and two finger.

    :Parameters:
        `rotation` : float, default to 0.0
            Set initial rotation of widget
        `translation` : list, default to (0,0)
            Set the initial translation of widget
        `scale` : float, default to 1.0
            Set the initial scaling of widget
        `do_rotation` : boolean, default to True
            Set to False for disabling rotation
        `do_translation` : boolean or list, default to True
            Set to False for disabling translation, and ['x'], ['y'] for limit translation only on x or y
        `do_scale` : boolean, default to True
            Set to False for disabling scale
        `auto_bring_to_front` : boolean, default to True
            Set to False for disabling widget bring to front
        `scale_min` : float, default to 0.01
            Minimum scale allowed. Don't set to 0, or you can have error with singular matrix.
            The 0.01 mean you can de-zoom up to 10000% (1/0.01*100).
        `scale_max` : float, default to None
            Maximum scale allowed.

    :Events:
        `on_transform` (rotation, scale, trans, intersect)
            Fired whenever the Scatter Widget is transformed (rotate, scale, moved, or zoomed).
    '''

    def __init__(self, **kwargs):
        super(MTScatter, self).__init__(**kwargs)

        self.register_event_type('on_transform')

        # private properties
        self._touches = []
        self._last_touch_pos = {}
        self._do_rotation = True
        self._do_scale = True
        self._do_translation = True
        self._do_translation_x = True
        self._do_translation_y = True

        self._transform        = identity_matrix()
        self._transform_inv    = identity_matrix()
        self._transform_gl     = ascontiguousarray(identity_matrix().T,
                                                   dtype='float32')
        self._transform_inv_gl = ascontiguousarray(identity_matrix().T,
                                                   dtype='float32')
        self.update_matrices()

        #enable/dissable features
        self.auto_bring_to_front = kwargs.get('auto_bring_to_front', True)
        self.do_translation = kwargs.get('do_translation', True)
        self.do_rotation    = kwargs.get('do_rotation', True)
        self.scale_min      = kwargs.get('scale_min', 0.01)
        self.scale_max      = kwargs.get('scale_max', 1e20)
        self.do_scale       = kwargs.get('do_scale', True)

        #inital transformation
        self.scale = kwargs.get('scale', 1)
        self.rotation = kwargs.get('rotation', 0)
        if kwargs.get('pos') and kwargs.get('center'):
            pymt_logger.exception('both "pos" and "center" set in MTScatter'
                                  'constructor, only use one of the two!')
        if kwargs.get('pos'):
            self.pos = kwargs.get('pos')
        if kwargs.get('center'):
            self.pos = kwargs.get('center')

    def _get_do_rotation(self):
        return self._do_rotation == 1
    def _set_do_rotation(self, flag):
        self._do_rotation = flag
    do_rotation = property(_get_do_rotation, _set_do_rotation,
        doc='Determines whether user interaction can rotate the widget')

    def _get_do_scale(self):
        return self._do_scale
    def _set_do_scale(self, flag):
        self._do_scale = flag
        if not self._do_scale:
            self.scale_max = self.scale_min = self.scale
    do_scale = property(_get_do_scale, _set_do_scale,
        doc='Determines whether user interaction can scale the widget')

    def _get_do_translation(self):
        return self._do_translation
    def _set_do_translation(self, val):
        self._do_translation = val
        self._do_translation_x = self._do_translation_y = 0.0
        if type(val) in (list, tuple, str):
            self._do_translation_x = 'x' in self.do_translation
            self._do_translation_y = 'y' in self.do_translation
        elif val:
            self._do_translation_x = self._do_translation_y = 1.0
    do_translation = property(_get_do_translation, _set_do_translation, doc='Determines whether user interaction can translate the widget')


    @property
    def bbox(self):
        '''
        Returns the bounding box of the widget in parent space ::

            ((x, y), (w, h)
            # x, y = lower left corner

        '''
        xmin, ymin = xmax, ymax = self.to_parent(0, 0)
        for point in [(self.width, 0), (0, self.height), self.size]:
            x, y = self.to_parent(*point)
            if x < xmin:
                xmin = x
            if y < ymin:
                ymin = y
            if x > xmax:
                xmax = x
            if y > ymax:
                ymax = y
        return (xmin, ymin), (xmax-xmin, ymax-ymin)

    def _get_center(self):
        return (self.bbox[0][0] + self.bbox[1][0]/2.0,
                self.bbox[0][1] + self.bbox[1][1]/2.0)
    def _set_center(self, center):
        if center == self.center:
            return False
        t = Vector(*center) - self.center
        trans = translation_matrix( (t.x, t.y, 0) )
        self.apply_transform(trans)
    center = property(_get_center, _set_center)

    def _get_pos(self):
        return self.bbox[0]
    def _set_pos(self, pos):
        _pos = self.bbox[0]
        if pos == _pos:
            return
        t = Vector(*pos) - _pos
        trans = translation_matrix( (t.x, t.y, 0) )
        self.apply_transform(trans)
    pos = property(_get_pos, _set_pos, doc='Object position (x, y).  Lower left of bounding box for rotated scatter')

    def _get_x(self):
        return self.pos[0]
    def _set_x(self, x):
        if x == self.pos[0]:
            return False
        self.pos = (x, self.y)
        return True
    x = property(_get_x, _set_x)

    def _get_y(self):
        return self.pos[1]
    def _set_y(self, y):
        if y == self.pos[1]:
            return False
        self.pos = (self.x, y)
        return True
    y = property(_get_y, _set_y)

    def _get_rotation(self):
        v1 = Vector(0, 10)
        v2 = Vector(*self.to_parent(*self.pos)) - self.to_parent(self.x, self.y + 10)
        return -1.0 *(v1.angle(v2) + 180) % 360
    def _set_rotation(self, rotation):
        angle_change = self.rotation - rotation
        r = rotation_matrix(-radians(angle_change), (0, 0, 1))
        self.apply_transform(r, post_multiply=True, anchor=self.to_local(*self.center))
    rotation = property(_get_rotation, _set_rotation,
        doc='''Get/set the rotation around center of the object (in degree)''')

    def _get_scale(self):
        p1 = Vector(*self.to_parent(0, 0))
        p2 = Vector(*self.to_parent(1, 0))
        scale = p1.distance(p2)
        return float(scale)
    def _set_scale(self, scale):
        #scale = boundary(scale, self.scale_min, self.scale_max) 
        rescale = scale * 1.0/self.scale
        self.apply_transform(scale_matrix(rescale), post_multiply=True, anchor=self.to_local(*self.center))
    scale = property(_get_scale, _set_scale,
        doc='''Get/set the scale factor of the object''')
    _scale = property(_get_scale, _set_scale, doc='''
        ..deprecated:: 0.5
        Get/set the scale factor of the object
    ''')


    @property
    @deprecated
    def transform_mat(self):
        '''..deprecated:: 0.5
        Use transform_gl for an OpenGL transformation instead.
        '''
        return self._transform_gl

    @property
    def transform_gl(self):
        '''Return the transformation matrix for OpenGL, read only.
        '''
        return self._transform_gl

    @property
    def transform_inv_gl(self):
        '''Return the inverse transformation matrix for OpenGL, read only.
        '''
        return self._transform_inv_gl

    @property
    def transform_inv(self):
        '''Inverse of transformation matrix (numpy matrix), read only.
        '''
        return self._transform_inv

    def _get_transform(self):
        return self._transform
    def _set_transform(self, x):
        self._transform = x
        self.update_matrices()
    transform = property(_get_transform, _set_transform,
        doc='Get/Set transformation matrix (numpy matrix)')

    def _get_state(self):
        return serialize_numpy(self._transform)
    def _set_state(self, state):
        self.transform = deserialize_numpy(state)
    state = property(_get_state, _set_state,
        doc='Save/restore the state of matrix widget (require numpy)')

    def collide_point(self, x, y):
        if not self.visible:
            return False
        local_coords = self.to_local(x, y)
        if local_coords[0] > 0 and local_coords[0] < self.width \
           and local_coords[1] > 0 and local_coords[1] < self.height:
            return True
        else:
            return False

    def to_parent(self, x, y, **k):
        p = matrix_multiply(self._transform, (x, y, 0, 1))
        return (p[0], p[1])

    def to_local(self, x, y, **k):
        p = matrix_multiply(self._transform_inv, (x, y, 0, 1))
        return (p[0], p[1])

    def apply_angle_scale_trans(self, angle, scale, trans, point=Vector(0, 0)):
        '''Update matrix transformation by adding new angle, scale and translate.

        :Parameters:
            `angle` : float
                Rotation angle to add
            `scale` : float
                Scaling value to add
            `trans` : Vector
                Vector translation to add
            `point` : Vector, default to (0, 0)
                Point to apply transformation
        '''
        old_scale = self.scale
        new_scale = old_scale * scale
        if new_scale < self.scale_min or old_scale > self.scale_max:
            scale = 1

        t = translation_matrix((trans[0]*self._do_translation_x, trans[1]*self._do_translation_y, 0))
        t = matrix_multiply(t, translation_matrix( (point[0], point[1], 0)))
        t = matrix_multiply(t, rotation_matrix(angle, (0, 0, 1)))
        t = matrix_multiply(t, scale_matrix(scale))
        t = matrix_multiply(t, translation_matrix((-point[0], -point[1], 0)))
        self.apply_transform(t)

        self.dispatch_event('on_transform', None)

    def apply_transform(self, trans, post_multiply=False, anchor=(0, 0)):
        '''
        Transforms scatter by trans (on top of its current transformation state)

        :Parameters:
            `trans`: transformation matrix from transformation lib.
                Transformation to be applied to the scatter widget
            `anchor`: tuple, default to (0, 0)
                The point to use as the origin of the transformation
                (uses local widget space)
            `post_multiply`: bool, default to False
                If true the transform matrix is post multiplied
                (as if applied before the current transform)
        '''
        t = translation_matrix( (anchor[0], anchor[1], 0) )
        t = matrix_multiply(t, trans)
        t = matrix_multiply(t, translation_matrix( (-anchor[0], -anchor[1], 0) ))

        if post_multiply:
            self.transform = matrix_multiply(self._transform, t)
        else:
            self.transform = matrix_multiply(t, self._transform)

    def update_matrices(self):
        '''Update inverse and OpenGL matrices, from the current transformation.
        If you change manually the transformation, you should call this
        function, or the drawing will failed.
        '''
        self._transform_inv = inverse_matrix(self._transform)
        self._transform_gl = ascontiguousarray(self._transform.T,
                                               dtype='float32')
        self._transform_inv_gl = ascontiguousarray(self._transform.T,
                                                   dtype='float32')

    def _apply_drag(self, touch):
        #_last_touch_pos has last pos in correct parent space, just liek incoming touch
        dx = (touch.x - self._last_touch_pos[touch][0]) * self._do_translation_x
        dy = (touch.y - self._last_touch_pos[touch][1]) * self._do_translation_y
        self.apply_transform(translation_matrix((dx, dy, 0)))
        self.dispatch_event('on_transform', touch)

    def transform_with_touch(self, touch):
        # just do a simple one finger drag
        if len(self._touches) == 1:
            return self._apply_drag(touch)

        # we have more than one touch...
        points = [Vector(*self._last_touch_pos[t]) for t in self._touches] 

        # we only want to transform if the touch is part of the two touches
        # furthest apart! So first we find anchor, the point to transform
        # around as the touch farthest away from touch
        anchor  = max(points, key=lambda p: p.distance(touch.pos))

        # now we find the touch farthest away from anchor, if its not the
        # same as touch. Touch is not one of the two touches used to transform
        farthest = max(points, key=anchor.distance)
        if points.index(farthest) != self._touches.index(touch):
            return

        # ok, so we have touch, and anchor, so we can actually compute the
        # transformation        
        old_line = Vector(*touch.dpos) - anchor
        new_line = Vector(*touch.pos) - anchor

        angle = radians( new_line.angle(old_line) ) * self._do_rotation
        scale = new_line.length() / old_line.length()
        new_scale = scale * self.scale
        if new_scale < self.scale_min or new_scale > self.scale_max:
            scale = 1.0

        self.apply_transform(rotation_matrix(angle, (0, 0, 1)), anchor=anchor)
        self.apply_transform(scale_matrix(scale), anchor=anchor)

        #dispatch on_transform with th touch that caused it
        self.dispatch_event('on_transform', touch)

    def on_transform(self, touch):
        pass

    def on_touch_down(self, touch):
        x, y = touch.x, touch.y
        # if the touch isnt on the widget we do nothing
        if not self.collide_point(x, y):
            return False

        # let the child widgets handle the event if they want
        touch.push()
        touch.apply_transform_2d(self.to_local)
        if super(MTScatter, self).on_touch_down(touch):
            touch.pop()
            return True
        touch.pop()

        #grab the touch so we get all it later move events for sure
        touch.grab(self)
        self._last_touch_pos[touch] = touch.pos
        self._touches.append(touch)

        #bring to front if auto_bring to front is on
        if self.auto_bring_to_front:
            self.bring_to_front()
        return True

    def on_touch_move(self, touch):
        x, y = touch.x, touch.y
        # let the child widgets handle the event if they want
        if self.collide_point(x, y) and not touch.grab_current == self:
            touch.push()
            touch.apply_transform_2d(self.to_local)
            if super(MTScatter, self).on_touch_move(touch):
                touch.pop()
                return True
            touch.pop()

        # rotate/scale/translate
        if touch in self._touches and touch.grab_current == self:
            self.transform_with_touch (touch)
            self._last_touch_pos[touch] = touch.pos

        # stop porpagating if its within our bounds
        if self.collide_point(x, y):
            return True

    def on_touch_up(self, touch):
        x, y = touch.x, touch.y
        # if the touch isnt on the widget we do nothing, just try children
        if not touch.grab_current == self:
            touch.push()
            touch.apply_transform_2d(self.to_local)
            if super(MTScatter, self).on_touch_up(touch):
                touch.pop()
                return True
            touch.pop()

        # remove it from our saved touches
        if touch in self._touches and touch.grab_state:
            touch.ungrab(self)
            del self._last_touch_pos[touch]
            self._touches.remove(touch)

        # stop porpagating if its within our bounds
        if self.collide_point(x, y):
            return True

    def on_draw(self):
        if not self.visible:
            return
        with gx_matrix:
            glMultMatrixf(self._transform_gl)
            super(MTScatter, self).on_draw()

    def draw(self):
        set_color(*self.style['bg-color'])
        drawCSSRectangle(pos=(0, 0), size=(self.width, self.height), style=self.style)


class MTScatterWidget(MTScatter):
    '''This class is deprecated, you should use MTScatter now.'''
    pass


class MTScatterPlane(MTScatterWidget):
    '''A Plane that transforms for zoom/rotate/pan.
    if none of the childwidgets handles the input
    (the background is touched), all of them are transformed
    together
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('auto_bring_to_front', False)
        super(MTScatterPlane, self).__init__(**kwargs)

    def draw(self):
        pass

    def collide_point(self, x, y):
        return self.visible


class MTScatterImage(MTScatterWidget):
    '''MTScatterImage is a image showed in a Scatter widget

    :Parameters:
        `filename` : str
            Filename of image
        `image` : Image
            Instead of using filename, use a Image object
        `opacity` : float, default to 1.0
            Used to set the opacity of the image.
        `scale` : float, default is 1.0
            Scaling of image, default is 100%, ie 1.0
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('filename', None)
        kwargs.setdefault('opacity', 1.0)
        kwargs.setdefault('scale', 1.0)
        kwargs.setdefault('image', None)
        if kwargs.get('filename') is None and kwargs.get('image') is None:
            raise Exception('No filename or image given to MTScatterImage')

        super(MTScatterImage, self).__init__(**kwargs)
        self._filename      = ''
        self.image          = kwargs.get('image')
        self.scale          = kwargs.get('scale')
        self.filename       = kwargs.get('filename')
        self.opacity        = kwargs.get('opacity')
        self.size           = self.image.size

    def _get_filename(self):
        return self._filename
    def _set_filename(self, filename):
        self._filename = filename
        if filename:
            self.image = Image(self.filename)
    filename = property(_get_filename, _set_filename)

    def draw(self):
        self.size           = self.image.size
        self.image.opacity  = self.opacity
        self.image.draw()

class MTScatterSvg(MTScatterWidget):
    '''Render an svg image into a scatter widget

    :Parameters:
        `filename` : str
            Filename of image
        `rawdata` : str
            Raw data of the image. If given, the filename property is used only for cache purposes.
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('filename', None)
        if kwargs.get('filename') is None:
            raise Exception('No filename given to MTSvg')
        kwargs.setdefault('rawdata', None)
        super(MTScatterSvg, self).__init__(**kwargs)
        self.squirt = MTSvg(filename=kwargs.get('filename'), rawdata=kwargs.get('rawdata'))
        self.size = (self.squirt.svg.width, self.squirt.svg.height)

    def draw(self):
        self.squirt.draw()


########NEW FILE########
__FILENAME__ = sidepanel
'''
Side panel: a panel widget that attach to a side of the screen
'''

__all__ = ('MTSidePanel', )

from pymt.graphx import drawCSSRectangle, set_color
from pymt.ui.animation import Animation
from pymt.ui.widgets.widget import MTWidget

class MTSidePanel(MTWidget):
    '''A panel widget that attach to a side of the screen
    (similar to gnome-panel for linux user).

    :Parameters:
        `align` : str, default to 'center'
            Alignement on the side. Can be one of
            'left', 'right', 'top', 'bottom', 'center', 'middle'.
            For information, left-bottom, center-middle, right-top have the
            same meaning.
        `corner` : MTWidget object, default to None
            Corner object to use for pulling in/out the layout. If None
            is provided, the default will be a MTButton() with appropriate
            text label (depend of side)
        `corner_size` : int, default to 30
            Size of the corner, can be the width or height, it depend of side.
        `duration` : float, default to 0.5
            Animation duration for pull in/out
        `hide` : bool, default to True
            If true, the widget will be hide by default, otherwise,
            the panel is showed
        `layout` : AbstractLayout object, default to None
            Layout to use inside corner widget. If None is provided,
            the default will be a MTBoxLayout() with default parameters
        `side` : str, default to 'left'
            Side to attach the widget. Can be one of
            'left', 'right', 'top', 'bottom'.
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('hide', True)

        super(MTSidePanel, self).__init__(**kwargs)

        self.side        = kwargs.get('side', 'left')
        self.align       = kwargs.get('align', 'center')
        self.corner_size = kwargs.get('corner_size', 30)
        self.duration    = kwargs.get('duration', .5)
        layout           = kwargs.get('layout', None)
        corner           = kwargs.get('corner', None)

        assert(self.side in ('bottom', 'top', 'left', 'right'))
        assert(self.align in ('bottom', 'top', 'left', 'right', 'middle', 'center'))

        if layout is None:
            from pymt.ui.widgets.layout import MTBoxLayout
            layout = MTBoxLayout()
        self.layout = layout
        super(MTSidePanel, self).add_widget(layout)

        if corner is None:
            from pymt.ui.widgets.button import MTButton
            if self.side == 'right':
                label = '<'
            elif self.side == 'left':
                label = '>'
            elif self.side == 'top':
                label = 'v'
            elif self.side == 'bottom':
                label = '^'
            corner = MTButton(label=label)
        else:
            self.corner_size = None
        self.corner = corner
        # Don't add to front or widgets added as children of layout will be occluded
        super(MTSidePanel, self).add_widget(self.corner, front=False)
        self.corner.connect('on_press', self._corner_on_press)

        self.initial_pos = self.pos
        self.need_reposition = True

        if kwargs.get('hide'):
            self.layout.visible = False
            self.hide()

    def add_widget(self, widget):
        self.layout.add_widget(widget)

    def remove_widget(self, widget):
        self.layout.remove_widget(widget)

    def _corner_on_press(self, *largs):
        if self.layout.visible:
            self.hide()
        else:
            self.show()
        return True

    def show(self):
        dpos = self._get_position_for(True)
        self.layout.visible = True
        self.layout.do(Animation(duration=self.duration, f='ease_out_cubic', pos=dpos))

    def _on_animation_complete_hide(self, *largs):
        self.layout.visible = False

    def hide(self):
        dpos = self._get_position_for(False)
        if dpos is None:
            return
        anim = Animation(duration=self.duration, f='ease_out_cubic', pos=dpos)
        anim.connect('on_complete', self._on_animation_complete_hide)
        self.layout.do(anim)

    def _get_position_for(self, visible):
        # get position for a specific state (visible or not visible)
        w = self.get_parent_window()
        if not w:
            return

        side = self.side
        x = self.layout.x
        y = self.layout.y
        if visible:
            if side == 'right':
                x = w.width - self.layout.width
            elif side == 'top':
                y = w.height - self.layout.height
            elif side == 'left':
                x = 0
            elif side == 'bottom':
                y = 0
        else:
            if side == 'left':
                x, y = (-self.layout.width, self.y)
            elif side == 'right':
                x, y = (w.width, self.y)
            elif side == 'top':
                x, y = (self.x, w.height)
            elif side == 'bottom':
                x, y = (self.x, -self.layout.height)
        return x, y

    def on_update(self):
        w = self.get_parent_window()
        side = self.side
        align = self.align

        # first execution, need to place layout in the good size
        if self.need_reposition:
            dpos = self._get_position_for(self.layout.visible)
            self.layout.pos = dpos
            self.need_reposition = False

        # adjust size + configure position
        cw, ch = self.corner.size
        if side in ('left', 'right'):
            if self.corner_size is not None:
                self.corner.size = (self.corner_size, self.layout.height)
            if align in ('bottom', 'left'):
                cy = ly = 0
            elif align in ('top', 'right'):
                ly = w.height - self.layout.height
                cy = w.height - ch
            elif align in ('center', 'middle'):
                ly = w.center[1] - self.layout.height / 2.
                cy = w.center[1] - ch / 2.
            self.layout.y = ly
        elif side in ('top', 'bottom'):
            if self.corner_size is not None:
                self.corner.size = (self.layout.width, self.corner_size)
            if align in ('bottom', 'left'):
                cx = lx = 0
            elif align in ('top', 'right'):
                lx = w.width - self.layout.width
                cx = w.width - cw
            elif align in ('center', 'middle'):
                lx = w.center[0] - self.layout.width / 2.
                cx = w.center[0] - cw / 2.
            self.layout.x = lx
        if side == 'left':
            cx = self.layout.x + self.layout.width
        elif side == 'right':
            cx = self.layout.x - self.corner.width
        elif side == 'top':
            cy = self.layout.y - self.corner.height
        elif side == 'bottom':
            cy = self.layout.y + self.layout.height

        # place corner :)
        self.corner.pos  = (cx, cy)
        super(MTSidePanel, self).on_update()

    def on_move(self, x, y):
        self.initial_pos = x, y
        self.layout.pos  = x, y

    def draw(self):
        if not self.layout.visible:
            return
        set_color(*self.style.get('bg-color'))
        drawCSSRectangle(pos=self.layout.pos, size=self.layout.size, style=self.style)

    # optimization

    def on_touch_down(self, touch):
        if self.corner.dispatch_event('on_touch_down', touch):
            return True
        return super(MTSidePanel, self).on_touch_down(touch)

    def on_touch_move(self, touch):
        if self.corner.dispatch_event('on_touch_move', touch):
            return True
        return super(MTSidePanel, self).on_touch_move(touch)

    def on_touch_up(self, touch):
        if self.corner.dispatch_event('on_touch_up', touch):
            return True
        return super(MTSidePanel, self).on_touch_up(touch)

########NEW FILE########
__FILENAME__ = slider
'''
Slider package: provide multiple slider implementation (simple, xy, boundary...)
'''

from __future__ import division

__all__ = ('MTSlider', 'MTXYSlider', 'MTBoundarySlider', 'MTMultiSlider')

import random
from pymt.ui.widgets.widget import MTWidget
from pymt.graphx import drawRectangle, drawCircle, drawLabel, set_color, \
        drawCSSRectangle

class MTSlider(MTWidget):
    '''MTSlider is an implementation of a scrollbar using MTWidget.

    :Parameters:
        `min` : int, default is 0
            Minimum value of slider
        `max` : int, default is 100
            Maximum value of slider
        `orientation` : str, default is vertical
            Type of orientation, can be 'horizontal' or 'vertical'
        `value` : int, default is `min`
            Default value of slider
        `value_show` : bool, default to False
            Show value on the slider
        `value_format` : str, default to '%d'
            If value is showed, this is the format used for drawing value
        `value_config` : dict, default to {}
            Settings to pass to drawLabel()
    :Styles:
        `slider-color` : color
            Color of the slider
        `slider-color-down` : color
            Color of the slider when pressed down (same as slider-color by default)
        `bg-color` : color
            Background color of the slider
        `padding` : int
            Padding of content

    :Events:
        `on_value_change` (value)
            Fired when slider value is changed
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('min', 0)
        kwargs.setdefault('max', 100)
        kwargs.setdefault('orientation', 'vertical')
        kwargs.setdefault('value_show', False)
        kwargs.setdefault('value_format', '%d')
        kwargs.setdefault('value_config', {})
        if kwargs.get('orientation') == 'vertical':
            kwargs.setdefault('size', (30, 400))
        else:
            kwargs.setdefault('size', (400, 30))
        kwargs.setdefault('value', None)

        super(MTSlider, self).__init__(**kwargs)
        self.register_event_type('on_value_change')
        self.touchstarts    = [] # only react to touch input that originated on this widget
        self.orientation    = kwargs.get('orientation')
        self.min            = kwargs.get('min')
        self.max            = kwargs.get('max')
        self.value_show     = kwargs.get('value_show')
        self.value_format   = kwargs.get('value_format')
        self.value_config   = kwargs.get('value_config')
        self._value         = self.min
        if kwargs.get('value'):
            self._value = kwargs.get('value')

    def on_value_change(self, value):
        pass

    def set_value(self, _value):
        self._value = _value
        self.dispatch_event('on_value_change', self._value)
    def get_value(self):
        return self._value
    value = property(get_value, set_value, doc='Value of the slider')

    def draw(self):
        px, py = self.style['padding']
        px2, py2 = px / 2., py / 2.
        diff = self.max - self.min
        if self.orientation == 'vertical':
            if diff == 0:
                length = 0
            else:
                length = int((self._value - self.min) * \
                             (self.height - py) / diff)
            pos = self.x + px2, self.y + py2
            size = self.width - px, length
        else:
            if diff == 0:
                length = 0
            else:
                length = int((self._value - self.min) * \
                             (self.width - px) / diff)
            pos = self.x + px2, self.y + py2
            size = length, self.height - py

        # draw outer rectangle
        set_color(*self.style.get('bg-color'))
        drawCSSRectangle(pos=self.pos, size=self.size, style=self.style)

        # draw inner rectangle
        if self.touchstarts:
            set_color(*self.style.get('slider-color-down'))
        else:
            set_color(*self.style.get('slider-color'))
        drawCSSRectangle(pos=pos, size=size, style=self.style, prefix='slider')

        if self.value_show:
            self.draw_value()

    def draw_value(self):
        drawLabel(self.value_format % (self.value), pos=self.center,
                  **self.value_config)

    def on_touch_down(self, touch):
        if self.collide_point(touch.x, touch.y):
            self.touchstarts.append(touch.id)
            self.on_touch_move(touch)
            return True
        return super(MTSlider, self).on_touch_down(touch)

    def on_touch_move(self, touch):
        if touch.id in self.touchstarts:
            last_value = self._value
            if self.orientation == 'vertical':
                self._value = (touch.y - self.y) * (self.max - self.min) / float(self.height) + self.min
            else:
                self._value = (touch.x - self.x) * (self.max - self.min) / float(self.width) + self.min
            if self._value >= self.max:
                self._value = self.max
            if self._value <= self.min:
                self._value = self.min
            if not self._value == last_value:
                self.dispatch_event('on_value_change', self._value)
            return True
        return super(MTSlider, self).on_touch_move(touch)

    def on_touch_up(self, touch):
        if touch.id in self.touchstarts:
            self.touchstarts.remove(touch.id)
        return super(MTSlider, self).on_touch_up(touch)

class MTXYSlider(MTWidget):
    '''MTXYSlider is an implementation of a 2D slider using MTWidget.

    :Parameters:
        `min_x` : int, default is 20
            Minimum value of slider
        `max_x` : int, default is 100
            Maximum value of slider
        `min_y` : int, default is 20
            Minimum value of slider
        `max_y` : int, default is 100
            Maximum value of slider
        `radius` : int, default is 200
            Radius of the slider handle
        `value_x` : int, default is `min_x`
            Default X value of slider
        `value_y` : int, default is `min_y`
            Default Y value of slider
    :Styles:
        `slider-color` : color
            Color of the slider
        `bg-color` : color
            Background color of the slider

    :Events:
        `on_value_change` (value X, value Y)
            Fired when slider x/y value is changed
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('min_x', 20)
        kwargs.setdefault('max_x', 100)
        kwargs.setdefault('min_y', 20)
        kwargs.setdefault('max_y', 100)
        kwargs.setdefault('radius', 20)
        kwargs.setdefault('size', (200, 200))
        kwargs.setdefault('value_x', kwargs.get('min_x'))
        kwargs.setdefault('value_y', kwargs.get('min_y'))

        super(MTXYSlider, self).__init__(**kwargs)
        self.register_event_type('on_value_change')
        self.touchstarts = [] # only react to touch input that originated on this widget
        self.radius     = kwargs.get('radius')
        self.padding    = kwargs.get('radius')
        self.min_x      = kwargs.get('min_x')
        self.max_x      = kwargs.get('max_x')
        self.min_y      = kwargs.get('min_y')
        self.max_y      = kwargs.get('max_y')
        self.radius     = kwargs.get('radius')
        self._value_x   = kwargs.get('value_x')
        self._value_y   = kwargs.get('value_y')

    def on_value_change(self, value_x, value_y):
        pass

    def set_value_x(self, value):
        self._value_x = value
        self.dispatch_event('on_value_change', self._value_x, self._value_y)
    def get_value_x(self):
        return self._value_x
    value_x = property(get_value_x, set_value_x, doc='Value of the slider (x axis)')

    def set_value_y(self, value):
        self._value_y = value
        self.dispatch_event('on_value_change', self._value_x, self._value_y)
    def get_value_y(self):
        return self._value_y
    value_y = property(get_value_y, set_value_y, doc='Value of the slider (y axis)')

    def draw(self):
        # draw outer rectangle
        set_color(*self.style.get('bg-color'))
        drawCSSRectangle(pos=self.pos, size=self.size, style=self.style)

        # draw inner circle
        set_color(*self.style.get('slider-color'))
        pos_x = int((self._value_x - self.min_x) * (self.width - self.padding*2) / (self.max_x - self.min_x))  + self.x + self.padding
        pos_y = int((self._value_y - self.min_y) * (self.height - self.padding*2) / (self.max_y - self.min_y)) + self.y + self.padding
        drawCircle(pos=(pos_x, pos_y), radius=self.radius)

    def on_touch_down(self, touch):
        if self.collide_point(touch.x, touch.y):
            self.touchstarts.append(touch.id)
            return True
        return super(MTXYSlider, self).on_touch_down(touch)

    def on_touch_move(self, touch):
        if touch.id in self.touchstarts:
            last_value_x, last_value_y = self._value_x, self._value_y
            self._value_x = (touch.x - self.x) * (self.max_x - self.min_x) / float(self.width) + self.min_x
            self._value_y = (touch.y - self.y) * (self.max_y - self.min_y) / float(self.height) + self.min_y
            if self._value_x >= self.max_x:
                self._value_x = self.max_x
            if self._value_x <= self.min_x:
                self._value_x = self.min_x
            if self._value_y >= self.max_y:
                self._value_y = self.max_y
            if self._value_y <= self.min_y:
                self._value_y = self.min_y
            if not self._value_x == last_value_x or not self._value_y == last_value_y:
                self.dispatch_event('on_value_change', self._value_x, self._value_y)
            return True
        return super(MTXYSlider, self).on_touch_move(touch)

    def on_touch_up(self, touch):
        if touch.id in self.touchstarts:
            self.touchstarts.remove(touch.id)
        return super(MTXYSlider, self).on_touch_up(touch)

class MTBoundarySlider(MTWidget):
    '''MTBoundarySlider is a widget that allows you to select minimum and maximum values.

    :Parameters:
        `min` : int, default is 0
            Minimum value of slider
        `max` : int, default is 100
            Maximum value of slider
        `orientation` : str, default is vertical
            Type of orientation, can be 'horizontal' or 'vertical'
        `value_max` : int, default is `max - (max/4)`
            The default maximum value
        `value_min` : int, the default is `min + (max/4)`
            The default minumum value
        `showtext` : boolean, defaults to false
            If true, the widget will show the min/max value

    :Styles:
        `slider-color` : color
            Color of the slider
        `bg-color` : color
            Background color of the slider

    :Events:
        `on_value_change` (value_min, value_max)
            Fired when min or max is changed
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('min', 0)
        kwargs.setdefault('max', 100)
        kwargs.setdefault('orientation', 'vertical')
        kwargs.setdefault('showtext', False)
        if kwargs.get('orientation') == 'vertical':
            kwargs.setdefault('size', (30, 400))
        else:
            kwargs.setdefault('size', (400, 30))

        super(MTBoundarySlider, self).__init__(**kwargs)
        self.register_event_type('on_value_change')
        self.touchstarts    = [] # only react to touch input that originated on this widget
        self.orientation    = kwargs.get('orientation')
        if self.orientation not in ('horizontal', 'vertical'):
            raise Exception('Invalid orientation %s. Must be horizontal or vertical' % self.orientation)
        self.min            = kwargs.get('min')
        self.max            = kwargs.get('max')
        self.showtext       = kwargs.get('showtext')

        kwargs.setdefault('value_min', self.min)
        kwargs.setdefault('value_max', self.max)
        self.value_min = kwargs.get('value_min')
        self.value_max = kwargs.get('value_max')

    def set_value(self, name, value):
        if name in ('value_min', 'value_max'):
            if self.orientation == 'vertical':
                x = self.height / self.ratio
            else:
                x = self.width / self.ratio
            if value < 0:
                return self.__setattr__(name, 0)
            if value > x:
                return self.__setattr__(name, x)
        if name == 'value_min' and value > self.value_max:
            return
        if name == 'value_max' and value < self.value_min:
            return
        return self.__setattr__(name, value)

    def get_value(self):
        '''Scale the value to the minimum and maximum system set by the user'''
        if self.orientation == 'vertical':
            tmin = (self.value_min / self.height) * self.max
            tmax = (self.value_max / self.height) * self.max
        elif self.orientation == 'horizontal':
            tmin = (self.value_min / self.width) * self.max
            tmax = (self.value_max / self.width) * self.max
        return tmin, tmax

    def on_value_change(self, vmin, vmax):
        pass

    @property
    def ratio(self):
        if self.orientation == 'vertical':
            return self.height / (self.max - self.min)
        return self.width / (self.max - self.min)

    def draw(self):
        px, py = self.style['padding']
        px2, py2 = px / 2, py / 2
        if self.orientation == 'vertical':
            pos = (self.x + px2, self.y + self.value_min * self.ratio + py2)
            size = (self.width - px, (self.value_max - self.value_min) *
                    self.ratio - py)
            textposmin = (self.x + self.width, self.y + self.value_min * self.ratio)
            textposmax = (self.x + self.width, self.y + self.value_max * self.ratio)
        elif self.orientation == 'horizontal':
            pos = (self.x + self.value_min * self.ratio + px2, self.y + py2)
            size = ((self.value_max - self.value_min) * self.ratio - px,
                    self.height - py)
            textposmin = (self.x + self.value_min * self.ratio, self.y + self.height)
            textposmax = (self.x + self.value_max * self.ratio, self.y + self.height)

        # draw outer rectangle
        set_color(*self.style.get('bg-color'))
        drawCSSRectangle(pos=self.pos, size=self.size, style=self.style)

        # draw inner rectangle
        set_color(*self.style.get('slider-color'))
        drawCSSRectangle(pos=pos, size=size, style=self.style, prefix='slider')
        if self.showtext and len(self.touchstarts):
            drawLabel(u'%.1f' % (self.value_min), pos=textposmin, font_size=self.style['font-size'])
            drawLabel(u'%.1f' % (self.value_max), pos=textposmax, font_size=self.style['font-size'])

    def on_touch_down(self, touch):
        # So the first on_touch_move in a
        # two-finger-drag doesn't teleport the widget
        if self.collide_point(touch.x, touch.y):
            if touch.is_double_tap:
                # Randomize the bound
                if self.orientation == 'vertical':
                    self.value_min = random.randrange(0, self.height)
                    self.value_max = random.randrange(self.value_min, self.height)
                else:
                    self.value_min = random.randrange(0, self.width)
                    self.value_max = random.randrange(self.value_min, self.width)
            # Decide wether we will move the upper or lower bound
            if self.orientation == 'vertical':
                if touch.y < (self.value_min * self.ratio + self.y*2 +
                              self.value_max * self.ratio)/2:
                    touch.userdata['boundary.side'] = 'value_min'
                else:
                    touch.userdata['boundary.side'] = 'value_max'
            elif self.orientation == 'horizontal':
                if touch.x < (self.value_min * self.ratio + self.x*2 +
                              self.value_max * self.ratio)/2:
                    touch.userdata['boundary.side'] = 'value_min'
                else:
                    touch.userdata['boundary.side'] = 'value_max'

            self.touchstarts.append(touch.id)
            self.on_touch_move(touch)
            return True
        return super(MTBoundarySlider, self).on_touch_down(touch)

    def on_touch_move(self, touch):
        if touch.id in self.touchstarts:
            # Either move a given bound, or shift both
            if self.orientation == 'vertical':
                if len(self.touchstarts) >= 2:
                    # Two or more fingers, shift the whole bound
                    rel = (touch.y - touch.dypos)
                    self.value_min += rel
                    self.value_max += rel
                else:
                    # Only one, just change one bound
                    self.set_value(touch.userdata['boundary.side'],
                                   (touch.y - self.y) / self.ratio)
                    self.dispatch_event('on_value_change', *self.get_value())
            elif self.orientation == 'horizontal':
                if len(self.touchstarts) >= 2:
                    # Two or more fingers, shift the whole bound
                    rel = (touch.x - touch.dxpos)
                    self.value_min += rel
                    self.value_max += rel
                else:
                    # Only one, just change one bound
                    self.set_value(touch.userdata['boundary.side'],
                                   (touch.x - self.x) / self.ratio)
                    self.dispatch_event('on_value_change', *self.get_value())
            return True
        return super(MTBoundarySlider, self).on_touch_move(touch)

    def on_touch_up(self, touch):
        if touch.id in self.touchstarts:
            self.touchstarts.remove(touch.id)
        return super(MTBoundarySlider, self).on_touch_up(touch)

class MTMultiSlider(MTWidget):
    '''Multi slider widget look like an equalizer widget.

    :Parameters:
        `sliders` : int, default to 20
            Number of sliders
        `spacing` : int, default to 1
            Spacing between slider
        `init_value` : float, default to 0.5
            Start value of all sliders

    :Styles:
        `slider-color` : color
            Color of slider
        `bg-color` : color
            Background color of slider

    :Events:
        `on_value_change` (values)
            Fired when the value of one slider change

    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('sliders', 20)
        kwargs.setdefault('size', (400, 300))
        kwargs.setdefault('spacing', 1)
        kwargs.setdefault('init_value', 0.5)
        super(MTMultiSlider, self).__init__(**kwargs)

        self.register_event_type('on_value_change')
        self.touchstarts = [] # only react to touch input that originated on this widget
        self._sliders = kwargs.get('sliders')
        self._spacing = kwargs.get('spacing')
        self._init_value = kwargs.get('init_value')
        self.slider_values = [self._init_value for x in range(self._sliders)]

    def _get_sliders(self):
        return self._sliders
    def _set_sliders(self, quantity):
        if quantity < self._sliders:
            self.slider_values = self.slider_values[0:quantity]
            self._sliders = quantity
        if quantity > self._sliders:
            self.slider_values = self.slider_values + list(
                [self._init_value for x in range(quantity - self._sliders)])
            self._sliders = quantity
        else:
            return
    sliders = property(_get_sliders, _set_sliders,
                       doc='Get/set the number of sliders')

    def _get_spacing(self):
        return self._spacing
    def _set_spacing(self, spacing):
        self._spacing = spacing
    spacing = property(_get_spacing, _set_spacing)

    def draw(self):
        # Draw background
        set_color(*self.style.get('bg-color'))
        drawRectangle(pos=self.pos, size=self.size)
        # Draw sliders
        set_color(*self.style.get('slider-color'))
        for slider in range(self._sliders):
            pos_x = self.x + slider * (float(self.width) / self._sliders)
            pos_y = self.y
            size_x = (float(self.width) / self._sliders) - self._spacing
            size_y = self.height * self.slider_values[slider]
            drawRectangle(pos = (pos_x, pos_y), size = (size_x, size_y))

    def on_value_change(self, value):
        pass

    def on_touch_down(self, touch):
        if self.collide_point(touch.x, touch.y):
            self.touchstarts.append(touch.id)
            self.on_touch_move(touch)
            return True
        return super(MTMultiSlider, self).on_touch_down(touch)

    def on_touch_move(self, touch):
        if touch.id in self.touchstarts:
            if touch.x > self.x and touch.x < self.x + self.width:
                current_slider = self.return_slider(touch.x)
                last_value = self.slider_values[current_slider]
                self.slider_values[current_slider] = (touch.y - self.y) / float(self.height)
                if self.slider_values[current_slider] >= 1:
                    self.slider_values[current_slider] = 1
                if self.slider_values[current_slider] <= 0:
                    self.slider_values[current_slider] = 0

                if not self.slider_values[current_slider] == last_value:
                    self.dispatch_event('on_value_change', self.slider_values)
            return True
        return super(MTMultiSlider, self).on_touch_move(touch)

    def on_touch_up(self, touch):
        if touch.id in self.touchstarts:
            self.touchstarts.remove(touch.id)
        return super(MTMultiSlider, self).on_touch_up(touch)

    def return_slider(self, x):
        return int((x - self.x) / float(self.width)  * self._sliders)


########NEW FILE########
__FILENAME__ = speechbubble
'''
Speech Bubble: a little speech bubble !
'''

__all__ = ('MTSpeechBubble', )

from pymt.ui.widgets.label import MTLabel
from pymt.graphx import drawPolygon, drawRoundedRectangle, gx_matrix
from pymt.vector import Vector
from OpenGL.GL import GL_LINE_SMOOTH, GL_LINE_LOOP, \
    glEnable, glTranslatef, glLineWidth

class MTSpeechBubble(MTLabel):
    '''A little speed bubble !

    :Parameters:
        `multiline` : bool, default to True
            Make label multiline
        `bgcolor` : list, default to (183./255, 224./255, 1)
            Background color of bubble
        `bordercolor` : list, default to (1, 1, 1)
            Border color of bubble
        `bordersize` : int, default to 2
            Size of border
        `radius` : int, default to 8
            Size of radius box
        `padding` : int, default to 5
            Padding inside label
        `relpos` : list, default to (-30, 20)
            Relative position of the bubble
        `trisize` : int, default to 8
            Size of triangle
    	`trirelpos` : list, default to (0, 0)
            Relative position of the triangle
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('multiline', True)
        kwargs.setdefault('bgcolor', (183./255, 224./255, 1))
        kwargs.setdefault('bordercolor', (1, 1, 1))
        kwargs.setdefault('bordersize', 2)
        kwargs.setdefault('radius', 8)
        kwargs.setdefault('padding', 5)
        kwargs.setdefault('autoheight', True)
        kwargs.setdefault('relpos', (-30, 20))
        kwargs.setdefault('trisize', 8)
        kwargs.setdefault('trirelpos', (0, 0))
        super(MTSpeechBubble, self).__init__(**kwargs)
        self.bordercolor    = kwargs.get('bordercolor')
        self.bordersize     = kwargs.get('bordersize')
        self.bgcolor        = kwargs.get('bgcolor')
        self.padding        = kwargs.get('padding')
        self.radius         = kwargs.get('radius')
        self.autoheight     = kwargs.get('autoheight')
        self.relpos         = kwargs.get('relpos')
        self.trisize        = kwargs.get('trisize')
        self.trirelpos      = kwargs.get('trirelpos')

    def draw(self):

        # extract relative position
        rx, ry = self.relpos

        # calculate triangle
        mx = self.x + rx + self.width * 0.5 + self.trirelpos[0]
        my = self.y + ry + self.height * 0.5 + self.trirelpos[1]
        angle = Vector(1, 0).angle(Vector(mx - self.x, my - self.y))
        vpos = Vector(mx, my)
        v1 = Vector(self.trisize, 0).rotate(angle) + vpos
        v2 = Vector(-self.trisize, 0).rotate(angle) + vpos

        # draw border
        if self.bordersize > 0:
            drawRoundedRectangle(
                pos=(self.x - self.padding - self.bordersize + rx,
                     self.y - self.padding - self.bordersize + ry),
                size=(self.width + self.padding * 2 + self.bordersize * 2,
                      self.height + self.padding * 2 + self.bordersize * 2),
                radius=self.radius,
                color=self.bordercolor
            )

            glEnable(GL_LINE_SMOOTH)
            glLineWidth(self.bordersize * 2)
            drawPolygon((self.x, self.y, v1.x, v1.y, v2.x, v2.y), style=GL_LINE_LOOP)

        # draw background
        drawRoundedRectangle(
            pos=(self.x - self.padding + rx,
                 self.y - self.padding + ry),
            size=(self.width + self.padding * 2,
                  self.height + self.padding * 2),
            radius=self.radius,
            color=self.bgcolor
        )
        drawPolygon((self.x, self.y, v1.x, v1.y, v2.x, v2.y))

        # hack to translate label position
        with gx_matrix:
            glTranslatef(rx, ry, 0)
            super(MTSpeechBubble, self).draw()

if __name__ == '__main__':
    from pymt import runTouchApp
    bl = MTSpeechBubble(
        color=(0,0,0,1),
        label="Bubble"
    )
    bl.pos = (100, 100)
    runTouchApp(bl)

########NEW FILE########
__FILENAME__ = stencilcontainer
'''
Stencil container: clip drawing of children to his container
'''

__all__ = ('MTStencilContainer', )

from pymt.ui.widgets.widget import MTWidget
from pymt.graphx import drawRectangle, stencilPush, stencilPop, stencilUse

stencil_stack = 0

class MTStencilContainer(MTWidget):
    '''This container clip the children drawing to his
    container ::

        from pymt import *
        s = MTStencilContainer(size=(200, 200))
        s.add_widget(MTLabel(label="plop", pos=(100, 100), font_size=16))
        s.add_widget(MTLabel(label="a very very long sentence !", pos=(100, 150), font_size=16))
        w = MTWindow()
        w.add_widget(s)
        runTouchApp()
    '''
    def __init__(self, **kwargs):
        super(MTStencilContainer, self).__init__(**kwargs)

    def stencil_push(self):
        stencilPush()
        # draw on stencil
        drawRectangle(pos=self.pos, size=self.size)
        # switch drawing to color buffer.
        stencilUse()

    def stencil_pop(self):
        stencilPop()

    def on_draw(self):
        self.stencil_push()
        # draw childrens
        for w in self.children[:]:
            w.dispatch_event('on_draw')
        self.stencil_pop()

########NEW FILE########
__FILENAME__ = svg
'''
SVG widget: widget that display an svg image
'''
__all__ = ('MTSvg', 'MTSvgButton')

import os

from pymt import pymt_data_dir
from pymt.logger import pymt_logger
from pymt.ui.widgets.widget import MTWidget
from pymt.ui.widgets.button import MTButton

squirtle = None

class MTSvg(MTWidget):
    '''Render an svg image

    :Parameters:
        `filename` : str
            Filename of image
	`rawdata`  : str
	    The raw data of an SVG file. If given, the filename property will only be used for cache purposes.
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('filename', None)
        kwargs.setdefault('rawdata', None)
        if kwargs.get('filename') is None:
            raise Exception('No filename given to MTSvg')
        super(MTSvg, self).__init__(**kwargs)
        self.rawdata = kwargs.get('rawdata')
        self.filename = kwargs.get('filename')
        self.size = (self.svg.width, self.svg.height)

    def draw(self, **kwargs):
        self.svg.draw(self.x, self.y, **kwargs)

    def _get_filename(self):
        return self._filename
    def _set_filename(self, filename):
        global squirtle
        if squirtle is None:
            import squirtle
        # TODO remove this ugly code, improve loader for this
        try:
            if self.rawdata is None:
                pymt_logger.debug('SVG: loading %s' % filename)
                self.svg = squirtle.SVG(filename)
            else:
                pymt_logger.debug('SVG: loading %s from rawdata' % filename)
                self.svg = squirtle.SVG(filename=filename, rawdata=self.rawdata)
        except Exception:
            try:
                svgpath = os.path.join(pymt_data_dir, 'icons/svg')
                pymt_logger.exception('SVG: unable to load %s' % filename)
                pymt_logger.warning('SVG: trying %s' % (svgpath + filename))
                self.svg = squirtle.SVG(os.path.join(svgpath, filename))
            except Exception:
                pymt_logger.exception('SVG: unable to load file %s' % filename)
                self._filename = filename
                self.size = (self.svg.width, self.svg.height)
    filename = property(_get_filename, _set_filename)

class MTSvgButton(MTButton):
    '''Render an svg image

    :Parameters:
        `filename` : str
            Filename of image
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('filename', None)
        if kwargs.get('filename') is None:
            raise Exception('No filename given to MTSvgButton')
        super(MTSvgButton, self).__init__(**kwargs)
        self.filename = kwargs.get('filename')
        self.size = (self.svg.width, self.svg.height)

    def draw(self, **kwargs):
        self.svg.draw(self.x, self.y, **kwargs)

    def _get_filename(self):
        return self._filename
    def _set_filename(self, filename):
        global squirtle
        if squirtle is None:
            import squirtle
		# TODO remove this ugly code, improve loader for this
        try:
            pymt_logger.debug('SVGButton: loading %s' % filename)
            self.svg = squirtle.SVG(filename)
        except Exception, e:
            try:
                svgpath = os.path.join(pymt_data_dir, 'icons/svg')
                pymt_logger.exception('SVGButton: unable to load %s' % filename)
                pymt_logger.warning('SVGButton: trying %s' % (
                    svgpath + filename))
                self.svg = squirtle.SVG(os.path.join(svgpath, filename))
            except Exception, e:
                pymt_logger.exception('SVGButton: unable to load file %s' % filename)
        self._filename = filename
        self.size = (self.svg.width, self.svg.height)
    filename = property(_get_filename, _set_filename)

########NEW FILE########
__FILENAME__ = widget
'''
Widget: Base of every widget implementation.
'''

__all__ = ('getWidgetById', 'MTWidget')

import weakref
from pymt.event import EventDispatcher
from pymt.logger import pymt_logger
from pymt.utils import SafeList
from pymt.ui.factory import MTWidgetFactory
from pymt.ui.colors import css_get_style
from pymt.graphx import set_color, drawCSSRectangle

_id_2_widget = dict()

def getWidgetById(widget_id):
    '''Get a widget by ID'''
    if widget_id not in _id_2_widget:
        return
    ref = _id_2_widget[widget_id]
    obj = ref()
    if not obj:
        del _id_2_widget[widget_id]
        return
    return obj


class MTWidgetMetaclass(type):
    '''Metaclass to auto register new widget into :ref:`MTWidgetFactory`
    .. warning::
        This metaclass is used for MTWidget. Don't use it directly !
    '''
    def __init__(mcs, name, bases, attrs):
        super(MTWidgetMetaclass, mcs).__init__(name, bases, attrs)
        # auto registration in factory
        MTWidgetFactory.register(name, mcs)

class MTWidget(EventDispatcher):
    '''Global base for any multitouch widget.
    Implement event for mouse, object, touch and animation.

    Event are dispatched through widget only if it's visible.

    :Parameters:
        `pos` : list, default is (0, 0)
            Position of widget, in (x, y) format
        `x` : int, default is None
            X position of widget
        `y` : int, default is None
            Y position of widget
        `size` : list, default is (100, 100)
            Size of widget, in (width, height) format
        `width` : int, default is None
            width position of widget
        `height` : int, default is None
            height position of widget
        `visible` : bool, default is True
            Visibility of widget
        `draw_children` : bool, default is True
            Indicate if children will be draw, or not
        `style` : dict, default to {}
            Add inline CSS
        `cls` : str, default is ''
            CSS class of this widget

    :Events:
        `on_update` ()
            Used to update the widget and his children.
        `on_draw` ()
            Used to draw the widget and his children.
        `on_touch_down` (Touch touch)
            Fired when a blob appear
        `on_touch_move` (Touch touch)
            Fired when a blob is moving
        `on_touch_up` (Touch touch)
            Fired when a blob disappear
        `on_resize` (float width, float height)
            Fired when widget is resized
        `on_parent_resize` (float width, float height)
            Fired when parent widget is resized
    '''

    __metaclass__ = MTWidgetMetaclass

    __slots__ = ('children', 'style', 'draw_children',
                 '_cls',
                 '_root_window_source', '_root_window',
                 '_parent_window_source', '_parent_window',
                 '_parent_layout_source', '_parent_layout',
                 '_size_hint', '_id', '_parent',
                 '_visible', '_inline_style',
                 '__animationcache__',
                 '__weakref__')

    visible_events = [
        'on_draw',
        'on_touch_up',
        'on_touch_move',
        'on_touch_down'
    ]
    def __init__(self, **kwargs):
        kwargs.setdefault('pos', (0, 0))
        kwargs.setdefault('x', None)
        kwargs.setdefault('y', None)
        kwargs.setdefault('size', (100, 100))
        kwargs.setdefault('size_hint', (None, None))
        kwargs.setdefault('width', None)
        kwargs.setdefault('height', None)
        kwargs.setdefault('visible', True)
        kwargs.setdefault('draw_children', True)
        kwargs.setdefault('cls', '')
        kwargs.setdefault('style', {})

        self._id = None
        if 'id' in kwargs:
            self.id = kwargs.get('id')

        super(MTWidget, self).__init__(**kwargs)

        # Registers events
        for ev in MTWidget.visible_events:
            self.register_event_type(ev)

        # privates
        self.__animationcache__   = set()
        self._parent              = None
        self._visible             = None
        self._size_hint           = kwargs.get('size_hint')


        #: List of children (SafeList)
        self.children             = SafeList()
        #: If False, childrens are not drawed. (deprecated)
        self.draw_children        = kwargs.get('draw_children')
        #: Dictionnary that contains the widget style
        self.style = {}

        # apply visibility
        self.visible              = kwargs.get('visible')

        # cache for get_parent_window()
        self._parent_layout         = None
        self._parent_layout_source  = None
        self._parent_window         = None
        self._parent_window_source  = None
        self._root_window           = None
        self._root_window_source    = None

        # register events
        register_event_type = self.register_event_type
        for event in ('on_update', 'on_animation_complete', 'on_resize',
                      'on_parent_resize', 'on_move', 'on_parent'):
            register_event_type(event)

        if kwargs.get('x'):
            self._pos = (kwargs.get('x'), self.y)
        if kwargs.get('y'):
            self._pos = (self.x, kwargs.get('y'))
        if kwargs.get('width'):
            self._size = (kwargs.get('width'), self.height)
        if kwargs.get('height'):
            self._size = (self.width, kwargs.get('height'))

        # apply style
        self._cls = ''
        self._inline_style = kwargs['style']

        # loading is done here automaticly
        self.cls = kwargs.get('cls')

    def _set_cls(self, cls):
        self._cls = cls
        self.reload_css()
    def _get_cls(self):
        return self._cls
    cls = property(_get_cls, _set_cls,
        doc='Get/Set the class of the widget (used for CSS, can be a string '
            'or a list of string')

    def _set_parent(self, parent):
        self._parent = parent
        self.dispatch_event('on_parent')
    def _get_parent(self):
        return self._parent
    parent = property(_get_parent, _set_parent,
                      doc='MTWidget: parent of widget. Fired on_parent event when set')

    def _set_id(self, id):
        ref = weakref.ref(self)
        if ref in _id_2_widget:
            del _id_2_widget[self._id]
        self._id = id
        if self._id:
            if ref in _id_2_widget:
                pymt_logger.warning('Widget: ID <%s> is already used ! Replacing with new one.' % id)
            _id_2_widget[self._id] = ref
    def _get_id(self):
        return self._id
    id = property(_get_id, _set_id,
                  doc='str: id of widget')

    def _set_visible(self, visible):
        if self._visible == visible:
            return
        self._visible = visible
        # register or unregister event if the widget is visible or not
        if visible:
            for ev in MTWidget.visible_events:
                self.register_event_type(ev)
        else:
            for ev in MTWidget.visible_events:
                self.unregister_event_type(ev)
    def _get_visible(self):
        return self._visible
    visible = property(_get_visible, _set_visible, doc=''
        'True if the widget is visible. If False, the events on_draw,'
        'on_touch_down, on_touch_move, on_touch_up are not dispatched.')

    def _set_size_hint(self, size_hint):
        if self._size_hint == size_hint:
            return False
        self._size_hint = size_hint
    def _get_size_hint(self):
        return self._size_hint
    size_hint = property(_get_size_hint, _set_size_hint,
                         doc='size_hint is used by layouts to determine size behaviour during layout')

    def apply_css(self, styles):
        '''Called at __init__ time to applied css attribute in current class.
        '''
        self.style.update(styles)

    def reload_css(self):
        '''Called when css want to be reloaded from scratch'''
        self.style = {}
        style = css_get_style(widget=self)
        self.apply_css(style)
        if len(self._inline_style):
            self.apply_css(self._inline_style)

    def to_widget(self, x, y, relative=False):
        '''Return the coordinate from window to local widget'''
        if self.parent:
            x, y = self.parent.to_widget(x, y)
        return self.to_local(x, y, relative=relative)

    def to_window(self, x, y, initial=True, relative=False):
        '''Transform local coordinate to window coordinate'''
        if not initial:
            x, y = self.to_parent(x, y, relative=relative)
        if self.parent:
            return self.parent.to_window(x, y, initial=False, relative=relative)
        return (x, y)

    def to_parent(self, x, y, relative=False):
        '''Transform local coordinate to parent coordinate

        :Parameters:
            `relative`: bool, default to False
                Change to True is you want to translate relative position from
                widget to his parent.
        '''
        if relative:
            return (x + self.x, y + self.y)
        return (x, y)

    def to_local(self, x, y, relative=False):
        '''Transform parent coordinate to local coordinate

        :Parameters:
            `relative`: bool, default to False
                Change to True is you want to translate a coordinate to a
                relative coordinate from widget.
        '''
        if relative:
            return (x - self.x, y - self.y)
        return (x, y)

    def collide_point(self, x, y):
        '''Test if the (x,y) is in widget bounding box'''
        if not self.visible:
            return False
        if x > self.x  and x < self.x + self.width and \
           y > self.y and y < self.y + self.height:
            return True

    def get_root_window(self):
        '''Return the root window of widget'''
        if not self.parent:
            return None

        # cache value
        if self._root_window_source != self.parent or self._root_window is None:
            self._root_window = self.parent.get_root_window()
            if not self._root_window:
                return None
            self._root_window_source = self.parent

        return self._root_window

    def get_parent_layout(self):
        '''Return the parent layout of widget'''
        if not self.parent:
            return None

        # cache value
        if self._parent_layout_source != self.parent or self._parent_layout is None:
            self._parent_layout = self.parent.get_parent_layout()
            if not self._parent_layout:
                return None
            self._parent_layout_source = self.parent

        return self._parent_layout

    def get_parent_window(self):
        '''Return the parent window of widget'''
        if not self.parent:
            return None

        # cache value
        if self._parent_window_source != self.parent or self._parent_window is None:
            self._parent_window = self.parent.get_parent_window()
            if not self._parent_window:
                return None
            self._parent_window_source = self.parent

        return self._parent_window

    def bring_to_front(self):
        '''Remove it from wherever it is and add it back at the top'''
        if self.parent:
            parent = self.parent
            parent.remove_widget(self)
            parent.add_widget(self)

    def hide(self):
        '''Hide the widget'''
        self.visible = False

    def show(self):
        '''Show the widget'''
        self.visible = True

    def on_update(self):
        for w in self.children[:]:
            w.dispatch_event('on_update')

    def on_draw(self):
        self.draw()
        if self.draw_children:
            for w in self.children[:]:
                w.dispatch_event('on_draw')

    def draw(self):
        '''Handle the draw of widget.
        Derivate this method to draw your widget.'''
        set_color(*self.style.get('bg-color'))
        drawCSSRectangle(pos=self.pos, size=self.size, style=self.style)

    def add_widget(self, w, front=True):
        '''Add a widget in the children list.'''
        if front:
            self.children.append(w)
        else:
            self.children.insert(0, w)
        try:
            w.parent = self
        except Exception:
            pass

    def add_widgets(self, *widgets):
        for w in widgets:
            self.add_widget(w)


    def remove_widget(self, w):
        '''Remove a widget from the children list'''
        if w in self.children:
            self.children.remove(w)

    def on_animation_complete(self, *largs):
        pass

    def on_parent(self):
        pass

    def on_parent_resize(self, w, h):
        pass

    def on_resize(self, w, h):
        for c in self.children[:]:
            c.dispatch_event('on_parent_resize', w, h)

    def on_move(self, x, y):
        for c in self.children[:]:
            c.dispatch_event('on_move', x, y)

    def on_touch_down(self, touch):
        for w in reversed(self.children[:]):
            if w.dispatch_event('on_touch_down', touch):
                return True

    def on_touch_move(self, touch):
        for w in reversed(self.children[:]):
            if w.dispatch_event('on_touch_move', touch):
                return True

    def on_touch_up(self, touch):
        for w in reversed(self.children[:]):
            if w.dispatch_event('on_touch_up', touch):
                return True

    def do(self, animation):
        '''Apply/Start animations on the widgets.

        :Parameters:
            `animation` : Animation Object
                Animation object with properties to be animateds ","
        '''
        if not animation.set_widget(self):
            return
        # XXX bug from Animation framework
        # we need to store a reference of our animation class
        # otherwise, if the animation is called with self.do(),
        # gc can suppress reference, and it's gone !
        animobj = animation.start(self)
        self.__animationcache__.add(animobj)
        def animobject_on_complete(widget, *l):
            if widget != self:
                return
            if animobj in self.__animationcache__:
                self.__animationcache__.remove(animobj)
        animation.connect('on_complete', animobject_on_complete)
        return animobj

    # generate event for all baseobject methods

    def _set_pos(self, x):
        if super(MTWidget, self)._set_pos(x):
            self.dispatch_event('on_move', *self._pos)
            return True
    pos = property(EventDispatcher._get_pos, _set_pos)

    def _set_x(self, x):
        if super(MTWidget, self)._set_x(x):
            self.dispatch_event('on_move', *self._pos)
            return True
    x = property(EventDispatcher._get_x, _set_x)

    def _set_y(self, x):
        if super(MTWidget, self)._set_y(x):
            self.dispatch_event('on_move', *self._pos)
            return True
    y = property(EventDispatcher._get_y, _set_y)

    def _set_size(self, x):
        if super(MTWidget, self)._set_size(x):
            self.dispatch_event('on_resize', *self._size)
            return True
    size = property(EventDispatcher._get_size, _set_size)

    def _set_width(self, x):
        if super(MTWidget, self)._set_width(x):
            self.dispatch_event('on_resize', *self._size)
            return True
    width = property(EventDispatcher._get_width, _set_width)

    def _set_height(self, x):
        if super(MTWidget, self)._set_height(x):
            self.dispatch_event('on_resize', *self._size)
            return True
    height = property(EventDispatcher._get_height, _set_height)

# install acceleration
try:
    import types
    from pymt.accelerate import accelerate
    if accelerate is not None:
        MTWidget.on_update = types.MethodType(accelerate.widget_on_update, None, MTWidget)
        MTWidget.on_draw = types.MethodType(accelerate.widget_on_draw, None, MTWidget)
        MTWidget.collide_point = types.MethodType(accelerate.widget_collide_point, None, MTWidget)
except ImportError, e:
    pymt_logger.warning('Widget: Unable to use accelerate module <%s>' % e)

########NEW FILE########
__FILENAME__ = xmlwidget
'''
XML widget: parse xml and create his children
'''

__all__ = ('XMLWidget', )

from pymt.logger import pymt_logger
from pymt.ui.factory import MTWidgetFactory
from pymt.ui.widgets.widget import MTWidget

class XMLWidget(MTWidget):
    '''XML widget create all his children by parsing and execute xml ::

        from pymt import *
        data = """<?xml version="1.0"?>
        <MTKinetic>
            <MTButton label="1" pos="(50,50)"/>
            <MTButton label="2" pos="(250,50)"/>
            <MTButton label="3" pos="(50,250)"/>
        </MTKinetic>
        """
        w = XMLWidget(xml=data)

    .. warning::
        the value is passed to eval function. Don't provide xml from
        untrusted source !


    :Parameters:
        `xml` : string, default is None
            XML string that contain all the data
    '''
    def __init__(self, **kwargs):
        kwargs.setdefault('xml', None)
        super(XMLWidget, self).__init__(**kwargs)
        xml = kwargs.get('xml')
        self.registerdb = {}
        if xml is not None:
            self.loadString(xml)

    @property
    def root(self):
        '''Return the root widget of the xml'''
        if len(self.children):
            return self.children[0]
        return None

    def getById(self, widget_id):
        if widget_id in self.registerdb:
            return self.registerdb[widget_id]
        return None

    def autoconnect(self, obj):
        '''Autoconnect event handler from widget in xml to obj.
        For example, if you have a <MTButton id='plop'> in xml,
        and you want to connect on on_press event, it will search
        the obj.on_plop_press() function.
        '''
        for widget_id, children in self.registerdb.items():
            for event in children.event_types:
                eventobj = event
                if eventobj[:3] == 'on_':
                    eventobj = eventobj[3:]
                eventobj = 'on_%s_%s' % (widget_id, eventobj)
                if hasattr(obj, eventobj):
                    children.connect(event, getattr(obj, eventobj))


    def createNode(self, node):
        from xml.dom import Node
        factory = MTWidgetFactory.get
        if node.nodeType == Node.ELEMENT_NODE:
            class_name = node.nodeName

            # parameters
            k = {}
            widget_id = None
            for name, value in node.attributes.items():
                name = str(name)
                if name == 'id':
                    widget_id = eval(value)
                else:
                    if name == 'xid':
                        name = 'id'
                    k[name] = eval(value)

            # create widget
            try:
                nodeWidget = factory(class_name)(**k)
                if widget_id is not None:
                    self.registerdb[widget_id] = nodeWidget
            except:
                pymt_logger.exception('XMLWidget: unable to create widget %s' \
                                      % class_name)
                raise

            # add child widgets
            for c in node.childNodes:
                w = self.createNode(c)
                if w:
                    nodeWidget.add_widget(w)

            return nodeWidget

    def loadString(self, xml):
        from xml.dom import minidom
        doc = minidom.parseString(xml)
        root = doc.documentElement
        self.add_widget(self.createNode(root))


########NEW FILE########
__FILENAME__ = win_glut
'''
Window GLUT: windowing provider based on GLUT
'''

__all__ = ('MTWindowGlut', )

import sys
import os
from pymt.ui.window import BaseWindow
from pymt.logger import pymt_logger
from pymt.base import stopTouchApp, getEventLoop
from OpenGL.GLUT import GLUT_RGBA, GLUT_DOUBLE, GLUT_ALPHA, GLUT_DEPTH, \
        GLUT_MULTISAMPLE, GLUT_STENCIL, GLUT_ACCUM, GLUT_RIGHT_BUTTON, \
        GLUT_DOWN, GLUT_ACTIVE_CTRL, GLUT_ACTIVE_ALT, GLUT_ACTIVE_SHIFT, \
        glutInitDisplayMode, glutInit, glutCreateWindow, glutReshapeWindow, \
        glutMouseFunc, glutMouseFunc, glutKeyboardFunc, glutShowWindow, \
        glutFullScreen, glutDestroyWindow, glutReshapeFunc, glutDisplayFunc, \
        glutMotionFunc, glutGetModifiers, glutSwapBuffers, glutPostRedisplay, \
        glutMainLoop

class MTWindowGlut(BaseWindow):

    __glut_window = None

    def create_window(self, params):
        if self.__glut_window is None:
            # init GLUT !
            pymt_logger.debug('WinGlut: GLUT initialization')
            glutInit('')
            if 'PYMT_GLUT_UNITTEST' in os.environ:
                glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE)
            else:
                glutInitDisplayMode(
                    GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA | GLUT_DEPTH |
                    GLUT_MULTISAMPLE | GLUT_STENCIL | GLUT_ACCUM)

            # create the window
            self.__glut_window = glutCreateWindow('pymt')

        # register all callbcaks
        glutReshapeFunc(self._glut_reshape)
        glutMouseFunc(self._glut_mouse)
        glutMotionFunc(self._glut_mouse_motion)
        glutKeyboardFunc(self._glut_keyboard)

        # update window size
        glutShowWindow()
        self.size = params['width'], params['height']
        if params['fullscreen']:
            pymt_logger.debug('WinGlut: Set window to fullscreen mode')
            glutFullScreen()

        super(MTWindowGlut, self).create_window(params)

    def close(self):
        if self.__glut_window:
            glutDestroyWindow(self.__glut_window)
            self.__glut_window = None
        super(MTWindowGlut, self).close()

    def on_keyboard(self, key, scancode=None, unicode=None):
        self._glut_update_modifiers()
        if ord(key) == 27:
            stopTouchApp()
            return True
        super(MTWindowGlut, self).on_keyboard(key, scancode, unicode)

    def _set_size(self, size):
        if super(MTWindowGlut, self)._set_size(size):
            glutReshapeWindow(*size)
            return True
    size = property(BaseWindow._get_size, _set_size)

    def flip(self):
        glutSwapBuffers()
        super(MTWindowGlut, self).flip()

    def mainloop(self):
        '''Main loop is done by GLUT itself.'''

        # callback for ticking
        def _glut_redisplay():
            evloop = getEventLoop()

            # hack, glut seem can't handle the leaving on the mainloop
            # so... leave with sys.exit() :[
            try:
                evloop.idle()
            except KeyboardInterrupt:
                evloop.quit = True
            if evloop.quit:
                sys.exit(0)

            glutPostRedisplay()

        # install handler
        glutDisplayFunc(_glut_redisplay)

        # run main loop
        glutMainLoop()


    #
    # GLUT callbacks
    #

    def _glut_reshape(self, w, h):
        self.size = w, h

    def _glut_mouse(self, button, state, x, y):
        self._glut_update_modifiers()

        btn = 'left'
        if button == GLUT_RIGHT_BUTTON:
            btn = 'right'

        if state == GLUT_DOWN:
            self.dispatch_event('on_mouse_down', x, y, btn, self.modifiers)
        else:
            self.dispatch_event('on_mouse_up', x, y, btn, self.modifiers)

    def _glut_mouse_motion(self, x, y):
        self.dispatch_event('on_mouse_move', x, y, self.modifiers)

    def _glut_keyboard(self, key, x, y):
        self.dispatch_event('on_keyboard', key, None, None)

    def _glut_update_modifiers(self):
        self._modifiers = []
        mods = glutGetModifiers()
        if mods & GLUT_ACTIVE_SHIFT:
            self._modifiers.append('shift')
        if mods & GLUT_ACTIVE_ALT:
            self._modifiers.append('alt')
        if mods & GLUT_ACTIVE_CTRL:
            self._modifiers.append('ctrl')


########NEW FILE########
__FILENAME__ = win_pygame
'''
Window Pygame: windowing provider based on Pygame
'''

__all__ = ('MTWindowPygame', )

import os
import pymt
from time import sleep, time
from pymt.clock import getClock
from pymt.ui.window import BaseWindow
from pymt.exceptions import pymt_exception_manager, ExceptionManager
from pymt.logger import pymt_logger
from pymt.base import stopTouchApp, getEventLoop
from OpenGL.GL import glEnable
from OpenGL.GL.ARB.multisample import GL_MULTISAMPLE_ARB

try:
    import pygame
except:
    pymt_logger.warning('WinPygame: Pygame is not installed !')
    raise

class MTWindowPygame(BaseWindow):
    def create_window(self, params):
        # force display to show (available only for fullscreen)
        displayidx = pymt.pymt_config.getint('graphics', 'display')
        if not 'SDL_VIDEO_FULLSCREEN_HEAD' in os.environ and displayidx != -1:
            os.environ['SDL_VIDEO_FULLSCREEN_HEAD'] = '%d' % displayidx

        # init some opengl, same as before.
        self.flags = pygame.HWSURFACE | pygame.OPENGL | pygame.DOUBLEBUF

        pygame.display.init()

        multisamples = pymt.pymt_config.getint('graphics', 'multisamples')

        if multisamples > 0:
            pygame.display.gl_set_attribute(pygame.GL_MULTISAMPLEBUFFERS, 1)
            pygame.display.gl_set_attribute(pygame.GL_MULTISAMPLESAMPLES, multisamples)
        pygame.display.gl_set_attribute(pygame.GL_DEPTH_SIZE, 16)
        pygame.display.gl_set_attribute(pygame.GL_STENCIL_SIZE, 1)
        pygame.display.gl_set_attribute(pygame.GL_ALPHA_SIZE, 8)
        pygame.display.set_caption('pymt')

        if params['position'] == 'auto':
            self._pos = None
        elif params['position'] == 'custom':
            self._pos = params['left'], params['top']
        else:
            raise ValueError('position token in configuration accept only '
                             '"auto" or "custom"')

        self._fullscreenmode = params['fullscreen']
        if self._fullscreenmode == 'fake':
            pymt_logger.debug('WinPygame: Set window to fake fullscreen mode')
            self.flags |= pygame.NOFRAME
            # if no position set, in fake mode, we always need to set the
            # position. so replace 0, 0.
            if self._pos is None:
                self._pos = (0, 0)
            os.environ['SDL_VIDEO_WINDOW_POS'] = '%d,%d' % self._pos

        elif self._fullscreenmode:
            pymt_logger.debug('WinPygame: Set window to fullscreen mode')
            self.flags |= pygame.FULLSCREEN

        elif self._pos is not None:
            os.environ['SDL_VIDEO_WINDOW_POS'] = '%d,%d' % self._pos

        # never stay with a None pos, application using w.center will be fired.
        self._pos = (0, 0)

        # prepare keyboard
        repeat_delay = int(pymt.pymt_config.get('keyboard', 'repeat_delay'))
        repeat_rate = float(pymt.pymt_config.get('keyboard', 'repeat_rate'))
        pygame.key.set_repeat(repeat_delay, int(1000. / repeat_rate))

        # set window icon before calling set_mode
        icon = pygame.image.load(pymt.pymt_config.get('graphics', 'window_icon'))
        pygame.display.set_icon(icon)

        # init ourself size + setmode
        # before calling on_resize
        self._size = params['width'], params['height']
        self._vsync = params['vsync']
        self._fps = float(params['fps'])

        # ensure the default fps will be 60 if vsync is actived
        # and if user didn't set any maximum fps.
        if self._vsync and self._fps <= 0:
            self._fps = 60.

        # try to use mode with multisamples
        try:
            self._pygame_set_mode()
        except pygame.error:
            if multisamples:
                pymt_logger.warning('WinPygame: Video: failed (multisamples=%d)' %
                                    multisamples)
                pymt_logger.warning('Video: trying without antialiasing')
                pygame.display.gl_set_attribute(pygame.GL_MULTISAMPLEBUFFERS, 0)
                pygame.display.gl_set_attribute(pygame.GL_MULTISAMPLESAMPLES, 0)
                multisamples = 0
                self._pygame_set_mode()
            else:
                pymt_logger.warning('WinPygame: Video setup failed :-(')
                raise

        if multisamples:
            try:
                glEnable(GL_MULTISAMPLE_ARB)
            except Exception:
                pass

        super(MTWindowPygame, self).create_window(params)

        # set mouse visibility
        pygame.mouse.set_visible(
            pymt.pymt_config.getboolean('graphics', 'show_cursor'))

        # set rotation
        self.rotation = params['rotation']

    def close(self):
        pygame.display.quit()

    def on_keyboard(self, key, scancode=None, unicode=None):
        if key == 27:
            stopTouchApp()
            self.close()  #not sure what to do here
            return True
        super(MTWindowPygame, self).on_keyboard(key, scancode, unicode)

    def flip(self):
        pygame.display.flip()
        super(MTWindowPygame, self).flip()

        # do software vsync if asked
        # FIXME: vsync is surely not 60 for everyone
        # this is not a real vsync. this must be done by driver...
        # but pygame can't do vsync on X11, and some people
        # use hack to make it work under darwin...
        fps = self._fps
        if fps > 0:
            s = 1 / fps - (time() - getClock().get_time())
            if s > 0:
                sleep(s)

    def toggle_fullscreen(self):
        if self.flags & pygame.FULLSCREEN:
            self.flags &= ~pygame.FULLSCREEN
        else:
            self.flags |= pygame.FULLSCREEN
        self._pygame_set_mode()

    def _mainloop(self):
        evloop = getEventLoop()
        evloop.idle()

        for event in pygame.event.get():

            # kill application (SIG_TERM)
            if event.type == pygame.QUIT:
                evloop.quit = True
                self.close()

            # mouse move
            elif event.type == pygame.MOUSEMOTION:
                # don't dispatch motion if no button are pressed
                if event.buttons == (0, 0, 0):
                    continue
                x, y = event.pos
                self.dispatch_event('on_mouse_move', x, y, self.modifiers)

            # mouse action
            elif event.type in (pygame.MOUSEBUTTONDOWN,
                                pygame.MOUSEBUTTONUP):
                self._pygame_update_modifiers()
                x, y = event.pos
                btn = 'left'
                if event.button == 3:
                    btn = 'right'
                elif event.button == 2:
                    btn = 'middle'
                eventname = 'on_mouse_down'
                if event.type == pygame.MOUSEBUTTONUP:
                    eventname = 'on_mouse_up'
                self.dispatch_event(eventname, x, y, btn, self.modifiers)

            # keyboard action
            elif event.type in (pygame.KEYDOWN, pygame.KEYUP):
                self._pygame_update_modifiers(event.mod)
                # atm, don't handle keyup
                if event.type == pygame.KEYUP:
                    self.dispatch_event('on_key_up', event.key,
                        event.scancode)
                    continue

                # don't dispatch more key if down event is accepted
                if self.dispatch_event('on_key_down', event.key,
                                       event.scancode, event.unicode):
                    continue
                self.dispatch_event('on_keyboard', event.key,
                                    event.scancode, event.unicode)

            # video resize
            elif event.type == pygame.VIDEORESIZE:
                pass

            # ignored event
            elif event.type in (pygame.ACTIVEEVENT, pygame.VIDEOEXPOSE):
                pass

            # unhandled event !
            else:
                pymt_logger.debug('WinPygame: Unhandled event %s' % str(event))

    def mainloop(self):
        # don't known why, but pygame required a resize event
        # for opengl, before mainloop... window reinit ?
        self.dispatch_event('on_resize', *self.size)

        evloop = getEventLoop()
        while not evloop.quit:
            try:
                self._mainloop()
                if not pygame.display.get_active():
                    pygame.time.wait(100)
            except BaseException, inst:
                # use exception manager first
                r = pymt_exception_manager.handle_exception(inst)
                if r == ExceptionManager.RAISE:
                    stopTouchApp()
                    raise
                else:
                    pass

        # force deletion of window
        pygame.display.quit()


    def _set_size(self, size):
        if super(MTWindowPygame, self)._set_size(size):
            self._pygame_set_mode()
            return True
    size = property(BaseWindow._get_size, _set_size)


    #
    # Pygame wrapper
    #
    def _pygame_set_mode(self, size=None):
        if size is None:
            size = self.size
        if self._fullscreenmode == 'auto':
            pygame.display.set_mode((0, 0), self.flags)
            info = pygame.display.Info()
            self._size = (info.current_w, info.current_h)
        else:
            pygame.display.set_mode(size, self.flags)

    def _pygame_update_modifiers(self, mods=None):
        # Available mod, from dir(pygame)
        # 'KMOD_ALT', 'KMOD_CAPS', 'KMOD_CTRL', 'KMOD_LALT',
        # 'KMOD_LCTRL', 'KMOD_LMETA', 'KMOD_LSHIFT', 'KMOD_META',
        # 'KMOD_MODE', 'KMOD_NONE'
        if mods is None:
            mods = pygame.key.get_mods()
        self._modifiers = []
        if mods & (pygame.KMOD_SHIFT | pygame.KMOD_LSHIFT):
            self._modifiers.append('shift')
        if mods & (pygame.KMOD_ALT | pygame.KMOD_LALT):
            self._modifiers.append('alt')
        if mods & (pygame.KMOD_CTRL | pygame.KMOD_LCTRL):
            self._modifiers.append('ctrl')

########NEW FILE########
__FILENAME__ = utils
'''
Utils: generic toolbox
'''

__all__ = ('intersection', 'difference', 'curry', 'strtotuple',
           'get_color_from_hex', 'get_color_for_pyglet', 'get_random_color',
           'is_color_transparent', 'boundary', 'connect',
           'deprecated', 'SafeList',
           'serialize_numpy', 'deserialize_numpy',
           'interpolate')

import inspect
import re
import functools
from pymt.logger import pymt_logger

def boundary(value, minvalue, maxvalue):
    '''Limit a value between a minvalue and maxvalue'''
    return min(max(value, minvalue), maxvalue)

def intersection(set1, set2):
    '''Return intersection between 2 list'''
    return filter(lambda s:s in set2, set1)

def difference(set1, set2):
    '''Return difference between 2 list'''
    return filter(lambda s:s not in set2, set1)

def curry(fn, *cargs, **ckwargs):
    '''Change the function signature to pass new variable.'''
    def call_fn(*fargs, **fkwargs):
        d = ckwargs.copy()
        d.update(fkwargs)
        return fn(*(cargs + fargs), **d)
    return call_fn

def interpolate(value_from, value_to, step=10):
    '''Interpolate a value to another. Can be useful to smooth some transition.
    For example ::

        # instead of setting directly 
        self.pos = pos

        # use interpolate, and you'll have a nice transition
        self.pos = interpolate(self.pos, new_pos)

    .. warning::
        This interpolation work only on list/tuple/double with the same
        dimension. No test are done if the dimension is not the same.
    '''
    if type(value_from) in (list, tuple):
        out = []
        for x, y in zip(value_from, value_to):
            out.append(interpolate(x, y, step))
        return out
    else:
        return value_from + (value_to - value_from) / float(step)

def strtotuple(s):
    '''Convert a tuple string into tuple,
    with some security check. Designed to be used
    with eval() function ::

        a = (12, 54, 68)
        b = str(a)         # return '(12, 54, 68)'
        c = strtotuple(b)  # return (12, 54, 68)

    '''
    # security
    if not re.match('^[,.0-9 ()\[\]]*$', s):
        raise Exception('Invalid characters in string for tuple conversion')
    # fast syntax check
    if s.count('(') != s.count(')'):
        raise Exception('Invalid count of ( and )')
    if s.count('[') != s.count(']'):
        raise Exception('Invalid count of [ and ]')
    r = eval(s)
    if type(r) not in (list, tuple):
        raise Exception('Conversion failed')
    return r

def get_color_from_hex(s):
    '''Transform from hex string color to pymt color'''
    if s.startswith('#'):
        return get_color_from_hex(s[1:])

    value = [int(x, 16)/255. for x in re.split('([0-9a-f]{2})', s) if x != '']
    if len(value) == 3:
        value.append(1)
    return value

def get_random_color(alpha=1.0):
    ''' Returns a random color (4 tuple)

    :Parameters:
        `alpha` : float, default to 1.0
            if alpha == 'random' a random alpha value is generated
    '''
    from random import random
    if alpha == 'random':
        return [random(), random(), random(), random()]
    else:
        return [random(), random(), random(), alpha]


def get_color_for_pyglet(c):
    '''Transform from pymt color to pyglet color'''
    return map(lambda x: int(255 * x), c)

def is_color_transparent(c):
    '''Return true if alpha channel is 0'''
    if len(c) < 4:
        return False
    if float(c[3]) == 0.:
        return True
    return False

def connect(w1, p1, w2, p2, func=lambda x: x):
    '''Connect events to a widget property'''
    w1.connect(p1, w2, p2, func)

DEPRECATED_CALLERS = []
def deprecated(func):
    '''This is a decorator which can be used to mark functions
    as deprecated. It will result in a warning being emitted the first time
    the function is used.'''

    @functools.wraps(func)
    def new_func(*args, **kwargs):
        file, line, caller = inspect.stack()[1][1:4]
        caller_id = "%s:%s:%s" % (file, line, caller)
        # We want to print deprecated warnings only once:
        if caller_id not in DEPRECATED_CALLERS:
            DEPRECATED_CALLERS.append(caller_id)
            warning = (
                'Call to deprecated function %s in %s line %d.'
                'Called from %s line %d'
                ' by %s().') % (
                func.__name__,
                func.func_code.co_filename,
                func.func_code.co_firstlineno + 1,
                file, line, caller)
            pymt_logger.warn(warning)
            if func.__doc__:
                pymt_logger.warn(func.__doc__)
        return func(*args, **kwargs)
    return new_func


class SafeList(list):
    '''List with clear() method

    .. warning::
        Usage of iterate() function will decrease your performance.
    '''
    def clear(self):
        del self[:]

    @deprecated
    def iterate(self, reverse=False):
        if reverse:
            return reversed(iter(self))
        return iter(self)


def serialize_numpy(obj):
    import numpy
    from StringIO import StringIO
    from base64 import b64encode
    io = StringIO()
    numpy.save(io, obj)
    io.seek(0)
    return b64encode(io.read())

def deserialize_numpy(s):
    import numpy
    from StringIO import StringIO
    from base64 import b64decode
    io = StringIO(b64decode(s))
    return numpy.load(io)


########NEW FILE########
__FILENAME__ = vector
'''Vector: class to handle Vector operation.
For example, if you want to get length of a vector ::

    from pymt import *
    v = Vector(1, 5)

    # get length
    print Vector.length(v)

'''

__all__ = ('Vector', )

import math

class Vector(list):
    '''Represents a 2D vector.'''

    def __init__(self, *largs):
        if len(largs) == 1:
            super(Vector, self).__init__(largs[0])
        elif len(largs) == 2:
            super(Vector, self).__init__(largs)
        else:
            raise Exception('Invalid vector')

    def _get_x(self):
        return self[0]
    def _set_x(self, x):
        self[0] = x
    x = property(_get_x, _set_x)

    def _get_y(self):
        return self[1]
    def _set_y(self, y):
        self[1] = y
    y = property(_get_y, _set_y)

    def __getslice__(self, i, j):
        try:
            # use the list __getslice__ method and convert
            # result to vector
            return Vector(super(Vector, self).__getslice__(i, j))
        except Exception:
            raise TypeError, 'vector::FAILURE in __getslice__'

    def __add__(self, val):
        return Vector(map(lambda x, y: x + y, self, val))

    def __iadd__(self, val):
        if type(val) in (int, float):
            self.x += val
            self.y += val
        else:
            self.x += val.x
            self.y += val.y
        return self

    def __neg__(self):
        return Vector(map(lambda x: -x, self))

    def __sub__(self, val):
        return Vector(map(lambda x, y: x - y, self, val))

    def __isub__(self, val):
        if type(val) in (int, float):
            self.x -= val
            self.y -= val
        else:
            self.x -= val.x
            self.y -= val.y
        return self

    def __mul__(self, val):
        try:
            return Vector(map(lambda x, y: x * y, self, val))
        except Exception:
            return Vector(map(lambda x: x * val, self))

    def __imul__(self, val):
        if type(val) in (int, float):
            self.x *= val
            self.y *= val
        else:
            self.x *= val.x
            self.y *= val.y
        return self

    def __rmul__(self, val):
        return (self * val)

    def __truediv__(self, val):
        try:
            return Vector(map(lambda x, y: x / y, self, val))
        except Exception:
            return Vector(map(lambda x: x / val, self))

    def __div__(self, val):
        try:
            return Vector(map(lambda x, y: x / y, self, val))
        except Exception:
            return Vector(map(lambda x: x / val, self))

    def __rdiv__(self, val):
        try:
            return Vector(map(lambda x, y: x / y, other, val))
        except Exception:
            return Vector(map(lambda x: other / x, val))

    def __idiv__(self, val):
        if type(val) in (int, float):
            self.x /= val
            self.y /= val
        else:
            self.x /= val.x
            self.y /= val.y
        return self


    def length(self):
        '''Returns the length of a vector'''
        return math.sqrt(self[0] ** 2 + self[1] ** 2)

    def length2(self):
        '''Returns the length of a vector squared.'''
        return self[0] ** 2 + self[1] ** 2

    def distance(self, to):
        '''Returns the distance between two points.'''
        return math.sqrt((self[0] - to[0]) ** 2 + (self[1] - to[1]) ** 2)

    def distance2(self, to):
        '''Returns the distance between two points squared.'''
        return (self[0] - to[0]) ** 2 + (self[1] - to[1]) ** 2

    def normalize(self):
        '''Returns a new vector that has the same direction as vec,
        but has a length of one.'''
        if self[0] == 0. and self[1] == 0.:
            return Vector(0., 0.)
        return self / self.length()

    def dot(self, a):
        '''Computes the dot product of a and b'''
        return self[0] * a[0] + self[1] * a[1]

    def angle(self, a):
        '''Computes the angle between a and b'''
        angle = -(180/math.pi) * math.atan2(
            self[0] * a[1] - self[1] * a[0],
            self[0] * a[0] + self[1] * a[1]
        )
        return angle

    def rotate(self, angle):
        '''Rotate the vector'''
        angle = math.radians(angle)
        return Vector((self[0] * math.cos(angle)) - (self[1] * math.sin(angle)),
                      (self[1] * math.cos(angle)) + (self[0] * math.sin(angle)))

    @staticmethod
    def line_intersection(v1, v2, v3, v4):
        '''
        Finds the intersection point between the lines (1)v1->v2 and (2)v3->v4
        and returns it as a vector object

        For math see: http://en.wikipedia.org/wiki/Line-line_intersection
        '''
        #linear algebar sucks...seriously!!
        x1, x2, x3, x4 = float(v1[0]), float(v2[0]), float(v3[0]), float(v4[0])
        y1, y2, y3, y4 = float(v1[1]), float(v2[1]), float(v3[1]), float(v4[1])

        u = (x1 * y2 - y1 * x2)
        v = (x3 * y4 - y3 * x4)
        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
        if denom == 0:
            return None

        px = ( u * (x3 - x4)  -  (x1 - x2) * v ) / denom
        py = ( u * (y3 - y4)  -  (y1 - y2) * v ) / denom

        return Vector(px, py)

    @staticmethod
    def in_bbox(point, a, b):
        '''Return a true if `point` is in bbox defined by `a` and `b`'''
        return ((point[0] <= a[0] and point[0] >= b[0] or
                 point[0] <= b[0] and point[0] >= a[0]) and
                (point[1] <= a[1] and point[1] >= b[1] or
                 point[1] <= b[1] and point[1] >= a[1]))


########NEW FILE########
__FILENAME__ = weakmethod
'''
WeakMethod: implementation of weakref for function and bounded method.

This class is used in Clock class, to prevent the clock of taking memory if the
object is deleted. Check examples/core/clock_method.py for more informations.

This WeakMethod class is taken from the recipe
http://code.activestate.com/recipes/81253/,
based on the nicodemus version. (thanks to him !)
'''

import weakref
import new

class WeakMethod(object):
    def __init__(self, method):
        try:
            if method.im_self is not None:
                # bound method
                self._obj = weakref.ref(method.im_self)
            else:
                # unbound method
                self._obj = None
            self._func = method.im_func
            self._class = method.im_class
        except AttributeError:
            # not a method
            self._obj = None
            self._func = method
            self._class = None

    def __call__(self):
        '''Return a new bound-method like the original, or the
        original function if refers just to a function or unbound
        method.
        Returns None if the original object doesn't exist
        '''
        if self.is_dead():
            return None
        if self._obj is not None:
            # we have an instance: return a bound method
            return new.instancemethod(self._func, self._obj(), self._class)
        else:
            # we don't have an instance: return just the function
            return self._func


    def is_dead(self):
        '''Returns True if the referenced callable was a bound method and
        the instance no longer exists. Otherwise, return False.
        '''
        return self._obj is not None and self._obj() is None


    def __eq__(self, other):
        try:
            return type(self) is type(other) and self() == other()
        except:
            return False

    def __ne__(self, other):
        return not self == other


########NEW FILE########
__FILENAME__ = bench_event
'''
Bench event

This bench was used to found bottleneck in our Scene Graph, and accelerate our
event dispatching method.

With Python 2.6.5 (r265:79063, Apr 16 2010, 13:57:41) [GCC 4.4.3] on linux2

The test case is constructed like this :
  - A tree with 10 children having each 100 children (1001 widgets in total)
  - dispatch 1000x a event through the root widget, walking on the tree

Event 'on_update' -> just dispatch on_update
Event 'on_touch_*' -> dispatch down/move/up event

Current master :
    MTWidget: on_update : Time=4.265, FPS=234.483
    MTWidget: on_touch_*: Time=11.815, FPS=84.635
    MTLabel: on_update : Time=12.925, FPS=77.367
    MTLabel: on_touch_*: Time=29.559, FPS=33.830
    MTScatterWidget: on_update : Time=4.286, FPS=233.303
    MTScatterWidget: on_touch_*: Time=20.192, FPS=49.525

Core optimization :
    MTWidget: on_update : Time=1.067, FPS=937.621
    MTWidget: on_touch_*: Time=5.531, FPS=180.815
    MTLabel: on_update : Time=1.110, FPS=900.846
    MTLabel: on_touch_*: Time=5.817, FPS=171.899
    MTScatterWidget: on_update : Time=1.143, FPS=874.883
    MTScatterWidget: on_touch_*: Time=17.059, FPS=58.621

Core optimization + accelerate module :
    MTWidget: on_update : Time=0.614, FPS=1629.753
    MTWidget: on_touch_*: Time=5.048, FPS=198.104
    MTLabel: on_update : Time=0.676, FPS=1479.345
    MTLabel: on_touch_*: Time=5.198, FPS=192.376
    MTScatterWidget: on_update : Time=0.691, FPS=1447.955
    MTScatterWidget: on_touch_*: Time=16.999, FPS=58.828

'''


import timeit

stmt_setup = '''
import pymt

# fake touch class
class TestTouch(pymt.Touch):
    pass

# fake touch instance
touch = TestTouch(0, 'unknown', (150, 150))

# override widget
TestWidget = pymt.%s
root = TestWidget()
for x in xrange(10):
    m = TestWidget()
    for x in xrange(100):
        m.add_widget(TestWidget())
    root.add_widget(m)
'''

stmt_on_update = '''
root.dispatch_event('on_update')
'''

stmt_on_touch_all = '''
root.dispatch_event('on_touch_down', touch)
root.dispatch_event('on_touch_move', touch)
root.dispatch_event('on_touch_up', touch)
'''

frames = 1000

for x in ('MTWidget', 'MTLabel', 'MTScatterWidget',):
    t = timeit.Timer(stmt_on_update, stmt_setup % x).timeit(number=frames)
    print '%s: on_update : Time=%.3f, FPS=%.3f' % (x, t, frames / t)
    t = timeit.Timer(stmt_on_touch_all, stmt_setup % x).timeit(number=frames)
    print '%s: on_touch_*: Time=%.3f, FPS=%.3f' % (x, t, frames / t)

########NEW FILE########
__FILENAME__ = init
__all__ = ('test', 'test_runpymt', 'test_image')

def import_pymt_no_window():
    import os
    os.environ['PYMT_SHADOW_WINDOW'] = '0'
    import pymt

def import_pymt_window():
    import os
    os.environ['PYMT_WINDOW'] = 'glut'
    os.environ['PYMT_GLUT_UNITTEST'] = '1'
    import pymt

def test_image():
    pass

def test_runpymt(*largs, **kwargs):
    from pymt import runTouchApp, curry, getClock, stopTouchApp
    kwargs.setdefault('frame', 1)

    class testinfo(object):
        frame = kwargs.get('frame') + 1

    def test_runpymt_stop(info, *largs):
        info.frame -= 1
        if info.frame == 0:
            stopTouchApp()

    getClock().schedule_interval(curry(test_runpymt_stop, testinfo), 0)
    runTouchApp(*largs)

def test(cond):
    '''Test a condition, and print the result on the screen'''
    import sys
    import inspect
    import os
    frame = sys._current_frames().values()[0]
    callers = inspect.getouterframes(frame)
    caller = callers[1]
    info = inspect.getframeinfo(caller[0])
    code = info.code_context[0].replace('\n','').strip()
    if cond:
        os.environ['__test_passed'] = str(int(os.environ['__test_passed']) + 1)
        testresult(code, 'OK')
    else:
        os.environ['__test_failed'] = str(int(os.environ['__test_failed']) + 1)
        testresult(code, 'Failed')

def testresult(code, ret):
    '''Print a result on the screen'''
    import os, sys
    if '__verbose' not in os.environ:
        return
    print '%-35s %-35s %4s' % (
        '%s:%s' % (os.environ['__modname'][5:],
                   os.environ['__testname'][9:]),
        code,
        ret
    )

def _set_testinfo(a, b):
    import os
    os.environ['__modname'] = a
    os.environ['__testname'] = b
    os.environ['__test_passed'] = '0'
    os.environ['__test_failed'] = '0'


if __name__ == '__main__':
    import os
    import sys
    import time

    def testrun(modname, testname):
        _set_testinfo(modname, testname)
        __import__(modname)
        mod = sys.modules[modname]
        getattr(mod, testname)()
        passed = os.environ['__test_passed']
        failed = os.environ['__test_failed']
        print '%-35s %3s passed, %3s failed' % (
            '%s:%s' % (os.environ['__modname'][5:],
                       os.environ['__testname'][9:]),
            passed, failed)

    def testrun_launch(modname, testname):
        import subprocess
        args = []
        kargs = {}
        if '__verbose' in os.environ:
            args.append('--verbose')
        if '__debug' not in os.environ:
            kargs['stderr'] = subprocess.PIPE
        p = subprocess.Popen(
            ['python', __file__, modname, testname] + args,
            env=os.environ,
            **kargs
        )
        p.communicate()

    opts = [x for x in sys.argv if x.startswith('--')]
    sys.argv = [x for x in sys.argv if not x.startswith('--')]

    for x in opts:
        if x in ('--verbose'):
            os.environ['__verbose'] = '1'
        elif x in ('--debug'):
            os.environ['__debug'] = '1'
        elif x in ('--help'):
            print 'Usage: python init.py [options] <filter>'
            print '  --debug              show debug'
            print '  --verbose            show verbose'
            print '  --help               show this help'
            sys.exit(0)

    if len(sys.argv) == 3:
        modname = sys.argv[1][:-3]
        testname = sys.argv[2]
        testrun(modname, testname)
    else:

        flt = None
        if len(sys.argv) == 2:
            flt = sys.argv[1]

        current_dir = os.path.dirname(__file__)
        if current_dir == '':
            current_dir = '.'

        start = time.time()

        l = os.listdir(current_dir)
        l.sort()
        for modname in l:
            if not modname.startswith('test_'):
                continue
            if modname[-3:] != '.py':
                continue
            mod = __import__(modname[:-3])
            for testname in dir(mod):
                if not testname.startswith('unittest_'):
                    continue
                if flt is None or flt in testname:
                    testrun_launch(modname, testname)

        elasped = time.time() - start
        print '>> Finished in %.3fs' % (
            elasped,
        )

########NEW FILE########
__FILENAME__ = scatter-test
from pymt import *

scatter_test_xml = '''
<MTBoxLayout>
<MTGridLayout cols='2'>
        <MTLabel label='"Scale:"' color='(1,1,1)' />
        <MTSlider id='"scale"' orientation='"horizontal"' min='0.2' max='5.0'/>
        <MTLabel label='"Rotation:"' color='(1,1,1)' />
        <MTSlider id='"rotation"' min='0' max='360' orientation='"horizontal"'/>
</MTGridLayout>
<MTButton id='"pos"' label='"pos=(100,500)"' size_hint='(1,1)'/>
<MTButton id='"center"' label='"center=(500,200)"' size_hint='(1,1)' />
<MTToggleButton id='"transform"' label='"Save Transform"' size_hint='(1,1)' />
</MTBoxLayout>
'''

class ScatterTest(MTWidget):
    def __init__(self, **kwargs):
        super(ScatterTest, self).__init__(**kwargs)
        self.xml = XMLWidget(xml=scatter_test_xml)
        self.xml.root.width=getWindow().width
        self.xml.autoconnect(self)

        self.scatter = MTScatterWidget(style={'draw-background':1})
        self.scatter.connect('on_transform', self.update_values)

        self.add_widget(self.xml.root)
        self.add_widget(self.scatter)

    def update_values(self, *args):
        self.xml.getById('scale').value = self.scatter.scale
        self.xml.getById('rotation').value = self.scatter.rotation

    def on_scale_value_change(self, val):
        self.scatter.scale = val

    def on_rotation_value_change(self, val):
        self.scatter.rotation = val

    def on_pos_release(self, *args):
        anim = Animation(pos=(100,500))
        self.scatter.do(anim)

    def on_center_release(self, *args):
        anim = Animation(center=(500,200), scale=4)
        self.scatter.do(anim)

    def on_transform_release(self, *args):
        toggle = self.xml.getById('transform')
        if toggle.state == 'down':
            self.saved_transform = (self.scatter.pos, self.scatter.rotation, self.scatter.scale)
            toggle.label = "Restore Transform"
        else:
            p,r,s = self.saved_transform
            anim = Animation(pos=p, rotation=r, scale=s)
            self.scatter.do(anim)
            toggle.label = "Save Transform"


    def draw(self):
        set_color(0,0,0,8)
        drawRectangle((0,0), getWindow().size)

        set_color(1,0,0)
        bbox = self.scatter.bbox
        drawRectangle(*bbox)

        set_color(0,1,0)
        drawCircle(bbox[0], radius=20)
        drawLabel("pos", pos=self.scatter.pos)

        set_color(0,0,1)
        drawCircle(self.scatter.center, radius=20)
        drawLabel("center", pos=self.scatter.center)

        set_color(1,0,1)
        drawCircle((500,200), radius=20)
        drawLabel("(500,200)", pos=(500,200))

        set_color(1,0,1)
        drawCircle((100,500), radius=20)
        drawLabel("(100,500)", pos=(100,500))




runTouchApp(ScatterTest())

########NEW FILE########
__FILENAME__ = test_baseobject
'''
BaseObject
'''

from init import test, import_pymt_no_window

def unittest_defaults():
    import_pymt_no_window()
    from pymt import BaseObject
    a = BaseObject()
    test(a.x == 0)
    test(a.y == 0)
    test(a.width == 0)
    test(a.height == 0)
    test(a.pos == (0, 0))
    test(a.size == (0, 0))

    # test every accessor
    a.x = 2
    test(a.x == 2)
    test(a.pos == (2, 0))
    test(a.center == (2, 0))

    a.y = 2
    test(a.y == 2)
    test(a.pos == (2, 2))
    test(a.center == (2, 2))

    a.pos = (0, 0)
    test(a.x == 0)
    test(a.y == 0)
    test(a.pos == (0, 0))
    test(a.center == (0, 0))

    a.width = 2
    test(a.width == 2)
    test(a.size == (2, 0))
    test(a.center == (1, 0))

    a.height = 2
    test(a.height == 2)
    test(a.size == (2, 2))
    test(a.center == (1, 1))

    a.size = (0, 0)
    test(a.width == 0)
    test(a.height == 0)
    test(a.size == (0, 0))
    test(a.center == (0, 0))

    a.center = (5, 5)
    test(a.x == 5)
    test(a.y == 5)
    test(a.pos == (5, 5))
    test(a.width == 0)
    test(a.height == 0)
    test(a.size == (0, 0))

    a.size = (20, 20)
    test(a.center == (15, 15))


########NEW FILE########
__FILENAME__ = test_css
'''
Css styling basic tests
'''

from init import test, import_pymt_no_window

def unittest_css():
    import_pymt_no_window()
    from pymt import MTWidget, Label
    from pymt import css_add_sheet
    css_add_sheet('''
    .style {
        bg-color: rgba(255, 255, 255, 255);
        }
    #my { bg-color : rgba(255, 0, 255, 0);}
    ''')
    w = MTWidget(cls='style')
    x = MTWidget(id='my',cls='style')
    test(w.style['bg-color'] == [1.0 ,1.0 ,1.0 ,1.0])
    test(x.style['bg-color'] == [1.0 ,0.0 ,1.0 ,0.0])
    x.style['bg-color'] = [0, 0, 0, 0]
    test(x.style['bg-color'] == [0 ,0 ,0 ,0])

def unittest_css_label():
    import_pymt_no_window()
    from pymt import MTLabel, css_add_sheet
    css_add_sheet('''
    .style {
        color: rgba(0, 255, 0, 255);
    }
    ''')
    l = MTLabel(label='test', cls='style')
    test(l.style['color'] == [0.0, 1.0, 0.0, 1.0])

def unittest_css_multiclass():
    import_pymt_no_window()
    from pymt import MTLabel, css_add_sheet
    css_add_sheet('''
    .test1 {
        font-color : rgba(255,255,255,255);
    }
    .test2 {
        font-size: 24;
    }
    ''')
    l = MTLabel(label = 'test', cls=('test1', 'test2'))
    test(l.style['font-size'] == 24)

########NEW FILE########
__FILENAME__ = test_events
'''
Events
'''

from init import test, import_pymt_no_window

def unittest_dispatcher():
    import_pymt_no_window()
    from pymt import EventDispatcher

    class MyEventDispatcher(EventDispatcher):
        def on_test(self, *largs):
            pass

    global testpass, testargs
    testpass = False
    testargs = None

    def callbacktest(*largs):
        global testpass, testargs
        testpass = True
        testargs = largs

    def resettest():
        global testpass, testargs
        testpass = False
        testargs = None

    a = MyEventDispatcher()

    # test unknown event
    resettest()
    try:
        a.connect('on_test', callbacktest)
    except:
        testpass = True

    test('no register' and testpass)

    # register event + test
    resettest()
    a.register_event_type('on_test')
    try:
        a.connect('on_test', callbacktest)
        testpass = True
    except:
        pass

    test('register' and testpass)

    # test dispatch
    resettest()
    a.dispatch_event('on_test')
    test('dispatch' and testpass)
    test(testargs == ())

    resettest()
    a.dispatch_event('on_test', 123)
    test('disp+arg' and testpass)
    test(testargs == (123,))

    resettest()
    a.dispatch_event('on_test', 123, 'blhe')
    test('disp+2args' and testpass)
    test(testargs == (123, 'blhe'))

    # remove handler
    resettest()
    a.remove_handler('on_test', callbacktest)
    a.dispatch_event('on_test')
    test('nohandler' and not testpass)



########NEW FILE########
__FILENAME__ = test_layout
'''
Layout
'''

from init import test, import_pymt_no_window

def unittest_boxlayout_horizontal():
    _test_boxlayout('horizontal')

def unittest_boxlayout_vertical():
    _test_boxlayout('vertical')

def _test_boxlayout(orientation):
    import_pymt_no_window()
    from pymt import MTBoxLayout, MTWidget

    # note: this test act always if orientation
    # is a horizontal one. use sw() around pos or size
    # to ensure that the swap is done.

    def sw(tpl):
        tpl = tuple(map(int, tpl))
        if orientation == 'vertical':
            return tpl[1], tpl[0]
        return tpl


    # note: default spacing is 1
    # default padding is 0

    # default add
    m = MTBoxLayout(orientation=orientation)
    for x in xrange(10):
        m.add_widget(MTWidget(size=(10,10)))
    test(sw(m.size) == (109, 10))

    #
    # spacing to 10
    #
    m = MTBoxLayout(orientation=orientation, spacing=10)
    for x in xrange(10):
        m.add_widget(MTWidget(size=(10,10)))
    test(sw(m.size) == (190, 10))

    #
    # padding to 10
    #
    m = MTBoxLayout(orientation=orientation, padding=10, spacing=0)
    for x in xrange(10):
        m.add_widget(MTWidget(size=(10,10)))
    m.do_layout()

    # size should be 10 (number of widget) * width (10) + 2 * padding
    test(sw(m.size) == (120, 30))
    for x in xrange(10):
        if orientation == 'vertical':
            test(sw(m.children[x].pos) == (10 + x * 10, 10))
        else:
            test(sw(m.children[x].pos) == (10 + (9 - x) * 10, 10))


    #
    # testing size_hint with padding
    #
    m = MTBoxLayout(orientation=orientation, padding=10, spacing=0,
                    size_hint=(None, None), size=(500, 500))
    m.add_widget(MTWidget(size_hint=(1, 1)))
    m.do_layout()
    test(sw(m.size) == (500, 500))
    test(sw(m.children[0].size) == (480, 480))

    #
    # testing size_hint with spacing
    #
    m = MTBoxLayout(orientation=orientation, spacing=10,
                    size_hint=(None, None), size=(500, 500))
    m.add_widget(MTWidget(size_hint=(1, 1)))
    m.do_layout()

    # only one should have no impact
    test(sw(m.size) == (500, 500))
    test(sw(m.children[0].size) == (500, 500))

    # add a second widget
    m.add_widget(MTWidget(size_hint=(1, 1)))
    m.do_layout()

    # now, we should see difference
    test(sw(m.size) == (500, 500))
    test(sw(m.children[0].size) == (245, 500))
    test(sw(m.children[1].size) == (245, 500))


    #
    # testing with padding + spacing
    #
    m = MTBoxLayout(orientation=orientation, spacing=10, padding=10)
    for x in xrange(10):
        m.add_widget(MTWidget(size=(10,10)))
    m.do_layout()

    test(sw(m.size) == (210, 30))
    for x in xrange(10):
        if orientation == 'vertical':
            test(sw(m.children[x].pos) == (10 + x * 20, 10))
        else:
            test(sw(m.children[x].pos) == (10 + (9 - x) * 20, 10))


    #
    # testing with padding + spacing + size_hint
    #
    m = MTBoxLayout(orientation=orientation, spacing=10, padding=10,
                    size_hint=(None, None), size=(500, 500))
    m.add_widget(MTWidget(size_hint=(1, 1)))
    m.add_widget(MTWidget(size_hint=(1, 1)))
    m.do_layout()

    # now, we should see difference
    test(sw(m.size) == (500, 500))
    test(sw(m.children[0].size) == (235, 480))
    test(sw(m.children[1].size) == (235, 480))
    if orientation == 'vertical':
        test(sw(m.children[0].pos) == (10, 10))
        test(sw(m.children[1].pos) == (255, 10))
    else:
        test(sw(m.children[0].pos) == (255, 10))
        test(sw(m.children[1].pos) == (10, 10))


########NEW FILE########
__FILENAME__ = test_textarea
'''
Test usage of MTTextArea widget
'''

from init import test, import_pymt_window

def instance(**kwargs):
    ''' Individual test framework'''
    import_pymt_window()
    from pymt import MTTextArea
    from pymt import css_add_sheet, css_reload
    try:
        return MTTextArea(**kwargs)
    except:
        return None

def unittest_mttextarea_cursor():
    t = instance()
    test(t is not None)
    if t is None:
        return

    test(t.cursor == (0, 0))
    test(t.cursor_index == 0)

    t.value = 'abc\ndef\nghi'
    test(len(t.value) == 11)
    test(t.cursor == (3, 2))
    test(t.cursor_index == 11)

    # test some cursor position from text index
    test(t.get_cursor_from_index(0)  == (0, 0))
    test(t.get_cursor_from_index(1)  == (1, 0))
    test(t.get_cursor_from_index(2)  == (2, 0))
    test(t.get_cursor_from_index(3)  == (3, 0))
    test(t.get_cursor_from_index(4)  == (0, 1))
    test(t.get_cursor_from_index(5)  == (1, 1))
    test(t.get_cursor_from_index(6)  == (2, 1))
    test(t.get_cursor_from_index(7)  == (3, 1))
    test(t.get_cursor_from_index(8)  == (0, 2))
    test(t.get_cursor_from_index(9)  == (1, 2))
    test(t.get_cursor_from_index(10) == (2, 2))
    test(t.get_cursor_from_index(11) == (3, 2))

    # now, set the cursor, and check the index
    t.cursor = (0, 0)
    test(t.cursor_index == 0)
    t.cursor = (1, 0)
    test(t.cursor_index == 1)
    t.cursor = (2, 0)
    test(t.cursor_index == 2)
    t.cursor = (3, 0)
    test(t.cursor_index == 3)
    t.cursor = (0, 1)
    test(t.cursor_index == 4)
    t.cursor = (1, 1)
    test(t.cursor_index == 5)
    t.cursor = (2, 1)
    test(t.cursor_index == 6)
    t.cursor = (3, 1)
    test(t.cursor_index == 7)
    t.cursor = (0, 2)
    test(t.cursor_index == 8)
    t.cursor = (1, 2)
    test(t.cursor_index == 9)
    t.cursor = (2, 2)
    test(t.cursor_index == 10)
    t.cursor = (3, 2)
    test(t.cursor_index == 11)

    # test bounds
    test(t.get_cursor_from_index(-1) == (0, 0))
    test(t.get_cursor_from_index(-100) == (0, 0))
    print t.get_cursor_from_index(12)
    test(t.get_cursor_from_index(12) == (3, 2))
    test(t.get_cursor_from_index(100) == (3, 2))


def unittest_mttextarea_basics():
    '''Test  driver'''

    # Test defaults
    t = instance()
    test(t is not None)
    if t is None: return
    test(t.height == 100)
    test(t.width == 100)
    test(t.value == '')
    test(len(t.lines) == 1)

    # Test operations with a single line in widget
    tline1 = 'This is a single line'
    t.value = tline1
    test(tline1 == t.value)
    test(len(t.lines) == 3)
    test(t.height == 100)
    test(t.width == 100)

    # Replace text with an empty string
    t.value = ''
    test(t.value == '')
    test(len(t.lines) == 1)
    test(t.height == 100)
    test(t.width == 100)

    # Now lets put in a string of 12 lines and see what happens
    tline2 = ['', 'Line 1', ('Line 2 which is rather long and should overflow'
              ' horizontally ........................'),
              'Line 3', 'Line 4', 'Line 5   ', 'Line 6', '   Line 7',
              'Line 8', '', 'Line 10', '']
    tline2b = '\n'.join(tline2)
    t.value = tline2b
    # Among other things, make sure leading and trailing white space
    # are not lost
    test(tline2b == t.value)
    test(len(t.lines) == 21)
    test(t.height == 100)
    test(t.width == 100)

    # Lets replace line 8
    '''This is now deprecated.
    lt1 = 'Replacement text for line 8'
    tline2[7] = lt1
    tline2c = '\n'.join(tline2)
    t.set_line_text(7, lt1)
    test(tline2c == t.value)
    test(len(t.lines) == 12)
    test(t.height == 100)
    test(t.width == 100)
    '''

    # Test full auto-sizing
    del t
    t = instance(autosize=True)
    test(t is not None)
    if t is None: return

    # Test defaults
    test(int(t.height) == 25)
    test(int(t.width) == 1)
    test(t.value == '')
    test(len(t._glyph_size) == 0)
    test(len(t.lines) == 1)

    # Test operations with a single line in widget
    # This test assumes the default font and Pygame as text manager running
    # on Ubuntu 10.04.
    # Other text managers may give slightly different results for dimensions
    # and different fonts could cause larger variations
    t.value = tline1
    test(tline1 == t.value)
    test(len(t.lines) == 1)
    test(int(t.height) == 25)
    test(int(t.width) == 203)

    # Replace text with an empty string
    t.value = ''
    test(t.value == '')
    test(len(t.lines) == 1)
    test(int(t.height) == 25)
    test(int(t.width) == 1)

    # Now lets put in a string of 12 lines and see what happens
    t.value = tline2b
    # Among other things, make sure leading and trailing white space
    # are not lost
    test(tline2b == t.value)
    test(len(t.lines) == 12)
    test(int(t.height) == 322)
    test(int(t.width) == 809)

########NEW FILE########
__FILENAME__ = test_textinput
'''
test usage of MTTextInput widget
'''

from init import test, import_pymt_window

def instance():
    import_pymt_window()
    from pymt import MTTextInput
    from pymt import css_add_sheet, css_reload
    try:
        t = MTTextInput()
        return True
    except:
        return False

def unittest_mttextinput():
    test(instance())


########NEW FILE########
__FILENAME__ = test_vector

from init import test, import_pymt_no_window

def unittest_basics():
    import_pymt_no_window()
    from pymt import Vector
    v = Vector(10, 10)
    test(v.x == 10)
    test(v.y == 10)

    a = Vector(1, 1)
    b = Vector(2, 2)

    test(a != b)

    # add
    c = a + b
    test(c.x == 3)
    test(c.y == 3)
    test(c[0] == 3)
    test(c[1] == 3)

    # sub
    c = a - b
    test(c.x == -1)
    test(c.y == -1)

    # mul
    c = b * 2
    test(c.x == 4)
    test(c.y == 4)

    # add with tuple
    c = b + (5, 6)
    test(c.x == 7)
    test(c.y == 8)

    # add with list
    c = b + [5, 6]
    test(c.x == 7)
    test(c.y == 8)

def unittest_methods():
    import_pymt_no_window()
    from pymt import Vector

    a = Vector(0, 10)
    test(a.length() == 10)

    b = Vector(0, 20)
    test(b.distance(a) == 10)


########NEW FILE########
__FILENAME__ = test_widget
'''
Widgets
'''

from init import test, import_pymt_no_window

def unittest_defaults():
    import_pymt_no_window()
    from pymt import MTWidget
    w = MTWidget()
    test(w.x == 0)
    test(w.y == 0)
    test(w.width == 100)
    test(w.height == 100)
    test(w.visible == True)
    test(w.draw_children == True)
    test(w.cls == '')

def unittest_visible_methods():
    import_pymt_no_window()
    from pymt import MTWidget
    w = MTWidget()
    w.hide()
    test(w.visible == False)
    w.show()
    test(w.visible == True)

def unittest_visible_events():
    import_pymt_no_window()
    from pymt import MTWidget

    global on_update_called
    on_update_called = 0

    def on_update():
        global on_update_called
        on_update_called += 1

    # by default, visible is True
    w = MTWidget()
    w.connect('on_draw', on_draw)
    w.dispatch_event('on_draw')
    test(on_draw_called == 1)

    # make it invisible
    w.visible = False
    w.dispatch_event('on_draw')
    test(on_draw_called == 1)

    # make it visible
    w.visible = True
    w.dispatch_event('on_draw')
    test(on_draw_called == 2)

    # create a new widget, visible default to False
    on_draw_called = 0
    w = MTWidget(visible=False)
    try:
        # XXX FIXME unable to connect to default on_draw
        # since it's not yet register.
        w.connect('on_draw', on_draw)
    except:
        pass
    w.dispatch_event('on_draw')
    test(on_draw_called == 0)

    w.visible = True
    w.connect('on_draw', on_draw)
    w.dispatch_event('on_draw')
    test(on_draw_called == 1)

def unittest_coordinate_transform():
    import_pymt_no_window()
    from pymt import MTWidget

    # child 2 inside child 1 inside child0
    child0 = MTWidget(pos=(100, 100))
    child1 = MTWidget(pos=(200, 200))
    child2 = MTWidget(pos=(300, 300))

    child0.add_widget(child1)
    child1.add_widget(child2)

    test(child0.pos == (100, 100))
    test(child1.pos == (200, 200))
    test(child2.pos == (300, 300))

    # screen coordinate is default
    test(child0.to_local(*child1.pos) == (200, 200))

    # using the relative attribute,
    # we should have relative coordinate
    test(child0.to_local(*child1.pos, relative=True) == (100, 100))
    test(child1.to_local(*child2.pos, relative=True) == (100, 100))

    # screen coordinate 400,400 is 100,100 in relative coordinate from child2
    test(child2.to_widget(400, 400, relative=True) == (100, 100))

    # 100, 100 relative coordinate from child2 is 400, 400 in screen coordinate
    test(child2.to_window(100, 100, relative=True) == (400, 400))


########NEW FILE########
__FILENAME__ = cleanwhitespace
'''
Tool dedicated for Thomas (with lot of love, by Mathieu ^^)
It wipe out all spaces and tabs at end of a line

Usage:
    python tools/cleanwhitespace.py
'''

import re
import os

endspacestab = re.compile('([\t\ ]*)$')

for root, dirs, files in os.walk('.'):
    files = [x for x in files if x[-3:] == '.py' and x[0] != '.']
    for file in files:
        filename = os.path.join(root, file)
        with open(filename, 'r') as fd:
            content = fd.read()
        lines = content.split('\r\n')
        changes = 0
        for idx in xrange(len(lines)):
            line = endspacestab.split(lines[idx], maxsplit=1)[0]
            if lines[idx] != line:
                changes += 1
                lines[idx] = line
        modified = '\r\n'.join(lines)
        if changes:
            print filename, ',', changes, 'removals'
            with open(filename, 'w') as fd:
                fd.write(modified)

########NEW FILE########
__FILENAME__ = depend
from subprocess import *
import os

system_lib = ['re', 'optparse', 'os', 'sys', 'shutil', 'warnings', 'Queue', 'osc', 'numpy', 'math', 'xml.dom', 'logging', 'random', 'ctypeasc', 'ConfigParser', 'getopt', 'ctypes', 'gzip', 'urllib', 'gtk', 'operator', 'time']
system_lib_find = ['cssutils', 'pyglet', 'encutils', 'squirtle', 'factory']

def f9(seq):
    # Not order preserving
    return {}.fromkeys(seq).keys()

cmd = "find pymt -iname '*.py' -exec grep -H 'import' {} \;"
output = Popen(cmd, shell=True, stdout=PIPE).communicate()[0]
cmps = []

for line in output.split("\n"):
	if line == '':
		continue
	if line.find('`') > 0:
		continue
	if line.find('=') > 0:
		continue
	filename, line = map(lambda x: x.strip(), line.split(':', 1))
	line = line.rsplit('#', 1)[0]
	filename = filename[:-3]
	if line.startswith('import'):
		line = line[7:].replace(' ', '').split(',')
		for k in line:
			cmps.append((filename, k))
	elif line.startswith('from'):
		line = line[4:].rsplit('import', 1)[0].strip()
		cmps.append((filename, line))

# remove init
cmps2 = []
for a, b in cmps:
	p = 0
	for s in system_lib:
		if s in b:
			p = 1
		if s in a:
			p = 1
	for s in system_lib_find:
		if b.find(s) >= 0:
			p = 1
		if a.find(s) >= 0:
			p = 1
	if p:
		continue
	if os.path.basename(a) == '__init__':
		a = a[:-9]
	cmps2.append((a, b))
cmps = cmps2

# resolve path in b
cmps2 = []
kcmp = f9(map(lambda x: x[0], cmps))
for a, b in cmps:
	nb = b.lstrip('.')
	nbp = len(b) - len(nb)
	bc = b = b.replace('.', '/')
	if nbp > 0:
		bc = ('../' * nbp) + b

	# test in current directory
	c = os.path.normpath(os.path.join(a, bc))
	if os.path.exists(c + '.py'):
		b = c
	elif os.path.exists(c):
		b = c
	elif os.path.exists(os.path.normpath(os.path.join(a, '../', bc))):
		b = os.path.normpath(os.path.join(a, '../', bc))
	elif os.path.exists(os.path.normpath(os.path.join(a, '../', bc)) + '.py'):
		b = os.path.normpath(os.path.join(a, '../', bc))
	else:
		pass

	# append
	cmps2.append((a, b))
cmps = cmps2

print 'digraph {'
for a, b in cmps:
	print '"%s" -> "%s"' % (b, a)
print '}'

########NEW FILE########
__FILENAME__ = pep8
#!/usr/bin/python
# pep8.py - Check Python source code formatting, according to PEP 8
# Copyright (C) 2006 Johann C. Rocholl <johann@browsershots.org>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""
Check Python source code formatting, according to PEP 8:
http://www.python.org/dev/peps/pep-0008/

For usage and a list of options, try this:
$ python pep8.py -h

This program and its regression test suite live here:
http://svn.browsershots.org/trunk/devtools/pep8/
http://trac.browsershots.org/browser/trunk/devtools/pep8/

Groups of errors and warnings:
E errors
W warnings
100 indentation
200 whitespace
300 blank lines
400 imports
500 line length
600 deprecation
700 statements

You can add checks to this program by writing plugins. Each plugin is
a simple function that is called for each line of source code, either
physical or logical.

Physical line:
- Raw line of text from the input file.

Logical line:
- Multi-line statements converted to a single line.
- Stripped left and right.
- Contents of strings replaced with 'xxx' of same length.
- Comments removed.

The check function requests physical or logical lines by the name of
the first argument:

def maximum_line_length(physical_line)
def extraneous_whitespace(logical_line)
def blank_lines(logical_line, blank_lines, indent_level, line_number)

The last example above demonstrates how check plugins can request
additional information with extra arguments. All attributes of the
Checker object are available. Some examples:

lines: a list of the raw lines from the input file
tokens: the tokens that contribute to this logical line
line_number: line number in the input file
blank_lines: blank lines before this one
indent_char: first indentation character in this file (' ' or '\t')
indent_level: indentation (with tabs expanded to multiples of 8)
previous_indent_level: indentation on previous line
previous_logical: previous logical line

The docstring of each check function shall be the relevant part of
text from PEP 8. It is printed if the user enables --show-pep8.

"""

import os
import sys
import re
import time
import inspect
import tokenize
from optparse import OptionParser
from keyword import iskeyword
from fnmatch import fnmatch

__version__ = '0.2.0'
__revision__ = '$Rev$'

default_exclude = '.svn,CVS,*.pyc,*.pyo'

indent_match = re.compile(r'([ \t]*)').match
raise_comma_match = re.compile(r'raise\s+\w+\s*(,)').match
equals_boolean_search = re.compile(r'([!=]=\s*(True|False))|((True|False)\s*[!=]=)').search
equals_None_search = re.compile(r'([!=]=\s*None)|(None\s*[!=]=)').search

not_one_ws_around_operators_match = re.compile(r'^[^\(\[]+[^\s](\+|\-|\*|/|%|\^|&|\||=|<|>|>>|<<|\+=|\-=|\*=|/=|%=|\^=|&=|\|=|==|<=|>=|>>=|<<=|!=|<>)[^\s][^\)\]]+$').match

operators = """
+  -  *  /  %  ^  &  |  =  <  >  >>  <<
+= -= *= /= %= ^= &= |= == <= >= >>= <<=
!= <> :
in is or not and
""".split()

options = None
args = None


##############################################################################
# Plugins (check functions) for physical lines
##############################################################################


def tabs_or_spaces(physical_line, indent_char):
    """
    Never mix tabs and spaces.

    The most popular way of indenting Python is with spaces only.  The
    second-most popular way is with tabs only.  Code indented with a mixture
    of tabs and spaces should be converted to using spaces exclusively.  When
    invoking the Python command line interpreter with the -t option, it issues
    warnings about code that illegally mixes tabs and spaces.  When using -tt
    these warnings become errors.  These options are highly recommended!
    """
    indent = indent_match(physical_line).group(1)
    for offset, char in enumerate(indent):
        if char != indent_char:
            return offset, "E101 indentation contains mixed spaces and tabs"


def tabs_obsolete(physical_line):
    """
    For new projects, spaces-only are strongly recommended over tabs.  Most
    editors have features that make this easy to do.
    """
    indent = indent_match(physical_line).group(1)
    if indent.count('\t'):
        return indent.index('\t'), "W191 indentation contains tabs"


def trailing_whitespace(physical_line):
    """
    JCR: Trailing whitespace is superfluous.
    """
    physical_line = physical_line.rstrip('\n') # chr(10), newline
    physical_line = physical_line.rstrip('\r') # chr(13), carriage return
    physical_line = physical_line.rstrip('\x0c') # chr(12), form feed, ^L
    stripped = physical_line.rstrip()
    if physical_line != stripped:
        return len(stripped), "W291 trailing whitespace"


def trailing_blank_lines(physical_line, lines, line_number):
    """
    JCR: Trailing blank lines are superfluous.
    """
    if physical_line.strip() == '' and line_number == len(lines):
        return 0, "W391 blank line at end of file"


def missing_newline(physical_line):
    """
    JCR: The last line should have a newline.
    """
    if physical_line.rstrip() == physical_line:
        return len(physical_line), "W292 no newline at end of file"


def maximum_line_length(physical_line):
    """
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.
    """
    length = len(physical_line.rstrip())
    if length > 79:
        return 79, "E501 line too long (%d characters)" % length


def crlf_lines(physical_line):
    """
    Line contains CR (e.g. as a CRLF line ending).

    Many free software projects have a strong focus on POSIX platforms (like
    Linux, *BSD, Unix, Mac OS X, etc.) and they all use LF-only line endings.
    Only Win32 platform uses CRLF line endings.
    So if you have a Win32-only source code using CRLF line endings, you might
    want to exclude this test.
    """
    pos = physical_line.find('\r')
    if pos >= 0:
        return pos, "W293 line contains CR char(s)"


##############################################################################
# Plugins (check functions) for logical lines
##############################################################################


def blank_lines(logical_line, blank_lines, indent_level, line_number,
                previous_logical):
    """
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.
    """
    if line_number == 1:
        return # Don't expect blank lines before the first line
    if previous_logical.startswith('@'):
        return # Don't expect blank lines after function decorator
    if (logical_line.startswith('def ') or
        logical_line.startswith('class ') or
        logical_line.startswith('@')):
        if indent_level > 0 and blank_lines != 1:
            return 0, "E301 expected 1 blank line, found %d" % blank_lines
        if indent_level == 0 and blank_lines != 2:
            return 0, "E302 expected 2 blank lines, found %d" % blank_lines
    if blank_lines > 2:
        return 0, "E303 too many blank lines (%d)" % blank_lines


def extraneous_whitespace(logical_line):
    """
    Avoid extraneous whitespace in the following situations:

    - Immediately inside parentheses, brackets or braces.

    - Immediately before a comma, semicolon, or colon.
    """
    line = logical_line
    for char in '([{':
        found = line.find(char + ' ')
        if found > -1:
            return found + 1, "E201 whitespace after '%s'" % char
    for char in '}])':
        found = line.find(' ' + char)
        if found > -1 and line[found - 1] != ',':
            return found, "E202 whitespace before '%s'" % char
    for char in ',;:':
        found = line.find(' ' + char)
        if found > -1:
            return found, "E203 whitespace before '%s'" % char


def missing_whitespace(logical_line):
    """
    JCR: Each comma, semicolon or colon should be followed by whitespace.
    """
    line = logical_line
    for index in range(len(line) - 1):
        char = line[index]
        if char in ',;:' and line[index + 1] != ' ':
            before = line[:index]
            if char == ':' and before.count('[') > before.count(']'):
                continue # Slice syntax, no space required
            return index, "E231 missing whitespace after '%s'" % char


def indentation(logical_line, previous_logical, indent_char,
                indent_level, previous_indent_level):
    """
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.
    """
    if indent_char == ' ' and indent_level % 4:
        return 0, "E111 indentation is not a multiple of four"
    indent_expect = previous_logical.endswith(':')
    if indent_expect and indent_level <= previous_indent_level:
        return 0, "E112 expected an indented block"
    if indent_level > previous_indent_level and not indent_expect:
        return 0, "E113 unexpected indentation"


def whitespace_before_parameters(logical_line, tokens):
    """
    Avoid extraneous whitespace in the following situations:

    - Immediately before the open parenthesis that starts the argument
      list of a function call.

    - Immediately before the open parenthesis that starts an indexing or
      slicing.
    """
    prev_type = tokens[0][0]
    prev_text = tokens[0][1]
    prev_end = tokens[0][3]
    for index in range(1, len(tokens)):
        token_type, text, start, end, line = tokens[index]
        if (token_type == tokenize.OP and
            text in '([' and
            start != prev_end and
            prev_type == tokenize.NAME and
            (index < 2 or tokens[index - 2][1] != 'class') and
            (not iskeyword(prev_text))):
            return prev_end, "E211 whitespace before '%s'" % text
        prev_type = token_type
        prev_text = text
        prev_end = end


def extra_whitespace_around_operator(logical_line):
    """
    Avoid extraneous whitespace in the following situations:

    - More than one space around an assignment (or other) operator to
      align it with another.
    """
    line = logical_line
    for operator in operators:
        found = line.find('  ' + operator)
        if found > -1:
            return found, "E221 multiple spaces before operator"
        found = line.find(operator + '  ')
        if found > -1:
            return found, "E222 multiple spaces after operator"
        found = line.find('\t' + operator)
        if found > -1:
            return found, "E223 tab before operator"
        found = line.find(operator + '\t')
        if found > -1:
            return found, "E224 tab after operator"


def whitespace_around_operator(logical_line):
    """
    Have exactly 1 space left and right of the operator.
    """
    match = not_one_ws_around_operators_match(logical_line)
    if match and not 'lambda' in logical_line:
        return match.start(1), "E225 operators shall be surrounded by a single space on each side %s" % logical_line


def whitespace_around_comma(logical_line):
    """
    Avoid extraneous whitespace in the following situations:

    - More than one space around an assignment (or other) operator to
      align it with another.

    JCR: This should also be applied around comma etc.
    """
    line = logical_line
    for separator in ',;:':
        found = line.find(separator + '  ')
        if found > -1:
            return found + 1, "E241 multiple spaces after '%s'" % separator
        found = line.find(separator + '\t')
        if found > -1:
            return found + 1, "E242 tab after '%s'" % separator


def imports_on_separate_lines(logical_line):
    """
    Imports should usually be on separate lines.
    """
    line = logical_line
    if line.startswith('import '):
        found = line.find(',')
        if found > -1:
            return found, "E401 multiple imports on one line"


def compound_statements(logical_line):
    """
    Compound statements (multiple statements on the same line) are
    generally discouraged.
    """
    line = logical_line
    found = line.find(':')
    if -1 < found < len(line) - 1:
        before = line[:found]
        if (before.count('{') <= before.count('}') and # {'a': 1} (dict)
            before.count('[') <= before.count(']') and # [1:2] (slice)
            not re.search(r'\blambda\b', before)):     # lambda x: x
            return found, "E701 multiple statements on one line (colon)"
    found = line.find(';')
    if -1 < found:
        return found, "E702 multiple statements on one line (semicolon)"


def python_3000_has_key(logical_line):
    """
    The {}.has_key() method will be removed in the future version of
    Python. Use the 'in' operation instead, like:
    d = {"a": 1, "b": 2}
    if "b" in d:
        print d["b"]
    """
    pos = logical_line.find('.has_key(')
    if pos > -1:
        return pos, "W601 .has_key() is deprecated, use 'in'"


def python_3000_raise_comma(logical_line):
    """
    When raising an exception, use "raise ValueError('message')"
    instead of the older form "raise ValueError, 'message'".

    The paren-using form is preferred because when the exception arguments
    are long or include string formatting, you don't need to use line
    continuation characters thanks to the containing parentheses.  The older
    form will be removed in Python 3000.
    """
    match = raise_comma_match(logical_line)
    if match:
        return match.start(1), "W602 deprecated form of raising exception"


def dumb_equals_boolean(logical_line):
    """
    Using "if x == True:" or "if x == False:" is wrong in any case:

    First if you already have a boolean, you don't need to compare it to
    another boolean. Just use "if x:" or "if not x:".

    Second, even if you have some sort of "tristate logic", not only using
    True/False, but other values, then you want to use "if x is True:" or
    "if x is False:" because there is exactly one True and one False object.
    """
    match = equals_boolean_search(logical_line)
    if match:
        return match.start(1), "E798 don't use 'x == <boolean>', but just 'x' or 'not x' or 'x is <boolean>'"


def dumb_equals_None(logical_line):
    """
    Using "if x == None:" is wrong in any case:

    You either want to use "if x is None:" (there is only 1 None object) or -
    in some simple cases - just "if not x:".
    """
    match = equals_None_search(logical_line)
    if match:
        return match.start(1), "E799 don't use 'x == None', but just 'x is None' or 'not x'"


##############################################################################
# Helper functions
##############################################################################


def expand_indent(line):
    """
    Return the amount of indentation.
    Tabs are expanded to the next multiple of 8.

    >>> expand_indent('    ')
    4
    >>> expand_indent('\\t')
    8
    >>> expand_indent('    \\t')
    8
    >>> expand_indent('       \\t')
    8
    >>> expand_indent('        \\t')
    16
    """
    result = 0
    for char in line:
        if char == '\t':
            result = result / 8 * 8 + 8
        elif char == ' ':
            result += 1
        else:
            break
    return result


##############################################################################
# Framework to run all checks
##############################################################################


def message(text):
    """Print a message."""
    # print >> sys.stderr, options.prog + ': ' + text
    # print >> sys.stderr, text
    print text


def find_checks(argument_name):
    """
    Find all globally visible functions where the first argument name
    starts with argument_name.
    """
    checks = []
    function_type = type(find_checks)
    for name, function in globals().iteritems():
        if type(function) is function_type:
            args = inspect.getargspec(function)[0]
            if len(args) >= 1 and args[0].startswith(argument_name):
                checks.append((name, function, args))
    checks.sort()
    return checks


def mute_string(text):
    """
    Replace contents with 'xxx' to prevent syntax matching.

    >>> mute_string('"abc"')
    '"xxx"'
    >>> mute_string("'''abc'''")
    "'''xxx'''"
    >>> mute_string("r'abc'")
    "r'xxx'"
    """
    start = 1
    end = len(text) - 1
    # String modifiers (e.g. u or r)
    if text.endswith('"'):
        start += text.index('"')
    elif text.endswith("'"):
        start += text.index("'")
    # Triple quotes
    if text.endswith('"""') or text.endswith("'''"):
        start += 2
        end -= 2
    return text[:start] + 'x' * (end - start) + text[end:]


class Checker:
    """
    Load a Python source file, tokenize it, check coding style.
    """

    def __init__(self, filename):
        self.filename = filename
        self.lines = file(filename, 'rb').readlines()
        self.physical_checks = find_checks('physical_line')
        self.logical_checks = find_checks('logical_line')
        options.counters['physical lines'] = \
            options.counters.get('physical lines', 0) + len(self.lines)

    def readline(self):
        """
        Get the next line from the input buffer.
        """
        self.line_number += 1
        if self.line_number > len(self.lines):
            return ''
        return self.lines[self.line_number - 1]

    def readline_check_physical(self):
        """
        Check and return the next physical line. This method can be
        used to feed tokenize.generate_tokens.
        """
        line = self.readline()
        if line:
            self.check_physical(line)
        return line

    def run_check(self, check, argument_names):
        """
        Run a check plugin.
        """
        arguments = []
        for name in argument_names:
            arguments.append(getattr(self, name))
        return check(*arguments)

    def check_physical(self, line):
        """
        Run all physical checks on a raw input line.
        """
        self.physical_line = line
        if self.indent_char is None and len(line) and line[0] in ' \t':
            self.indent_char = line[0]
        for name, check, argument_names in self.physical_checks:
            result = self.run_check(check, argument_names)
            if result is not None:
                offset, text = result
                self.report_error(self.line_number, offset, text, check)

    def build_tokens_line(self):
        """
        Build a logical line from tokens.
        """
        self.mapping = []
        logical = []
        length = 0
        previous = None
        for token in self.tokens:
            token_type, text = token[0:2]
            if token_type in (tokenize.COMMENT, tokenize.NL,
                              tokenize.INDENT, tokenize.DEDENT,
                              tokenize.NEWLINE):
                continue
            if token_type == tokenize.STRING:
                text = mute_string(text)
            if previous:
                end_line, end = previous[3]
                start_line, start = token[2]
                if end_line != start_line: # different row
                    if self.lines[end_line - 1][end - 1] not in '{[(':
                        logical.append(' ')
                        length += 1
                elif end != start: # different column
                    fill = self.lines[end_line - 1][end:start]
                    logical.append(fill)
                    length += len(fill)
            self.mapping.append((length, token))
            logical.append(text)
            length += len(text)
            previous = token
        self.logical_line = ''.join(logical)
        assert self.logical_line.lstrip() == self.logical_line
        assert self.logical_line.rstrip() == self.logical_line

    def check_logical(self):
        """
        Build a line from tokens and run all logical checks on it.
        """
        options.counters['logical lines'] = \
            options.counters.get('logical lines', 0) + 1
        self.build_tokens_line()
        first_line = self.lines[self.mapping[0][1][2][0] - 1]
        indent = first_line[:self.mapping[0][1][2][1]]
        self.previous_indent_level = self.indent_level
        self.indent_level = expand_indent(indent)
        if options.verbose >= 2:
            print self.logical_line[:80].rstrip()
        for name, check, argument_names in self.logical_checks:
            if options.verbose >= 3:
                print '   ', name
            result = self.run_check(check, argument_names)
            if result is not None:
                offset, text = result
                if type(offset) is tuple:
                    original_number, original_offset = offset
                else:
                    for token_offset, token in self.mapping:
                        if offset >= token_offset:
                            original_number = token[2][0]
                            original_offset = (token[2][1]
                                               + offset - token_offset)
                self.report_error(original_number, original_offset,
                                  text, check)
        self.previous_logical = self.logical_line

    def check_all(self):
        """
        Run all checks on the input file.
        """
        self.file_errors = 0
        self.line_number = 0
        self.indent_char = None
        self.indent_level = 0
        self.previous_logical = ''
        self.blank_lines = 0
        self.tokens = []
        parens = 0
        for token in tokenize.generate_tokens(self.readline_check_physical):
            # print tokenize.tok_name[token[0]], repr(token)
            self.tokens.append(token)
            token_type, text = token[0:2]
            if token_type == tokenize.OP and text in '([{':
                parens += 1
            if token_type == tokenize.OP and text in '}])':
                parens -= 1
            if token_type == tokenize.NEWLINE and not parens:
                self.check_logical()
                self.blank_lines = 0
                self.tokens = []
            if token_type == tokenize.NL and not parens:
                self.blank_lines += 1
                self.tokens = []
            if token_type == tokenize.COMMENT:
                self.blank_lines = 0
        return self.file_errors

    def report_error(self, line_number, offset, text, check):
        """
        Report an error, according to options.
        """
        if options.quiet == 1 and not self.file_errors:
            message(self.filename)
        code = text[:4]
        if ignore_code(code):
            return
        self.file_errors += 1
        options.counters[code] = options.counters.get(code, 0) + 1
        options.messages[code] = text[5:]
        if options.quiet:
            return
        if options.testsuite:
            base = os.path.basename(self.filename)[:4]
            if base == code:
                return
            if base[0] == 'E' and code[0] == 'W':
                return
        if options.counters[code] == 1 or options.repeat:
            message("%s:%s:%d: %s" %
                    (self.filename, line_number, offset + 1, text))
            if options.show_source:
                line = self.lines[line_number - 1]
                message(line.rstrip())
                message(' ' * offset + '^')
            if options.show_pep8:
                message(check.__doc__.lstrip('\n').rstrip())


def input_file(filename):
    """
    Run all checks on a Python source file.
    """
    if excluded(filename) or not filename_match(filename):
        return {}
    if options.verbose:
        message('checking ' + filename)
    options.counters['files'] = options.counters.get('files', 0) + 1
    errors = Checker(filename).check_all()
    if options.testsuite and not errors:
        message("%s: %s" % (filename, "no errors found"))


def input_dir(dirname):
    """
    Check all Python source files in this directory and all subdirectories.
    """
    dirname = dirname.rstrip('/')
    if excluded(dirname):
        return
    for root, dirs, files in os.walk(dirname):
        if options.verbose:
            message('directory ' + root)
        options.counters['directories'] = \
            options.counters.get('directories', 0) + 1
        dirs.sort()
        for subdir in dirs:
            if excluded(subdir):
                dirs.remove(subdir)
        files.sort()
        for filename in files:
            input_file(os.path.join(root, filename))


def excluded(filename):
    """
    Check if options.exclude contains a pattern that matches filename.
    """
    basename = os.path.basename(filename)
    for pattern in options.exclude:
        if fnmatch(basename, pattern):
            # print basename, 'excluded because it matches', pattern
            return True


def filename_match(filename):
    """
    Check if options.filename contains a pattern that matches filename.
    If options.filename is unspecified, this always returns True.
    """
    if not options.filename:
        return True
    for pattern in options.filename:
        if fnmatch(filename, pattern):
            return True


def ignore_code(code):
    """
    Check if options.ignore contains a prefix of the error code.
    """
    for ignore in options.ignore:
        if code.startswith(ignore):
            return True


def get_error_statistics():
    """Get error statistics."""
    return get_statistics("E")


def get_warning_statistics():
    """Get warning statistics."""
    return get_statistics("W")


def get_statistics(prefix=''):
    """
    Get statistics for message codes that start with the prefix.

    prefix='' matches all errors and warnings
    prefix='E' matches all errors
    prefix='W' matches all warnings
    prefix='E4' matches all errors that have to do with imports
    """
    stats = []
    keys = options.messages.keys()
    keys.sort()
    for key in keys:
        if key.startswith(prefix):
            stats.append('%-7s %s %s' %
                         (options.counters[key], key, options.messages[key]))
    return stats


def print_statistics(prefix=''):
    """Print overall statistics (number of errors and warnings)."""
    for line in get_statistics(prefix):
        print line


def print_benchmark(elapsed):
    """
    Print benchmark numbers.
    """
    print '%-7.2f %s' % (elapsed, 'seconds elapsed')
    keys = ['directories', 'files',
            'logical lines', 'physical lines']
    for key in keys:
        if key in options.counters:
            print '%-7d %s per second (%d total)' % (
                options.counters[key] / elapsed, key,
                options.counters[key])


def process_options(arglist=None):
    """
    Process options passed either via arglist or via command line args.
    """
    global options, args
    usage = "%prog [options] input ..."
    parser = OptionParser(usage)
    parser.add_option('-v', '--verbose', default=0, action='count',
                      help="print status messages, or debug with -vv")
    parser.add_option('-q', '--quiet', default=0, action='count',
                      help="report only file names, or nothing with -qq")
    parser.add_option('--exclude', metavar='patterns', default=default_exclude,
                      help="skip matches (default %s)" % default_exclude)
    parser.add_option('--filename', metavar='patterns',
                      help="only check matching files (e.g. *.py)")
    parser.add_option('--ignore', metavar='errors', default='',
                      help="skip errors and warnings (e.g. E4,W)")
    parser.add_option('--repeat', action='store_true',
                      help="show all occurrences of the same error")
    parser.add_option('--show-source', action='store_true',
                      help="show source code for each error")
    parser.add_option('--show-pep8', action='store_true',
                      help="show text of PEP 8 for each error")
    parser.add_option('--statistics', action='store_true',
                      help="count errors and warnings")
    parser.add_option('--benchmark', action='store_true',
                      help="measure processing speed")
    parser.add_option('--testsuite', metavar='dir',
                      help="run regression tests from dir")
    parser.add_option('--doctest', action='store_true',
                      help="run doctest on myself")
    options, args = parser.parse_args(arglist)
    if options.testsuite:
        args.append(options.testsuite)
    if len(args) == 0:
        parser.error('input not specified')
    options.prog = os.path.basename(sys.argv[0])
    options.exclude = options.exclude.split(',')
    for index in range(len(options.exclude)):
        options.exclude[index] = options.exclude[index].rstrip('/')
    if options.filename:
        options.filename = options.filename.split(',')
    if options.ignore:
        options.ignore = options.ignore.split(',')
    else:
        options.ignore = []
    options.counters = {}
    options.messages = {}

    return options, args


def _main():
    """
    Parse options and run checks on Python source.
    """
    options, args = process_options()
    if options.doctest:
        import doctest
        return doctest.testmod()
    start_time = time.time()
    for path in args:
        if os.path.isdir(path):
            input_dir(path)
        else:
            input_file(path)
    elapsed = time.time() - start_time
    if options.statistics:
        print_statistics()
    if options.benchmark:
        print_benchmark(elapsed)


if __name__ == '__main__':
    _main()

########NEW FILE########
__FILENAME__ = pep8pymt
import sys
import os
import pep8
import time

htmlmode = False

class PymtChecker(pep8.Checker):
    def __init__(self, filename):
        pep8.Checker.__init__(self, filename)

    def report_error(self, line_number, offset, text, check):
        if htmlmode == False:
            return pep8.Checker.report_error(
                self, line_number, offset, text, check)

        # html generation
        print '<tr><td>%d</td><td>%s</td></tr>' % (line_number, text)

if __name__ == '__main__':

    def usage():
        print 'Usage: python pep8pymt.py [-html] <directory_of_pymt>'
        sys.exit(1)

    if len(sys.argv) < 2:
        usage()
    if sys.argv[1] == '-html':
        if len(sys.argv) < 3:
            usage()
        else:
            htmlmode = True
            basedir = sys.argv[2]
    else:
        basedir = sys.argv[1]


    pep8.process_options([''])

    if htmlmode:
        print '''<html>
        <head>
            <title>PyMT Pep8 checker</title>
            <style type="text/css">
            body, html
            {
                background: black url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQMAAAGQCAMAAACd/fUUAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAxQTFRFJysvIyMjJSgqJCYnQLTKlAAAMgtJREFUeNrMXYty5DgOk4H//+ebbtsS36Ld2apL7d3OThK3DVMUCYLUGJ8vHgfG+joOqv/62y/8xbXnRZj+COdn/Puh+VGQnywfE//+e/2XQYT1fXx+l/j3df0c/33V98+/wJcdDPi9P45//+D6W/3JQ78PymceBqDqVcg/sfdoe3zbpoACAxynGYx/P8sQA9jnxPzTeIIBj2H/1Dfl+l3j83PTwh5igO/94N+/sZYCDfrpgyJHgOeXwoDrZ9Mno1wu4rfR8xuMvw+WxvZdDuf/YC8Kj4G4HMPPZmw24/yk0g4YY4qtlX1Q4xe9pudQnui7BMbnOsFSiBbDCcPnA0NYzI/qlSUMO3i5HPZjNDgWhAkwrWHvAPhn9PKl/buf+778Uph/M6ovhE5MWMewdoAAA0aX1mvEPcv3keE83BYAHoe4tngS+KUQOoSRrIwABNoVvf7ePiPiy2f2z/lrfokAOwC0uayP5vpAfxPomICHVb1isY8cDoMU49QJnM8S/kC2GgjpyxBZIOQN3Y9dGELsa6O4RkZD158JGSEVKy3dDD5vkuH3Y0Pg936xfF7kiylsg2bFNgFQEPTDmra3iaKbyEguZ2E2gvNR52MzDJeFGcw7Y7AYwMZWjVd5QQuEFW6v7+L+5/SK1LcJE///g8hcGOq1zc8VILADQLyy2gF99sXCt4kF/LnfrwV8MdCB1pCO78IAwyGrXATlzQk8/PN/7Us9DM9/H39kBuJSOkjAitg/r/mMuxDujhy0L4flHuoe6nLoUZKn41heMFNcgfzJG/gtFjpmGOtbWIlumE6YrY6Fw/J7VnLdf1bhQynpcyFCInxumHxjBiaFZ7QPDvUfOIoYvIEBNdYT3BHcOM3in66qWubXOmXbDK7HRuhorjV8XvN2Y/Qr3ZkVN3xH9M0RmO9R7OLsmngDA+QY3O8eE9cgbeIIkrEisRgPMLhszOTtc3G6h2YAAn/E4DJpiE/3jnswwqDcqI4uBv8AhvV8gfGbCFlZT8Md6PQzeEBxewy35eH2dhS7N3SSgAoDCJdbePnFO+EnDEwYIy2dnKsckZFPhoHXbhJFOd8fuR8B0VZkMYB2t8i9/NprokcbfQx8BGx9GC/C073ic1/68AaId6e1JkXcYbeiYbxxyJZEj4SFWbXMexhoUkU6AdS+HsgePnbh4VY0VuQd3jr3GCBKBN5gwBHleT/xz+EnJhiY77oQNMSAMhM194/uvmA3Hshn5o91CD7AQKdTwbsKHwCquLBFbZM1QVGS5j2+tIP43uxWNCQER+277TfkPb+JkaLbPTd4DNgaxsZ/9pYC44z6dER5gJsu74sURvJkeIjBd4s/n58r2vMYYJu+I+eIjhDKL/e+xyA155Q557OlgIuc5XHV7BBnVNhyGMhvO/nFcSXsZ3SRva30pSJ/uY/N4HKyV5k0XroM9xNmtVi0SMyhokgktzq6X+gTCPQYLMu3DuHw1EdCZSinzx1ztTDgSPdGX4YW91k/F59sjBIDikSZMi8GDhPC0wXHSNdwuoSGhCC8bWb7hfWI6e104iPhX6kS5UXgc1Z1qYsyzDFItSQ0GIyoHKcwYMMj8hGXxDA34CRCkMQ7FLnThQDC/TCNPVc6cL+0ISHIAwQ+3Ol2y4GqtGZ2bIZXcwYNxvGC3vxpfi8oJ4xjVx9sbnV4wi7Tb/XzliSlnb/f6/VnJSFDvUKWr/mlh24i7rsjg+WLU5cCnteNUlj1Xl8XMT4Zrf5dTTN1Y2co5GlLsiEI6FHmpR7E5uP2FtwyTQoDiCH4ltt6ATSGXWfMvVPxZMHzd27glJNoOY5dqszIgOvH1kYoIDhLrl9GaXcnH6YledzoftMiCi2d+NQco2v1tHzUpLN0CGMqaDZ8SmJjz55CujUC+EVcdzSL2a56TMOAcVWdx9GrMmnzeJScPyZ2WEk2+7V4xW3CVp3wKY2BknP8fq4KoZgmDGZv7Jgv9kJURhsISoFPiapyh8OVEc5gTVTkZtrJJWlzhiQwuPHhxrmTDQqD3PAGCoi+LEOqquA4ZonBSbirt+bMwHAQY5ZwaO9QgsKW70IvuWQWOvQMcZkBqXQI31rDBQ+GwQCS2tCveyyE1quCL7FgS+GgnWCnGJi8M1QvDiHSmCtd+TtQhppYGeStUIChHa6cieFDiKD7a+Vfy8j2Am/0p8a0iClRpVKlTNeoQA8VZnzRgwbtWAG6C6mHMBOkN8SpSL1i5hIDG6sws3kW+JQrxFx/HFMEwXHL9Q9VNRC88RVarPBySDECMhflMtBgZ6iCyxXlcIOBEr80ozCsD+WZdcG5xEPpfe6kK8BARIHcVIA8CuUOR0VvVckH/TIx4UYRu9qgSZGzBoPvDgk6DNInMT0uV2ne/8ix1z9Aa+WS5CtcOkV4bsDBOIwkwxfbv5wdlk8cCQPhvJeKFhi+6QcYIN0aQwaDRmZbhuFU7kBh8C3pf98jPJ84HyYDgalvYn1vkHJ37DFAVOWhlIdvQdAhtX5GSPnUsBhldQz5jAxA2KgXp3mlxEnaLTBDnIEnRdhrWxbltWx/iTBI3qnd8fKQPt8ZrBixCJGsvKnZbOdYk0MsJftdFR8kHG7MR3GX1mzZVWvyyEEQwjy80gwf0WJQqdMIzKBiFljx6HiMAU1Pqec2xS4/fsIAqTcbsewte1hegQ7+CIPDytMQ+lHa3ts39FXBHzC7YFwSQxCw/4ABrGDB9EKJaA8/YoAMhIpDQbRjUSSSrzGgX5TRctAYpHuITMwqei+7w8rHMkidZs46+DcYuJAAkfWK/tERM/Idsj/WgpbbTCQpOG4pllW8/46BrbObQmgg0BbMNFo4RGGevBys0BGBUBOL38R4ggE63OFQ6sRJbKQYzj6eu6Fl/sVVEXMLI958fPafZvBSguVcAhpxYswkqYfOFzCiWt0lwIVWtfEQ6ohAeT6g7cjD7LNXmewITfNgH4NCH1aII0ziDPVMuBusCbGJ3W47WxX0ybrS3jERlklGTsXwzzFQnRS7OQ7lJbnaNe8Vylls+YQwd2EZxthcC/pQyT8KDCjo58B067xRkDOBqWGbcGdxn9YFnevzq/C7hc7LjWvKHIKCzzE4vNLZPxka/EFQc3iAQbVQrirZuF36yk+/MzAEI4SqOj5UTBgznjh8cslrb3B6D93+mwgWjt8xuB72NGauqgHOh/2WqWX7Y8HxDBUo6J+j4TCCpYoHesQgVnbkFNUsgFJU+AkY7urBvRF+DePjHb606pxKAMwQixsMgED8R5UpKA2tdglvMDgQKPXZxOBzc9bEcaehV1OsF1CzxqBy0hzDZnnQiUO/zmTmZDh2Xi15pE4WYhrNqe+YgSbH9ea/FTOwrtn4wgJzeg6rNVREFvwNg6PEYBUJr8EoVAaEkXZWfGC4BxJ8AmDQxeKfK5JTk8Up1CrMQKwAz+WzjwHrGOKavcNK03b9oNGJXcE+hpM2CDVlyOjiQorc1L4hequXnwSeOoS4PoAHRsT4aXiFQKTvN4H9eENpYKcwW/GRFWSsNBo/LIWnDhUioLm2RPVWRdP2lVGQ82fC3i1d0QgKblwzFo41gGQZWrgYcH9J045FLHyKwRiuiUZpiukShq8HJUbW4KH1kWEwgyBLXo18rPi3RjT9GoNrkhQ08Euud++fZ+QIcIcBVkDvsmYxtEj6maGI+k3W8HcYcOUJtzvRngamsHvNKRjI+tRmJ4vUHZpCuAwNVwYBt8lXvfd2FSypxEs7wOH6K3HG57c143r138YALfKjEt7PJDPDANPsAsLoFjS84bo3vQE7n3hNxaPdBuYmg8knfSxAB/+THP1ax+0p6DqUIAKkGR/d5UrZaf4cAyVpeIzBSpqxdolbgs1LX7YynesHlE88N7mPgGURkndR47IgqgoHo8IsRMSIl1YwRtg2vt9Zl+YGOjw8TloJizQQCbDwV1QbwFzit3+cUxyi+RpUm8P892sziPqFGxhcRkuuQu7gtA1c7o3nvyH0xWo8EEyIBBkr4FBNrq72I+i7c894UfQxbcMPA+3ZfIC7OAoVNZw5k974lNBZA8s0XhIYnGO4ZJeXLEMj0MbcyRzvYFgESAiSnL0JKPJ/vkiuYRQiKpabPMTWT4QYHHWIBNPkHuyBqIJfBqVC7jvntNJxT1afzltNsNBtd1+aEUGJ6tb1TdlGtDWubSEqOTOuwEr22ltz3UWKXRIXfsxhe3DtD3xjBGOtDCZrMahoIRlMQ6DR8cMjzfxWuD1D21du5bvD3ZN0V+KjA4evhp3IONXo0dbbHV6Kt9hSYF9drNoFX1TRGRYpp8F/R+l+Y+Ornf5QCWQLgwhtqEx/ZYOdyprzeBJHdqLq+NK6+kTdg3ut2kW436zL8Q4DWbzjwwCowCDTkxXmgZ72ezZbeTE632JwcDfQ+REGbHk5bqmWzPCybZfxPNI/n6ofyQ6bGFg2jTu2KZg0YPpQcYf0CEUT/38Y7Ei3YuDEufrDQSR3ywWzsXn/HQY3g8YgAmLDkYr4KGdcqZQLHNFI37V9s6y1/TkIGYlybqnsmUGRNNG3DR9XaABk6wbjeIQB0PaBl4onfODFqD7KorZJE31HzMrjPsyGn1Uz6nkoV4FlscBP+njPBzTN40xznsZeUrTXD9N7JZJI0n1XZwupyY+yIw9PfACb77Qe5I3OBWDV35RcwKMh7yZT/gUE0hftNxSAbpc2pldkkSpBEgU/3I/P3ZOI8z06K7DnDkpFfnY/iB56Z0mivKXHh1xFv1PVi6JzMrV7sIPBNd5Qdw7dZU6MfrUgkGR6R5/9JuTeAIEBefn+UQxRr84a2GJAxN2fcwDu6Ht4jwGbGGBSg4SGENe8EK4xSu6FFa/naGCAm24hjMTwXtXob/SpQBIdW4Iki5RkRZFh4IN6FvLvQheeA4GrD4zac4TkUT3wG351u27WvOIBgUKhvg86kkx/jIJRuPQcDwQprjfMz7bsxQeqWIfd4VfoFa9ibyot1ukzuYq7jzBQwknlvzZyDJ08qOw+R4Ako/B56w5gnjfoqb+nzq3Db7o1Aoy0EP5K41b0weZv2Oh1Cgd+eAzWbAVeFUg+xEA9QxIPYr9muWXhsPcBqLdj2bKi9ZXXdrD8WruO3sHAXg0NIuVZPkodl6B0FaGQHJpnDXV+P6wFeMV7smO8heAJBlYwCN6RtjU1PsKAPkxMpayjGBjwOiWnLOKnYK1WDbhGlBuDK8r8CD7aU8b96v0BAxqZlFb9jC4GLLfiI5xgIwbO3AVddj28zxvzVb6NnugyMPpKTrrryXdau4ORY2ADxcdSktoO6GOVUZTuKNWLG6vUGNSu68oKsBSGPNzMUz7YGofPFIvwLK1XxwKlQ/UbtRVurNP8WF0Ha218hUFqsu0jTRwG6GIA0S+AKkiE2RfEC5Kvc67tv8Ig5cTKBMJigM19zPC7TBlpXDIPJW1zQ57bkqI4FHrxBYNom5hctFvM4kK3LqymikAJ+g4DNVfwZwwWtcbxN4mI6YoM2Qg8DkqK8PYXDIaXzI1Enf4OgSM+8CePz9hbwH0MlpIr63EIX8JvFhY9cDA05nmAXkS37XshdtcbzzHw7iCWF7laAF4bQhcDNIuz4aU6r4RTuIr9cuXcAIFtssLn7uBoLpnYFsJP79zMkZ4xRVG8KR/sJQi9BdSYMlth0CAmZ4yEXNkAN9hyjuzc3SYemsHxDIKjGC4YHMD5/EsNaKhHTeN4YQqG6YxBQ1TJT+ol1bbAH3eFahReNKhc3ybr8i91y2UlRWI6ICsauTp+x4Duck0QonY4pAiPqEgS3gSau8WLbaGzVstpheabl6tAUOdewoCoNB2KvBuseBODZ4aAdEZqWbWhiSXZ4XpLDNhwrbuJG3iu8UnuGyVCUDS9mgbRmAM7sn2crVeILgZPQNjGvSjMDvegVdb7SY6Bn0j14KBwoSALak38wQqO7THnItqSEXTDEHROtP7qiQ0jit0FKQKngUbVWg6rNVH5YS6uW7SFJICLGDKZkXJ9NJ9ZMALq+cYgP1oCLlvS2kI/TNpvVGbs6Sy83bQM4il96YCYEDE8sV5BpM1sIR/mYGqYDIaemaM0h5eHx4uCd/2fHoPtbIO3gk1YWheaJIsG5ftCmv9kHRsxcNTJFiEbv9B//gADPgzp1nXsdZnmlYKK9OCbozSHF8zFB4lhHRCxJIivNqXsaDTk6oCEig7ifR94D0MX+aM06X1PfLoNBASVxAlbDHbVgLTK5K/rXaN3J8PShu4ozWO0ZnvlZY8oFC1P4ECKAbeGYL95/SZdMi12Oju1MjhKky6g3VEGCbWPGrP4W6tZK1FRNupREIPgArduMQiO0jxGdiCurq8wKIaHRZvgSfNEUW//dXUhx0BmqO4IjQQDeZSmnUlv3T1gdPyxZ5P3yiJTDCxkXSH3p3U2WOZZOhKIj9IMuHU0Im2GvuucrGDVGvmgS245gPZkIlaKc0md+aM0/Vm6aF3f854cU8xgQMjTPGyfj8/UsdGrPGALdtr8EVJsjaTLBSPEdXaeLRYPd5hl7BDKgPldIAZwJn0rcTNHaUZsc9PSXH3ccictDLh7xe3CYpAWzOIxA3NCluc/yHus5ENv8Ec0LjiysrgsDjv++dFpqzN8/CSMZzQDsz6iLH7rerDBALBTD3oYZEbH0a+mxIT5JbAdeod0R2liG4ss5LjBQL/RBINehiFbR7sYOLKPlPEB9kOBU3kPQ/7KPs4RHb4+XmMwhKCqO8hTfEQUI7FRNctlQ1kMjeiORxz58ikG1AHXfhUhbkNcq2A/Kb3S4WKPAQPyApmh9sgTx2a0IyRjsRaD4IxWMfvgWSCGJOYN/vMpBuiIeNNtyxjC16WJKSG0NfcnEhMWQRJd8h3PtOB+XzQtFz1XojPFIIU1DgH8ewxmt8PN4WbnU6VuM+FNmmy8ubOo+wWqPIj/AIPB6ptJJZL72LjHQtp02W8mmCNRTzN4hQFo6feioJnrDeA9f3SRaLRQP1e4zoPVHut2evVZ8vGJxfQnmCC5J9UmWgRxq+6SwbhnHuoY1qchZtyXn/3VUoRZ+v1dxXddWwOG0I56VYngPv2EEmp9SABbr48Gked+hgEXlY5t5NbrZo5EofRMxZjNNRwIop2U4PgZAzd3aq8zQObuSzO4Z6DN0NiR0KcjuFoVmWDAP8UgmbrFjTIEqR32mCYmhnCUDmEkHRqopTD5w9czx1DoY1idEYAW0XTzy/aN3mEDkBR+0PMHipIL95Cj8RVRJkHVHj1FYMyEHPBzHWffMvxYxTRvTBLu49evt7qRwiG6v3CGMFMGHt4fUGQ5iMb3vX5oNUTpXSfITteuqDZ99ok1hInB3cJtMWB0ILgo1j6fgZkHgR0eASW08mQSWdzRXIV1vyOTn56RpdYV2MnlKNz4My0vWpQI+G51aQxIdfIE7uHj4eE9OK7BzUr6OAehDGmFfIoAzMEj2JlCfKR8bYUUEga1/c17KIaJHXcVXlkW1YnlOuF5NhotIk/K/ITFqtqOILVPeh5txkLBpSLl71xvKM3OZGU4K6+mPht6CcSLGnElAGG+4DRUYIn/pUihOU7lmLX93eoSb5wecw5VkoQ+teGefrOifz/MBMgMoWNSStiRmvKlFLMYbI4nP+Io1Qm5YVQ/87gOe15gUs2i5woebK7m7NNs0O81QCrsSSwJ5RgWx1zAHEFyTqjxg0AZMq0MKFa+wwDnqQtB+ZfXOSQPMLgGKiabjFk6U7UwI+H5hqMzel3SPvy0Fz7Z83IlzHpxc8xeE4M1BJWhddB7zEn5k2fd2i/PSjDCvTy8gQFTTQcVBtxiQKZPS04piZLc0B2wR7fbcDf9ZYy3dmDYJsIVHXBvnziicZrjpo7gWGe4rhaoB6TcGs3sMNcMhXQ+QpRi0nKTcrSa3m7N6FEY7RCn7LTAAJqWGms7QHgAi3gQte2AVt2A+Fz3UJpYZrvyT7QbB5Lqi7pTzBjWezmu3ofvHynPJ6Uj+eBEHL5wxXvWtQvXi8ICSgwoSOStKCbEYASKQ82RqekekJok43FXpd+gs2ghIvYm4dnZTXWNOEnKnn4aZhNIC7Ha0V+uG0N2H5mA0zWHIVolTKWWyQyFtnBIHCaR2EFQv0gLsacUW9/HhcExdzWaN3k4uBEVbjldFvNdFGabNDxZfBK6Fl7f79HwIurgBbi5rJ+7WMdPyfeKxY2JGU/2KGhHJofzQaptC+Eeg1pl6ielMXlEzCB75VVZ6e47el74OBmbHTKSp7pdV+6C2XQbLEGIWYmBu33I/l27FO77RC68mVeBEWHP4Gx5AEJ4dq4sE8nttSxhpkUZhYI8m6atVBxbDEAi0bldFQVVsuUd/E8MJCdxctmy/Obz+k5KE7c8+Nay8MdkNMT7jF6qQXOX/NmFWyEG7oQG3OtUDcGsmah33HFw9Az+hCVESkRGZWwO4Q60EV7vmVum4i0GobonOEbml/MPjYkGMnicjCj9Zu871UJu8gpTjz/8wnhDmbTKzyFOV35rQ48rX+CWm3QEFPl7KSmizvjUGNjB4O5NckthGJVuxU0iEkbjZxRcUIQXl8XmZngG2F93CB9+SQxKbjJplPi79eD2bOdTU3+xw+A6w+3r/X2eoQ50LLnJuyV4qz7YlxeBSFKDHANsqJXd4VkXd3T+z6nRkGKQcZOdBqF9qBAFg6Ju4Yns64yYlOHccW1XABEsBdPv3OAmMd6DwEKIJgUyULUru2fj8fbM1QN9RCl3gkHCTYbJOu3KjZctdwJiH6LxiHrWH+/PKhwNVP7UGNTcpB5/gii2S+O9RwflHEjIPFGSehOGMOaWNAYlNxkfm7EKx1b70JJOpvd9zWseWe0z3DnCYJtZUi67WbvcZHyMzhPNZR+EL791xKdKbc6O9T6KiMIQipRhdLnJI+Z49o/XQorh4SnIKoAsXQ3TcFmYgXii0eUm8RKDVn8mNKnpMMD9z+kVqRXiitINAxfYfhdZ1+F4yE3u1sJhuox6Q450X9L0BxCVoHGpZ3meQSUaa4JTHhEWnoVZ0PGkHW7StGIU75W+VLSzF09Ki/eJu6QJtzvmAr3NVuFXSYObVJshWbzXh+ONGQeIJ6shzH0JwJLS1xaaECJJ0u24yeZwG7vSMXqOI2bm7pWi/iOq4waPWXZswltFg5scfQzkkmw2KqZbpAiaIEM5U78rGO1wKQT9jXtu8sEUQkqoH8pNzaCyY4hT0GhrNRW5t+nJotqPR4+bDAWwqDAYXeiiwQpmsi989bo0g6MYB0/liBd/sOcm66Ko3hmvmLvrRYYhsgwI1Am+boTcazPiBELH/qPHTSa3nUYHLzCIBpV9AyWu+QyCGZZxgD/+zVUDZz3UWvHKFzbcZEYgCQ72XMqkC7abGMSDyqQP4yVjg1vyF97XmK5gpVDXc6A+0OZMvfMEbFU0/KGHdjDCQWXiYa0LHCqUvvwmV3ti0UNNLSTpYZCYbznW+xkG2aCyfKXKZ5x1Mkz6gUVDvA0NWtxket9FHtXFALKK4waVmZJhigEgkiuDQdR9wyvg1fWFJ2SgJlxyDNrn1+WDynyuEtvBFW8eYnh5tbGreP5xbTPd4bnXm5XuIB5UFhmcxWBcBWlTMGFOh6sel7/AIJxh+CxfKAaV5Rgs1wzPPA+kGFhn3sJgvPjqnjlEuQP6QWX5zq1YqMXDTmbhyDDAYXR2/zEGx6MIiVkEGPlEU3swZeB79FOyaSul/ehU9pJOVVbjgpvkq96/7KAy8xRVDuxYRybjRXglAWKtNCp7LPUiLBtstxMuSxJcf5NJAhhXl6LCx1jTZGBy511lb5fwE8XTdaeUsJrWGikeqjYcPdCBAV8uuaROZa/RXVq8YTRWwizVPRF35HIFmPEFOiunw6BR2YsKAvbFFAeqPBnN8LiYiOSNhBNoZM4PsxY2lT2EfQXJBhY9H/4TCDIQkCg5EID08RqjVdlLSwb5MQf7smtkwVsnEO1YwTlqW3gh9OejV9kjuS/vsXzJxnEiQiDZz7DrXwX1tF/mheuketes7CX7PXP/G7l3IBQpcI0bFS8Y2At/UG/LjQU32pW9lk2/1SrhzJflmZaoAqQCBmTlwXhJLH+wr+y5ctMRPi5e+TvctfADoTwKYcNp4ItgdvT7sKTq+DuMZmVPF+Ax5FEHwd08MwMRoiCou1MJJfTa8uoVpxUQlEcy2qBX2TNaFA451o9pTbMpm4KpdwSNQIgON6F1bIFBIs6ZnD/YVvasCIH1Ps8X6wAGA4e8M2KTSecuwpxPkvW5bip76aaAN/JaD8ExmRMEGETHy0C3XCA5uW4EWKT9zmVlr8Dg4G/xHlZzCcQcx1FjANV4c0Q9ua4nLl8MQxW1kspehQF+woCz9ZSnh5v6EvepDoKDeWVNDlTbHA0pyJaispdjgF3VrxuyXpeZbNqK/c7GKlVvhvc5V0Joqu/wPjFY35AsfFbZs9mqTKF+1K/fPQUnI7g2xyIUC6dcju9cF7jcEeYYF0bwBbo9V9lzSemKO/hj+jd4robDBAh5ACwgoC2mRV0X51u+O/FB0asWRpNJZc/+AltUTtsfnKv/s9d9ab6EcqCDwB6xBmZvzLYGIGy25NGrwUvAyZ9YAGpafLLxYsOYxN4qBTB0CDjVlCsJ0MWmS+w3VUZAcbIAty0q+DMiRHJS17v5Royh9akdfIR4yhbWWTyV52VBqySCShzyyl7BHBaZ/W6InPwU3iJtNHaRlEOk+MNsV4SX2lOxDNiVkktTiDTGYcUhbGrQn/PlgckyzsYIMwObMSzWkNrVo64RmpNAdxYevGLuzqezQPh2FuwgQMr3CAzo5jesGR7M1PlaA/VqlXfP59sUk8vFwyHMIPrBafFwwaPYN4iwDB+orB7G/A+0i8GS6nLIgu5hfSfXOStusvwNA6yKjIffHR8z3L1SZDwmz1td1he16eUxrK0pyq5zbRcOIhyyTTp8iYEtE7E4ozAvMKKwD25NBXmOmESfUgLRJfUTDKqONvqYkltwXrT9emOoHZfEgL8wIXtpI0RuuK1LxS+x8W7us0Qh+wi4J6HHG/orwqD8LiNOIvGXcT98xzJgaJO0ykKE/c4/5T3l3f2AgTxjGo1NW1JmPBRPaX2sbE34gy7+TTkHUn+XbAzxMdvqTMWjEbkoN0ubCHkmACJ8NC0EeIHBxkJ5eLkAdt57UgkYaKRzc0Si3JexdVk+Vvtsnw9BQH1nlBaa1KkZ7rUrPEQvUZUoqy4/5Pj5XQj5AE2/ph5hUBUnYxAY7/nYZDKBebL4VReu3gNxkR5Nyhr9Rxhg1u0iERhElvBm8gQ9NXSplGsMzrQLUU7CK9DB32HAIc5gYlyuoxgc+TBycto4Mg9KdW6h6w7uinHP9SsMDpXX06MTuYNXu9i1dYVXcKuRkGGnflAecRnyEQaMFi8CVyGL8EUfHKSSvsq8wcwtYBhy8juG90vHWcHVzFmjOvM7DDK6WtqxVDrYtuiQqtnTgDTefQQWf85VPYxCcboZjj/HwMldVK8Mgq1xjWxBHwdRHwx1qio95eHGf2KpKzCeYIAODc10BG2M4fT09zyLdVr1RQykWxsijabHgGdlQrU3SoopkN88xgC7JINFQIlLBvOpU6uewM9SrjhfiKi7wOATad47oXKIUv3PPgZxZrQZbxX1AKtBXhf5BSFRRDS0nOlLYYXBlYSLhHrYEZZeIrHHQOlHd9xteclZU16GPU9T4nm8kpD2YUt3hGsHpxZi6BYxKsq2mzdSJ3KV2reLAdZez7UUcM00E30qkbc9jJaXyfHUX3Ee5Q1HxrLnD4KawwMMqk5DnIzpuGIErPyU5/l7unvLoRC1/VmCwfSFwYUKcF2k0LNPkw6XI8Hgq14dLQyuhx1z/+b5jNeQ5FPyCzPapWxeJWJ2W/WjB2aK7pnCZbd4tkhrX/FBC6Jr+Tv08dq/v0W7yacBM8RijkFMJUHdHkz1bmiX8AYDM67n8I3UacPW97R3pzi47ovjktfKnq0chDO0SDCAqXEF5Fv7oPUs4fFqbzPYX00hl2tRjOI/NeCzNMRxvfnvCUJgXUw/kbxMBZsUVE9OMMXNtxj067UusmD4oVhPdU9j/vBi9+kLI69+bDHQK0BOoggrBU8HwOAZfLeEQI+qv0poGEdQViazN+CmIhQVbzHmUZZ08NQhNMqVm99lOoXi1F2448MxUEiVW8TEio9snrdSS/y0FJ5hABF0Xlui1uPCsE74ns6XxOYtDGYjAZdOQjjGeOQc7q/zvLY72ieP3zEYamyK7ddTYv1r6/h60GSYnF5JnpgVS8HmemuoiOnVfVOFeYfB1ZMKDfw98uyEf0WOAAsM5tF6XBd0SwHm0YVptp7zLzCA9uRTemPYAPizmc4+ITXERB8wNbmH0HOp4GDFHcI6qInnHeu/cmG8wmAGU645A2d8jmPRi5M2UmMkpSBRreIEA8jxZ3BZ/cuCdSIMbQ9KuB/tOilD4TDlJjef9NV7M5Af2aceR7yDzVGK0iOuWiXeYGBHgj3Ucy1edO0SF4lwvdgpQ50T4IRPZPTULDDgUAVsQS6uiBEvrUCPY9gtBNPJj7PrToeH1xnuWKQBdZPBlMMM3d1zPT0LDPTStysDr80gOw5cN6IxCfLJVci9z+s9D97FNWMIlJMAL+UqdhiAuivNjOobcnO42Zh3hwWkg2OSBw8qn7OVAktNt1ovoZ4SU3ASYYDrnFFpmQYDTjZWadgQdlPcYvOvU7o7UWRnoceAeHhCNm82net8PBEVy0gR6//OqgmGKFgsNcqNAe5AU0dI1B0rZg8sw08GpcKX53VWMcXpvAnTbyeYzPOAQk4a7KweiKJ37g9w78JHXHLmZuo1I2Z91xj+eEXZ+Pi7G8K+i2OeZH4dzbYwuCVMiH0i4hY3Mss3R4WBMYRfhFBrNj6voxVEsYkmf/wOeCEWRRU2qzLu2z93QXMox1IF76uLI5tN9A6CQPB8u+lvmz4vtvU6nJ6HSiBFNSG6v3DoiZnNejs7Fh7MKGUZ8wfRsVVxVF1puGY+qh/jPpsdOi5mMACVgrSbOZMr4iOTIvecFRsciqmopW0qrcFDczi2PTY7DM150q9b68OjM8Q2GLDl5fYdtnsmDkb4Bp+j4cm8tHdB4JCqwk3pfXOGwlERUoI/MAaBY56yLor7tHOY/j8w2JFuKIhJnmndkVg61WHz8af/PQY3g0YeqSh5zyxfoSUT3l2fNspQ9i7bNKo96I8xyFLpuwD5G6OIoBpzibbEkPLgt2q3F0xqQtsHEohEL3oP3V+rTUvLdNhgcC9+BlP+dvvRKVRYLDAehC/nAxbnlI6ecE792A4DeKm/aDoOBVo1BPlhEnjiA9h8pzEOzBNpfwFY9bfq4n10ENTZaf68MhjjiI0VWFdGZRYIammxLakESRT8cD8+d08iJoU2T9VouAPzKT1yODzqaWdJorylh68ed8P4KrrHO0j60sG3GMwyJ0bXDHRXdSw9KO4Hcm+AwOCkA74uHunqQ3FTLQxO7p70bgD5YV8tDNjEYOV6+piUryc9iR4CstWVe199Mm8dDBiewLz2xQflEnk/zzCYohtzg4oWv9QU3ASwxgiy76oE+uqPTbRLB9tLYWa9yyvCb/iVNwnHVuAwWUI/DEOBQcKvm2DvpEsfVIz8kRkYzX3BRgBQysA6HEd1zbGbdcpgVKcMkvisarYmdLhJ4DO9KX47ovwI4dkZh3JR+LxoqKNeCvLoDzlrY8bZFAdkditm8EXUN1/eYaFpAFRb8ti4RGmiZr4jvo5YHhbfxSAQFLh4EFmikApL2V8CVKKewY3y5XAYzN4/4dfahcMOBvZqaBApz/JRKtXIQL2JxQdWwagnRzv/a6wFt9OmO8ZbCB5hoA89hNUoIXq0pk80YWIqZR3FkaCvU3KDQRnYz62M1Fzl8hXfwKU6uyy+baaH5jzAgEYmpVU/rRXJ4ge5YnEPjnjvV0GXXQ/v88Z8lW+jJ7oMjD1ZAyQG3MT1R3iSh9uGeTzCQL3F3FRiBUpWuqNUL26sUmGAMpyLMKA++ujUHx5vMMh+yz8ysvfq4kz3IXUi7su1zh6xDv2hoi2ka2stwAiD1GTZFkFbDNDFAKvDeJMv2WYVo06xVOFfYZByYmUCYTHA5j5ChYT3SjQZrcHAcsZtkWEcCr34gkG0TUyuYcvcZc0jjJGyCK2NgZor+DMGi1p7eKSwE6yE3C9ktZyBUOtpnQCvkGuEGwE7i7fA+vN/AkYGnWJjnZK3MFhKrqzTJXwJv1lYNki3/Jsnr/TBL2FXnPbXG/8JBm6wUNn1wj/DAM3ibHipziu59kSgs1y5VCjLII+XIKCJATdSlRgDU4rk5mUkUSK7D/YShN4CQl/hEH2rc1Lckhx2H01K0Xa3iYdmcDyD4EhPo7bbAt/tjNwUFqNywBNTMExnDFqj0MnOtsA/8ojFDdBKNkXLd13+pW65xJP3oB0Dqm3hFQZd8ZkDgd6bM/e3IyqSpDzpVEb0NXHvgy+UxdUKhFvmGNS5lzAgKk2HIm8liOnslykGzwwB+ymdTBcelBdC922FGHAnZ2nYZ+vQxFd+AEhAoDlTfHsxVzRlVNx6ca8MCqUv6jXRs9+1ZcRmdx3PvkZR8CkGR0qmNtyWUJAF2zb/wgo4z9zmCCz6UvVA0tRor4WpZ+gX30cUuuszA0g9xX2qEYj9FYnh9fhz4AiC2PxQGNzkzFFLFGOimQ/eXWDtEoM8pUESHx35qjx/j0f8ficv9m0CuErgoRawOgJ5/MDEaCJtZgtIF7ipYd7yyqE3uChQ4LlN5VJj3vV/egy2Ey5eUSoM+HdzIlk0Wzn5YDNVwBW1uRP1zlksN0+N/vMHGOChG19/Y3+CaV7pGEMtkoLC79MWdLdtVZwB1gERS4L4alPCU0eeyjOD0VXZZNpJdp9e79rppPbvLD6XiSIEBMjdWugVdishudpWAhWwPdlmOFaod3k3Sal/J1DxVL81S9xHphpO3vTGDLK68PYY8XvDpUumXfIxJnN6NQmfAxOUmGcX+SAku9MYpMAgNpPxyhDG2qlGoI4NMYDwsDCZgNf/k9F5vhtKIKpHcWsGHFE5pHeePOSoVibm7DDgqqx8fcR1nk243QFGxx+/G2kcrDLFUS0FxG1qG86sc67IGvwEUYte3oDzyLd4v8OeSrqrxuAcARL3sLGojfojNvBgL2FOEHL5xDGPTpTh9t3RWwmS2eE9OWYd34DQTvNST8LHQYh6lQIDSUHp4ho3NCVqDHDcAxlFGPocA+Ss22MMrtLC2SiNQxTDp07UFlO4GVxSn317z4lQd4S4wlsFEsTT7bHagLEkJsGgK31pcdzhy7znMgMmGAz3W+hm/u3F4CgFLIbwHLio1gc8ebsXI2ODAWCnHlQYtIPmh90zEgFZRhctKEDU1o2Cqj6YHXFnMdDRfI0Bn2ePj9JMN81gT30VRVymR2ohfWLv4T1yaOZO7DoEcV9hmNvsX8s6xvYZcBgvhB4VmzxpzyLsl0K8k/cwSKDGHgMG5AVqDPhA99tYDLLFPa589zB4FoihSHvyYJm7ZDHdjto7Y2gIyu3jrzCg+57ad7KzRfbZYvJs/W5V25XzjZGIOrH8HYPZ7TAAJumEJYU6nq4bYZo7cwHzp5/JiX7/GoPB6puIvpNIVTPxAbtmEE2Fxji86PcxBqBdTkVBE9uSSVqX10NOmrfn3LVNfz+Dy9nBID6xWDEpQc1H2gI3Nfm4IIs0c0IPAx/DeokygVcYpBFEP86LovMgG4A+XCSMTR/kMvStvdcJFtvy6/bagYb+Rb0TqXKHR1paLRxCtBXSW9c4LIfQMAT8BQZRgrJhZxBHZXUvyl3tu0cV+nFLi6J9ECz/iEExdav6EKT4lGZgOF9vCPWRydmnoJbC5A+/nznWcRboxfJ2l7r5ZftG3flQL/2BWk7hHtLUfNmxyYEhoqkITKwHfq5jB4Nmf+UvxwMXHwZsyezCIbq/cIaAA34KdsQMIRrf9/qh1RClR2rXtHUgib64MlweiSEYDJAlwzbHn8Xax0eDR2pxtlGoXTflySSyuKNZF8N9cxyxuMWZgbTTSbunT/FUywu2UHhscSPAgGprIMIETI+WhmFxp1htSCvkUwRAKqkU9rYQz3joyGq1REbECHAcQ6RRkPhTynKMMujZaDQWAXKyxpmuqu0IUoPBgXuABpGcbmoW1JyFBUPsf4VwUAWqFdyS2yq9/WsUri6OCXDNysljrmvUOm2quebD1dIt+Rsecw7Vxg8zKeOafrNWmx9mAmwMITd3GGFHqbC8tDnRqgRLDOwxJJ4E1aqfeVwHzGtkHOXQVR/HoyBCq+NSoe35+Hk/Xq2FMdGPcxQwR5CcE2r8IFCGTCsD6pDvMMA5KT2IH3mdQ9LDgNgKpmDPOLyJEy7VrRNtjHjyyZoq9HICuztDMqDtjmOO2dtjsJtaejgB/5mATYqLPOvWfnmOYgIOyySpiwFTTQcVBqwwYJPjgZHc8HBLhlYvzN30l34QaDHQ9ByMk7+5N0yBWqHFQZeQpJ6YRn8+5ByVAO8OknEmoeVByDfWcAGaMwz1iW06np07ljj4NcUAJm5DQ16hth3Qqhtg3BULj1tmu/JP3BRWzMFRU1iCqbYbe1qglahDJWR2QuGZr7hPKKgolBhQnL1oLBOplDEM95iXl7GJ23zuZCobixYiYt/56DQqE0zJkUT6hhgmXUhVCVpmQKShqxj2kxZTk+oOsw2ED3QCrqog9zz9E0H9IlWnnFJsfR/BHWFqMo3qGkHoKcOm02UxEa8cxjc4eghxTrSoDfkeDS+iDl6Am8v6uQvMWr/cSjHCWSz3fgtX+j6q1ZBvWwgtB/6dh1vxsHZgHxEzyM47sUV6AyghelgJ+paaiEgs4wdjNECgNFrkQqWMSofVudBk8MM3UwXCm1Wfky7RCwLuv2FyDmTEa7QsYaZFGYWCPJumrVQcWwxAGhZQdIYPWnEZI5kEdPkflc61E9AmaX/WWmZrZ9Snhh/nrCrp8y/2w4VbIQbuhAZEZjn0u38VvYaVsRZLiIefkpcggrnnJ8+he849Bh/jpypFvMpiQs+wpc2BX84/NG3mgQwe51F2WmcpabH/CTAA9QYogmSFqccAAAAASUVORK5CYII=') repeat;
                color: #2D3841;
                font-weight: 100;
                margin: 0;
            }

            table
            {
                width: 100%%;
                color: #BDC8D1;
            }

            table th,
            table td
            {
                padding: 8px;
            }

            table tr:hover td
            {
                background-color: #393939;
            }

            table th
            {
                background-color: #191919;
                text-align: left !important;
            }

            #header
            {
                clear: both;
                padding: 0px 0px 10px 20px;
                height: 150px;
            }

            #wrapper
            {
                margin: auto;
                width: 800px;
                color: #BDC8D1;
            }

            #wrapper h1
            {
                background-color: #191919;
                color: white;
                letter-spacing: 2px;
                margin: 0px;
                padding: 8px 15px;
                font-family: 'Lucida Grande',Calibri,Verdana,sans-serif;
                font-weight: 100;
            }

            .page-content {
                padding: 20px;
                background-color:#232323;
            }
            </style>
        </head>
        <body>
        <div id="wrapper">
        <h1>PyMT Pep8 checker</h1>
        <div class="page-content">
        <p>Generated on %s</p>
        <table>''' % (time.strftime('%c'))

    for dirpath, dirnames, filenames in os.walk(basedir):
        # exclude libs
        if '/lib' in dirpath:
            continue
        for filename in filenames:
            if filename.split('.')[-1] != 'py':
                continue
            complete_filename = os.path.join(dirpath, filename)

            if htmlmode:
                print '<tr><th colspan="2">%s</td></tr>' % complete_filename
            checker = PymtChecker(complete_filename)
            checker.check_all()

    if htmlmode:
        print '</div></div></table></body></html>'

########NEW FILE########
__FILENAME__ = widgettester
'''
You can use this file to test out your widgets or do live coding.
Click the grey box at the top left, this will popup a keyboard. (you can hit the tab key also)
You can either use the displayed keyboard or your physical keyboard to type.
You can now add widgets by using the widgets dictionary :
    widgets['mywidget'] = MyWidget()
    w.add_widget(widgets['mywidget'])
Now you can interact with your widget :
    widgets['mywidget'].pos = (400,300)

There is also a quick way to add a widget, use the add function:
    add('slider', MTSlider())

Enjoy !

'''
from pymt import *

w = MTWindow()

widgets = {}
history = []
count = -1

def on_key_press(symbol, modifiers):
    global count
    if symbol == 65362: #up arrow
        if not keyb.is_active_input:
           keyb.show_keyboard()
        count = count + 1
        if count == len(history):
            count = len(history) - 1
        keyb.label = list(reversed(history))[count]

    if symbol == 65364: #down arrow
        if not keyb.is_active_input:
           keyb.show_keyboard()
        if count != -1:
            count = count - 1
        if count == -1:
            count = -1
            keyb.label = ''
            return
        keyb.label = list(reversed(history))[count]



    if symbol == 65289: #tab
        if not keyb.is_active_input:
           keyb.show_keyboard()
        else: keyb.hide_keyboard()
w.push_handlers(on_key_press = on_key_press)

keyb = MTTextInput(size = (35,30), font_size = 16, pos = (0, w.height - 30))

def add(name, widget):
    widgets[name] = widget
    w.add_widget(widget)

@keyb.event
def on_text_validate():
    global count
    count = -1
    try:
        exec keyb.label
    except Exception, e:
        print 'Error', e
        p = MTModalPopup(title='Exception occured', content=str(e))
        w.add_widget(p)
    history.append(keyb.label)
    keyb.label = ''
    keyb.size = (35,30)
    keyb.pos = (0, w.height - 30)

w.add_widget(keyb)

runTouchApp()

########NEW FILE########
