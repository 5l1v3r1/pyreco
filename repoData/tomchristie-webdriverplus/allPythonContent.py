__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Asset Platform documentation build configuration file, created by
# sphinx-quickstart on Fri Nov 19 20:24:09 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

PROJECT_DIR = os.path.dirname(os.path.dirname(__file__))

sys.path.insert(0, PROJECT_DIR)


# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

todo_include_todos = True

# Add any paths that contain templates here, relative to this directory.
templates_path = ['templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'webdriverplus'
copyright = '2011, Tom Christie'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

autodoc_member_order='bysource'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = "WebDriver Plus"

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = []

analytics_code= "UA-27795084-1"
# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
#htmlhelp_basename = ''


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
#latex_documents = [
#  (),
#]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True

# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
#man_pages = [
#    ()
#]

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
# coding: utf-8

import sys
import unittest
import warnings

import webdriverplus
from selenium.webdriver.common.keys import Keys

# WebElements as set

# close_on_shutdown
# default_selector
# base_url

# drag & drop

# find_all().find() is broken
# No such element exceptions need to be cleaner

run_slow_tests = '--all' in sys.argv
browser = 'firefox'

# Support unicode literals for all versions
if sys.version < '3':
    import codecs

    def u(x):
        return codecs.unicode_escape_decode(x)[0]
else:
    def u(x):
        return x


class WebDriverPlusTests(unittest.TestCase):
    extra_webdriver_kwargs = {}

    def setUp(self):
        super(WebDriverPlusTests, self).setUp()
        self.driver = webdriverplus.WebDriver(browser, reuse_browser=True,
                                              **self.extra_webdriver_kwargs)

    def tearDown(self):
        self.driver.quit()


if run_slow_tests:
    class BrowserPoolingTests(unittest.TestCase):
        # Note: We don't inherit from WebDriverPlusTests as we don't want the
        #       default reuse browser behaviour for theses tests.

        # TODO: Similar tests, but with multiple windows open.

        def setUp(self):
            webdriverplus.WebDriver._pool.pop('firefox', None)

        def tearDown(self):
            for browser, signature in webdriverplus.WebDriver._pool.values():
                browser.quit(force=True)

        def test_reuse_browser_set(self):
            browser = webdriverplus.WebDriver('firefox', reuse_browser=True)
            browser.quit()
            other = webdriverplus.WebDriver('firefox', reuse_browser=True)
            self.assertEqual(browser, other)

        def test_reuse_browser_unset(self):
            browser = webdriverplus.WebDriver('firefox')
            browser.quit()
            other = webdriverplus.WebDriver('firefox')
            self.assertNotEqual(browser, other)


class DriverTests(WebDriverPlusTests):
    def test_open(self):
        page_text = 'abc'
        self.driver.open(page_text)
        self.assertEqual(self.driver.page_text,  page_text)

    def test_find(self):
        self.driver.open(u('<h1>123</h1><h2>☃</h2><h3>789</h3>'))
        self.assertEqual(self.driver.find('h2').text, u('☃'))

    def test_find_wait(self):
        self.driver.open('<h1 id="t">123</h1>')
        js = """
        setTimeout(
          function () {
            // create a new div element
            // and give it some content
            var newDiv = document.createElement("div");
            var newContent = document.createTextNode("Hello");

            newDiv.appendChild(newContent); //add the text node to the newly created div.

            // add the newly created element and it's content into the DOM
            h1 = document.getElementById("t");
            document.body.insertBefore(newDiv, h1);
          },
          1000
          )
        """
        self.driver.execute_script(js)
        self.assertEqual(self.driver.find('div', wait=2).text, 'Hello')

    def test_unicode(self):
        self.driver.open('<h1>123</h1><h2>456</h2><h3>789</h3>')
        self.assertEqual(self.driver.find('h2').text, '456')

    def test_iframe(self):
        self.driver.open('<p>Test iframe</p><iframe></iframe>')
        self.assertEqual(self.driver.find('p').text, 'Test iframe')
        self.driver.switch_to_frame(self.driver.find('iframe'))
        self.assertFalse(self.driver.find('p'))

    def test_wait_for(self):
        self.driver.open('<h1 id="t" style="display:none">123</h1>')
        self.assertFalse(self.driver.find('#t').is_displayed())
        # For backwards compatibility purpose
        self.assertFalse(self.driver.find('#t').is_displayed)
        self.driver.execute_script(
            'setTimeout(function () { document.getElementById("t").style.display="block"}, 1000)')
        self.driver.wait_for('#t', wait=2)
        self.assertTrue(self.driver.find('#t').is_displayed())
        # For backwards compatibility purpose
        self.assertTrue(self.driver.find('#t').is_displayed)

    def test_wait_for2(self):
        self.driver.open('<h1 id="t" style="display:none">123</h1>')
        self.assertFalse(self.driver.find('#t').is_displayed())
        # For backwards compatibility purpose
        self.assertFalse(self.driver.find('#t').is_displayed)
        self.driver.execute_script(
            'setTimeout(function () { document.getElementById("t").style.display="block"}, 1000)')
        self.driver.wait_for(text='123', wait=2)
        el = self.driver.find(text='123')
        self.assertTrue(el.is_displayed())
        # For backwards compatibility purpose
        self.assertTrue(el.is_displayed)
        self.assertEqual(el.text, '123')

    def test_wait_for3(self):
        self.driver.open('<h1 id="t" style="display:none">123</h1>')
        self.assertFalse(self.driver.find('#t').is_displayed())
        # For backwards compatibility purpose
        self.assertFalse(self.driver.find('#t').is_displayed)
        self.driver.execute_script(
            'setTimeout(function () { document.getElementById("t").style.display="block"}, 1000)')

        self.driver.wait_for('h1', text='123', wait=2)
        el = self.driver.find('h1', text='123', wait=2)
        self.assertTrue(el.is_displayed())
        # For backwards compatibility purpose
        self.assertTrue(el.is_displayed)
        self.assertEqual(el.text, '123')


class SelectorTests(WebDriverPlusTests):
    def setUp(self):
        super(SelectorTests, self).setUp()
        snippet = """<html>
                         <h1>header</h1>
                         <ul id="mylist">
                             <li>one</li>
                             <li>two</li>
                             <li class="selected">three</li>
                             <li><a href="#">four</a></li>
                             <li><strong>hi</strong>five</li>
                             <li>six<strong>hi</strong></li>
                             <li><strong>seven</strong></li>
                             <span>one</span>
                         </ul>
                         <form>
                             <label for="username">Username:</label>
                             <input type="text" name="username" value="lucy"/>
                             <label for="password">Password:</label>
                             <input type="password" name="password" />
                             <select>
                                <option value='1'>1</option>
                                <option value='2'>2</option>
                             </select>
                         </form>
                         <form id="checkboxlist">
                             <input type="checkbox" value="red" />
                             <input type="checkbox" value="green" />
                             <input type="checkbox" value="blue" checked=yes />
                         </form>
                     </html>"""
        self.driver.open(snippet)

    def test_multiple_selectors(self):
        node = self.driver.find('li', text='one')
        self.assertEqual(node.html, '<li>one</li>')

    def test_nonexistant_multiple_selectors(self):
        """If a combination of selector doesn't match one or more
        elements, none should be returned."""
        nodes = self.driver.find('li', text='fubar')
        self.assertFalse(nodes)

    def test_multiple_named_selectors(self):
        node = self.driver.find(tag_name='li', text='one')
        self.assertEqual(node.html, '<li>one</li>')

    def test_nonexistant_multiple_named_selectors(self):
        """If a combination of named selector doesn't match one or more
        elements, none should be returned."""
        nodes = self.driver.find(tag_name='li', text='fubar')
        self.assertFalse(nodes)

    def test_id(self):
        node = self.driver.find(id='mylist')
        self.assertEqual(node.tag_name, 'ul')

    def test_class_name(self):
        node = self.driver.find(class_name='selected')
        self.assertEqual(node.text, 'three')

    def test_tag_name(self):
        node = self.driver.find(tag_name='h1')
        self.assertEqual(node.text, 'header')

    def test_name(self):
        node = self.driver.find(name='username')
        self.assertEqual(node.tag_name, 'input')
        self.assertEqual(node.value, 'lucy')

    def test_css(self):
        node = self.driver.find(css='ul li.selected')
        self.assertEqual(node.text, 'three')

    def test_xpath(self):
        node = self.driver.find(xpath='//ul/li[@class="selected"]')
        self.assertEqual(node.text, 'three')

    def test_link_text(self):
        node = self.driver.find(link_text='four')
        self.assertEqual(node.tag_name, 'a')
        self.assertEqual(node.text, 'four')

    def test_link_text_contains(self):
        node = self.driver.find(link_text_contains='ou')
        self.assertEqual(node.tag_name, 'a')
        self.assertEqual(node.text, 'four')

    def test_text(self):
        self.assertEqual(self.driver.find(text='one').index, 0)
        self.assertEqual(self.driver.find(text='two').index, 1)
        self.assertEqual(self.driver.find(text='three').index, 2)

    def test_text_contains(self):
        self.assertEqual(self.driver.find('li', text_contains='ne').index, 0)
        self.assertEqual(self.driver.find('li', text_contains='tw').index, 1)
        self.assertEqual(self.driver.find('li', text_contains='hre').index, 2)

        self.assertEqual(len(self.driver.find(text_contains='ne')), 2)
        self.assertEqual(len(self.driver.find(text_contains='tw')), 1)
        self.assertEqual(len(self.driver.find(text_contains='hre')), 1)

        self.assertEqual(len(self.driver.find('li', text_contains='ive')), 1)
        self.assertEqual(len(self.driver.find('li', text_contains='ix')), 1)
        self.assertEqual(len(self.driver.find('li', text_contains='eve')), 0)

    #def test_label(self):
    #    node = self.driver.find(label='Password:')
    #    expected = '<input type="password" name="password" />'
    #    self.assertEqual(node.html, expected)

    #def test_label_contains(self):
    #    node = self.driver.find(label_contains='Password')
    #    expected = '<input type="password" name="password" />'
    #    self.assertEqual(node.html, expected)

    def test_attribute(self):
        node = self.driver.find(attribute='checked')
        self.assertEqual(node.value, 'blue')

    def test_attribute_value(self):
        node = self.driver.find(attribute_value=('checked', 'yes'))
        self.assertEqual(node.value, 'blue')

    def test_value(self):
        node = self.driver.find(value='blue')
        self.assertEqual(node.tag_name, 'input')
        self.assertEqual(node.type, 'checkbox')
        self.assertEqual(node.value, 'blue')

    def test_value_setter(self):
        node = self.driver.find('input[type="text"]')
        self.assertEqual(node.value, 'lucy')
        node.value = 'lucyyy'
        node = self.driver.find('input[type="text"]')
        self.assertEqual(node.value, 'lucyyy')

    def test_value_setter_select(self):
        node = self.driver.find('select')
        node.value = '2'
        node = self.driver.find('select')
        self.assertEqual(node.value, '2')

    def test_type(self):
        node = self.driver.find(type='checkbox')
        self.assertEqual(node.value, 'red')

    def test_checked(self):
        elem = self.driver.find(id='checkboxlist')
        self.assertEqual(len(elem.find(checked=True)), 1)
        self.assertEqual(len(elem.find(checked=False)), 2)

        # TODO: checked=True, checked=False, selected=True, selected=False


class TraversalTests(WebDriverPlusTests):
    def setUp(self):
        super(TraversalTests, self).setUp()
        snippet = """<html>
                         <ul>
                             <li>1</li>
                             <li>2</li>
                             <li class="selected">3</li>
                             <li>4</li>
                             <li><strong>5</strong></li>
                         </ul>
                     </html>"""
        self.driver.open(snippet)

    def test_indexing(self):
        elem = self.driver.find('ul').children()[0]
        self.assertEqual(elem.html, '<li>1</li>')

    def test_slicing(self):
        elems = self.driver.find('ul').children()[0:-1]
        expected = [
            '<li>1</li>',
            '<li>2</li>',
            '<li class="selected">3</li>',
            '<li>4</li>'
        ]
        self.assertEqual([elem.html for elem in elems], expected)

    def test_children(self):
        nodes = self.driver.find('ul').children()
        text = [node.text for node in nodes]
        self.assertEqual(text, ['1', '2', '3', '4', '5'])

    def test_filtering_traversal(self):
        nodes = self.driver.find('ul').children('.selected')
        text = [node.text for node in nodes]
        self.assertEqual(text, ['3'])

    def test_parent(self):
        node = self.driver.find('.selected').parent()
        self.assertEqual(node.tag_name, 'ul')

    def test_descendants(self):
        nodes = self.driver.find('ul').descendants()
        tag_names = [node.tag_name for node in nodes]
        self.assertEqual(tag_names, ['li', 'li', 'li', 'li', 'li', 'strong'])

    def test_ancestors(self):
        nodes = self.driver.find(class_name='selected').ancestors()
        tag_names = [node.tag_name for node in nodes]
        self.assertEqual(tag_names, ['html', 'body', 'ul'])

    def test_next(self):
        node = self.driver.find('.selected').next()
        self.assertEqual(node.text, '4')

    def test_prev(self):
        node = self.driver.find('.selected').prev()
        self.assertEqual(node.text, '2')

    def test_next_all(self):
        nodes = self.driver.find('.selected').next_all()
        text = [node.text for node in nodes]
        self.assertEqual(text, ['4', '5'])

    def test_prev_all(self):
        nodes = self.driver.find('.selected').prev_all()
        text = [node.text for node in nodes]
        self.assertEqual(text, ['1', '2'])

    def test_siblings(self):
        nodes = self.driver.find('.selected').siblings()
        text = [node.text for node in nodes]
        self.assertEqual(text, ['1', '2', '4', '5'])


class FilteringTests(WebDriverPlusTests):
    def setUp(self):
        super(FilteringTests, self).setUp()
        snippet = """<ul>
                         <li>1</li>
                         <li>2</li>
                         <li class="selected">3</li>
                         <li>4</li>
                         <li class="selected">5</li>
                     </ul>"""
        self.driver.open(snippet)

    def test_filter(self):
        nodes = self.driver.find('li').filter('.selected')
        self.assertEqual([node.text for node in nodes], ['3', '5'])

    def test_exclude(self):
        nodes = self.driver.find('li').exclude('.selected')
        self.assertEqual([node.text for node in nodes], ['1', '2', '4'])


class ShortcutTests(WebDriverPlusTests):
    def setUp(self):
        super(ShortcutTests, self).setUp()
        snippet = """<ul>
                         <li>1</li>
                         <li>2</li>
                         <li class="selected">3</li>
                         <li>4</li>
                         <li>5</li>
                     </ul>"""
        self.driver.open(snippet)

    def test_index(self):
        node = self.driver.find('.selected')
        self.assertEqual(node.index, 2)

    def test_html(self):
        node = self.driver.find('.selected')
        self.assertEqual(node.html, '<li class="selected">3</li>')

    def test_inner_html(self):
        node = self.driver.find('.selected')
        self.assertEqual(node.inner_html, '3')

    def test_has_class(self):
        node = self.driver.find(css='ul li.selected')
        self.assertTrue(node.has_class('selected'))

    def test_set_has_class(self):
        nodes = self.driver.find(css='ul li')
        self.assertTrue(nodes.has_class('selected'))

    def test_attr(self):
        node = self.driver.find(css='ul li.selected')
        self.assertEqual(node.attr('class'), 'selected')


class InspectionTests(WebDriverPlusTests):
    def setUp(self):
        super(InspectionTests, self).setUp()
        snippet = """<html>
                         <head>
                             <style type="text/css">
                                 .selected {color: red}
                                 img {width: 100px; height: 50px;}
                             </style>
                         </head>
                         <body>
                             <img src='#' width='100px' height='50px'>
                             <ul style="color: blue">
                                 <li>1</li>
                                 <li>2</li>
                                 <li class="selected">3</li>
                                 <li>4</li>
                                 <li>5</li>
                             </ul>
                         </body>
                     </html>"""
        self.driver.open(snippet)

    def test_get_style_inline(self):
        elem = self.driver.find('ul')
        self.assertTrue(elem.style.color in ('#0000ff', 'blue', 'rgb(0, 0, 255)', 'rgba(0, 0, 255, 1)'))
        self.assertTrue(elem.css('color') in ('#0000ff', 'blue', 'rgb(0, 0, 255)', 'rgba(0, 0, 255, 1)'))

    def test_get_style_css(self):
        elem = self.driver.find('.selected')
        self.assertTrue(elem.style.color, ('#ff0000', 'red', 'rgb(255, 0, 0)', 'rgba(255 ,0, 0, 1)'))
        self.assertTrue(elem.css('color'), ('#ff0000', 'red', 'rgb(255, 0, 0)', 'rgba(255 ,0, 0, 1)'))

    def test_set_style(self):
        elem = self.driver.find('.selected')
        elem.style.color = 'green'
        self.assertTrue(elem.style.color in ('#008000', 'green', 'rgb(0, 128, 0)', 'rgba(0, 128, 0, 1)'))
        self.assertTrue(elem.css('color') in ('#008000', 'green', 'rgb(0, 128, 0)', 'rgba(0, 128, 0, 1)'))

    def test_set_style(self):
        elem = self.driver.find('.selected')
        elem.css('color', 'blue')
        self.assertTrue(elem.style.color in ('#0000ff', 'blue', 'rgb(0, 0, 255)', 'rgba(0, 0, 255, 1)'))
        self.assertTrue(elem.css('color') in ('#0000ff', 'blue', 'rgb(0, 0, 255)', 'rgba(0, 0, 255, 1)'))

    def test_size(self):
        elem = self.driver.find('img')
        self.assertEqual(elem.size.width, 100)
        self.assertEqual(elem.css('width'), '100px')
        self.assertEqual(elem.size.height, 50)
        self.assertEqual(elem.css('height'), '50px')

    def test_size_unpacked(self):
        (width, height) = self.driver.find('img').size
        self.assertEqual(width, 100)
        self.assertEqual(height, 50)

    def test_attributes(self):
        elem = self.driver.find('img')
        self.assertEqual(elem.attributes,
                          {'width': '100px', 'height': '50px', 'src': '#'})
        self.assertEqual(set(elem.attributes.keys()),
                          set(['width', 'height', 'src']))
        self.assertEqual(set(elem.attributes.values()),
                          set(['100px', '50px', '#']))

    def test_get_attribute(self):
        elem = self.driver.find('img')
        self.assertEqual(elem.attributes['width'], '100px')

    def test_set_attribute(self):
        elem = self.driver.find('img')
        elem.attributes['width'] = '33px'
        self.assertEqual(elem.attributes['width'], '33px')

    def test_del_attribute(self):
        elem = self.driver.find('img')
        del elem.attributes['src']
        self.assertEqual(elem.attributes,
                          {'width': '100px', 'height': '50px'})


class FormInspectionTests(WebDriverPlusTests):
    def setUp(self):
        super(FormInspectionTests, self).setUp()
        snippet = """<html>
                         <form>
                             <select multiple>
                                 <option selected>Walk</option>
                                 <option>Cycle</option>
                                 <option>Drive</option>
                             </select>
                             <fieldset>
                                 <input type="checkbox" value="peanuts" />
                                 I like peanuts
                             </fieldset>
                             <fieldset>
                                 <input type="checkbox" value="jam" checked />
                                 I like jam
                             </fieldset>
                         </form>
                     </html>"""
        self.driver.open(snippet)

    def test_is_selected(self):
        elem = self.driver.find('form')
        self.assertTrue(elem.find(text='Walk').is_selected())
        self.assertFalse(elem.find(text='Cycle').is_selected())
        self.assertFalse(elem.find(text='Drive').is_selected())

        # Backwards compat test
        self.assertTrue(elem.find(text='Walk').is_selected)
        self.assertFalse(elem.find(text='Cycle').is_selected)
        self.assertFalse(elem.find(text='Drive').is_selected)

    def test_is_checked(self):
        elem = self.driver.find('form')
        self.assertFalse(elem.find(value='peanuts').is_checked())
        self.assertTrue(elem.find(value='jam').is_checked())

        # Backwards compat test
        self.assertFalse(elem.find(value='peanuts').is_checked)
        self.assertTrue(elem.find(value='jam').is_checked)

    def test_deselect_option(self):
        elem = self.driver.find('form select')
        elem.deselect_option(text='Walk')
        self.assertFalse(elem.attr('value'))
        self.assertFalse(elem.find(text='Walk').is_selected())

        # Backwards compat test
        self.assertFalse(elem.find(text='Walk').is_selected)

    def test_select_option(self):
        elem = self.driver.find('form select')
        elem.select_option(text='Cycle')
        self.assertTrue(elem.find(text='Cycle').is_selected())

        # Backwards compat test
        self.assertTrue(elem.find(text='Cycle').is_selected)


class ValueTests(WebDriverPlusTests):
    def setUp(self):
        super(ValueTests, self).setUp()
        snippet = """<form>
                         <input type="text" name="username" value="mike">
                     </form>"""
        self.driver.open(snippet)

    def test_get_value(self):
        pass

    def test_set_value(self):
        pass


class InputTests(WebDriverPlusTests):
    def setUp(self):
        super(InputTests, self).setUp()
        snippet = """<form>
                         <input type="text" name="username" value="mike">
                     </form>"""
        self.driver.open(snippet)

    def test_send_keys(self):
        elem = self.driver.find('input')
        elem.send_keys("hello")

    def test_type_keys(self):
        elem = self.driver.find('input')
        elem.type_keys("hello")


class SetTests(WebDriverPlusTests):
    def setUp(self):
        super(SetTests, self).setUp()
        snippet = """<ul>
                         <li>1</li>
                         <li>2</li>
                         <li>3</li>
                         <li>4</li>
                         <li>5</li>
                     </ul>
                     <ul>
                         <li>a</li>
                         <li>b</li>
                         <li>c</li>
                     </ul>"""
        self.driver.open(snippet)

    def test_set_uniqueness(self):
        nodes = self.driver.find('li')
        self.assertEqual(len(nodes), 8)
        self.assertEqual(len(nodes.parent()), 2)


class ActionTests(WebDriverPlusTests):
    # TODO: Urg.  Refactor these
    def test_click(self):
        js = "document.getElementById('msg').innerHTML = 'click'"
        snippet = "<div id='msg'></div><a onclick=\"%s\">here</a>" % js
        self.driver.open(snippet).find('a').click()
        self.assertEqual(self.driver.find(id='msg').text, 'click')

    def test_double_click(self):
        js = "document.getElementById('msg').innerHTML = 'double click'"
        snippet = "<div id='msg'></div><a onDblclick=\"%s\">here</a>" % js
        self.driver.open(snippet).find('a').double_click()
        self.assertEqual(self.driver.find(id='msg').text, 'double click')

    def test_context_click(self):
        js = "document.getElementById('msg').innerHTML = event.button;"
        snippet = "<div id='msg'></div><a oncontextmenu=\"%s\">here</a>" % js
        self.driver.open(snippet).find('a').context_click()
        self.assertEqual(self.driver.find(id='msg').text, '2')

        # context menu stays open, so close it
        self.driver.find('body').send_keys(Keys.ESCAPE)

    def test_click_and_hold(self):
        js = "document.getElementById('msg').innerHTML = 'mouse down'"
        snippet = "<div id='msg'></div><a onMouseDown=\"%s\">here</a>" % js
        self.driver.open(snippet).find('a').click_and_hold()
        self.assertEqual(self.driver.find(id='msg').text, 'mouse down')

    def test_release(self):
        js = "document.getElementById('msg').innerHTML = 'mouse up'"
        snippet = "<div id='msg'></div><a onMouseUp=\"%s\">here</a>" % js
        elem = self.driver.open(snippet).find('a')
        elem.click_and_hold()
        self.assertEqual(self.driver.find(id='msg').text, '')
        elem.release()
        self.assertEqual(self.driver.find(id='msg').text, 'mouse up')

    def test_move_to(self):
        js = "document.getElementById('msg').innerHTML = 'mouse over'"
        snippet = "<div id='msg'></div><a onMouseOver=\"%s\">here</a>" % js
        self.driver.open(snippet).find('a').move_to()
        self.assertEqual(self.driver.find(id='msg').text, 'mouse over')

    def test_move_to_and_click(self):
        js = "document.getElementById('msg').innerHTML = 'click'"
        snippet = "<div id='msg'></div><a onClick=\"%s\">here</a>" % js
        self.driver.open(snippet).find('a').move_to_and_click()
        self.assertEqual(self.driver.find(id='msg').text, 'click')

    def test_check_unchecked(self):
        snippet = "<form><input type='checkbox' id='cbx'> Checkbox</form>"
        self.driver.open(snippet).find('#cbx').check()
        self.assertEqual(self.driver.find('#cbx').get_attribute('checked'), 'true')

    def test_check_checked(self):
        snippet = "<form><input type='checkbox' id='cbx' checked='checked'> Checkbox</form>"
        self.driver.open(snippet).find('#cbx').check()
        self.assertEqual(self.driver.find('#cbx').get_attribute('checked'), 'true')

    def test_uncheck_unchecked(self):
        snippet = "<form><input type='checkbox' id='cbx'> Checkbox</form>"
        self.driver.open(snippet).find('#cbx').uncheck()
        self.assertEqual(self.driver.find('#cbx').get_attribute('checked'), None)

    def test_uncheck_checked(self):
        snippet = "<form><input type='checkbox' id='cbx' checked='checked'> Checkbox</form>"
        self.driver.open(snippet).find('#cbx').uncheck()
        self.assertEqual(self.driver.find('#cbx').get_attribute('checked'), None)

    #def test_submit(self):
    #    js = "document.getElementById('msg').innerHTML = 'submit'"
    #    snippet = "<div id='msg'></div><form onSubmit=\"%s\"><input></input></form>" % js
    #    self.driver.open(snippet).find('input').submit()
    #    self.assertEqual(self.driver.find(id='msg').text, 'submit')

    #def test_submit(self):
    #    snippet = "<form onSubmit=\"alert('submit')\"><input></input></form>"
    #    self.driver.open(snippet).find('input').submit()
    #    self.assertEqual(self.driver.alert.text, 'submit')


WAIT_SNIPPET = """<html>
    <head>
        <script type="text/javascript">
addTextLater = function() {
    setTimeout(addText, 1000);
}
addText = function () {
    var txtNode = document.createTextNode("Hello World!");
    var p = document.getElementById("mypara");
    p.appendChild(txtNode);
}
        </script>
    </head>
    <body onload="addTextLater();">
        <p id="mypara"></p>
    </body>
</html>"""


class WaitTests(WebDriverPlusTests):
    extra_webdriver_kwargs = {'wait': 10}

    def setUp(self):
        super(WaitTests, self).setUp()
        snippet = WAIT_SNIPPET
        self.driver.open(snippet)

    def test_element_added_after_load_found(self):
        nodes = self.driver.find('p', text_contains='Hello World')
        self.assertEqual(len(nodes), 1)


class NoWaitTests(WebDriverPlusTests):
    def setUp(self):
        super(NoWaitTests, self).setUp()
        snippet = WAIT_SNIPPET
        self.driver.open(snippet)

    def test_element_added_after_load_not_found(self):
        nodes = self.driver.find('p', text_contains='Hello World')
        self.assertEqual(len(nodes), 0)


class ClassWithDeprecations(object):
    @webdriverplus.deprecation.deprecated_property
    def true(self):
        return True

    @webdriverplus.deprecation.deprecated_property
    def false(self):
        return False


class DeprecationWarningTests(unittest.TestCase):
    def setUp(self):
        webdriverplus.deprecation.WARN_ONLY = True

    def test_calling(self):
        instance = ClassWithDeprecations()
        with warnings.catch_warnings(record=True) as caught:
            self.assertTrue(instance.true())
            self.assertEqual(instance.true(), True)
            self.assertFalse(instance.false())
            self.assertEqual(instance.false(), False)
        self.assertEqual(len(caught), 0)

    def test_eq_prop(self):
        instance = ClassWithDeprecations()
        with warnings.catch_warnings(record=True) as caught:
            self.assertEqual(instance.false, False)
        self.assertEqual(len(caught), 1)

    def test_bool_prop(self):
        instance = ClassWithDeprecations()
        with warnings.catch_warnings(record=True) as caught:
            self.assertTrue(instance.true)
        self.assertEqual(len(caught), 1)


class DeprecationErrorTests(unittest.TestCase):
    def setUp(self):
        webdriverplus.deprecation.WARN_ONLY = False

    def test_calling(self):
        instance = ClassWithDeprecations()
        self.assertTrue(instance.true())
        self.assertEqual(instance.true(), True)
        self.assertFalse(instance.false())
        self.assertEqual(instance.false(), False)

    def test_eq_prop(self):
        instance = ClassWithDeprecations()
        self.assertRaises(
            webdriverplus.deprecation.DeprecatedPropertyError,
            lambda: not instance.false
        )

    def test_bool_prop(self):
        instance = ClassWithDeprecations()
        self.assertRaises(
            webdriverplus.deprecation.DeprecatedPropertyError,
            lambda: instance.true == True
        )
        self.assertRaises(
            webdriverplus.deprecation.DeprecatedPropertyError,
            lambda: instance.true != False
        )


if __name__ == '__main__':
    try:
        sys.argv.remove('--all')
    except:
        pass

    try:
        idx = sys.argv.index('--browser')
        browser = sys.argv[idx + 1]
        sys.argv.pop(idx)
        sys.argv.pop(idx)
    except:
        pass

    # If --headless argument is given, run headless in virtual session
    # using Xvfb or Xvnc.
    try:
        sys.argv.remove('--headless')
    except ValueError:
        pass
    else:
        try:
            from pyvirtualdisplay import Display
            from easyprocess import EasyProcessCheckInstalledError
        except ImportError:
            print('Error: --headless mode requires pyvirtualdisplay')
            sys.exit(2)
        try:
            display = Display(visible=0, size=(800, 600))
        except EasyProcessCheckInstalledError:
            print('Error: Could not initialize virtual display. ',
                  'Is either Xvfb or Xvnc installed?')
            sys.exit(2)
        print('Running tests in headless mode.')
        display.start()

    unittest.main()

    if 'display' in locals():
        display.stop()

########NEW FILE########
__FILENAME__ = deprecation
""" Descriptor to provide an upgrade path for promoting property methods
back to regular methods """

import warnings

WARN_ONLY = True

message = """This property has been replaced by a method in order to conform
with the Selenium API. Please use %s() instead
"""


class DeprecatedPropertyError(Exception):
    pass


class DeprecatedProperty(object):
    def __init__(self, instance, method):

        self.instance = instance
        self.method = method

    def call(self):
        return self.method(self.instance)

    def call_and_notify(self):
        method = self.method
        method_name = method.__name__
        if WARN_ONLY:
            warnings.warn(message % method_name)
            return self.call()
        else:
            raise DeprecatedPropertyError(message % method_name)

    def __call__(self):
        return self.call()

    def __nonzero__(self):
        value = self.call_and_notify()
        return bool(value)

    # Python3 support
    def __bool__(self):
        return self.__nonzero__()

    def __eq__(self, other):
        value = self.call_and_notify()
        return value == other

    def __ne__(self, other):
        return not (self == other)


class DeprecatedPropertyDescriptor(object):
    def __init__(self, method):
        self.method = method

    def __get__(self, instance, owner):
        return DeprecatedProperty(instance, self.method)


# to conform to @property lowercase naming convention
deprecated_property = DeprecatedPropertyDescriptor
########NEW FILE########
__FILENAME__ = orderedset
## {{{ http://code.activestate.com/recipes/576694/ (r7)
import collections

KEY, PREV, NEXT = range(3)


class OrderedSet(collections.MutableSet):
    def __init__(self, iterable=None):
        self.end = end = []
        end += [None, end, end]         # sentinel node for doubly linked list
        self.map = {}                   # key --> [key, prev, next]
        if iterable is not None:
            self |= iterable

    def __len__(self):
        return len(self.map)

    def __contains__(self, key):
        return key in self.map

    @property
    def _first(self):
        return self.end[NEXT][KEY]

    def add(self, key):
        if key not in self.map:
            end = self.end
            curr = end[PREV]
            curr[NEXT] = end[PREV] = self.map[key] = [key, curr, end]

    def discard(self, key):
        if key in self.map:
            key, prev, next = self.map.pop(key)
            prev[NEXT] = next
            next[PREV] = prev

    def __iter__(self):
        end = self.end
        curr = end[NEXT]
        while curr is not end:
            yield curr[KEY]
            curr = curr[NEXT]

    def __reversed__(self):
        end = self.end
        curr = end[PREV]
        while curr is not end:
            yield curr[KEY]
            curr = curr[PREV]

    def pop(self, last=True):
        if not self:
            raise KeyError('set is empty')
        key = next(reversed(self)) if last else next(iter(self))
        self.discard(key)
        return key

    def __repr__(self):
        if not self:
            return '%s()' % (self.__class__.__name__,)
        return '%s(%r)' % (self.__class__.__name__, list(self))

    def __eq__(self, other):
        if isinstance(other, OrderedSet):
            return len(self) == len(other) and list(self) == list(other)
        return set(self) == set(other)

    def __del__(self):
        super(OrderedSet, self).clear()       # remove circular references


if __name__ == '__main__':
    print(OrderedSet('abracadaba'))
    print(OrderedSet('simsalabim'))

########NEW FILE########
__FILENAME__ = selectors
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.expected_conditions import visibility_of_element_located, presence_of_element_located

def xpath_literal(s):
    """
    http://stackoverflow.com/questions/6937525/escaping-xpath-literal-with-python
    """
    if "'" not in s:
        return "'%s'" % s
    if '"' not in s:
        return '"%s"' % s
    return "concat('%s')" % s.replace("'", "',\"'\",'")


class SelectorMixin(object):
    _ARG_TO_SELECTOR = {
        'id':
            lambda self, val: (By.ID, val),
        'xpath':
            lambda self, val: (By.XPATH, val),
        'name':
            lambda self, val: (By.NAME, val),
        'tag_name':
            lambda self, val: (By.TAG_NAME, val),
        'class_name':
            lambda self, val: (By.CLASS_NAME, val),
        'css':
            lambda self, val: (By.CSS_SELECTOR, val),
        'link_text':
            lambda self, val: (By.LINK_TEXT, val),
        'link_text_contains':
            lambda self, val: (By.PARTIAL_LINK_TEXT, val),
        'attribute':
            lambda self, val: (By.XPATH, '%s[@%s]' % (self._xpath_prefix, val)),
        'attribute_value':
            lambda self, val: (By.XPATH,
                         '%s[@%s=%s]' % (self._xpath_prefix, val[0], xpath_literal(val[1]))),
        'text':
            lambda self, val: (By.XPATH,
                         '%s[text()=%s]' % (self._xpath_prefix, xpath_literal(val))),
        'text_contains':
            lambda self, val: (By.XPATH,
                         '%s/text()[contains(.,%s)]/..' % (self._xpath_prefix, xpath_literal(val))),
        #'label':
        #    lambda self, val: (By.XPATH,
        #                 '//*[@id=//label[text()=%s]/@for]' % xpath_literal(val)),
        #'label_contains':
        #    lambda self, val: (By.XPATH,
        #                 '//*[@id=//label[contains(text(),%s)]/@for]' % xpath_literal(val)),
        'value':
            lambda self, val: (By.XPATH,
                         '%s[@value=%s]' % (self._xpath_prefix, xpath_literal(val))),
        'type':
            lambda self, val: (By.XPATH,
                         '%s[@type=%s]' % (self._xpath_prefix, xpath_literal(val))),
        'checked':
            lambda self, val: (By.XPATH,
                         self._xpath_prefix + ('[@checked]' if val else '[not(@checked)]')),
        'selected':
            lambda self, val: (By.XPATH,
                         self._xpath_prefix + ('[@selected]' if val else '[not(@selected)]')),
        # TODO: label, label_contains
    }

    def _get_selector(self, **kwargs):
        for arg, value in kwargs.items():
            func = self._ARG_TO_SELECTOR.get(arg, None)
            assert func, "'%s' is not a valid selector argument." % arg
            yield func(self, value)  # (selector, value) tuple

    def find(self, *args, **kwargs):
        # Allow local override
        wait = kwargs.pop('wait', 0) or getattr(self, 'wait', 0)
        if wait:
            return WebDriverWait(self, wait).until(
                lambda selector: selector._find_nowait(*args, **kwargs)
            )
        else:
            return self._find_nowait(*args, **kwargs)

    def _find_nowait(self, css=None, **kwargs):
        if css:
            kwargs['css'] = css
        assert kwargs, 'no selector argument supplied.'

        elems = None
        for selector, value in self._get_selector(**kwargs):
            if elems is not None:
                other = self.find_elements(by=selector, value=value)
                elems &= other
            else:
                elems = self.find_elements(by=selector, value=value)
        return elems

    def wait_for(self, css=None, **kwargs):
        displayed = kwargs.pop('displayed', True)
        wait = kwargs.pop('wait', 0) or getattr(self, 'wait', 0)

        if css:
            kwargs['css'] = css
        assert kwargs, 'no selector argument supplied.'

        for locator in self._get_selector(**kwargs):
            if displayed:
                WebDriverWait(self, wait).until(visibility_of_element_located(locator))
            WebDriverWait(self, wait).until(presence_of_element_located(locator))


    #def find_all(self, css=None, **kwargs):
    #    (selector, value) = self._get_selector(css, **kwargs)
    #    return self.find_elements(by=selector, value=value)

########NEW FILE########
__FILENAME__ = utils
import os
try:
    from urllib2 import urlopen
except ImportError:
    from urllib.request import urlopen


def _download(url, filename):
    file_name = url.split('/')[-1]
    u = urlopen(url)
    f = open(filename, 'wb')
    meta = u.info()
    size = int(meta.getheaders("Content-Length")[0])
    print("Downloading: %s Bytes: %s" % (file_name, size))

    downloaded = 0
    block_sz = 8192
    while True:
        buffer = u.read(block_sz)
        if not buffer:
            break

        downloaded += len(buffer)
        f.write(buffer)
        status = r"%10d  [%3.2f%%]" % (downloaded, downloaded * 100. / size)
        status = status + chr(8) * (len(status) + 1)
        print(status),

    print(chr(8) + 'Done' + ' ' * (len(status) + 1))
    f.close()


# http://stackoverflow.com/questions/566746/how-to-get-console-window-width-in-python
def get_terminal_size():
    def ioctl_GWINSZ(fd):
        try:
            import fcntl
            import struct
            import termios
            cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ,
        '1234'))
        except:
            return None
        return cr
    cr = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)
    if not cr:
        try:
            fd = os.open(os.ctermid(), os.O_RDONLY)
            cr = ioctl_GWINSZ(fd)
            os.close(fd)
        except:
            pass
    if not cr:
        try:
            cr = (os.environ['LINES'], os.environ['COLUMNS'])
        except:
            cr = (25, 80)
    return int(cr[1]), int(cr[0])

########NEW FILE########
__FILENAME__ = webdriver
from webdriverplus.webelement import WebElement
from webdriverplus.webelementset import WebElementSet
from webdriverplus.selectors import SelectorMixin
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.wait import WebDriverWait

import re
import tempfile

from selenium.common.exceptions import StaleElementReferenceException


class WebDriverMixin(SelectorMixin):
    def __init__(self, *args, **kwargs):
        self.reuse_browser = kwargs.pop('reuse_browser', False)
        self.quit_on_exit = kwargs.pop('quit_on_exit', False)
        self.wait = kwargs.pop('wait', 0)
        self.highlight = kwargs.pop('highlight', True)
        self._highlighted = None
        self._has_quit = False
        super(WebDriverMixin, self).__init__(*args, **kwargs)

    def quit(self, force=False):
        if self._has_quit:
            return
        if self.reuse_browser and not force:
            # alert = self.alert
            # if alert:
            #     alert.dismiss()
            return
        super(WebDriverMixin, self).quit()
        self._has_quit = True

    def _highlight(self, elems):
        if not self.highlight:
            return
        if self._highlighted:
            script = """for (var i = 0, j = arguments.length; i < j; i++) {
                            var elem = arguments[i];
                            elem.style.backgroundColor = elem.getAttribute('savedBackground');
                            elem.style.borderColor = elem.getAttribute('savedBorder');
                            elem.style.outline = elem.getAttribute('savedOutline');
                        }"""
            try:
                self.execute_script(script, *self._highlighted)
            except StaleElementReferenceException:
                pass

        self._highlighted = elems
        script = """
            for (var i = 0, j = arguments.length; i < j; i++) {
                var elem = arguments[i];
                elem.setAttribute('savedBackground', elem.style.backgroundColor);
                elem.setAttribute('savedBorder', elem.style.borderColor);
                elem.setAttribute('savedOutline', elem.style.outline);
                elem.style.backgroundColor = '#f9edbe'
                elem.style.borderColor = '#f9edbe'
                elem.style.outline = '1px solid black';
            }"""
        try:
            self.execute_script(script, *elems)
        except StaleElementReferenceException:
            pass

    @property
    def _xpath_prefix(self):
        return '//*'

    # Override the default behavior to return our own WebElement and
    # WebElements objects.
    def _is_web_element(self, value):
        return isinstance(value, dict) and 'ELEMENT' in value

    def _is_web_element_list(self, lst):
        return all(isinstance(value, WebElement) for value in lst)

    def _create_web_element(self, element_id):
        return WebElement(self, element_id)

    def _create_web_elements(self, elements):
        return WebElementSet(self, elements)

    def _unwrap_value(self, value):
        if self._is_web_element(value):
            return self._create_web_element(value['ELEMENT'])
        elif isinstance(value, list):
            lst = [self._unwrap_value(item) for item in value]
            if self._is_web_element_list(lst):
                return self._create_web_elements(lst)
            return lst
        else:
            return value

    def _wrap_value(self, value):
        if isinstance(value, dict):
            converted = {}
            for key, val in value.items():
                converted[key] = self._wrap_value(val)
            return converted
        elif isinstance(value, WebElement):
            return {'ELEMENT': value._id}  # Use '._id', not '.id'
        elif isinstance(value, list):
            return list(self._wrap_value(item) for item in value)
        else:
            return value

    # Override get to return self
    def get(self, url):
        super(WebDriverMixin, self).get(url)
        return self

    # Add some useful shortcuts.
    def open(self, content):
        """
        Shortcut to open from text.
        """
        if not re.match("[^<]*<(html|doctype)", content, re.IGNORECASE):
            content = '<html><head><meta charset="utf-8"></head>%s</html>' % content
        with tempfile.NamedTemporaryFile() as temp:
            temp.write(content.encode('utf-8'))
            temp.flush()
            return self.get('file://' + temp.name)

    @property
    def page_text(self):
        """
        Returns the full page text.
        """
        return self.find(tag_name='body').text

    @property
    def alert(self):
        alert = self.switch_to_alert()
        try:
            alert.text
        except:
            return None
        return alert

    def switch_to_frame(self, frame):
        if isinstance(frame, WebElementSet):
            return super(WebDriverMixin, self).switch_to_frame(frame._first)
        return super(WebDriverMixin, self).switch_to_frame(frame)

    def __repr__(self):
        return '<WebDriver Instance, %s>' % (self.name)

########NEW FILE########
__FILENAME__ = webelement
from selenium.common.exceptions import StaleElementReferenceException
from selenium.webdriver.remote.webelement import WebElement as _WebElement
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.select import Select

from webdriverplus.deprecation import deprecated_property
from webdriverplus.selectors import SelectorMixin
from webdriverplus.utils import get_terminal_size
from webdriverplus.wrappers import Style, Attributes, Size, Location

try:
    from urllib2 import quote
except ImportError:
    from urllib.request import quote

import os
import sys


# http://stackoverflow.com/questions/6157929/how-to-simulate-mouse-click-using-javascript/6158050#6158050
def simulate_event(event, **options):
    return """
    function simulate(element, eventName)
    {
        var options = extend(defaultOptions, arguments[2] || {});
        var oEvent, eventType = null;

        for (var name in eventMatchers)
        {
            if (eventMatchers[name].test(eventName)) { eventType = name; break; }
        }

        if (!eventType)
            throw new SyntaxError('Only HTMLEvents and MouseEvents interfaces are supported');

        if (document.createEvent)
        {
            oEvent = document.createEvent(eventType);
            if (eventType == 'HTMLEvents')
            {
                oEvent.initEvent(eventName, options.bubbles, options.cancelable);
            }
            else
            {
                oEvent.initMouseEvent(eventName, options.bubbles, options.cancelable, document.defaultView,
          options.button, options.pointerX, options.pointerY, options.pointerX, options.pointerY,
          options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, element);
            }
            element.dispatchEvent(oEvent);
        }
        else
        {
            options.clientX = options.pointerX;
            options.clientY = options.pointerY;
            var evt = document.createEventObject();
            oEvent = extend(evt, options);
            element.fireEvent('on' + eventName, oEvent);
        }
        return element;
    }

    function extend(destination, source) {
        for (var property in source)
          destination[property] = source[property];
        return destination;
    }

    var eventMatchers = {
        'HTMLEvents': /^(?:load|unload|abort|error|select|change|submit|reset|focus|blur|resize|scroll)$/,
        'MouseEvents': /^(?:click|dblclick|mouse(?:down|up|over|move|out))$/
    }
    var defaultOptions = {
        pointerX: 0,
        pointerY: 0,
        button: 0,
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        metaKey: false,
        bubbles: true,
        cancelable: true
    }

    simulate(arguments[0], "%s", %s);""" % (event, repr(options))


class ParentProxy(object):
    """ We want to use the name 'parent', for traversal, but this hides
        the default WebElement property. We use a proxy so that _calling
        parent does the traversal while allowing _WebElement to use parent
        to access the WebDriver
    """

    def __init__(self, _webelement):
        self._webelement = _webelement

    def __call__(self, *args, **kwargs):
        return self._webelement._traversal_parent(*args, **kwargs)

    def __getattr__(self, name):
        return getattr(self._webelement._parent, name)


class WebElement(SelectorMixin, _WebElement):
    @property
    def _xpath_prefix(self):
        return './/*'

    @property
    def parent(self):
        """
        Note: We're overriding the default WebElement.parent behaviour here.
        (Normally .parent is a property that returns the WebDriver object.)
        """
        return ParentProxy(self)

    # Traversal
    def _traversal_parent(self, *args, **kwargs):
        ret = self.find(xpath='..')
        return ret.filter(*args, **kwargs)

    def children(self, *args, **kwargs):
        ret = self.find(xpath='./*')
        return ret.filter(*args, **kwargs)

    def descendants(self):
        return self.find(xpath='./descendant::*')

    def ancestors(self, *args, **kwargs):
        ret = self.find(xpath='./ancestor::*')
        return ret.filter(*args, **kwargs)

    def next(self, *args, **kwargs):
        ret = self.find(xpath='./following-sibling::*[1]')
        return ret.filter(*args, **kwargs)

    def prev(self, *args, **kwargs):
        ret = self.find(xpath='./preceding-sibling::*[1]')
        return ret.filter(*args, **kwargs)

    def next_all(self, *args, **kwargs):
        ret = self.find(xpath='./following-sibling::*')
        return ret.filter(*args, **kwargs)

    def prev_all(self, *args, **kwargs):
        ret = self.find(xpath='./preceding-sibling::*')
        return ret.filter(*args, **kwargs)

    def siblings(self, *args, **kwargs):
        ret = self.prev_all() | self.next_all()
        return ret.filter(*args, **kwargs)

    # Inspection & Manipulation
    @property
    def id(self):
        return self.get_attribute('id')

    @property
    def type(self):
        return self.get_attribute('type')

    @property
    def value(self):
        return self.get_attribute('value')
    
    @value.setter
    def value(self, value):
        self._parent.execute_script('arguments[0].value=unescape(decodeURI("%s"));' % quote(value), self)

    @deprecated_property
    def is_checked(self):
        return self.get_attribute('checked') is not None

    @deprecated_property
    def is_selected(self):
        return super(WebElement, self).is_selected()

    @deprecated_property
    def is_displayed(self):
        return super(WebElement, self).is_displayed()

    @deprecated_property
    def is_enabled(self):
        return super(WebElement, self).is_enabled()

    @property
    def inner_html(self):
        return self.get_attribute('innerHTML')

    @property
    def html(self):
        # http://stackoverflow.com/questions/1763479/how-to-get-the-html-for-a-dom-element-in-javascript
        script = """
            var container = document.createElement("div");
            container.appendChild(arguments[0].cloneNode(true));
            return container.innerHTML;
        """
        return self._parent.execute_script(script, self)

    @property
    def index(self):
        return len(self.prev_all())

    @property
    def style(self):
        return Style(self)

    @property
    def size(self):
        val = super(WebElement, self).size
        return Size(val['width'], val['height'])

    @property
    def location(self):
        val = super(WebElement, self).location
        return Location(val['x'], val['y'])

    @property
    def attributes(self):
        return Attributes(self)

    def attr(self, attribute):
        return self.get_attribute(attribute)

    def has_class(self, cls):
        return cls in self.attr('class').split(' ')

    def css(self, name, value=None):
        if value is None:
            return getattr(self.style, name)
        setattr(self.style, name, value)
        return self

    def javascript(self, script):
        script = "return arguments[0].%s;" % script
        return self._parent.execute_script(script, self)

    def jquery(self, script):
        script = "return $(arguments[0]).%s;" % script
        return self._parent.execute_script(script, self)

    # Actions...
    # Native events not supported on mac.
    def double_click(self):
        # self._parent.execute_script(simulate_event('dblclick'), self)
        ActionChains(self._parent).double_click(super(WebElement, self)).perform()
        return self

    def context_click(self):
        # self._parent.execute_script(simulate_event('click', button=2), self)
        ActionChains(self._parent).context_click(super(WebElement, self)).perform()
        return self

    def click_and_hold(self):
        # self._parent.execute_script(simulate_event('mousedown'), self)
        ActionChains(self._parent).click_and_hold(super(WebElement, self)).perform()
        return self

    def release(self):
        self._parent.execute_script(simulate_event('mouseup'), self)
        # ActionChains(self._parent).click_and_hold(super(WebElement, self)).perform()
        return self

    def move_to(self, x=0, y=0):
        # self._parent.execute_script(simulate_event('mouseover'), self)
        if x and y:
            ActionChains(self._parent).move_to_element_with_offset(super(WebElement, self), x, y).perform()
        else:
            ActionChains(self._parent).move_to_element(super(WebElement, self)).perform()
        return self

    def move_to_and_click(self, x=0, y=0):
        # self._parent.execute_script(simulate_event('mouseover'), self)
        if x and y:
            action_chains = ActionChains(self._parent).move_to_element_with_offset(super(WebElement, self), x, y)
        else:
            action_chains = ActionChains(self._parent).move_to_element(super(WebElement, self))
        action_chains.click().perform()
        return self

    def check(self):
        if not self.is_checked():
            self.click()

    def uncheck(self):
        if self.is_checked():
            self.click()

    # Bug in chrome driver that prevents send_keys to certain elements
    # so click 1st, clear, then send_keys
    # https://code.google.com/p/chromedriver/issues/detail?id=290
    def type_keys(self, *args):
        self.click()
        self.clear()
        self.send_keys(*args)

    def select_option(self, value=None, text=None, index=None):
        # Python3 filter -> list(filter)
        if len(list(filter(None, (value, text, index)))) != 1:
            raise ValueError("You must supply exactly one of (value, text, index) kwargs")

        select = Select(self)
        if value is not None:
            select.select_by_value(value)
        elif text is not None:
            select.select_by_visible_text(text)
        else:
            select.select_by_index(index)

    def deselect_option(self, value=None, text=None, index=None):
        if len(list(filter(None, (value, text, index)))) != 1:
            raise ValueError("You must supply exactly one of (value, text, index) kwargs")

        select = Select(self)
        if value is not None:
            select.deselect_by_value(value)
        elif text is not None:
            select.deselect_by_visible_text(text)
        else:
            select.deselect_by_index(index)

    def __repr__(self):
        try:
            if os.isatty(sys.stdin.fileno()):
                try:
                    width = get_terminal_size()[0]
                except:
                    width = 80
            else:
                width = 80

            ret = self.html
            ret = ' '.join(ret.split())
            ret = ret.encode('utf-8')

            if len(ret) >= width - 2:
                ret = ret[:width - 5] + '...'
                #self.style.backgroundColor = '#f9edbe'
            #self.style.borderColor = '#f9edbe'
            #self.style.outline = '1px solid black'
            return ret
        except StaleElementReferenceException:
            return '<StaleElement>'

    def __hash__(self):
        return hash(self._id)

    def __eq__(self, other):
        return self._id == other._id

########NEW FILE########
__FILENAME__ = webelementset
from webdriverplus.orderedset import OrderedSet
from webdriverplus.selectors import SelectorMixin
from webdriverplus.wrappers import Style, Attributes
from webdriverplus.deprecation import deprecated_property


class WebElementSet(SelectorMixin, OrderedSet):
    def __init__(self, webdriver, *args):
        super(WebElementSet, self).__init__(*args)
        self._webdriver = webdriver

    def _from_iterable(self, it):
        return WebElementSet(self._webdriver, it)

    def _empty(self):
        return WebElementSet(self._webdriver)

    def find(self, css=None, **kwargs):
        ret = self._empty()
        for elem in self:
            ret |= elem.find(css, **kwargs)
        return ret

    #def find_all(self, css=None, **kwargs):
    #    ret = WebElementSet(self._webdriver)
    #    for elem in self:
    #        ret |= elem.find_all(css, **kwargs)
    #    return ret

    def filter(self, css=None, **kwargs):
        if not css or kwargs:
            return self
        others = self._webdriver.find(css, **kwargs)
        return self & others

    def exclude(self, css=None, **kwargs):
        others = self._webdriver.find(css, **kwargs)
        return self - others

    @property
    def tag_name(self):
        return self._first.tag_name

    @property
    def text(self):
        return self._first.text

    @deprecated_property
    def is_selected(self):
        return self._first.is_selected()

    @deprecated_property
    def is_enabled(self):
        return self._first.is_enabled()

    @deprecated_property
    def is_displayed(self):
        return self._first.is_displayed()

    @deprecated_property
    def is_checked(self):
        return self._first.is_checked()

    # Events...
    def click(self):
        self._first.click()
        return self

    def double_click(self):
        self._first.double_click()
        return self

    def context_click(self):
        self._first.context_click()
        return self

    def click_and_hold(self):
        self._first.click_and_hold()
        return self

    def release(self):
        self._first.release()
        return self

    def move_to(self, x=0, y=0):
        self._first.move_to(x, y)
        return self

    def move_to_and_click(self, *args, **kwargs):
        self._first.move_to_and_click(*args, **kwargs)
        return self

    def check(self):
        self._first.check()
        return self

    def uncheck(self):
        self._first.uncheck()
        return self

    def submit(self):
        self._first.submit()
        return self

    def clear(self):
        self._first.clear()
        return self

    #
    def get_attribute(self, name):
        return self._first.get_attribute(name)

    def attr(self, name):
        return self._first.attr(name)

    def send_keys(self, *value):
        [elem.send_keys(*value) for elem in self]
        return self

    @property
    def type(self):
        return self._first.type

    @property
    def inner_html(self):
        return self._first.inner_html

    @property
    def html(self):
        return self._first.html

    @property
    def index(self):
        return self._first.index

    @property
    def value(self):
        return self._first.value

    @value.setter
    def value(self, value):
        self._first.value = value
        
    def value_of_css_property(self, property_name):
        return [elem.value_of_css_property(property_name) for elem in self]

    @property
    def location(self):
        return self._first.location

    @property
    def size(self):
        return self._first.size

    @property
    def id(self):
        return self._first.id

    @property
    def style(self):
        return Style(self._first)

    @property
    def attributes(self):
        return Attributes(self._first)

    def has_class(self, cls):
        for elem in self:
            if elem.has_class(cls):
                return True
        return False

    def css(self, name, value=None):
        return self._first.css(name, value)

    def javascript(self, script):
        return [elem.javascript(script) for elem in self]

    def __repr__(self):
        ret = "WebElementSet(\n  %s\n)" % '\n  '.join([repr(elem) for elem in self])
        script = """for (var i = 0, j = arguments.length; i < j; i++) {
                        var style = arguments[i].style;
                        style.backgroundColor = '#f9edbe'
                        style.borderColor = '#f9edbe'
                        style.outline = '1px solid black';
                    }"""
        self._webdriver._highlight([elem for elem in self])
        return ret

    # Traversal
    def parent(self, *args, **kwargs):
        ret = self._empty()
        for elem in self:
            ret |= elem.parent()
        return ret.filter(*args, **kwargs)

    def children(self, *args, **kwargs):
        ret = self._empty()
        for elem in self:
            ret |= elem.children()
        return ret.filter(*args, **kwargs)

    def descendants(self):
        ret = self._empty()
        for elem in self:
            ret |= elem.descendants()
        return ret

    def ancestors(self, *args, **kwargs):
        ret = self._empty()
        for elem in self:
            ret |= elem.ancestors()
        return ret.filter(*args, **kwargs)

    def next(self, *args, **kwargs):
        ret = self._empty()
        for elem in self:
            ret |= elem.next()
        return ret.filter(*args, **kwargs)

    def prev(self, *args, **kwargs):
        ret = self._empty()
        for elem in self:
            ret |= elem.prev()
        return ret.filter(*args, **kwargs)

    def next_all(self, *args, **kwargs):
        ret = self._empty()
        for elem in self:
            ret |= elem.next_all()
        return ret.filter(*args, **kwargs)

    def prev_all(self, *args, **kwargs):
        ret = self._empty()
        for elem in self:
            ret |= elem.prev_all()
        return ret.filter(*args, **kwargs)

    def siblings(self, *args, **kwargs):
        ret = self._empty()
        for elem in self:
            ret |= elem.siblings()
        return ret.filter(*args, **kwargs)

    def type_keys(self, *args):
        return self._first.type_keys(*args)

    def select_option(self, value=None, text=None, index=None):
        return self._first.select_option(value=value, text=text, index=index)

    def deselect_option(self, value=None, text=None, index=None):
        return self._first.deselect_option(value=value, text=text, index=index)

    def __getitem__(self, key):
        if isinstance(key, slice):
            elems = list(self)[key]
        else:
            elems = [list(self)[key]]
        return WebElementSet(self._webdriver, elems)

########NEW FILE########
__FILENAME__ = wrappers
from collections import namedtuple


Size = namedtuple('Size', ['width', 'height'])

Location = namedtuple('Location', ['x', 'y'])


class Style(object):
    """
    Allows getting and setting the CSS style.
    """
    _elem = None

    def __init__(self, elem):
        self.__dict__.update({'_elem': elem})

    def __getattr__(self, name):
        return self._elem.value_of_css_property(name)

    def __setattr__(self, name, value):
        self._elem.javascript('style.%s = "%s"' % (name, value))


# http://thatmattbone.com/2010/04/delaying-computation-lazy-dictionaries-in-python/
# http://stackoverflow.com/questions/2048720/get-all-attributes-from-a-html-element-with-javascript-jquery
class Attributes(object):
    """
    Allows getting, setting and deleting attributes.
    """

    def __init__(self, elem):
        self._elem = elem

    def _get_attributes(self):
        script = """
        var elem = arguments[0];
        var ret = {}
        for (var i=0, attrs=elem.attributes, l=attrs.length; i<l; i++){
            ret[attrs.item(i).nodeName] = attrs.item(i).nodeValue
        }
        return ret"""
        return self._elem._parent.execute_script(script, self._elem)

    def __getitem__(self, name):
        return self._elem.javascript("getAttribute('%s')" % name)

    def __setitem__(self, name, value):
        return self._elem.javascript("setAttribute('%s', %s)" %
                                     (name, repr(value)))

    def __delitem__(self, name):
        return self._elem.javascript("removeAttribute('%s')" % name)

    def __getattr__(self, name):
        data = self._get_attributes()
        return getattr(data, name)

    def __repr__(self):
        return repr(self._get_attributes())

    def __eq__(self, other):
        return self._get_attributes() == other

########NEW FILE########
