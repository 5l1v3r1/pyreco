__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Envelopes documentation build configuration file, created by
# sphinx-quickstart on Tue Aug  6 09:11:14 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Envelopes'
copyright = u'2013, Tomasz Wójcik'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.4'
# The full version, including alpha/beta/rc tags.
release = '0.4'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Envelopesdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Envelopes.tex', u'Envelopes Documentation',
   u'Tomasz Wójcik', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'envelopes', u'Envelopes Documentation',
     [u'Tomasz Wójcik'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Envelopes', u'Envelopes Documentation',
   u'Tomasz Wójcik', 'Envelopes', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-
# Copyright (c) 2013 Tomasz Wójcik <tomek@bthlabs.pl>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sys

def encoded(_str, coding):
    if sys.version_info[0] == 3:
        return _str
    else:
        if isinstance(_str, unicode):
            return _str.encode(coding)
        else:
            return _str

########NEW FILE########
__FILENAME__ = conn
# -*- coding: utf-8 -*-
# Copyright (c) 2013 Tomasz Wójcik <tomek@bthlabs.pl>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
envelopes.conn
==============

This module contains SMTP connection wrapper.
"""

import smtplib
import socket

TimeoutException = socket.timeout

__all__ = ['SMTP', 'GMailSMTP', 'SendGridSMTP', 'MailcatcherSMTP',
           'TimeoutException']


class SMTP(object):
    """Wrapper around :py:class:`smtplib.SMTP` class."""

    def __init__(self, host=None, port=25, login=None, password=None,
                 tls=False, timeout=None):
        self._conn = None
        self._host = host
        self._port = port
        self._login = login
        self._password = password
        self._tls = tls
        self._timeout = timeout

    @property
    def is_connected(self):
        """Returns *True* if the SMTP connection is initialized and
        connected. Otherwise returns *False*"""
        try:
            self._conn.noop()
        except (AttributeError, smtplib.SMTPServerDisconnected):
            return False
        else:
            return True

    def _connect(self, replace_current=False):
        if self._conn is None or replace_current:
            try:
                self._conn.quit()
            except (AttributeError, smtplib.SMTPServerDisconnected):
                pass

            if self._timeout:
                self._conn = smtplib.SMTP(self._host, self._port,
                                          timeout=self._timeout)
            else:
                self._conn = smtplib.SMTP(self._host, self._port)

        if self._tls:
            self._conn.starttls()

        if self._login:
            self._conn.login(self._login, self._password or '')

    def send(self, envelope):
        """Sends an *envelope*."""
        if not self.is_connected:
            self._connect()

        msg = envelope.to_mime_message()
        to_addrs = [envelope._addrs_to_header([addr]) for addr in envelope._to + envelope._cc + envelope._bcc]

        return self._conn.sendmail(msg['From'], to_addrs, msg.as_string())


class GMailSMTP(SMTP):
    """Subclass of :py:class:`SMTP` preconfigured for GMail SMTP."""

    GMAIL_SMTP_HOST = 'smtp.googlemail.com'
    GMAIL_SMTP_TLS = True

    def __init__(self, login=None, password=None):
        super(GMailSMTP, self).__init__(
            self.GMAIL_SMTP_HOST, tls=self.GMAIL_SMTP_TLS, login=login,
            password=password
        )


class SendGridSMTP(SMTP):
    """Subclass of :py:class:`SMTP` preconfigured for SendGrid SMTP."""

    SENDGRID_SMTP_HOST = 'smtp.sendgrid.net'
    SENDGRID_SMTP_PORT = 587
    SENDGRID_SMTP_TLS = False

    def __init__(self, login=None, password=None):
        super(SendGridSMTP, self).__init__(
            self.SENDGRID_SMTP_HOST, port=self.SENDGRID_SMTP_PORT,
            tls=self.SENDGRID_SMTP_TLS, login=login,
            password=password
        )


class MailcatcherSMTP(SMTP):
    """Subclass of :py:class:`SMTP` preconfigured for local Mailcatcher
    SMTP."""

    MAILCATCHER_SMTP_HOST = 'localhost'

    def __init__(self, port=1025):
        super(MailcatcherSMTP, self).__init__(
            self.MAILCATCHER_SMTP_HOST, port=port
        )

########NEW FILE########
__FILENAME__ = connstack
# -*- coding: utf-8 -*-
# Copyright 2012 Vincent Driessen. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#
#    2. Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY VINCENT DRIESSEN ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL VINCENT DRIESSEN OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation are
# those of the authors and should not be interpreted as representing official
# policies, either expressed or implied, of Vincent Driessen.
#

"""
envelopes.connstack
===================

This module implements SMTP connection stack management.
"""

from contextlib import contextmanager
from .local import LocalStack, release_local


class NoSMTPConnectionException(Exception):
    pass


@contextmanager
def Connection(connection):
    push_connection(connection)
    try:
        yield
    finally:
        popped = pop_connection()
        assert popped == connection, \
            'Unexpected SMTP connection was popped off the stack. ' \
            'Check your SMTP connection setup.'


def push_connection(connection):
    """Pushes the given connection on the stack."""
    _connection_stack.push(connection)


def pop_connection():
    """Pops the topmost connection from the stack."""
    return _connection_stack.pop()


def use_connection(connection):
    """Clears the stack and uses the given connection.  Protects against mixed
    use of use_connection() and stacked connection contexts.
    """
    assert len(_connection_stack) <= 1, \
        'You should not mix Connection contexts with use_connection().'
    release_local(_connection_stack)
    push_connection(connection)


def get_current_connection():
    """Returns the current SMTP connection (i.e. the topmost on the
    connection stack).
    """
    return _connection_stack.top


def resolve_connection(connection=None):
    """Convenience function to resolve the given or the current connection.
    Raises an exception if it cannot resolve a connection now.
    """
    if connection is not None:
        return connection

    connection = get_current_connection()
    if connection is None:
        raise NoSMTPConnectionException(
            'Could not resolve an SMTP connection.')
    return connection


_connection_stack = LocalStack()

__all__ = [
    'Connection', 'get_current_connection', 'push_connection',
    'pop_connection', 'use_connection'
]

########NEW FILE########
__FILENAME__ = envelope
# -*- coding: utf-8 -*-
# Copyright (c) 2013 Tomasz Wójcik <tomek@bthlabs.pl>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
envelopes.envelope
==================

This module contains the Envelope class.
"""

import sys

if sys.version_info[0] == 2:
    from email import Encoders as email_encoders
elif sys.version_info[0] == 3:
    from email import encoders as email_encoders
    basestring = str

    def unicode(_str, _charset):
        return str(_str.encode(_charset), _charset)
else:
    raise RuntimeError('Unsupported Python version: %d.%d.%d' % (
        sys.version_info[0], sys.version_info[1], sys.version_info[2]
    ))

from email.header import Header
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from email.mime.audio import MIMEAudio
from email.mime.image import MIMEImage
from email.mime.text import MIMEText
import mimetypes
import os
import re

from .conn import SMTP
from .compat import encoded


class MessageEncodeError(Exception):
    pass

class Envelope(object):
    """
    The Envelope class.

    **Address formats**

    The following formats are supported for e-mail addresses:

    * ``"user@server.com"`` - just the e-mail address part as a string,
    * ``"Some User <user@server.com>"`` - name and e-mail address parts as a string,
    * ``("user@server.com", "Some User")`` - e-mail address and name parts as a tuple.

    Whenever you come to manipulate addresses feel free to use any (or all) of
    the formats above.

    :param to_addr: ``To`` address or list of ``To`` addresses
    :param from_addr: ``From`` address
    :param subject: message subject
    :param html_body: optional HTML part of the message
    :param text_body: optional plain text part of the message
    :param cc_addr: optional single CC address or list of CC addresses
    :param bcc_addr: optional single BCC address or list of BCC addresses
    :param headers: optional dictionary of headers
    :param charset: message charset
    """

    ADDR_FORMAT = '%s <%s>'
    ADDR_REGEXP = re.compile(r'^(.*) <([^@]+@[^@]+)>$')

    def __init__(self, to_addr=None, from_addr=None, subject=None,
                 html_body=None, text_body=None, cc_addr=None, bcc_addr=None,
                 headers=None, charset='utf-8'):
        if to_addr:
            if isinstance(to_addr, list):
                self._to = to_addr
            else:
                self._to = [to_addr]
        else:
            self._to = []

        self._from = from_addr
        self._subject = subject
        self._parts = []

        if text_body:
            self._parts.append(('text/plain', text_body, charset))

        if html_body:
            self._parts.append(('text/html', html_body, charset))

        if cc_addr:
            if isinstance(cc_addr, list):
                self._cc = cc_addr
            else:
                self._cc = [cc_addr]
        else:
            self._cc = []

        if bcc_addr:
            if isinstance(bcc_addr, list):
                self._bcc = bcc_addr
            else:
                self._bcc = [bcc_addr]
        else:
            self._bcc = []

        if headers:
            self._headers = headers
        else:
            self._headers = {}

        self._charset = charset

        self._addr_format = unicode(self.ADDR_FORMAT, charset)

    def __repr__(self):
        return u'<Envelope from="%s" to="%s" subject="%s">' % (
            self._addrs_to_header([self._from]),
            self._addrs_to_header(self._to),
            self._subject
        )

    @property
    def to_addr(self):
        """List of ``To`` addresses."""
        return self._to

    def add_to_addr(self, to_addr):
        """Adds a ``To`` address."""
        self._to.append(to_addr)

    def clear_to_addr(self):
        """Clears list of ``To`` addresses."""
        self._to = []

    @property
    def from_addr(self):
        return self._from

    @from_addr.setter
    def from_addr(self, from_addr):
        self._from = from_addr

    @property
    def cc_addr(self):
        """List of CC addresses."""
        return self._cc

    def add_cc_addr(self, cc_addr):
        """Adds a CC address."""
        self._cc.append(cc_addr)

    def clear_cc_addr(self):
        """Clears list of CC addresses."""
        self._cc = []

    @property
    def bcc_addr(self):
        """List of BCC addresses."""
        return self._bcc

    def add_bcc_addr(self, bcc_addr):
        """Adds a BCC address."""
        self._bcc.append(bcc_addr)

    def clear_bcc_addr(self):
        """Clears list of BCC addresses."""
        self._bcc = []

    @property
    def charset(self):
        """Message charset."""
        return self._charset

    @charset.setter
    def charset(self, charset):
        self._charset = charset

        self._addr_format = unicode(self.ADDR_FORMAT, charset)

    def _addr_tuple_to_addr(self, addr_tuple):
        addr = ''

        if len(addr_tuple) == 2 and addr_tuple[1]:
            addr = self._addr_format % (
                self._header(addr_tuple[1] or ''),
                addr_tuple[0] or ''
            )
        elif addr_tuple[0]:
            addr = addr_tuple[0]

        return addr

    @property
    def headers(self):
        """Dictionary of custom headers."""
        return self._headers

    def add_header(self, key, value):
        """Adds a custom header."""
        self._headers[key] = value

    def clear_headers(self):
        """Clears custom headers."""
        self._headers = {}

    def _addrs_to_header(self, addrs):
        _addrs = []
        for addr in addrs:
            if not addr:
                continue

            if isinstance(addr, basestring):
                if self._is_ascii(addr):
                    _addrs.append(self._encoded(addr))
                else:
                    # these headers need special care when encoding, see:
                    #   http://tools.ietf.org/html/rfc2047#section-8
                    # Need to break apart the name from the address if there are
                    # non-ascii chars
                    m = self.ADDR_REGEXP.match(addr)
                    if m:
                        t = (m.group(2), m.group(1))
                        _addrs.append(self._addr_tuple_to_addr(t))
                    else:
                        # What can we do? Just pass along what the user gave us and hope they did it right
                        _addrs.append(self._encoded(addr))
            elif isinstance(addr, tuple):
                _addrs.append(self._addr_tuple_to_addr(addr))
            else:
                self._raise(MessageEncodeError,
                            '%s is not a valid address' % str(addr))

        _header = ','.join(_addrs)
        return _header

    def _raise(self, exc_class, message):
        raise exc_class(self._encoded(message))

    def _header(self, _str):
        if self._is_ascii(_str):
            return _str
        return Header(_str, self._charset).encode()

    def _is_ascii(self, _str):
        return all(ord(c) < 128 for c in _str)

    def _encoded(self, _str):
        return encoded(_str, self._charset)

    def to_mime_message(self):
        """Returns the envelope as
        :py:class:`email.mime.multipart.MIMEMultipart`."""
        msg = MIMEMultipart('alternative')
        msg['Subject'] = self._header(self._subject or '')

        msg['From'] = self._encoded(self._addrs_to_header([self._from]))
        msg['To'] = self._encoded(self._addrs_to_header(self._to))

        if self._cc:
            msg['CC'] = self._addrs_to_header(self._cc)

        if self._headers:
            for key, value in self._headers.items():
                msg[key] = self._header(value)

        for part in self._parts:
            type_maj, type_min = part[0].split('/')
            if type_maj == 'text' and type_min in ('html', 'plain'):
                msg.attach(MIMEText(part[1], type_min, self._charset))
            else:
                msg.attach(part[1])

        return msg

    def add_attachment(self, file_path, mimetype=None):
        """Attaches a file located at *file_path* to the envelope. If
        *mimetype* is not specified an attempt to guess it is made. If nothing
        is guessed then `application/octet-stream` is used."""
        if not mimetype:
            mimetype, _ = mimetypes.guess_type(file_path)

        if mimetype is None:
            mimetype = 'application/octet-stream'

        type_maj, type_min = mimetype.split('/')
        with open(file_path, 'rb') as fh:
            part_data = fh.read()

            part = MIMEBase(type_maj, type_min)
            part.set_payload(part_data)
            email_encoders.encode_base64(part)

            part_filename = os.path.basename(self._encoded(file_path))
            part.add_header('Content-Disposition', 'attachment; filename="%s"'
                            % part_filename)

            self._parts.append((mimetype, part))

    def send(self, *args, **kwargs):
        """Sends the envelope using a freshly created SMTP connection. *args*
        and *kwargs* are passed directly to :py:class:`envelopes.conn.SMTP`
        constructor.

        Returns a tuple of SMTP object and whatever its send method returns."""
        conn = SMTP(*args, **kwargs)
        send_result = conn.send(self)
        return conn, send_result

########NEW FILE########
__FILENAME__ = local
# -*- coding: utf-8 -*-
# Copyright (c) 2011 by the Werkzeug Team, see AUTHORS for more details.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#
#     * The names of the contributors may not be used to endorse or
#       promote products derived from this software without specific
#       prior written permission.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

"""
    werkzeug.local
    ~~~~~~~~~~~~~~

    This module implements context-local objects.

    :copyright: (c) 2011 by the Werkzeug Team, see AUTHORS for more details.
    :license: BSD, see LICENSE for more details.
"""
# Since each thread has its own greenlet we can just use those as identifiers
# for the context.  If greenlets are not available we fall back to the
# current thread ident.
try:
    from greenlet import getcurrent as get_ident
except ImportError:  # noqa
    try:
        from thread import get_ident  # noqa
    except ImportError:  # noqa
        from _thread import get_ident  # noqa


def release_local(local):
    """Releases the contents of the local for the current context.
    This makes it possible to use locals without a manager.

    Example::

        >>> loc = Local()
        >>> loc.foo = 42
        >>> release_local(loc)
        >>> hasattr(loc, 'foo')
        False

    With this function one can release :class:`Local` objects as well
    as :class:`StackLocal` objects.  However it is not possible to
    release data held by proxies that way, one always has to retain
    a reference to the underlying local object in order to be able
    to release it.

    .. versionadded:: 0.6.1
    """
    local.__release_local__()


class Local(object):
    __slots__ = ('__storage__', '__ident_func__')

    def __init__(self):
        object.__setattr__(self, '__storage__', {})
        object.__setattr__(self, '__ident_func__', get_ident)

    def __iter__(self):
        return iter(self.__storage__.items())

    def __call__(self, proxy):
        """Create a proxy for a name."""
        return LocalProxy(self, proxy)

    def __release_local__(self):
        self.__storage__.pop(self.__ident_func__(), None)

    def __getattr__(self, name):
        try:
            return self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        ident = self.__ident_func__()
        storage = self.__storage__
        try:
            storage[ident][name] = value
        except KeyError:
            storage[ident] = {name: value}

    def __delattr__(self, name):
        try:
            del self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)


class LocalStack(object):
    """This class works similar to a :class:`Local` but keeps a stack
    of objects instead.  This is best explained with an example::

        >>> ls = LocalStack()
        >>> ls.push(42)
        >>> ls.top
        42
        >>> ls.push(23)
        >>> ls.top
        23
        >>> ls.pop()
        23
        >>> ls.top
        42

    They can be force released by using a :class:`LocalManager` or with
    the :func:`release_local` function but the correct way is to pop the
    item from the stack after using.  When the stack is empty it will
    no longer be bound to the current context (and as such released).

    By calling the stack without arguments it returns a proxy that resolves to
    the topmost item on the stack.

    .. versionadded:: 0.6.1
    """

    def __init__(self):
        self._local = Local()

    def __release_local__(self):
        self._local.__release_local__()

    def _get__ident_func__(self):
        return self._local.__ident_func__

    def _set__ident_func__(self, value):  # noqa
        object.__setattr__(self._local, '__ident_func__', value)
    __ident_func__ = property(_get__ident_func__, _set__ident_func__)
    del _get__ident_func__, _set__ident_func__

    def __call__(self):
        def _lookup():
            rv = self.top
            if rv is None:
                raise RuntimeError('object unbound')
            return rv
        return LocalProxy(_lookup)

    def push(self, obj):
        """Pushes a new item to the stack"""
        rv = getattr(self._local, 'stack', None)
        if rv is None:
            self._local.stack = rv = []
        rv.append(obj)
        return rv

    def pop(self):
        """Removes the topmost item from the stack, will return the
        old value or `None` if the stack was already empty.
        """
        stack = getattr(self._local, 'stack', None)
        if stack is None:
            return None
        elif len(stack) == 1:
            release_local(self._local)
            return stack[-1]
        else:
            return stack.pop()

    @property
    def top(self):
        """The topmost item on the stack.  If the stack is empty,
        `None` is returned.
        """
        try:
            return self._local.stack[-1]
        except (AttributeError, IndexError):
            return None

    def __len__(self):
        stack = getattr(self._local, 'stack', None)
        if stack is None:
            return 0
        return len(stack)


class LocalManager(object):
    """Local objects cannot manage themselves. For that you need a local
    manager.  You can pass a local manager multiple locals or add them later
    by appending them to `manager.locals`.  Everytime the manager cleans up
    it, will clean up all the data left in the locals for this context.

    The `ident_func` parameter can be added to override the default ident
    function for the wrapped locals.

    .. versionchanged:: 0.6.1
       Instead of a manager the :func:`release_local` function can be used
       as well.

    .. versionchanged:: 0.7
       `ident_func` was added.
    """

    def __init__(self, locals=None, ident_func=None):
        if locals is None:
            self.locals = []
        elif isinstance(locals, Local):
            self.locals = [locals]
        else:
            self.locals = list(locals)
        if ident_func is not None:
            self.ident_func = ident_func
            for local in self.locals:
                object.__setattr__(local, '__ident_func__', ident_func)
        else:
            self.ident_func = get_ident

    def get_ident(self):
        """Return the context identifier the local objects use internally for
        this context.  You cannot override this method to change the behavior
        but use it to link other context local objects (such as SQLAlchemy's
        scoped sessions) to the Werkzeug locals.

        .. versionchanged:: 0.7
           Yu can pass a different ident function to the local manager that
           will then be propagated to all the locals passed to the
           constructor.
        """
        return self.ident_func()

    def cleanup(self):
        """Manually clean up the data in the locals for this context.  Call
        this at the end of the request or use `make_middleware()`.
        """
        for local in self.locals:
            release_local(local)

    def __repr__(self):
        return '<%s storages: %d>' % (
            self.__class__.__name__,
            len(self.locals)
        )


class LocalProxy(object):
    """Acts as a proxy for a werkzeug local.  Forwards all operations to
    a proxied object.  The only operations not supported for forwarding
    are right handed operands and any kind of assignment.

    Example usage::

        from werkzeug.local import Local
        l = Local()

        # these are proxies
        request = l('request')
        user = l('user')


        from werkzeug.local import LocalStack
        _response_local = LocalStack()

        # this is a proxy
        response = _response_local()

    Whenever something is bound to l.user / l.request the proxy objects
    will forward all operations.  If no object is bound a :exc:`RuntimeError`
    will be raised.

    To create proxies to :class:`Local` or :class:`LocalStack` objects,
    call the object as shown above.  If you want to have a proxy to an
    object looked up by a function, you can (as of Werkzeug 0.6.1) pass
    a function to the :class:`LocalProxy` constructor::

        session = LocalProxy(lambda: get_current_request().session)

    .. versionchanged:: 0.6.1
       The class can be instanciated with a callable as well now.
    """
    __slots__ = ('__local', '__dict__', '__name__')

    def __init__(self, local, name=None):
        object.__setattr__(self, '_LocalProxy__local', local)
        object.__setattr__(self, '__name__', name)

    def _get_current_object(self):
        """Return the current object.  This is useful if you want the real
        object behind the proxy at a time for performance reasons or because
        you want to pass the object into a different context.
        """
        if not hasattr(self.__local, '__release_local__'):
            return self.__local()
        try:
            return getattr(self.__local, self.__name__)
        except AttributeError:
            raise RuntimeError('no object bound to %s' % self.__name__)

    @property
    def __dict__(self):
        try:
            return self._get_current_object().__dict__
        except RuntimeError:
            raise AttributeError('__dict__')

    def __repr__(self):
        try:
            obj = self._get_current_object()
        except RuntimeError:
            return '<%s unbound>' % self.__class__.__name__
        return repr(obj)

    def __nonzero__(self):
        try:
            return bool(self._get_current_object())
        except RuntimeError:
            return False

    def __unicode__(self):
        try:
            return unicode(self._get_current_object())
        except RuntimeError:
            return repr(self)

    def __dir__(self):
        try:
            return dir(self._get_current_object())
        except RuntimeError:
            return []

    def __getattr__(self, name):
        if name == '__members__':
            return dir(self._get_current_object())
        return getattr(self._get_current_object(), name)

    def __setitem__(self, key, value):
        self._get_current_object()[key] = value

    def __delitem__(self, key):
        del self._get_current_object()[key]

    def __setslice__(self, i, j, seq):
        self._get_current_object()[i:j] = seq

    def __delslice__(self, i, j):
        del self._get_current_object()[i:j]

    __setattr__ = lambda x, n, v: setattr(x._get_current_object(), n, v)
    __delattr__ = lambda x, n: delattr(x._get_current_object(), n)
    __str__ = lambda x: str(x._get_current_object())
    __lt__ = lambda x, o: x._get_current_object() < o
    __le__ = lambda x, o: x._get_current_object() <= o
    __eq__ = lambda x, o: x._get_current_object() == o
    __ne__ = lambda x, o: x._get_current_object() != o
    __gt__ = lambda x, o: x._get_current_object() > o
    __ge__ = lambda x, o: x._get_current_object() >= o
    __cmp__ = lambda x, o: cmp(x._get_current_object(), o)
    __hash__ = lambda x: hash(x._get_current_object())
    __call__ = lambda x, *a, **kw: x._get_current_object()(*a, **kw)
    __len__ = lambda x: len(x._get_current_object())
    __getitem__ = lambda x, i: x._get_current_object()[i]
    __iter__ = lambda x: iter(x._get_current_object())
    __contains__ = lambda x, i: i in x._get_current_object()
    __getslice__ = lambda x, i, j: x._get_current_object()[i:j]
    __add__ = lambda x, o: x._get_current_object() + o
    __sub__ = lambda x, o: x._get_current_object() - o
    __mul__ = lambda x, o: x._get_current_object() * o
    __floordiv__ = lambda x, o: x._get_current_object() // o
    __mod__ = lambda x, o: x._get_current_object() % o
    __divmod__ = lambda x, o: x._get_current_object().__divmod__(o)
    __pow__ = lambda x, o: x._get_current_object() ** o
    __lshift__ = lambda x, o: x._get_current_object() << o
    __rshift__ = lambda x, o: x._get_current_object() >> o
    __and__ = lambda x, o: x._get_current_object() & o
    __xor__ = lambda x, o: x._get_current_object() ^ o
    __or__ = lambda x, o: x._get_current_object() | o
    __div__ = lambda x, o: x._get_current_object().__div__(o)
    __truediv__ = lambda x, o: x._get_current_object().__truediv__(o)
    __neg__ = lambda x: -(x._get_current_object())
    __pos__ = lambda x: +(x._get_current_object())
    __abs__ = lambda x: abs(x._get_current_object())
    __invert__ = lambda x: ~(x._get_current_object())
    __complex__ = lambda x: complex(x._get_current_object())
    __int__ = lambda x: int(x._get_current_object())
    __long__ = lambda x: long(x._get_current_object())
    __float__ = lambda x: float(x._get_current_object())
    __oct__ = lambda x: oct(x._get_current_object())
    __hex__ = lambda x: hex(x._get_current_object())
    __index__ = lambda x: x._get_current_object().__index__()
    __coerce__ = lambda x, o: x._get_current_object().__coerce__(x, o)
    __enter__ = lambda x: x._get_current_object().__enter__()
    __exit__ = lambda x, *a, **kw: x._get_current_object().__exit__(*a, **kw)

########NEW FILE########
__FILENAME__ = example_celery
# -*- coding: utf-8 -*-
# Copyright (c) 2013 Tomasz Wójcik <tomek@bthlabs.pl>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
sys.path = ['.'] + sys.path

from celery import Celery
from envelopes import Envelope

celery = Celery('envelopes_demo')
celery.conf.BROKER_URL = 'amqp://guest@localhost//'


@celery.task
def send_envelope():
    envelope = Envelope(
        from_addr='%s@localhost' % os.getlogin(),
        to_addr='%s@localhost' % os.getlogin(),
        subject='Envelopes in Celery demo',
        text_body="I'm a helicopter!"
    )
    envelope.send('localhost', port=1025)

########NEW FILE########
__FILENAME__ = example_flask
# -*- coding: utf-8 -*-
# Copyright (c) 2013 Tomasz Wójcik <tomek@bthlabs.pl>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sys
sys.path = ['.'] + sys.path

from envelopes import Envelope, SMTP
import envelopes.connstack
from flask import Flask, jsonify
import os


app = Flask(__name__)
app.config['DEBUG'] = True

conn = SMTP('127.0.0.1', 1025)


@app.before_request
def app_before_request():
    envelopes.connstack.push_connection(conn)


@app.after_request
def app_after_request(response):
    envelopes.connstack.pop_connection()
    return response


@app.route('/mail', methods=['POST'])
def post_mail():
    envelope = Envelope(
        from_addr='%s@localhost' % os.getlogin(),
        to_addr='%s@localhost' % os.getlogin(),
        subject='Envelopes in Flask demo',
        text_body="I'm a helicopter!"
    )

    smtp = envelopes.connstack.get_current_connection()
    smtp.send(envelope)

    return jsonify(dict(status='ok'))

if __name__ == '__main__':
    app.run()

########NEW FILE########
__FILENAME__ = testing
# -*- coding: utf-8 -*-
# Copyright (c) 2013 Tomasz Wójcik <tomek@bthlabs.pl>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
lib.testing
===========

Various utilities used in testing.
"""

import codecs
import json
import os
import smtplib
import tempfile

HTML_BODY = u"""<html>
<head></head>
<body><p>I'm a helicopter!</p></body>
</html>"""

TEXT_BODY = u"""I'm a helicopter!"""


class MockSMTP(object):
    """A class that mocks ``smtp.SMTP``."""

    debuglevel = 0
    file = None
    helo_resp = None
    ehlo_msg = "ehlo"
    ehlo_resp = None
    does_esmtp = 0
    default_port = smtplib.SMTP_PORT

    def __init__(self, host='', port=0, local_hostname=None, timeout=0):
        self._host = host
        self._port = port
        self._local_hostname = local_hostname
        self._timeout = timeout
        self._call_stack = {}

    def __append_call(self, method, args, kwargs):
        if method not in self._call_stack:
            self._call_stack[method] = []

        self._call_stack[method].append((args, kwargs))

    def set_debuglevel(self, debuglevel):
        self.debuglevel = debuglevel

    def _get_socket(self, port, host, timeout):
        return None

    def connect(self, host='localhost', port=0):
        self.__append_call('connect', [], dict(host=host, port=port))

    def send(self, str):
        self.__append_call('connect', [str], {})

    def putcmd(self, cmd, args=""):
        self.__append_call('connect', [cmd], dict(args=args))

    def getreply(self):
        self.__append_call('getreply', [], dict())

    def docmd(self, cmd, args=""):
        self.__append_call('docmd', [cmd], dict(args=args))

    def helo(self, name=''):
        self.__append_call('helo', [], dict(name=name))

    def ehlo(self, name=''):
        self.__append_call('ehlo', [], dict(name=name))

    def has_extn(self, opt):
        self.__append_call('has_extn', [opt], dict())

    def help(self, args=''):
        self.__append_call('help', [], dict(args=args))

    def rset(self):
        self.__append_call('rset', [], dict())

    def noop(self):
        self.__append_call('noop', [], dict())

    def mail(self, sender, options=[]):
        self.__append_call('mail', [sender], dict(options=options))

    def rcpt(self, recip, options=[]):
        self.__append_call('rcpt', [recip], dict(options=options))

    def data(self, msg):
        self.__append_call('data', [msg], dict())

    def verify(self, address):
        self.__append_call('verify', [address], dict())

    vrfy = verify

    def expn(self, address):
        self.__append_call('expn', [address], dict())

    def ehlo_or_helo_if_needed(self):
        self.__append_call('ehlo_or_helo_if_needed', [], dict())

    def login(self, user, password):
        self.__append_call('login', [user, password], dict())

    def starttls(self, keyfile=None, certfile=None):
        self.__append_call('starttls', [], dict(keyfile=keyfile,
                                                certfile=certfile))

    def sendmail(self, from_addr, to_addrs, msg, mail_options=[],
                 rcpt_options=[]):
        _args = [from_addr, to_addrs, msg]
        _kwargs = dict(mail_options=mail_options, rcpt_options=rcpt_options)
        self.__append_call('sendmail', _args, _kwargs)

    def close(self):
        self.__append_call('close', [], dict())

    def quit(self):
        self.__append_call('quit', [], dict())


class BaseTestCase(object):
    """Base class for Envelopes test cases."""

    @classmethod
    def setUpClass(cls):
        cls._tempfiles = []

    @classmethod
    def tearDownClass(cls):
        for tempfile in cls._tempfiles:
            os.unlink(tempfile)

    def tearDown(self):
        self._unpatch_smtplib()

    def _patch_smtplib(self):
        self._orig_smtp = smtplib.SMTP
        smtplib.SMTP = MockSMTP

    def _unpatch_smtplib(self):
        if hasattr(self, '_orig_smtp'):
            smtplib.SMTP = self._orig_smtp

    def _dummy_message(self):
        return dict({
            'to_addr': ('to@example.com', 'Example To'),
            'from_addr': ('from@example.com', 'Example From'),
            'subject': "I'm a helicopter!",
            'html_body': HTML_BODY,
            'text_body': TEXT_BODY,
            'cc_addr': [
                'cc1@example.com',
                'Example CC2 <cc2@example.com>',
                ('cc3@example.com', 'Example CC3')
            ],
            'bcc_addr': [
                'bcc1@example.com',
                'Example BCC2 <bcc2@example.com>',
                ('bcc3@example.com', 'Example BCC3')
            ],
            'headers': {
                'Reply-To': 'reply-to@example.com',
                'X-Mailer': 'Envelopes by BTHLabs'
            },
            'charset': 'utf-8'
        })

    def _tempfile(self, **kwargs):
        fd, path = tempfile.mkstemp(**kwargs)
        os.close(fd)
        self._tempfiles.append(path)

        return path

########NEW FILE########
__FILENAME__ = test_conn
# -*- coding: utf-8 -*-
# Copyright (c) 2013 Tomasz Wójcik <tomek@bthlabs.pl>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
test_conn
=========

This module contains test suite for the *SMTP* class.
"""

from envelopes.conn import SMTP
from envelopes.envelope import Envelope
from lib.testing import BaseTestCase


class Test_SMTPConnection(BaseTestCase):
    def setUp(self):
        self._patch_smtplib()

    def test_constructor(self):
        conn = SMTP('localhost', port=587, login='spam',
                    password='eggs', tls=True, timeout=10)

        assert conn._conn is None
        assert conn._host == 'localhost'
        assert conn._port == 587
        assert conn._login == 'spam'
        assert conn._password == 'eggs'
        assert conn._tls is True
        assert conn._timeout == 10

    def test_constructor_all_kwargs(self):
        conn = SMTP(host='localhost', port=587, login='spam',
                    password='eggs', tls=True)

        assert conn._conn is None
        assert conn._host == 'localhost'
        assert conn._port == 587
        assert conn._login == 'spam'
        assert conn._password == 'eggs'
        assert conn._tls is True

    def test_connect(self):
        conn = SMTP('localhost')
        conn._connect()
        assert conn._conn is not None

        old_conn = conn._conn
        conn._connect()
        assert old_conn == conn._conn

    def test_connect_replace_current(self):
        conn = SMTP('localhost')
        conn._connect()
        assert conn._conn is not None

        old_conn = conn._conn
        conn._connect(replace_current=True)
        assert conn._conn is not None
        assert conn._conn != old_conn

    def test_connect_starttls(self):
        conn = SMTP('localhost', tls=False)
        conn._connect()
        assert conn._conn is not None
        assert len(conn._conn._call_stack.get('starttls', [])) == 0

        conn = SMTP('localhost', tls=True)
        conn._connect()
        assert conn._conn is not None
        assert len(conn._conn._call_stack.get('starttls', [])) == 1

    def test_connect_login(self):
        conn = SMTP('localhost')
        conn._connect()
        assert conn._conn is not None
        assert len(conn._conn._call_stack.get('login', [])) == 0

        conn = SMTP('localhost', login='spam')
        conn._connect()
        assert conn._conn is not None
        assert len(conn._conn._call_stack.get('login', [])) == 1

        call_args = conn._conn._call_stack['login'][0][0]
        assert len(call_args) == 2
        assert call_args[0] == conn._login
        assert call_args[1] == ''

        conn = SMTP('localhost', login='spam', password='eggs')
        conn._connect()
        assert conn._conn is not None
        assert len(conn._conn._call_stack.get('login', [])) == 1

        call_args = conn._conn._call_stack['login'][0][0]
        assert len(call_args) == 2
        assert call_args[0] == conn._login
        assert call_args[1] == conn._password

    def test_is_connected(self):
        conn = SMTP('localhost')
        assert conn.is_connected is False

        conn._connect()
        assert conn.is_connected is True
        assert len(conn._conn._call_stack.get('noop', [])) == 1

    def test_send(self):
        conn = SMTP('localhost')

        msg = self._dummy_message()
        envelope = Envelope(**msg)
        mime_msg = envelope.to_mime_message()

        conn.send(envelope)
        assert conn._conn is not None
        assert len(conn._conn._call_stack.get('sendmail', [])) == 1

        call_args = conn._conn._call_stack['sendmail'][0][0]
        assert len(call_args) == 3
        assert call_args[0] == mime_msg['From']
        assert call_args[1] == [envelope._addrs_to_header([addr]) for addr in envelope._to + envelope._cc + envelope._bcc]
        assert call_args[2] != ''

########NEW FILE########
__FILENAME__ = test_envelope
# -*- coding: utf-8 -*-
# Copyright (c) 2013 Tomasz Wójcik <tomek@bthlabs.pl>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
test_envelope
=============

This module contains test suite for the *Envelope* class.
"""

from email.header import Header
import os
import sys

from envelopes.envelope import Envelope, MessageEncodeError
from envelopes.compat import encoded
from lib.testing import BaseTestCase


class Test_Envelope(BaseTestCase):
    def setUp(self):
        self._patch_smtplib()

    def test_constructor(self):
        msg = self._dummy_message()
        envelope = Envelope(**msg)

        assert envelope._to == [msg['to_addr']]
        assert envelope._from == msg['from_addr']
        assert envelope._subject == msg['subject']
        assert len(envelope._parts) == 2

        text_part = envelope._parts[0]
        assert text_part[0] == 'text/plain'
        assert text_part[1] == msg['text_body']
        assert text_part[2] == msg['charset']

        html_part = envelope._parts[1]
        assert html_part[0] == 'text/html'
        assert html_part[1] == msg['html_body']
        assert html_part[2] == msg['charset']

        assert envelope._cc == msg['cc_addr']
        assert envelope._bcc == msg['bcc_addr']
        assert envelope._headers == msg['headers']
        assert envelope._charset == msg['charset']

    def test_addr_tuple_to_addr(self):
        addr = Envelope()._addr_tuple_to_addr(('test@example.com', 'Test'))
        assert addr == 'Test <test@example.com>'

        addr = Envelope(charset='utf-8')._addr_tuple_to_addr((
            'test@example.com', ))
        assert addr == 'test@example.com'

    def test_addrs_to_header(self):
        addrs = [
            'test1@example.com',
            'Test2 <test2@example.com>',
            ('test3@example.com', 'Test3'),
        ]

        header = Envelope()._addrs_to_header(addrs)
        ok_header = (
            'test1@example.com,'
            'Test2 <test2@example.com>,'
            'Test3 <test3@example.com>'
        )

        assert header == ok_header

        try:
            header = Envelope()._addrs_to_header([1])
        except MessageEncodeError as exc:
            assert exc.args[0] == '1 is not a valid address'
        except:
            raise
        else:
            assert False, "MessageEncodeError not raised"

    def test_raise(self):
        try:
            Envelope()._raise(RuntimeError, u'ęóąśłżźćń')
        except RuntimeError as exc:
            assert exc.args[0] == encoded(u'ęóąśłżźćń', 'utf-8')
        except:
            raise
        else:
            assert 'RuntimeError not raised'

    def test_to_mime_message_with_data(self):
        msg = self._dummy_message()
        envelope = Envelope(**msg)

        mime_msg = envelope.to_mime_message()
        assert mime_msg is not None

        assert mime_msg['Subject'] == msg['subject']
        assert mime_msg['To'] == 'Example To <to@example.com>'
        assert mime_msg['From'] == 'Example From <from@example.com>'

        cc_header = (
            'cc1@example.com,'
            'Example CC2 <cc2@example.com>,'
            'Example CC3 <cc3@example.com>'
        )
        assert mime_msg['CC'] == cc_header
        assert 'BCC' not in mime_msg

        assert mime_msg['Reply-To'] == msg['headers']['Reply-To']
        assert mime_msg['X-Mailer'] == msg['headers']['X-Mailer']

        mime_msg_parts = [part for part in mime_msg.walk()]
        assert len(mime_msg_parts) == 3
        text_part, html_part = mime_msg_parts[1:]

        assert text_part.get_content_type() == 'text/plain'
        assert text_part.get_payload(decode=True) == msg['text_body'].encode('utf-8')

        assert html_part.get_content_type() == 'text/html'
        assert html_part.get_payload(decode=True) == msg['html_body'].encode('utf-8')

    def test_to_mime_message_with_many_to_addresses(self):
        msg = self._dummy_message()
        msg['to_addr'] = [
            'to1@example.com',
            'Example To2 <to2@example.com>',
            ('to3@example.com', 'Example To3')
        ]
        envelope = Envelope(**msg)

        mime_msg = envelope.to_mime_message()
        assert mime_msg is not None

        to_header = (
            'to1@example.com,'
            'Example To2 <to2@example.com>,'
            'Example To3 <to3@example.com>'
        )
        assert mime_msg['To'] == to_header

    def test_to_mime_message_with_no_data(self):
        envelope = Envelope()
        mime_msg = envelope.to_mime_message()

        assert mime_msg['Subject'] == ''
        assert mime_msg['To'] == ''
        assert mime_msg['From'] == ''

        assert 'CC' not in mime_msg
        assert 'BCC' not in mime_msg

        mime_msg_parts = [part for part in mime_msg.walk()]
        assert len(mime_msg_parts) == 1

    def test_to_mime_message_unicode(self):
        msg = {
            'to_addr': ('to@example.com', u'ęóąśłżźćń'),
            'from_addr': ('from@example.com', u'ęóąśłżźćń'),
            'subject': u'ęóąśłżźćń',
            'html_body': u'ęóąśłżźćń',
            'text_body': u'ęóąśłżźćń',
            'cc_addr': [
                ('cc@example.com', u'ęóąśłżźćń')
            ],
            'bcc_addr': [
                u'ęóąśłżźćń <bcc@example.com>'
            ],
            'headers': {
                'X-Test': u'ęóąśłżźćń'
            },
            'charset': 'utf-8'
        }

        envelope = Envelope(**msg)

        def enc_addr_header(name, email):
            header = Header(name)
            header.append(email)
            return header.encode()

        mime_msg = envelope.to_mime_message()
        assert mime_msg is not None

        assert mime_msg['Subject'] == Header(msg['subject'], 'utf-8').encode()
        assert mime_msg['To'] == enc_addr_header(u'ęóąśłżźćń', '<to@example.com>')
        assert mime_msg['From'] == enc_addr_header(u'ęóąśłżźćń', '<from@example.com>')

        assert mime_msg['CC'] == enc_addr_header(u'ęóąśłżźćń', '<cc@example.com>')

        assert 'BCC' not in mime_msg

        assert mime_msg['X-Test'] == Header(msg['headers']['X-Test'], 'utf-8').encode()

        mime_msg_parts = [part for part in mime_msg.walk()]
        assert len(mime_msg_parts) == 3
        text_part, html_part = mime_msg_parts[1:]

        assert text_part.get_content_type() == 'text/plain'
        assert text_part.get_payload(decode=True) == msg['text_body'].encode('utf-8')

        assert html_part.get_content_type() == 'text/html'
        assert html_part.get_payload(decode=True) == msg['html_body'].encode('utf-8')

    def test_send(self):
        envelope = Envelope(
            from_addr='spam@example.com',
            to_addr='eggs@example.com',
            subject='Testing envelopes!',
            text_body='Just a testy test.'
        )

        conn, result = envelope.send(host='localhost')
        assert conn._conn is not None
        assert len(conn._conn._call_stack.get('sendmail', [])) == 1

    def test_to_addr_property(self):
        msg = self._dummy_message()

        envelope = Envelope(**msg)
        assert envelope.to_addr == envelope._to

        msg.pop('to_addr')
        envelope = Envelope(**msg)
        assert envelope.to_addr == []

    def test_add_to_addr(self):
        msg = self._dummy_message()
        msg.pop('to_addr')

        envelope = Envelope(**msg)
        envelope.add_to_addr('to2@example.com')
        assert envelope.to_addr == ['to2@example.com']

    def test_clear_to_addr(self):
        msg = self._dummy_message()

        envelope = Envelope(**msg)
        envelope.clear_to_addr()
        assert envelope.to_addr == []

    def test_from_addr_property(self):
        envelope = Envelope(**self._dummy_message())
        assert envelope.from_addr == envelope._from

        envelope.from_addr = 'new@example.com'
        assert envelope.from_addr == 'new@example.com'

    def test_cc_addr_property(self):
        msg = self._dummy_message()

        envelope = Envelope(**msg)
        assert envelope.cc_addr == envelope._cc

        msg.pop('cc_addr')
        envelope = Envelope(**msg)
        assert envelope.cc_addr == []

    def test_add_cc_addr(self):
        msg = self._dummy_message()
        msg.pop('cc_addr')

        envelope = Envelope(**msg)
        envelope.add_cc_addr('cc@example.com')
        assert envelope.cc_addr == ['cc@example.com']

    def test_clear_cc_addr(self):
        msg = self._dummy_message()

        envelope = Envelope(**msg)
        envelope.clear_cc_addr()
        assert envelope.cc_addr == []

    def test_bcc_addr_property(self):
        msg = self._dummy_message()

        envelope = Envelope(**msg)
        assert envelope.bcc_addr == envelope._bcc

        msg.pop('bcc_addr')
        envelope = Envelope(**msg)
        assert envelope.bcc_addr == []

    def test_add_bcc_addr(self):
        msg = self._dummy_message()
        msg.pop('bcc_addr')

        envelope = Envelope(**msg)
        envelope.add_bcc_addr('bcc@example.com')
        assert envelope.bcc_addr == ['bcc@example.com']

    def test_clear_bcc_addr(self):
        msg = self._dummy_message()

        envelope = Envelope(**msg)
        envelope.clear_bcc_addr()
        assert envelope.bcc_addr == []

    def test_charset_property(self):
        envelope = Envelope()
        assert envelope.charset == envelope._charset

        envelope.charset = 'latin2'
        assert envelope._charset == 'latin2'

    def test_headers_property(self):
        msg = self._dummy_message()
        envelope = Envelope(**msg)

        assert envelope.headers == msg['headers']

    def test_add_header(self):
        msg = self._dummy_message()
        msg.pop('headers')
        envelope = Envelope(**msg)

        envelope.add_header('X-Spam', 'eggs')
        assert envelope.headers == {'X-Spam': 'eggs'}

    def test_clear_headers(self):
        msg = self._dummy_message()
        envelope = Envelope(**msg)

        envelope.clear_headers()
        assert envelope.headers == {}

    def test_add_attachment(self):
        msg = self._dummy_message()
        envelope = Envelope(**msg)

        _jpg = self._tempfile(suffix='.jpg')
        envelope.add_attachment(_jpg)

        _mp3 = self._tempfile(suffix='.mp3')
        envelope.add_attachment(_mp3)

        _pdf = self._tempfile(suffix='.pdf')
        envelope.add_attachment(_pdf)

        _something = self._tempfile(suffix='.something', prefix=u'ęóąśłżźćń')
        envelope.add_attachment(_something)

        _octet = self._tempfile(suffix='.txt')
        envelope.add_attachment(_octet, mimetype='application/octet-stream')

        assert len(envelope._parts) == 7

        assert envelope._parts[0][0] == 'text/plain'
        assert envelope._parts[1][0] == 'text/html'

        assert envelope._parts[2][0] == 'image/jpeg'
        assert envelope._parts[2][1]['Content-Disposition'] ==\
            'attachment; filename="%s"' % os.path.basename(_jpg)

        assert envelope._parts[3][0] == 'audio/mpeg'
        assert envelope._parts[3][1]['Content-Disposition'] ==\
            'attachment; filename="%s"' % os.path.basename(_mp3)

        assert envelope._parts[4][0] == 'application/pdf'
        assert envelope._parts[4][1]['Content-Disposition'] ==\
            'attachment; filename="%s"' % os.path.basename(_pdf)

        assert envelope._parts[5][0] == 'application/octet-stream'
        assert envelope._parts[5][1]['Content-Disposition'] ==\
            'attachment; filename="%s"' %\
            os.path.basename(encoded(_something, 'utf-8'))

        assert envelope._parts[6][0] == 'application/octet-stream'
        assert envelope._parts[6][1]['Content-Disposition'] ==\
            'attachment; filename="%s"' % os.path.basename(_octet)

    def test_repr(self):
        msg = self._dummy_message()
        envelope = Envelope(**msg)

        assert envelope.__repr__() == (
            u"""<Envelope from="Example From <from@example.com>" """
            u"""to="Example To <to@example.com>" """
            u"""subject="I'm a helicopter!">"""
        )

########NEW FILE########
