== Disclaimer ==
I hate writing GUI code, it makes me feel like a brainless monkey. On the
other hand, I wanted to show that RPyC can be easily incorporated into GUI
apps, like the GTK reactor. Yes, the code is horrible, but please, don't
judge a man by his GUI!


== Server Design ==
The ChatService exposes a single method, login, which clients call with their
credentials and a callback function. If the credentials are correct, a
"user-token" object is created and returned to the client. The client then
uses this user-token for performing actions on behalf of the user (currently
limited to say() and logout()). The callback function is used by the server
to notify clients of messages sent by other users.

This is not a sophisticated design (compare to IRC, for instance), but
it's a good show-case after all: instead of defining custom protocols, sending
a message to a chat server is analogous to calling a function on the server,
while receiving messages from the chat server is analogous to the server
calling an (async) function on the client. RPC at its best.

Also, do keep in mind the inherent securiy of this model: the server exposes
a well defined set of methods (so there's no risk of the client abusing
the server), while the server can't abuse the client because it can invoke
only a designated callback it is passed. This allows both parties not to
trust each other while still providing RPyC-grade servive.


== Threading issues ==
The server is multi-threaded and naturally has to be synchronized. The client,
at least the one I provide, is single-threaded.


== Client Design ==
With all the visual noise caused by the GUI code, it's easy to get lost on
the RPyC part. In short, this is the RPyC releated code:

	def on_message(text):
	    # server-side callback
	    textbox.append_line(text)

	conn = rpyc.connect("localhost", 19912)
	user_token = conn.root.login("foo", "bar", on_message)
	user_token.say("hello world")


a demonstation of events: the file monitor will send events to the client
(invoke an async callback) whenever a file is changed (as reported by os.stat)


rpycfs -- a remote file system (like sambda of nfs)

it should be quite easy, subclassing Fuse and exposing a file-system like
interface above it, and then use rpyc to perform the IOs, but i find
python-fuse to be quite confusing and i lost interest in the project.
sorry.
if someone wants to contribute the code, i'll happily include it in the demos.

it should look something like this:
    # server
    rpycfsd /path/to/expose --port=12345 --user=foo --password=bar

    # client
    /sbin/mount.rpycfs host:/relativepath /localpoint -o port=12345 -o user=foo -o password=bar


A canonical example of a basic service:
 * time_service.py defines the service
 * server.py exposes the service
 * client.py utilizes the service


"web8" -- a vision of how web development should have been...


`RPyC <http://rpyc.sourceforge.net>`_ (pronounced like *are-pie-see*), or *Remote Python Call*, 
is a **transparent** library for **symmetrical** `remote procedure calls 
<http://en.wikipedia.org/wiki/Remote_procedure_calls>`_, 
`clustering <http://en.wikipedia.org/wiki/Clustering>`_, and 
`distributed-computing <http://en.wikipedia.org/wiki/Distributed_computing>`_.
RPyC makes use of `object-proxying <http://en.wikipedia.org/wiki/Proxy_pattern>`_,
a technique that employs python's dynamic nature, to overcome the physical boundaries
between processes and computers, so that remote objects can be manipulated as if they were local.

.. figure:: http://rpyc.readthedocs.org/en/latest/_images/screenshot.png
   :align: center
   
   A screenshot of a Windows client connecting to a Linux server.
   
   Note that text written to the server's ``stdout`` is actually printed on 
   the server's console.


.. image:: https://d2weczhvl823v0.cloudfront.net/tomerfiliba/rpyc/trend.png
   :alt: Bitdeli badge
   :target: https://bitdeli.com/free


