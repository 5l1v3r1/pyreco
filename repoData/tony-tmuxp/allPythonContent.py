__FILENAME__ = bootstrap_env
#!/usr/bin/env python

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals


import os
import sys
import subprocess


def warning(*objs):
    print("WARNING: ", *objs, file=sys.stderr)


def fail(message):
    sys.exit("Error: {message}".format(message=message))


PY2 = sys.version_info[0] == 2
if PY2:
    from urllib import urlretrieve
else:
    from urllib.request import urlretrieve


def has_module(module_name):
    try:
        import imp
        imp.find_module(module_name)
        del imp
        return True
    except ImportError:
        return False


def which(exe=None, throw=True):
    """Return path of bin. Python clone of /usr/bin/which.

    from salt.util - https://www.github.com/saltstack/salt - license apache

    :param exe: Application to search PATHs for.
    :type exe: string
    :param throw: Raise ``Exception`` if not found in paths
    :type throw: bool
    :rtype: string

    """
    if exe:
        if os.access(exe, os.X_OK):
            return exe

        # default path based on busybox's default
        default_path = '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin'
        search_path = os.environ.get('PATH', default_path)

        for path in search_path.split(os.pathsep):
            full_path = os.path.join(path, exe)
            if os.access(full_path, os.X_OK):
                return full_path

        message = (
            '{0!r} could not be found in the following search '
            'path: {1!r}'.format(
                exe, search_path
            )
        )

        if throw:
            raise Exception(message)
        else:
            print(message)
    return None


project_dir = os.path.dirname(os.path.realpath(__file__))
env_dir = os.path.join(project_dir, '.env')
pip_bin = os.path.join(env_dir, 'bin', 'pip')
python_bin = os.path.join(env_dir, 'bin', 'python')
virtualenv_bin = which('virtualenv', throw=False)
virtualenv_exists = os.path.exists(env_dir) and os.path.isfile(python_bin)
sphinx_requirements_filepath = os.path.join(project_dir, 'doc', 'requirements.pip')


try:
    import virtualenv
except ImportError:
    message = (
        'Virtualenv is required for this bootstrap to run.\n'
        'Install virtualenv via:\n'
        '\t$ [sudo] pip install virtualenv'
    )
    fail(message)


try:
    import pip
except ImportError:
    message = (
        'pip is required for this bootstrap to run.\n'
        'Find instructions on how to install at: %s' %
        'http://pip.readthedocs.org/en/latest/installing.html'
    )
    fail(message)


def main():
    if not virtualenv_exists:
        virtualenv_bin = which('virtualenv', throw=False)

        subprocess.check_call(
            [virtualenv_bin, env_dir]
        )

        subprocess.check_call(
            [pip_bin, 'install', '-e', project_dir]
        )

    if not os.path.isfile(os.path.join(env_dir, 'bin', 'watching_testrunner')):
        subprocess.check_call(
            [pip_bin, 'install', 'watching-testrunner']
        )

    if not os.path.isfile(os.path.join(env_dir, 'bin', 'sphinx-quickstart')):
        subprocess.check_call(
            [pip_bin, 'install', '-r', sphinx_requirements_filepath]
        )

    if os.path.exists(os.path.join(env_dir, 'build')):
        os.removedirs(os.path.join(env_dir, 'build'))

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# tmuxp documentation build configuration file, created by
# sphinx-quickstart on Sun Sep  8 17:59:29 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
#import sphinx_rtd_theme

from tmuxp import __version__

# Get the project root dir, which is the parent dir of this
cwd = os.getcwd()
project_root = os.path.dirname(cwd)

# Insert the project root dir as the first element in the PYTHONPATH.
# This lets us ensure that the source package is imported, and that its
# version is used.
sys.path.insert(0, project_root)
from ..package_metadata import p

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------


# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc',
              'sphinx.ext.intersphinx',
              'sphinx.ext.todo',
              'sphinxcontrib.aafig',
              'sphinxarg.ext',
              ]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = p.title
copyright = p.copyright

rst_prolog = """
.. note::

    tmuxp is usable but still needs your help reporting errors, bugs and
    usability feedback. If you encounter an error, please post on the
    `Issue tracker`_.

.. _Issue tracker: https://github.com/tony/tmuxp/issues
"""

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '%s' % ('.'.join(p.version.split('.'))[:2])
# The full version, including alpha/beta/rc tags.
release = '%s' % (p.version)

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
on_rtd = os.environ.get('READTHEDOCS', None) == 'True'
if on_rtd:
    html_theme = 'default'
else:
    html_theme = 'pyramid'

#html_theme = 'sphinx_rtd_theme'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']
#html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]

# from pyramid_sphinx_themes import get_html_themes_path
# html_theme_path = get_html_themes_path()

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = '%sdoc' % p.title

# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', '{0}.tex'.format(p.package_name), '{0} Documentation'.format(p.title),
   p.author, 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', p.package_name, '{0} Documentation'.format(p.title),
    p.author, 1),
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    ('index', '{0}'.format(p.package_name), '{0} Documentation'.format(p.title),
    p.author, p.package_name, p.description, 'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

# aafig format, try to get working with pdf
aafig_format = dict(latex='pdf', html='png')

aafig_default_options = dict(
    scale=.75,
    aspect=0.5,
    proportional=True,
)

########NEW FILE########
__FILENAME__ = package_metadata
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import sys
import re

package_file = os.path.join(os.path.dirname(__file__), "tmuxp/__init__.py")
file_content = open(package_file, "rt").read()


class Package_Metadata(dict):
    __getattr__ = dict.__getitem__
    __setattr__ = dict.__setitem__

    attributes = [
        'title', 'package_name', 'author', 'description', 'email',
        'version', 'license', 'copyright'
    ]

    @staticmethod
    def get_attribute(attr, file_content):
        regex_expression = r"^__{0}__ = ['\"]([^'\"]*)['\"]".format(attr)
        mo = re.search(regex_expression, file_content, re.M)
        if mo:
            return mo.group(1)
        else:
            raise RuntimeError("Unable to find version string in %s." % (package_file,))

    def refresh(self, attributes):

        file_content = open(self.package_file, "rt").read()

        for k in attributes:
            attr_val = self.get_attribute(k, file_content)
            if attr_val:
                self[k] = attr_val

    def __init__(self, package_file, attributes=None):

        if attributes:
            self.attributes = attributes

        self.package_file = package_file

        self.refresh(self.attributes)


p = Package_Metadata(package_file)


def print_metadata():
    for k, v in p.items():
        print('%s: %s' % (k, v))

if __name__ == '__main__':
    print_metadata()
    sys.exit()

########NEW FILE########
__FILENAME__ = run-tests
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from tmuxp.testsuite import main
main()

########NEW FILE########
__FILENAME__ = cli
# -*- coding: utf-8 -*-
"""Command line tool for managing tmux workspaces and tmuxp configurations.

tmuxp.cli
~~~~~~~~~

"""
from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import sys
import argparse
import re
import logging

from distutils.util import strtobool

import argcomplete
import kaptan

from . import log, util, exc, WorkspaceBuilder, Server, config
from ._compat import ascii_lowercase, input, string_types
from .workspacebuilder import freeze


VERSIONFILE = os.path.join(
    os.path.abspath(os.path.dirname(__file__)), '__init__.py'
)
verstrline = open(VERSIONFILE, "rt").read()
VSRE = r"^__version__ = ['\"]([^'\"]*)['\"]"
mo = re.search(VSRE, verstrline, re.M)
if mo:
    __version__ = mo.group(1)

logger = logging.getLogger(__name__)

config_dir = os.path.expanduser('~/.tmuxp/')
cwd_dir = os.getcwd() + '/'
tmuxinator_config_dir = os.path.expanduser('~/.tmuxinator/')
teamocil_config_dir = os.path.expanduser('~/.teamocil/')


def prompt(name, default=None):
    """Return user input from command line.

    :meth:`~prompt`, :meth:`~prompt_bool` and :meth:`prompt_choices` are from
    `flask-script`_. See the `flask-script license`_.

    .. _flask-script: https://github.com/techniq/flask-script
    .. _flask-script license:
        https://github.com/techniq/flask-script/blob/master/LICENSE

    :param name: prompt text
    :param default: default value if no input provided.
    :rtype: string

    """

    prompt = name + (default and ' [%s]' % default or '')
    prompt += name.endswith('?') and ' ' or ': '
    while True:
        rv = input(prompt)
        if rv:
            return rv
        if default is not None:
            return default


def prompt_bool(name, default=False, yes_choices=None, no_choices=None):
    """Return user input from command line and converts to boolean value.

    :param name: prompt text
    :param default: default value if no input provided.
    :param yes_choices: default 'y', 'yes', '1', 'on', 'true', 't'
    :param no_choices: default 'n', 'no', '0', 'off', 'false', 'f'
    :rtype: bool

    """

    yes_choices = yes_choices or ('y', 'yes', '1', 'on', 'true', 't')
    no_choices = no_choices or ('n', 'no', '0', 'off', 'false', 'f')

    if default is None:
        prompt_choice = 'y/n'
    elif default is True:
        prompt_choice = 'Y/n'
    else:
        prompt_choice = 'y/N'

    prompt = name + ' [%s]' % prompt_choice
    prompt += name.endswith('?') and ' ' or ': '

    while True:
        rv = input(prompt)
        if not rv:
            return default
        if rv.lower() in yes_choices:
            return True
        elif rv.lower() in no_choices:
            return False


def prompt_yes_no(name, default=True):
    """:meth:`prompt_bool()` returning yes by default."""
    return prompt_bool(name, default=default)


def prompt_choices(name, choices, default=None, no_choice=('none',)):
    """Return user input from command line from set of provided choices.

    :param name: prompt text
    :param choices: list or tuple of available choices. Choices may be
                    single strings or (key, value) tuples.
    :param default: default value if no input provided.
    :param no_choice: acceptable list of strings for "null choice"
    :rtype: str

    """

    _choices = []
    options = []

    for choice in choices:
        if isinstance(choice, string_types):
            options.append(choice)
        else:
            options.append("%s [%s]" % (choice, choice[0]))
            choice = choice[0]
        _choices.append(choice)

    while True:
        rv = prompt(name + ' - (%s)' % ', '.join(options), default)
        if not rv:
            return default
        rv = rv.lower()
        if rv in no_choice:
            return None
        if rv in _choices:
            return rv


class ConfigFileCompleter(argcomplete.completers.FilesCompleter):

    """argcomplete completer for tmuxp files."""

    def __call__(self, prefix, **kwargs):

        completion = argcomplete.completers.FilesCompleter.__call__(
            self, prefix, **kwargs
        )

        completion += [os.path.join(config_dir, c)
                       for c in config.in_dir(config_dir)]

        return completion


class TmuxinatorCompleter(argcomplete.completers.FilesCompleter):

    """argcomplete completer for Tmuxinator files."""

    def __call__(self, prefix, **kwargs):
        completion = argcomplete.completers.FilesCompleter.__call__(
            self, prefix, **kwargs
        )

        tmuxinator_configs = config.in_dir(
            tmuxinator_config_dir, extensions='yml'
        )
        completion += [
            os.path.join(tmuxinator_config_dir, f)
            for f in tmuxinator_configs
        ]

        return completion


class TeamocilCompleter(argcomplete.completers.FilesCompleter):

    """argcomplete completer for Teamocil files."""

    def __call__(self, prefix, **kwargs):
        completion = argcomplete.completers.FilesCompleter.__call__(
            self, prefix, **kwargs
        )

        teamocil_configs = config.in_dir(teamocil_config_dir, extensions='yml')
        completion += [
            os.path.join(teamocil_config_dir, f)
            for f in teamocil_configs
        ]

        return completion


def SessionCompleter(prefix, parsed_args, **kwargs):
    """Return list of session names for argcomplete completer."""

    t = Server(
        socket_name=parsed_args.socket_name,
        socket_path=parsed_args.socket_path
    )

    sessions_available = [
        s.get('session_name') for s in t._sessions
        if s.get('session_name').startswith(' '.join(prefix))
    ]

    if parsed_args.session_name and sessions_available:
        return []

    return [
        s.get('session_name') for s in t._sessions
        if s.get('session_name').startswith(prefix)
    ]


def setup_logger(logger=None, level='INFO'):
    """Setup logging for CLI use.

    :param logger: instance of logger
    :type logger: :py:class:`Logger`

    """
    if not logger:
        logger = logging.getLogger()
    if not logger.handlers:
        channel = logging.StreamHandler()
        channel.setFormatter(log.DebugLogFormatter())

        # channel.setFormatter(log.LogFormatter())
        logger.setLevel(level)
        logger.addHandler(channel)


def startup(config_dir):
    """Initialize CLI.

    :param config_dir: Config directory to search
    :type config_dir: string

    """

    if not os.path.exists(config_dir):
        os.makedirs(config_dir)


def load_workspace(config_file, args):
    """Build config workspace.

    :param config_file: full path to config file
    :param type: string

    """

    sconfig = kaptan.Kaptan()
    sconfig = sconfig.import_config(config_file).get()
    # expands configurations relative to config / profile file location
    sconfig = config.expand(sconfig, os.path.dirname(config_file))
    sconfig = config.trickle(sconfig)

    t = Server(
        socket_name=args.socket_name,
        socket_path=args.socket_path,
        colors=args.colors
    )

    try:
        builder = WorkspaceBuilder(sconf=sconfig, server=t)
    except exc.EmptyConfigException:
        logger.error('%s is empty or parsed no config data' % config_file)
        return

    tmux_bin = util.which('tmux')

    try:
        logger.info('Loading %s.' % config_file)
        builder.build()

        if 'TMUX' in os.environ:
            if not args.detached and (args.answer_yes or prompt_yes_no(
                'Already inside TMUX, switch to session?'
            )):
                tmux_env = os.environ.pop('TMUX')
                builder.session.switch_client()

                os.environ['TMUX'] = tmux_env
                return
            else:
                sys.exit('Session created in detached state.')

        if not args.detached:
            builder.session.attach_session()
    except exc.TmuxSessionExists as e:
        if not args.detached and (
            args.answer_yes or prompt_yes_no('%s Attach?' % e)
        ):
            if 'TMUX' in os.environ:
                builder.session.switch_client()

            else:
                builder.session.attach_session()
        return
    except exc.TmuxpException as e:
        import traceback

        print(traceback.format_exc())
        logger.error(e)

        choice = prompt_choices(
            'Error loading workspace. (k)ill, (a)ttach, (d)etach?',
            choices=['k', 'a', 'd'],
            default='k'
        )

        if choice == 'k':
            builder.session.kill_session()
            print('Session killed.')
        elif choice == 'a':
            if 'TMUX' in os.environ:
                builder.session.switch_client()
            else:
                builder.session.attach_session()
        else:
            sys.exit()


def command_freeze(args):
    """Import teamocil config to tmuxp format."""

    ctext = ' '.join(args.session_name)

    t = Server(
        socket_name=args.socket_name,
        socket_path=args.socket_path,
        colors=args.colors
    )

    try:
        session = t.findWhere({
            'session_name': ctext
        })

        if not session:
            raise exc.TmuxpException('Session not found.')
    except exc.TmuxpException as e:
        print(e)
        return

    sconf = freeze(session)
    configparser = kaptan.Kaptan()
    newconfig = config.inline(sconf)
    configparser.import_config(newconfig)
    config_format = prompt_choices('Convert to', choices=[
        'yaml', 'json'], default='yaml')

    if config_format == 'yaml':
        newconfig = configparser.export(
            'yaml', indent=2, default_flow_style=False, safe=True
        )
    elif config_format == 'json':
        newconfig = configparser.export('json', indent=2)
    else:
        sys.exit('Unknown config format.')

    print(newconfig)
    print(
        '---------------------------------------------------------------')
    print(
        'Configuration import does its best to convert teamocil files.\n')
    if args.answer_yes or prompt_yes_no(
        'The new config *WILL* require adjusting afterwards. Save config?'
    ):
        dest = None
        while not dest:
            save_to = os.path.abspath(
                os.path.join(
                    config_dir,
                    '%s.%s' % (sconf.get('session_name'), config_format)
                )
            )
            dest_prompt = prompt('Save to: ', save_to)
            if os.path.exists(dest_prompt):
                print('%s exists. Pick a new filename.' % dest_prompt)
                continue

            dest = dest_prompt

        dest = os.path.abspath(os.path.relpath(os.path.expanduser(dest)))
        if args.answer_yes or prompt_yes_no('Save to %s?' % dest):
            destdir = os.path.dirname(dest)
            if not os.path.isdir(destdir):
                os.makedirs(destdir)
            buf = open(dest, 'w')
            buf.write(newconfig)
            buf.close()

            print('Saved to %s.' % dest)
    else:
        print(
            'tmuxp has examples in JSON and YAML format at '
            '<http://tmuxp.readthedocs.org/en/latest/examples.html>\n'
            'View tmuxp docs at <http://tmuxp.readthedocs.org/>.'
        )
        sys.exit()


def command_load(args):
    """Load a session from a tmuxp session file."""

    if isinstance(args.config, list):
        args.config = ' '.join(args.config)

    if '.' == args.config:
        if config.in_cwd():
            configfile = config.in_cwd()[0]
        else:
            sys.exit('No tmuxp configs found in current directory.')
    else:
        configfile = args.config

    file_user = os.path.join(config_dir, configfile)
    file_cwd = os.path.join(cwd_dir, configfile)

    if os.path.exists(file_cwd) and os.path.isfile(file_cwd):
        print('load %s' % file_cwd)
        load_workspace(file_cwd, args)
    elif os.path.exists(file_user) and os.path.isfile(file_user):
        load_workspace(file_user, args)
    else:
        logger.error('%s not found.' % configfile)


def command_import_teamocil(args):
    """Import teamocil config to tmuxp format."""

    if args.list:
        try:
            configs_in_user = config.in_dir(
                teamocil_config_dir, extensions='yml')
        except OSError:
            configs_in_user = []
        configs_in_cwd = config.in_dir(
            config_dir=cwd_dir, extensions='yml')

        output = ''

        if not os.path.exists(teamocil_config_dir):
            output += '# %s: \n\tDirectory doesn\'t exist.\n' % \
                teamocil_config_dir
        elif not configs_in_user:
            output += '# %s: \n\tNone found.\n' % teamocil_config_dir
        else:
            output += '# %s: \n\t%s\n' % (
                config_dir, ', '.join(configs_in_user)
            )

        if configs_in_cwd:
            output += '# current directory:\n\t%s' % (
                ', '.join(configs_in_cwd)
            )

        print(output)
    elif args.config:
        configfile = os.path.abspath(os.path.relpath(
            os.path.expanduser(args.config)))
        configparser = kaptan.Kaptan(handler='yaml')

        if os.path.exists(configfile):
            print(configfile)
            configparser.import_config(configfile)
            newconfig = config.import_teamocil(configparser.get())
            configparser.import_config(newconfig)
        else:
            sys.exit('File not found: %s' % configfile)

        config_format = prompt_choices('Convert to', choices=[
                                       'yaml', 'json'], default='yaml')

        if config_format == 'yaml':
            newconfig = configparser.export(
                'yaml', indent=2, default_flow_style=False
            )
        elif config_format == 'json':
            newconfig = configparser.export('json', indent=2)
        else:
            sys.exit('Unknown config format.')

        print(newconfig)
        print(
            '---------------------------------------------------------------')
        print(
            'Configuration import does its best to convert teamocil files.\n')
        if args.answer_yes or prompt_yes_no(
            'The new config *WILL* require adjusting afterwards. Save config?'
        ):
            dest = None
            while not dest:
                dest_prompt = prompt('Save to: ', os.path.abspath(
                    os.path.join(config_dir, 'myimport.%s' % config_format)))
                if os.path.exists(dest_prompt):
                    print('%s exists. Pick a new filename.' % dest_prompt)
                    continue

                dest = dest_prompt

            dest = os.path.abspath(os.path.relpath(os.path.expanduser(dest)))
            if args.answer_yes or prompt_yes_no('Save to %s?' % dest):
                buf = open(dest, 'w')
                buf.write(newconfig)
                buf.close()

                print('Saved to %s.' % dest)
        else:
            print(
                'tmuxp has examples in JSON and YAML format at '
                '<http://tmuxp.readthedocs.org/en/latest/examples.html>\n'
                'View tmuxp docs at <http://tmuxp.readthedocs.org/>'
            )
            sys.exit()


def command_import_tmuxinator(args):
    """Import tmuxinator config to tmuxp format."""
    if args.list:
            try:
                configs_in_user = config.in_dir(
                    tmuxinator_config_dir, extensions='yml')
            except OSError:
                configs_in_user = []
            configs_in_cwd = config.in_dir(
                config_dir=cwd_dir, extensions='yml')

            output = ''

            if not os.path.exists(tmuxinator_config_dir):
                output += '# %s: \n\tDirectory doesn\'t exist.\n' % \
                    tmuxinator_config_dir
            elif not configs_in_user:
                output += '# %s: \n\tNone found.\n' % tmuxinator_config_dir
            else:
                output += '# %s: \n\t%s\n' % (
                    config_dir, ', '.join(configs_in_user)
                )

            if configs_in_cwd:
                output += '# current directory:\n\t%s' % (
                    ', '.join(configs_in_cwd)
                )

            print(output)

    if args.config:
        configfile = os.path.abspath(os.path.relpath(
            os.path.expanduser(args.config)))
        configparser = kaptan.Kaptan(handler='yaml')

        if os.path.exists(configfile):
            print(configfile)
            configparser.import_config(configfile)
            newconfig = config.import_tmuxinator(configparser.get())
            configparser.import_config(newconfig)
        else:
            sys.exit('File not found: %s' % configfile)

        config_format = prompt_choices('Convert to', choices=[
                                       'yaml', 'json'], default='yaml')

        if config_format == 'yaml':
            newconfig = configparser.export(
                'yaml', indent=2, default_flow_style=False
            )
        elif config_format == 'json':
            newconfig = configparser.export('json', indent=2)
        else:
            sys.exit('Unknown config format.')

        print(newconfig)
        print(
            '---------------------------------------------------------------')
        print(
            'Configuration import does its best to convert tmuxinator files.\n')
        if args.answer_yes or prompt_yes_no(
            'The new config *WILL* require adjusting afterwards. Save config?'
        ):
            dest = None
            while not dest:
                dest_prompt = prompt('Save to: ', os.path.abspath(
                    os.path.join(config_dir, 'myimport.%s' % config_format)))
                if os.path.exists(dest_prompt):
                    print('%s exists. Pick a new filename.' % dest_prompt)
                    continue

                dest = dest_prompt

            dest = os.path.abspath(os.path.relpath(os.path.expanduser(dest)))
            if args.answer_yes or prompt_yes_no('Save to %s?' % dest):
                buf = open(dest, 'w')
                buf.write(newconfig)
                buf.close()

                print('Saved to %s.' % dest)
        else:
            print(
                'tmuxp has examples in JSON and YAML format at '
                '<http://tmuxp.readthedocs.org/en/latest/examples.html>\n'
                'View tmuxp docs at <http://tmuxp.readthedocs.org/>'
            )
            sys.exit()


def command_convert(args):
    """Convert tmuxp config to and from JSON and YAML."""

    try:
        configfile = args.config
    except exc.TmuxpException:
        print('Please enter a config')

    file_user = os.path.join(config_dir, configfile)
    file_cwd = os.path.join(cwd_dir, configfile)
    if os.path.exists(file_cwd) and os.path.isfile(file_cwd):
        fullfile = os.path.normpath(file_cwd)
        filename, ext = os.path.splitext(file_cwd)
    elif os.path.exists(file_user) and os.path.isfile(file_user):

        fullfile = os.path.normpath(file_user)
        filename, ext = os.path.splitext(file_user)
    else:
        logger.error('%s not found.' % configfile)
        return

    if 'json' in ext:
        if args.answer_yes or prompt_yes_no(
            'convert to <%s> to yaml?' % (fullfile)
        ):
            configparser = kaptan.Kaptan()
            configparser.import_config(configfile)
            newfile = fullfile.replace(ext, '.yaml')
            newconfig = configparser.export(
                'yaml', indent=2, default_flow_style=False
            )
            if args.answer_yes or prompt_yes_no(
                'Save config to %s?' % (newfile)
            ):
                buf = open(newfile, 'w')
                buf.write(newconfig)
                buf.close()
                print('New config saved to %s' % (newfile))
    elif 'yaml' in ext:
        if args.answer_yes or prompt_yes_no(
            'convert to <%s> to json?' % (fullfile)
        ):
            configparser = kaptan.Kaptan()
            configparser.import_config(configfile)
            newfile = fullfile.replace(ext, '.json')
            newconfig = configparser.export('json', indent=2)
            print(newconfig)
            if args.answer_yes or prompt_yes_no(
                'Save config to <%s>?' % (newfile)
            ):
                buf = open(newfile, 'w')
                buf.write(newconfig)
                buf.close()
                print('New config saved to <%s>.' % (newfile))


def command_attach_session(args):
    """Command to attach / switch client to a tmux session."""
    commands = []
    ctext = ' '.join(args.session_name)

    t = Server(
        socket_name=args.socket_name,
        socket_path=args.socket_path,
        colors=args.colors
    )

    try:
        session = next((s for s in t.sessions if s.get(
            'session_name') == ctext), None)
        if not session:
            raise exc.TmuxpException('Session not found.')
    except exc.TmuxpException as e:
        print(e)
        return

    if 'TMUX' in os.environ:
        del os.environ['TMUX']
        session.switch_client()
        print('Inside tmux client, switching client.')
    else:
        session.attach_session()
        print('Attaching client.')


def command_kill_session(args):
    """Command to kill a tmux session."""
    commands = []
    ctext = ' '.join(args.session_name)

    t = Server(
        socket_name=args.socket_name or None,
        socket_path=args.socket_path or None
    )

    try:
        session = next((s for s in t.sessions if s.get(
            'session_name') == ctext), None)
        if not session:
            raise exc.TmuxpException('Session not found.')
    except exc.TmuxpException as e:
        print(e)
        return

    try:
        session.kill_session()
        print("Killed session %s." % ctext)
    except exc.TmuxpException as e:
        logger.error(e)


def get_parser():
    """Return :py:class:`argparse.ArgumentParser` instance for CLI."""

    server_parser = argparse.ArgumentParser(add_help=False)

    server_parser.add_argument(
        '-L', dest='socket_name',
        default=None,
        help='socket name of tmux server. Same as tmux.',
        metavar='socket-name'
    )

    server_parser.add_argument(
        '-S',
        dest='socket_path',
        default=None,
        help='socket path of tmux server. Same as tmux.',
        metavar='socket-path'
    )

    server_parser.add_argument(
        '-y',
        dest='answer_yes',
        default=None,
        help='Always answer yes.',
        action='store_true'
    )

    parser = argparse.ArgumentParser(
        description='Launch tmux workspace. '
                    'Help documentation: <http://tmuxp.rtfd.org>.',
        parents=[server_parser]
    )

    client_parser = argparse.ArgumentParser(add_help=False)
    colorsgroup = client_parser.add_mutually_exclusive_group()

    colorsgroup.add_argument(
        '-2',
        dest='colors',
        action='store_const',
        const=256,
        help='Force tmux to assume the terminal supports 256 colours.',
    )

    colorsgroup.add_argument(
        '-8',
        dest='colors',
        action='store_const',
        const=88,
        help='Like -2, but indicates that the terminal supports 88 colours.',
    )

    parser.set_defaults(colors=None)

    subparsers = parser.add_subparsers(
        title='commands',
        description='valid commands',
    )

    kill_session = subparsers.add_parser(
        'kill-session',
        parents=[server_parser],
        help='Kill tmux session by name.'
    )
    kill_session.set_defaults(callback=command_kill_session)

    kill_session.add_argument(
        dest='session_name',
        type=str,
        nargs='+',
        default=None,
        help='Name of session',
    ).completer = SessionCompleter

    attach_session = subparsers.add_parser(
        'attach-session',
        parents=[server_parser, client_parser],
        help='If run from outside tmux, create a new client in the current '
             'terminal and attach it. If used from inside, switch the current '
             'client.'
    )
    attach_session.set_defaults(callback=command_attach_session)

    attach_session.add_argument(
        dest='session_name',
        nargs='+',
        type=str,
        help='Name of session',
    ).completer = SessionCompleter

    freeze = subparsers.add_parser(
        'freeze',
        parents=[server_parser],
        help='Create a snapshot of a tmux session and save it to JSON or YAML.'
    )
    freeze.set_defaults(callback=command_freeze)

    freeze.add_argument(
        dest='session_name',
        type=str,
        nargs='+',
        help='Name of session',
    ).completer = SessionCompleter

    load = subparsers.add_parser(
        'load',
        parents=[server_parser, client_parser],
        help='Load a configuration from file. Attach the session. If session '
             'already exists, offer to attach instead.'
    )

    load.add_argument(
        dest='config',
        type=str,
        nargs='+',
        help='List config available in working directory and config folder.'
    ).completer = ConfigFileCompleter(
        allowednames=('.yaml', '.json'), directories=False
    )
    load.set_defaults(callback=command_load)

    load.add_argument(
        '-d',
        dest='detached',
        default=None,
        help='Load a session without attaching to it.',
        action='store_true'
    )

    convert = subparsers.add_parser(
        'convert',
        help='Convert tmuxp config between YAML and JSON format.'
    )

    convert.add_argument(
        dest='config',
        type=str,
        default=None,
        help='Absolute or relative path to config file.'
    ).completer = ConfigFileCompleter(
        allowednames=('.yaml', '.json'), directories=False
    )

    convert.set_defaults(callback=command_convert)

    importparser = subparsers.add_parser(
        'import',
        help='Import configurations from teamocil and tmuxinator.'
    )
    importsubparser = importparser.add_subparsers(
        title='commands',
        description='valid commands',
        help='additional help'
    )

    import_teamocil = importsubparser.add_parser(
        'teamocil',
        help="Parse teamocil configurations into tmuxp format"
    )

    import_teamocilgroup = import_teamocil.add_mutually_exclusive_group(
        required=True
    )
    import_teamocilgroup.add_argument(
        '--list', dest='list', action='store_true',
        help='List configs in ~/.teamocil and current working directory.'
    )

    import_teamocilgroup.add_argument(
        dest='config',
        type=str,
        nargs='?',
        help='''\
        Checks current ~/.teamocil and current directory for yaml files.
        '''
    ).completer = TeamocilCompleter(allowednames=('.yml'), directories=False)
    import_teamocil.set_defaults(callback=command_import_teamocil)

    import_tmuxinator = importsubparser.add_parser(
        'tmuxinator',
        help="Parse teamocil configurations into tmuxp format"
    )

    import_tmuxinatorgroup = import_tmuxinator.add_mutually_exclusive_group(
        required=True)
    import_tmuxinatorgroup.add_argument(
        '--list', dest='list', action='store_true',
        help='List yaml configs in ~/.tmuxinator and current working directory.'
    )

    import_tmuxinatorgroup.add_argument(
        dest='config',
        type=str,
        nargs='?',
        help='''\
        Checks current ~/.tmuxinator and current directory for yaml files.
        '''
    ).completer = TmuxinatorCompleter(allowednames=('.yml'), directories=False)

    import_tmuxinator.set_defaults(callback=command_import_tmuxinator)

    # http://stackoverflow.com/questions/8521612/argparse-optional-subparser
    parser.add_argument(
        '-v', '--version', action='version',
        version='tmuxp %s' % __version__,
        help='Prints the tmuxp version',
    )

    return parser


def main():
    """Main CLI application."""

    parser = get_parser()

    argcomplete.autocomplete(parser, always_complete_options=False)

    args = parser.parse_args()

    setup_logger(
        level=args.log_level.upper() if 'log_level' in args else 'INFO'
    )

    try:
        util.has_required_tmux_version()
    except exc.TmuxpException as e:
        logger.error(e)
        sys.exit()

    util.oh_my_zsh_auto_title()

    t = Server(
        socket_name=args.socket_name,
        socket_path=args.socket_path,
        colors=args.colors
    )

    try:
        if not hasattr(args, 'callback'):
            parser.print_help()
        elif args.callback is command_load:
            command_load(args)
        elif args.callback is command_convert:
            command_convert(args)
        elif args.callback is command_import_teamocil:
            command_import_teamocil(args)
        elif args.callback is command_import_tmuxinator:
            command_import_tmuxinator(args)
        elif args.callback is command_freeze:
            command_freeze(args)
        elif args.callback is command_attach_session:
            command_attach_session(args)
        elif args.callback is command_kill_session:
            command_kill_session(args)
    except KeyboardInterrupt:
        pass

########NEW FILE########
__FILENAME__ = config
# -*- coding: utf-8 -*-
"""Configuration parsing and export for tmuxp.

tmuxp.config
~~~~~~~~~~~~

"""
from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import copy
import logging

from . import exc
from ._compat import string_types

logger = logging.getLogger(__name__)


def validate_schema(sconf):
    """Return True if config schema is correct.

    :param sconf: session configuration
    :type sconf: dict
    :rtype: bool

    """

    # verify session_name
    if not 'session_name' in sconf:
        raise exc.ConfigError('config requires "session_name"')

    if not 'windows' in sconf:
        raise exc.ConfigError('config requires list of "windows"')

    for window in sconf['windows']:
        if not 'window_name' in window:
            raise exc.ConfigError('config window is missing "window_name"')

        if not 'panes' in window:
            raise exc.ConfigError(
                'config window %s requires list of panes' %
                window['window_name']
            )

    return True


def is_config_file(filename, extensions=['.yml', '.yaml', '.json']):
    """Return True if file has a valid config file type.

    :param filename: filename to check (e.g. ``mysession.json``).
    :type filename: string
    :param extensions: filetypes to check (e.g. ``['.yaml', '.json']``).
    :type extensions: list or string
    :rtype: bool

    """

    extensions = [extensions] if isinstance(
        extensions, string_types) else extensions
    return any(filename.endswith(e) for e in extensions)


def in_dir(
    config_dir=os.path.expanduser('~/.tmuxp'),
    extensions=['.yml', '.yaml', '.json']
):
    """Return a list of configs in ``config_dir``.

    :param config_dir: directory to search
    :type config_dir: string
    :param extensions: filetypes to check (e.g. ``['.yaml', '.json']``).
    :type extensions: list
    :rtype: list

    """
    configs = []

    for filename in os.listdir(config_dir):
        if is_config_file(filename, extensions) and \
           not filename.startswith('.'):
            configs.append(filename)

    return configs


def in_cwd():
    """Return list of configs in current working directory.

    If filename is ``.tmuxp.py``, ``.tmuxp.json``, ``.tmuxp.yaml``.

    :rtype: list

    """
    configs = []

    for filename in os.listdir(os.getcwd()):
        if filename.startswith('.tmuxp') and is_config_file(filename):
            configs.append(filename)

    return configs


def inline(sconf):
    """ Return config in inline form, opposite of :meth:`config.expand`.

    :param sconf: unexpanded config file
    :type sconf: dict
    :rtype: dict

    """

    if (
        'shell_command' in sconf and
        isinstance(sconf['shell_command'], list) and
        len(sconf['shell_command']) == 1
    ):
        sconf['shell_command'] = sconf['shell_command'][0]

        if len(sconf.keys()) == int(1):
            sconf = sconf['shell_command']
    if (
        'shell_command_before' in sconf and
        isinstance(sconf['shell_command_before'], list) and
        len(sconf['shell_command_before']) == 1
    ):
        sconf['shell_command_before'] = sconf['shell_command_before'][0]

    # recurse into window and pane config items
    if 'windows' in sconf:
        sconf['windows'] = [
            inline(window) for window in sconf['windows']
        ]
    if 'panes' in sconf:
        sconf['panes'] = [inline(pane) for pane in sconf['panes']]

    return sconf


def expand(sconf, cwd=None):
    """Return config with shorthand and inline properties expanded.

    This is necessary to keep the code in the :class:`WorkspaceBuilder` clean
    and also allow for neat, short-hand configurations.

    As a simple example, internally, tmuxp expects that config options
    like ``shell_command`` are a list (array)::

        'shell_command': ['htop']

    tmuxp configs allow for it to be simply a string::

        'shell_command': 'htop'

    Kaptan will load JSON/YAML files into python dicts for you.

    :param sconf: the configuration for the session
    :type sconf: dict
    :param cwd: directory to expand relative paths against. should be the dir
                of the config directory.
    :rtype: dict

    """

    # Note: cli.py will expand configs relative to project's config directory
    # for the first cwd argument.
    if not cwd:
        cwd = os.getcwd()

    # Any config section, session, window, pane that can contain the
    # 'shell_command' value
    if 'start_directory' in sconf:
        start_path = sconf['start_directory']
        if any(start_path.startswith(a) for a in ['.', './']):
            start_path = os.path.normpath(os.path.join(cwd, start_path))
            sconf['start_directory'] = start_path

    if 'before_script' in sconf:
        before_script = sconf['before_script']
        if any(before_script.startswith(a) for a in ['.', './']):
            before_script = os.path.normpath(os.path.join(cwd, before_script))
            sconf['before_script'] = before_script

    if (
        'shell_command' in sconf and
        isinstance(sconf['shell_command'], string_types)
    ):
        sconf['shell_command'] = [sconf['shell_command']]

    if (
        'shell_command_before' in sconf and
        isinstance(sconf['shell_command_before'], string_types)
    ):
        sconf['shell_command_before'] = [sconf['shell_command_before']]

    # recurse into window and pane config items
    if 'windows' in sconf:
        sconf['windows'] = [
            expand(window) for window in sconf['windows']
        ]
    elif 'panes' in sconf:

        for pconf in sconf['panes']:
            p_index = sconf['panes'].index(pconf)
            p = copy.deepcopy(pconf)
            pconf = sconf['panes'][p_index] = {}

            if isinstance(p, string_types):
                p = {
                    'shell_command': [p]
                }
            elif not p:
                p = {
                    'shell_command': []
                }

            assert isinstance(p, dict)
            if 'shell_command' in p:
                cmd = p['shell_command']

                if isinstance(p['shell_command'], string_types):
                    cmd = [cmd]

                if not cmd or any(a == cmd for a in [None, 'blank', 'pane']):
                    cmd = []

                if isinstance(cmd, list) and len(cmd) == int(1):
                    if any(a in cmd for a in [None, 'blank', 'pane']):
                        cmd = []

                p['shell_command'] = cmd
            else:
                p['shell_command'] = []

            pconf.update(p)
        sconf['panes'] = [expand(pane) for pane in sconf['panes']]

    return sconf


def trickle(sconf):
    """Return a dict with "trickled down" / inherited config values.

    This will only work if config has been expanded to full form with
    :meth:`config.expand`.

    tmuxp allows certain commands to be default at the session, window
    level. shell_command_before trickles down and prepends the
    ``shell_command`` for the pane.

    :param sconf: the session configuration
    :type sconf: dict
    :rtype: dict

    """

    # prepends a pane's ``shell_command`` list with the window and sessions'
    # ``shell_command_before``.

    if 'start_directory' in sconf:
        session_start_directory = sconf['start_directory']
    else:
        session_start_directory = None

    for windowconfig in sconf['windows']:

        # Prepend start_directory to relative window commands
        if session_start_directory:
            if not 'start_directory' in windowconfig:
                windowconfig['start_directory'] = session_start_directory
            else:
                if not any(
                    windowconfig['start_directory'].startswith(a)
                    for a in ['~', '/']
                ):
                    window_start_path = os.path.join(
                        session_start_directory, windowconfig['start_directory']
                    )
                    windowconfig['start_directory'] = window_start_path

        for paneconfig in windowconfig['panes']:
            commands_before = []

            # Prepend shell_command_before to commands
            if 'shell_command_before' in sconf:
                commands_before.extend(sconf['shell_command_before'])
            if 'shell_command_before' in windowconfig:
                commands_before.extend(windowconfig['shell_command_before'])
            if 'shell_command_before' in paneconfig:
                commands_before.extend(paneconfig['shell_command_before'])

            if 'shell_command' in paneconfig:
                commands_before.extend(paneconfig['shell_command'])

            p_index = windowconfig['panes'].index(paneconfig)
            windowconfig['panes'][p_index]['shell_command'] = commands_before
            #paneconfig['shell_command'] = commands_before

    return sconf


def import_tmuxinator(sconf):
    """Return tmuxp config from a `tmuxinator`_ yaml config.

    .. _tmuxinator: https://github.com/aziz/tmuxinator

    :param sconf: python dict for session configuration
    :type sconf: dict
    :rtype: dict

    """

    tmuxp_config = {}

    if 'project_name' in sconf:
        tmuxp_config['session_name'] = sconf.pop('project_name')
    elif 'name' in sconf:
        tmuxp_config['session_name'] = sconf.pop('name')
    else:
        tmuxp_config['session_name'] = None

    if 'project_root' in sconf:
        tmuxp_config['start_directory'] = sconf.pop('project_root')

    if 'cli_args' in sconf:
        tmuxp_config['config'] = sconf['cli_args']

        if '-f' in tmuxp_config['config']:
            tmuxp_config['config'] = tmuxp_config[
                'config'
            ].replace('-f', '').strip()
    elif 'tmux_options' in sconf:
        tmuxp_config['config'] = sconf['tmux_options']

        if '-f' in tmuxp_config['config']:
            tmuxp_config['config'] = tmuxp_config[
                'config'
            ].replace('-f', '').strip()

    if 'socket_name' in sconf:
        tmuxp_config['socket_name'] = sconf['socket_name']

    tmuxp_config['windows'] = []

    if 'tabs' in sconf:
        sconf['windows'] = sconf.pop('tabs')

    if 'pre' in sconf and 'pre_window' in sconf:
        tmuxp_config['shell_command'] = sconf['pre']

        if isinstance(sconf['pre'], string_types):
            tmuxp_config['shell_command_before'] = [sconf['pre_window']]
        else:
            tmuxp_config['shell_command_before'] = sconf['pre_window']
    elif 'pre' in sconf:
        if isinstance(sconf['pre'], string_types):
            tmuxp_config['shell_command_before'] = [sconf['pre']]
        else:
            tmuxp_config['shell_command_before'] = sconf['pre']

    if 'rbenv' in sconf:
        if 'shell_command_before' not in tmuxp_config:
            tmuxp_config['shell_command_before'] = []
        tmuxp_config['shell_command_before'].append(
            'rbenv shell %s' % sconf['rbenv']
        )

    for w in sconf['windows']:
        for k, v in w.items():

            windowdict = {}

            windowdict['window_name'] = k

            if isinstance(v, string_types) or v is None:
                windowdict['panes'] = [v]
                tmuxp_config['windows'].append(windowdict)
                continue
            elif isinstance(v, list):
                windowdict['panes'] = v
                tmuxp_config['windows'].append(windowdict)
                continue

            if 'pre' in v:
                windowdict['shell_command_before'] = v['pre']
            if 'panes' in v:
                windowdict['panes'] = v['panes']

            if 'layout' in v:
                windowdict['layout'] = v['layout']
            tmuxp_config['windows'].append(windowdict)
    return tmuxp_config


def import_teamocil(sconf):
    """Return tmuxp config from a `teamocil`_ yaml config.

    .. _teamocil: https://github.com/remiprev/teamocil

    :todo: change  'root' to a cd or start_directory
    :todo: width in pane -> main-pain-width
    :todo: with_env_var
    :todo: clear
    :todo: cmd_separator

    :param sconf: python dict for session configuration
    :type sconf: dict

    """

    tmuxp_config = {}

    if 'session' in sconf:
        sconf = sconf['session']

    if 'name' in sconf:
        tmuxp_config['session_name'] = sconf['name']
    else:
        tmuxp_config['session_name'] = None

    if 'root' in sconf:
        tmuxp_config['start_directory'] = sconf.pop('root')

    tmuxp_config['windows'] = []

    for w in sconf['windows']:

        windowdict = {}

        windowdict['window_name'] = w['name']
        if 'clear' in w:
            windowdict['clear'] = w['clear']

        if 'filters' in w:
            if 'before' in w['filters']:
                for b in w['filters']['before']:
                    windowdict['shell_command_before'] = w['filters']['before']
            if 'after' in w['filters']:
                for b in w['filters']['after']:
                    windowdict['shell_command_after'] = w['filters']['after']

        if 'root' in w:
            windowdict['start_directory'] = w.pop('root')

        if 'splits' in w:
            w['panes'] = w.pop('splits')

        if 'panes' in w:
            for p in w['panes']:
                if 'cmd' in p:
                    p['shell_command'] = p.pop('cmd')
                if 'width' in p:
                    # todo support for height/width
                    p.pop('width')
            windowdict['panes'] = w['panes']

        if 'layout' in w:
            windowdict['layout'] = w['layout']
        tmuxp_config['windows'].append(windowdict)

    return tmuxp_config

########NEW FILE########
__FILENAME__ = exc
# -*- coding: utf-8 -*-
"""Exceptions for tmuxp.

tmuxp.exc
~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import subprocess

from ._compat import implements_to_string


class TmuxpException(Exception):

    """Base Exception for Tmuxp Errors.

    Also for Python 2.6 compat:
        http://stackoverflow.com/a/6029838

    """


class TmuxSessionExists(TmuxpException):

    """Session does not exist in the server."""

    pass


class ConfigError(TmuxpException):

    """Error parsing tmuxp configuration dict."""

    pass


class EmptyConfigException(ConfigError):

    """Configuration is empty."""

    pass


class BeforeLoadScriptNotExists(OSError):

    def __init__(self, *args, **kwargs):
        super(BeforeLoadScriptNotExists, self).__init__(*args, **kwargs)

        self.strerror = "before_script file '%s' doesn't exist." % self.strerror


@implements_to_string
class BeforeLoadScriptError(Exception):

    """Exception replacing :py:class:`subprocess.CalledProcessError` for
    :meth:`util.run_before_script`.
    """

    def __init__(self, returncode, cmd, output=None):
        self.returncode = returncode
        self.cmd = cmd
        self.output = output
        self.message = (
            'before_script failed with returncode {returncode}.\n'
            'command: {cmd}\n'
            'Error output:\n'
            '{output}'
        ).format(returncode=self.returncode, cmd=self.cmd, output=self.output)

    def __str__(self):
        return self.message

########NEW FILE########
__FILENAME__ = formats
# -*- coding: utf-8 -*-
"""Format variables for tmux objects.

tmuxp.formats
~~~~~~~~~~~~~

For reference: http://sourceforge.net/p/tmux/tmux-code/ci/master/tree/format.c

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals


SESSION_FORMATS = [
    'session_name',
    'session_windows',
    'session_width',
    'session_height',
    'session_id',
    'session_created',
    'session_created_string',
    'session_attached',
    'session_grouped',
    'session_group',
]

CLIENT_FORMATS = [
    'client_cwd',
    'client_height',
    'client_width',
    'client_tty',
    'client_termname',
    'client_created',
    'client_created_string',
    'client_activity',
    'client_activity_string',
    'client_prefix',
    'client_utf8',
    'client_readonly',
    'client_session',
    'client_last_session',
]

WINDOW_FORMATS = [
    # format_window()
    'window_id',
    'window_name',
    'window_width',
    'window_height',
    'window_layout',
    'window_panes',
    # format_winlink()
    'window_index',
    'window_flags',
    'window_active',
    'window_bell_flag',
    'window_activity_flag',
    'window_silence_flag',
]

PANE_FORMATS = [
    'history_size',
    'history_limit',
    'history_bytes',
    'pane_index',
    'pane_width',
    'pane_height',
    'pane_title',
    'pane_id',
    'pane_active',
    'pane_dead',
    'pane_in_mode',
    'pane_synchronized',
    'pane_tty',
    'pane_pid',
    'pane_start_command',
    'pane_start_path',
    'pane_current_path',
    'pane_current_command',

    'cursor_x',
    'cursor_y',
    'scroll_region_upper',
    'scroll_region_lower',
    'saved_cursor_x',
    'saved_cursor_y',

    'alternate_on',
    'alternate_saved_x',
    'alternate_saved_y',

    'cursor_flag',
    'insert_flag',
    'keypad_cursor_flag',
    'keypad_flag',
    'wrap_flag',

    'mouse_standard_flag',
    'mouse_button_flag',
    'mouse_any_flag',
    'mouse_utf8_flag',
]

########NEW FILE########
__FILENAME__ = log
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Log utilities for tmuxp.

tmuxp.log
~~~~~~~~~

"""
from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import logging
import time

from ._vendor.colorama import init
from ._vendor.colorama import Fore, Back, Style

LEVEL_COLORS = {
    'DEBUG': Fore.BLUE,  # Blue
    'INFO': Fore.GREEN,  # Green
    'WARNING': Fore.YELLOW,
    'ERROR': Fore.RED,
    'CRITICAL': Fore.RED
}


def default_log_template(self, record):
    """Return the prefix for the log message. Template for Formatter.

    :param: record: :py:class:`logging.LogRecord` object. this is passed in
    from inside the :py:meth:`logging.Formatter.format` record.

    """

    reset = Style.RESET_ALL
    levelname = (
        LEVEL_COLORS.get(record.levelname) + Style.BRIGHT +
        '(%(levelname)s)'
        + Style.RESET_ALL + ' '
    )
    asctime = (
        '[' + Fore.BLACK + Style.DIM + Style.BRIGHT +
        '%(asctime)s'
        + Fore.RESET + Style.RESET_ALL + ']'
    )
    name = (
        ' ' + Fore.WHITE + Style.DIM + Style.BRIGHT +
        '%(name)s'
        + Fore.RESET + Style.RESET_ALL + ' '
    )

    tpl = reset + levelname + asctime + name + reset

    return tpl


class LogFormatter(logging.Formatter):

    template = default_log_template

    def __init__(self, color=True, *args, **kwargs):
        logging.Formatter.__init__(self, *args, **kwargs)

    def format(self, record):
        try:
            record.message = record.getMessage()
        except Exception as e:
            record.message = "Bad message (%r): %r" % (e, record.__dict__)

        date_format = '%H:%m:%S'
        record.asctime = time.strftime(
            date_format, self.converter(record.created)
        )

        prefix = self.template(record) % record.__dict__

        formatted = prefix + " " + record.message
        return formatted.replace("\n", "\n    ")


def debug_log_template(self, record):
    """ Return the prefix for the log message. Template for Formatter.

    :param: record: :py:class:`logging.LogRecord` object. this is passed in
    from inside the :py:meth:`logging.Formatter.format` record.

    """

    reset = Style.RESET_ALL
    levelname = (
        LEVEL_COLORS.get(record.levelname) + Style.BRIGHT +
        '(%(levelname)1.1s)'
        + Style.RESET_ALL + ' '
    )
    asctime = (
        '[' + Fore.BLACK + Style.DIM + Style.BRIGHT +
        '%(asctime)s'
        + Fore.RESET + Style.RESET_ALL + ']'
    )
    name = (
        ' ' + Fore.WHITE + Style.DIM + Style.BRIGHT +
        '%(name)s'
        + Fore.RESET + Style.RESET_ALL + ' '
    )
    module_funcName = (
        Fore.GREEN + Style.BRIGHT +
        '%(module)s.%(funcName)s()'
    )
    lineno = (
        Fore.BLACK + Style.DIM + Style.BRIGHT + ':' + Style.RESET_ALL +
        Fore.CYAN + '%(lineno)d'
    )

    tpl = reset + levelname + asctime + name + module_funcName + lineno + reset

    return tpl


class DebugLogFormatter(LogFormatter):

    """Provides greater technical details than standard log Formatter."""

    template = debug_log_template

########NEW FILE########
__FILENAME__ = pane
# -*- coding: utf-8 -*-
"""Pythonization of the :ref:`tmux(1)` pane.

tmuxp.pane
~~~~~~~~~~

"""
from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import logging

from . import util, formats, exc


logger = logging.getLogger(__name__)


class Pane(util.TmuxMappingObject, util.TmuxRelationalObject):

    """:term:`tmux(1)` :ref:`pane`.

    :param window: :class:`Window`

    """

    def __init__(self, window=None, **kwargs):
        if not window:
            raise ValueError('Pane must have \
                             ``Window`` object')

        self.window = window
        self.session = self.window.session
        self.server = self.session.server

        self._pane_id = kwargs['pane_id']

        self.server._update_panes()

    @property
    def _TMUX(self, *args):

        attrs = {
            'pane_id': self._pane_id
        }

        # from https://github.com/serkanyersen/underscore.py
        def by(val, *args):
            for key, value in attrs.items():
                try:
                    if attrs[key] != val[key]:
                        return False
                except KeyError:
                    return False
                return True

        return list(filter(by, self.server._panes))[0]

    def tmux(self, cmd, *args, **kwargs):
        """Return :meth:`Server.tmux` defaulting to ``target_pane`` as target.

        Send command to tmux with :attr:`pane_id` as ``target-pane``.

        Specifying ``('-t', 'custom-target')`` or ``('-tcustom_target')`` in
        ``args`` will override using the object's ``pane_id`` as target.

        :rtype: :class:`Server.tmux`

        """
        if not any(arg.startswith('-t') for arg in args):
            args = ('-t', self.get('pane_id')) + args

        return self.server.tmux(cmd, *args, **kwargs)

    def send_keys(self, cmd, enter=True):
        """``$ tmux send-keys`` to the pane.

        :param cmd: Text or input into pane
        :type cmd: str
        :param enter: Send enter after sending the input.
        :type enter: bool

        """
        self.tmux('send-keys', ' ' + cmd)

        if enter:
            self.enter()

    def clear(self):
        """Clear pane."""
        self.send_keys('reset')

    def reset(self):
        """Reset and clear pane history. """

        self.tmux('send-keys', '-R \; clear-history')

    def split_window(self, attach=False):
        """Split window at pane and return newly created :class:`Pane`.

        :param attach: Attach / select pane after creation.
        :type attach: bool
        :rtype: :class:`Pane`.

        """
        return self.window.split_window(
            target=self.get('pane_id'),
            attach=attach
        )

    def set_width(self, width):
        """Set width of pane.

        :param width: pane width, in cells.
        :type width: int

        """
        self.resize_pane(width=width)

    def set_height(self, height):
        """Set height of pane.

        :param height: pane height, in cells.
        :type height: int

        """
        self.resize_pane(height=height)

    def resize_pane(self, *args, **kwargs):
        """``$ tmux resize-pane`` of pane and return ``self``.

        :param target_pane: ``target_pane``, or ``-U``,``-D``, ``-L``, ``-R``.
        :type target_pane: string
        :rtype: :class:`Pane`

        """

        if 'height' in kwargs:
            proc = self.tmux('resize-pane', '-y%s' % int(kwargs['height']))
        elif 'width' in kwargs:
            proc = self.tmux('resize-pane', '-x%s' % int(kwargs['width']))
        else:
            proc = self.tmux('resize-pane', args[0])

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        self.server._update_panes()
        return self

    def enter(self):
        """Send carriage return to pane.

        ``$ tmux send-keys`` send Enter to the pane.

        """
        self.tmux('send-keys', 'Enter')

    def select_pane(self):
        """Select pane. Return ``self``.

        To select a window object asynchrously. If a ``pane`` object exists
        and is no longer longer the current window, ``w.select_pane()``
        will make ``p`` the current pane.

        :rtype: :class:`pane`

        """
        return self.window.select_pane(self.get('pane_id'))

    def __repr__(self):
        return "%s(%s %s)" % (
            self.__class__.__name__,
            self.get('pane_id'),
            self.window
        )

########NEW FILE########
__FILENAME__ = server
# -*- coding: utf-8 -*-
"""Pythonization of the :term:`tmux(1)` server.

tmuxp.server
~~~~~~~~~~~~

"""
from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import logging

from .util import tmux, TmuxRelationalObject
from .session import Session
from . import formats, exc

logger = logging.getLogger(__name__)


class Server(TmuxRelationalObject):

    """The :term:`tmux(1)` server.

    - :attr:`Server._sessions` [:class:`Session`, ...]

      - :attr:`Session._windows` [:class:`Window`, ...]

        - :attr:`Window._panes` [:class:`Pane`, ...]

          - :class:`Pane`

    When instantiated, provides the ``t`` global. stores information on live,
    running tmux server.

    """

    #: ``[-L socket-name]``
    socket_name = None
    #: ``[-S socket-path]``
    socket_path = None
    #: ``[-f file]``
    config_file = None
    #: ``-2`` or ``-8``
    colors = None
    #: unique child ID key
    childIdAttribute = 'session_id'

    def __init__(
        self,
        socket_name=None,
        socket_path=None,
        config_file=None,
        colors=None,
        **kwargs
    ):
        self._windows = []
        self._panes = []

        if socket_name:
            self.socket_name = socket_name

        if socket_path:
            self.socket_path = socket_path

        if config_file:
            self.config_file = config_file

        if colors:
            self.colors = colors

    def tmux(self, *args, **kwargs):
        """Return :class:`util.tmux` send tmux commands with sockets, colors.

        :rtype: :class:`util.tmux`

        """

        args = list(args)
        if self.socket_name:
            args.insert(0, '-L{0}'.format(self.socket_name))
        if self.socket_path:
            args.insert(0, '-S{0}'.format(self.socket_path))
        if self.config_file:
            args.insert(0, '-f{0}'.format(self.config_file))
        if self.colors:
            if self.colors == 256:
                args.insert(0, '-2')
            elif self.colors == 88:
                args.insert(0, '-8')
            else:
                raise ValueError('Server.colors must equal 88 or 256')

        return tmux(*args, **kwargs)

    def _list_sessions(self):
        """Return list of sessions in :py:obj:`dict` form.

        Retrieved from ``$ tmux(1) list-sessions`` stdout.

        The :py:obj:`list` is derived from ``stdout`` in :class:`util.tmux`
        which wraps :py:meth:`Subprocess.Popen`.

        :rtype: :py:obj:`list` of :py:obj:`dict`

        """

        sformats = formats.SESSION_FORMATS
        tmux_formats = ['#{%s}' % f for f in sformats]

        tmux_args = (
            '-F%s' % '\t'.join(tmux_formats),   # output
        )

        proc = self.tmux(
            'list-sessions',
            *tmux_args
        )

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)
        else:
            session_info = proc.stdout[0]

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        sformats = formats.SESSION_FORMATS
        tmux_formats = ['#{%s}' % format for format in sformats]
        sessions = proc.stdout

        # combine format keys with values returned from ``tmux list-windows``
        sessions = [dict(zip(
            sformats, session.split('\t'))) for session in sessions]

        # clear up empty dict
        sessions = [
            dict((k, v) for k, v in session.items() if v)
            for session in sessions
        ]

        return sessions

    @property
    def _sessions(self):
        """Property / alias to return :meth:`~._list_sessions`."""

        return self._list_sessions()

    def list_sessions(self):
        """Return list of :class:`Session` from the ``tmux(1)`` session.

        :rtype: :py:obj:`list` of :class:`Session`

        """
        return [
            Session(server=self, **s) for s in self._sessions
        ]

    @property
    def sessions(self):
        """Property / alias to return :meth:`~.list_sessions`."""
        return self.list_sessions()
    #: Alias of :attr:`sessions`.
    children = sessions

    def _list_windows(self):
        """Return list of windows in :py:obj:`dict` form.

        Retrieved from ``$ tmux(1) list-windows`` stdout.

        The :py:obj:`list` is derived from ``stdout`` in :class:`util.tmux`
        which wraps :py:meth:`Subprocess.Popen`.

        :rtype: list

        """

        wformats = ['session_name', 'session_id'] + formats.WINDOW_FORMATS
        tmux_formats = ['#{%s}' % format for format in wformats]

        proc = self.tmux(
            'list-windows',                     # ``tmux list-windows``
            '-a',
            '-F%s' % '\t'.join(tmux_formats),   # output
        )

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        windows = proc.stdout

        wformats = ['session_name', 'session_id'] + formats.WINDOW_FORMATS

        # combine format keys with values returned from ``tmux list-windows``
        windows = [dict(zip(
            wformats, window.split('\t'))) for window in windows]

        # clear up empty dict
        windows = [
            dict((k, v) for k, v in window.items() if v) for window in windows
        ]

        # tmux < 1.8 doesn't have window_id, use window_name
        for w in windows:
            if not 'window_id' in w:
                w['window_id'] = w['window_name']

        if self._windows:
            # http://stackoverflow.com/a/14465359
            self._windows[:] = []

        self._windows.extend(windows)

        return self._windows

    def _update_windows(self):
        """Update internal window data and return ``self`` for chainability.

        :rtype: :class:`Server`

        """
        self._list_windows()
        return self

    def _list_panes(self):
        """Return list of panes in :py:obj:`dict` form.

        Retrieved from ``$ tmux(1) list-panes`` stdout.

        The :py:obj:`list` is derived from ``stdout`` in :class:`util.tmux`
        which wraps :py:meth:`Subprocess.Popen`.

        :rtype: list

        """

        pformats = [
            'session_name', 'session_id',
            'window_index', 'window_id',
            'window_name'
        ] + formats.PANE_FORMATS
        tmux_formats = ['#{%s}\t' % f for f in pformats]

        proc = self.tmux(
            'list-panes',
            '-a',
            '-F%s' % ''.join(tmux_formats),     # output
        )

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        panes = proc.stdout

        pformats = [
            'session_name', 'session_id',
            'window_index', 'window_id', 'window_name'
        ] + formats.PANE_FORMATS

        # combine format keys with values returned from ``tmux list-panes``
        panes = [dict(zip(
            pformats, window.split('\t'))) for window in panes]

        # clear up empty dict
        panes = [
            dict((k, v) for k, v in window.items() if v) for window in panes
        ]

        if self._panes:
            # http://stackoverflow.com/a/14465359
            self._panes[:] = []

        self._panes.extend(panes)

        return self._panes

    def _update_panes(self):
        """Update internal pane data and return ``self`` for chainability.

        :rtype: :class:`Server`

        """
        self._list_panes()
        return self

    def attached_sessions(self):
        """Return active :class:`Session` object.

        This will not work where multiple tmux sessions are attached.

        :rtype: :class:`Server`

        """

        sessions = self._sessions
        attached_sessions = list()

        for session in sessions:
            if 'session_attached' in session:
                # for now session_active is a unicode
                if session.get('session_attached') == '1':
                    logger.debug('session %s attached', session.get(
                        'session_name'))
                    attached_sessions.append(session)
                else:
                    continue

        return attached_sessions or None

    def has_session(self, target_session):
        """Return True if session exists. ``$ tmux has-session``.

        :param: target_session: str of session name.
        :rtype: bool

        """

        proc = self.tmux('has-session', '-t%s' % target_session)

        if 'failed to connect to server' in proc.stdout:
            return False
        elif 'session not found' in proc.stdout:
            return False
        else:
            return True

    def kill_server(self):
        """``$ tmux kill-server``."""
        self.tmux('kill-server')

    def kill_session(self, target_session=None):
        """Kill the tmux session with ``$ tmux kill-session``, return ``self``.

        :param: target_session: str. note this accepts ``fnmatch(3)``. 'asdf'
            will kill 'asdfasd'.

        :rtype: :class:`Server`

        """
        proc = self.tmux('kill-session', '-t%s' % target_session)

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        return self

    def switch_client(self, target_session):
        """``$ tmux switch-client``.

        :param: target_session: str. name of the session. fnmatch(3) works.

        """

        # tmux('switch-client', '-t', target_session)
        proc = self.tmux('switch-client', '-t%s' % target_session)

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

    def attach_session(self, target_session=None):
        """``$ tmux attach-session`` aka alias: ``$ tmux attach``.

        :param: target_session: str. name of the session. fnmatch(3) works.

        """
        tmux_args = tuple()
        if target_session:
            tmux_args += ('-t%s' % target_session,)

        proc = self.tmux('attach-session', *tmux_args)

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

    def new_session(self,
                    session_name=None,
                    kill_session=False,
                    attach=False,
                    *args,
                    **kwargs):
        """Return :class:`Session` from  ``$ tmux new-session``.

        Uses ``-P`` flag to print session info, ``-F`` for return formatting
        returns new Session object.

        ``$ tmux new-session -d`` will create the session in the background
        ``$ tmux new-session -Ad`` will move to the session name if it already
        exists. todo: make an option to handle this.

        :param session_name: session name::

            $ tmux new-session -s <session_name>
        :type session_name: string

        :param detach: create session background::

            $ tmux new-session -d
        :type detach: bool

        :param attach_if_exists: if the session_name exists, attach it.
                                 if False, this method will raise a
                                 :exc:`tmuxp.exc.TmuxSessionExists` exception
        :type attach_if_exists: bool

        :param kill_session: Kill current session if ``$ tmux has-session``
                             Useful for testing workspaces.
        :type kill_session: bool
        :rtype: :class:`Session`

        """

        if self.has_session(session_name):
            if kill_session:
                self.tmux('kill-session', '-t%s' % session_name)
                logger.info('session %s exists. killed it.' % session_name)
            else:
                raise exc.TmuxSessionExists(
                    'Session named %s exists' % session_name
                )

        logger.debug('creating session %s' % session_name)

        sformats = formats.SESSION_FORMATS
        tmux_formats = ['#{%s}' % f for f in sformats]

        env = os.environ.get('TMUX')

        if env:
            del os.environ['TMUX']

        tmux_args = (
            '-s%s' % session_name,
            '-P', '-F%s' % '\t'.join(tmux_formats),   # output
        )

        if not attach:
            tmux_args += ('-d',)

        proc = self.tmux(
            'new-session',
            *tmux_args
        )

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        session = proc.stdout[0]

        if env:
            os.environ['TMUX'] = env

        # combine format keys with values returned from ``tmux list-windows``
        session = dict(zip(sformats, session.split('\t')))

        # clear up empty dict
        session = dict((k, v) for k, v in session.items() if v)

        session = Session(server=self, **session)

        return session

########NEW FILE########
__FILENAME__ = session
# -*- coding: utf-8 -*-
"""Pythonization of the :term:`tmux(1)` session.

tmuxp.session
~~~~~~~~~~~~~

"""
from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import logging

from .window import Window
from . import util, formats, exc

logger = logging.getLogger(__name__)


class Session(util.TmuxMappingObject, util.TmuxRelationalObject):

    """:term:`tmux(1)` session.

    Holds :class:`Window` objects.

    """

    childIdAttribute = 'window_id'

    def __init__(self, server=None, **kwargs):

        self.server = server

        if not 'session_id' in kwargs:
            raise ValueError('Session requires a `session_id`')
        self._session_id = kwargs['session_id']
        self.server._update_windows()

    @property
    def _TMUX(self, *args):

        attrs = {
            'session_id': str(self._session_id)
        }

        # from https://github.com/serkanyersen/underscore.py
        def by(val, *args):
            for key, value in attrs.items():
                try:
                    if attrs[key] != val[key]:
                        return False
                except KeyError:
                    return False
                return True

        try:
            return list(filter(by, self.server._sessions))[0]
        except IndexError as e:
            logger.error(e)

    def tmux(self, *args, **kwargs):
        """Return :meth:`Server.tmux`.

        :rtype: :class:`Server.tmux`

        """
        if '-t' not in kwargs:
            kwargs['-t'] = self.get('session_id')
        return self.server.tmux(*args, **kwargs)

    def attach_session(self, target_session=None):
        """Return ``$ tmux attach-session`` aka alias: ``$ tmux attach``.

        :param: target_session: str. name of the session. fnmatch(3) works.

        """
        proc = self.tmux('attach-session', '-t%s' % self.get('session_id'))

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

    def kill_session(self):
        """``$ tmux kill-session``."""

        proc = self.tmux('kill-session', '-t%s' % self.get('session_id'))

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

    def switch_client(self, target_session=None):
        """``$ tmux kill-session``.

        :param: target_session: str. note this accepts fnmatch(3). 'asdf' will
                                kill asdfasd

        """
        proc = self.tmux('switch-client', '-t%s' % self.get('session_id'))

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

    def rename_session(self, new_name):
        """Rename session and return new :class:`Session` object.

        :param rename_session: new session name
        :type rename_session: string
        :rtype: :class:`Session`

        """
        proc = self.tmux(
            'rename-session',
            '-t%s' % self.get('session_id'),
            new_name
        )

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        return self

    def new_window(self,
                   window_name=None,
                   start_directory=None,
                   attach=True,
                   window_index=''):
        """Return :class:`Window` from ``$ tmux new-window``.

        .. note::

            By default, this will make the window active. For the new window
            to be created and not set to current, pass in ``attach=False``.

        :param window_name: window name.

        .. code-block:: bash

            $ tmux new-window -n <window_name> -c <start_directory>

        :type window_name: string
        :param start_directory: specifies the working directory in which the
            new created.
        :type start_directory: string
        :param attach: make new window the current window after creating it,
                       default True.
        :param type: bool
        :rtype: :class:`Window`

        """

        wformats = ['session_name', 'session_id'] + formats.WINDOW_FORMATS
        tmux_formats = ['#{%s}' % f for f in wformats]

        window_args = tuple()

        if not attach:
            window_args += ('-d',)

        window_args += (
            '-P',
        )

        if start_directory:
            # as of 2014-02-08 tmux 1.9-dev doesn't expand ~ in new-window -c.
            start_directory = os.path.expanduser(start_directory)
            window_args += ('-c%s' % start_directory,)

        window_args += (
            '-F"%s"' % '\t'.join(tmux_formats),  # output
        )
        if window_name:
            window_args += ('-n%s' % window_name,)

        window_args += (
            # empty string for window_index will use the first one available
            '-t%s:%s' % (self.get('session_id'), window_index),
        )

        proc = self.tmux('new-window', *window_args)

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        window = proc.stdout[0]

        window = dict(zip(wformats, window.split('\t')))

        # clear up empty dict
        window = dict((k, v) for k, v in window.items() if v)
        window = Window(session=self, **window)

        self.server._update_windows()

        return window

    def kill_window(self, target_window=None):
        """``$ tmux kill-window``.

        Kill the current window or the window at ``target-window``. removing it
        from any sessions to which it is linked.

        :param target_window: the ``target window``.
        :type target_window: string

        """

        tmux_args = list()

        if target_window:
            if isinstance(target_window, int):
                target = '-t%s:%d' % (self.get('session_name'), target_window)
            else:
                target = '-t%s' % target_window

        proc = self.tmux('kill-window', target)

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        self.server._update_windows()

    def _list_windows(self):
        windows = self.server._update_windows()._windows

        windows = [
            w for w in windows if w['session_id'] == self.get('session_id')
        ]

        return windows

    @property
    def _windows(self):
        """Property / alias to return :meth:`~._list_windows`."""

        return self._list_windows()

    def list_windows(self):
        """Return a list of :class:`Window` from the ``tmux(1)`` session.

        :rtype: :class:`Window`

        """
        windows = [
            w for w in self._windows if w['session_id'] == self._session_id
        ]

        return [Window(session=self, **window) for window in windows]

    @property
    def windows(self):
        """Property / alias to return :meth:`~.list_windows`."""
        return self.list_windows()
    #: Alias of :attr:`windows`.
    children = windows

    def attached_window(self):
        """Return active :class:`Window` object.

        :rtype: :class:`Window`

        """
        active_windows = []
        for window in self._windows:
            if 'window_active' in window:
                # for now window_active is a unicode
                if window.get('window_active') == '1':
                    active_windows.append(Window(session=self, **window))
                else:
                    continue

        if len(active_windows) == int(1):
            return active_windows[0]
        else:
            raise exc.TmuxpException(
                'multiple active windows found. %s' % active_windows)

        if len(self._windows) == int(0):
            raise exc.TmuxpException('No Windows')

    def select_window(self, target_window):
        """Return :class:`Window` selected via ``$ tmux select-window``.

        :param: window: ``target_window`` also 'last-window' (``-l``),
                        'next-window' (``-n``), or 'previous-window' (``-p``)
        :type window: integer
        :rtype: :class:`Window`

        :todo: assure ``-l``, ``-n``, ``-p`` work.

        """

        target = '-t%s' % target_window

        proc = self.tmux('select-window', target)

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        return self.attached_window()

    def attached_pane(self):
        """Return active :class:`Pane` object."""

        return self.attached_window().attached_pane()

    def set_option(self, option, value):
        """Set option ``$ tmux set-option <option> <value>``.

        todo: needs tests

        :param option: the window option. such as 'default-shell'.
        :type option: string
        :param value: window value. True/False will turn in 'on' and 'off'.
        :type value: string or bool

        """

        if isinstance(value, bool) and value:
            value = 'on'
        elif isinstance(value, bool) and not value:
            value = 'off'

        proc = self.tmux(
            'set-option', option, value
        )

        if proc.stderr:
            if isinstance(proc.stderr, list) and len(proc.stderr) == int(1):
                proc.stderr = proc.stderr[0]
            raise ValueError('tmux set-option stderr: %s' % proc.stderr)

    def show_options(self, option=None, g=False):
        """Return a dict of options for the window.

        For familiarity with tmux, the option ``option`` param forwards to pick
        a single option, forwarding to :meth:`Session.show_option`.

        :param option: optional. show a single option.
        :type option: string
        :param g: Pass ``-g`` flag for global variable
        :type g: bool
        :rtype: :py:obj:`dict`

        """

        tmux_args = tuple()

        if g:
            tmux_args += ('-g',)

        if option:
            return self.show_option(option, g=g)
        else:
            tmux_args += ('show-options',)
            session_options = self.tmux(
                *tmux_args
            ).stdout

        session_options = [tuple(item.split(' ')) for item in session_options]

        session_options = dict(session_options)

        for key, value in session_options.items():
            if value.isdigit():
                session_options[key] = int(value)

        return session_options

    def show_option(self, option, g=False):
        """Return a list of options for the window.

        :todo: test and return True/False for on/off string

        :param option: option to return.
        :type option: string
        :rtype: string, int or bool

        """

        tmux_args = tuple()

        if g:
            tmux_args += ('-g',)

        window_option = self.tmux(
            'show-options', option, *tmux_args
        ).stdout
        window_option = [tuple(item.split(' ')) for item in window_option][0]

        if window_option[1].isdigit():
            window_option = (window_option[0], int(window_option[1]))

        return window_option[1]

    def __repr__(self):
        return "%s(%s %s)" % (
            self.__class__.__name__,
            self.get('session_id'),
            self.get('session_name')
        )

########NEW FILE########
__FILENAME__ = cli
# -*- coding: utf-8 -*-
"""Test for tmuxp command line interface.

tmuxp.tests.cli
~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import shutil
import tempfile
import logging
import unittest

import kaptan

from .. import config, cli
from ..util import tmux
from .helpers import TestCase

logger = logging.getLogger(__name__)
TMUXP_DIR = os.path.join(os.path.dirname(__file__), '.tmuxp')


class CLIVersion(TestCase):

    pass


class StartupTest(TestCase):

    """test startup_cli()."""

    def setUp(self):
        if os.path.isdir(TMUXP_DIR):
            shutil.rmtree(TMUXP_DIR)

    def test_creates_config_dir_not_exists(self):
        """cli.startup() creates config dir if not exists."""

        self.assertFalse(os.path.exists(TMUXP_DIR))
        cli.startup(TMUXP_DIR)

        self.assertTrue(os.path.exists(TMUXP_DIR))

    @classmethod
    def tearDownClass(cls):
        if os.path.isdir(TMUXP_DIR):
            shutil.rmtree(TMUXP_DIR)
        logger.debug('wiped %s' % TMUXP_DIR)


class FindConfigsTest(TestCase):

    """test in_dir() test."""

    def setUp(self):
        if os.path.isdir(TMUXP_DIR):
            shutil.rmtree(TMUXP_DIR)

    def test_in_dir_from_config_dir(self):
        """config.in_dir() finds configs config dir."""

        cli.startup(TMUXP_DIR)
        config1 = tempfile.NamedTemporaryFile(
            dir=TMUXP_DIR,
            prefix='myconfig',
            suffix='.yaml'
        )

        config2 = tempfile.NamedTemporaryFile(
            dir=TMUXP_DIR,
            prefix='myconfig',
            suffix='.json'
        )
        configs_found = config.in_dir(TMUXP_DIR)

        self.assertEqual(len(configs_found), 2)

    def test_in_dir_from_current_dir(self):
        """config.in_dir() find configs config dir."""

        cli.startup(TMUXP_DIR)
        config1 = tempfile.NamedTemporaryFile(
            dir=TMUXP_DIR,
            prefix='myconfig',
            suffix='.yaml'
        )

        config2 = tempfile.NamedTemporaryFile(
            dir=TMUXP_DIR,
            prefix='myconfig',
            suffix='.json'
        )
        configs_found = config.in_dir(TMUXP_DIR)

        self.assertEqual(len(configs_found), 2)

    def test_ignore_non_configs_from_current_dir(self):
        """cli.in_dir() ignore non-config from config dir."""

        cli.startup(TMUXP_DIR)
        badconfig = tempfile.NamedTemporaryFile(
            dir=TMUXP_DIR,
            prefix='myconfig',
            suffix='.psd'
        )

        config1 = tempfile.NamedTemporaryFile(
            dir=TMUXP_DIR,
            prefix='watmyconfig',
            suffix='.json'
        )
        configs_found = config.in_dir(TMUXP_DIR)

        self.assertEqual(len(configs_found), 1)

    def test_get_configs_cwd(self):
        """config.in_cwd() find config in shell current working directory."""

        current_dir = os.getcwd()

        configs_found = config.in_cwd()

        # create a temporary folder and change dir into it
        tmp_dir = tempfile.mkdtemp(suffix='tmuxp')
        os.chdir(tmp_dir)

        try:
            config1 = open('.tmuxp.json', 'w+b')
            config1.close()

            configs_found = config.in_cwd()
        finally:
            os.remove(config1.name)

        self.assertEqual(len(configs_found), 1)
        self.assertIn('.tmuxp.json', configs_found)

        # clean up
        os.chdir(current_dir)
        if os.path.isdir(tmp_dir):
            shutil.rmtree(tmp_dir)

    @classmethod
    def tearDownClass(cls):
        if os.path.isdir(TMUXP_DIR):
            shutil.rmtree(TMUXP_DIR)
        logger.debug('wiped %s' % TMUXP_DIR)


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(FindConfigsTest))
    suite.addTest(unittest.makeSuite(StartupTest))
    return suite

########NEW FILE########
__FILENAME__ = config
# -*- coding: utf-8 -*-
"""Test for tmuxp configuration import, inlining, expanding and export.

tmuxp.tests.config
~~~~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import shutil
import tempfile
import logging
import unittest

import kaptan

from .. import config, exc
from ..util import tmux
from .helpers import TestCase


logger = logging.getLogger(__name__)
TMUXP_DIR = os.path.join(os.path.dirname(__file__), '.tmuxp')
current_dir = os.path.abspath(os.path.dirname(__file__))
example_dir = os.path.abspath(os.path.join(
    current_dir, '..', '..', 'examples'))


sampleconfigdict = {
    'session_name': 'sampleconfig',
    'start_directory': '~',
    'windows': [
        {
            'window_name': 'editor',
            'panes': [
                {
                    'start_directory': '~',
                    'shell_command': ['vim'],
                },  {
                    'shell_command': ['cowsay "hey"']
                },
            ],
            'layout': 'main-verticle'
        },
        {
            'window_name': 'logging',
            'panes': [{
                'shell_command': ['tail -F /var/log/syslog'],
                'start_directory':'/var/log'
            }]
        },
        {
            'options': {
                'automatic_rename': True,
            },
            'panes': [
                {'shell_command': ['htop']}
            ]
        }
    ]
}


class ImportExportTest(TestCase):

    def setUp(self):
        self.tmp_dir = tempfile.mkdtemp(suffix='tmuxp')

    def tearDown(self):
        if os.path.isdir(self.tmp_dir):
            shutil.rmtree(self.tmp_dir)
        logging.debug('wiped %s' % TMUXP_DIR)

    def test_export_json(self):
        json_config_file = os.path.join(self.tmp_dir, 'config.json')

        configparser = kaptan.Kaptan()
        sampleconfig = config.inline(sampleconfigdict)
        configparser.import_config(sampleconfigdict)

        json_config_data = configparser.export('json', indent=2)

        with open(json_config_file, 'w') as buf:
            buf.write(json_config_data)

        new_config = kaptan.Kaptan()
        new_config_data = new_config.import_config(json_config_file).get()
        self.assertDictEqual(sampleconfigdict, new_config_data)

    def test_export_yaml(self):
        yaml_config_file = os.path.join(self.tmp_dir, 'config.yaml')

        configparser = kaptan.Kaptan()
        sampleconfig = config.inline(sampleconfigdict)
        configparser.import_config(sampleconfig)

        yaml_config_data = configparser.export(
            'yaml', indent=2, default_flow_style=False)

        with open(yaml_config_file, 'w') as buf:
            buf.write(yaml_config_data)

        new_config = kaptan.Kaptan()
        new_config_data = new_config.import_config(yaml_config_file).get()
        self.assertDictEqual(sampleconfigdict, new_config_data)

    def test_scan_config(self):
        configs = []

        garbage_file = os.path.join(self.tmp_dir, 'config.psd')
        with open(garbage_file, 'w') as buf:
            buf.write('wat')

        if os.path.exists(self.tmp_dir):
            for r, d, f in os.walk(self.tmp_dir):
                for filela in (
                    x for x in f if x.endswith(('.json', '.ini', 'yaml'))
                ):
                    configs.append(os.path.join(
                        self.tmp_dir, filela))

        files = 0
        if os.path.exists(os.path.join(self.tmp_dir, 'config.json')):
            files += 1
            self.assertIn(os.path.join(
                self.tmp_dir, 'config.json'), configs)

        if os.path.exists(os.path.join(self.tmp_dir, 'config.yaml')):
            files += 1
            self.assertIn(os.path.join(
                self.tmp_dir, 'config.yaml'), configs)

        if os.path.exists(os.path.join(self.tmp_dir, 'config.ini')):
            files += 1
            self.assertIn(os.path.join(self.tmp_dir, 'config.ini'), configs)

        self.assertEqual(len(configs), files)


class ExpandTest(TestCase):

    """Assume configuration has been imported into a python dict correctly."""

    before_config = {
        'session_name': 'sampleconfig',
        'start_directory': '~',
        'windows': [
            {
                'window_name': 'editor',
                'panes': [
                    {
                        'shell_command': [
                            'vim',
                            'top'
                        ]
                    },
                    {
                        'shell_command': ['vim'],
                    },
                    {
                        'shell_command': 'cowsay "hey"'
                    }
                ],
                'layout': 'main-verticle'
            },
            {
                'window_name': 'logging',
                'panes': [
                    {
                        'shell_command': ['tail -F /var/log/syslog'],
                    }
                ]
            },
            {
                'start_directory': '/var/log',
                'options': {'automatic_rename': True, },
                'panes': [
                    {
                        'shell_command': 'htop'
                    },
                    'vim',
                ]
            },
            {
                'start_directory': './',
                'panes': [
                    'pwd'
                ]
            },
            {
                'start_directory': './asdf/',
                'panes': [
                    'pwd'
                ]
            },
            {
                'start_directory': '../',
                'panes': [
                    'pwd'
                ]
            },
            {
                'panes': [
                    'top'
                ]
            }
        ]
    }

    after_config = {
        'session_name': 'sampleconfig',
        'start_directory': '~',
        'windows': [
            {
                'window_name': 'editor',
                'panes': [
                    {
                        'shell_command': ['vim', 'top'],
                    },
                    {
                        'shell_command': ['vim'],
                    },
                    {
                        'shell_command': ['cowsay "hey"']
                    },
                ],
                'layout': 'main-verticle'
            },
            {
                'window_name': 'logging',
                'panes': [
                    {
                        'shell_command': ['tail -F /var/log/syslog'],
                    }
                ]
            },
            {
                'start_directory': '/var/log',
                'options': {'automatic_rename': True},
                'panes': [
                    {'shell_command': ['htop']},
                    {'shell_command': ['vim']}
                ]
            },
            {
                'start_directory': os.path.abspath('./'),
                'panes': [
                    {'shell_command': ['pwd']}
                ]
            },
            {
                'start_directory': os.path.abspath('./asdf/'),
                'panes': [
                    {'shell_command': ['pwd']}
                ]
            },
            {
                'start_directory': os.path.abspath('../'),
                'panes': [
                    {'shell_command': ['pwd']}
                ]
            },

            {
                'panes': [
                    {'shell_command': ['top']}
                ]
            }
        ]
    }

    def test_config(self):
        """Expand shell commands from string to list."""
        self.maxDiff = None
        test_config = config.expand(self.before_config)
        self.assertDictEqual(test_config, self.after_config)

    def test_no_window_name(self):
        """Expand shell commands from string to list."""

        unexpanded_yaml = """
        session_name: sampleconfig
        start_directory: '~'
        windows:
        - window_name: focused window
          layout: main-horizontal
          focus: true
          panes:
          - shell_command:
            - cd ~
          - shell_command:
            - cd /usr
            focus: true
          - shell_command:
            - cd ~
            - echo "moo"
            - top
        - window_name: window 2
          panes:
          - shell_command:
            - top
            focus: true
          - shell_command:
            - echo "hey"
          - shell_command:
            - echo "moo"
          - window_name: window 3
          panes:
          - shell_command: cd /
            focus: true
          - pane
          - pane
        """

        expanded_yaml = """
        session_name: sampleconfig
        start_directory: '~'
        windows:
        - window_name: focused window
          layout: main-horizontal
          focus: true
          panes:
          - shell_command:
            - cd ~
          - shell_command:
            - cd /usr
            focus: true
          - shell_command:
            - cd ~
            - echo "moo"
            - top
        - window_name: window 2
          panes:
          - shell_command:
            - top
            focus: true
          - shell_command:
            - echo "hey"
          - shell_command:
            - echo "moo"
          - window_name: window 3
          panes:
          - shell_command:
            - cd /
            focus: true
          - shell_command: []
          - shell_command: []
        """

        self.maxDiff = None

        unexpanded_dict = kaptan.Kaptan(handler='yaml'). \
            import_config(unexpanded_yaml).get()

        expanded_dict = kaptan.Kaptan(handler='yaml'). \
            import_config(expanded_yaml).get()

        self.assertDictEqual(
            config.expand(unexpanded_dict),
            expanded_dict
        )


class InlineTest(TestCase):

    """Tests for :meth:`config.inline()`."""

    before_config = {
        'session_name': 'sampleconfig',
        'start_directory': '~',
        'windows': [
            {
                'shell_command': ['top'],
                'window_name': 'editor',
                'panes': [
                    {
                        'shell_command': ['vim'],
                    },  {
                        'shell_command': ['cowsay "hey"']
                    },
                ],
                'layout': 'main-verticle'
            },
            {
                'window_name': 'logging',
                'panes': [
                    {
                        'shell_command': ['tail -F /var/log/syslog'],
                    }
                ]
            },
            {
                'options': {'automatic_rename': True, },
                'panes': [
                    {'shell_command': ['htop']}
                ]
            }
        ]
    }

    after_config = {
        'session_name': 'sampleconfig',
        'start_directory': '~',
        'windows': [
            {
                'shell_command': 'top',
                'window_name': 'editor',
                'panes': [
                    'vim',
                    'cowsay "hey"'
                ],
                'layout': 'main-verticle'
            },
            {
                'window_name': 'logging',
                'panes': [
                    'tail -F /var/log/syslog',
                ]
            },
            {
                'options': {
                    'automatic_rename': True,
                },
                'panes': [
                    'htop'
                ]
            },

        ]
    }

    def test_config(self):
        """:meth:`config.inline()` shell commands list to string."""

        self.maxDiff = None
        test_config = config.inline(self.before_config)
        self.assertDictEqual(test_config, self.after_config)


class InheritanceTest(TestCase):

    """Test config inheritance for the nested 'start_command'."""

    config_before = {
        'session_name': 'sampleconfig',
        'start_directory': '/',
        'windows': [
            {
                'window_name': 'editor',
                'start_directory': '~',
                'panes': [
                    {
                        'shell_command': ['vim'],
                    },
                    {
                        'shell_command': ['cowsay "hey"']
                    },
                ],
                'layout': 'main-verticle'
            },
            {
                'window_name': 'logging',
                'panes': [
                    {
                        'shell_command': ['tail -F /var/log/syslog'],
                    }
                ]
            },
            {
                'window_name': 'shufu',
                'panes': [
                    {
                        'shell_command': ['htop'],
                    }
                ]
            },
            {
                'options': {
                    'automatic_rename': True,
                },
                'panes': [
                    {
                        'shell_command': ['htop']
                    }
                ]
            }
        ]
    }

    config_after = {
        'session_name': 'sampleconfig',
        'start_directory': '/',
        'windows': [
            {
                'window_name': 'editor',
                'start_directory': '~',
                'panes': [
                    {
                        'shell_command': ['vim'],
                    },  {
                        'shell_command': ['cowsay "hey"'],
                    },
                ],
                'layout': 'main-verticle'
            },
            {
                'window_name': 'logging',
                'panes': [
                    {
                        'shell_command': ['tail -F /var/log/syslog'],
                    }
                ]
            },
            {
                'window_name': 'shufu',
                'panes': [
                    {
                        'shell_command': ['htop'],
                    }
                ]
            },
            {
                'options': {'automatic_rename': True, },
                'panes': [
                    {
                        'shell_command': ['htop'],
                    }
                ]
            }
        ]
    }

    def test_start_directory(self):
        config = self.config_before

        if 'start_directory' in config:
            session_start_directory = config['start_directory']
        else:
            session_start_directory = None

        for windowconfitem in config['windows']:
            window_start_directory = None
            if 'start_directory' in windowconfitem:
                window_start_directory = windowconfitem['start_directory']
            elif session_start_directory:
                window_start_directory = session_start_directory

            for paneconfitem in windowconfitem['panes']:
                # if 'start_directory' in paneconfitem:
                    # pane_start_directory = paneconfitem['start_directory']
                # elif window_start_directory:
                    # paneconfitem['start_directory'] = window_start_directory
                # elif session_start_directory:
                    # paneconfitem['start_directory'] = session_start_directory
                pass

        self.maxDiff = None
        self.assertDictEqual(config, self.config_after)


class ShellCommandBeforeTest(TestCase):

    """Config inheritance for the nested 'start_command'."""

    config_unexpanded = {  # shell_command_before is string in some areas
        'session_name': 'sampleconfig',
        'start_directory': '/',
        'windows': [
            {
                'window_name': 'editor',
                'start_directory': '~',
                'shell_command_before': 'source .env/bin/activate',
                'panes': [
                    {
                        'shell_command': ['vim'],
                    },
                    {
                        'shell_command_before': ['rbenv local 2.0.0-p0'],
                        'shell_command': ['cowsay "hey"']
                    },
                ],
                'layout': 'main-verticle'
            },
            {
                'shell_command_before': 'rbenv local 2.0.0-p0',
                'window_name': 'logging',
                'panes': [
                    {
                        'shell_command': ['tail -F /var/log/syslog'],
                    },
                    {
                    }
                ]
            },
            {
                'window_name': 'shufu',
                'panes': [
                    {
                        'shell_command_before': ['rbenv local 2.0.0-p0'],
                        'shell_command': ['htop'],
                    }
                ]
            },
            {
                'options': {'automatic_rename': True, },
                'panes': [
                    {'shell_command': ['htop']}
                ]
            },
            {
                'panes': ['top']
            }
        ]
    }

    config_expanded = {  # shell_command_before is string in some areas
        'session_name': 'sampleconfig',
        'start_directory': '/',
        'windows': [
            {
                'window_name': 'editor',
                'start_directory': '~',
                'shell_command_before': ['source .env/bin/activate'],
                'panes': [
                    {
                        'shell_command': ['vim'],
                    },
                    {
                        'shell_command_before': ['rbenv local 2.0.0-p0'],
                        'shell_command': ['cowsay "hey"']
                    },
                ],
                'layout': 'main-verticle'
            },
            {
                'shell_command_before': ['rbenv local 2.0.0-p0'],
                'window_name': 'logging',
                'panes': [
                    {
                        'shell_command': ['tail -F /var/log/syslog'],
                    },
                    {
                        'shell_command': []
                    }
                ]
            },
            {
                'window_name': 'shufu',
                'panes': [
                    {
                        'shell_command_before': ['rbenv local 2.0.0-p0'],
                        'shell_command': ['htop'],
                    }
                ]
            },
            {
                'options': {'automatic_rename': True, },
                'panes': [
                    {'shell_command': ['htop']}
                ]
            },
            {
                'panes': [{
                    'shell_command': ['top']
                }]
            },
        ]
    }

    config_after = {  # shell_command_before is string in some areas
        'session_name': 'sampleconfig',
        'start_directory': '/',
        'windows': [
            {
                'window_name': 'editor',
                'start_directory': '~',
                'shell_command_before': ['source .env/bin/activate'],
                'panes': [
                    {
                        'shell_command': ['source .env/bin/activate', 'vim'],
                    },
                    {
                        'shell_command_before': ['rbenv local 2.0.0-p0'],
                        'shell_command': [
                            'source .env/bin/activate',
                            'rbenv local 2.0.0-p0', 'cowsay "hey"'
                        ]
                    },
                ],
                'layout': 'main-verticle'
            },
            {
                'shell_command_before': ['rbenv local 2.0.0-p0'],
                'start_directory': '/',
                'window_name': 'logging',
                'panes': [
                    {
                        'shell_command': [
                            'rbenv local 2.0.0-p0',
                            'tail -F /var/log/syslog'
                        ],
                    },
                    {
                        'shell_command': ['rbenv local 2.0.0-p0']
                    }
                ]
            },
            {
                'start_directory': '/',
                'window_name': 'shufu',
                'panes': [
                    {
                        'shell_command_before': ['rbenv local 2.0.0-p0'],
                        'shell_command': ['rbenv local 2.0.0-p0', 'htop'],
                    }
                ]
            },
            {
                'start_directory': '/',
                'options': {'automatic_rename': True, },
                'panes': [
                    {
                        'shell_command': ['htop']
                    }
                ]
            },
            {
                'start_directory': '/',
                'panes': [
                    {
                        'shell_command': ['top']
                    }
                ]
            }
        ]
    }

    def test_shell_command_before(self):
        self.maxDiff = None
        test_config = self.config_unexpanded
        test_config = config.expand(test_config)

        self.assertDictEqual(test_config, self.config_expanded)

        test_config = config.trickle(test_config)
        self.maxDiff = None
        self.assertDictEqual(test_config, self.config_after)


class ShellCommandBeforeSession(TestCase):

    def test_in_session_scope(self):

        yaml_config = """
        shell_command_before:
          - 'echo "hi"'
        session_name: 'test'
        windows:
        - window_name: editor
          panes:
          - shell_command:
            - vim
            - :Ex
          - pane
          - cd /usr
        - window_name: logging
          panes:
          - shell_command:
            -
          - shell_command:
            - top
            - emacs
        """

        yaml_final_config = """
        shell_command_before:
          - 'echo "hi"'
        session_name: 'test'
        windows:
        - window_name: editor
          panes:
          - shell_command:
            - 'echo "hi"'
            - vim
            - :Ex
          - shell_command:
            - 'echo "hi"'
          - shell_command:
            - 'echo "hi"'
            - cd /usr
        - window_name: logging
          panes:
          - shell_command:
            - 'echo "hi"'
          - shell_command:
            - 'echo "hi"'
            - top
            - emacs
        """

        self.maxDiff = None

        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(yaml_config).get()

        config.validate_schema(sconfig)

        self.assertDictEqual(config.expand(sconfig), sconfig)

        self.assertDictEqual(
            config.expand(config.trickle(sconfig)),
            self.yaml_to_dict(yaml_final_config)
        )

    def yaml_to_dict(self, yaml):
        return kaptan.Kaptan(handler='yaml').import_config(yaml).get()


class TrickleRelativeStartDirectory(TestCase):

    config_expanded = {  # shell_command_before is string in some areas
        'session_name': 'sampleconfig',
        'start_directory': '/var',
        'windows': [
            {
                'window_name': 'editor',
                'start_directory': 'log',
                'panes': [
                    {
                        'shell_command': ['vim'],
                    },
                    {
                        'shell_command': ['cowsay "hey"']
                    },
                ],
                'layout': 'main-verticle'
            },
            {
                'window_name': 'logging',
                'start_directory': '~',
                'panes': [
                    {
                        'shell_command': ['tail -F /var/log/syslog'],
                    },
                    {
                        'shell_command': []
                    }
                ]
            },
        ]
    }

    config_after = {  # shell_command_before is string in some areas
        'session_name': 'sampleconfig',
        'start_directory': '/var',
        'windows': [
            {
                'window_name': 'editor',
                'start_directory': '/var/log',
                'panes': [
                    {
                        'shell_command': ['vim'],
                    },
                    {
                        'shell_command': [
                            'cowsay "hey"'
                        ]
                    },
                ],
                'layout': 'main-verticle'
            },
            {
                'start_directory': '~',
                'window_name': 'logging',
                'panes': [
                    {
                        'shell_command': ['tail -F /var/log/syslog'],
                    },
                    {
                        'shell_command': []
                    }
                ]
            },
        ]
    }

    def test_shell_command_before(self):

        test_config = config.trickle(self.config_expanded)
        self.assertDictEqual(test_config, self.config_after)


class ConfigBlankPanes(TestCase):

    yaml_config_file = os.path.join(example_dir, 'blank-panes.yaml')

    expanded_config = {
        'session_name': 'Blank pane test',
        'windows': [
            {
                'window_name': 'Blank pane test',
                'panes': [
                    {
                        'shell_command': [],
                    },
                    {
                        'shell_command': [],
                    },
                    {
                        'shell_command': [],
                    }
                ]
            },
            {
                'window_name': 'More blank panes',
                'panes': [
                    {
                        'shell_command': [],
                    },
                    {
                        'shell_command': [],
                    },
                    {
                        'shell_command': [],
                    }
                ]
            },
            {
                'window_name': 'Empty string (return)',
                'panes': [
                    {
                        'shell_command': [
                            ''
                        ],
                    },
                    {
                        'shell_command': [
                            ''
                        ],
                    },
                    {
                        'shell_command': [
                            ''
                        ],
                    }
                ]
            },
            {
                'window_name': 'Blank with options',
                'panes': [
                    {
                        'shell_command': [],
                        'focus': True,
                    },
                    {
                        'shell_command': [],
                        'start_directory': '/tmp',
                    }
                ]
            }
        ]
    }

    def test_expands_blank(self):
        """Expand blank config into full form.

        Handle ``NoneType`` and 'blank'::

        # nothing, None, 'blank'
        'panes': [
            None,
            'blank'
        ]

        # should be blank
        'panes': [
            'shell_command': []
        ]

        Blank strings::

            panes: [
                ''
            ]

            # should output to:
            panes:
                'shell_command': ['']

        """

        self.maxDiff = None

        test_config = kaptan.Kaptan().import_config(
            self.yaml_config_file).get()

        self.assertDictEqual(
            config.expand(test_config),
            self.expanded_config
        )


class ConfigConsistency(TestCase):

    delete_this = """
    session_name: sampleconfig
    start_directory: '~'
    windows:
    - layout: main-vertical
    panes:
    - shell_command:
        - vim
        start_directory: '~'
    - shell_command:
        - cowsay "hey"
    window_name: editor
    - panes:
    - shell_command:
        - tail -F /var/log/syslog
        start_directory: /var/log
    window_name: logging
    - automatic_rename: true
    panes:
    - shell_command:
        - htop
    """

    def test_no_session_name(self):
        yaml_config = """
        - window_name: editor
          panes:
          shell_command:
            - tail -F /var/log/syslog
          start_directory: /var/log
        - window_name: logging
          automatic_rename: true
          panes:
          - shell_command:
            - htop
        """

        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(yaml_config).get()

        with self.assertRaisesRegexp(
            exc.ConfigError, 'requires "session_name"'
        ):
            config.validate_schema(sconfig)

    def test_no_windows(self):
        yaml_config = """
        session_name: test session
        """

        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(yaml_config).get()

        with self.assertRaisesRegexp(exc.ConfigError, 'list of "windows"'):
            config.validate_schema(sconfig)

    def test_no_window_name(self):
        yaml_config = """
        session_name: test session
        windows:
        - window_name: editor
          panes:
          shell_command:
            - tail -F /var/log/syslog
          start_directory: /var/log
        - automatic_rename: true
          panes:
          - shell_command:
            - htop
        """

        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(yaml_config).get()

        with self.assertRaisesRegexp(exc.ConfigError, 'missing "window_name"'):
            config.validate_schema(sconfig)


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ConfigBlankPanes))
    suite.addTest(unittest.makeSuite(ConfigConsistency))
    suite.addTest(unittest.makeSuite(ExpandTest))
    suite.addTest(unittest.makeSuite(ImportExportTest))
    suite.addTest(unittest.makeSuite(InlineTest))
    suite.addTest(unittest.makeSuite(ShellCommandBeforeTest))
    suite.addTest(unittest.makeSuite(ShellCommandBeforeSession))
    suite.addTest(unittest.makeSuite(TrickleRelativeStartDirectory))
    return suite

########NEW FILE########
__FILENAME__ = config_teamocil
# -*- coding: utf-8 -*-
"""Test for tmuxp teamocil configuration..

tmuxp.tests.config_teamocil
~~~~~~~~~~~~~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import logging
import unittest

import kaptan

from .. import config, exc
from ..util import tmux
from .helpers import TestCase

logger = logging.getLogger(__name__)
TMUXP_DIR = os.path.join(os.path.dirname(__file__), '.tmuxp')


class TeamocilTest(TestCase):

    teamocil_yaml = """\
    windows:
    - name: "sample-two-panes"
      root: "~/Code/sample/www"
      layout: even-horizontal
      panes:
        - cmd: ["pwd", "ls -la"]
        - cmd: "rails server --port 3000"
    """

    teamocil_dict = {
        'windows': [{
            'name': 'sample-two-panes',
            'root': '~/Code/sample/www',
            'layout': 'even-horizontal',
            'panes': [
                {
                    'cmd': [
                        'pwd',
                        'ls -la'
                    ]
                },
                {
                    'cmd': 'rails server --port 3000'
                }
            ]
        }]
    }

    tmuxp_dict = {
        'session_name': None,
        'windows': [
            {
                'window_name': 'sample-two-panes',
                'layout': 'even-horizontal',
                'start_directory': '~/Code/sample/www',
                'panes': [
                    {
                        'shell_command': [
                            'pwd',
                            'ls -la'
                        ]
                    },
                    {
                        'shell_command': 'rails server --port 3000'
                    }
                ]
            }
        ]
    }

    def test_config_to_dict(self):
        configparser = kaptan.Kaptan(handler='yaml')
        test_config = configparser.import_config(self.teamocil_yaml)
        yaml_to_dict = test_config.get()
        self.assertDictEqual(yaml_to_dict, self.teamocil_dict)

        self.assertDictEqual(
            config.import_teamocil(self.teamocil_dict),
            self.tmuxp_dict
        )

        config.validate_schema(
            config.import_teamocil(
                self.teamocil_dict
            )
        )


class Teamocil2Test(TestCase):

    teamocil_yaml = """\
    windows:
    - name: "sample-four-panes"
      root: "~/Code/sample/www"
      layout: tiled
      panes:
        - cmd: "pwd"
        - cmd: "pwd"
        - cmd: "pwd"
        - cmd: "pwd"
    """

    teamocil_dict = {
        'windows': [{
            'name': 'sample-four-panes',
            'root': '~/Code/sample/www',
            'layout': 'tiled',
            'panes': [
                {'cmd': 'pwd'},
                {'cmd': 'pwd'},
                {'cmd': 'pwd'},
                {'cmd': 'pwd'},
            ]
        }]
    }

    tmuxp_dict = {
        'session_name': None,
        'windows': [
            {
                'window_name': 'sample-four-panes',
                'layout': 'tiled',
                'start_directory': '~/Code/sample/www',
                'panes': [
                    {
                        'shell_command': 'pwd'
                    },
                    {
                        'shell_command': 'pwd'
                    },
                    {
                        'shell_command': 'pwd'
                    },
                    {
                        'shell_command': 'pwd'
                    },
                ]
            }
        ]
    }

    def test_config_to_dict(self):
        configparser = kaptan.Kaptan(handler='yaml')
        test_config = configparser.import_config(self.teamocil_yaml)
        yaml_to_dict = test_config.get()
        self.assertDictEqual(yaml_to_dict, self.teamocil_dict)

        self.assertDictEqual(
            config.import_teamocil(self.teamocil_dict),
            self.tmuxp_dict
        )

        config.validate_schema(
            config.import_teamocil(
                self.teamocil_dict
            )
        )


class Teamocil3Test(TestCase):

    teamocil_yaml = """\
    windows:
    - name: "my-first-window"
      root: "~/Projects/foo-www"
      layout: even-vertical
      filters:
        before: "rbenv local 2.0.0-p0"
        after: "echo 'I am done initializing this pane.'"
      panes:
        - cmd: "git status"
        - cmd: "bundle exec rails server --port 4000"
          focus: true
        - cmd:
          - "sudo service memcached start"
          - "sudo service mongodb start"
    """

    teamocil_dict = {
        'windows': [{
            'name': 'my-first-window',
            'root': '~/Projects/foo-www',
            'layout': 'even-vertical',
            'filters': {
                'before': 'rbenv local 2.0.0-p0',
                'after': 'echo \'I am done initializing this pane.\''
            },
            'panes': [
                {'cmd': 'git status'},
                {'cmd': 'bundle exec rails server --port 4000',
                    'focus': True},
                {'cmd': [
                    'sudo service memcached start',
                    'sudo service mongodb start',
                ]}
            ]
        }]
    }

    tmuxp_dict = {
        'session_name': None,
        'windows': [
            {
                'window_name': 'my-first-window',
                'layout': 'even-vertical',
                'start_directory': "~/Projects/foo-www",
                'shell_command_before': 'rbenv local 2.0.0-p0',
                'shell_command_after': (
                    'echo '
                    '\'I am done initializing this pane.\''
                ),
                'panes': [
                    {
                        'shell_command': 'git status'
                    },
                    {
                        'shell_command': 'bundle exec rails server --port 4000',
                        'focus': True
                    },
                    {
                        'shell_command': [
                            'sudo service memcached start',
                            'sudo service mongodb start'
                        ]
                    }
                ]
            }

        ]
    }

    def test_config_to_dict(self):
        self.maxDiff = None
        configparser = kaptan.Kaptan(handler='yaml')
        test_config = configparser.import_config(self.teamocil_yaml)
        yaml_to_dict = test_config.get()
        self.assertDictEqual(yaml_to_dict, self.teamocil_dict)

        self.assertDictEqual(
            config.import_teamocil(self.teamocil_dict),
            self.tmuxp_dict
        )

        config.validate_schema(
            config.import_teamocil(
                self.teamocil_dict
            )
        )


class Teamocil4Test(TestCase):

    teamocil_yaml = """\
    windows:
    - name: "erb-example"
      root: <%= ENV['MY_PROJECT_ROOT'] %>
      panes:
        - cmd: "pwd"
    """

    teamocil_dict = {
        'windows': [{
            'name': 'erb-example',
            'root': "<%= ENV['MY_PROJECT_ROOT'] %>",
            'panes': [
                {'cmd': 'pwd'}
            ]
        }]
    }

    tmuxp_dict = {
        'session_name': None,
        'windows': [
            {
                'window_name': 'erb-example',
                'start_directory': "<%= ENV['MY_PROJECT_ROOT'] %>",
                'panes': [
                    {
                        'shell_command': 'pwd'
                    }
                ]
            }
        ]
    }

    def test_config_to_dict(self):
        self.maxDiff = None
        configparser = kaptan.Kaptan(handler='yaml')
        test_config = configparser.import_config(self.teamocil_yaml)
        yaml_to_dict = test_config.get()
        self.assertDictEqual(yaml_to_dict, self.teamocil_dict)

        self.assertDictEqual(
            config.import_teamocil(self.teamocil_dict),
            self.tmuxp_dict
        )

        config.validate_schema(
            config.import_teamocil(
                self.teamocil_dict
            )
        )


class TeamocilLayoutsTest(TestCase):

    """Import configurations from teamocil's <fixtures/layout.yml>.

    https://github.com/remiprev/teamocil/blob/master/spec/fixtures/layouts.yml

    LICENSE: https://github.com/remiprev/teamocil/blob/master/LICENSE

    """

    teamocil_yaml = """\
    # Simple two windows layout
    two-windows:
        windows:
          - name: "foo"
            clear: true
            root: "/foo"
            layout: "tiled"
            panes:
              - cmd: "echo 'foo'"
              - cmd: "echo 'foo again'"
          - name: "bar"
            root: "/bar"
            splits:
              - cmd:
                - "echo 'bar'"
                - "echo 'bar in an array'"
                target: bottom-right
              - cmd: "echo 'bar again'"
                focus: true
                width: 50

    # Simple two windows layout with filters
    two-windows-with-filters:
        windows:
          - name: "foo"
            root: "/foo"
            filters:
              before:
                - "echo first before filter"
                - "echo second before filter"
              after:
                - "echo first after filter"
                - "echo second after filter"
            panes:
              - cmd: "echo 'foo'"
              - cmd: "echo 'foo again'"
                width: 50

    two-windows-with-custom-command-options:
        windows:
          - name: "foo"
            cmd_separator: "\n"
            with_env_var: false
            clear: true
            root: "/foo"
            layout: "tiled"
            panes:
                - cmd: "echo 'foo'"
                - cmd: "echo 'foo again'"
          - name: "bar"
            cmd_separator: " && "
            with_env_var: true
            root: "/bar"
            splits:
              - cmd:
                - "echo 'bar'"
                - "echo 'bar in an array'"
                target: bottom-right
              - cmd: "echo 'bar again'"
                focus: true
                width: 50

    three-windows-within-a-session:
        session:
            name: "my awesome session"
            windows:
            - name: "first window"
              panes:
                - cmd: "echo 'foo'"
            - name: "second window"
              panes:
                - cmd: "echo 'foo'"
            - name: "third window"
              panes:
                - cmd: "echo 'foo'"
    """

    teamocil_dict = {
        'two-windows': {
            'windows': [
                {
                    'name': 'foo',
                    'clear': True,
                    'root': '/foo',
                    'layout': 'tiled',
                    'panes': [
                        {
                            'cmd': "echo 'foo'"
                        },
                        {
                            'cmd': "echo 'foo again'"
                        }
                    ]
                },
                {
                    'name': 'bar',
                    'root': '/bar',
                    'splits': [
                        {
                            'cmd': [
                                "echo 'bar'",
                                "echo 'bar in an array'"
                            ],
                            'target': 'bottom-right'
                        },
                        {
                            'cmd': "echo 'bar again'",
                            'focus': True,
                            'width': 50
                        }
                    ]

                }
            ]
        },

        'two-windows-with-filters': {
            'windows': [
                {
                    'name': 'foo',
                    'root': '/foo',
                    'filters':
                    {
                        'before': [
                            'echo first before filter',
                            'echo second before filter'
                        ],
                        'after': [
                            'echo first after filter',
                            'echo second after filter',
                        ]
                    },
                    'panes': [
                        {
                            'cmd': "echo 'foo'"
                        },
                        {
                            'cmd': "echo 'foo again'",
                            'width': 50
                        }
                    ]
                }
            ]
        },

        'two-windows-with-custom-command-options': {
            'windows': [
                {
                    'name': 'foo',
                    'cmd_separator': ' ',
                    'with_env_var': False,
                    'clear': True,
                    'root': '/foo',
                    'layout': 'tiled',
                    'panes': [
                        {
                            'cmd': "echo 'foo'"
                        },
                        {
                            'cmd': "echo 'foo again'"
                        }
                    ]
                }, {
                    'name': 'bar',
                    'cmd_separator': ' && ',
                    'with_env_var': True,
                    'root': '/bar',
                    'splits': [
                        {
                            'cmd': [
                                "echo 'bar'",
                                "echo 'bar in an array'"
                            ],
                            'target': 'bottom-right'
                        },
                        {
                            'cmd': "echo 'bar again'",
                            'focus': True,
                            'width': 50
                        }
                    ]
                }]
        },

        'three-windows-within-a-session': {
            'session': {
                'name': 'my awesome session',
                'windows': [
                    {
                        'name': 'first window',
                        'panes': [
                            {
                                'cmd': "echo 'foo'"
                            }
                        ]
                    }, {
                        'name': 'second window',
                        'panes': [
                            {
                                'cmd': "echo 'foo'"}
                        ]
                    }, {
                        'name': 'third window',
                        'panes': [
                            {
                                'cmd': "echo 'foo'"
                            }
                        ]
                    }
                ]
            }
        }
    }

    two_windows = \
        {
            'session_name': None,
            'windows': [
                {
                    'window_name': 'foo',
                    'start_directory': '/foo',
                    'clear': True,
                    'layout': 'tiled',
                    'panes': [
                        {
                            'shell_command': "echo 'foo'"
                        },
                        {
                            'shell_command': "echo 'foo again'"
                        }
                    ]
                },
                {
                    'window_name': 'bar',
                    'start_directory': '/bar',
                    'panes': [
                        {
                            'shell_command': [
                                "echo 'bar'",
                                "echo 'bar in an array'"
                            ],
                            'target': 'bottom-right'
                        },
                        {
                            'shell_command': "echo 'bar again'",
                            'focus': True,
                        }
                    ]
                }
            ]
        }

    two_windows_with_filters = \
        {
            'session_name': None,
            'windows': [
                {
                    'window_name': 'foo',
                    'start_directory': '/foo',
                    'shell_command_before': [
                        'echo first before filter',
                        'echo second before filter',
                    ],
                    'shell_command_after': [
                        'echo first after filter',
                        'echo second after filter',
                    ],
                    'panes': [
                        {
                            'shell_command': "echo 'foo'"
                        },
                        {
                            'shell_command': "echo 'foo again'",
                        }
                    ]
                }
            ]
        }

    two_windows_with_custom_command_options = \
        {
            'session_name': None,
            'windows': [
                {
                    'window_name': 'foo',
                    'start_directory': '/foo',
                    'clear': True,
                    'layout': 'tiled',
                    'panes': [
                        {
                            'shell_command': "echo 'foo'",
                        },
                        {
                            'shell_command': "echo 'foo again'",
                        }
                    ]
                },
                {
                    'window_name': 'bar',
                    'start_directory': '/bar',
                    'panes': [
                        {
                            'shell_command': [
                                "echo 'bar'",
                                "echo 'bar in an array'"
                            ],
                            'target': 'bottom-right'
                        },
                        {
                            'shell_command': "echo 'bar again'",
                            'focus': True,
                        }
                    ]

                }
            ]

        }

    three_windows_within_a_session = {
        'session_name': 'my awesome session',
        'windows': [
            {
                'window_name': 'first window',
                'panes': [
                    {
                        'shell_command': "echo 'foo'"
                    },
                ]
            },
            {
                'window_name': 'second window',
                'panes': [
                    {
                        'shell_command': "echo 'foo'"
                    },
                ]
            },
            {
                'window_name': 'third window',
                'panes': [
                    {
                        'shell_command': "echo 'foo'"
                    },
                ]
            },
        ]
    }

    def test_config_to_dict(self):
        self.maxDiff = None
        configparser = kaptan.Kaptan(handler='yaml')
        test_config = configparser.import_config(self.teamocil_yaml)
        yaml_to_dict = test_config.get()
        self.assertDictEqual(yaml_to_dict, self.teamocil_dict)

        self.assertDictEqual(
            config.import_teamocil(
                self.teamocil_dict['two-windows'],
            ),
            self.two_windows
        )

        config.validate_schema(
            config.import_teamocil(
                self.teamocil_dict['two-windows']
            )
        )

        self.assertDictEqual(
            config.import_teamocil(
                self.teamocil_dict['two-windows-with-filters'],
            ),
            self.two_windows_with_filters
        )

        config.validate_schema(
            config.import_teamocil(
                self.teamocil_dict['two-windows-with-filters']
            )
        )

        self.assertDictEqual(
            config.import_teamocil(
                self.teamocil_dict['two-windows-with-custom-command-options'],
            ),
            self.two_windows_with_custom_command_options
        )

        config.validate_schema(
            config.import_teamocil(
                self.teamocil_dict['two-windows-with-custom-command-options']
            )
        )

        self.assertDictEqual(
            config.import_teamocil(
                self.teamocil_dict['three-windows-within-a-session'],
            ),
            self.three_windows_within_a_session
        )
        config.validate_schema(
            config.import_teamocil(
                self.teamocil_dict['three-windows-within-a-session']
            )
        )

        """ this configuration contains multiple sessions in a single file.
            tmuxp can split them into files, proceed?
        """


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(TeamocilTest))
    suite.addTest(unittest.makeSuite(Teamocil2Test))
    suite.addTest(unittest.makeSuite(Teamocil3Test))
    suite.addTest(unittest.makeSuite(Teamocil4Test))
    suite.addTest(unittest.makeSuite(TeamocilLayoutsTest))
    return suite

########NEW FILE########
__FILENAME__ = config_tmuxinator
# -*- coding: utf-8 -*-
"""Test for tmuxp tmuxinator configuration.

tmuxp.tests.config_tmuxinator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import logging
import unittest

import kaptan

from .. import config, exc
from ..util import tmux
from .._compat import string_types
from .helpers import TestCase

import logging

logger = logging.getLogger(__name__)
TMUXP_DIR = os.path.join(os.path.dirname(__file__), '.tmuxp')


class TmuxinatorTest(TestCase):

    tmuxinator_yaml = """\
    windows:
    - editor:
        layout: main-vertical
        panes:
            - vim
            - guard
    - server: bundle exec rails s
    - logs: tail -f logs/development.log
    """

    tmuxinator_dict = {
        'windows': [
            {
                'editor': {
                    'layout': 'main-vertical',
                    'panes': [
                        'vim',
                        'guard'
                    ]
                }
            },
            {
                'server': 'bundle exec rails s',
            },
            {
                'logs': 'tail -f logs/development.log'
            }
        ]
    }

    tmuxp_dict = {
        'session_name': None,
        'windows': [
            {
                'window_name': 'editor',
                'layout': 'main-vertical',
                'panes': [
                    'vim',
                    'guard'
                ]
            },
            {
                'window_name': 'server',
                'panes': [
                    'bundle exec rails s'
                ]
            },
            {
                'window_name': 'logs',
                'panes': [
                    'tail -f logs/development.log'
                ]
            }
        ]
    }

    def test_config_to_dict(self):
        configparser = kaptan.Kaptan(handler='yaml')
        test_config = configparser.import_config(self.tmuxinator_yaml)
        yaml_to_dict = test_config.get()
        self.assertDictEqual(yaml_to_dict, self.tmuxinator_dict)

        self.assertDictEqual(config.import_tmuxinator(
            self.tmuxinator_dict), self.tmuxp_dict)


class TmuxinatorDeprecationsTest(TestCase):

    """Tmuxinator uses `tabs` instead of `windows` in older versions.

    https://github.com/aziz/tmuxinator/blob/master/lib/tmuxinator/project.rb#L18

    https://github.com/aziz/tmuxinator/blob/master/spec/fixtures/sample.deprecations.yml

    LICENSE: https://github.com/aziz/tmuxinator/blob/master/LICENSE

    """

    tmuxinator_yaml = """\
    project_name: sample
    project_root: ~/test
    socket_name: foo # Remove to use default socket
    pre: sudo /etc/rc.d/mysqld start # Runs before everything
    rbenv: 2.0.0-p247
    cli_args: -f ~/.tmux.mac.conf # Pass arguments to tmux
    tabs:
    - editor:
        pre:
            - echo "I get run in each pane, before each pane command!"
            -
        layout: main-vertical
        panes:
            - vim
            - #empty, will just run plain bash
            - top
    - shell: git pull
    - guard:
        layout: tiled
        pre:
            - echo "I get run in each pane."
            - echo "Before each pane command!"
        panes:
            -
            - #empty, will just run plain bash
            -
    - database: bundle exec rails db
    - server: bundle exec rails s
    - logs: tail -f log/development.log
    - console: bundle exec rails c
    - capistrano:
    - server: ssh user@example.com
    """

    tmuxinator_dict = {
        'project_name': 'sample',
        'project_root': '~/test',
        'socket_name': 'foo',
        'pre': 'sudo /etc/rc.d/mysqld start',
        'rbenv': '2.0.0-p247',
        'cli_args': '-f ~/.tmux.mac.conf',
        'tabs': [
            {
                'editor': {
                    'pre': [
                        'echo "I get run in each pane, '
                        'before each pane command!"',
                        None
                    ],
                    'layout': 'main-vertical',
                    'panes': [
                        'vim',
                        None,
                        'top'
                    ]
                }
            },
            {'shell': 'git pull', },
            {
                'guard': {
                    'layout': 'tiled',
                    'pre': [
                        'echo "I get run in each pane."',
                        'echo "Before each pane command!"'
                    ],
                    'panes': [
                        None,
                        None,
                        None
                    ]
                }
            },
            {'database': 'bundle exec rails db'},
            {'server': 'bundle exec rails s'},
            {'logs': 'tail -f log/development.log'},
            {'console': 'bundle exec rails c'},
            {'capistrano': None},
            {'server': 'ssh user@example.com'}
        ]
    }

    tmuxp_dict = {
        'session_name': 'sample',
        'socket_name': 'foo',
        'config': '~/.tmux.mac.conf',
        'start_directory': '~/test',
        'shell_command_before': [
            'sudo /etc/rc.d/mysqld start',
            'rbenv shell 2.0.0-p247'
        ],
        'windows': [
            {
                'window_name': 'editor',
                'shell_command_before': [
                    'echo "I get run in each pane, before each pane command!"',
                    None
                ],
                'layout': 'main-vertical',
                'panes': [
                    'vim',
                    None,
                    'top'
                ]
            },
            {
                'window_name': 'shell',
                'panes': [
                    'git pull'
                ]
            },
            {
                'window_name': 'guard',
                'layout': 'tiled',
                'shell_command_before': [
                    'echo "I get run in each pane."',
                    'echo "Before each pane command!"'
                ],
                'panes': [
                    None,
                    None,
                    None
                ]
            },
            {
                'window_name': 'database',
                'panes': [
                    'bundle exec rails db'
                ]
            },
            {
                'window_name': 'server',
                'panes': [
                    'bundle exec rails s'
                ]
            },
            {
                'window_name': 'logs',
                'panes': [
                    'tail -f log/development.log'
                ]
            },
            {
                'window_name': 'console',
                'panes': [
                    'bundle exec rails c'
                ]
            },
            {
                'window_name': 'capistrano',
                'panes': [
                    None
                ]
            },
            {
                'window_name': 'server',
                'panes': [
                    'ssh user@example.com'
                ]
            }
        ]
    }

    def test_config_to_dict(self):
        self.maxDiff = None
        configparser = kaptan.Kaptan(handler='yaml')
        test_config = configparser.import_config(self.tmuxinator_yaml)
        yaml_to_dict = test_config.get()
        self.assertDictEqual(yaml_to_dict, self.tmuxinator_dict)

        self.assertDictEqual(
            config.import_tmuxinator(self.tmuxinator_dict), self.tmuxp_dict
        )


class TmuxinatoriSampleTest(TestCase):

    """Test importing <spec/fixtures/sample.yml>.

    https://github.com/aziz/tmuxinator/blob/master/spec/fixtures/sample.yml

    LICENSE: https://github.com/aziz/tmuxinator/blob/master/LICENSE

    """

    tmuxinator_yaml = """\
    # ~/.tmuxinator/sample.yml
    # you can make as many tabs as you wish...

    name: sample
    root: ~/test
    socket_name: foo # Remove to use default socket
    pre: sudo /etc/rc.d/mysqld start # Runs before everything
    pre_window: rbenv shell 2.0.0-p247 # Runs in each tab and pane
    tmux_options: -f ~/.tmux.mac.conf # Pass arguments to tmux
    windows:
    - editor:
        pre:
            - echo "I get run in each pane, before each pane command!"
            -
        layout: main-vertical
        panes:
            - vim
            - #empty, will just run plain bash
            - top
    - shell:
        - git pull
        - git merge
    - guard:
        layout: tiled
        pre:
            - echo "I get run in each pane."
            - echo "Before each pane command!"
        panes:
            -
            - #empty, will just run plain bash
            -
    - database: bundle exec rails db
    - server: bundle exec rails s
    - logs: tail -f log/development.log
    - console: bundle exec rails c
    - capistrano:
    - server: ssh user@example.com
    """

    tmuxinator_dict = {
        'name': 'sample',
        'root': '~/test',
        'socket_name': 'foo',
        'tmux_options': '-f ~/.tmux.mac.conf',
        'pre': 'sudo /etc/rc.d/mysqld start',
        'pre_window': 'rbenv shell 2.0.0-p247',
        'windows': [
            {
                'editor': {
                    'pre': [
                        'echo "I get run in each pane, '
                        'before each pane command!"',
                        None
                    ],
                    'layout': 'main-vertical',
                    'panes': [
                        'vim',
                        None,
                        'top'
                    ]
                }
            },
            {
                'shell': [
                    'git pull',
                    'git merge'
                ]
            },
            {
                'guard': {
                    'layout': 'tiled',
                    'pre': [
                        'echo "I get run in each pane."',
                        'echo "Before each pane command!"'
                    ],
                    'panes': [
                        None,
                        None,
                        None
                    ]
                }
            },
            {'database': 'bundle exec rails db'},
            {'server': 'bundle exec rails s'},
            {'logs': 'tail -f log/development.log'},
            {'console': 'bundle exec rails c'},
            {'capistrano': None},
            {'server': 'ssh user@example.com'}
        ]
    }

    tmuxp_dict = {
        'session_name': 'sample',
        'socket_name': 'foo',
        'config': '~/.tmux.mac.conf',
        'shell_command': 'sudo /etc/rc.d/mysqld start',
        'shell_command_before': [
            'rbenv shell 2.0.0-p247'
        ],
        'windows': [
            {
                'window_name': 'editor',
                'shell_command_before': [
                    'echo "I get run in each pane, before each pane command!"',
                    None
                ],
                'layout': 'main-vertical',
                'panes': [
                    'vim',
                    None,
                    'top'
                ]
            },
            {
                'window_name': 'shell',
                'panes': [
                    'git pull',
                    'git merge'
                ]
            },
            {
                'window_name': 'guard',
                'layout': 'tiled',
                'shell_command_before': [
                    'echo "I get run in each pane."',
                    'echo "Before each pane command!"'
                ],
                'panes': [
                    None,
                    None,
                    None
                ]
            },
            {
                'window_name': 'database',
                'panes': [
                    'bundle exec rails db'
                ]
            },
            {
                'window_name': 'server',
                'panes': [
                    'bundle exec rails s'
                ]
            },
            {
                'window_name': 'logs',
                'panes': [
                    'tail -f log/development.log'
                ]
            },
            {
                'window_name': 'console',
                'panes': [
                    'bundle exec rails c'
                ]
            },
            {
                'window_name': 'capistrano',
                'panes': [
                    None
                ]
            },
            {
                'window_name': 'server',
                'panes': [
                    'ssh user@example.com'
                ]
            }
        ]
    }

    def test_config_to_dict(self):
        self.maxDiff = None
        configparser = kaptan.Kaptan(handler='yaml')
        test_config = configparser.import_config(self.tmuxinator_yaml)
        yaml_to_dict = test_config.get()
        self.assertDictEqual(yaml_to_dict, self.tmuxinator_dict)

        self.assertDictEqual(
            config.import_tmuxinator(self.tmuxinator_dict),
            self.tmuxp_dict
        )


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(TmuxinatorTest))
    suite.addTest(unittest.makeSuite(TmuxinatorDeprecationsTest))
    suite.addTest(unittest.makeSuite(TmuxinatoriSampleTest))
    return suite

########NEW FILE########
__FILENAME__ = helpers
# -*- coding: utf-8 -*-
"""Helper methods for tmuxp unittests."""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import time
import logging
import contextlib

try:
    import unittest2 as unittest
except ImportError:  # Python 2.7
    import unittest

from random import randint

from . import t
from .. import Server, log, exc

logger = logging.getLogger(__name__)

TEST_SESSION_PREFIX = 'test tmuxp_'


def get_test_session_name(server, prefix=TEST_SESSION_PREFIX):
    while True:
        session_name = prefix + str(randint(0, 9999999))
        if not t.has_session(session_name):
            break
    return session_name


def get_test_window_name(session, prefix=TEST_SESSION_PREFIX):
    while True:
        window_name = prefix + str(randint(0, 9999999))
        if not session.findWhere(window_name=window_name):
            break
    return window_name


@contextlib.contextmanager
def temp_session(server, session_name=None):
    if not session_name:
        session_name = get_test_session_name(server)

    session = server.new_session(session_name)
    try:
        yield session
    finally:
        if server.has_session(session_name):
            session.kill_session()
    return


@contextlib.contextmanager
def temp_session(server, *args, **kwargs):
    """Return a context manager with a temporary session.

    e.g.::

        with temp_session(server) as session:
            session.new_window(window_name='my window')

    The session will destroy itself upon closing with :meth:`Session.
    kill_session()`.

    If no ``session_name`` is entered, :func:`get_test_session_name` will make
    an unused session name.

    :args: Same arguments as :meth:`Server.new_session`
    :yields: Temporary session
    :rtype: :class:`Session`
    """

    if 'session_name' in kwargs:
        session_name = kwargs.pop('session_name')
    else:
        session_name = get_test_session_name(server)

    session = server.new_session(session_name, *args, **kwargs)

    try:
        yield session
    finally:
        if server.has_session(session_name):
            session.kill_session()
    return


@contextlib.contextmanager
def temp_window(session, *args, **kwargs):
    """Return a context manager with a temporary window.

    e.g.::

        with temp_window(session) as window:
            my_pane = window.split_window()

    The window will destroy itself upon closing with :meth:`window.
    kill_window()`.

    If no ``window_name`` is entered, :func:`get_test_window_name` will make
    an unused window name.

    :args: Same arguments as :meth:`Session.new_window`
    :yields: Temporary window
    :rtype: :class:`Window`
    """

    if 'window_name' not in kwargs:
        window_name = get_test_window_name(session)
    else:
        window_name = kwargs.pop('window_name')

    window = session.new_window(window_name, *args, **kwargs)

    # Get ``window_id`` before returning it, it may be killed within context.
    window_id = window.get('window_id')

    try:
        yield session
    finally:
        if session.findWhere(window_id=window_id):
            window.kill_window()
    return


class TestCase(unittest.TestCase):

    """Base TestClass so we don't have to try: unittest2 every module. """

    @classmethod
    def setUpClass(cls):
        super(TestCase, cls).setUpClass()  # for python 2.6 unittest2


class TmuxTestCase(TestCase):

    """TmuxTestCase class, wraps the TestCase in a :class:`Session`."""

    #: :class:`Session` object.
    session = None
    #: Session name for the TestCase.
    TEST_SESSION_NAME = None

    def temp_session(self, session_name=None):
        return temp_session(self.server, session_name)

    def setUp(self):
        """Run bootstrap if :attr:`~.session` is not set."""

        if not self.TEST_SESSION_NAME or not self.session:
            self.bootstrap()

    def bootstrap(self):
        """Return tuple of the session_name (generated) and :class:`Session`.

        Checks to verify if the user has a tmux client open.

        It will clean up and delete other sessions starting with the
        :attr:`TEST_SESSION_PREFIX` ``tmuxp``.

        Since tmux closes when all sessions are deleted, the bootstrap will see
        if there is no other client open aside from a tmuxp_ prefixed session
        a dumby session will be made to prevent tmux from closing.

        """

        session_name = 'tmuxp'
        if not t.has_session(session_name):
            t.tmux('new-session', '-d', '-s', session_name)

        # find current sessions prefixed with tmuxp
        old_test_sessions = [
            s.get('session_name') for s in t._sessions
            if s.get('session_name').startswith(TEST_SESSION_PREFIX)
        ]

        other_sessions = [
            s.get('session_name') for s in t._sessions
            if not s.get('session_name').startswith(
                TEST_SESSION_PREFIX
            )
        ]

        TEST_SESSION_NAME = get_test_session_name(server=t)

        try:
            session = t.new_session(
                session_name=TEST_SESSION_NAME,
            )
        except exc.TmuxpException as e:
            raise e

        """
        Make sure that tmuxp can :ref:`test_builder_visually` and switches to
        the newly created session for that testcase.
        """
        try:
            t.switch_client(session.get('session_id'))
            pass
        except exc.TmuxpException as e:
            # t.attach_session(session.get('session_id'))
            pass

        for old_test_session in old_test_sessions:
            logger.debug(
                'Old test test session %s found. Killing it.' %
                old_test_session
            )
            t.kill_session(old_test_session)
        assert TEST_SESSION_NAME == session.get('session_name')
        assert TEST_SESSION_NAME != 'tmuxp'

        self.TEST_SESSION_NAME = TEST_SESSION_NAME
        self.server = t
        self.session = session

########NEW FILE########
__FILENAME__ = pane
# -*- coding: utf-8 -*-
"""Test for tmuxp Pane object.

tmuxp.tests.pane
~~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import unittest
import logging

from . import t
from .helpers import TmuxTestCase

logger = logging.getLogger(__name__)


class ResizeTest(TmuxTestCase):

    def test_resize_pane(self):
        """ Test Pane.resize_pane(). """

        window = self.session.attached_window()
        window.rename_window('test_resize_pane')

        pane1 = window.attached_pane()
        pane1_id = pane1['pane_id']
        pane1_height = pane1['pane_height']
        pane2 = window.split_window()

        pane1.resize_pane(height=4)
        self.assertNotEqual(pane1['pane_height'], pane1_height)
        self.assertEqual(int(pane1['pane_height']), 4)

        pane1.resize_pane(height=3)
        self.assertEqual(int(pane1['pane_height']), 3)

    def test_set_height(self):
        window = self.session.new_window(window_name='test_set_height')
        pane2 = window.split_window()
        pane1 = window.attached_pane()
        pane1_height = pane1['pane_height']

        pane1.set_height(2)
        self.assertNotEqual(pane1['pane_height'], pane1_height)
        self.assertEqual(int(pane1['pane_height']), 2)

    def test_set_width(self):
        window = self.session.new_window(window_name='test_set_width')
        pane2 = window.split_window()

        window.select_layout('main-vertical')
        pane1 = window.attached_pane()
        pane1_width = pane1['pane_width']

        pane1.set_width(10)
        self.assertNotEqual(pane1['pane_width'], pane1_width)
        self.assertEqual(int(pane1['pane_width']), 10)

        pane1.reset()


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ResizeTest))
    return suite

########NEW FILE########
__FILENAME__ = server
# -*- coding: utf-8 -*-
"""Test for tmuxp Server object.

tmuxp.tests.server
~~~~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

from random import randint

import unittest
import logging

from .. import Server
from .helpers import TmuxTestCase
from . import t

logger = logging.getLogger(__name__)


class ServerTest(TmuxTestCase):

    def test_has_session(self):
        self.assertTrue(t.has_session(self.TEST_SESSION_NAME))
        self.assertFalse(t.has_session('asdf2314324321'))

    def test_socket_name(self):
        """ ``-L`` socket_name.

        ``-L`` socket_name  file name of socket. which will be stored in
               env TMUX_TMPDIR or /tmp if unset.)

        """
        myserver = Server(socket_name='test')

        self.assertEqual(myserver.socket_name, 'test')

    def test_socket_path(self):
        """ ``-S`` socket_path  (alternative path for server socket). """

        myserver = Server(socket_path='test')

        self.assertEqual(myserver.socket_path, 'test')

    def test_config(self):
        """ ``-f`` file for tmux(1) configuration. """

        myserver = Server(config_file='test')
        self.assertEqual(myserver.config_file, 'test')

    def test_256_colors(self):
        myserver = Server(colors=256)
        self.assertEqual(myserver.colors, 256)

        proc = myserver.tmux('list-servers')

        self.assertIn('-2', proc.cmd)
        self.assertNotIn('-8', proc.cmd)

    def test_88_colors(self):
        myserver = Server(colors=88)
        self.assertEqual(myserver.colors, 88)

        proc = myserver.tmux('list-servers')

        self.assertIn('-8', proc.cmd)
        self.assertNotIn('-2', proc.cmd)


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ServerTest))
    return suite

########NEW FILE########
__FILENAME__ = session
# -*- coding: utf-8 -*-
"""Test for tmuxp Session object.

tmuxp.tests.session
~~~~~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

from random import randint

import unittest
import logging

from .. import Session, Window, Pane
from ..util import tmux

from .helpers import TmuxTestCase, TEST_SESSION_PREFIX
from . import t

logger = logging.getLogger(__name__)


class SessionTest(TmuxTestCase):

    def test_has_session(self):
        """Server.has_session returns True if has session_name exists."""
        self.assertTrue(t.has_session(self.TEST_SESSION_NAME))
        self.assertFalse(t.has_session('asdf2314324321'))

    def test_select_window(self):
        """Session.select_window moves window."""
        # get the current window_base_index, since different user tmux config
        # may start at 0 or 1, or whatever they want.
        window_base_index = int(
            self.session.attached_window().get('window_index')
        )

        window = self.session.new_window(window_name='test_window')
        window_count = len(self.session._windows)

        self.assertGreaterEqual(window_count, 2)  # 2 or more windows

        self.assertEqual(len(self.session._windows), window_count)

        # tmux selects a window, moves to it, shows it as attached_window
        selected_window1 = self.session.select_window(window_base_index)
        self.assertIsInstance(selected_window1, Window)
        attached_window1 = self.session.attached_window()

        self.assertEqual(selected_window1, attached_window1)
        self.assertEqual(selected_window1.__dict__, attached_window1.__dict__)

        # again: tmux selects a window, moves to it, shows it as
        # attached_window
        selected_window2 = self.session.select_window(window_base_index + 1)
        self.assertIsInstance(selected_window2, Window)
        attached_window2 = self.session.attached_window()

        self.assertEqual(selected_window2, attached_window2)
        self.assertEqual(selected_window2.__dict__, attached_window2.__dict__)

        # assure these windows were really different
        self.assertNotEqual(selected_window1, selected_window2)
        self.assertNotEqual(
            selected_window1.__dict__, selected_window2.__dict__)

    def test_select_window_returns_Window(self):
        """Session.select_window returns Window object."""

        window_count = len(self.session._windows)
        self.assertEqual(len(self.session._windows), window_count)
        window_base_index = int(
            self.session.attached_window().get('window_index'))

        self.assertIsInstance(self.session.select_window(
            window_base_index), Window)

    def test_attached_window(self):
        """Session.attached_window() returns Window."""
        self.assertIsInstance(self.session.attached_window(), Window)

    def test_attached_pane(self):
        """Session.attached_pane() returns Pane."""
        self.assertIsInstance(self.session.attached_pane(), Pane)

    def test_session_rename(self):
        """Session.rename_session renames session."""
        test_name = 'testingdis_sessname'
        self.session.rename_session(test_name)
        self.assertEqual(self.session.get('session_name'), test_name)
        self.session.rename_session(self.TEST_SESSION_NAME)
        self.assertEqual(
            self.session.get('session_name'),
            self.TEST_SESSION_NAME
        )


class SessionNewTest(TmuxTestCase):

    def test_new_session(self):
        """Server.new_session creates new session."""
        new_session_name = TEST_SESSION_PREFIX + str(randint(0, 1337))
        new_session = t.new_session(session_name=new_session_name, detach=True)

        self.assertIsInstance(new_session, Session)
        self.assertEqual(new_session.get('session_name'), new_session_name)


class Options(TmuxTestCase):

    def test_show_options(self):
        """Session.show_options() returns dict."""

        options = self.session.show_options()
        self.assertIsInstance(options, dict)

    def test_set_show_options_single(self):
        """Set option then Session.show_options(key)."""

        self.session.set_option('history-limit', 20)
        self.assertEqual(20, self.session.show_options('history-limit'))

        self.session.set_option('history-limit', 40)
        self.assertEqual(40, self.session.show_options('history-limit'))

        self.assertEqual(40, self.session.show_options()['history-limit'])

    def test_set_show_option(self):
        """Set option then Session.show_option(key)."""
        self.session.set_option('history-limit', 20)
        self.assertEqual(20, self.session.show_option('history-limit'))

        self.session.set_option('history-limit', 40)

        self.assertEqual(40, self.session.show_option('history-limit'))

    def test_set_option_bad(self):
        """Session.set_option raises ValueError for bad option key."""
        with self.assertRaises(ValueError):
            self.session.set_option('afewewfew', 43)


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(Options))
    suite.addTest(unittest.makeSuite(SessionNewTest))
    suite.addTest(unittest.makeSuite(SessionTest))
    return suite

########NEW FILE########
__FILENAME__ = test_utils
# -*- coding: utf-8 -*-
"""Tests for tmuxp testsuite's helper and utility functions."""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

from .helpers import get_test_session_name, temp_session, TestCase, \
    TmuxTestCase, unittest  # , temp_window, temp_pane


class TempSession(TmuxTestCase):

    def test_kills_session(self):
        server = self.server
        session_name = get_test_session_name(server=server)

        with temp_session(server=server, session_name=session_name) as session:
            result = server.has_session(session_name)
            self.assertTrue(result)

        self.assertFalse(server.has_session(session_name))

    def test_if_session_killed_before(self):
        """Handles situation where session already closed within context"""

        server = self.server
        session_name = get_test_session_name(server=server)

        with temp_session(server=server, session_name=session_name) as session:

            # an error or an exception within a temp_session kills the session
            server.kill_session(session_name)

            result = server.has_session(session_name)
            self.assertFalse(result)

        # really dead?
        self.assertFalse(server.has_session(session_name))

    def test_if_session_name_works(self):
        """should allow custom ``session_name``."""
        pass


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(TempSession))
    return suite

########NEW FILE########
__FILENAME__ = tmuxobject
# -*- coding: utf-8 -*-
"""Test for tmuxp TmuxRelationalObject and TmuxMappingObject.

tmuxp.tests.tmuxobject
~~~~~~~~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import random
import logging
import unittest

from .. import Pane, Window, Session
from . import t

from .helpers import TmuxTestCase, TEST_SESSION_PREFIX

logger = logging.getLogger(__name__)


class TmuxObjectTest(TmuxTestCase):

    """Test the :class:`TmuxRelationalObject` base class object."""

    def test_findWhere(self):
        """Test that findWhere() retrieves single matching object."""
        self.maxDiff = None
        # server.findWhere
        for session in t.sessions:
            session_id = session.get('session_id')

            self.assertEqual(t.findWhere({'session_id': session_id}), session)
            self.assertIsInstance(
                t.findWhere({
                    'session_id': session_id
                }), Session
            )

            # session.findWhere
            for window in session.windows:
                window_id = window.get('window_id')

                self.assertEqual(
                    session.findWhere({'window_id': window_id}), window
                )
                self.assertIsInstance(
                    session.findWhere({'window_id': window_id}), Window
                )

                # window.findWhere
                for pane in window.panes:
                    pane_id = pane.get('pane_id')

                    self.assertEqual(window.findWhere(
                        {'pane_id': pane_id}), pane)
                    self.assertIsInstance(window.findWhere(
                        {'pane_id': pane_id}), Pane)

    def test_findWhere_None(self):
        """.findWhere returns None if no results found."""

        while True:
            nonexistant_session = TEST_SESSION_PREFIX + str(
                random.randint(0, 9999)
            )

            if not t.has_session(nonexistant_session):
                break

        self.assertIsNone(t.findWhere({
            'session_name': nonexistant_session
        }))

    def test_findWhere_multiple_attrs(self):
        """.findWhere returns objects with multiple attributes."""

        for session in t.sessions:
            session_id = session.get('session_id')
            session_name = session.get('session_name')
            find_where = t.findWhere({
                'session_id': session_id,
                'session_name': session_name
            })

            self.assertEqual(find_where, session)
            self.assertIsInstance(find_where, Session)

            # session.findWhere
            for window in session.windows:
                window_id = window.get('window_id')
                window_index = window.get('window_index')

                find_where = session.findWhere({
                    'window_id': window_id,
                    'window_index': window_index
                })

                self.assertEqual(find_where, window)
                self.assertIsInstance(find_where, Window)

                # window.findWhere
                for pane in window.panes:
                    pane_id = pane.get('pane_id')
                    pane_tty = pane.get('pane_tty')

                    find_where = window.findWhere({
                        'pane_id': pane_id,
                        'pane_tty': pane_tty
                    })

                    self.assertEqual(find_where, pane)
                    self.assertIsInstance(find_where, Pane)

    def test_where(self):
        """Test self.where() returns matching objects."""

        window = self.session.attached_window()
        window.split_window()  # create second pane

        for session in t.sessions:
            session_id = session.get('session_id')
            session_name = session.get('session_name')
            where = t.where({
                'session_id': session_id,
                'session_name': session_name
            })

            self.assertEqual(len(where), 1)
            self.assertIsInstance(where, list)
            self.assertEqual(where[0], session)
            self.assertIsInstance(where[0], Session)

            # session.where
            for window in session.windows:
                window_id = window.get('window_id')
                window_index = window.get('window_index')

                where = session.where({
                    'window_id': window_id,
                    'window_index': window_index
                })

                self.assertEqual(len(where), 1)
                self.assertIsInstance(where, list)
                self.assertEqual(where[0], window)
                self.assertIsInstance(where[0], Window)

                # window.where
                for pane in window.panes:
                    pane_id = pane.get('pane_id')
                    pane_tty = pane.get('pane_tty')

                    where = window.where({
                        'pane_id': pane_id,
                        'pane_tty': pane_tty
                    })

                    self.assertEqual(len(where), 1)
                    self.assertIsInstance(where, list)
                    self.assertEqual(where[0], pane)
                    self.assertIsInstance(where[0], Pane)

    def test_getById(self):
        """Test self.getById() retrieves child object."""

        window = self.session.attached_window()

        window.split_window()  # create second pane

        for session in t.sessions:
            session_id = session.get('session_id')
            session_name = session.get('session_name')
            get_by_id = t.getById(session_id)

            self.assertEqual(get_by_id, session)
            self.assertIsInstance(get_by_id, Session)
            self.assertIsNone(t.getById(
                '$' + str(random.randint(50000, 90000))
            ))

            # session.getById
            for window in session.windows:
                window_id = window.get('window_id')
                window_index = window.get('window_index')

                get_by_id = session.getById(window_id)

                self.assertEqual(get_by_id, window)
                self.assertIsInstance(get_by_id, Window)

                self.assertIsNone(session.getById(
                    '@' + str(random.randint(50000, 90000))
                ))

                # window.getById
                for pane in window.panes:
                    pane_id = pane.get('pane_id')
                    pane_tty = pane.get('pane_tty')

                    get_by_id = window.getById(pane_id)

                    self.assertEqual(get_by_id, pane)
                    self.assertIsInstance(get_by_id, Pane)
                    self.assertIsNone(window.getById(
                        '%' + str(random.randint(50000, 90000))
                    ))


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(TmuxObjectTest))
    return suite

########NEW FILE########
__FILENAME__ = util
# -*- coding: utf-8 -*-
"""Tests for utility functions in tmux.

tmuxp.tests.util
~~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import random
import logging
import unittest
import subprocess
import os

from .. import exc
from ..util import has_required_tmux_version, run_before_script
from ..exc import BeforeLoadScriptNotExists, BeforeLoadScriptError


from .helpers import TmuxTestCase, TestCase

logger = logging.getLogger(__name__)

current_dir = os.path.abspath(os.path.dirname(__file__))
fixtures_dir = os.path.abspath(os.path.join(current_dir, 'fixtures'))


class TmuxVersionTest(TmuxTestCase):

    """Test the :meth:`has_required_tmux_version`."""

    def test_no_arg_uses_tmux_version(self):
        result = has_required_tmux_version()
        self.assertRegexpMatches(result, r'[0-9]\.[0-9]')

    def test_ignores_letter_versions(self):
        """Ignore letters such as 1.8b.

        See ticket https://github.com/tony/tmuxp/issues/55.

        In version 0.1.7 this is adjusted to use LooseVersion, in order to
        allow letters.

        """
        result = has_required_tmux_version('1.9a')
        self.assertRegexpMatches(result, r'[0-9]\.[0-9]')

        result = has_required_tmux_version('1.8a')
        self.assertEqual(result, r'1.8')

    def test_error_version_less_1_7(self):
        with self.assertRaisesRegexp(exc.TmuxpException, 'tmuxp only supports'):
            has_required_tmux_version('1.7')

        with self.assertRaisesRegexp(exc.TmuxpException, 'tmuxp only supports'):
            has_required_tmux_version('1.6a')

        has_required_tmux_version('1.9a')


class RunBeforeScript(TestCase):

    def test_raise_BeforeLoadScriptNotExists_if_not_exists(self):
        script_file = os.path.join(fixtures_dir, 'script_noexists.sh')

        with self.assertRaises(BeforeLoadScriptNotExists):
            run_before_script(script_file)

        with self.assertRaises(OSError):
            run_before_script(script_file)

    def test_raise_BeforeLoadScriptError_if_retcode(self):
        script_file = os.path.join(fixtures_dir, 'script_failed.sh')

        with self.assertRaises(BeforeLoadScriptError):
            run_before_script(script_file)

    def test_return_stdout_if_ok(self):
        script_file = os.path.join(fixtures_dir, 'script_complete.sh')

        run_before_script(script_file)


class BeforeLoadScriptErrorTestCase(TestCase):

    def test_returncode(self):
        script_file = os.path.join(fixtures_dir, 'script_failed.sh')

        with self.assertRaisesRegexp(exc.BeforeLoadScriptError, "113"):
            run_before_script(script_file)

    def test_returns_stderr_messages(self):
        script_file = os.path.join(fixtures_dir, 'script_failed.sh')

        with self.assertRaisesRegexp(exc.BeforeLoadScriptError, "failed with returncode"):
            run_before_script(script_file)


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(BeforeLoadScriptErrorTestCase))
    suite.addTest(unittest.makeSuite(RunBeforeScript))
    suite.addTest(unittest.makeSuite(TmuxVersionTest))
    return suite

########NEW FILE########
__FILENAME__ = window
# -*- coding: utf-8 -*-
"""Test for tmuxp Window object.

tmuxp.tests.window
~~~~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import logging
import unittest

from .. import Pane, Window, Server
from . import t
from .helpers import TmuxTestCase


logger = logging.getLogger(__name__)


class SelectTest(TmuxTestCase):

    def test_select_window(self):
        window_count = len(self.session._windows)
        # to do, get option for   base-index from tmux
        # for now hoever, let's get the index from the first window.
        self.assertEqual(window_count, 1)

        window_base_index = int(
            self.session.attached_window().get('window_index'))

        window = self.session.new_window(window_name='testing 3')

        # self.assertEqual(2,
        # int(self.session.attached_window().get('window_index')))
        self.assertEqual(int(window_base_index) + 1, int(
            window.get('window_index')))

        self.session.select_window(window_base_index)
        self.assertEqual(window_base_index, int(
            self.session.attached_window().get('window_index')))

        self.session.select_window('testing 3')
        self.assertEqual(int(window_base_index) + 1, int(
            self.session.attached_window().get('window_index')))

        self.assertEqual(len(self.session._windows), 2)


class NewTest(TmuxTestCase):

    def test_zfresh_window_data(self):

        pane_base_index = int(self.session.attached_window().show_window_option(
            'pane-base-index', g=True
        ))

        self.assertEqual(len(self.session.windows), 1)

        self.assertEqual(len(self.session.attached_window().panes), 1)
        current_windows = len(self.session._windows)
        self.assertNotEqual('@0', self.session.get('session_id'))
        self.assertEqual(current_windows, 1)

        self.assertEqual(len(self.session.attached_window().panes), 1)
        self.assertIsInstance(self.session.server, Server)
        # len(self.session.attached_window().panes))

        self.assertEqual(1, len(self.session.windows))
        self.assertEqual(len(self.session.attached_window().panes), 1)
        for w in self.session.windows:
            self.assertIsInstance(w, Window)
        window = self.session.attached_window()
        self.assertIsInstance(window, Window)
        self.assertEqual(len(self.session.attached_window().panes), 1)
        pane = window.split_window()
        self.session.attached_window().select_pane(pane_base_index)
        self.session.attached_pane().send_keys('cd /srv/www/flaskr')
        self.session.attached_window().select_pane(pane_base_index + 1)
        self.session.attached_pane().send_keys('source .env/bin/activate')
        self.session.new_window(window_name='second')
        current_windows += 1
        self.assertEqual(current_windows, len(self.session._windows))
        self.session.new_window(window_name='hey')
        current_windows += 1
        self.assertEqual(current_windows, len(self.session._windows))

        self.session.select_window(1)
        self.session.kill_window(target_window='hey')
        current_windows -= 1
        self.assertEqual(current_windows, len(self.session._windows))


class NewTest2(TmuxTestCase):

    def test_newest_pane_data(self):
        window = self.session.new_window(window_name='test', attach=True)
        self.assertIsInstance(window, Window)
        self.assertEqual(1, len(window.panes))
        window.split_window(attach=True)

        self.assertEqual(2, len(window.panes))
        # note: the below used to accept -h, removing because split_window now
        # has attach as its only argument now
        window.split_window(attach=True)
        self.assertEqual(3, len(window.panes))


class NewTest3(TmuxTestCase):

    def test_attached_pane(self):
        """Window.attached_window() returns active Pane."""

        window = self.session.attached_window()  # current window
        self.assertIsInstance(window.attached_pane(), Pane)


class NewTest4(TmuxTestCase):

    def test_split_window(self):
        """Window.split_window() splits window, returns new Pane."""
        window_name = 'test split window'
        window = self.session.new_window(window_name=window_name, attach=True)
        pane = window.split_window()
        self.assertEqual(2, len(window.panes))
        self.assertIsInstance(pane, Pane)


class RenameTest(TmuxTestCase):

    window_name_before = 'test'
    window_name_after = 'ha ha ha fjewlkjflwef'

    def test_window_rename(self):
        """Window.rename_window()."""
        self.session.set_option('automatic-rename', 'off')
        window = self.session.new_window(
            window_name=self.window_name_before, attach=True)

        self.assertEqual(window, self.session.attached_window())
        self.assertEqual(window.get('window_name'), self.window_name_before)

        window.rename_window(self.window_name_after)

        window = self.session.attached_window()

        self.assertEqual(window.get('window_name'), self.window_name_after)

        window = self.session.attached_window()

        self.assertEqual(window.get('window_name'), self.window_name_after)


class RenameSpacesTest(RenameTest):
    window_name_after = 'hello \\ wazzup 0'


class KillWindow(TmuxTestCase):

    def test_kill_window(self):
        self.session.new_window()
        # create a second window to not kick out the client.
        # there is another way to do this via options too.

        w = self.session.attached_window()

        w.get('window_id')

        w.kill_window()
        with self.assertRaises(IndexError):
            w.get('window_id')


class Options(TmuxTestCase):

    def test_show_window_options(self):
        """Window.show_window_options() returns dict."""
        window = self.session.new_window(window_name='test_window')

        options = window.show_window_options()
        self.assertIsInstance(options, dict)

    def test_set_show_window_options(self):
        """Set option then Window.show_window_options(key)."""
        window = self.session.new_window(window_name='test_window')

        window.set_window_option('main-pane-height', 20)
        self.assertEqual(20, window.show_window_options('main-pane-height'))

        window.set_window_option('main-pane-height', 40)
        self.assertEqual(40, window.show_window_options('main-pane-height'))

        self.assertEqual(40, window.show_window_options()['main-pane-height'])

    def test_show_window_option(self):
        """Set option then Window.show_window_option(key)."""
        window = self.session.new_window(window_name='test_window')

        window.set_window_option('main-pane-height', 20)
        self.assertEqual(20, window.show_window_option('main-pane-height'))

        window.set_window_option('main-pane-height', 40)
        self.assertEqual(40, window.show_window_option('main-pane-height'))

        self.assertEqual(40, window.show_window_option('main-pane-height'))

    def test_set_window_option_bad(self):
        """Window.set_window_option raises ValueError for bad option key."""

        window = self.session.new_window(window_name='test_window')

        with self.assertRaises(ValueError):
            window.set_window_option('afewewfew', 43)


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(KillWindow))
    suite.addTest(unittest.makeSuite(NewTest))
    suite.addTest(unittest.makeSuite(NewTest2))
    suite.addTest(unittest.makeSuite(NewTest3))
    suite.addTest(unittest.makeSuite(NewTest4))
    suite.addTest(unittest.makeSuite(Options))
    suite.addTest(unittest.makeSuite(RenameTest))
    suite.addTest(unittest.makeSuite(RenameSpacesTest))
    suite.addTest(unittest.makeSuite(SelectTest))
    return suite

########NEW FILE########
__FILENAME__ = workspacebuilder
# -*- coding: utf-8 -*-
"""Test for tmuxp workspacebuilder.

tmuxp.tests.workspacebuilder
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import sys
import logging
import unittest
import time

import kaptan

from .. import Window, config, exc
from .._compat import text_type
from ..workspacebuilder import WorkspaceBuilder
from .helpers import TestCase, TmuxTestCase, temp_session

logger = logging.getLogger(__name__)

current_dir = os.path.abspath(os.path.dirname(__file__))
example_dir = os.path.abspath(os.path.join(current_dir, '..', '..', 'examples'))
fixtures_dir = os.path.abspath(os.path.join(current_dir, 'fixtures'))


class TwoPaneTest(TmuxTestCase):

    yaml_config = """
    session_name: sampleconfig
    start_directory: '~'
    windows:
    - layout: main-vertical
      panes:
      - shell_command:
        - vim
      - shell_command:
        - echo "hey"
      window_name: editor
    - panes:
      - shell_command:
        - tail | echo 'hi'
      window_name: logging
    - window_name: test
      panes:
      - shell_command:
        - htop
    """

    def test_split_windows(self):
        s = self.session
        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(self.yaml_config).get()

        builder = WorkspaceBuilder(sconf=sconfig)

        window_count = len(self.session._windows)  # current window count
        self.assertEqual(len(s._windows), window_count)
        for w, wconf in builder.iter_create_windows(s):
            window_pane_count = len(w._panes)
            for p in builder.iter_create_panes(w, wconf):
                p = p
                self.assertEqual(len(s._windows), window_count)
            self.assertIsInstance(w, Window)

            self.assertEqual(len(s._windows), window_count)
            window_count += 1


class ThreePaneTest(TmuxTestCase):

    yaml_config = """
    session_name: sampleconfig
    start_directory: '~'
    windows:
    - window_name: test
      layout: main-horizontal
      panes:
      - shell_command:
        - vim
      - shell_command:
        - echo "hey"
      - shell_command:
        - echo "moo"
    """

    def test_split_windows(self):
        s = self.session
        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(self.yaml_config).get()

        builder = WorkspaceBuilder(sconf=sconfig)

        window_count = len(self.session._windows)  # current window count
        self.assertEqual(len(s._windows), window_count)
        for w, wconf in builder.iter_create_windows(s):

            window_pane_count = len(w._panes)
            for p in builder.iter_create_panes(w, wconf):
                p = p
                self.assertEqual(len(s._windows), window_count)
            self.assertIsInstance(w, Window)

            self.assertEqual(len(s._windows), window_count)
            window_count += 1
            w.set_window_option('main-pane-height', 50)
            w.select_layout(wconf['layout'])


class FocusAndPaneIndexTest(TmuxTestCase):

    yaml_config = """
    session_name: sampleconfig
    start_directory: '~'
    windows:
    - window_name: focused window
      layout: main-horizontal
      focus: true
      panes:
      - shell_command:
        - cd ~
      - shell_command:
        - cd /usr
        focus: true
      - shell_command:
        - cd ~
        - echo "moo"
        - top
    - window_name: window 2
      panes:
      - shell_command:
        - top
        focus: true
      - shell_command:
        - echo "hey"
      - shell_command:
        - echo "moo"
    - window_name: window 3
      panes:
      - shell_command: cd /
        focus: true
      - pane
      - pane
    """

    def test_focus_pane_index(self):
        s = self.session
        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(self.yaml_config).get()
        sconfig = config.expand(sconfig)
        sconfig = config.trickle(sconfig)

        builder = WorkspaceBuilder(sconf=sconfig)

        builder.build(session=self.session)

        self.assertEqual(
            self.session.attached_window().get('window_name'),
            'focused window'
        )

        pane_base_index = int(self.session.attached_window().show_window_option(
            'pane-base-index', g=True
        ))

        if not pane_base_index:
            pane_base_index = 0
        else:
            pane_base_index = int(pane_base_index)

        # get the pane index for each pane
        pane_base_indexes = []
        for pane in self.session.attached_window().panes:
            pane_base_indexes.append(int(pane.get('pane_index')))

        pane_indexes_should_be = [pane_base_index + x for x in range(0, 3)]
        self.assertListEqual(pane_indexes_should_be, pane_base_indexes)

        w = self.session.attached_window()

        self.assertNotEqual(w.get('window_name'), 'man')

        pane_path = '/usr'
        for i in range(60):
            p = w.attached_pane()
            p.server._update_panes()
            if p.get('pane_current_path') == pane_path:
                break
            time.sleep(.2)

        self.assertEqual(p.get('pane_current_path'), pane_path)

        proc = self.session.tmux('show-option', '-gv', 'base-index')
        base_index = int(proc.stdout[0])
        self.session.server._update_windows()

        window3 = self.session.findWhere({'window_index': str(base_index + 2)})
        self.assertIsInstance(window3, Window)

        p = None
        pane_path = '/'
        for i in range(60):
            p = window3.attached_pane()
            p.server._update_panes()
            if p.get('pane_current_path') == pane_path:
                break
            time.sleep(.2)

        self.assertEqual(p.get('pane_current_path'), pane_path)


class WindowOptions(TmuxTestCase):

    yaml_config = """
    session_name: test window options
    start_directory: '~'
    windows:
    - layout: main-horizontal
      options:
        main-pane-height: 5
      panes:
      - pane
      - pane
      - pane
      window_name: editor
    """

    def test_window_options(self):
        s = self.session
        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(self.yaml_config).get()
        sconfig = config.expand(sconfig)

        builder = WorkspaceBuilder(sconf=sconfig)

        window_count = len(self.session._windows)  # current window count
        self.assertEqual(len(s._windows), window_count)
        for w, wconf in builder.iter_create_windows(s):

            window_pane_count = len(w._panes)
            for p in builder.iter_create_panes(w, wconf):
                p = p
                self.assertEqual(len(s._windows), window_count)
            self.assertIsInstance(w, Window)
            self.assertEqual(w.show_window_option('main-pane-height'), 5)

            self.assertEqual(len(s._windows), window_count)
            window_count += 1
            w.select_layout(wconf['layout'])


class WindowAutomaticRename(TmuxTestCase):

    yaml_config = """
    session_name: test window options
    start_directory: '~'
    windows:
    - layout: main-horizontal
      options:
        automatic-rename: on
      panes:
      - shell_command:
        - man echo
        start_directory: '~'
      - shell_command:
        - echo "hey"
      - shell_command:
        - echo "moo"
    """

    def test_automatic_rename_option(self):
        """With option automatic-rename: on."""
        s = self.session
        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(self.yaml_config).get()

        builder = WorkspaceBuilder(sconf=sconfig)

        window_count = len(self.session._windows)  # current window count
        self.assertEqual(len(s._windows), window_count)
        for w, wconf in builder.iter_create_windows(s):

            window_pane_count = len(w._panes)
            for p in builder.iter_create_panes(w, wconf):
                p = p
                self.assertEqual(len(s._windows), window_count)
            self.assertIsInstance(w, Window)
            self.assertEqual(w.show_window_option('automatic-rename'), 'on')

            self.assertEqual(len(s._windows), window_count)

            window_count += 1
            w.select_layout(wconf['layout'])

        self.assertNotEqual(s.get('session_name'), 'tmuxp')
        w = s.windows[0]

        for i in range(60):
            self.session.server._update_windows()
            if w.get('window_name') != 'man':
                break
            time.sleep(.1)

        self.assertNotEqual(w.get('window_name'), 'man')

        pane_base_index = w.show_window_option('pane-base-index', g=True)
        w.select_pane(pane_base_index)

        for i in range(60):
            self.session.server._update_windows()
            if w.get('window_name') == 'man':
                break
            time.sleep(.1)

        self.assertEqual(w.get('window_name'), text_type('man'))

        w.select_pane('-D')
        for i in range(60):
            self.session.server._update_windows()
            if w['window_name'] != 'man':
                break
            time.sleep(.1)

        self.assertNotEqual(w.get('window_name'), text_type('man'))


class BlankPaneTest(TmuxTestCase):

    """:todo: Verify blank panes of various types build into workspaces."""

    yaml_config_file = os.path.join(example_dir, 'blank-panes.yaml')

    def test_blank_pane_count(self):

        test_config = kaptan.Kaptan().import_config(self.yaml_config_file).get()
        test_config = config.expand(test_config)
        # for window in test_config['windows']:
        #     window['layout'] = 'tiled'
        builder = WorkspaceBuilder(sconf=test_config)
        builder.build(session=self.session)

        self.assertEqual(self.session, builder.session)

        window1 = self.session.findWhere({'window_name': 'Blank pane test'})
        self.assertEqual(len(window1._panes), 3)

        window2 = self.session.findWhere({'window_name': 'More blank panes'})
        self.assertEqual(len(window2._panes), 3)

        window3 = self.session.findWhere(
            {'window_name': 'Empty string (return)'}
        )
        self.assertEqual(len(window3._panes), 3)

        window4 = self.session.findWhere({'window_name': 'Blank with options'})
        self.assertEqual(len(window4._panes), 2)


class StartDirectoryTest(TmuxTestCase):
    yaml_config = """
    session_name: sampleconfig
    start_directory: '/usr'
    windows:
    - window_name: supposed to be /usr/bin
      start_directory: '/usr/bin'
      layout: main-horizontal
      options:
          main-pane-height: 50
      panes:
      - shell_command:
        - echo "hey"
      - shell_command:
        - echo "moo"
    - window_name: support to be /dev
      start_directory: '/dev'
      layout: main-horizontal
      panes:
      - shell_command:
        - pwd
      - shell_command:
        - echo "hey"
      - shell_command:
        - echo "moo"
    - window_name: cwd containing a space
      start_directory: /tmp/foo bar
      layout: main-horizontal
      panes:
      - shell_command:
        - pwd
      - shell_command:
        - echo "hey"
      - shell_command:
        - echo "moo"
    - window_name: testsa3
      layout: main-horizontal
      panes:
      - shell_command:
        - pwd
      - shell_command:
        - echo "hey"
      - shell_command:
        - echo "moo3"
    - window_name: cwd relative to config file
      layout: main-horizontal
      start_directory: ./
      panes:
      - shell_command:
        - pwd
      - shell_command:
        - echo "hey"
      - shell_command:
        - echo "moo3"
    """

    def setUp(self):
        super(StartDirectoryTest, self).setUp()
        if not os.path.exists('/tmp/foo bar'):
            os.mkdir('/tmp/foo bar')
            self._temp_dir_created = True
        else:
            self._temp_dir_created = False

    def tearDown(self):
        super(StartDirectoryTest, self).tearDown()
        if self._temp_dir_created:
            os.rmdir('/tmp/foo bar')

    def test_start_directory(self):

        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(self.yaml_config).get()
        sconfig = config.expand(sconfig)
        sconfig = config.trickle(sconfig)

        builder = WorkspaceBuilder(sconf=sconfig)
        builder.build(session=self.session)

        assert(self.session == builder.session)
        dirs = ['/usr/bin', '/dev', '/tmp/foo bar', '/usr', os.getcwd()]
        for path, window in zip(dirs, self.session.windows):
            for p in window.panes:
                for i in range(60):
                    p.server._update_panes()
                    if p.get('pane_current_path') == path:
                        break
                    time.sleep(.2)

                self.assertEqual(p.get('pane_current_path'), path)


class PaneOrderingTest(TmuxTestCase):

    """Pane ordering based on position in config and ``pane_index``.

    Regression test for https://github.com/tony/tmuxp/issues/15.

    """

    yaml_config = """
    session_name: sampleconfig
    start_directory: '~'
    windows:
    - options:
      - automatic_rename: on
      layout: tiled
      panes:
      - cd /usr/bin
      - cd /usr
      - cd /sbin
      - cd /home
    """

    def test_pane_order(self):

        # test order of `panes` (and pane_index) above aganist pane_dirs
        pane_paths = [
            '/usr/bin',
            '/usr',
            '/sbin',
            '/home'
        ]
        s = self.session
        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(self.yaml_config).get()
        sconfig = config.expand(sconfig)
        sconfig = config.trickle(sconfig)

        builder = WorkspaceBuilder(sconf=sconfig)

        window_count = len(self.session._windows)  # current window count
        self.assertEqual(len(s._windows), window_count)
        for w, wconf in builder.iter_create_windows(s):
            window_pane_count = len(w._panes)
            for p in builder.iter_create_panes(w, wconf):
                p = p
                self.assertEqual(len(s._windows), window_count)

            self.assertIsInstance(w, Window)

            self.assertEqual(len(s._windows), window_count)
            window_count += 1

        for w in self.session.windows:
            pane_base_index = w.show_window_option('pane-base-index', g=True)
            for p_index, p in enumerate(w.list_panes(), start=pane_base_index):
                self.assertEqual(int(p_index), int(p.get('pane_index')))

                # pane-base-index start at base-index, pane_paths always start
                # at 0 since python list.
                pane_path = pane_paths[p_index - pane_base_index]

                for i in range(60):
                    p.server._update_panes()
                    if p.get('pane_current_path') == pane_path:
                        break
                    time.sleep(.2)

                self.assertEqual(p.get('pane_current_path'), pane_path)


class WindowIndexTest(TmuxTestCase):
    yaml_config = """
    session_name: sampleconfig
    windows:
    - window_name: zero
      panes:
      - echo 'zero'
    - window_name: five
      panes:
      - echo 'five'
      window_index: 5
    - window_name: one
      panes:
      - echo 'one'
    """

    def test_window_index(self):
        proc = self.session.tmux('show-option', '-gv', 'base-index')
        base_index = int(proc.stdout[0])
        name_index_map = {
            'zero': 0 + base_index,
            'one': 1 + base_index,
            'five': 5,
        }

        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(self.yaml_config).get()
        sconfig = config.expand(sconfig)
        sconfig = config.trickle(sconfig)

        builder = WorkspaceBuilder(sconf=sconfig)

        for window, wconf in builder.iter_create_windows(self.session):
            expected_index = name_index_map[window['window_name']]
            self.assertEqual(int(window['window_index']), expected_index)


class BeforeLoadScript(TmuxTestCase):

    config_script_not_exists = """
    session_name: sampleconfig
    before_script: {fixtures_dir}/script_not_exists.sh
    windows:
    - panes:
      - pane
    """

    config_script_fails = """
    session_name: sampleconfig
    before_script: {fixtures_dir}/script_failed.sh
    windows:
    - panes:
      - pane
    """

    config_script_completes = """
    session_name: sampleconfig
    before_script: {fixtures_dir}/script_complete.sh
    windows:
    - panes:
      - pane
    """

    def test_throw_error_if_retcode_error(self):

        sconfig = kaptan.Kaptan(handler='yaml')
        yaml = self.config_script_fails.format(
            fixtures_dir=fixtures_dir
        )
        sconfig = sconfig.import_config(yaml).get()
        sconfig = config.expand(sconfig)
        sconfig = config.trickle(sconfig)

        builder = WorkspaceBuilder(sconf=sconfig)

        with self.temp_session() as sess:
            session_name = sess.get('session_name')

            with self.assertRaises(exc.BeforeLoadScriptError):
                builder.build(session=sess)

            result = self.server.has_session(session_name)
            self.assertFalse(
                result,
                msg="Kills session if before_script exits with errcode"
            )

    def test_throw_error_if_file_not_exists(self):

        sconfig = kaptan.Kaptan(handler='yaml')
        yaml = self.config_script_not_exists.format(
            fixtures_dir=fixtures_dir
        )
        sconfig = sconfig.import_config(yaml).get()
        sconfig = config.expand(sconfig)
        sconfig = config.trickle(sconfig)

        builder = WorkspaceBuilder(sconf=sconfig)

        with self.temp_session() as sess:
            session_name = sess.get('session_name')
            temp_session_exists = self.server.has_session(sess.get('session_name'))
            self.assertTrue(temp_session_exists)
            with self.assertRaisesRegexp(
                (exc.BeforeLoadScriptNotExists, OSError),
                'No such file or directory'
            ):
                builder.build(session=sess)
            result = self.server.has_session(session_name)
            self.assertFalse(
                result,
                msg="Kills session if before_script doesn't exist"
            )

    def test_true_if_test_passes(self):

        sconfig = kaptan.Kaptan(handler='yaml')
        yaml = self.config_script_completes.format(
            fixtures_dir=fixtures_dir
        )
        sconfig = sconfig.import_config(yaml).get()
        sconfig = config.expand(sconfig)
        sconfig = config.trickle(sconfig)

        builder = WorkspaceBuilder(sconf=sconfig)

        with self.temp_session() as session:
            builder.build(session=self.session)


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(BeforeLoadScript))
    suite.addTest(unittest.makeSuite(BlankPaneTest))
    suite.addTest(unittest.makeSuite(FocusAndPaneIndexTest))
    suite.addTest(unittest.makeSuite(PaneOrderingTest))
    suite.addTest(unittest.makeSuite(StartDirectoryTest))
    suite.addTest(unittest.makeSuite(ThreePaneTest))
    suite.addTest(unittest.makeSuite(TwoPaneTest))
    suite.addTest(unittest.makeSuite(WindowAutomaticRename))
    suite.addTest(unittest.makeSuite(WindowIndexTest))
    suite.addTest(unittest.makeSuite(WindowOptions))
    return suite

########NEW FILE########
__FILENAME__ = workspacefreezer
# -*- coding: utf-8 -*-
"""Test for tmuxp workspacefreezer.

tmuxp.tests.workspacefreezer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import logging
import unittest
import time

import kaptan

from .. import Window, config, exc
from ..workspacebuilder import WorkspaceBuilder, freeze
from .helpers import TmuxTestCase

logger = logging.getLogger(__name__)

current_dir = os.path.abspath(os.path.dirname(__file__))
example_dir = os.path.abspath(os.path.join(current_dir, '..', '..'))


class FreezeTest(TmuxTestCase):

    yaml_config = """
    session_name: sampleconfig
    start_directory: '~'
    windows:
    - layout: main-vertical
      panes:
      - shell_command:
        - vim
        start_directory: '~'
      - shell_command:
        - echo "hey"
        - cd ../
      window_name: editor
    - panes:
      - shell_command:
        - pane
        start_directory: /usr/bin
      window_name: logging
    - window_name: test
      panes:
      - shell_command:
        - top
    """

    def test_focus(self):
        # assure the built yaml config has focus
        pass

    def test_freeze_config(self):
        sconfig = kaptan.Kaptan(handler='yaml')
        sconfig = sconfig.import_config(self.yaml_config).get()

        builder = WorkspaceBuilder(sconf=sconfig)
        builder.build(session=self.session)
        assert(self.session == builder.session)

        time.sleep(.50)

        session = self.session
        sconf = freeze(session)

        config.validate_schema(sconf)

        sconf = config.inline(sconf)

        kaptanconf = kaptan.Kaptan()
        kaptanconf = kaptanconf.import_config(sconf)
        json = kaptanconf.export(
            'json',
            indent=2
        )
        yaml = kaptanconf.export(
            'yaml',
            indent=2,
            default_flow_style=False,
            safe=True
        )


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(FreezeTest))
    return suite

########NEW FILE########
__FILENAME__ = util
# -*- coding: utf-8 -*-
"""Utility and helper methods for tmuxp.

tmuxp.util
~~~~~~~~~~

"""
from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import unittest
import collections
import subprocess
import re
import os
import sys
import logging

from distutils.version import StrictVersion

from . import exc

from ._compat import console_to_str

logger = logging.getLogger(__name__)

PY2 = sys.version_info[0] == 2


def run_before_script(script_file):
    """Function to wrap try/except for subprocess.check_call()."""
    try:
        proc = subprocess.Popen(
            script_file,
            stderr=subprocess.PIPE
        )
        proc.wait()

        if proc.returncode:
            stderr = proc.stderr.read()
            proc.stderr.close()
            stderr = console_to_str(stderr).split('\n')
            stderr = '\n'.join(list(filter(None, stderr)))  # filter empty values

            raise exc.BeforeLoadScriptError(proc.returncode, os.path.abspath(script_file), stderr)

        return proc.returncode
    except OSError as e:
        if e.errno == 2:
            raise exc.BeforeLoadScriptNotExists(e, os.path.abspath(script_file))
        else:
            raise(e)


class tmux(object):

    """:py:mod:`subprocess` for :term:`tmux(1)`.

    Usage::

        proc = tmux('new-session', '-s%' % 'my session')

        if proc.stderr:
            raise exc.TmuxpException(
                'Command: %s returned error: %s' % (proc.cmd, proc.stderr)
            )

        print('tmux command returned %s' % proc.stdout)

    Equivalent to:

    .. code-block:: bash

        $ tmux new-session -s my session

    """

    def __init__(self, *args, **kwargs):
        cmd = [which('tmux')]
        cmd += args  # add the command arguments to cmd
        cmd = [str(c) for c in cmd]

        self.cmd = cmd

        try:
            self.process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
            self.process.wait()
            stdout = self.process.stdout.read()
            self.process.stdout.close()
            stderr = self.process.stderr.read()
            self.process.stderr.close()
        except Exception as e:
            logger.error(
                'Exception for %s: \n%s' % (
                    subprocess.list2cmdline(cmd),
                    e
                )
            )

        self.stdout = console_to_str(stdout)
        self.stdout = self.stdout.split('\n')
        self.stdout = list(filter(None, self.stdout))  # filter empty values

        self.stderr = console_to_str(stderr)
        self.stderr = self.stderr.split('\n')
        self.stderr = list(filter(None, self.stderr))  # filter empty values

        if 'has-session' in cmd and len(self.stderr):
            if not self.stdout:
                self.stdout = self.stderr[0]

        logging.debug('self.stdout for %s: \n%s' %
                      (' '.join(cmd), self.stdout))


class TmuxMappingObject(collections.MutableMapping):

    """Base: :py:class:`collections.MutableMapping`.

    Convenience container. Base class for :class:`Pane`, :class:`Window`,
    :class:`Session` and :class:`Server`.

    Instance attributes for useful information :term:`tmux(1)` uses for
    Session, Window, Pane, stored :attr:`self._TMUX`. For example, a
    :class:`Window` will have a ``window_id`` and ``window_name``.

    """

    def __getitem__(self, key):
        return self._TMUX[key]

    def __setitem__(self, key, value):
        self._TMUX[key] = value
        self.dirty = True

    def __delitem__(self, key):
        del self._TMUX[key]
        self.dirty = True

    def keys(self):
        """Return list of keys."""
        return self._TMUX.keys()

    def __iter__(self):
        return self._TMUX.__iter__()

    def __len__(self):
        return len(self._TMUX.keys())


class TmuxRelationalObject(object):

    """Base Class for managing tmux object child entities.

    Manages collection of child objects  (a :class:`Server` has a collection of
    :class:`Session` objects, a :class:`Session` has collection of
    :class:`Window`)

    Children of :class:`TmuxRelationalObject` are going to have a
    ``self.children``, ``self.childIdAttribute`` and ``self.list_children``.

    ================ ================== ===================== ============================
    Object           ``.children``      ``.childIdAttribute`` method
    ================ ================== ===================== ============================
    :class:`Server`  ``self._sessions`` 'session_id'          :meth:`Server.list_sessions`
    :class:`Session` ``self._windows``  'window_id'           :meth:`Session.list_windows`
    :class:`Window`  ``self._panes``    'pane_id'             :meth:`Window.list_panes`
    :class:`Pane`
    ================ ================== ===================== ============================

    """

    def findWhere(self, attrs):
        """Return object on first match.

        Based on `.findWhere()`_ from `underscore.js`_.

        .. _.findWhere(): http://underscorejs.org/#findWhere
        .. _underscore.js: http://underscorejs.org/

        """
        try:
            return self.where(attrs)[0]
        except IndexError:
            return None

    def where(self, attrs, first=False):
        """Return objects matching child objects properties.

        Based on `.where()`_ from `underscore.js`_.

        .. _.where(): http://underscorejs.org/#where
        .. _underscore.js: http://underscorejs.org/

        :param attrs: tmux properties to match
        :type attrs: dict
        :rtype: list

        """

        # from https://github.com/serkanyersen/underscore.py
        def by(val, *args):
            for key, value in attrs.items():
                try:
                    if attrs[key] != val[key]:
                        return False
                except KeyError:
                    return False
                return True

        if first:
            return list(filter(by, self.children))[0]
        else:
            return list(filter(by, self.children))

    def getById(self, id):
        """Return object based on ``childIdAttribute``.

        Based on `.get()`_ from `backbone.js`_.

        .. _backbone.js: http://backbonejs.org/
        .. _.get(): http://backbonejs.org/#Collection-get

        :param id:
        :type id: string
        :rtype: object

        """
        for child in self.children:
            if child[self.childIdAttribute] == id:
                return child
            else:
                continue

        return None


def which(exe=None):
    """Return path of bin. Python clone of /usr/bin/which.

    from salt.util - https://www.github.com/saltstack/salt - license apache

    :param exe: Application to search PATHs for.
    :type exe: string
    :rtype: string

    """
    if exe:
        if os.access(exe, os.X_OK):
            return exe

        # default path based on busybox's default
        default_path = '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin'
        search_path = os.environ.get('PATH', default_path)

        for path in search_path.split(os.pathsep):
            full_path = os.path.join(path, exe)
            if os.access(full_path, os.X_OK):
                return full_path
        raise exc.TmuxpException(
            '{0!r} could not be found in the following search '
            'path: {1!r}'.format(
                exe, search_path
            )
        )
    logger.error('No executable was passed to be searched by which')
    return None


def is_version(version):
    """Return True if tmux version installed.

    :param version: version, '1.8'
    :param type: string
    :rtype: bool

    """
    proc = tmux('-V')

    if proc.stderr:
        raise exc.TmuxpException(proc.stderr)

    installed_version = proc.stdout[0].split('tmux ')[1]

    return StrictVersion(installed_version) == StrictVersion(version)


def has_required_tmux_version(version=None):
    """Return if tmux meets version requirement. Version >1.8 or above.

    :versionchanged: 0.1.7
        Versions will now remove trailing letters per `Issue 55`_.

        .. _Issue 55: https://github.com/tony/tmuxp/issues/55.

    """

    if not version:
        proc = tmux('-V')

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        version = proc.stdout[0].split('tmux ')[1]

    version = re.sub(r'[a-z]', '', version)

    if StrictVersion(version) <= StrictVersion("1.7"):
        raise exc.TmuxpException(
            'tmuxp only supports tmux 1.8 and greater. This system'
            ' has %s installed. Upgrade your tmux to use tmuxp.' % version
        )
    return version


def oh_my_zsh_auto_title():
    """Give warning and offer to fix ``DISABLE_AUTO_TITLE``.

    see: https://github.com/robbyrussell/oh-my-zsh/pull/257

    """

    if 'SHELL' in os.environ and 'zsh' in os.environ.get('SHELL'):
        if os.path.exists(os.path.expanduser('~/.oh-my-zsh')):
            # oh-my-zsh exists
            if (
                'DISABLE_AUTO_TITLE' not in os.environ or
                os.environ.get('DISABLE_AUTO_TITLE') == "false"
            ):
                print('Please set:\n\n'
                      '\texport DISABLE_AUTO_TITLE = \'true\'\n\n'
                      'in ~/.zshrc or where your zsh profile is stored.\n'
                      'Remember the "export" at the beginning!\n\n'
                      'Then create a new shell or type:\n\n'
                      '\t$ source ~/.zshrc')

########NEW FILE########
__FILENAME__ = window
# -*- coding: utf-8 -*-
"""Pythonization of the :term:`tmux(1)` window.

tmuxp.window
~~~~~~~~~~~~

"""
from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import logging

from . import util, formats, exc
from .pane import Pane

logger = logging.getLogger(__name__)


class Window(util.TmuxMappingObject, util.TmuxRelationalObject):

    """:term:`tmux(1)` window."""

    childIdAttribute = 'pane_id'

    def __init__(self, session=None, **kwargs):

        if not session:
            raise ValueError('Window requires a Session, session=Session')

        self.session = session
        self.server = self.session.server

        if not 'window_id' in kwargs:
            raise ValueError('Window requires a `window_id`')

        self._window_id = kwargs['window_id']

    def __repr__(self):
        return "%s(%s %s:%s, %s)" % (
            self.__class__.__name__,
            self.get('window_id'),
            self.get('window_index'),
            self.get('window_name'),
            self.session
        )

    @property
    def _TMUX(self, *args):

        attrs = {
            'window_id': self._window_id
        }

        # from https://github.com/serkanyersen/underscore.py
        def by(val, *args):
            for key, value in attrs.items():
                try:
                    if attrs[key] != val[key]:
                        return False
                except KeyError:
                    return False
                return True

        return list(filter(by, self.server._windows))[0]

    def tmux(self, cmd, *args, **kwargs):
        """Return :meth:`Server.tmux` defaulting ``target_window`` as target.

        Send command to tmux with :attr:`window_id` as ``target-window``.

        Specifying ``('-t', 'custom-target')`` or ``('-tcustom_target')`` in
        ``args`` will override using the object's ``window_id`` as target.

        :rtype: :class:`Server.tmux`

        """
        if not any(arg.startswith('-t') for arg in args):
            args = ('-t', self.get('window_id')) + args

        return self.server.tmux(cmd, *args, **kwargs)

    def select_layout(self, layout=None):
        """Wrapper for ``$ tmux select-layout <layout>``.

        even-horizontal: Panes are spread out evenly from left to right across
        the window.

        even-vertical: Panes are spread evenly from top to bottom.

        main-horizontal: A large (main) pane is shown at the top of the window
        and the remaining panes are spread from left to right in the leftover
        space at the bottom.

        main-vertical: Similar to main-horizontal but the large pane is placed
        on the left and the others spread from top to bottom along the right.

        tiled: Panes are spread out as evenly as possible over the window in
        both rows and columns.

        custom: custom dimensions (see :term:`tmux(1)` manpages).

        :param layout: string of the layout, 'even-horizontal', 'tiled', etc.
        :type layout: string

        """

        proc = self.tmux(
            'select-layout',
            '-t%s:%s' % (self.get('session_id'), self.get('window_index')),
            layout
        )

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

    def set_window_option(self, option, value):
        """Wrapper for ``$ tmux set-window-option <option> <value>``.

        :param value: window value. True/False will turn in 'on' and 'off'.
        :type value: string or bool

        """

        self.server._update_windows()

        if isinstance(value, bool) and value:
            value = 'on'
        elif isinstance(value, bool) and not value:
            value = 'off'

        process = self.tmux(
            'set-window-option',
            '-t%s:%s' % (self.get('session_id'), self.get('window_index')),
            #'-t%s' % self.get('window_id'),
            option, value
        )

        if process.stderr:
            if isinstance(process.stderr, list) and len(process.stderr):
                process.stderr = process.stderr[0]
            raise ValueError(
                'tmux set-window-option -t%s:%s %s %s\n' % (
                    self.get('session_id'),
                    self.get('window_index'),
                    option,
                    value
                ) +
                process.stderr
            )

    def show_window_options(self, option=None, g=False):
        """Return a dict of options for the window.

        For familiarity with tmux, the option ``option`` param forwards to pick
        a single option, forwarding to :meth:`Window.show_window_option`.

        :param option: optional. show a single option.
        :type option: string
        :param g: Pass ``-g`` flag for global variable
        :type g: bool
        :rtype: :py:obj:`dict`

        """

        tmux_args = tuple()

        if g:
            tmux_args += ('-g',)

        if option:
            return self.show_window_option(option, g=g)
        else:
            tmux_args += ('show-window-options',)
            window_options = self.tmux(
                *tmux_args
            ).stdout

        window_options = [tuple(item.split(' ')) for item in window_options]

        window_options = dict(window_options)

        for key, value in window_options.items():
            if value.isdigit():
                window_options[key] = int(value)

        return window_options

    def show_window_option(self, option, g=False):
        """Return a list of options for the window.

        todo: test and return True/False for on/off string

        :param option: option to return.
        :type option: string
        :param g: Pass ``-g`` flag, global.
        :type g: bool
        :rtype: string, int

        """

        tmux_args = tuple()

        if g:
            tmux_args += ('-g',)

        tmux_args += (option,)

        window_option = self.tmux(
            'show-window-options', *tmux_args
        ).stdout

        if window_option:
            window_option = [tuple(item.split(' '))
                             for item in window_option][0]
        else:
            return None

        if window_option[1].isdigit():
            window_option = (window_option[0], int(window_option[1]))

        return window_option[1]

    def rename_window(self, new_name):
        """Return :class:`Window` object ``$ tmux rename-window <new_name>``.

        :param new_name: name of the window
        :type new_name: string

        """

        import shlex
        lex = shlex.shlex(new_name)
        lex.escape = ' '
        lex.whitespace_split = False

        try:
            self.tmux(
                'rename-window',
                new_name
            )
            self['window_name'] = new_name
        except Exception as e:
            logger.error(e)

        self.server._update_windows()

        return self

    def kill_window(self):
        """Kill the current :class:`Window` object. ``$ tmux kill-window``."""

        proc = self.tmux(
            'kill-window',
            #'-t:%s' % self.get('window_id')
            '-t%s:%s' % (self.get('session_id'), self.get('window_index')),
        )

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        self.server._update_windows()

    def move_window(self, destination):
        """Move the current :class:`Window` object ``$ tmux move-window``.

        :param destination: the ``target window`` or index to move the window
            to.
        :type target_window: string

        """

        proc = self.tmux(
            'move-window',
            '-s%s:%s' % (self.get('session_id'), self.get('window_index')),
            '-t%s:%s' % (self.get('session_id'), destination),
        )

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        self.server._update_windows()

    def select_window(self):
        """Select window. Return ``self``.

        To select a window object asynchrously. If a ``window`` object exists
        and is no longer longer the current window, ``w.select_window()``
        will make ``w`` the current window.

        :rtype: :class:`Window`

        """
        target = '%s:%s' % (self.get('session_id'), self.get('window_index')),
        return self.session.select_window(target)

    def select_pane(self, target_pane):
        """Return selected :class:`Pane` through ``$ tmux select-pane``.

        :param target_pane: ``target_pane``, or ``-U``,``-D``, ``-L``, ``-R``
            or ``-l``.
        :type target_pane: string
        :rtype: :class:`Pane`

        """

        if target_pane in ['-l', '-U', '-D', '-L', '-R']:
            proc = self.tmux(
                'select-pane',
                '-t%s' % self.get('window_id'),
                target_pane
            )
        else:
            proc = self.tmux('select-pane', '-t%s' % target_pane)

        if proc.stderr:
            raise exc.TmuxpException(proc.stderr)

        return self.attached_pane()

    def last_pane(self):
        """Return last pane."""
        return self.select_pane('-l')

    def split_window(
        self,
        target=None,
        start_directory=None,
        attach=True
    ):
        """Split window and return the created :class:`Pane`.

        .. note::

            :term:`tmux(1)` will move window to the new pane if the
            ``split-window`` target is off screen. tmux handles the ``-d`` the
            same way as ``new-window`` and ``attach`` in
            :class:`Session.new_window`.

            By default, this will make the window the pane is created in
            active. To remain on the same window and split the pane in another
            target window, pass in ``attach=False``.


        Used for splitting window and holding in a python object.

        :param attach: make new window the current window after creating it,
                       default True.
        :type attach: bool
        :param start_directory: specifies the working directory in which the
            new created.
        :type start_directory: string
        :param target: ``target_pane`` to split.
        :type target: bool

        :rtype: :class:`Pane`

        """

        pformats = ['session_name', 'session_id',
                    'window_index', 'window_id'] + formats.PANE_FORMATS
        tmux_formats = ['#{%s}\t' % f for f in pformats]

        #'-t%s' % self.attached_pane().get('pane_id'),
        # 2013-10-18 LOOK AT THIS, rm'd it..
        tmux_args = tuple()

        if target:
            tmux_args += ('-t%s' % target,)
        else:
            tmux_args += ('-t%s' % self.panes[0].get('pane_id'),)

        tmux_args += (
            '-P', '-F%s' % ''.join(tmux_formats)     # output
        )

        if start_directory:
            # as of 2014-02-08 tmux 1.9-dev doesn't expand ~ in new-window -c.
            start_directory = os.path.expanduser(start_directory)
            tmux_args += ('-c%s' % start_directory,)

        if not attach:
            tmux_args += ('-d',)

        pane = self.tmux(
            'split-window',
            *tmux_args
        )

        # tmux < 1.7. This is added in 1.7.
        if pane.stderr:
            raise exc.TmuxpException(pane.stderr)
            if 'pane too small' in pane.stderr:
                pass

            raise exc.TmuxpException(pane.stderr, self._TMUX, self.panes)
        else:
            pane = pane.stdout[0]

            pane = dict(zip(pformats, pane.split('\t')))

            # clear up empty dict
            pane = dict((k, v) for k, v in pane.items() if v)

        return Pane(window=self, **pane)

    def attached_pane(self):
        """Return the attached :class:`Pane`.

        :rtype: :class:`Pane`

        """
        for pane in self._panes:
            if 'pane_active' in pane:
                # for now pane_active is a unicode
                if pane.get('pane_active') == '1':
                    # return Pane(window=self, **pane)
                    return Pane(window=self, **pane)
                else:
                    continue

        return []

    def _list_panes(self):
        panes = self.server._update_panes()._panes

        panes = [
            p for p in panes if p['session_id'] == self.get('session_id')
        ]
        panes = [
            p for p in panes if p['window_id'] == self.get('window_id')
        ]
        return panes

    @property
    def _panes(self):
        """Property / alias to return :meth:`~._list_panes`."""

        return self._list_panes()

    def list_panes(self):
        """Return list of :class:`Pane` for the window.

        :rtype: list of :class:`Pane`

        """

        return [Pane(window=self, **pane) for pane in self._panes]

    @property
    def panes(self):
        """Property / alias to return :meth:`~.list_panes`."""
        return self.list_panes()
    #: Alias of :attr:`panes`.
    children = panes

########NEW FILE########
__FILENAME__ = workspacebuilder
# -*- coding: utf8 -*-
"""Create a tmux workspace from a configuration :py:obj:`dict`.

tmuxp.workspacebuilder
~~~~~~~~~~~~~~~~~~~~~~

"""

from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import os
import logging
import subprocess

from . import exc, config, Window, Pane, Session, Server
from ._compat import PY2, console_to_str
from .util import run_before_script

logger = logging.getLogger(__name__)


class WorkspaceBuilder(object):

    """Load workspace from session :py:obj:`dict`.

    Build tmux workspace from a configuration. Creates and names windows, sets
    options, splits windows into panes.

    The normal phase of loading is:

        1.  :term:`kaptan` imports json/yaml/ini. ``.get()`` returns python
            :class:`dict`::

                import kaptan
                sconf = kaptan.Kaptan(handler='yaml')
                sconf = sconfig.import_config(self.yaml_config).get()

            or from config file with extension::

                import kaptan
                sconf = kaptan.Kaptan()
                sconf = sconfig.import_config('path/to/config.yaml').get()

            kaptan automatically detects the handler from filenames.

        2.  :meth:`config.expand` sconf inline shorthand::

                from tmuxp import config
                sconf = config.expand(sconf)

        3.  :meth:`config.trickle` passes down default values from session
            -> window -> pane if applicable::

                sconf = config.trickle(sconf)

        4.  (You are here) We will create a :class:`Session` (a real
            ``tmux(1)`` session) and iterate through the list of windows, and
            their panes, returning full :class:`Window` and :class:`Pane`
            objects each step of the way::

                workspace = WorkspaceBuilder(sconf=sconf)

    It handles the magic of cases where the user may want to start
    a session inside tmux (when `$TMUX` is in the env variables).

    """

    def __init__(self, sconf, server=None):
        """Initialize workspace loading.

        :todo: initialize :class:`Session` from here, in ``self.session``.

        :param sconf: session config, includes a :py:obj:`list` of ``windows``.
        :type sconf: :py:obj:`dict`

        :param server:
        :type server: :class:`Server`

        """

        if not sconf:
            raise exc.EmptyConfigException('session configuration is empty.')

        # config.validate_schema(sconf)

        if isinstance(server, Server):
            self.server = server
        else:
            self.server = None

        self.sconf = sconf

    def build(self, session=None):
        """Build tmux workspace in session.

        Optionally accepts ``session`` to build with only session object.

        Without ``session``, it will use :class:`Server` at ``self.server``
        passed in on initialization to create a new Session object.

        :param session: - session to build workspace in
        :type session: :class:`Session`

        """

        if not session:
            if not self.server:
                raise exc.TmuxpException(
                    'WorkspaceBuilder.build requires server to be passed ' +
                    'on initialization, or pass in session object to here.'
                )

            if self.server.has_session(self.sconf['session_name']):
                self.session = self.server.findWhere(
                    {
                        'session_name': self.sconf['session_name']
                    }
                )
                raise exc.TmuxSessionExists(
                    'Session name %s is already running.' %
                    self.sconf['session_name']
                )
            else:
                session = self.server.new_session(
                    session_name=self.sconf['session_name']
                )

            assert(self.sconf['session_name'] == session.get('session_name'))
            assert(len(self.sconf['session_name']) > 0)

        self.session = session
        self.server = session.server

        self.server._list_sessions()
        assert self.server.has_session(session.get('session_name'))
        assert session.get('session_id')

        assert(isinstance(session, Session))

        focus = None

        if 'before_script' in self.sconf:
            try:
                run_before_script(self.sconf['before_script'])
            except Exception as e:
                self.session.kill_session()
                raise(e)

        for w, wconf in self.iter_create_windows(session):
            assert(isinstance(w, Window))

            focus_pane = None
            for p, pconf in self.iter_create_panes(w, wconf):
                assert(isinstance(p, Pane))
                p = p

                if 'layout' in wconf:
                    w.select_layout(wconf['layout'])

                if 'focus' in pconf and pconf['focus']:
                    focus_pane = p

            if 'focus' in wconf and wconf['focus']:
                focus = w

            if focus_pane:
                focus_pane.select_pane()

        if focus:
            focus.select_window()

    def iter_create_windows(self, s):
        """Return :class:`Window` iterating through session config dict.

        Generator yielding :class:`Window` by iterating through
        ``sconf['windows']``.

        Applies ``window_options`` to window.

        :param session: :class:`Session` from the config
        :rtype: tuple(:class:`Window`, ``wconf``)

        """
        for i, wconf in enumerate(self.sconf['windows'], start=1):
            if 'window_name' not in wconf:
                window_name = None
            else:
                window_name = wconf['window_name']

            w1 = None
            if i == int(1):  # if first window, use window 1
                w1 = s.attached_window()
                w1.move_window(99)
                pass

            sd = wconf['start_directory'] if 'start_directory' in wconf else None
            w = s.new_window(
                window_name=window_name,
                start_directory=sd,
                attach=False,  # do not move to the new window
                window_index=wconf.get('window_index', ''),
            )

            if i == int(1) and w1:  # if first window, use window 1
                w1.kill_window()
            assert(isinstance(w, Window))
            s.server._update_windows()
            if 'options' in wconf and isinstance(wconf['options'], dict):
                for key, val in wconf['options'].items():
                    w.set_window_option(key, val)

            if 'focus' in wconf and wconf['focus']:
                w.select_window()

            s.server._update_windows()

            yield w, wconf

    def iter_create_panes(self, w, wconf):
        """Return :class:`Pane` iterating through window config dict.

        Run ``shell_command`` with ``$ tmux send-keys``.

        :param w: window to create panes for
        :type w: :class:`Window`
        :param wconf: config section for window
        :type wconf: :py:obj:`dict`
        :rtype: tuple(:class:`Pane`, ``pconf``)

        """
        assert(isinstance(w, Window))

        pane_base_index = int(w.show_window_option('pane-base-index', g=True))

        for pindex, pconf in enumerate(wconf['panes'], start=pane_base_index):

            if pindex == int(pane_base_index):
                p = w.attached_pane()

            else:
                def get_pane_start_directory():

                    if 'start_directory' in pconf:
                        return pconf['start_directory']
                    elif 'start_directory' in wconf:
                        return wconf['start_directory']
                    else:
                        return None
                p = w.split_window(
                    attach=True,
                    start_directory=get_pane_start_directory(),
                )

            assert(isinstance(p, Pane))
            assert(int(p.get('pane_index')) == int(pindex))
            if 'layout' in wconf:
                w.select_layout(wconf['layout'])

            for cmd in pconf['shell_command']:
                p.send_keys(cmd)

            if 'focus' in pconf and pconf['focus']:
                w.select_pane(p['pane_id'])

            w.server._update_panes()

            yield p, pconf


def freeze(session):
    """Freeze live tmux session and Return session config :py:obj:`dict`.

    :param session: session object
    :type session: :class:`Session`
    :rtype: dict

    """
    sconf = {}

    sconf['session_name'] = session['session_name']

    sconf['windows'] = []
    for w in session.windows:
        wconf = {}
        wconf['options'] = w.show_window_options()
        wconf['window_name'] = w.get('window_name')
        wconf['layout'] = w.get('window_layout')
        wconf['panes'] = []
        if w.get('window_active', '0') == '1':
            wconf['focus']='true'

        # If all panes have same path, set 'start_directory' instead
        # of using 'cd' shell commands.
        pane_has_same_path = lambda p: (
            w.panes[0].get('pane_current_path') ==
            p.get('pane_current_path')
        )

        if (all(pane_has_same_path(p) for p in w.panes)):
            wconf['start_directory'] = w.panes[0].get('pane_current_path')

        for p in w.panes:
            pconf = {}
            pconf['shell_command'] = []

            if 'start_directory' not in wconf:
                pconf['shell_command'].append(
                    'cd ' + p.get('pane_current_path')
                )
                
            if p.get('pane_active', '0') == '1':
                pconf['focus']='true'

            current_cmd = p.get('pane_current_command')

            def filter_interpretters_and_shells():
                return (
                    current_cmd.startswith('-') or
                    any(
                        current_cmd.endswith(cmd)
                        for cmd in ['python', 'ruby', 'node']
                    )
                )

            if (filter_interpretters_and_shells()):
                current_cmd = None

            if current_cmd:
                pconf['shell_command'].append(current_cmd)
            else:
                if not len(pconf['shell_command']):
                    pconf = 'pane'

            wconf['panes'].append(pconf)

        sconf['windows'].append(wconf)

    return sconf

########NEW FILE########
__FILENAME__ = _compat
# -*- coding: utf8 -*-
import sys

PY2 = sys.version_info[0] == 2

_identity = lambda x: x


if PY2:
    unichr = unichr
    text_type = unicode
    string_types = (str, unicode)
    integer_types = (int, long)
    from urllib import urlretrieve

    text_to_native = lambda s, enc: s.encode(enc)

    iterkeys = lambda d: d.iterkeys()
    itervalues = lambda d: d.itervalues()
    iteritems = lambda d: d.iteritems()

    from cStringIO import StringIO as BytesIO
    from StringIO import StringIO
    import cPickle as pickle
    import ConfigParser as configparser

    from itertools import izip, imap
    range_type = xrange

    cmp = cmp

    input = raw_input
    from string import lower as ascii_lowercase
    import urlparse

    exec('def reraise(tp, value, tb=None):\n raise tp, value, tb')

    def implements_to_string(cls):
        cls.__unicode__ = cls.__str__
        cls.__str__ = lambda x: x.__unicode__().encode('utf-8')
        return cls

    def console_to_str(s):
        return s.decode('utf_8')

else:
    unichr = chr
    text_type = str
    string_types = (str,)
    integer_types = (int, )

    text_to_native = lambda s, enc: s

    iterkeys = lambda d: iter(d.keys())
    itervalues = lambda d: iter(d.values())
    iteritems = lambda d: iter(d.items())

    from io import StringIO, BytesIO
    import pickle
    import configparser

    izip = zip
    imap = map
    range_type = range

    cmp = lambda a, b: (a > b) - (a < b)

    input = input
    from string import ascii_lowercase
    import urllib.parse as urllib
    import urllib.parse as urlparse
    from urllib.request import urlretrieve

    console_encoding = sys.__stdout__.encoding

    implements_to_string = _identity

    def console_to_str(s):
        """ From pypa/pip project, pip.backwardwardcompat. License MIT. """
        try:
            return s.decode(console_encoding)
        except UnicodeDecodeError:
            return s.decode('utf_8')

    def reraise(tp, value, tb=None):
        if value.__traceback__ is not tb:
            raise(value.with_traceback(tb))
        raise value


number_types = integer_types + (float,)

########NEW FILE########
__FILENAME__ = ansi
# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
'''
This module generates ANSI character codes to printing colors to terminals.
See: http://en.wikipedia.org/wiki/ANSI_escape_code
'''

CSI = '\033['

def code_to_chars(code):
    return CSI + str(code) + 'm'

class AnsiCodes(object):
    def __init__(self, codes):
        for name in dir(codes):
            if not name.startswith('_'):
                value = getattr(codes, name)
                setattr(self, name, code_to_chars(value))

class AnsiFore:
    BLACK   = 30
    RED     = 31
    GREEN   = 32
    YELLOW  = 33
    BLUE    = 34
    MAGENTA = 35
    CYAN    = 36
    WHITE   = 37
    RESET   = 39

class AnsiBack:
    BLACK   = 40
    RED     = 41
    GREEN   = 42
    YELLOW  = 43
    BLUE    = 44
    MAGENTA = 45
    CYAN    = 46
    WHITE   = 47
    RESET   = 49

class AnsiStyle:
    BRIGHT    = 1
    DIM       = 2
    NORMAL    = 22
    RESET_ALL = 0

Fore = AnsiCodes( AnsiFore )
Back = AnsiCodes( AnsiBack )
Style = AnsiCodes( AnsiStyle )


########NEW FILE########
__FILENAME__ = ansitowin32
# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
import re
import sys

from .ansi import AnsiFore, AnsiBack, AnsiStyle, Style
from .winterm import WinTerm, WinColor, WinStyle
from .win32 import windll


if windll is not None:
    winterm = WinTerm()


def is_a_tty(stream):
    return hasattr(stream, 'isatty') and stream.isatty()


class StreamWrapper(object):
    '''
    Wraps a stream (such as stdout), acting as a transparent proxy for all
    attribute access apart from method 'write()', which is delegated to our
    Converter instance.
    '''
    def __init__(self, wrapped, converter):
        # double-underscore everything to prevent clashes with names of
        # attributes on the wrapped stream object.
        self.__wrapped = wrapped
        self.__convertor = converter

    def __getattr__(self, name):
        return getattr(self.__wrapped, name)

    def write(self, text):
        self.__convertor.write(text)


class AnsiToWin32(object):
    '''
    Implements a 'write()' method which, on Windows, will strip ANSI character
    sequences from the text, and if outputting to a tty, will convert them into
    win32 function calls.
    '''
    ANSI_RE = re.compile('\033\[((?:\d|;)*)([a-zA-Z])')

    def __init__(self, wrapped, convert=None, strip=None, autoreset=False):
        # The wrapped stream (normally sys.stdout or sys.stderr)
        self.wrapped = wrapped

        # should we reset colors to defaults after every .write()
        self.autoreset = autoreset

        # create the proxy wrapping our output stream
        self.stream = StreamWrapper(wrapped, self)

        on_windows = sys.platform.startswith('win')

        # should we strip ANSI sequences from our output?
        if strip is None:
            strip = on_windows
        self.strip = strip

        # should we should convert ANSI sequences into win32 calls?
        if convert is None:
            convert = on_windows and is_a_tty(wrapped)
        self.convert = convert

        # dict of ansi codes to win32 functions and parameters
        self.win32_calls = self.get_win32_calls()

        # are we wrapping stderr?
        self.on_stderr = self.wrapped is sys.stderr


    def should_wrap(self):
        '''
        True if this class is actually needed. If false, then the output
        stream will not be affected, nor will win32 calls be issued, so
        wrapping stdout is not actually required. This will generally be
        False on non-Windows platforms, unless optional functionality like
        autoreset has been requested using kwargs to init()
        '''
        return self.convert or self.strip or self.autoreset


    def get_win32_calls(self):
        if self.convert and winterm:
            return {
                AnsiStyle.RESET_ALL: (winterm.reset_all, ),
                AnsiStyle.BRIGHT: (winterm.style, WinStyle.BRIGHT),
                AnsiStyle.DIM: (winterm.style, WinStyle.NORMAL),
                AnsiStyle.NORMAL: (winterm.style, WinStyle.NORMAL),
                AnsiFore.BLACK: (winterm.fore, WinColor.BLACK),
                AnsiFore.RED: (winterm.fore, WinColor.RED),
                AnsiFore.GREEN: (winterm.fore, WinColor.GREEN),
                AnsiFore.YELLOW: (winterm.fore, WinColor.YELLOW),
                AnsiFore.BLUE: (winterm.fore, WinColor.BLUE),
                AnsiFore.MAGENTA: (winterm.fore, WinColor.MAGENTA),
                AnsiFore.CYAN: (winterm.fore, WinColor.CYAN),
                AnsiFore.WHITE: (winterm.fore, WinColor.GREY),
                AnsiFore.RESET: (winterm.fore, ),
                AnsiBack.BLACK: (winterm.back, WinColor.BLACK),
                AnsiBack.RED: (winterm.back, WinColor.RED),
                AnsiBack.GREEN: (winterm.back, WinColor.GREEN),
                AnsiBack.YELLOW: (winterm.back, WinColor.YELLOW),
                AnsiBack.BLUE: (winterm.back, WinColor.BLUE),
                AnsiBack.MAGENTA: (winterm.back, WinColor.MAGENTA),
                AnsiBack.CYAN: (winterm.back, WinColor.CYAN),
                AnsiBack.WHITE: (winterm.back, WinColor.GREY),
                AnsiBack.RESET: (winterm.back, ),
            }


    def write(self, text):
        if self.strip or self.convert:
            self.write_and_convert(text)
        else:
            self.wrapped.write(text)
            self.wrapped.flush()
        if self.autoreset:
            self.reset_all()


    def reset_all(self):
        if self.convert:
            self.call_win32('m', (0,))
        elif is_a_tty(self.wrapped):
            self.wrapped.write(Style.RESET_ALL)


    def write_and_convert(self, text):
        '''
        Write the given text to our wrapped stream, stripping any ANSI
        sequences from the text, and optionally converting them into win32
        calls.
        '''
        cursor = 0
        for match in self.ANSI_RE.finditer(text):
            start, end = match.span()
            self.write_plain_text(text, cursor, start)
            self.convert_ansi(*match.groups())
            cursor = end
        self.write_plain_text(text, cursor, len(text))


    def write_plain_text(self, text, start, end):
        if start < end:
            self.wrapped.write(text[start:end])
            self.wrapped.flush()


    def convert_ansi(self, paramstring, command):
        if self.convert:
            params = self.extract_params(paramstring)
            self.call_win32(command, params)


    def extract_params(self, paramstring):
        def split(paramstring):
            for p in paramstring.split(';'):
                if p != '':
                    yield int(p)
        return tuple(split(paramstring))


    def call_win32(self, command, params):
        if params == []:
            params = [0]
        if command == 'm':
            for param in params:
                if param in self.win32_calls:
                    func_args = self.win32_calls[param]
                    func = func_args[0]
                    args = func_args[1:]
                    kwargs = dict(on_stderr=self.on_stderr)
                    func(*args, **kwargs)
        elif command in ('H', 'f'): # set cursor position
            func = winterm.set_cursor_position
            func(params, on_stderr=self.on_stderr)
        elif command in ('J'):
            func = winterm.erase_data
            func(params, on_stderr=self.on_stderr)
        elif command == 'A':
            if params == () or params == None:
                num_rows = 1
            else:
                num_rows = params[0]
            func = winterm.cursor_up
            func(num_rows, on_stderr=self.on_stderr)


########NEW FILE########
__FILENAME__ = initialise
# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
import atexit
import sys

from .ansitowin32 import AnsiToWin32


orig_stdout = sys.stdout
orig_stderr = sys.stderr

wrapped_stdout = sys.stdout
wrapped_stderr = sys.stderr

atexit_done = False


def reset_all():
    AnsiToWin32(orig_stdout).reset_all()


def init(autoreset=False, convert=None, strip=None, wrap=True):

    if not wrap and any([autoreset, convert, strip]):
        raise ValueError('wrap=False conflicts with any other arg=True')

    global wrapped_stdout, wrapped_stderr
    sys.stdout = wrapped_stdout = \
        wrap_stream(orig_stdout, convert, strip, autoreset, wrap)
    sys.stderr = wrapped_stderr = \
        wrap_stream(orig_stderr, convert, strip, autoreset, wrap)

    global atexit_done
    if not atexit_done:
        atexit.register(reset_all)
        atexit_done = True


def deinit():
    sys.stdout = orig_stdout
    sys.stderr = orig_stderr


def reinit():
    sys.stdout = wrapped_stdout
    sys.stderr = wrapped_stdout


def wrap_stream(stream, convert, strip, autoreset, wrap):
    if wrap:
        wrapper = AnsiToWin32(stream,
            convert=convert, strip=strip, autoreset=autoreset)
        if wrapper.should_wrap():
            stream = wrapper.stream
    return stream



########NEW FILE########
__FILENAME__ = win32
# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.

# from winbase.h
STDOUT = -11
STDERR = -12

try:
    from ctypes import windll
    from ctypes import wintypes
except ImportError:
    windll = None
    SetConsoleTextAttribute = lambda *_: None
else:
    from ctypes import (
        byref, Structure, c_char, c_short, c_uint32, c_ushort, POINTER
    )

    class CONSOLE_SCREEN_BUFFER_INFO(Structure):
        """struct in wincon.h."""
        _fields_ = [
            ("dwSize", wintypes._COORD),
            ("dwCursorPosition", wintypes._COORD),
            ("wAttributes", wintypes.WORD),
            ("srWindow", wintypes.SMALL_RECT),
            ("dwMaximumWindowSize", wintypes._COORD),
        ]
        def __str__(self):
            return '(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)' % (
                self.dwSize.Y, self.dwSize.X
                , self.dwCursorPosition.Y, self.dwCursorPosition.X
                , self.wAttributes
                , self.srWindow.Top, self.srWindow.Left, self.srWindow.Bottom, self.srWindow.Right
                , self.dwMaximumWindowSize.Y, self.dwMaximumWindowSize.X
            )

    _GetStdHandle = windll.kernel32.GetStdHandle
    _GetStdHandle.argtypes = [
        wintypes.DWORD,
    ]
    _GetStdHandle.restype = wintypes.HANDLE

    _GetConsoleScreenBufferInfo = windll.kernel32.GetConsoleScreenBufferInfo
    _GetConsoleScreenBufferInfo.argtypes = [
        wintypes.HANDLE,
        POINTER(CONSOLE_SCREEN_BUFFER_INFO),
    ]
    _GetConsoleScreenBufferInfo.restype = wintypes.BOOL

    _SetConsoleTextAttribute = windll.kernel32.SetConsoleTextAttribute
    _SetConsoleTextAttribute.argtypes = [
        wintypes.HANDLE,
        wintypes.WORD,
    ]
    _SetConsoleTextAttribute.restype = wintypes.BOOL

    _SetConsoleCursorPosition = windll.kernel32.SetConsoleCursorPosition
    _SetConsoleCursorPosition.argtypes = [
        wintypes.HANDLE,
        wintypes._COORD,
    ]
    _SetConsoleCursorPosition.restype = wintypes.BOOL

    _FillConsoleOutputCharacterA = windll.kernel32.FillConsoleOutputCharacterA
    _FillConsoleOutputCharacterA.argtypes = [
        wintypes.HANDLE,
        c_char,
        wintypes.DWORD,
        wintypes._COORD,
        POINTER(wintypes.DWORD),
    ]
    _FillConsoleOutputCharacterA.restype = wintypes.BOOL

    _FillConsoleOutputAttribute = windll.kernel32.FillConsoleOutputAttribute
    _FillConsoleOutputAttribute.argtypes = [
        wintypes.HANDLE,
        wintypes.WORD,
        wintypes.DWORD,
        wintypes._COORD,
        POINTER(wintypes.DWORD),
    ]
    _FillConsoleOutputAttribute.restype = wintypes.BOOL

    handles = {
        STDOUT: _GetStdHandle(STDOUT),
        STDERR: _GetStdHandle(STDERR),
    }

    def GetConsoleScreenBufferInfo(stream_id=STDOUT):
        handle = handles[stream_id]
        csbi = CONSOLE_SCREEN_BUFFER_INFO()
        success = _GetConsoleScreenBufferInfo(
            handle, byref(csbi))
        return csbi

    def SetConsoleTextAttribute(stream_id, attrs):
        handle = handles[stream_id]
        return _SetConsoleTextAttribute(handle, attrs)

    def SetConsoleCursorPosition(stream_id, position):
        position = wintypes._COORD(*position)
        # If the position is out of range, do nothing.
        if position.Y <= 0 or position.X <= 0:
            return
        # Adjust for Windows' SetConsoleCursorPosition:
        #    1. being 0-based, while ANSI is 1-based.
        #    2. expecting (x,y), while ANSI uses (y,x).
        adjusted_position = wintypes._COORD(position.Y - 1, position.X - 1)
        # Adjust for viewport's scroll position
        sr = GetConsoleScreenBufferInfo(STDOUT).srWindow
        adjusted_position.Y += sr.Top
        adjusted_position.X += sr.Left
        # Resume normal processing
        handle = handles[stream_id]
        return _SetConsoleCursorPosition(handle, adjusted_position)

    def FillConsoleOutputCharacter(stream_id, char, length, start):
        handle = handles[stream_id]
        char = c_char(char)
        length = wintypes.DWORD(length)
        num_written = wintypes.DWORD(0)
        # Note that this is hard-coded for ANSI (vs wide) bytes.
        success = _FillConsoleOutputCharacterA(
            handle, char, length, start, byref(num_written))
        return num_written.value

    def FillConsoleOutputAttribute(stream_id, attr, length, start):
        ''' FillConsoleOutputAttribute( hConsole, csbi.wAttributes, dwConSize, coordScreen, &cCharsWritten )'''
        handle = handles[stream_id]
        attribute = wintypes.WORD(attr)
        length = wintypes.DWORD(length)
        num_written = wintypes.DWORD(0)
        # Note that this is hard-coded for ANSI (vs wide) bytes.
        return _FillConsoleOutputAttribute(
            handle, attribute, length, start, byref(num_written))

########NEW FILE########
__FILENAME__ = winterm
# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
from . import win32


# from wincon.h
class WinColor(object):
    BLACK   = 0
    BLUE    = 1
    GREEN   = 2
    CYAN    = 3
    RED     = 4
    MAGENTA = 5
    YELLOW  = 6
    GREY    = 7

# from wincon.h
class WinStyle(object):
    NORMAL = 0x00 # dim text, dim background
    BRIGHT = 0x08 # bright text, dim background


class WinTerm(object):

    def __init__(self):
        self._default = win32.GetConsoleScreenBufferInfo(win32.STDOUT).wAttributes
        self.set_attrs(self._default)
        self._default_fore = self._fore
        self._default_back = self._back
        self._default_style = self._style

    def get_attrs(self):
        return self._fore + self._back * 16 + self._style

    def set_attrs(self, value):
        self._fore = value & 7
        self._back = (value >> 4) & 7
        self._style = value & WinStyle.BRIGHT

    def reset_all(self, on_stderr=None):
        self.set_attrs(self._default)
        self.set_console(attrs=self._default)

    def fore(self, fore=None, on_stderr=False):
        if fore is None:
            fore = self._default_fore
        self._fore = fore
        self.set_console(on_stderr=on_stderr)

    def back(self, back=None, on_stderr=False):
        if back is None:
            back = self._default_back
        self._back = back
        self.set_console(on_stderr=on_stderr)

    def style(self, style=None, on_stderr=False):
        if style is None:
            style = self._default_style
        self._style = style
        self.set_console(on_stderr=on_stderr)

    def set_console(self, attrs=None, on_stderr=False):
        if attrs is None:
            attrs = self.get_attrs()
        handle = win32.STDOUT
        if on_stderr:
            handle = win32.STDERR
        win32.SetConsoleTextAttribute(handle, attrs)

    def get_position(self, handle):
        position = win32.GetConsoleScreenBufferInfo(handle).dwCursorPosition
        # Because Windows coordinates are 0-based,
        # and win32.SetConsoleCursorPosition expects 1-based.
        position.X += 1
        position.Y += 1
        return position
    
    def set_cursor_position(self, position=None, on_stderr=False):
        if position is None:
            #I'm not currently tracking the position, so there is no default.
            #position = self.get_position()
            return
        handle = win32.STDOUT
        if on_stderr:
            handle = win32.STDERR
        win32.SetConsoleCursorPosition(handle, position)

    def cursor_up(self, num_rows=0, on_stderr=False):
        if num_rows == 0:
            return
        handle = win32.STDOUT
        if on_stderr:
            handle = win32.STDERR
        position = self.get_position(handle)
        adjusted_position = (position.Y - num_rows, position.X)
        self.set_cursor_position(adjusted_position, on_stderr)

    def erase_data(self, mode=0, on_stderr=False):
        # 0 (or None) should clear from the cursor to the end of the screen.
        # 1 should clear from the cursor to the beginning of the screen.
        # 2 should clear the entire screen. (And maybe move cursor to (1,1)?)
        #
        # At the moment, I only support mode 2. From looking at the API, it
        #    should be possible to calculate a different number of bytes to clear,
        #    and to do so relative to the cursor position.
        if mode[0] not in (2,):
            return
        handle = win32.STDOUT
        if on_stderr:
            handle = win32.STDERR
        # here's where we'll home the cursor
        coord_screen = win32.COORD(0,0)
        csbi = win32.GetConsoleScreenBufferInfo(handle)
        # get the number of character cells in the current buffer
        dw_con_size = csbi.dwSize.X * csbi.dwSize.Y
        # fill the entire screen with blanks
        win32.FillConsoleOutputCharacter(handle, ' ', dw_con_size, coord_screen)
        # now set the buffer's attributes accordingly
        win32.FillConsoleOutputAttribute(handle, self.get_attrs(), dw_con_size, coord_screen );
        # put the cursor at (0, 0)
        win32.SetConsoleCursorPosition(handle, (coord_screen.X, coord_screen.Y))

########NEW FILE########
__FILENAME__ = __main__
# -*- coding: utf-8 -*-
"""For accessing tmuxp as a package.

tmuxp
~~~~~

"""
from __future__ import absolute_import, division, print_function, \
    with_statement, unicode_literals

import sys
import os


def run():
    """Assure tmuxp is in python path's and available as a package. """
    base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    sys.path.insert(0, base)
    import tmuxp.cli
    tmuxp.cli.main()

if __name__ == '__main__':
    exit = run()
    if exit:
        sys.exit(exit)

########NEW FILE########
