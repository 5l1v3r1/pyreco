__FILENAME__ = topaz_untranslated
#!/usr/bin/env python

import os
import sys


if __name__ == "__main__":
    os.execv(sys.executable, [sys.executable, "-m", "topaz"] + sys.argv[1:])

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Topaz documentation build configuration file, created by
# sphinx-quickstart on Tue May 22 16:43:32 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Topaz'
copyright = u'2012-2013, Alex Gaynor'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'pyramid'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Topazdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
}
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('index', 'Topaz.tex', u'Topaz Documentation', u'Alex Gaynor', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'topaz', u'Topaz Documentation',
     [u'Alex Gaynor'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    ('index', 'Topaz', u'Topaz Documentation', u'Alex Gaynor', 'Topaz', 'One line description of project.', 'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = targettopaz
from rpython.jit.codewriter.policy import JitPolicy

from topaz.main import create_entry_point, get_topaz_config_options


def target(driver, args):
    driver.exe_name = "bin/topaz"
    driver.config.set(**get_topaz_config_options())
    return create_entry_point(driver.config), None


def jitpolicy(driver):
    return JitPolicy()


def handle_config(config, translateconfig):
    config.translation.suggest(check_str_without_nul=True)

########NEW FILE########
__FILENAME__ = base
import os

from invoke import run


class BaseTest(object):
    def download_mspec(self):
        if not os.path.isdir("../mspec"):
            run("cd .. && git clone --depth=100 --quiet https://github.com/rubyspec/mspec")

    def download_rubyspec(self):
        if not os.path.isdir("../rubyspec"):
            run("cd .. && git clone --depth=100 --branch='1.x' --quiet https://github.com/rubyspec/rubyspec")
            run("cd ../rubyspec && git checkout 1.x")

########NEW FILE########
__FILENAME__ = specs
import invoke

from .base import BaseTest


class Rubyspecs(BaseTest):
    def __init__(self, files, options, untranslated=False):
        super(Rubyspecs, self).__init__()
        self.exe = "`pwd`/bin/%s" % ("topaz_untranslated.py" if untranslated else "topaz")
        self.files = files
        self.options = options
        self.download_mspec()
        self.download_rubyspec()

    def mspec(self, args):
        invoke.run("../mspec/bin/mspec %s -t %s --config=topaz.mspec %s" % (args, self.exe, self.files), echo=True)

    def run(self):
        self.mspec("run -G fails %s" % self.options)

    def tag(self):
        self.mspec("tag --add fails -G fails -f spec %s" % self.options)

    def untag(self):
        self.mspec("tag --del fails -g fails -f spec %s" % self.options)


def generate_spectask(taskname):
    def spectask(files="", options="", untranslated=False):
        runner = Rubyspecs(files, options, untranslated=untranslated)
        getattr(runner, taskname)()
    spectask.__name__ = taskname
    return invoke.task(spectask)


run = generate_spectask("run")
tag = generate_spectask("tag")
untag = generate_spectask("untag")

########NEW FILE########
__FILENAME__ = travis
import glob
import os
import struct
import sys

import invoke

import requests

from .base import BaseTest


class Test(BaseTest):
    def __init__(self, func, deps=[], needs_rpython=True, needs_rubyspec=False,
                 create_build=False):
        super(Test, self).__init__()
        self.func = func
        self.deps = deps
        self.needs_rpython = needs_rpython
        self.needs_rubyspec = needs_rubyspec
        self.create_build = create_build

    def install_deps(self):
        invoke.run("pip install {}".format(" ".join(self.deps)))

    def download_rpython(self):
        invoke.run("wget https://bitbucket.org/pypy/pypy/get/default.tar.bz2 -O `pwd`/../pypy.tar.bz2 || wget https://bitbucket.org/pypy/pypy/get/default.tar.bz2 -O `pwd`/../pypy.tar.bz2")
        invoke.run("tar -xf `pwd`/../pypy.tar.bz2 -C `pwd`/../")
        [path_name] = glob.glob("../pypy-pypy*")
        path_name = os.path.abspath(path_name)
        with open("rpython_marker", "w") as f:
            f.write(path_name)

    def run_tests(self):
        env = {}
        if self.needs_rpython:
            with open("rpython_marker") as f:
                env["rpython_path"] = f.read()
        self.func(env)

    def upload_build(self):
        if (os.environ["TRAVIS_BRANCH"] == "master" and
            "BUILD_SECRET" in os.environ):

            width = struct.calcsize("P") * 8
            if "linux" in sys.platform:
                platform = "linux{}".format(width)
            elif "darwin" in sys.platform:
                platform = "osx{}".format(width)
            elif "win" in sys.platform:
                platform = "windows{}".format(width)
            else:
                raise ValueError("Don't recognize platform: {!r}".format(sys.platform))
            build_name = "topaz-{platform}-{sha1}.tar.bz2".format(platform=platform, sha1=os.environ["TRAVIS_COMMIT"])
            invoke.run("python topaz/tools/make_release.py {}".format(build_name))
            with open(build_name, "rb") as f:
                response = requests.post("http://www.topazruby.com/builds/create/", {
                    "build_secret": os.environ["BUILD_SECRET"],
                    "sha1": os.environ["TRAVIS_COMMIT"],
                    "platform": platform,
                    "success": "true",
                }, files={"build": (build_name, f)})
                response.raise_for_status()


@invoke.task
def install_requirements():
    t = TEST_TYPES[os.environ["TEST_TYPE"]]
    if t.deps:
        t.install_deps()
    if t.needs_rpython:
        t.download_rpython()
    if t.needs_rubyspec:
        t.download_mspec()
        t.download_rubyspec()


@invoke.task
def run_tests():
    t = TEST_TYPES[os.environ["TEST_TYPE"]]
    t.run_tests()


@invoke.task
def tag_specs(files=""):
    invoke.run("../mspec/bin/mspec tag -t {} -f spec --config=topaz.mspec {}".format("`pwd`/bin/topaz", files))


@invoke.task
def untag_specs(files=""):
    invoke.run("../mspec/bin/mspec tag --del fails -t {} -f spec --config=topaz.mspec {}".format("`pwd`/bin/topaz", files))


@invoke.task
def upload_build():
    t = TEST_TYPES[os.environ["TEST_TYPE"]]
    if t.create_build:
        t.upload_build()


def run_own_tests(env):
    invoke.run("PYTHONPATH=$PYTHONPATH:{rpython_path} py.test".format(**env))


def run_rubyspec_untranslated(env):
    run_specs("bin/topaz_untranslated.py", prefix="PYTHONPATH=$PYTHONPATH:{rpython_path} ".format(**env))


def run_translate_tests(env):
    invoke.run("PYTHONPATH={rpython_path}:$PYTHONPATH python {rpython_path}/rpython/bin/rpython --batch targettopaz.py".format(**env))
    run_specs("`pwd`/bin/topaz")


def run_translate_jit_tests(env):
    invoke.run("PYTHONPATH={rpython_path}:$PYTHONPATH python {rpython_path}/rpython/bin/rpython --batch -Ojit targettopaz.py".format(**env))
    run_specs("`pwd`/bin/topaz")
    invoke.run("PYTHONPATH={rpython_path}:$PYTHONPATH py.test --topaz=bin/topaz tests/jit/".format(**env))


def run_specs(binary, prefix=""):
    invoke.run("{prefix}../mspec/bin/mspec -G fails -t {binary} --format=dotted --config=topaz.mspec".format(
        prefix=prefix,
        binary=binary
    ))


def run_docs_tests(env):
    invoke.run("sphinx-build -W -b html docs/ docs/_build/")


def run_flake8_tests(env):
    # E124 closing bracket does not match visual indentation
    # E125 continuation line does not distinguish itself from next logical line
    # E128 continuation line under-indented for visual indent
    # E501 line too long
    # F811 redefinition of unused
    invoke.run('flake8 . --ignore="E124,E125,E128,E501,F811"')


TEST_TYPES = {
    "own": Test(run_own_tests, deps=["-r requirements.txt"]),
    "rubyspec_untranslated": Test(run_rubyspec_untranslated, deps=["-r requirements.txt"], needs_rubyspec=True),
    "translate": Test(run_translate_tests, deps=["-r requirements.txt"], needs_rubyspec=True),
    "translate-jit": Test(run_translate_jit_tests, deps=["-r requirements.txt"], needs_rubyspec=True, create_build=True),
    "docs": Test(run_docs_tests, deps=["sphinx"], needs_rpython=False),
    "flake8": Test(run_flake8_tests, deps=["flake8"], needs_rpython=False),
}

########NEW FILE########
__FILENAME__ = base
from contextlib import contextmanager

import pytest

from topaz.error import RubyError
from topaz.objects.arrayobject import W_ArrayObject
from topaz.objects.bignumobject import W_BignumObject
from topaz.objects.boolobject import W_TrueObject, W_FalseObject
from topaz.objects.floatobject import W_FloatObject
from topaz.objects.intobject import W_FixnumObject
from topaz.objects.moduleobject import W_ModuleObject
from topaz.objects.stringobject import W_StringObject
from topaz.objects.symbolobject import W_SymbolObject


class BaseTopazTest(object):
    @contextmanager
    def raises(self, space, exc_name, msg=None):
        with pytest.raises(RubyError) as exc:
            yield
        assert space.getclass(exc.value.w_value).name == exc_name
        if msg is not None:
            assert exc.value.w_value.msg == msg

    def find_const(self, space, name):
        return space.find_const(space.w_object, name)

    def unwrap(self, space, w_obj):
        if isinstance(w_obj, W_FixnumObject):
            return space.int_w(w_obj)
        elif isinstance(w_obj, W_BignumObject):
            return space.bigint_w(w_obj)
        elif isinstance(w_obj, W_FloatObject):
            return space.float_w(w_obj)
        elif isinstance(w_obj, W_TrueObject):
            return True
        elif isinstance(w_obj, W_FalseObject):
            return False
        elif isinstance(w_obj, W_StringObject):
            return space.str_w(w_obj)
        elif isinstance(w_obj, W_SymbolObject):
            return space.symbol_w(w_obj)
        elif isinstance(w_obj, W_ArrayObject):
            return [self.unwrap(space, w_x) for w_x in space.listview(w_obj)]
        elif isinstance(w_obj, W_ModuleObject):
            return w_obj
        elif w_obj is space.w_true:
            return True
        elif w_obj is space.w_false:
            return False
        elif w_obj is space.w_nil:
            return None
        raise NotImplementedError(type(w_obj))

########NEW FILE########
__FILENAME__ = conftest
import copy

from rpython.config.translationoption import get_combined_translation_config


def pytest_funcarg__space(request):
    # Inside the function so various intitialization stuff isn't seen until
    # coverage is setup.
    import topaz
    from topaz.main import get_topaz_config_options
    from topaz.objspace import ObjectSpace

    # Building a space is exceptionally expensive, so we create one once, and
    # then just deepcopy it.  Note that deepcopying is still fairly expensive
    # (at the time of writing about 1/3 of total test time), but significantly
    # less so than building a new space.
    def build_space():
        space = ObjectSpace(get_combined_translation_config(
            overrides=get_topaz_config_options(),
        ))
        space.setup(topaz.__file__)
        return space

    space = request.cached_setup(
        setup=build_space,
        scope="session",
    )
    return copy.deepcopy(space)

########NEW FILE########
__FILENAME__ = base
import subprocess

# TODO:
from rpython.tool.jitlogparser.parser import SimpleParser, Op
from rpython.tool.jitlogparser.storage import LoopStorage

from rpython.jit.metainterp.resoperation import opname
from rpython.jit.tool import oparser
from rpython.tool import logparser


class BaseJITTest(object):
    def run(self, topaz, tmpdir, code):
        tmpdir.join("t.rb").write(code)
        proc = subprocess.Popen(
            [str(topaz), str(tmpdir.join("t.rb"))],
            cwd=str(tmpdir),
            env={"PYPYLOG": "jit-log-opt:%s" % tmpdir.join("x.pypylog")}
        )
        proc.wait()
        data = logparser.parse_log_file(str(tmpdir.join("x.pypylog")), verbose=False)
        data = logparser.extract_category(data, "jit-log-opt-")

        storage = LoopStorage()
        traces = [SimpleParser.parse_from_input(t) for t in data]
        traces = storage.reconnect_loops(traces)
        return [Trace(t) for t in traces]

    def assert_matches(self, trace, expected):
        expected_lines = [
            line.strip()
            for line in expected.splitlines()
            if line and not line.isspace()
        ]
        parser = Parser(None, None, {}, "lltype", None, invent_fail_descr=None, nonstrict=True)
        expected_ops = [parser.parse_next_op(l) for l in expected_lines]
        aliases = {}
        assert len(trace) == len(expected_ops)
        for op, expected in zip(trace, expected_ops):
            self._assert_ops_equal(aliases, op, expected)

    def _assert_ops_equal(self, aliases, op, expected):
        assert op.name == expected.name
        assert len(op.args) == len(expected.args)
        for arg, expected_arg in zip(op.args, expected.args):
            if arg in aliases:
                arg = aliases[arg]
            elif arg != expected_arg and expected_arg not in aliases.viewvalues():
                aliases[arg] = arg = expected_arg
            assert arg == expected_arg


class Parser(oparser.OpParser):
    def get_descr(self, poss_descr, allow_invent):
        if poss_descr.startswith(("TargetToken", "<Guard")):
            return poss_descr
        return super(Parser, self).get_descr(poss_descr, allow_invent)

    def getvar(self, arg):
        return arg

    def create_op(self, opnum, args, res, descr):
        return Op(opname[opnum].lower(), args, res, descr)


class Trace(object):
    def __init__(self, trace):
        self.trace = trace

    @property
    def loop(self):
        label_seen = False
        for idx, op in enumerate(self.trace.operations):
            if op.name == "label":
                if label_seen:
                    return self.trace.operations[idx:]
                label_seen = True
        raise ValueError("Loop body couldn't be found")

########NEW FILE########
__FILENAME__ = conftest
import py


def pytest_addoption(parser):
    group = parser.getgroup("Topaz JIT tests")
    group.addoption(
        "--topaz",
        dest="topaz",
        default=None,
        help="Path to a compiled topaz binary"
    )


def pytest_funcarg__topaz(request):
    return py.path.local(request.config.getvalueorskip("topaz"))

########NEW FILE########
__FILENAME__ = test_array
from .base import BaseJITTest


class TestArray(BaseJITTest):
    def test_subscript_assign_simple(self, topaz, tmpdir):
        traces = self.run(topaz, tmpdir, """
        arr = [false]
        10000.times { arr[0] = true }
        """)
        self.assert_matches(traces[0].loop, """
        label(p0, p1, p3, p4, p5, p6, p7, p8, p10, p13, i69, p21, p24, p26, p28, i40, p37, p51, p66, descr=TargetToken(4310782200))
        debug_merge_point(0, 0, 'times at LOAD_DEREF')
        debug_merge_point(0, 0, 'times at LOAD_SELF')
        debug_merge_point(0, 0, 'times at SEND')
        setfield_gc(p28, 42, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        guard_not_invalidated(descr=<Guard0x100fe5d30>)
        p72 = force_token()
        i73 = int_lt(i69, i40)
        guard_true(i73, descr=<Guard0x100fe5cb8>)
        debug_merge_point(0, 0, 'times at JUMP_IF_FALSE')
        debug_merge_point(0, 0, 'times at LOAD_DEREF')
        debug_merge_point(0, 0, 'times at YIELD')
        p74 = force_token()
        debug_merge_point(1, 1, 'block in <main> at LOAD_DEREF')
        debug_merge_point(1, 1, 'block in <main> at LOAD_CONST')
        debug_merge_point(1, 1, 'block in <main> at BUILD_ARRAY')
        debug_merge_point(1, 1, 'block in <main> at LOAD_CONST')
        debug_merge_point(1, 1, 'block in <main> at BUILD_ARRAY')
        debug_merge_point(1, 1, 'block in <main> at SEND_SPLAT')
        p75 = force_token()
        debug_merge_point(1, 1, 'block in <main> at RETURN')
        debug_merge_point(0, 0, 'times at DISCARD_TOP')
        debug_merge_point(0, 0, 'times at LOAD_DEREF')
        debug_merge_point(0, 0, 'times at LOAD_CONST')
        debug_merge_point(0, 0, 'times at SEND')
        p76 = force_token()
        i77 = int_add(i69, 1)
        debug_merge_point(0, 0, 'times at STORE_DEREF')
        debug_merge_point(0, 0, 'times at DISCARD_TOP')
        debug_merge_point(0, 0, 'times at JUMP')
        debug_merge_point(0, 0, 'times at LOAD_DEREF')
        setfield_gc(p28, 63, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        i78 = arraylen_gc(p51, descr=<ArrayP 8>)
        i79 = arraylen_gc(p66, descr=<ArrayP 8>)
        jump(p0, p1, p3, p4, p5, p6, p7, p8, p10, p13, i77, p21, p24, p26, p28, i40, p37, p51, p66, descr=TargetToken(4310782200))
        """)

########NEW FILE########
__FILENAME__ = test_basic
from .base import BaseJITTest


class TestBasic(BaseJITTest):
    def test_while_loop(self, topaz, tmpdir):
        traces = self.run(topaz, tmpdir, """
        i = 0
        while i < 10000
          i += 1
        end
        """)
        self.assert_matches(traces[0].loop, """
        label(p0, p1, p3, p4, p5, p6, p7, p10, i35, p20, p22, p28, descr=TargetToken(4310781936))
        debug_merge_point(0, 0, '<main> at LOAD_DEREF')
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at SEND')
        setfield_gc(p22, 21, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        guard_not_invalidated(descr=<Guard0x100febda8>)
        p37 = force_token()
        i38 = int_lt(i35, 10000)
        guard_true(i38, descr=<Guard0x100febcb8>)
        debug_merge_point(0, 0, '<main> at JUMP_IF_FALSE')
        debug_merge_point(0, 0, '<main> at LOAD_DEREF')
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at SEND')
        p39 = force_token()
        i40 = int_add(i35, 1)
        debug_merge_point(0, 0, '<main> at STORE_DEREF')
        debug_merge_point(0, 0, '<main> at DISCARD_TOP')
        debug_merge_point(0, 0, '<main> at JUMP')
        debug_merge_point(0, 0, '<main> at LOAD_DEREF')
        setfield_gc(p22, 35, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        jump(p0, p1, p3, p4, p5, p6, p7, p10, i40, p20, p22, p28, descr=TargetToken(4310781936))
        """)

    def test_constant_string(self, topaz, tmpdir):
        traces = self.run(topaz, tmpdir, """
        i = 0
        while i < 10000
          i += "a".length
        end
        """)
        self.assert_matches(traces[0].loop, """
        label(p0, p1, p3, p4, p5, p6, p7, p10, i36, p20, p22, p28, descr=TargetToken(4310781936))
        debug_merge_point(0, 0, '<main> at LOAD_DEREF')
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at SEND')
        setfield_gc(p22, 21, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        guard_not_invalidated(descr=<Guard0x100ff6818>)
        p38 = force_token()
        i39 = int_lt(i36, 10000)
        guard_true(i39, descr=<Guard0x100ff6728>)
        debug_merge_point(0, 0, '<main> at JUMP_IF_FALSE')
        debug_merge_point(0, 0, '<main> at LOAD_DEREF')
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at COERCE_STRING')
        debug_merge_point(0, 0, '<main> at SEND')
        p40 = force_token()
        debug_merge_point(0, 0, '<main> at SEND')
        p41 = force_token()
        i42 = int_add(i36, 1)
        debug_merge_point(0, 0, '<main> at STORE_DEREF')
        debug_merge_point(0, 0, '<main> at DISCARD_TOP')
        debug_merge_point(0, 0, '<main> at JUMP')
        debug_merge_point(0, 0, '<main> at LOAD_DEREF')
        setfield_gc(p22, 41, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        jump(p0, p1, p3, p4, p5, p6, p7, p10, i42, p20, p22, p28, descr=TargetToken(4310781936))
        """)

    def test_method_missing(self, topaz, tmpdir):
        traces = self.run(topaz, tmpdir, """
        i = 0
        while i < 10000
          Array.try_convert(1)
          i += 1
        end
        """)
        self.assert_matches(traces[0].loop, """
        label(p0, p1, p3, p4, p5, p7, p10, i56, p19, p22, p24, p30, descr=TargetToken(4310782288))
        debug_merge_point(0, 0, '<main> at LOAD_DEREF')
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at SEND')
        setfield_gc(p24, 21, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        guard_not_invalidated(descr=<Guard0x101e21e20>)
        p59 = force_token()
        i60 = int_lt(i56, 10000)
        guard_true(i60, descr=<Guard0x101e209f8>)
        debug_merge_point(0, 0, '<main> at JUMP_IF_FALSE')
        debug_merge_point(0, 0, '<main> at LOAD_SCOPE')
        debug_merge_point(0, 0, '<main> at LOAD_LOCAL_CONSTANT')
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at SEND')
        p61 = force_token()
        debug_merge_point(1, 1, 'try_convert at LOAD_SCOPE')
        debug_merge_point(1, 1, 'try_convert at LOAD_LOCAL_CONSTANT')
        debug_merge_point(1, 1, 'try_convert at LOAD_DEREF')
        debug_merge_point(1, 1, 'try_convert at LOAD_SCOPE')
        debug_merge_point(1, 1, 'try_convert at LOAD_LOCAL_CONSTANT')
        debug_merge_point(1, 1, 'try_convert at LOAD_CONST')
        debug_merge_point(1, 1, 'try_convert at SEND')
        p62 = force_token()
        p63 = force_token()
        p64 = force_token()
        p65 = force_token()
        p66 = force_token()
        p67 = force_token()
        p68 = force_token()
        p69 = force_token()
        p70 = force_token()
        p71 = force_token()
        p72 = force_token()
        debug_merge_point(1, 1, 'try_convert at RETURN')
        p73 = force_token()
        debug_merge_point(0, 0, '<main> at DISCARD_TOP')
        debug_merge_point(0, 0, '<main> at LOAD_DEREF')
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at SEND')
        p74 = force_token()
        i75 = int_add(i56, 1)
        debug_merge_point(0, 0, '<main> at STORE_DEREF')
        debug_merge_point(0, 0, '<main> at DISCARD_TOP')
        debug_merge_point(0, 0, '<main> at JUMP')
        debug_merge_point(0, 0, '<main> at LOAD_DEREF')
        setfield_gc(p24, 48, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        setfield_gc(p1, p73, descr=<FieldP topaz.frame.Frame.vable_token 32>)
        jump(p0, p1, p3, p4, p5, p7, p10, i75, p19, p22, p24, p30, descr=TargetToken(4310782288))
        """)

########NEW FILE########
__FILENAME__ = test_closure
from .base import BaseJITTest


class TestClosure(BaseJITTest):
    def test_int_closure_cells(self, topaz, tmpdir):
        traces = self.run(topaz, tmpdir, """
        a = 1
        (1..10_000).each do |i|
          a = i
        end
        """)
        self.assert_matches(traces[0].loop, """
        label(p0, p1, p3, p4, p5, p6, p7, p8, p10, p13, i80, p21, p23, p25, p27, p29, p31, p33, p35, p38, p40, p42, i59, p53, p74, p72, descr=TargetToken(4310782200))
        debug_merge_point(0, 0, 'each at LOAD_DEREF')
        debug_merge_point(0, 0, 'each at LOAD_SELF')
        debug_merge_point(0, 0, 'each at SEND')
        setfield_gc(p42, 291, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        guard_not_invalidated(descr=<Guard0x100f633d0>)
        p84 = force_token()
        debug_merge_point(0, 0, 'each at SEND')
        p85 = force_token()
        setfield_gc(p42, 296, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        i86 = int_lt(i80, i59)
        guard_true(i86, descr=<Guard0x100f63358>)
        debug_merge_point(0, 0, 'each at LOAD_CONST')
        debug_merge_point(0, 0, 'each at SEND')
        p87 = force_token()
        debug_merge_point(0, 0, 'each at JUMP_IF_FALSE')
        debug_merge_point(0, 0, 'each at LOAD_DEREF')
        debug_merge_point(0, 0, 'each at YIELD')
        p88 = force_token()
        debug_merge_point(1, 1, 'block in <main> at LOAD_DEREF')
        debug_merge_point(1, 1, 'block in <main> at STORE_DEREF')
        debug_merge_point(1, 1, 'block in <main> at RETURN')
        debug_merge_point(0, 0, 'each at DISCARD_TOP')
        debug_merge_point(0, 0, 'each at LOAD_DEREF')
        debug_merge_point(0, 0, 'each at SEND')
        p89 = force_token()
        debug_merge_point(1, 2, 'succ at LOAD_SELF')
        debug_merge_point(1, 2, 'succ at LOAD_CONST')
        debug_merge_point(1, 2, 'succ at SEND')
        p90 = force_token()
        i91 = int_add(i80, 1)
        debug_merge_point(1, 2, 'succ at RETURN')
        debug_merge_point(0, 0, 'each at STORE_DEREF')
        debug_merge_point(0, 0, 'each at DISCARD_TOP')
        debug_merge_point(0, 0, 'each at JUMP')
        debug_merge_point(0, 0, 'each at LOAD_DEREF')
        setfield_gc(p42, 9, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        setfield_gc(p74, i80, descr=<FieldS topaz.closure.IntCell.inst_intvalue 16>)
        i92 = arraylen_gc(p72, descr=<ArrayP 8>)
        jump(p0, p1, p3, p4, p5, p6, p7, p8, p10, p13, i91, p21, p23, p25, p27, p29, p31, p33, p35, p38, p40, p42, i59, p53, p74, p72, descr=TargetToken(4310782200))
        """)

########NEW FILE########
__FILENAME__ = test_instance_vars
from .base import BaseJITTest


class TestInstanceVars(BaseJITTest):
    def test_initialize(self, topaz, tmpdir):
        traces = self.run(topaz, tmpdir, """
        class A
          def initialize
            @a = 1
            @b = 2
            @c = 3
          end
        end
        i = 0
        while i < 10000
          A.new
          i += 1
        end
        """)
        self.assert_matches(traces[0].loop, """
        label(p0, p1, p3, p4, p5, p7, p10, i41, p19, p22, p24, p30, descr=TargetToken(4310782288))
        debug_merge_point(0, 0, '<main> at LOAD_DEREF')
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at SEND')
        setfield_gc(p24, 34, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        guard_not_invalidated(descr=<Guard0x100f63808>)
        p43 = force_token()
        i44 = int_lt(i41, 10000)
        guard_true(i44, descr=<Guard0x100f63718>)
        debug_merge_point(0, 0, '<main> at JUMP_IF_FALSE')
        debug_merge_point(0, 0, '<main> at LOAD_SCOPE')
        debug_merge_point(0, 0, '<main> at LOAD_LOCAL_CONSTANT')
        debug_merge_point(0, 0, '<main> at SEND')
        p45 = force_token()
        p46 = force_token()
        p47 = force_token()
        debug_merge_point(1, 1, 'initialize at LOAD_SELF')
        debug_merge_point(1, 1, 'initialize at LOAD_CONST')
        debug_merge_point(1, 1, 'initialize at STORE_INSTANCE_VAR')
        debug_merge_point(1, 1, 'initialize at DISCARD_TOP')
        debug_merge_point(1, 1, 'initialize at LOAD_SELF')
        debug_merge_point(1, 1, 'initialize at LOAD_CONST')
        debug_merge_point(1, 1, 'initialize at STORE_INSTANCE_VAR')
        debug_merge_point(1, 1, 'initialize at DISCARD_TOP')
        debug_merge_point(1, 1, 'initialize at LOAD_SELF')
        debug_merge_point(1, 1, 'initialize at LOAD_CONST')
        debug_merge_point(1, 1, 'initialize at STORE_INSTANCE_VAR')
        debug_merge_point(1, 1, 'initialize at RETURN')
        debug_merge_point(0, 0, '<main> at DISCARD_TOP')
        debug_merge_point(0, 0, '<main> at LOAD_DEREF')
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at SEND')
        p48 = force_token()
        i49 = int_add(i41, 1)
        debug_merge_point(0, 0, '<main> at STORE_DEREF')
        debug_merge_point(0, 0, '<main> at DISCARD_TOP')
        debug_merge_point(0, 0, '<main> at JUMP')
        debug_merge_point(0, 0, '<main> at LOAD_DEREF')
        setfield_gc(p24, 58, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        jump(p0, p1, p3, p4, p5, p7, p10, i49, p19, p22, p24, p30, descr=TargetToken(4310782288))
        """)

    def test_unboxed_int_storage(self, topaz, tmpdir):
        traces = self.run(topaz, tmpdir, """
        @i = 0
        while @i < 10000
          @i += 1
        end
        """)
        self.assert_matches(traces[0].loop, """
        label(p0, p1, p3, p4, p5, p6, p7, p10, f39, p20, p31, p26, descr=TargetToken(4310773744))
        debug_merge_point(0, 0, '<main> at LOAD_SELF')
        debug_merge_point(0, 0, '<main> at LOAD_INSTANCE_VAR')
        i42 = convert_float_bytes_to_longlong(f39)
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at SEND')
        setfield_gc(p20, 23, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        guard_not_invalidated(descr=<Guard0x100ff6bd8>)
        p43 = force_token()
        i44 = int_lt(i42, 10000)
        guard_true(i44, descr=<Guard0x100ff6b60>)
        debug_merge_point(0, 0, '<main> at JUMP_IF_FALSE')
        debug_merge_point(0, 0, '<main> at LOAD_SELF')
        debug_merge_point(0, 0, '<main> at DUP_TOP')
        debug_merge_point(0, 0, '<main> at LOAD_INSTANCE_VAR')
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at SEND')
        p45 = force_token()
        i46 = int_add(i42, 1)
        debug_merge_point(0, 0, '<main> at STORE_INSTANCE_VAR')
        f47 = convert_longlong_bytes_to_float(i46)
        debug_merge_point(0, 0, '<main> at DISCARD_TOP')
        debug_merge_point(0, 0, '<main> at JUMP')
        debug_merge_point(0, 0, '<main> at LOAD_SELF')
        setfield_gc(p20, 39, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        setarrayitem_gc(p26, 0, f47, descr=<ArrayF 8>)
        i48 = arraylen_gc(p26, descr=<ArrayF 8>)
        jump(p0, p1, p3, p4, p5, p6, p7, p10, f47, p20, p31, p26, descr=TargetToken(4310773744))
        """)

    def test_unboxed_float_storage(self, topaz, tmpdir):
        traces = self.run(topaz, tmpdir, """
        @data = 0.0
        while @data < 10000.0
          @data += 1.0
        end
        """)
        self.assert_matches(traces[0].loop, """
        label(p0, p1, p3, p4, p5, p6, p7, p10, p20, f37, p30, p26, descr=TargetToken(4310773744))
        debug_merge_point(0, 0, '<main> at LOAD_SELF')
        debug_merge_point(0, 0, '<main> at LOAD_INSTANCE_VAR')
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at SEND')
        setfield_gc(p20, 23, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        guard_not_invalidated(descr=<Guard0x100ff1d30>)
        p40 = force_token()
        i41 = float_lt(f37, 10000.000000)
        guard_true(i41, descr=<Guard0x100ff1cb8>)
        debug_merge_point(0, 0, '<main> at JUMP_IF_FALSE')
        debug_merge_point(0, 0, '<main> at LOAD_SELF')
        debug_merge_point(0, 0, '<main> at DUP_TOP')
        debug_merge_point(0, 0, '<main> at LOAD_INSTANCE_VAR')
        debug_merge_point(0, 0, '<main> at LOAD_CONST')
        debug_merge_point(0, 0, '<main> at SEND')
        p42 = force_token()
        f43 = float_add(f37, 1.000000)
        debug_merge_point(0, 0, '<main> at STORE_INSTANCE_VAR')
        debug_merge_point(0, 0, '<main> at DISCARD_TOP')
        debug_merge_point(0, 0, '<main> at JUMP')
        debug_merge_point(0, 0, '<main> at LOAD_SELF')
        setfield_gc(p20, 39, descr=<FieldS topaz.executioncontext.ExecutionContext.inst_last_instr 24>)
        setarrayitem_gc(p26, 0, f43, descr=<ArrayF 8>)
        i44 = arraylen_gc(p26, descr=<ArrayF 8>)
        jump(p0, p1, p3, p4, p5, p6, p7, p10, p20, f43, p30, p26, descr=TargetToken(4310773744))
        """)

########NEW FILE########
__FILENAME__ = test_comparable
class TestComparable(object):
    def test_name(self, space):
        space.execute("Comparable")

    def test_gt(self, space):
        w_res = space.execute("return 'a' > 'b'")
        assert w_res is space.w_false

    def test_lt(self, space):
        w_res = space.execute("return 'a' < 'b'")
        assert w_res is space.w_true

    def test_le(self, space):
        w_res = space.execute("return 'b' <= 'b'")
        assert w_res is space.w_true
        w_res = space.execute("return 'a' <= 'b'")
        assert w_res is space.w_true
        w_res = space.execute("return 'c' <= 'b'")
        assert w_res is space.w_false

    def test_ge(self, space):
        w_res = space.execute("return 'c' >= 'b'")
        assert w_res is space.w_true

    def test_eqeq(self, space):
        w_res = space.execute("return 'a' == 'a'")
        assert w_res is space.w_true

    def test_not_eqeq(self, space):
        w_res = space.execute("return 'a' == 'b'")
        assert w_res is space.w_false

    def test_between_true(self, space):
        w_res = space.execute("return 'c'.between?('b', 'd')")
        assert w_res is space.w_true

    def test_between_false_low(self, space):
        w_res = space.execute("return 'a'.between?('b', 'd')")
        assert w_res is space.w_false

    def test_between_false_high(self, space):
        w_res = space.execute("return 'e'.between?('b', 'd')")
        assert w_res is space.w_false

    def test_between_equal(self, space):
        w_res = space.execute("return 'e'.between?('e', 'z')")
        assert w_res is space.w_true
        w_res = space.execute("return 'e'.between?('a', 'e')")
        assert w_res is space.w_true

########NEW FILE########
__FILENAME__ = test_enumerable
from ..base import BaseTopazTest


class TestEnumberable(BaseTopazTest):
    def test_inject(self, space):
        w_res = space.execute("""
        return (5..10).inject(1) do |prod, n|
          prod * n
        end
        """)
        assert space.int_w(w_res) == 151200

        w_res = space.execute("""
        return (1..10).inject(0) do |sum, n|
          sum + n
        end
        """)
        assert space.int_w(w_res) == 55

    def test_reduce(self, space):
        w_res = space.execute("""
        return [1, 2, 4, 8].reduce(0) do |accum, cur|
          accum + cur
        end
        """)
        assert space.int_w(w_res) == 15

    def test_each_with_index(self, space):
        w_res = space.execute("""
        result = []
        (5..10).each_with_index do |n, idx|
          result << [n, idx]
        end
        return result
        """)
        assert self.unwrap(space, w_res) == [[5, 0], [6, 1], [7, 2], [8, 3], [9, 4], [10, 5]]

    def test_all(self, space):
        w_res = space.execute("""
        return ["ant", "bear", "cat"].all? do |word|
          word.length > 2
        end
        """)
        assert w_res is space.w_true

    def test_all_false(self, space):
        w_res = space.execute("""
        return ["ant", "bear", "cat"].all? do |word|
          word.length > 3
        end
        """)
        assert w_res is space.w_false

    def test_all_empty(self, space):
        w_res = space.execute("""
        return [].all?
        """)
        assert w_res is space.w_true

    def test_all_no_block(self, space):
        w_res = space.execute("""
        return [1, 2, 3].all?
        """)
        assert w_res is space.w_true

    def test_any(self, space):
        w_res = space.execute("""
        return ["ant", "bear", "cat"].any? do |word|
          word.length > 2
        end
        """)
        assert w_res is space.w_true

    def test_any_false(self, space):
        w_res = space.execute("""
        return [nil, nil, nil].any?
        """)
        assert w_res is space.w_false

    def test_select(self, space):
        w_res = space.execute("""
        return (2..4).select { |x| x == 2 }
        """)
        assert self.unwrap(space, w_res) == [2]

    def test_include(self, space):
        w_res = space.execute("""
        return (2..5).include? 12
        """)
        assert w_res is space.w_false

        w_res = space.execute("""
        return (2..3).include? 2
        """)
        assert w_res is space.w_true

    def test_drop(self, space):
        w_res = space.execute("""return [0, 1, 2, 3, 4, 5, 6, 7].drop 3""")
        assert self.unwrap(space, w_res) == [3, 4, 5, 6, 7]

        w_res = space.execute("""return [].drop 3""")
        assert self.unwrap(space, w_res) == []

        w_res = space.execute("""return [1, 2, 3].drop 3""")
        assert self.unwrap(space, w_res) == []

        with self.raises(space, "ArgumentError", 'attempt to drop negative size'):
            space.execute("""return [0, 1, 2, 3, 4, 5, 6, 7].drop -3""")

    def test_drop_while(self, space):
        w_res = space.execute("""return [1, 2, 3, 4, 5, 0].drop_while { |i| i < 3 }""")
        assert self.unwrap(space, w_res) == [3, 4, 5, 0]

        w_res = space.execute("""return [1, 2, 3].drop_while { |i| i == 0 } """)
        assert self.unwrap(space, w_res) == [1, 2, 3]

        w_res = space.execute("""return [].drop_while { |i| i > 3 }""")
        assert self.unwrap(space, w_res) == []

    def test_to_a(self, space):
        w_res = space.execute("""return (5..10).to_a""")
        assert self.unwrap(space, w_res) == [x for x in range(5, 11)]

        w_res = space.execute("""return [1, 2, 3, 4].to_a""")
        assert self.unwrap(space, w_res) == [1, 2, 3, 4]

        w_res = space.execute("""
        class A
          include Enumerable

          def each
            i = 0
            while i < 5
              yield i
              i += 1
            end
          end
        end
        return A.new.to_a""")
        assert self.unwrap(space, w_res) == [0, 1, 2, 3, 4]

    def test_detect(self, space):
        w_res = space.execute("return (1..10).detect { |i| i == 11 }")
        assert w_res == space.w_nil
        w_res = space.execute("return (1..10).detect(-1) { |i| i == 11 }")
        assert space.int_w(w_res) == -1
        w_res = space.execute("return (1..10).detect { |i| i == 5 }")
        assert space.int_w(w_res) == 5

    def test_map(self, space):
        w_res = space.execute("return [1, 2, 3, 4, 5].map { |i| i + 1 }")
        assert self.unwrap(space, w_res) == range(2, 7)
        w_res = space.execute("return [1, 2, 3, 4, 5].collect { |i| i + 1 }")
        assert self.unwrap(space, w_res) == range(2, 7)

    def test_take(self, space):
        w_res = space.execute("return [1, 2, 3, 4, 5].take(2)")
        assert self.unwrap(space, w_res) == [1, 2]
        w_res = space.execute("return [1, 2, 3, 4, 5].take(0)")
        assert self.unwrap(space, w_res) == []
        w_res = space.execute("return [].take(2)")
        assert self.unwrap(space, w_res) == []

    def test_take_while(self, space):
        w_res = space.execute("return (1..10).take_while { |i| i < 4 }")
        assert self.unwrap(space, w_res) == [1, 2, 3]
        w_res = space.execute("return [].take_while { |i| i == 11 }")
        assert self.unwrap(space, w_res) == []
        w_res = space.execute("return (1..10).take_while { |i| i > 11 }")
        assert self.unwrap(space, w_res) == []
        w_res = space.execute("return (1..10).take_while { |i| i < 11 }")
        assert self.unwrap(space, w_res) == range(1, 11)

    def test_reject(self, space):
        w_res = space.execute("return [1, 2, 3].reject { |i| i == 3 }")
        assert self.unwrap(space, w_res) == [1, 2]
        w_res = space.execute("return [].reject { |i| i == 3 }")
        assert self.unwrap(space, w_res) == []
        w_res = space.execute("return (1..10).reject { |i| i > 11 }")
        assert self.unwrap(space, w_res) == range(1, 11)
        w_res = space.execute("return (1..10).reject { |i| i < 11 }")
        assert self.unwrap(space, w_res) == []

########NEW FILE########
__FILENAME__ = test_kernel
import os
import time

import pytest

from ..base import BaseTopazTest


class TestKernel(BaseTopazTest):
    def test_puts_nil(self, space, capfd):
        space.execute("puts nil")
        out, err = capfd.readouterr()
        assert out == "\n"

    def test_print(self, space, capfd):
        space.execute("print 1, 3")
        out, err = capfd.readouterr()
        assert out == "13"

    def test_p(self, space, capfd):
        space.execute("p 1,2,3")
        out, err = capfd.readouterr()
        assert out == "1\n2\n3\n"

    def test_lambda(self, space):
        w_res = space.execute("""
        l = lambda { |x| 3 }
        return [l.class, l.lambda?]
        """)
        w_cls, w_lambda = space.listview(w_res)
        assert w_cls is space.w_proc
        assert w_lambda is space.w_true

    def test_proc(self, space):
        w_res = space.execute("""
        l = proc { |x| 3 }
        return [l.class, l.lambda?]
        """)
        w_cls, w_lambda = space.listview(w_res)
        assert w_cls is space.w_proc
        assert w_lambda is space.w_false

    def test_singleton_methods(self, space):
        w_res = space.execute("""
        class X
        end

        return X.new.singleton_methods
        """)
        assert self.unwrap(space, w_res) == []

        w_res = space.execute("""
        def X.foo
        end

        return X.singleton_methods
        """)
        assert self.unwrap(space, w_res) == ["foo"]

        w_res = space.execute("""
        class Y < X
        end
        return [Y.singleton_methods, Y.singleton_methods(false)]
        """)
        assert self.unwrap(space, w_res) == [["foo"], []]

    def test_raise(self, space):
        with self.raises(space, "RuntimeError", "foo"):
            space.execute("raise 'foo'")
        with self.raises(space, "TypeError", "foo"):
            space.execute("raise TypeError, 'foo'")
        with self.raises(space, "TypeError", "foo"):
            space.execute("fail TypeError, 'foo'")
        with self.raises(space, "TypeError", "exception class/object expected"):
            space.execute("fail nil")
        with self.raises(space, "TypeError", "exception object expected"):
            space.execute("""
            class A
              def exception(msg=nil)
              end
            end
            raise A.new
            """)
        with self.raises(space, "RuntimeError"):
            space.execute("""
            class A
              def exception(msg=nil); RuntimeError.new(msg); end
            end
            raise A.new
            """)
        with self.raises(space, "RuntimeError"):
            space.execute("raise")

    def test_overriding_raise(self, space):
        w_res = space.execute("""
        class A
          def raise(*args); args; end
          def do_raise; raise 'foo'; end
        end
        return A.new.do_raise
        """)
        assert self.unwrap(space, w_res) == ['foo']

    def test_raise_error_subclass(self, space):
        with self.raises(space, "CustomError", 'foo'):
            space.execute("""
            class CustomError < StandardError; end
            raise CustomError, 'foo'
            """)

    def test_Array(self, space):
        w_res = space.execute("""
        class A
          def to_ary; ["to_ary"]; end
          def to_a; ["to_a"]; end
        end
        class B
          def to_a; ["to_a"]; end
        end
        return Array(A.new), Array(B.new)
        """)
        assert self.unwrap(space, w_res) == [["to_ary"], ["to_a"]]
        assert self.unwrap(space, space.execute("return Array(1)")) == [1]

    def test_String(self, space):
        w_res = space.execute("return [String('hello'), String(4)]")
        assert self.unwrap(space, w_res) == ["hello", "4"]

    def test_Integer(self, space):
        w_res = space.execute("return [Integer(4), Integer('123')]")
        assert self.unwrap(space, w_res) == [4, 123]

    def test_exit(self, space):
        with self.raises(space, "SystemExit"):
            space.execute("Kernel.exit")
        with self.raises(space, "SystemExit"):
            space.execute("exit")

    def test_block_given_p(self, space):
        assert space.execute("return block_given?") is space.w_false
        assert space.execute("return iterator?") is space.w_false
        assert space.execute("return (proc { block_given? })[]") is space.w_false
        w_res = space.execute("""
        def foo
          block_given?
        end
        return foo, foo { }
        """)
        assert self.unwrap(space, w_res) == [False, True]
        w_res = space.execute("""
        def foo
          bar { block_given? }
        end

        def bar
          yield
        end

        return foo, foo { }
        """)
        assert self.unwrap(space, w_res) == [False, True]

    def test_eqlp(self, space):
        w_res = space.execute("""
        x = Object.new
        return [x.eql?(x), x.eql?(4)]
        """)
        assert self.unwrap(space, w_res) == [True, False]

    def test_eval(self, space):
        w_res = space.execute("""
        a = 4
        return eval('a + 2')
        """)
        assert space.int_w(w_res) == 6

    def test_responds_to(self, space):
        w_res = space.execute("return [4.respond_to?(:foo_bar), nil.respond_to?(:object_id)]")
        assert self.unwrap(space, w_res) == [False, True]

    def test_Float(self, space):
        assert space.float_w(space.execute("return Float(1)")) == 1.0
        assert space.float_w(space.execute("return Float(1.1)")) == 1.1
        assert space.float_w(space.execute("return Float('1.1')")) == 1.1
        assert space.float_w(space.execute("return Float('1.1e10')")) == 11000000000.0
        with self.raises(space, "TypeError"):
            space.execute("Float(nil)")
        with self.raises(space, "ArgumentError"):
            space.execute("Float('a')")
        w_res = space.execute("""
        class A; def to_f; 1.1; end; end
        return Float(A.new)
        """)
        assert space.float_w(w_res) == 1.1

    def test_loop(self, space):
        w_res = space.execute("""
        res = []
        i = 0
        loop {
          i += 1
          res << i
          break if i == 3
        }
        return res
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3]

    def test_sleep(self, space):
        now = time.time()
        w_res = space.execute("return sleep 0.001")
        assert space.int_w(w_res) == 0
        assert time.time() - now >= 0.001

        now = time.time()
        w_res = space.execute("return sleep 0.002")
        assert space.int_w(w_res) == 0
        assert time.time() - now >= 0.002

    def test_trust(self, space):
        w_res = space.execute("return 'a'.untrusted?")
        assert self.unwrap(space, w_res) is False
        w_res = space.execute("""
        a = 'a'
        a.untrust
        return a.untrusted?, a.dup.untrusted?, a.clone.untrusted?
        """)
        assert self.unwrap(space, w_res) == [True, True, True]
        w_res = space.execute("""
        a = 'a'
        a.untrust
        a.trust
        return a.untrusted?, a.dup.untrusted?, a.clone.untrusted?
        """)
        assert self.unwrap(space, w_res) == [False, False, False]

    def test_taint(self, space):
        w_res = space.execute("return 'a'.tainted?")
        assert self.unwrap(space, w_res) is False
        w_res = space.execute("""
        a = 'a'
        a.taint
        return a.tainted?, a.dup.tainted?, a.clone.tainted?
        """)
        assert self.unwrap(space, w_res) == [True, True, True]
        w_res = space.execute("""
        a = 'a'
        a.taint
        a.untaint
        return a.tainted?, a.dup.tainted?, a.clone.tainted?
        """)
        assert self.unwrap(space, w_res) == [False, False, False]

    def test_freeze(self, space):
        w_res = space.execute("return 'a'.frozen?")
        assert self.unwrap(space, w_res) is False
        w_res = space.execute("""
        a = 'a'
        a.freeze
        return a.frozen?, a.dup.frozen?, a.clone.frozen?
        """)
        assert self.unwrap(space, w_res) == [True, False, True]

    def test_backtick(self, space):
        w_res = space.execute("return `echo 10`")
        assert self.unwrap(space, w_res) == "10\n"

    def test_backtick_sets_process_status(self, space):
        w_res = space.execute("""
        $? = nil
        `echo`
        return $?.class.name
        """)
        assert self.unwrap(space, w_res) == "Process::Status"


class TestRequire(BaseTopazTest):
    def test_simple(self, space, tmpdir):
        f = tmpdir.join("t.rb")
        f.write("""
        def t(a, b)
          a - b
        end
        """)
        w_res = space.execute("""
        require '%s'

        return t(5, 10)
        """ % f)
        assert space.int_w(w_res) == -5

    def test_no_ext(self, space, tmpdir):
        f = tmpdir.join("t.rb")
        f.write("""
        def t(a, b)
          a - b
        end
        """)
        w_res = space.execute("""
        require '%s'

        return t(12, 21)
        """ % str(f)[:-3])
        assert space.int_w(w_res) == -9

    def test_load_path(self, space, tmpdir):
        f = tmpdir.join("t.rb")
        f.write("""
        def t(a, b)
          a - b
        end
        """)
        w_res = space.execute("""
        $LOAD_PATH[0..-1] = ['%s']
        require 't.rb'

        return t(2, 5)
        """ % tmpdir)
        assert space.int_w(w_res) == -3

    def test_stdlib_default_load_path(self, space):
        w_res = space.execute("""
        return require 'prettyprint'
        """)
        assert w_res is space.w_true

    def test_nonexistance(self, space):
        with self.raises(space, "LoadError"):
            space.execute("require 'xxxxxxx'")

    def test_already_loaded(self, space, tmpdir):
        f = tmpdir.join("f.rb")
        f.write("""
        @a += 1
        """)

        w_res = space.execute("""
        @a = 0
        require '%s'
        require '%s'
        require '%s'

        return @a
        """ % (f, f, f))
        assert space.int_w(w_res) == 1

    def test_load(self, space, tmpdir):
        f = tmpdir.join("f.rb")
        f.write("""
        @a += 1
        """)

        w_res = space.execute("""
        @a = 0
        load '%s'
        load '%s'
        load '%s'

        return @a
        """ % (f, f, f))
        assert space.int_w(w_res) == 3

    def test_no_ext_on_path(self, space, tmpdir):
        f = tmpdir.join("t.txt")
        f.write("""
        @a = 5
        """)

        w_res = space.execute("""
        require '%s'
        return @a
        """ % f)
        assert space.int_w(w_res) == 5

    def test_null_bytes(self, space):
        with self.raises(space, "ArgumentError", "string contains null byte"):
            space.execute('require "b\\0"')
        with self.raises(space, "ArgumentError", "string contains null byte"):
            space.execute("""
            $LOAD_PATH.unshift "\\0"
            require 'pp'
            """)

    def test_load_path_element_coerce(self, space, tmpdir):
        f = tmpdir.join("t.rb")
        f.write("""
        $success = true
        """)
        w_res = space.execute("""
        class A
          def to_path
            "%s"
          end
        end
        $LOAD_PATH.unshift A.new
        require 't'
        return $success
        """ % tmpdir)
        assert w_res is space.w_true

    def test_path_ambigious_directory_file(self, space, tmpdir):
        f = tmpdir.join("t.rb")
        f.write("""
        $success = true
        """)
        tmpdir.join("t").ensure(dir=True)
        w_res = space.execute("""
        $LOAD_PATH << '%s'
        require '%s'
        return $success
        """ % (tmpdir, tmpdir.join("t")))
        assert w_res is space.w_true


class TestExec(BaseTopazTest):
    def fork_and_wait(self, space, capfd, code):
        cpid = os.fork()
        if cpid == 0:
            try:
                space.execute(code)
            finally:
                os._exit(0)
        else:
            os.waitpid(cpid, 0)
            out, err = capfd.readouterr()
            return out

    def test_exec_with_sh(self, space, capfd):
        out = self.fork_and_wait(space, capfd, "exec 'echo $0'")
        assert out == "sh\n"

    def test_exec_directly(self, space, capfd):
        out = self.fork_and_wait(space, capfd, "exec '/bin/echo', '$0'")
        assert out == "$0\n"

    def test_exec_with_custom_argv0(self, space, capfd):
        out = self.fork_and_wait(space, capfd, "exec ['/bin/sh', 'argv0'], '-c', 'echo $0'")
        assert out == "argv0\n"

    @pytest.mark.xfail
    def test_exec_with_path_search(self, space, capfd):
        out = self.fork_and_wait(space, capfd, "exec 'echo', '$0'")
        assert out == "$0\n"

    def test_exec_with_null_bytes(self, space):
        with self.raises(space, "ArgumentError", "string contains null byte"):
            space.execute('exec "\\0"')
        with self.raises(space, "ArgumentError", "string contains null byte"):
            space.execute('exec ["\\0", "none"]')
        with self.raises(space, "ArgumentError", "string contains null byte"):
            space.execute('exec ["none", "\\0"]')
        with self.raises(space, "ArgumentError", "string contains null byte"):
            space.execute('exec "none", "\\0"')


class TestSetTraceFunc(BaseTopazTest):
    def test_class(self, space):
        w_res = space.execute("""
        output = []
        set_trace_func proc { |event, file, line, id, binding, classname|
          output << [event, file, line, id, classname]
        }

        class << self
        end

        set_trace_func nil

        return output
        """)
        assert self.unwrap(space, w_res) == [
            ["c-return", "-e", 3, "set_trace_func", "Kernel"],
            ["line", "-e", 7, None, None],
            ["class", "-e", 7, None, None],
            ["end", "-e", 7, None, None],
            ["line", "-e", 10, None, None],
            ["c-call", "-e", 10, "set_trace_func", "Kernel"]
        ]

########NEW FILE########
__FILENAME__ = test_math
import math

from rpython.rlib import rfloat

from ..base import BaseTopazTest


class TestMath(BaseTopazTest):
    def assert_float_equal(self, result, expected, eps=1e-15):
        assert abs(result - expected) < eps

    def test_domain_error(self, space):
        space.execute("Math::DomainError")

    def test_pi(self, space):
        w_res = space.execute("return Math::PI")
        assert space.float_w(w_res) == math.pi

    def test_e(self, space):
        w_res = space.execute("return Math::E")
        assert space.float_w(w_res) == math.e

    def test_acos(self, space):
        w_res = space.execute("return [Math.acos(0), Math.acos(1)]")
        assert self.unwrap(space, w_res) == [math.acos(0), 0]

    def test_acosh(self, space):
        w_res = space.execute("return [Math.acosh(1), Math.acosh(2)]")
        assert self.unwrap(space, w_res) == [0, math.acosh(2)]

        with self.raises(space, "Math::DomainError", 'Numerical argument is out of domain - "acosh"'):
            space.execute("Math.acosh(0)")

    def test_asin(self, space):
        w_res = space.execute("return [Math.asin(0), Math.asin(1)]")
        assert self.unwrap(space, w_res) == [0, math.asin(1)]

    def test_asinh(self, space):
        w_res = space.execute("return [Math.asinh(0), Math.asinh(1)]")
        assert self.unwrap(space, w_res) == [math.asinh(0), math.asinh(1)]

    def test_atan(self, space):
        w_res = space.execute("return [Math.atan(0), Math.atan(1)]")
        assert self.unwrap(space, w_res) == [0, math.atan(1)]

    def test_atan2(self, space):
        w_res = space.execute("return [Math.atan2(-0.0, -1.0), Math.atan2(-1, -1.0)]")
        assert self.unwrap(space, w_res) == [math.atan2(-0.0, -1.0), math.atan2(-1.0, -1)]

    def test_atanh(self, space):
        w_res = space.execute("return [Math.atanh(1), Math.atanh(-1), Math.atanh(0), Math.atanh(0.5)]")
        assert self.unwrap(space, w_res) == [float("inf"), float("-inf"), 0, math.atanh(0.5)]

        with self.raises(space, "Math::DomainError", 'Numerical argument is out of domain - "atanh"'):
            space.execute("Math.atanh(2)")

    def test_cbrt(self, space):
        w_res = space.execute("return [Math.cbrt(-8), Math.cbrt(-1), Math.cbrt(0)]")
        assert self.unwrap(space, w_res) == [-2.0, -1.0, 0]

        w_res = space.execute("return Math.cbrt(8)")
        self.assert_float_equal(space.float_w(w_res), 2.0)

        w_res = space.execute("return Math.cbrt(64)")
        self.assert_float_equal(space.float_w(w_res), 4.0)

    def test_cos(self, space):
        w_res = space.execute("return [Math.cos(0), Math.cos(1)]")
        assert self.unwrap(space, w_res) == [1, math.cos(1)]

    def test_cosh(self, space):
        w_res = space.execute("return [Math.cosh(0), Math.cosh(1), Math.cosh(123123)]")
        assert self.unwrap(space, w_res) == [1, math.cosh(1), float("inf")]

    def test_exp(self, space):
        w_res = space.execute("return [Math.exp(0.0), Math.exp(1)]")
        assert self.unwrap(space, w_res) == [1, math.exp(1)]

    def test_frexp(self, space):
        w_res = space.execute("return Math.frexp(1234)")
        assert self.unwrap(space, w_res) == [math.frexp(1234)[0], 11]

    def test_gamma(self, space):
        w_res = space.execute("return Math.gamma(5.0)")
        self.assert_float_equal(space.float_w(w_res), 24.0)

        w_res = space.execute("return Math.gamma(6.0)")
        self.assert_float_equal(space.float_w(w_res), 120.0)

        w_res = space.execute("return Math.gamma(0.5)")
        self.assert_float_equal(space.float_w(w_res), math.pi ** 0.5)

        w_res = space.execute("return Math.gamma(1000)")
        assert space.float_w(w_res) == float("inf")

        w_res = space.execute("return Math.gamma(0.0)")
        assert space.float_w(w_res) == float("inf")

        w_res = space.execute("return Math.gamma(-0.0)")
        assert space.float_w(w_res) == float("-inf")

        w_res = space.execute("return Math.gamma(Float::INFINITY)")
        assert space.float_w(w_res) == float("inf")

        with self.raises(space, "Math::DomainError", 'Numerical argument is out of domain - "gamma"'):
            space.execute("""Math.gamma(-1)""")
        with self.raises(space, "Math::DomainError", 'Numerical argument is out of domain - "gamma"'):
            space.execute("""Math.gamma(-Float::INFINITY)""")

        w_res = space.execute("return Math.gamma(Float::NAN)")
        assert math.isnan(space.float_w(w_res))

    def test_lgamma(self, space):
        res_w = space.execute("return Math.lgamma(6.0)")
        w_res1, w_res2 = space.listview(res_w)
        self.assert_float_equal(space.float_w(w_res1), math.log(120))
        assert space.int_w(w_res2) == 1

        res_w = space.execute("return Math.lgamma(-1)")
        w_inf = space.execute("return Float::INFINITY")
        w_res1, w_res2 = space.listview(res_w)
        assert self.unwrap(space, w_res1) == self.unwrap(space, w_inf)
        assert space.int_w(w_res2) == 1

        res_w = space.execute("return Math.lgamma(Float::NAN)")
        w_res1, w_res2 = space.listview(res_w)
        assert math.isnan(self.unwrap(space, w_res1))
        assert space.int_w(w_res2) == 1

    def test_hypot(self, space):
        w_res = space.execute("return Math.hypot(3, 4)")
        assert self.unwrap(space, w_res) == 5

    def test_ldexp(self, space):
        w_res = space.execute("return Math.ldexp(Math.frexp(1234)[0], 11)")
        assert self.unwrap(space, w_res) == 1234

    def test_log(self, space):
        with self.raises(space, "Math::DomainError", 'Numerical argument is out of domain - "log"'):
            space.execute("Math.log(-1)")

        w_res = space.execute("return Math.log(0)")
        assert space.float_w(w_res) == float("-inf")

        w_res = space.execute("return Math.log(4, 10)")
        self.assert_float_equal(space.float_w(w_res), math.log(4, 10))

        w_res = space.execute("return Math.log(28)")
        self.assert_float_equal(space.float_w(w_res), math.log(28))

        w_res = space.execute("return Math.log(3, 4)")
        self.assert_float_equal(space.float_w(w_res), math.log(3, 4))

    def test_log10(self, space):
        with self.raises(space, "Math::DomainError", 'Numerical argument is out of domain - "log10"'):
            space.execute("Math.log10(-1)")

        w_res = space.execute("return Math.log10(0)")
        assert space.float_w(w_res) == float("-inf")

        w_res = space.execute("return Math.log10(1)")
        assert space.float_w(w_res) == 0.0

        w_res = space.execute("return Math.log10(10)")
        assert space.float_w(w_res) == 1.0

    def test_log2(self, space):
        with self.raises(space, "Math::DomainError", 'Numerical argument is out of domain - "log2"'):
            space.execute("Math.log2(-1)")

        w_res = space.execute("return Math.log2(0)")
        assert space.float_w(w_res) == float("-inf")

        w_res = space.execute("return Math.log2(1)")
        assert space.float_w(w_res) == 0.0

        w_res = space.execute("return Math.log2(2)")
        assert space.float_w(w_res) == 1.0

        w_res = space.execute("return Math.log2(32768)")
        assert space.float_w(w_res) == 15.0

        w_res = space.execute("return Math.log2(65536)")
        assert space.float_w(w_res) == 16.0

    def test_sin(self, space):
        w_res = space.execute("return [Math.sin(0), Math.sin(1)]")
        assert self.unwrap(space, w_res) == [0, math.sin(1)]

    def test_sinh(self, space):
        w_res = space.execute("return [Math.sinh(0), Math.sinh(2), Math.sinh(1234)]")
        assert self.unwrap(space, w_res) == [0, math.sinh(2), float("inf")]

    def test_sqrt(self, space):
        w_res = space.execute("return [Math.sqrt(4), Math.sqrt(28)]")
        assert self.unwrap(space, w_res) == [2, math.sqrt(28)]

    def test_tan(self, space):
        w_res = space.execute("return Math.tan(Float::INFINITY)")
        assert math.isnan(space.float_w(w_res))

        w_res = space.execute("return [Math.tan(0), Math.tan(1)]")
        assert self.unwrap(space, w_res) == [0, math.tan(1)]

    def test_tanh(self, space):
        w_res = space.execute("return [Math.tanh(0), Math.tanh(1), Math.tanh(1234)]")
        assert self.unwrap(space, w_res) == [0, math.tanh(1), 1.0]

    def test_erf(self, space):
        w_res = space.execute("return [Math.erf(0), Math.erf(10), Math.erf(-10)]")
        assert self.unwrap(space, w_res) == [0.0, 1.0, -1.0]

    def test_erfc(self, space):
        w_res = space.execute("return [Math.erfc(-1), Math.erfc(0), Math.erfc(1.5)]")
        assert self.unwrap(space, w_res) == [rfloat.erfc(-1), 1.0, rfloat.erfc(1.5)]

########NEW FILE########
__FILENAME__ = test_objectspace
from rpython.rlib import rgc


class TestObjectSpace(object):
    def test_name(self, space):
        space.execute("ObjectSpace")

    def test_each_object(self, space, monkeypatch):
        space.execute("""
        class X
        end
        """)
        monkeypatch.setattr(rgc, "get_rpy_roots", lambda: [rgc._GcRef(space)])
        w_res = space.execute("""
        names = []
        ObjectSpace.each_object(Module) do |mod|
          names << mod.name
        end
        return names.include? "X"
        """)
        assert w_res is space.w_true

########NEW FILE########
__FILENAME__ = test_process
import os

import pytest

from topaz.modules import process

from ..base import BaseTopazTest


class TestProcess(BaseTopazTest):
    def test_euid(self, space):
        w_res = space.execute("return Process.euid")
        assert space.int_w(w_res) == os.geteuid()

    def test_pid(self, space):
        w_res = space.execute("return Process.pid")
        assert space.int_w(w_res) == os.getpid()
        w_res = space.execute("return $$")
        assert space.int_w(w_res) == os.getpid()

    def test_exit(self, space):
        with self.raises(space, "SystemExit"):
            space.execute("Process.exit")
        w_res = space.execute("""
        begin
          Process.exit
        rescue SystemExit => e
          return e.success?, e.status
        end
        """)
        assert self.unwrap(space, w_res) == [True, 0]
        w_res = space.execute("""
        begin
          Process.exit(1)
        rescue SystemExit => e
          return e.success?, e.status
        end
        """)
        assert self.unwrap(space, w_res) == [False, 1]

    def test_fork(self, space, monkeypatch, capfd):
        monkeypatch.setattr(process, "fork", lambda: 0)
        with self.raises(space, "SystemExit"):
            space.execute("""
            Process.fork do
              puts "child"
            end
            """)
        out, err = capfd.readouterr()
        assert err == ""
        assert out == "child\n"
        monkeypatch.setattr(process, "fork", lambda: 200)
        w_res = space.execute("""
        return Process.fork do
          puts "child"
        end
        """)
        assert space.int_w(w_res) == 200

    @pytest.mark.parametrize("code", [0, 1, 173])
    def test_waitpid(self, space, code):
        pid = os.fork()
        if pid == 0:
            os._exit(code)
        else:
            w_res = space.execute("return Process.waitpid %i" % pid)
            assert space.int_w(w_res) == pid
            w_res = space.execute("return $?")
            status = space.send(w_res, "to_i", [])
            assert space.int_w(status) == code

    @pytest.mark.parametrize("code", [0, 1, 173])
    def test_waitpid2(self, space, code):
        pid = os.fork()
        if pid == 0:
            os._exit(code)
        else:
            w_res = space.execute("return Process.waitpid2 %i" % pid)
            [returned_pid, returned_code] = space.listview(w_res)
            assert space.int_w(returned_pid) == pid
            code_to_i = space.send(returned_code, "to_i", [])
            assert space.int_w(code_to_i) == code

########NEW FILE########
__FILENAME__ = test_signal
class TestSignal(object):
    def test_name(self, space):
        space.execute("Signal")

########NEW FILE########
__FILENAME__ = test_arrayobject
# coding=utf-8

import struct

from ..base import BaseTopazTest


class TestArrayObject(BaseTopazTest):
    def test_to_s(self, space):
        w_res = space.execute("return [].to_s")
        assert space.str_w(w_res) == "[]"

        w_res = space.execute("return [[1]].to_s")
        assert space.str_w(w_res) == "[[1]]"

        w_res = space.execute("return [[1], [2], [3]].to_s")
        assert space.str_w(w_res) == "[[1], [2], [3]]"

    def test_subscript(self, space):
        w_res = space.execute("return [1][0]")
        assert space.int_w(w_res) == 1
        w_res = space.execute("return [1].at(0)")
        assert space.int_w(w_res) == 1
        w_res = space.execute("return [1][1]")
        assert w_res is space.w_nil
        w_res = space.execute("return [1][-1]")
        assert space.int_w(w_res) == 1
        w_res = space.execute("return [1][-2]")
        assert w_res == space.w_nil
        w_res = space.execute("return [1, 2][0, 0]")
        assert self.unwrap(space, w_res) == []
        w_res = space.execute("return [1, 2][0, 1]")
        assert self.unwrap(space, w_res) == [1]
        w_res = space.execute("return [1, 2][0, 5]")
        assert self.unwrap(space, w_res) == [1, 2]
        w_res = space.execute("return [1, 2][0, -1]")
        assert w_res is space.w_nil
        w_res = space.execute("return [1, 2][-1, 1]")
        assert self.unwrap(space, w_res) == [2]
        w_res = space.execute("return [1, 2][-2, 2]")
        assert self.unwrap(space, w_res) == [1, 2]
        w_res = space.execute("return [1, 2][-2, 2]")
        assert self.unwrap(space, w_res) == [1, 2]
        with self.raises(space, "TypeError"):
            space.execute("[1, 2][1..2, 1]")
        w_res = space.execute("""
        class String; def to_int; 1; end; end
        return [1, 2]["1", "1"]
        """)
        assert self.unwrap(space, w_res) == [2]

    def test_subscript_assign(self, space):
        w_res = space.execute("a = [1]; a[0] = 42; return a")
        assert self.unwrap(space, w_res) == [42]
        w_res = space.execute("a = [1]; a[1] = 42; return a")
        assert self.unwrap(space, w_res) == [1, 42]
        w_res = space.execute("a = [1]; a[-1] = 42; return a")
        assert self.unwrap(space, w_res) == [42]
        with self.raises(space, "IndexError", "index -2 too small for array; minimum: -1"):
            space.execute("a = [1]; a[-2] = 42")
        w_res = space.execute("a = [1, 2]; a[0, 0] = 42; return a")
        assert self.unwrap(space, w_res) == [42, 1, 2]
        w_res = space.execute("a = []; a[0, 0] = [3, 4, 5]; return a")
        assert self.unwrap(space, w_res) == [3, 4, 5]
        w_res = space.execute("a = [1, 2]; a[0, 1] = 42; return a")
        assert self.unwrap(space, w_res) == [42, 2]
        w_res = space.execute("a = [1, 2]; a[0, 5] = 42; return a")
        assert self.unwrap(space, w_res) == [42]
        with self.raises(space, "IndexError", "negative length (-1)"):
            w_res = space.execute("a = [1, 2]; a[0, -1] = 42")
        w_res = space.execute("a = [1, 2]; a[-1, 1] = 42; return a")
        assert self.unwrap(space, w_res) == [1, 42]
        w_res = space.execute("a = [1, 2]; a[-2, 2] = 42; return a")
        assert self.unwrap(space, w_res) == [42]

    def test_length(self, space):
        w_res = space.execute("return [1, 2, 3].length")
        assert space.int_w(w_res) == 3

    def test_emptyp(self, space):
        w_res = space.execute("return [].empty?")
        assert w_res is space.w_true
        w_res = space.execute("return [1].empty?")
        assert w_res is space.w_false

    def test_plus(self, space):
        w_res = space.execute("return [1, 2] + [3]")
        assert self.unwrap(space, w_res) == [1, 2, 3]
        with self.raises(space, "TypeError", "can't convert Symbol into Array"):
            space.execute("[1, 2] + :not_an_array")
        w_res = space.execute("""
        class NotAnArray
          def to_ary
            [8, 7]
          end
        end
        return [9] + NotAnArray.new
        """)
        assert self.unwrap(space, w_res) == [9, 8, 7]

    def test_minus(self, space):
        w_res = space.execute("return [1, 1, 2, '3'] - [1, '3']")
        assert self.unwrap(space, w_res) == [2]

    def test_lshift(self, space):
        w_res = space.execute("return [] << 1")
        assert self.unwrap(space, w_res) == [1]

    def test_concat(self, space):
        w_res = space.execute("""
        a = [1, 2]
        b = a.concat([3, 4])
        return a, a == b
        """)
        assert self.unwrap(space, w_res) == [[1, 2, 3, 4], True]

    def test_zip(self, space):
        w_res = space.execute("return [1, 2, 3].zip([3, 2, 1])")
        assert self.unwrap(space, w_res) == [[1, 3], [2, 2], [3, 1]]

    def test_product(self, space):
        w_res = space.execute("return [1, 2].product([3, 4])")
        assert self.unwrap(space, w_res) == [[1, 3], [1, 4], [2, 3], [2, 4]]

    def test_size(self, space):
        w_res = space.execute("return [1, 2].size")
        assert space.int_w(w_res) == 2

    def test_range_inclusive(self, space):
        w_res = space.execute("return [1, 2, 3, 4, 5][1..2]")
        assert self.unwrap(space, w_res) == [2, 3]
        w_res = space.execute("return [1, 2, 3, 4, 5][1..-1]")
        assert self.unwrap(space, w_res) == [2, 3, 4, 5]
        w_res = space.execute("return [1, 2, 3, 4, 5][-2..-1]")
        assert self.unwrap(space, w_res) == [4, 5]
        w_res = space.execute("return [][-1..-2]")
        assert w_res == space.w_nil
        w_res = space.execute("return [][0..-2]")
        assert self.unwrap(space, w_res) == []
        w_res = space.execute("return [1, 2][-1..-2]")
        assert self.unwrap(space, w_res) == []
        w_res = space.execute("""
        class String; def to_int; 1; end; end
        return [1, 2, 3, 4, 5]["1".."1"]
        """)
        assert self.unwrap(space, w_res) == [2]

    def test_range_exclusive(self, space):
        w_res = space.execute("return [1, 2, 3, 4, 5][1...3]")
        assert self.unwrap(space, w_res) == [2, 3]
        w_res = space.execute("return [1, 2, 3, 4, 5][1...-1]")
        assert self.unwrap(space, w_res) == [2, 3, 4]
        w_res = space.execute("return [1, 2, 3, 4, 5][-2...-1]")
        assert self.unwrap(space, w_res) == [4]

    def test_range_assignment(self, space):
        w_res = space.execute("x = [1, 2, 3]; x[1..2] = 4; return x")
        assert self.unwrap(space, w_res) == [1, 4]
        w_res = space.execute("x = [1, 2, 3]; x[1..-2] = 4; return x")
        assert self.unwrap(space, w_res) == [1, 4, 3]
        w_res = space.execute("x = [1, 2, 3]; x[-3..-2] = 4; return x")
        assert self.unwrap(space, w_res) == [4, 3]
        w_res = space.execute("x = [1, 2, 3]; x[-1..-2] = 4; return x")
        assert self.unwrap(space, w_res) == [1, 2, 4, 3]
        w_res = space.execute("x = [1, 2, 3]; x[1..-2] = []; return x")
        assert self.unwrap(space, w_res) == [1, 3]
        w_res = space.execute("x = [1, 2, 3]; x[1..-2] = [4]; return x")
        assert self.unwrap(space, w_res) == [1, 4, 3]
        w_res = space.execute("x = [1, 2, 3]; x[1..-2] = [4, 5]; return x")
        assert self.unwrap(space, w_res) == [1, 4, 5, 3]

    def test_at(self, space):
        w_res = space.execute("return [1, 2, 3, 4, 5].at(2)")
        assert space.int_w(w_res) == 3

    def test_unshift(self, space):
        w_res = space.execute("return [1, 2].unshift(3, 4)")
        assert self.unwrap(space, w_res) == [3, 4, 1, 2]

    def test_join(self, space):
        w_res = space.execute("return [1, 'a', :b].join")
        assert space.str_w(w_res) == "1ab"
        w_res = space.execute("return [1, 'a', :b].join('--')")
        assert space.str_w(w_res) == "1--a--b"
        w_res = space.execute("return [1, 'a', :b].join(?-)")
        assert space.str_w(w_res) == "1-a-b"
        with self.raises(space, "TypeError", "can't convert Symbol into String"):
            space.execute("[1].join(:foo)")
        w_res = space.execute("return [].join(:foo)")
        assert space.str_w(w_res) == ""
        w_res = space.execute("""
        class A; def to_str; 'A'; end; end
        return [1, 2].join(A.new)
        """)
        assert space.str_w(w_res) == "1A2"

    def test_dup(self, space):
        w_res = space.execute("""
        x = [1, 2, 3]
        y = x.dup
        x << 4
        return [x, y]
        """)
        x, y = self.unwrap(space, w_res)
        assert x == [1, 2, 3, 4]
        assert y == [1, 2, 3]

    def test_compact(self, space):
        w_res = space.execute("return ['a', nil, 'b', nil, 'c'].compact")
        assert self.unwrap(space, w_res) == ['a', 'b', 'c']

    def test_rejectbang(self, space):
        w_res = space.execute("return [1, 2, 3, 4].reject! { false }")
        assert w_res == space.w_nil
        w_res = space.execute("return [1, 2, 3, 4].reject! { true }")
        assert space.listview(w_res) == []

    def test_delete_if(self, space):
        w_res = space.execute("""
        a = [1, 2, 3]
        a.delete_if { true }
        return a
        """)
        assert self.unwrap(space, w_res) == []
        w_res = space.execute("""
        a = [1, 2, 3, 4]
        return a.delete_if {|x| x > 2 }
        """)
        assert self.unwrap(space, w_res) == [1, 2]
        w_res = space.execute("""
        a = [1, 2, 3, 4]
        return a.delete_if {|x| x == 2 || x == 4 }
        """)
        assert self.unwrap(space, w_res) == [1, 3]
        w_res = space.execute("""
        a = [1, 2, 3, 4]
        return a.delete_if {|x| x == 1 || x == 3 }
        """)
        assert self.unwrap(space, w_res) == [2, 4]

    def test_pop(self, space):
        assert self.unwrap(space, space.execute("return [1, 2, 3].pop")) == 3
        assert self.unwrap(space, space.execute("return [1, 2, 3].pop(0)")) == []
        assert self.unwrap(space, space.execute("return [1, 2, 3].pop(1)")) == [3]
        assert self.unwrap(space, space.execute("return [1, 2, 3].pop(2)")) == [2, 3]
        assert self.unwrap(space, space.execute("return [1, 2, 3].pop(10)")) == [1, 2, 3]
        assert self.unwrap(space, space.execute("return [].pop(1)")) == []
        assert self.unwrap(space, space.execute("return [].pop")) is None
        with self.raises(space, "ArgumentError"):
            space.execute("[1].pop(-1)")
        with self.raises(space, "TypeError"):
            space.execute("[1].pop('a')")

    def test_delete(self, space):
        w_res = space.execute("""
        a = [ "a", "b", "b", "b", "c" ]
        r = []
        r << a.delete("b")
        r << a
        r << a.delete("z")
        r << a.delete("z") { "not found" }
        return r
        """)
        assert self.unwrap(space, w_res) == ["b", ["a", "c"], None, "not found"]

    def test_delete_at(self, space):
        w_res = space.execute("""
        res = []
        a = ["ant", "bat", "cat", "dog"]
        res << a.delete_at(2)    #=> "cat"
        res << a                 #=> ["ant", "bat", "dog"]
        res << a.delete_at(99)   #=> nil
        return res
        """)
        assert self.unwrap(space, w_res) == ["cat", ["ant", "bat", "dog"], None]

    def test_first(self, space):
        assert space.int_w(space.execute("return [1, 2, 3].first")) == 1
        assert space.execute("return [].first") == space.w_nil

    def test_last(self, space):
        assert space.int_w(space.execute("return [1, 2, 3].last")) == 3
        assert space.execute("return [].last") == space.w_nil

    def test_shift(self, space):
        w_res = space.execute("return [].shift")
        assert w_res is space.w_nil

        w_res = space.execute("""
        a = [1, 2]
        return [a.shift, a]
        """)
        assert self.unwrap(space, w_res) == [1, [2]]

        w_res = space.execute("""
        a = [1, 2, 3, 4, 5]
        return [a.shift(2), a]
        """)
        assert self.unwrap(space, w_res) == [[1, 2], [3, 4, 5]]

        with self.raises(space, "ArgumentError"):
            space.execute("[].shift(-2)")

    def test_push(self, space):
        w_res = space.execute("return [].push(2, 3)")
        assert self.unwrap(space, w_res) == [2, 3]

    def test_eq(self, space):
        w_res = space.execute("""
        x = []
        return [
          [] == :abc,
          [] == [],
          [:abc] == [:abc],
          x == (x << 2),
          [1, 2, 3] == [1, 2, 4],
          [1] == [1, 2],
        ]
        """)
        assert self.unwrap(space, w_res) == [False, True, True, True, False, False]

    def test_eqlp(self, space):
        w_res = space.execute("return [].eql? 2")
        assert w_res is space.w_false
        w_res = space.execute("return [0].eql? [0.0]")
        assert w_res is space.w_false
        w_res = space.execute("return [0].eql? [0]")
        assert w_res is space.w_true

    def test_clear(self, space):
        w_res = space.execute("""
        a = [1, 2, 3]
        a.clear
        return a
        """)
        assert self.unwrap(space, w_res) == []

    def test_hashability(self, space):
        w_res = space.execute("return {[] => 2}[[]]")
        assert space.int_w(w_res) == 2
        w_res = space.execute("return {[1] => 5}[[1]]")
        assert space.int_w(w_res) == 5
        w_res = space.execute("return {[1, 2, 3] => 5}[[1, 2]]")
        assert w_res is space.w_nil

    def test_sort(self, space):
        w_res = space.execute("""
        a = [3, 2, 1]
        b = a.sort
        return a.object_id == b.object_id, a, b
        """)
        assert self.unwrap(space, w_res) == [False, [3, 2, 1], [1, 2, 3]]
        w_res = space.execute("""
        a = [3, 2, 1]
        b = a.sort!
        return a.object_id == b.object_id, a, b
        """)
        assert self.unwrap(space, w_res) == [True, [1, 2, 3], [1, 2, 3]]
        w_res = space.execute("""
        a = [1, 2, 3]
        b = a.sort { |a, b| -a <=> -b }
        return a.object_id == b.object_id, a, b
        """)
        assert self.unwrap(space, w_res) == [False, [1, 2, 3], [3, 2, 1]]
        w_res = space.execute("""
        a = [1, 2, 3]
        b = a.sort! { |a, b| -a <=> -b }
        return a.object_id == b.object_id, a, b
        """)
        assert self.unwrap(space, w_res) == [True, [3, 2, 1], [3, 2, 1]]
        with self.raises(space, "ArgumentError", "comparison of Array with Object failed"):
            space.execute("[Object.new, []].sort")

    def test_multiply(self, space):
        w_res = space.execute("return [ 1, 2, 3 ] * 3")
        assert self.unwrap(space, w_res) == [1, 2, 3, 1, 2, 3, 1, 2, 3]
        w_res = space.execute("return [ 1, 2, 3 ] * ','")
        assert self.unwrap(space, w_res) == "1,2,3"

    def test_flatten(self, space):
        w_res = space.execute("""
        s = [ 1, 2, 3 ]
        t = [ 4, 5, 6, [7, 8] ]
        a = [ s, t, 9, 10 ]
        return a.flatten
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        w_res = space.execute("return [ 1, 2, [3, [4, 5] ] ].flatten(1)")
        assert self.unwrap(space, w_res) == [1, 2, 3, [4, 5]]
        with self.raises(space, "ArgumentError", "tried to flatten recursive array"):
            space.execute("""
            a = [0, 1, 2, 3]
            a[0] = a
            a.flatten
            """)


class TestArrayPack(BaseTopazTest):
    def test_garbage_format(self, space):
        assert space.str_w(space.execute("return [].pack ''")) == ""
        assert space.str_w(space.execute("return [].pack 'yy'")) == ""
        assert space.str_w(space.execute("return [1, 2].pack 'y3'")) == ""

    def test_padding(self, space):
        assert space.str_w(space.execute("return [].pack 'xx'")) == "\0\0"
        assert space.str_w(space.execute("return [].pack 'x2'")) == "\0\0"

    def test_moving(self, space):
        assert space.str_w(space.execute("return [].pack '@2'")) == "\0\0"
        assert space.str_w(space.execute("return [].pack 'xx@2'")) == "\0\0"

    def test_backing_up(self, space):
        assert space.str_w(space.execute("return [].pack 'xxXX'")) == ""
        with self.raises(space, "ArgumentError", "X outside of string"):
            space.execute("[].pack 'X'")

    def test_char(self, space):
        assert space.str_w(space.execute("return [-10, 10].pack 'cc'")) == struct.pack("bb", -10, 10)
        assert space.str_w(space.execute("return [255].pack 'C'")) == struct.pack("B", 255)
        assert space.str_w(space.execute("return [256].pack 'C'")) == struct.pack("B", 256 % 256)
        assert space.str_w(space.execute("return [-255].pack 'C'")) == struct.pack("B", -255 % 256)
        with self.raises(space, "ArgumentError", "> allowed only after types SsIiLlQq"):
            space.execute("[-255].pack 'C>'")
        with self.raises(space, "ArgumentError", "! allowed only after types SsIiLl"):
            space.execute("[-255].pack 'C!'")
        with self.raises(space, "ArgumentError", "< allowed only after types SsIiLlQq"):
            space.execute("[-255].pack 'C<'")

    def test_short(self, space):
        assert space.str_w(space.execute("return [-255].pack 'S'")) == struct.pack("H", -255 % 2 ** 16)
        assert space.str_w(space.execute("return [12].pack 's'")) == struct.pack("h", 12)
        assert space.str_w(space.execute("return [12].pack 'S!'")) == struct.pack("@h", 12)
        assert space.str_w(space.execute("return [12].pack 'S_'")) == struct.pack("@h", 12)
        assert space.str_w(space.execute("return [12].pack 'S_!_'")) == struct.pack("@h", 12)
        with self.raises(space, "RangeError", "Can't use both '<' and '>'"):
            space.execute("[2].pack 'S><'")

    def test_long(self, space):
        assert space.str_w(space.execute("return [-255].pack 'I'")) == struct.pack("I", -255 % 2 ** 32)
        assert space.str_w(space.execute("return [12].pack 'i'")) == struct.pack("i", 12)
        assert space.str_w(space.execute("return [-255].pack 'L'")) == struct.pack("I", -255 % 2 ** 32)
        assert space.str_w(space.execute("return [12].pack 'l'")) == struct.pack("i", 12)

    def test_longlong(self, space):
        assert space.str_w(space.execute("return [-255].pack 'Q'")) == struct.pack("Q", -255 % 2 ** 64)
        assert space.str_w(space.execute("return [12].pack 'q'")) == struct.pack("q", 12)

    def test_float(self, space):
        assert space.str_w(space.execute("return [-255].pack 'f'")) == struct.pack("f", -255)
        assert space.str_w(space.execute("return [-255].pack 'F'")) == struct.pack("f", -255)
        assert space.str_w(space.execute("return [-255.42].pack 'F'")) == struct.pack("f", -255.42)

    def test_double(self, space):
        assert space.str_w(space.execute("return [-255].pack 'd'")) == struct.pack("d", -255)
        assert space.str_w(space.execute("return [-255].pack 'D'")) == struct.pack("d", -255)
        assert space.str_w(space.execute("return [-255.42].pack 'D'")) == struct.pack("d", -255.42)

    def test_strings(self, space):
        string = "abö"
        assert space.str_w(space.execute("return ['%s'].pack 'a'" % string)) == string[0]
        assert space.str_w(space.execute("return ['%s'].pack 'A6'" % string)) == string + "  "
        assert space.str_w(space.execute("return ['abö'].pack 'a6'")) == string + "\0\0"
        assert space.str_w(space.execute("return ['abö'].pack 'Z6'")) == string + "\0\0"
        assert space.str_w(space.execute("return ['abö'].pack 'Z*'")) == string + "\0"

    def test_endianess(self, space):
        assert space.str_w(space.execute("return [42].pack 's<'")) == struct.pack("<h", 42)
        assert space.str_w(space.execute("return [42].pack 's>'")) == struct.pack(">h", 42)
        assert space.str_w(space.execute("return [42].pack 'S<'")) == struct.pack("<H", 42)
        assert space.str_w(space.execute("return [42].pack 'S>'")) == struct.pack(">H", 42)

        assert space.str_w(space.execute("return [42].pack 'i<'")) == struct.pack("<i", 42)
        assert space.str_w(space.execute("return [42].pack 'i>'")) == struct.pack(">i", 42)
        assert space.str_w(space.execute("return [42].pack 'I<'")) == struct.pack("<I", 42)
        assert space.str_w(space.execute("return [42].pack 'I>'")) == struct.pack(">I", 42)

        assert space.str_w(space.execute("return [42].pack 'q<'")) == struct.pack("<q", 42)
        assert space.str_w(space.execute("return [42].pack 'q>'")) == struct.pack(">q", 42)
        assert space.str_w(space.execute("return [42].pack 'Q<'")) == struct.pack("<Q", 42)
        assert space.str_w(space.execute("return [42].pack 'Q>'")) == struct.pack(">Q", 42)

        assert space.str_w(space.execute("return [42].pack 'v'")) == struct.pack("<H", 42)
        assert space.str_w(space.execute("return [42].pack 'V'")) == struct.pack("<I", 42)
        assert space.str_w(space.execute("return [42].pack 'n'")) == struct.pack(">H", 42)
        assert space.str_w(space.execute("return [42].pack 'N'")) == struct.pack(">I", 42)

        assert space.str_w(space.execute("return [4.2].pack 'e'")) == struct.pack("<f", 4.2)
        assert space.str_w(space.execute("return [4.2].pack 'g'")) == struct.pack(">f", 4.2)
        assert space.str_w(space.execute("return [4.2].pack 'E'")) == struct.pack("<d", 4.2)
        assert space.str_w(space.execute("return [4.2].pack 'G'")) == struct.pack(">d", 4.2)

    def test_complex(self, space):
        w_res = space.execute("""
        return [65, 66, 5, 5, 4.2, 4.2, "hello"].pack 'c02s<s>egg0Z*'
        """)
        expected = (struct.pack("2b", 65, 66) +
                    struct.pack("<h", 5) +
                    struct.pack(">h", 5) +
                    struct.pack("<f", 4.2) +
                    struct.pack(">f", 4.2) +
                    "hello\0")
        assert space.str_w(w_res) == expected

    def test_pointers(self, space):
        pointerlen = struct.calcsize("P")
        w_res = space.execute("return [''].pack 'P'")
        assert space.str_w(w_res) == "\0" * pointerlen
        w_res = space.execute("return [''].pack 'p'")
        assert space.str_w(w_res) == "\0" * pointerlen

    def test_errors(self, space):
        with self.raises(space, "ArgumentError", "too few arguments"):
            space.execute("[].pack 'P'")
        with self.raises(space, "ArgumentError", "too few arguments"):
            space.execute("[].pack 'a'")
        with self.raises(space, "ArgumentError", "too few arguments"):
            space.execute("[].pack 'c'")
        with self.raises(space, "ArgumentError", "too few arguments"):
            space.execute("[].pack 'f'")
        with self.raises(space, "RangeError", "pack length too big"):
            space.execute("[].pack 'a18446744073709551617'")

    def test_max(self, space):
        w_res = space.execute("""
        a = %w(albatross dog horse)
        return a.max
        """)
        assert self.unwrap(space, w_res) == "horse"
        w_res = space.execute("""
        a = %w(albatross dog horse)
        return a.max { |a, b| a.length <=> b.length }
        """)
        assert self.unwrap(space, w_res) == "albatross"
        assert space.execute("[].max") is space.w_nil

    def test_singleton_subscript(self, space):
        w_res = space.execute("return Array[6, -1]")
        assert self.unwrap(space, w_res) == [6, -1]

    def test_each(self, space):
        w_res = space.execute("return [1, 2].each { }")
        assert self.unwrap(space, w_res) == [1, 2]

########NEW FILE########
__FILENAME__ = test_bignumobject
from rpython.rlib.rbigint import rbigint

from ..base import BaseTopazTest


class TestBignumObject(BaseTopazTest):
    def test_name(self, space):
        space.execute("Bignum")

    def test_plus(self, space):
        w_res = space.execute("return 18446744073709551628 + 9")
        assert space.bigint_w(w_res) == rbigint.fromlong(18446744073709551637)

    def test_sub(self, space):
        w_res = space.execute("return 18446744073709551628 - 18446744073709551658")
        assert space.bigint_w(w_res) == rbigint.fromint(-30)

    def test_neg(self, space):
        w_res = space.execute("return -(18446744073709551628)")
        assert space.bigint_w(w_res) == rbigint.fromlong(-18446744073709551628)

    def test_and(self, space):
        w_res = space.execute("return 18446744073709551628 & 18446744073709551658")
        assert space.bigint_w(w_res) == rbigint.fromlong(18446744073709551624)

    def test_xor(self, space):
        w_res = space.execute("return 18446744073709551628 ^ 18446744073709551658")
        assert space.bigint_w(w_res) == rbigint.fromint(38)

    def test_eq(self, space):
        w_res = space.execute("return 18446744073709551628 == 18446744073709551628")
        assert w_res is space.w_true
        w_res = space.execute("return 18446744073709551628 == 18446744073709551629")
        assert w_res is space.w_false

    def test_comparator(self, space):
        w_res = space.execute("return 18446744073709551628 <=> 2")
        assert space.int_w(w_res) == 1

    def test_hash(self, space):
        w_res = space.execute("return 18446744073709551628.hash == 18446744073709551628.hash")
        assert w_res is space.w_true
        w_res = space.execute("return 18446744073709551628.hash == 18446744073709551658.hash")
        assert w_res is space.w_false

    def test_coerce(self, space):
        w_res = space.execute("return 18446744073709551628.coerce 12")
        assert self.unwrap(space, w_res) == [rbigint.fromint(12), rbigint.fromlong(18446744073709551628)]

        w_res = space.execute("return 18446744073709551628.coerce 18446744073709551628")
        assert self.unwrap(space, w_res) == [rbigint.fromlong(18446744073709551628), rbigint.fromlong(18446744073709551628)]

        with self.raises(space, "TypeError", "can't coerce String to Bignum"):
            space.execute("18446744073709551628.coerce 'hello'")

    def test_to_f(self, space):
        w_res = space.execute("return 18446744073709551628.to_f")
        assert space.float_w(w_res) == 1.8446744073709552e+19

    def test_pow(self, space):
        w_res = space.execute("return 18446744073709551628 ** 2")
        assert self.unwrap(space, w_res) == rbigint.fromlong(340282366920938463906096465200797450384)
        w_res = space.execute("return 18446744073709551628 ** -2")
        assert self.unwrap(space, w_res) == 1.0 / 340282366920938463906096465200797450384
        w_res = space.execute("return 18446744073709551628 ** 0.5")
        assert self.unwrap(space, w_res) == 4294967296.0
        w_res = space.execute("return 18446744073709551628 ** -0.5")
        assert self.unwrap(space, w_res) == 2.3283064365386963e-10
        with self.raises(space, "TypeError", "String can't be coerced into Bignum"):
            space.execute("18446744073709551628 ** 'hallo'")

########NEW FILE########
__FILENAME__ = test_bindingobject
class TestBindingObject(object):
    def test_simple(self, space):
        w_res = space.execute("return binding.eval('4')")
        assert space.int_w(w_res) == 4

    def test_local(self, space):
        w_res = space.execute("""
        a = 4
        return binding.eval('a + 2')
        """)
        assert space.int_w(w_res) == 6

    def test_local_in_binding(self, space):
        w_res = space.execute("""
        a = 5
        return binding.eval('b = 4; a + b')
        """)
        return space.int_w(w_res) == 9

    def test_in_block(self, space):
        w_res = space.execute("""
        def f(a, b)
          return proc { binding }
        end

        return f(3, 4).call.eval("a + b")
        """)
        assert space.int_w(w_res) == 7

    def test_unused_closure(self, space):
        w_res = space.execute("""
        a = 5
        return binding.eval('12')
        """)
        assert space.int_w(w_res) == 12

########NEW FILE########
__FILENAME__ = test_boolobject
from ..base import BaseTopazTest


class TestTrueObject(BaseTopazTest):
    def test_name(self, space):
        space.execute("TrueClass")

    def test_to_s(self, space):
        w_res = space.execute("return true.to_s")
        assert space.str_w(w_res) == "true"

    def test_inspect(self, space):
        w_res = space.execute("return true.inspect")
        assert space.str_w(w_res) == "true"

    def test_eql(self, space):
        w_res = space.execute("return true == false")
        assert self.unwrap(space, w_res) is False

        w_res = space.execute("return true == true")
        assert self.unwrap(space, w_res) is True

    def test_and(self, space):
        w_res = space.execute("return true & 3")
        assert w_res is space.w_true
        w_res = space.execute("return true & false")
        assert w_res is space.w_false

    def test_or(self, space):
        w_res = space.execute("return true | 3")
        assert w_res is space.w_true
        w_res = space.execute("return true | nil")
        assert w_res is space.w_true

    def test_xor(self, space):
        assert space.execute("return true ^ nil") is space.w_true
        assert space.execute("return true ^ false") is space.w_true
        assert space.execute("return true ^ true") is space.w_false
        assert space.execute("return true ^ 1") is space.w_false

    def test_singleton_class(self, space):
        w_res = space.execute("return true.singleton_class == TrueClass")
        assert w_res is space.w_true


class TestFalseObject(BaseTopazTest):
    def test_name(self, space):
        space.execute("FalseClass")

    def test_to_s(self, space):
        w_res = space.execute("return false.to_s")
        assert space.str_w(w_res) == "false"

    def test_inspect(self, space):
        w_res = space.execute("return false.inspect")
        assert space.str_w(w_res) == "false"

    def test_eql(self, space):
        w_res = space.execute("return false == false")
        assert self.unwrap(space, w_res) is True

        w_res = space.execute("return false == true")
        assert self.unwrap(space, w_res) is False

    def test_and(self, space):
        w_res = space.execute("return false & 3")
        assert w_res is space.w_false
        w_res = space.execute("return false & false")
        assert w_res is space.w_false

    def test_or(self, space):
        w_res = space.execute("return false | 3")
        assert w_res is space.w_true
        w_res = space.execute("return false | nil")
        assert w_res is space.w_false

    def test_xor(self, space):
        assert space.execute("return false ^ nil") is space.w_false
        assert space.execute("return false ^ false") is space.w_false
        assert space.execute("return false ^ true") is space.w_true
        assert space.execute("return false ^ 1") is space.w_true

    def test_singleton_class(self, space):
        w_res = space.execute("return false.singleton_class == FalseClass")
        assert w_res is space.w_true

########NEW FILE########
__FILENAME__ = test_classobject
import pytest
from ..base import BaseTopazTest


class TestClassObject(BaseTopazTest):
    def test_name(self, space):
        space.execute("Class")

    def test_generated_subclass(self, space):
        w_res = space.execute("""
        class Foo
          class Bar
            class Baz
            end
          end
        end
        return Foo::Bar::Baz.name
        """)
        assert space.str_w(w_res) == "Foo::Bar::Baz"

    def test_to_s(self, space):
        w_res = space.execute("return 1.class.to_s")
        assert space.str_w(w_res) == "Fixnum"

        w_res = space.execute("return 1.class.class.to_s")
        assert space.str_w(w_res) == "Class"

    def test_anon_class_to_s(self, space):
        w_res = space.execute("return Class.new.to_s")
        assert space.str_w(w_res).startswith("#<Class:0x")

        w_res = space.execute("return Class.new.new.to_s")
        assert space.str_w(w_res).startswith("#<#<Class:0x")

    @pytest.mark.xfail
    def test_singletonclass_to_s(self, space):
        w_res = space.execute("Class.new.singleton_class.to_s")
        assert space.str_w(w_res).startswith("#<Class:#<Class:0x")

    def test_anon_class_name(self, space):
        w_res = space.execute("return Class.new.name")
        assert w_res is space.w_nil

    def test_anon_class_method_missing_raises(self, space):
        with self.raises(space, "NoMethodError"):
            space.execute("""
            class A; end
            Class.new.does_not_exist
            """)

    def test_singletonclass_name(self, space):
        w_res = space.execute("Class.new.singleton_class.name")
        assert w_res is space.w_nil

    def test_class_new(self, space):
        w_res = space.execute("return Class.new.superclass.name")
        assert space.str_w(w_res) == "Object"
        w_res = space.execute("return Class.new(String).superclass.name")
        assert space.str_w(w_res) == "String"

    def test_new(self, space):
        w_res = space.execute("""
        class X
        end

        return X.new
        """)
        w_cls = space.w_object.constants_w["X"]
        assert space.getclass(w_res) is w_cls

        w_res = space.execute("""
        class X
          def m
            self
          end
        end

        x = X.new
        return [x, x.m]
        """)

        [w_x, w_xm] = space.listview(w_res)
        assert w_xm is w_x

    def test_superclass(self, space):
        w_res = space.execute("return Object.superclass")
        assert w_res is space.w_basicobject
        w_res = space.execute("return BasicObject.superclass")
        assert w_res is space.w_nil

    def test_attr_accessor(self, space):
        w_res = space.execute("""
        class X
          attr_accessor :a, :b, :c
          def initialize a
            @a = a
            self.b = 25
          end
        end

        x = X.new(3)
        orig_a = x.a
        x.a = 5
        return [orig_a, x.a, x.b]
        """)
        assert [space.int_w(w_x) for w_x in space.listview(w_res)] == [3, 5, 25]

    def test_attr_reader(self, space):
        w_res = space.execute("""
        class X
          attr_reader :a
          def initialize
            @a = 5
          end
        end
        return X.new.a
        """)
        assert space.int_w(w_res) == 5

########NEW FILE########
__FILENAME__ = test_dirobject
import os

from ..base import BaseTopazTest


class TestDir(BaseTopazTest):
    def test_name(self, space):
        space.execute("Dir")

    def test_pwd(self, space):
        w_res = space.execute("return Dir.pwd")
        assert space.str_w(w_res) == os.getcwd()
        w_res = space.execute("return Dir.getwd")
        assert space.str_w(w_res) == os.getcwd()

    def test_new(self, space, tmpdir):
        d = tmpdir.mkdir("sub")
        f = d.join("content")
        f.write("hello")
        space.execute("Dir.new('%s')" % d)
        with self.raises(space, "Errno::ENOENT"):
            space.execute("Dir.new('this does not exist')")
        with self.raises(space, "Errno::ENOTDIR"):
            space.execute("Dir.new('%s')" % f)

    def test_delete(self, space, tmpdir):
        d = tmpdir.mkdir("sub")
        space.execute("Dir.delete('%s')" % d)
        assert not tmpdir.listdir()
        d = tmpdir.mkdir("sub")
        f = d.join("content")
        f.write("hello")
        with self.raises(space, "Errno::ENOTEMPTY"):
            space.execute("Dir.delete('%s')" % d)

    def test_mkdir(self, space, tmpdir):
        space.execute("Dir.mkdir(File.join('%s', 'madedir'))" % tmpdir)
        assert tmpdir.join("madedir").check()
        assert tmpdir.join("madedir").stat().mode & 0100 == 0100

    def test_chdir(self, space, tmpdir, monkeypatch):
        w_res = space.execute("""
        dirs = []
        dirs << Dir.pwd
        Dir.chdir('%s') do
          dirs << Dir.pwd
        end
        dirs << Dir.pwd
        return dirs
        """ % tmpdir)
        paths = [os.getcwd(), os.path.realpath(str(tmpdir)), os.getcwd()]
        assert self.unwrap(space, w_res) == paths

        monkeypatch.setenv("HOME", str(tmpdir))
        w_res = space.execute("""
        Dir.chdir do
          return Dir.pwd
        end
        """)

        assert space.str_w(w_res) == os.path.realpath(str(tmpdir))

    def test_glob(self, space, tmpdir):
        sub1 = tmpdir.mkdir("sub1")
        sub2 = tmpdir.mkdir("sub2")
        sub1.join("sub1content1").ensure()
        sub1.join("sub1content2").ensure()
        sub2.join("sub2content1").ensure()
        sub2.join("sub2content2").ensure()
        w_res = space.execute("""
        Dir.chdir('%s') do
          return Dir['*']
        end
        """ % tmpdir)
        res = self.unwrap(space, w_res)
        res.sort()
        assert res == ["sub1", "sub2"]
        w_res = space.execute("""
        Dir.chdir('%s') do
          return Dir['**/*']
        end
        """ % tmpdir)
        res = self.unwrap(space, w_res)
        res.sort()
        assert res == ["sub1", "sub1/sub1content1", "sub1/sub1content2", "sub2", "sub2/sub2content1", "sub2/sub2content2"]
        w_res = space.execute("""
        Dir.chdir('%s') do
          return Dir['**/*{1con}*']
        end
        """ % tmpdir)
        res = self.unwrap(space, w_res)
        res.sort()
        assert res == ["sub1/sub1content1", "sub1/sub1content2"]
        w_res = space.execute("""
        Dir.chdir('%s') do
          return Dir['**/sub[1]content[12]']
        end
        """ % tmpdir)
        res = self.unwrap(space, w_res)
        res.sort()
        assert res == ["sub1/sub1content1", "sub1/sub1content2"]
        w_res = space.execute("""
        Dir.chdir('%s') do
          return Dir['%s/']
        end
        """ % (tmpdir, tmpdir.join("..")))
        assert self.unwrap(space, w_res) == [str(tmpdir.join("..")) + "/"]
        w_res = space.execute("""
        Dir.chdir('%s') do
          return Dir["sub1\\0foo", "sub\\02bar"], Dir["sub1\\0foo"]
        end
        """ % tmpdir)
        res = self.unwrap(space, w_res)
        assert res == [["sub1"], ["sub1"]]

    def test_read(self, space, tmpdir):
        d = tmpdir.mkdir("sub")
        f = d.join("content")
        f.write("hello")
        f = d.join("content2")
        f.write("hello")
        w_res = space.execute("""
        d = Dir.new('%s')
        return [d.read, d.read, d.read, d.read, d.read]
        """ % d)
        res = self.unwrap(space, w_res)
        res.sort()
        assert res == [None, ".", "..", "content", "content2"]

    def test_close(self, space, tmpdir):
        with self.raises(space, "IOError", "closed directory"):
            space.execute("""
            d = Dir.new('%s')
            d.close
            d.close
            """ % tmpdir)
        with self.raises(space, "IOError", "closed directory"):
            space.execute("""
            d = Dir.new('%s')
            d.close
            d.read
            """ % tmpdir)

########NEW FILE########
__FILENAME__ = test_encodingobject
class TestEncodingObject(object):
    def test_exists(self, space):
        space.execute("Encoding")

########NEW FILE########
__FILENAME__ = test_envobject
import os

from ..base import BaseTopazTest


class TestEnvObject(BaseTopazTest):
    def test_get(self, space, monkeypatch):
        monkeypatch.setenv("ABC", "12")
        w_res = space.execute("return ENV['ABC']")
        assert self.unwrap(space, w_res) == "12"

    def test_get_nonexistant(self, space, monkeypatch):
        monkeypatch.delenv("ZZZZ", raising=False)
        w_res = space.execute("return ENV['ZZZZ']")
        assert self.unwrap(space, w_res) is None

    def test_set(self, space, monkeypatch):
        monkeypatch.delenv("ZZZZ", raising=False)
        w_res = space.execute("""
        ENV['ZZZZ'] = "/home/newhome"
        return ENV['ZZZZ']
        """)
        assert space.str_w(w_res) == os.environ["ZZZZ"] == "/home/newhome"

    def test_null_bytes(self, space):
        with self.raises(space, "ArgumentError", "bad environment variable name"):
            space.execute("""ENV["\\0"]""")
        with self.raises(space, "ArgumentError", "bad environment variable name"):
            space.execute("""ENV["\\0"] = "1" """)
        with self.raises(space, "ArgumentError", "bad environment variable value"):
            space.execute("""ENV["1"] = "\\0" """)

    def test_class(self, space):
        w_res = space.execute("return ENV.class")
        assert w_res is space.w_object

########NEW FILE########
__FILENAME__ = test_exceptionobject
from topaz.objects.exceptionobject import W_TypeError

from ..base import BaseTopazTest


class TestExceptionObject(BaseTopazTest):
    def test_name(self, space):
        space.execute("""
        Exception
        LoadError
        SyntaxError
        NameError
        StandardError
        LocalJumpError
        IOError
        IndexError
        RegexpError
        ThreadError
        NotImplementedError
        """)

    def test_new(self, space):
        w_res = space.execute("return TypeError.new")
        assert isinstance(w_res, W_TypeError)
        assert w_res.msg == "TypeError"
        w_res = space.execute("return TypeError.new('msg')")
        assert isinstance(w_res, W_TypeError)
        assert w_res.msg == "msg"
        w_res = space.execute("return TypeError.new(nil)")
        assert isinstance(w_res, W_TypeError)
        assert w_res.msg == "TypeError"

    def test_to_s(self, space):
        w_res = space.execute("return TypeError.new('msg').to_s")
        assert space.str_w(w_res) == "msg"

    def test_exceptions(self, space):
        w_res = space.execute("return TypeError.exception('msg')")
        assert isinstance(w_res, W_TypeError)
        w_res = space.execute("""
        e1 = TypeError.new('msg')
        e2 = e1.exception
        e3 = e1.exception('new msg')
        return [e1, e2, e3]
        """)
        res = space.listview(w_res)
        assert res[0] is res[1]
        assert res[0] is not res[2]

    def test_systemcallerror(self, space):
        w_res = space.execute("return SystemCallError.new('msg', 1).errno")
        assert space.int_w(w_res) == 1

    def test_message(self, space):
        w_res = space.execute("""
        begin
          raise "foo"
        rescue StandardError => e
          return e.message
        end
        """)
        assert self.unwrap(space, w_res) == "foo"

    def test_message_calls_to_s(self, space):
        w_res = space.execute("""
        class X < Exception
          def to_s
            "hi, a message!"
          end
        end
        return X.new.message
        """)
        assert space.str_w(w_res) == "hi, a message!"

    def test_backtrace(self, space):
        w_res = space.execute("""
        def f
          yield
        end
        begin
          f { 1 / 0}
        rescue Exception => e
          return e.backtrace
        end
        """)
        assert self.unwrap(space, w_res) == [
            "-e:6:in `/'",
            "-e:6:in `block in <main>'",
            "-e:3:in `f'",
            "-e:6:in `<main>'"
        ]

    def test_backtrace_complex(self, space):
        w_res = space.execute("""
        def f
          1 / 0
        end


        def g
          begin
            f
          rescue => e
            return e
          end
        end

        def h
          e = g
          nil
          nil
          nil
          nil
          @e = e
        end

        def i
          h
          @e
        end

        return i.backtrace
        """)
        assert self.unwrap(space, w_res) == [
            "-e:3:in `/'",
            "-e:3:in `f'",
            "-e:9:in `g'",
            "-e:16:in `h'",
            "-e:25:in `i'",
            "-e:29:in `<main>'",
        ]

########NEW FILE########
__FILENAME__ = test_fiberobject
from ..base import BaseTopazTest


class TestFiberObject(BaseTopazTest):
    def test_new(self, space):
        space.execute("""
        Fiber.new { }
        """)
        with self.raises(space, "ArgumentError"):
            space.execute("Fiber.new")

    def test_resume(self, space):
        w_res = space.execute("""
        f = Fiber.new { 2 }
        return f.resume
        """)
        assert space.int_w(w_res) == 2

    def test_nested_resume(self, space):
        space.execute("""
        $f = Fiber.new {
          $f.resume
        }
        """)
        with self.raises(space, "FiberError", "double resume"):
            space.execute("$f.resume")

    def test_closure(self, space):
        w_res = space.execute("""
        a = 2
        f = Fiber.new { a = 5 }
        f.resume
        return a
        """)
        assert space.int_w(w_res) == 5

    def test_exception(self, space):
        space.execute("""
        $f = Fiber.new { 1 / 0 }
        """)
        with self.raises(space, "ZeroDivisionError"):
            space.execute("$f.resume")

    def test_yield(self, space):
        w_res = space.execute("""
        r = []
        f = Fiber.new {
          r << 1
          Fiber.yield 3
          r << 2
        }
        r << "a"
        res = f.resume
        r << res
        r << "b"
        f.resume
        r << "c"
        return r
        """)
        assert self.unwrap(space, w_res) == ["a", 1, 3, "b", 2, "c"]

    def test_yield_multiarg(self, space):
        w_res = space.execute("""
        f = Fiber.new {
          Fiber.yield 1, 2, 3
        }
        return f.resume
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3]

    def test_yield_with_no_value(self, space):
        w_res = space.execute("""
        f = Fiber.new {
          Fiber.yield
        }
        return f.resume
        """)
        assert w_res is space.w_nil

    def test_yield_from_main(self, space):
        with self.raises(space, "FiberError", "can't yield from root fiber"):
            space.execute("Fiber.yield")

    def test_resume_dead_fiber(self, space):
        space.execute("""
        $f = Fiber.new {}
        $f.resume
        """)
        with self.raises(space, "FiberError", "dead fiber called"):
            space.execute("$f.resume")

    def test_first_resume_block_arguments(self, space):
        w_res = space.execute("""
        f = Fiber.new { |x, y| Fiber.yield(x + y) }
        return f.resume(2, 5)
        """)
        assert space.int_w(w_res) == 7

    def test_return_in_block(self, space):
        space.execute("""
        $f = Fiber.new { return }
        """)
        with self.raises(space, "LocalJumpError", "unexpected return"):
            space.execute("$f.resume")

    def test_break_in_block(self, space):
        space.execute("""
        $f = Fiber.new { break }
        """)
        with self.raises(space, "LocalJumpError", "break from proc-closure"):
            space.execute("$f.resume")

    def test_resume_with_value(self, space):
        w_res = space.execute("""
        r = []
        f = Fiber.new {
          r << (Fiber.yield)
        }
        f.resume
        f.resume(10)
        return r
        """)
        assert self.unwrap(space, w_res) == [10]

    def test_nested_resume_yield(self, space):
        space.execute("""
        f2 = Fiber.new { Fiber.yield }
        f1 = Fiber.new { f2.resume }
        f1.resume
        f2.resume
        """)

    def test_multiple_resume_exception(self, space):
        space.execute("""
        $f = Fiber.new { Fiber.yield; raise "error" }
        $f.resume
        """)
        with self.raises(space, "RuntimeError", "error"):
            space.execute("$f.resume")

########NEW FILE########
__FILENAME__ = test_fileobject
import os
import stat

import pytest

from topaz.objects.fileobject import W_FileObject
from topaz.system import IS_WINDOWS

from ..base import BaseTopazTest


class TestFile(BaseTopazTest):
    def test_access_flags(self, space):
        assert space.int_w(space.execute("return File::RDONLY")) == os.O_RDONLY
        assert space.int_w(space.execute("return File::WRONLY")) == os.O_WRONLY
        assert space.int_w(space.execute("return File::RDWR")) == os.O_RDWR
        assert space.int_w(space.execute("return File::APPEND")) == os.O_APPEND
        assert space.int_w(space.execute("return File::CREAT")) == os.O_CREAT
        assert space.int_w(space.execute("return File::EXCL")) == os.O_EXCL
        assert space.int_w(space.execute("return File::TRUNC")) == os.O_TRUNC
        w_res = space.execute("return File::BINARY")
        assert space.int_w(w_res) == (os.O_BINARY if hasattr(os, "O_BINARY") else 0)

    def test_separator(self, space):
        space.execute("File::SEPARATOR")

    def test_alt_separator(self, space):
        space.execute("File::ALT_SEPARATOR")

    def test_path_separator(self, space):
        space.execute("File::PATH_SEPARATOR")

    def test_fnm_syscase(self, space):
        space.execute("File::FNM_SYSCASE")

    def test_fnm_dotmatch(self, space):
        space.execute("File::FNM_DOTMATCH")

    def test_fnm_pathname(self, space):
        space.execute("File::FNM_PATHNAME")

    def test_fnm_noescape(self, space):
        space.execute("File::FNM_NOESCAPE")

    def test_new_simple(self, space, tmpdir):
        contents = "foo\nbar\nbaz\n"
        f = tmpdir.join("file.txt")
        f.write(contents)

        w_res = space.execute("return File.new('%s')" % f)
        assert isinstance(w_res, W_FileObject)
        w_res = space.execute("return File.new('%s', 'r')" % f)
        assert isinstance(w_res, W_FileObject)
        w_res = space.execute("return File.new('%s', 'rb')" % f)
        assert isinstance(w_res, W_FileObject)
        w_res = space.execute("return File.new('%s', 'r+')" % f)
        assert isinstance(w_res, W_FileObject)
        w_res = space.execute("return File.new('%s', 'rb+')" % f)
        assert isinstance(w_res, W_FileObject)
        w_res = space.execute("return File.new('%s', 'a+')" % f)
        assert isinstance(w_res, W_FileObject)

        with self.raises(space, "ArgumentError", "invalid access mode rw"):
            space.execute("File.new('%s', 'rw')" % f)
        with self.raises(space, "ArgumentError", "invalid access mode wa"):
            space.execute("File.new('%s', 'wa')" % f)
        with self.raises(space, "ArgumentError", "invalid access mode rw+"):
            space.execute("File.new('%s', 'rw+')" % f)
        with self.raises(space, "ArgumentError", "invalid access mode ra"):
            space.execute("File.new('%s', 'ra')" % f)
        with self.raises(space, "Errno::ENOENT"):
            space.execute("File.new('%s', 1)" % tmpdir.join("non-existant"))

        w_res = space.execute("return File.new('%s%snonexist', 'w')" % (tmpdir.dirname, os.sep))
        assert isinstance(w_res, W_FileObject)

        w_res = space.execute("""
        path = '%s%snonexist2'
        f = File.new(path, 'w')
        f.puts "first"
        f = File.new(path, 'a')
        f.puts "second"
        f = File.new(path, 'r')
        return f.read
        """ % (tmpdir.dirname, os.sep))
        assert space.str_w(w_res) == "first\nsecond\n"

    def test_readline(self, space, tmpdir):
        contents = "01\n02\n03\n04\n"
        f = tmpdir.join("file.txt")
        f.write(contents)
        w_res = space.execute("return File.new('%s').readline" % f)
        assert self.unwrap(space, w_res) == "01\n"

        w_res = space.execute("return File.new('%s').readline('3')" % f)
        assert self.unwrap(space, w_res) == "01\n02\n03"

        w_res = space.execute("return File.new('%s').readline(1)" % f)
        assert self.unwrap(space, w_res) == "0"

        w_res = space.execute("return File.new('%s').readline('3', 4)" % f)
        assert self.unwrap(space, w_res) == "01\n0"

    def test_readlines(self, space, tmpdir):
        contents = "01\n02\n03\n04\n"
        f = tmpdir.join("file.txt")
        f.write(contents)
        w_res = space.execute("return File.new('%s').readlines()" % f)
        assert self.unwrap(space, w_res) == ["01", "02", "03", "04", ""]

        w_res = space.execute("return File.new('%s').readlines('3')" % f)
        assert self.unwrap(space, w_res) == ["01\n02\n0", "\n04\n"]

        w_res = space.execute("return File.new('%s').readlines(1)" % f)
        assert self.unwrap(space, w_res) == ["0", "1", "0", "2", "0", "3", "0", "4", ""]

        w_res = space.execute("return File.new('%s').readlines('3', 4)" % f)
        assert self.unwrap(space, w_res) == ["01\n0", "2\n0", "\n04\n"]

    def test_each_line(self, space, tmpdir):
        contents = "01\n02\n03\n04\n"
        f = tmpdir.join("file.txt")
        f.write(contents)
        w_res = space.execute("""
        r = []
        File.new('%s').each_line { |l| r << l }
        return r
        """ % f)
        assert self.unwrap(space, w_res) == ["01", "02", "03", "04", ""]
        w_res = space.execute("""
        r = []
        File.new('%s').each_line('3') { |l| r << l }
        return r
        """ % f)
        assert self.unwrap(space, w_res) == ["01\n02\n0", "\n04\n"]
        w_res = space.execute("""
        r = []
        File.new('%s').each_line(1) { |l| r << l }
        return r
        """ % f)
        assert self.unwrap(space, w_res) == ["0", "1", "0", "2", "0", "3", "0", "4", ""]
        w_res = space.execute("""
        r = []
        File.new('%s').each_line('3', 4) { |l| r << l }
        return r
        """ % f)
        assert self.unwrap(space, w_res) == ["01\n0", "2\n0", "\n04\n"]

        with self.raises(space, "ArgumentError", "invalid limit: 0 for each_line"):
            w_res = space.execute("""
            File.new('%s').each_line(0) { |l| }
            """ % f)

    def test_join(self, space):
        w_res = space.execute("return File.join('/abc', 'bin')")
        assert space.str_w(w_res) == "/abc/bin"
        w_res = space.execute("return File.join('', 'abc', 'bin')")
        assert space.str_w(w_res) == "/abc/bin"
        w_res = space.execute("return File.join")
        assert space.str_w(w_res) == ""
        w_res = space.execute("return File.join('abc')")
        assert space.str_w(w_res) == "abc"
        w_res = space.execute("return File.join('abc', 'def', 'ghi')")
        assert space.str_w(w_res) == "abc/def/ghi"
        w_res = space.execute("return File.join(['abc', ['def'], []], 'ghi')")
        assert space.str_w(w_res) == "abc/def/ghi"
        w_res = space.execute("return File.join('a', '//', 'b', '/', 'd', '/')")
        assert space.str_w(w_res) == "a//b/d/"
        w_res = space.execute("return File.join('a', '')")
        assert space.str_w(w_res) == "a/"
        w_res = space.execute("return File.join('a/')")
        assert space.str_w(w_res) == "a/"
        w_res = space.execute("return File.join('a/', '')")
        assert space.str_w(w_res) == "a/"
        w_res = space.execute("return File.join('a', '/')")
        assert space.str_w(w_res) == "a/"
        w_res = space.execute("return File.join('a/', '/')")
        assert space.str_w(w_res) == "a/"
        w_res = space.execute("return File.join('')")
        assert space.str_w(w_res) == ""
        w_res = space.execute("return File.join([])")
        assert space.str_w(w_res) == ""

    def test_existp(self, space, tmpdir):
        f = tmpdir.join("test.rb")
        f.write("")
        w_res = space.execute("return File.exist?('%s')" % f)
        assert w_res is space.w_true
        w_res = space.execute("return File.exist?('%s')" % tmpdir)
        assert w_res is space.w_true
        w_res = space.execute("return File.exist?('no way this exists')")
        assert w_res is space.w_false

    def test_filep(self, space, tmpdir):
        f = tmpdir.join("test.rb")
        f.write("")
        w_res = space.execute("return File.file?('%s')" % f)
        assert w_res is space.w_true
        w_res = space.execute("return File.file?('%s')" % tmpdir)
        assert w_res is space.w_false
        w_res = space.execute("return File.file?('no way this exists')")
        assert w_res is space.w_false

    def test_executablep(self, space, tmpdir):
        f = tmpdir.join("test.rb")
        f.write("")
        w_res = space.execute("return File.executable?('%s')" % f)
        assert w_res is space.w_false
        os.chmod(str(f), stat.S_IEXEC)
        w_res = space.execute("return File.executable?('%s')" % f)
        assert w_res is space.w_true

    def test_directoryp(self, space, tmpdir):
        w_res = space.execute("return File.directory?('%s')" % tmpdir)
        assert self.unwrap(space, w_res) is True
        w_res = space.execute("return File.directory?('%s')" % tmpdir.join("t.rb"))
        assert self.unwrap(space, w_res) is False

    def test_open(self, space, tmpdir):
        contents = "foo\nbar\nbaz\n"
        f = tmpdir.join("file.txt")
        f.write(contents)

        w_res = space.execute("""
        File.open('%s') { |f| return f, f.read }
        """ % f)
        w_file, w_string = space.listview(w_res)
        assert space.str_w(w_string) == contents
        with pytest.raises(OSError):
            # fd should be inaccessible
            os.fstat(w_file.fd)

    def test_close(self, space, tmpdir):
        f = tmpdir.join("file.txt")
        f.write("")
        w_res = space.execute("""
        f = File.new('%s')
        f.close
        return f
        """ % f)
        with pytest.raises(OSError):
            # fd should be inaccessible
            os.fstat(w_res.fd)

    def test_closedp(self, space, tmpdir):
        f = tmpdir.join("file.txt")
        f.write("")
        w_res = space.execute("""
        f = File.new('%s')
        opened = f.closed?
        f.close
        return opened, f.closed?
        """ % f)
        assert self.unwrap(space, w_res) == [False, True]

    def test_basename(self, space):
        assert space.str_w(space.execute("return File.basename('ab')")) == "ab"
        assert space.str_w(space.execute("return File.basename('/ab')")) == "ab"
        assert space.str_w(space.execute("return File.basename('/foo/bar/ab')")) == "ab"
        assert space.str_w(space.execute("return File.basename('ab.rb', '.rb')")) == "ab"
        assert space.str_w(space.execute("return File.basename('ab.rb', 'b.rb')")) == "a"

    def test_truncate(self, space, tmpdir):
        f = tmpdir.join("file.txt")
        f.write("content")
        w_res = space.execute("""
        f = File.new('%s', "r+")
        f.truncate(3)
        return f.read
        """ % f)
        assert self.unwrap(space, w_res) == "con"

    def test_get_umask(self, space, monkeypatch):
        monkeypatch.setattr(os, "umask", lambda mask: 2)
        w_res = space.execute("return File.umask")
        assert space.int_w(w_res) == 2

    def test_set_umask(self, space, monkeypatch):
        umask = [2]

        def mock_umask(mask):
            [current], umask[0] = umask, mask
            return current
        monkeypatch.setattr(os, "umask", mock_umask)
        w_res = space.execute("return File.umask(10), File.umask")
        assert self.unwrap(space, w_res) == [2, 10]

    def test_size_p(self, space, tmpdir):
        w_res = space.execute("return File.size?('%s')" % tmpdir.join("x.txt"))
        assert w_res is space.w_nil
        tmpdir.join("x.txt").ensure()
        w_res = space.execute("return File.size?('%s')" % tmpdir.join("x.txt"))
        assert w_res is space.w_nil
        tmpdir.join("x.txt").write("abc")
        w_res = space.execute("return File.size?('%s')" % tmpdir.join("x.txt"))
        assert space.int_w(w_res) == 3

    def test_delete(self, space, tmpdir):
        tmpdir.join("t.txt").ensure()
        w_res = space.execute("return File.delete('%s')" % tmpdir.join("t.txt"))
        assert space.int_w(w_res) == 1
        assert not tmpdir.join("t.txt").check()


class TestExpandPath(BaseTopazTest):
    def test_expand_to_absolute(self, space):
        w_res = space.execute("""
        return [File.expand_path(""), File.expand_path("a"), File.expand_path("a", nil)]
        """)
        assert self.unwrap(space, w_res) == [
            os.getcwd(),
            os.path.join(os.getcwd(), "a"),
            os.path.join(os.getcwd(), "a"),
        ]
        with self.raises(space, "ArgumentError", "string contains null byte"):
            space.execute("""return File.expand_path(".\\0.")""")

    def test_expand_backslash_handling(self, space):
        w_res = space.execute("""
        return File.expand_path("a\\\\b")
        """)
        res = self.unwrap(space, w_res)
        if IS_WINDOWS:
            assert res == "/".join([os.getcwd().replace("\\", "/"), "a", "b"])
        else:
            assert res == os.path.join(os.getcwd(), "a\\b")

    def test_covert_to_absolute_using_provided_base(self, space):
        w_res = space.execute("""return File.expand_path("", "/tmp")""")
        assert self.unwrap(space, w_res) == "/tmp"
        w_res = space.execute("""return File.expand_path("a", "/tmp")""")
        assert self.unwrap(space, w_res) == "/tmp/a"
        w_res = space.execute("""return File.expand_path("../a", "/tmp/xxx")""")
        assert self.unwrap(space, w_res) == "/tmp/a"
        w_res = space.execute("""return File.expand_path(".", "/")""")
        assert self.unwrap(space, w_res) == "/"
        w_res = space.execute("""return File.expand_path(".", nil)""")
        assert self.unwrap(space, w_res) == os.getcwd()

    def test_home_expansion(self, space):
        w_res = space.execute("""return File.expand_path("~")""")
        assert self.unwrap(space, w_res) == os.environ["HOME"]
        w_res = space.execute("""return File.expand_path("~", "/tmp/random")""")
        assert self.unwrap(space, w_res) == os.environ["HOME"]
        w_res = space.execute("""return File.expand_path("~/a", "/tmp/random")""")
        assert self.unwrap(space, w_res) == os.path.join(os.environ["HOME"], "a")


class TestDirname(BaseTopazTest):
    def test_simple(self, space):
        w_res = space.execute("""
        return [
          File.dirname("/home/guido"),
          File.dirname("/home/guido/test.txt"),
          File.dirname("test.txt"),
          File.dirname("/home///guido//file.txt"),
          File.dirname(""),
          File.dirname("/"),
          File.dirname("/foo/foo"),
          File.dirname("/foo/foo//")
        ]
        """)
        assert self.unwrap(space, w_res) == [
            "/home",
            "/home/guido",
            ".",
            "/home///guido",
            ".",
            "/",
            "/foo",
            "/foo",
        ]

    def test_windows_backslash_handling(self, space):
        w_res = space.execute("""
        return [
          File.dirname("a/b/c"),
          File.dirname("a\\\\b\\\\//\\\\c/\\\\"),
          File.dirname("\\\\"),
        ]
        """)
        res = self.unwrap(space, w_res)
        if IS_WINDOWS:
            assert res == ["a/b", "a\\b", "/"]
        else:
            assert res == ["a/b", "a\\b\\//\\c", "."]

########NEW FILE########
__FILENAME__ = test_floatobject
import math
import sys

from ..base import BaseTopazTest


class TestFloatObject(BaseTopazTest):
    def test_max(self, space):
        assert space.float_w(space.execute("return Float::MAX")) == sys.float_info.max

    def test_min(self, space):
        assert space.float_w(space.execute("return Float::MIN")) == sys.float_info.min

    def test_infinity(self, space):
        assert space.float_w(space.execute("return Float::INFINITY")) == float("infinity")

    def test_nan_constant(self, space):
        assert math.isnan(space.float_w(space.execute("return Float::NAN")))

    def test_add(self, space):
        w_res = space.execute("return 1.0 + 2.9")
        assert space.float_w(w_res) == 3.9

    def test_sub(self, space):
        w_res = space.execute("return 1.0 - 5.4")
        assert space.float_w(w_res) == -4.4

    def test_mul(self, space):
        w_res = space.execute("return 1.2 * 5.0")
        assert space.float_w(w_res) == 6.0

        w_res = space.execute("return 1.2 * 2")
        assert space.float_w(w_res) == 2.4

    def test_div(self, space):
        w_res = space.execute("return 5.0 / 2.0")
        assert space.float_w(w_res) == 2.5

    def test_neg(self, space):
        w_res = space.execute("return (-5.0)")
        assert space.float_w(w_res) == -5.0

        w_res = space.execute("return (-(4.0 + 1.0))")
        assert space.float_w(w_res) == -5.0

    def test_equal(self, space):
        w_res = space.execute("return 2.3 == 2.3")
        assert w_res is space.w_true
        w_res = space.execute("return 2.4 == 2.3")
        assert w_res is space.w_false

    def test_equal_method(self, space):
        w_res = space.execute("return 2.3.equal?(2.3)")
        assert w_res is space.w_true
        w_res = space.execute("return Float::NAN.equal?(Float::NAN)")
        assert w_res is space.w_true

    def test_hashability(self, space):
        w_res = space.execute("return 1.0.hash == 1.0.hash")
        assert w_res is space.w_true

    def test_to_s(self, space):
        w_res = space.execute("return 1.5.to_s")
        assert space.str_w(w_res) == "1.5"
        w_res = space.execute("return (0.0 / 0.0).to_s")
        assert space.str_w(w_res) == "NaN"
        w_res = space.execute("return (1.0 / 0.0).to_s")
        assert space.str_w(w_res) == "Infinity"
        w_res = space.execute("return (-1.0 / 0.0).to_s")
        assert space.str_w(w_res) == "-Infinity"

    def test_to_i(self, space):
        w_res = space.execute("return [1.1.to_i, 1.1.to_int]")
        assert self.unwrap(space, w_res) == [1, 1]
        with self.raises(space, "FloatDomainError", "NaN"):
            space.execute("(0.0 / 0.0).to_i")
        with self.raises(space, "FloatDomainError", "Infinity"):
            space.execute("(1.0 / 0.0).to_i")
        with self.raises(space, "FloatDomainError", "-Infinity"):
            space.execute("(-1.0 / 0.0).to_i")

    def test_lt(self, space):
        assert space.execute("return 1.1 < 1.2") is space.w_true
        assert space.execute("return 1.2 < 0") is space.w_false

    def test_lte(self, space):
        assert space.execute("return 1.1 <= 2") is space.w_true
        assert space.execute("return 1.0 <= 1") is space.w_true
        assert space.execute("return 1.1 <= 1.1") is space.w_true
        assert space.execute("return 1.1 <= 0.9") is space.w_false
        assert space.execute("return 1.0 <= '1.1'") is space.w_true
        with self.raises(space, "ArgumentError", "comparison of Float with String failed"):
            space.execute("1.0 <= 'a'")

    def test_gt(self, space):
        assert space.execute("return 1.1 > 1.2") is space.w_false
        assert space.execute("return 1.2 > 0") is space.w_true

    def test_gte(self, space):
        assert space.execute("return 1.1 >= 2") is space.w_false
        assert space.execute("return 1.0 >= 1") is space.w_true
        assert space.execute("return 1.1 >= 1.1") is space.w_true
        assert space.execute("return 1.1 >= 0.9") is space.w_true
        assert space.execute("return 1.0 >= '1.1'") is space.w_false
        with self.raises(space, "ArgumentError", "comparison of Float with String failed"):
            space.execute("1.0 >= 'a'")

    def test_abs(self, space):
        w_res = space.execute("return -123.534.abs")
        assert space.float_w(w_res) == 123.534

    def test_zero_division_nan(self, space):
        w_res = space.execute("return 0.0 / 0.0")
        assert math.isnan(self.unwrap(space, w_res))

    def test_zero_division_inf(self, space):
        w_res = space.execute("return 1.0 / 0.0")
        assert self.unwrap(space, w_res) == float('inf')
        w_res = space.execute("return -1.0 / 0.0")
        assert self.unwrap(space, w_res) == -float('inf')

    def test_pow(self, space):
        w_res = space.execute("return 1.0 ** 2")
        assert self.unwrap(space, w_res) == 1.0
        w_res = space.execute("return 2.0 ** 2")
        assert self.unwrap(space, w_res) == 4.0
        w_res = space.execute("return 2.0 ** 0")
        assert self.unwrap(space, w_res) == 1.0
        w_res = space.execute("return 4.0 ** 4.0")
        assert self.unwrap(space, w_res) == 256.0
        w_res = space.execute("return 0.0 ** (-1.0)")
        assert self.unwrap(space, w_res) == float('inf')
        w_res = space.execute("return (-2.0) ** 2")
        assert self.unwrap(space, w_res) == 4
        w_res = space.execute("return (-2.0) ** 3")
        assert self.unwrap(space, w_res) == -8
        w_res = space.execute("return (-2.0) ** -2")
        assert self.unwrap(space, w_res) == 0.25
        w_res = space.execute("return (-2.0) ** -3")
        assert self.unwrap(space, w_res) == -0.125
        with self.raises(space, "TypeError", "String can't be coerced into Bignum"):
            space.execute("18446744073709551628 ** 'hallo'")

    def test_pow_with_nan(self, space):
        w_res = space.execute("return (0.0 / 0.0) ** 1")
        assert math.isnan(self.unwrap(space, w_res))
        w_res = space.execute("return 1.0 ** (0.0 / 0.0)")
        assert self.unwrap(space, w_res) == 1.0
        w_res = space.execute("return 1.0 ** (0.0 / 0.0)")
        assert self.unwrap(space, w_res) == 1.0

    def test_pow_with_infinity(self, space):
        w_res = space.execute("return (1.0 / 0.0) ** 10")
        assert self.unwrap(space, w_res) == float('inf')
        w_res = space.execute("return (-1.0 / 0.0) ** 10")
        assert self.unwrap(space, w_res) == float('inf')
        w_res = space.execute("return (-1.0 / 0.0) ** 9")
        assert self.unwrap(space, w_res) == -float('inf')
        w_res = space.execute("return (-1.0 / 0.0) ** -10")
        assert self.unwrap(space, w_res) == 0.0
        w_res = space.execute("return (-1.0 / 0.0) ** -9")
        assert self.unwrap(space, w_res) == -0.0
        w_res = space.execute("return 1.0 ** (1.0 / 0.0)")
        assert self.unwrap(space, w_res) == 1.0
        w_res = space.execute("return (-1.0) ** (1.0 / 0.0)")
        assert self.unwrap(space, w_res) == -1.0
        w_res = space.execute("return 1.1 ** (1.0 / 0.0)")
        assert self.unwrap(space, w_res) == float('inf')
        w_res = space.execute("return (-1.1) ** (1.0 / 0.0)")
        assert self.unwrap(space, w_res) == float('inf')
        w_res = space.execute("return (-0.1) ** (1.0 / 0.0)")
        assert self.unwrap(space, w_res) == -0.0
        w_res = space.execute("return 0.1 ** (1.0 / 0.0)")
        assert self.unwrap(space, w_res) == 0.0
        w_res = space.execute("return 0.1 ** (-1.0 / 0.0)")
        assert self.unwrap(space, w_res) == float('inf')
        w_res = space.execute("return (-0.1) ** (-1.0 / 0.0)")
        assert self.unwrap(space, w_res) == float('inf')
        w_res = space.execute("return (-2) ** (-1.0 / 0.0)")
        assert self.unwrap(space, w_res) == 0.0
        w_res = space.execute("return 2 ** (-1.0 / 0.0)")
        assert self.unwrap(space, w_res) == 0.0

        w_res = space.execute("return 1 <=> 2")
        assert space.int_w(w_res) == -1

    def test_comparator_eq(self, space):
        w_res = space.execute("return 1.0 <=> 1.0")
        assert space.int_w(w_res) == 0

    def test_comparator_gt(self, space):
        w_res = space.execute("return 2.0 <=> 1.0")
        assert space.int_w(w_res) == 1

    def test_comparator_int(self, space):
        w_res = space.execute("return 1.1 <=> 1")
        assert space.int_w(w_res) == 1

    def test_comparator_other_type(self, space):
        w_res = space.execute("return 1.0 <=> '1'")
        assert w_res is space.w_nil

    def test_infinite(self, space):
        w_res = space.execute("return 1.0.infinite?")
        assert w_res is space.w_nil
        w_res = space.execute("return Float::INFINITY.infinite?")
        assert space.int_w(w_res) == 1
        w_res = space.execute("return (-Float::INFINITY).infinite?")
        assert space.int_w(w_res) == -1

    def test_nan(self, space):
        w_res = space.execute("return 1.0.nan?")
        assert w_res is space.w_false
        w_res = space.execute("return Float::NAN.nan?")
        assert w_res is space.w_true

########NEW FILE########
__FILENAME__ = test_hashobject
from ..base import BaseTopazTest


class TestHashObject(BaseTopazTest):
    def test_name(self, space):
        space.execute("Hash")

    def test_create(self, space):
        space.execute("{2 => 3, 4 => 5}")

    def test_subscript_create(self, space):
        w_res = space.execute("return Hash[].length")
        assert space.int_w(w_res) == 0

    def test_subscript_create_hash(self, space):
        w_res = space.execute("return Hash[{2 => 3}][2]")
        assert space.int_w(w_res) == 3

    def test_default_value(self, space):
        w_res = space.execute("""
        x = Hash.new 5
        return x[2]
        """)
        assert space.int_w(w_res) == 5
        w_res = space.execute("""
        x = Hash.new 5
        x[2] = 12
        return x[2]
        """)
        assert space.int_w(w_res) == 12
        w_res = space.execute("return Hash.new(2).default")
        assert space.int_w(w_res) == 2

        w_res = space.execute("""
        class Foo < Hash
          def default key
            key * 2
          end
        end

        return Foo.new[6]
        """)
        assert space.int_w(w_res) == 12

    def test_default_proc(self, space):
        w_res = space.execute("""
        x = Hash.new { |h, k| h[k + 2] = k }
        return [x[2], x[4]]
        """)
        assert self.unwrap(space, w_res) == [2, 2]

    def test_new(self, space):
        w_res = space.execute("return Hash.new.keys")
        assert self.unwrap(space, w_res) == []

    def test_lookup(self, space):
        w_res = space.execute("""
        x = {2 => 3}
        return x[2]
        """)
        assert self.unwrap(space, w_res) == 3

    def test_lookup_non_existing(self, space):
        w_res = space.execute("""
        x = {}
        return x[2]
        """)
        assert w_res is space.w_nil

    def test_clear(self, space):
        w_res = space.execute("""
        x = {2 => 3}
        x.clear
        return x.keys
        """)
        assert self.unwrap(space, w_res) == []

    def test_lookup_eql(self, space):
        w_res = space.execute("return {1 => 2}[1.0]")
        assert w_res is space.w_nil

    def test_fetch_existing(self, space):
        w_res = space.execute("return {'a' => 1}.fetch('a')")
        assert self.unwrap(space, w_res) == 1

    def test_fetch_non_existing_with_value(self, space):
        w_res = space.execute("return {}.fetch('a', 1)")
        assert self.unwrap(space, w_res) == 1

    def test_fetch_non_existing_with_block(self, space):
        w_res = space.execute("return {}.fetch('a') { 1 }")
        assert self.unwrap(space, w_res) == 1

    def test_fetch_non_existing_with_no_value_and_no_block(self, space):
        with self.raises(space, "KeyError"):
            space.execute("return {}.fetch('a')")

    def test_fetch_no_args(self, space):
        with self.raises(space, "ArgumentError"):
            space.execute("{}.fetch()")

    def test_delete(self, space):
        w_res = space.execute("""
        x = {2 => 3, 4 => 5}
        return [x.delete(2), x.keys, x.delete(123)]
        """)
        assert self.unwrap(space, w_res) == [3, [4], None]

    def test_delete_with_block(self, space):
        w_res = space.execute("return {}.delete(3) { |a| a }")
        assert space.int_w(w_res) == 3

    def test_replace(self, space):
        w_res = space.execute("return {}.replace({'a' => 1}).keys")
        assert self.unwrap(space, w_res) == ['a']

    def test_keys(self, space):
        w_res = space.execute("""
        x = {2 => 3, "four" => 5, 1 => 3, '1' => 'a'}
        return x.keys
        """)
        assert self.unwrap(space, w_res) == [2, "four", 1, "1"]

    def test_values(self, space):
        w_res = space.execute("""
        x = {2 => 3, "four" => 5, 1 => 3, '1' => 'a'}
        return x.values
        """)
        assert self.unwrap(space, w_res) == [3, 5, 3, "a"]

    def test_each_key(self, space):
        w_res = space.execute("""
        x = {2 => 3, "four" => 5, 3 => 2}
        result = []
        x.each_key do |k|
          result << k
        end
        return result
        """)
        assert self.unwrap(space, w_res) == [2, "four", 3]

    def test_each(self, space):
        w_res = space.execute("""
        x = {2 => 3, "four" => 5, 3 => 2}
        result = []
        x.each do |k, v|
          result << [k, v]
        end
        return result
        """)
        assert self.unwrap(space, w_res) == [[2, 3], ["four", 5], [3, 2]]
        w_res = space.execute("""
        result = []
        {2 => 3}.each_pair do |k, v|
          result << [k, v]
        end
        return result
        """)
        assert self.unwrap(space, w_res) == [[2, 3]]

    def test_includep(self, space):
        w_res = space.execute("""
        h = { "a" => 100, "b" => 200 }
        return h.include?("a"), h.include?("z"), h.key?("a"), h.key?("z"), h.has_key?("a"), h.has_key?("z"), h.member?("a"), h.member?("z")
        """)
        assert self.unwrap(space, w_res) == [True, False, True, False, True, False, True, False]

    def test_size(self, space):
        w_res = space.execute("return {}.size")
        assert space.int_w(w_res) == 0
        w_res = space.execute("return {:a => 2}.size")
        assert space.int_w(w_res) == 1

    def test_emptyp(self, space):
        w_res = space.execute("return {}.empty?")
        assert w_res is space.w_true
        w_res = space.execute("return {1 => 2}.empty?")
        assert w_res is space.w_false

    def test_equal(self, space):
        w_res = space.execute("return {} == nil")
        assert w_res is space.w_false
        w_res = space.execute("return {1 => 2, 2 => 3} == {2 => 3, 1 => 2}")
        assert w_res is space.w_true
        w_res = space.execute("return {} == {}")
        assert w_res is space.w_true
        w_res = space.execute("return {} == {1 => 2}")
        assert w_res is space.w_false
        w_res = space.execute("""
        h = {}
        return h == h
        """)
        assert w_res is space.w_true

    def test_shift(self, space):
        w_res = space.execute("return {}.shift")
        assert w_res is space.w_nil
        w_res = space.execute("return {3 => 4}.shift")
        assert self.unwrap(space, w_res) == [3, 4]

    def test_dup(self, space):
        w_res = space.execute("return {2 => 4}.dup.length")
        assert space.int_w(w_res) == 1

########NEW FILE########
__FILENAME__ = test_integerobject
class TestIntegerObject(object):
    def test_name(self, space):
        space.execute("Integer")

########NEW FILE########
__FILENAME__ = test_intobject
import math
import sys

from rpython.rlib.rarithmetic import LONG_BIT
from rpython.rlib.rbigint import rbigint

from ..base import BaseTopazTest


class TestFixnumObject(BaseTopazTest):
    def test_addition(self, space):
        w_res = space.execute("return 1 + 2")
        assert space.int_w(w_res) == 3

        w_res = space.execute("return 1 + 2.5")
        assert space.float_w(w_res) == 3.5

    def test_addition_ovf(self, space):
        w_res = space.execute("return (2 << (0.size * 8 - 3)) + (2 << (0.size * 8 - 3)) + (2 << (0.size * 8 - 3))")
        assert space.bigint_w(w_res) == rbigint.fromlong((2 << (LONG_BIT - 3)) * 3)

    def test_addition_bigint(self, space):
        w_res = space.execute("return 2 + %d" % (sys.maxint + 1))
        assert self.unwrap(space, w_res) == rbigint.fromlong(sys.maxint + 3)

    def test_multiplication(self, space):
        w_res = space.execute("return 2 * 3")
        assert space.int_w(w_res) == 6

    def test_multiplication_ovf(self, space):
        w_res = space.execute("return (2 << (0.size * 8 - 3)) * (2 << (0.size * 8 - 3))")
        assert space.bigint_w(w_res) == rbigint.fromlong((2 << (LONG_BIT - 3)) ** 2)

    def test_multiplication_bigint(self, space):
        w_res = space.execute("return 1 * %d" % (sys.maxint + 1))
        assert self.unwrap(space, w_res) == rbigint.fromlong(sys.maxint + 1)

    def test_subtraction(self, space):
        w_res = space.execute("return 2 - 3")
        assert space.int_w(w_res) == -1

        w_res = space.execute("return 2 - 3.5")
        assert space.float_w(w_res) == -1.5

    def test_subtraction_ovf(self, space):
        w_res = space.execute("return 0 - (2 << (0.size * 8 - 3)) - (2 << (0.size * 8 - 3)) - (2 << (0.size * 8 - 3))")
        assert space.bigint_w(w_res) == rbigint.fromlong((2 << (LONG_BIT - 3)) * -3)

    def test_substraction_bigint(self, space):
        w_res = space.execute("return 1 - %d" % (sys.maxint + 1))
        assert self.unwrap(space, w_res) == rbigint.fromlong(1 - sys.maxint - 1)

    def test_division(self, space):
        w_res = space.execute("return 3 / 5")
        assert space.int_w(w_res) == 0
        w_res = space.execute("return 3 / 5.0")
        assert space.float_w(w_res) == 0.6
        w_res = space.execute("return 3 / (0.0 / 0.0)")
        assert math.isnan(space.float_w(w_res))
        w_res = space.execute("return 3 / (1.0 / 0.0)")
        assert space.float_w(w_res) == 0.0
        w_res = space.execute("return 3 / (1.0 / -0.0)")
        assert space.float_w(w_res) == -0.0

    def test_div(self, space):
        w_res = space.execute("return 3.div(5)")
        assert space.int_w(w_res) == 0
        w_res = space.execute("return 3.div(5.0)")
        assert space.int_w(w_res) == 0
        with self.raises(space, "ZeroDivisionError", "divided by 0"):
            space.execute("return 3.div(0)")
        with self.raises(space, "FloatDomainError", "NaN"):
            space.execute("return 3.div(0.0 / 0.0)")

    def test_modulo(self, space):
        w_res = space.execute("return 5 % 2")
        assert space.int_w(w_res) == 1

    def test_left_shift(self, space):
        w_res = space.execute("return 3 << 4")
        assert space.int_w(w_res) == 48
        w_res = space.execute("return 48 << -4")
        assert space.int_w(w_res) == 3

    def test_left_shift_ovf(self, space):
        w_res = space.execute("return 4 << 90")
        assert space.bigint_w(w_res) == rbigint.fromlong(4951760157141521099596496896)
        w_res = space.execute("return %d << 2" % sys.maxint)
        assert self.unwrap(space, w_res) == rbigint.fromlong(sys.maxint << 2)
        w_res = space.execute("return 4 << -90")
        assert space.int_w(w_res) == 0

    def test_and(self, space):
        w_res = space.execute("return 12 & 123")
        assert space.int_w(w_res) == 8

    def test_xor(self, space):
        w_res = space.execute("return 12 ^ 15")
        assert space.int_w(w_res) == 3

    def test_or(self, space):
        w_res = space.execute("return 16 | 7")
        assert space.int_w(w_res) == 23
        w_res = space.execute("return 7 | 3")
        assert space.int_w(w_res) == 7

    def test_equal(self, space):
        w_res = space.execute("return 1 == 1")
        assert w_res is space.w_true
        w_res = space.execute("""
        class A
          def ==(o); 'hi'; end
        end
        return 1 == A.new
        """)
        assert space.str_w(w_res) == 'hi'
        w_res = space.execute("return 1 == '1'")
        assert w_res is space.w_false

    def test_not_equal(self, space):
        w_res = space.execute("return 1 != 1")
        assert w_res is space.w_false
        w_res = space.execute("return 1 != '1'")
        assert w_res is space.w_true
        w_res = space.execute("""
        class A
          def ==(o); 'hi'; end
        end
        return 1 != A.new
        """)
        assert w_res is space.w_false

    def test_less(self, space):
        w_res = space.execute("return 1 < 2")
        assert w_res is space.w_true
        w_res = space.execute("return 1 < 1.2")
        assert w_res is space.w_true

    def test_less_equal(self, space):
        assert space.execute("return 1 <= 2") is space.w_true
        assert space.execute("return 1 <= 1") is space.w_true
        assert space.execute("return 1 <= 1.1") is space.w_true
        assert space.execute("return 1 <= 0.9") is space.w_false
        assert space.execute("return 1 <= '1.1'") is space.w_true
        with self.raises(space, "ArgumentError", "comparison of Fixnum with String failed"):
            space.execute("1 <= 'a'")

    def test_greater(self, space):
        w_res = space.execute("return 1 > 2")
        assert w_res is space.w_false

    def test_greater_equal(self, space):
        w_res = space.execute("return 5 >= 4")
        assert w_res is space.w_true

    def test_times(self, space):
        w_res = space.execute("""
        res = []
        3.times do |x|
          res << x
        end
        return res
        """)
        assert self.unwrap(space, w_res) == [0, 1, 2]

    def test_upto(self, space):
        w_res = space.execute("""
        res = []
        3.upto(6) do |x|
          res << x
        end
        return res
        """)
        assert self.unwrap(space, w_res) == [3, 4, 5, 6]

    def test_comparator_lt(self, space):
        w_res = space.execute("return 1 <=> 2")
        assert space.int_w(w_res) == -1

    def test_comparator_eq(self, space):
        w_res = space.execute("return 1 <=> 1")
        assert space.int_w(w_res) == 0

    def test_comparator_gt(self, space):
        w_res = space.execute("return 2 <=> 1")
        assert space.int_w(w_res) == 1

    def test_comparator_float(self, space):
        w_res = space.execute("return 1 <=> 1.1")
        assert space.int_w(w_res) == -1

    def test_comparator_other_type(self, space):
        w_res = space.execute("return 1 <=> '1'")
        assert w_res is space.w_nil

    def test_eqlp(self, space):
        w_res = space.execute("return 1.eql? 1.0")
        assert w_res is space.w_false
        w_res = space.execute("return 1.eql? 1")
        assert w_res is space.w_true

    def test_to_i(self, space):
        w_res = space.execute("return [1.to_i, 1.to_int]")
        assert self.unwrap(space, w_res) == [1, 1]

    def test_nonzero(self, space):
        w_res = space.execute("return [2.nonzero?, 0.nonzero?]")
        assert self.unwrap(space, w_res) == [2, None]

    def test_object_id(self, space):
        w_res = space.execute("return 2.object_id, 2.object_id")
        id_1, id_2 = self.unwrap(space, w_res)
        assert id_1 == id_2

    def test___id__(self, space):
        w_res = space.execute("return 2.__id__, 2.__id__")
        id_1, id_2 = self.unwrap(space, w_res)
        assert id_1 == id_2

    def test_ivar(self, space):
        w_res = space.execute("""
        class Fixnum
          def set; @foo = -1; end
          def get; @foo; end
        end
        2.set
        return 2.get, 2.get, 3.get
        """)
        [x, y, z] = self.unwrap(space, w_res)
        assert x == y == -1
        assert z is None

    def test_succ(self, space):
        w_res = space.execute("return -1.succ")
        assert self.unwrap(space, w_res) == 0

        w_res = space.execute("return 7.succ")
        assert self.unwrap(space, w_res) == 8

    def test_zero(self, space):
        w_res = space.execute("return [0.zero?, 2.zero?]")
        assert self.unwrap(space, w_res) == [True, False]

    def test_even(self, space):
        w_res = space.execute("return [1.even?, -2.even?]")
        assert self.unwrap(space, w_res) == [False, True]

    def test_odd(self, space):
        w_res = space.execute("return [2.odd?, -1.odd?]")
        assert self.unwrap(space, w_res) == [False, True]

    def test_size(self, space):
        if sys.maxint == 2 ** 63 - 1:
            expected = 8
        elif sys.maxint == 2 ** 31 - 1:
            expected = 4
        else:
            raise NotImplementedError(sys.maxint)
        w_res = space.execute("return 1.size")
        assert space.int_w(w_res) == expected

    def test_chr(self, space):
        w_res = space.execute("return 65.chr")
        assert self.unwrap(space, w_res) == "A"
        with self.raises(space, "RangeError", "256 out of char range"):
            space.execute("256.chr")
        with self.raises(space, "RangeError", "-1 out of char range"):
            space.execute("-1.chr")

    def test_pow(self, space):
        w_res = space.execute("return 2 ** 6")
        assert self.unwrap(space, w_res) == 64
        w_res = space.execute("return 2 ** -6")
        assert self.unwrap(space, w_res) == 1.0 / 64
        w_res = space.execute("return 4 ** 0.5")
        assert self.unwrap(space, w_res) == 2.0
        w_res = space.execute("return 4 ** -0.5")
        assert self.unwrap(space, w_res) == 0.5
        with self.raises(space, "TypeError", "String can't be coerced into Fixnum"):
            space.execute("2 ** 'hallo'")

    def test_step(self, space):
        w_res = space.execute("""
        res = []
        1.step(4) { |i| res << i }
        return res
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3, 4]
        w_res = space.execute("""
        res = []
        1.step(4.1) { |i| res << i }
        return res
        """)
        assert self.unwrap(space, w_res) == [1.0, 2.0, 3.0, 4.0]
        w_res = space.execute("""
        res = []
        1.step(10, 2) { |i| res << i }
        return res
        """)
        assert self.unwrap(space, w_res) == [1, 3, 5, 7, 9]
        w_res = space.execute("""
        res = []
        1.step(2, 0.6) { |i| res << i }
        return res
        """)
        assert self.unwrap(space, w_res) == [1.0, 1.6]

########NEW FILE########
__FILENAME__ = test_ioobject
import os

import pytest

from topaz.objects.ioobject import W_IOObject

from ..base import BaseTopazTest


class TestIO(BaseTopazTest):
    def test_constants(self, space):
        assert space.int_w(space.execute("return IO::SEEK_CUR")) == os.SEEK_CUR
        assert space.int_w(space.execute("return IO::SEEK_END")) == os.SEEK_END
        assert space.int_w(space.execute("return IO::SEEK_SET")) == os.SEEK_SET

    def test_new_from_file(self, space, tmpdir):
        contents = "foo\nbar\nbaz\n"
        f = tmpdir.join("file.txt")
        f.write(contents)

        w_res = space.execute("""
        f = File.new('%s')
        io = IO.new(f)
        return io.read
        """ % f)
        assert space.str_w(w_res) == contents

    def test_new_from_fd(self, space):
        w_res = space.execute("return IO.new(1)")
        assert isinstance(w_res, W_IOObject)

    def test_write(self, space, capfd, tmpdir):
        content = "foo\n"
        space.execute('return IO.new(1, "w").write("%s")' % content)
        out, err = capfd.readouterr()
        assert out == content
        content = "foo\n"

        f = tmpdir.join("file.txt")
        with self.raises(space, "IOError", "closed stream"):
            space.execute("""
            io = File.new('%s', "w")
            io.close
            io.write("")
            """ % f)

    def test_push(self, space, capfd, tmpdir):
        space.execute('return IO.new(1, "w") << "hello" << "world"')
        out, err = capfd.readouterr()
        assert out == "helloworld"

        f = tmpdir.join("file.txt")
        with self.raises(space, "IOError", "closed stream"):
            space.execute("""
            io = File.new('%s', "w")
            io.close
            io << ""
            """ % f)

    def test_read(self, space, tmpdir):
        contents = "foo\nbar\nbaz\n"
        f = tmpdir.join("file.txt")
        f.write(contents)

        w_res = space.execute("return File.new('%s').read" % f)
        assert space.str_w(w_res) == contents

        w_res = space.execute("return File.new('%s').read(4)" % f)
        assert space.str_w(w_res) == contents[:4]

        w_res = space.execute("""
        a = 'hello world'
        File.new('%s').read(10, a)
        return a
        """ % f)
        assert space.str_w(w_res) == contents[:10]

        with self.raises(space, "ArgumentError"):
            space.execute("File.new('%s').read(-1)" % f)

        with self.raises(space, "IOError", "closed stream"):
            space.execute("""
            io = File.new('%s')
            io.close
            io.read
            """ % f)

    def test_simple_print(self, space, capfd, tmpdir):
        space.execute('IO.new(1, "w").print("foo")')
        out, err = capfd.readouterr()
        assert out == "foo"

        f = tmpdir.join("file.txt")
        with self.raises(space, "IOError", "closed stream"):
            space.execute("""
            io = File.new('%s', "w")
            io.close
            io.print ""
            """ % f)

    def test_multi_print(self, space, capfd):
        space.execute('IO.new(1, "w").print("This", "is", 100, "percent")')
        out, err = capfd.readouterr()
        assert out == "Thisis100percent"

    def test_print_globals(self, space, capfd):
        space.globals.set(space, "$,", space.newstr_fromstr(":"))
        space.globals.set(space, "$\\", space.newstr_fromstr("\n"))
        space.execute('IO.new(1, "w").print("foo", "bar", "baz")')
        space.globals.set(space, "$_", space.newstr_fromstr('lastprint'))
        space.execute('IO.new(1, "w").print')
        out, err = capfd.readouterr()
        assert out == "foo:bar:baz\nlastprint\n"

    def test_non_string_print_globals(self, space, capfd):
        space.globals.set(space, "$,", space.w_nil)
        space.globals.set(space, "$\\", space.w_nil)
        space.execute('IO.new(1, "w").print("foo", "bar", "baz")')
        space.globals.set(space, "$_", space.w_nil)
        space.execute('IO.new(1, "w").print')
        out, err = capfd.readouterr()
        assert out == "foobarbaz"

    def test_puts(self, space, capfd, tmpdir):
        space.execute("IO.new(1, 'w').puts('This', 'is\n', 100, 'percent')")
        out, err = capfd.readouterr()
        assert out == "This\nis\n100\npercent\n"

        f = tmpdir.join("file.txt")
        with self.raises(space, "IOError", "closed stream"):
            space.execute("""
            io = File.new('%s', "w")
            io.close
            io.puts ""
            """ % f)

    def test_flush(self, space, capfd, tmpdir):
        space.execute("IO.new(1, 'w').flush.puts('String')")
        out, err = capfd.readouterr()
        assert out == "String\n"

        f = tmpdir.join("file.txt")
        with self.raises(space, "IOError", "closed stream"):
            space.execute("""
            io = File.new('%s', "w")
            io.close
            io.flush
            """ % f)

    def test_globals(self, space, capfd):
        w_res = space.execute("""
        STDOUT.puts("STDOUT")
        $stdout.puts("$stdout")
        $>.puts("$>")
        STDERR.puts("STDERR")
        $stderr.puts("$stderr")
        return STDIN.read, $stdin.read
        """)
        out, err = capfd.readouterr()
        assert out == "STDOUT\n$stdout\n$>\n"
        assert err == "STDERR\n$stderr\n"
        assert self.unwrap(space, w_res) == [None, None]

    def test_rewind(self, space, tmpdir):
        f = tmpdir.join("file.txt")
        f.write("content")
        w_res = space.execute("""
        f = File.new('%s', "r+")
        c = f.read
        f.rewind
        return c, f.read
        """ % f)
        assert self.unwrap(space, w_res) == ["content", "content"]
        with self.raises(space, "IOError", "closed stream"):
            space.execute("""
            io = File.new('%s')
            io.close
            io.rewind
            """ % f)

    def test_seek(self, space, tmpdir):
        f = tmpdir.join("file.txt")
        f.write("content")
        w_res = space.execute("""
        res = []
        f = File.new('%s', "r+")
        f.seek(2, IO::SEEK_SET)
        res << f.read
        f.seek(2)
        res << f.read
        f.seek(-3, IO::SEEK_CUR)
        res << f.read
        f.seek(-2, IO::SEEK_END)
        res << f.read
        return res
        """ % f)
        assert self.unwrap(space, w_res) == [
            "ntent", "ntent", "ent", "nt"
        ]
        with self.raises(space, "IOError", "closed stream"):
            space.execute("""
            io = File.new('%s')
            io.close
            io.seek 2
            """ % f)

    def test_pos(self, space, tmpdir):
        f = tmpdir.join("file.txt")
        f.write("words in here")
        w_res = space.execute("""
        f = File.new('%s', "r+")
        f.seek(2, IO::SEEK_SET)
        pos0 = f.pos
        f.seek(8, IO::SEEK_SET)
        return pos0, f.pos
        """ % f)
        assert self.unwrap(space, w_res) == [2, 8]

    def test_pipe(self, space):
        w_res = space.execute("""
        return IO.pipe
        """)
        w_read, w_write = space.listview(w_res)
        assert isinstance(w_read, W_IOObject)
        assert isinstance(w_read, W_IOObject)
        w_res = space.execute("""
        r, w, r_c, w_c = IO.pipe do |r, w|
          r.close
          [r, w, r.closed?, w.closed?]
        end
        return r.closed?, w.closed?, r_c, w_c
        """)
        assert self.unwrap(space, w_res) == [True, True, True, False]

    def test_singleton_readlines(self, space, tmpdir):
        tmpdir.join("x.txt").write("abc")
        w_res = space.execute("return IO.readlines('%s')" % tmpdir.join("x.txt"))
        assert self.unwrap(space, w_res) == ["abc"]

    def test_to_io(self, space, tmpdir):
        f = tmpdir.join("file.txt")
        f.write("")
        w_res = space.execute("""
        f = File.new '%s'
        return f.eql? f.to_io
        """ % f)
        assert w_res == space.w_true

    def test_to_i(self, space, tmpdir):
        f1 = tmpdir.join("file1.txt")
        f1.write("")
        f2 = tmpdir.join("file2.txt")
        f2.write("")

        w_res = space.execute("""
        f1 = File.new '%s'
        f2 = File.new '%s'
        return f1.to_i, f2.to_i
        """ % (f1, f2))
        fds = self.unwrap(space, w_res)
        assert fds[0] != fds[1]

        w_res = space.execute("return STDIN.to_i")
        assert space.int_w(w_res) == 0
        w_res = space.execute("return STDOUT.to_i")
        assert space.int_w(w_res) == 1
        w_res = space.execute("return STDERR.to_i")
        assert space.int_w(w_res) == 2

    def test_reopen_stdout_in_closed_io(self, space, tmpdir):
        f = tmpdir.join("file.txt")
        f.write('')
        with self.raises(space, "IOError", "closed stream"):
            space.execute("""
            f = File.new('%s')
            f.close
            f.reopen($stdout)
            """ % f)

    def test_reopen_closed_io(self, space, tmpdir):
        f = tmpdir.join("file.txt")
        f.write('')
        with self.raises(space, "IOError", "closed stream"):
            space.execute("""
            f = File.new('%s')
            f.close
            $stderr.reopen(f)
            """ % f)

    def test_reopen(self, space, tmpdir):
        content = "This is line one"
        f = tmpdir.join("testfile")
        f.write(content + "\n")
        w_res = space.execute("""
        res = []
        class A
          def to_io
            File.new("%s")
          end
        end
        f1 = A.new
        f2 = File.new("%s")
        res << f2.readlines[0]
        f2.reopen(f1)
        res << f2.readlines[0]
        res << f2.readlines[0]
        return res
        """ % (f, f))
        assert self.unwrap(space, w_res) == [content, content, ""]

    def test_reopen_path(self, space, tmpdir):
        content = "This is line one"
        f = tmpdir.join("testfile")
        f.write(content + "\n")
        w_res = space.execute("""
        res = []
        f = File.new("%s")
        res << f.readlines[0]
        f.reopen("%s")
        res << f.readlines[0]
        res << f.readlines[0]
        return res
        """ % (f, f))
        assert self.unwrap(space, w_res) == [content, content, ""]

    def test_reopen_with_invalid_arg(self, space):
        with self.raises(space, "TypeError", "can't convert Fixnum into String"):
            space.execute("$stderr.reopen(12)")

    def test_popen_read(self, space):
        w_res = space.execute("""
        io = IO.popen("echo foo", "r")
        return io.pid.is_a?(Fixnum), io.read
        """)
        assert self.unwrap(space, w_res) == [True, "foo\n"]

    @pytest.mark.xfail
    def test_popen_write(self, space, capfd):
        space.execute("""
        IO.popen("cat", "w") do |io|
          io.write 'foo\n'
        end
        """)
        out, err = capfd.readouterr()
        assert out == "foo\n"

########NEW FILE########
__FILENAME__ = test_methodobject
from topaz.objects.methodobject import W_MethodObject, W_UnboundMethodObject

from ..base import BaseTopazTest


class TestMethodObject(BaseTopazTest):
    def test_name(self, space):
        space.execute("Method")

    def test_to_s(self, space):
        w_res = space.execute("return 'test'.method(:to_s).to_s")
        assert space.str_w(w_res) == "#<Method: String#to_s>"

    def test_allocate(self, space):
        with self.raises(space, "TypeError", "allocator undefined for Method"):
            space.execute("Method.allocate")

    def test_owner(self, space):
        w_res = space.execute("return 'test'.method(:to_s).owner")
        assert w_res == space.w_string

    def test_unbind(self, space):
        w_res = space.execute("return 'test'.method(:to_s).unbind.class")
        assert w_res == space.getclassfor(W_UnboundMethodObject)

    def test_receiver(self, space):
        w_res = space.execute("""
        a = 'test'
        return a.method(:to_s).receiver == a
        """)
        assert self.unwrap(space, w_res) is True

    def test_eql(self, space):
        w_res = space.execute("return 'test'.method(:to_s) == 'test'.method(:to_s)")
        assert self.unwrap(space, w_res) is False
        w_res = space.execute("""
        a = 'test'
        return a.method(:to_s) == a.method(:to_s)
        """)
        assert self.unwrap(space, w_res) is True
        w_res = space.execute("""
        a = 'test'
        return a.method(:to_s) == a.method(:==)
        """)
        assert self.unwrap(space, w_res) is False

    def test_call(self, space):
        w_res = space.execute("""
        return 'test'.method(:to_s).call
        """)
        assert self.unwrap(space, w_res) == "test"

        w_res = space.execute("""
        return 'test'.method(:to_s).unbind.bind('hello').call
        """)
        assert self.unwrap(space, w_res) == "hello"

        with self.raises(space, "TypeError", "bind argument must be an instance of String"):
            w_res = space.execute("""
            return 'test'.method(:to_s).unbind.bind(1)
            """)


class TestUnboundObject(BaseTopazTest):
    def test_name(self, space):
        space.execute("UnboundMethod")

    def test_to_s(self, space):
        w_res = space.execute("return 'test'.method(:to_s).unbind.to_s")
        assert space.str_w(w_res) == "#<UnboundMethod: String#to_s>"

    def test_allocate(self, space):
        with self.raises(space, "TypeError", "allocator undefined for UnboundMethod"):
            space.execute("return UnboundMethod.allocate")

    def test_owner(self, space):
        w_res = space.execute("return 'test'.method(:to_s).owner")
        assert w_res == space.w_string

    def test_bind(self, space):
        w_res = space.execute("""
        r = 'another'
        m = 'test'.method(:to_s).unbind.bind(r)
        return r == m.receiver, m.class
        """)
        assert self.unwrap(space, w_res) == [True, space.getclassfor(W_MethodObject)]

    def test_eql(self, space):
        w_res = space.execute("return 'test'.method(:to_s).unbind == 'test'.method(:to_s).unbind")
        assert self.unwrap(space, w_res) is True
        w_res = space.execute("return 'test'.method(:to_s).unbind == 'test'.method(:==).unbind")
        assert self.unwrap(space, w_res) is False

########NEW FILE########
__FILENAME__ = test_moduleobject
# coding=utf-8

from ..base import BaseTopazTest

import pytest


class TestModuleObject(BaseTopazTest):
    def test_name(self, space):
        space.execute("Module")

    def test_new(self, space):
        w_res = space.execute("""
        m = Module.new
        m::Const = 4
        return m::Const
        """)
        assert space.int_w(w_res) == 4

    def test_submodule(self, space):
        w_res = space.execute("""
        return Math::DomainError.name
        """)
        assert space.str_w(w_res) == "Math::DomainError"

    def test_generated_submodule(self, space):
        w_res = space.execute("""
        module Foo
          module Bar
            module Baz
            end
          end
        end
        return Foo::Bar::Baz.name
        """)
        assert space.str_w(w_res) == "Foo::Bar::Baz"

    def test_module_function(self, space):
        w_res = space.execute("""
        module Mod
          def f
            3
          end
          def g
            4
          end
          module_function :f, :g
        end
        class X
          include Mod
          def mathf
            f + 2
          end
          def mathg
            g + 2
          end
        end
        return [Mod.f, X.new.mathf, X.new.mathg]
        """)
        assert self.unwrap(space, w_res) == [3, 5, 6]

    def test_alias_method(self, space):
        w_res = space.execute("""
        class X
          def f
            3
          end
          alias_method :g, :f
        end

        return X.new.g
        """)
        assert self.unwrap(space, w_res) == 3

    def test_alias_method_builtin(self, space):
        w_res = space.execute("""
        class Fixnum
          alias_method :comparator, :<=>
          def <=>(*args)
            comparator(*args)
          end
        end

        return 1 <=> 1
        """)
        assert self.unwrap(space, w_res) == 0

    def test_define_method_with_block(self, space):
        w_res = space.execute("""
        class X
          a = 10
          define_method :add do
            self.b + a
          end
          sub = proc { a - self.b }
          define_method :sub, sub
          def b; 5; end
        end
        return X.new.add, X.new.sub
        """)
        assert self.unwrap(space, w_res) == [15, 5]

    def test_define_method_with_method(self, space):
        w_res = space.execute("""
        class X
          def a; 10; end
          define_method :x, instance_method(:a).bind(self.new)
          define_method :y, instance_method(:a)
        end
        return X.new.x, X.new.y
        """)
        assert self.unwrap(space, w_res) == [10, 10]

    def test_singleton_class(self, space):
        w_res = space.execute("""
        class X; end
        return X.singleton_class, X.singleton_class.ancestors, X.singleton_class.class
        """)
        s, s_ancs, s_class = self.unwrap(space, w_res)
        assert s not in s_ancs
        assert s_class == s_ancs[0]

        w_res = space.execute("""
        class X; end
        return X.singleton_class, X.singleton_class.singleton_class
        """)
        s, s_s = self.unwrap(space, w_res)
        assert s.name == "#<Class:X>"
        assert s_s.name == "#<Class:#<Class:X>>"

    def test_instance_variable(self, space):
        w_res = space.execute("""
        class X
          @abc = 3
          def self.m
            @abc
          end
        end

        return X.m
        """)
        assert self.unwrap(space, w_res) == 3

    def test_missing_instance_variable(self, space):
        w_res = space.execute("""
        class X
          def self.m
            @a
          end
        end
        return X.m
        """)
        assert self.unwrap(space, w_res) is None

    def test_module_eval(self, space, capfd):
        w_res = space.execute("""
        class X; end
        X.module_eval('def foo; 1; end')
        return X.new.foo
        """)
        assert space.int_w(w_res) == 1

        w_res = space.execute("""
        class X; end
        X.module_eval { def foo; 1; end }
        return X.new.foo
        """)
        assert space.int_w(w_res) == 1

        w_res = space.execute("""
        class X; end
        X.module_eval('def foo; [__FILE__, __LINE__]; end', 'dummy', 123)
        return X.new.foo
        """)
        assert self.unwrap(space, w_res) == ["dummy", 123]

    def test_module_eval_has_scope_of_its_block_and_the_receiving_module(self, space):
        w_res = space.execute("""
        module A
          Cow = "cow"
        end
        module B
          Horse = "horse"
          A.module_eval { $animals = [Horse, Cow] }
        end
        return $animals
        """)
        assert self.unwrap(space, w_res) == ["horse", "cow"]

    def test_const_definedp(self, space):
        w_res = space.execute("""
        class X; Const = 1; end
        class Y < X; end
        return X.const_defined?("Const"), X.const_defined?("NoConst"),
          X.const_defined?("X"), Y.const_defined?("Const"), Y.const_defined?("Const", false),
          X.const_defined?("Const", false)
        """)
        assert self.unwrap(space, w_res) == [True, False, True, True, False, True]

    def test_const_get(self, space):
        space.execute("""
        class X
          Const = 1
        end
        class Y < X
        end
        """)
        w_res = space.execute("return X.const_get :Const")
        assert space.int_w(w_res) == 1
        w_res = space.execute("return Y.const_get :Const")
        assert space.int_w(w_res) == 1
        with self.raises(space, "NameError", "uninitialized constant Y::Const"):
            space.execute("Y.const_get :Const, false")

    def test_method_definedp(self, space):
        w_res = space.execute("""
        class X; def foo; end; end
        return X.method_defined?("foo"), X.method_defined?("no_method")
        """)
        assert self.unwrap(space, w_res) == [True, False]

    def test_attr_reader(self, space):
        w_res = space.execute("""
        class X
          attr_reader :foo, :bar
          def initialize; @foo = 1; @bar = 2; end
        end
        return X.new.foo, X.new.bar
        """)
        assert self.unwrap(space, w_res) == [1, 2]

    def test_attr_accessor(self, space):
        w_res = space.execute("""
        class X; attr_accessor :foo, :bar; end
        x = X.new
        x.foo = 1
        x.bar = 2
        return x.foo, x.bar
        """)
        assert self.unwrap(space, w_res) == [1, 2]

    def test_attr_writer(self, space):
        w_res = space.execute("""
        class X
          attr_writer :foo, :bar
          def ivars
            return @foo, @bar
          end
        end
        x = X.new
        x.foo = 1
        x.bar = 2
        return x.ivars
        """)
        assert self.unwrap(space, w_res) == [1, 2]

    def test_attr(self, space):
        space.execute("""
        class X
          attr :a, false
          attr :b, true
          attr :c, :d

          def set_a v
            @a = v
          end
        end
        """)
        with self.raises(space, "NoMethodError"):
            space.execute("X.new.a = 3")
        w_res = space.execute("""
        x = X.new
        x.set_a 3
        return x.a
        """)
        assert space.int_w(w_res) == 3

        w_res = space.execute("""
        x = X.new
        x.b = 5
        return x.b
        """)
        assert space.int_w(w_res) == 5

    def test_eqeqeq(self, space):
        w_res = space.execute("""
        r = []
        module M; end
        class A
          include M
        end
        class B < A; end
        class C < B; end
        b = B.new
        r << (A === b)
        r << (B === b)
        r << (C === b)
        r << (M === b)
        return r
        """)
        assert self.unwrap(space, w_res) == [True, True, False, True]

    def test_instance_method(self, space):
        w_res = space.execute("""
        class Interpreter
          def do_a() "there, "; end
          def do_d() "Hello ";  end
          def do_e() "!\n";     end
          def do_v() "Dave";    end
          Dispatcher = {
            "a" => instance_method(:do_a),
            "d" => instance_method(:do_d),
            "e" => instance_method(:do_e),
            "v" => instance_method(:do_v)
          }
          def interpret(instructions)
            instructions.map {|b| Dispatcher[b].bind(self).call }
          end
        end

        interpreter = Interpreter.new
        return interpreter.interpret(%w[d a v e])
        """)
        assert self.unwrap(space, w_res) == ["Hello ", "there, ", "Dave", "!\n"]

    def test_undef_method(self, space):
        space.execute("""
        class A
          def hello
          end
        end
        """)
        space.execute("""
        class A
          undef_method :hello
        end
        """)
        with self.raises(space, "NoMethodError", "undefined method `hello' for A"):
            space.execute("A.new.hello")
        with self.raises(space, "NameError", "undefined method `undefinedmethod' for class `A'"):
            space.execute("""
            class A
              undef_method :undefinedmethod
            end
            """)
        with self.raises(space, "NameError", "undefined method `hello' for class `A'"):
            space.execute("""
            class A
              undef_method :hello
            end
            """)
        space.execute("""
        class A
          undef_method :==
        end
        """)
        with self.raises(space, "NoMethodError", "undefined method `==' for A"):
            space.execute("""
            A.new == 1
            """)

    def test_remove_method(self, space):
        space.execute("""
        class A
          def foo
          end
        end
        """)
        space.execute("A.new.foo")
        space.execute("""
        class A
          remove_method :foo
        end
        """)
        with self.raises(space, "NoMethodError"):
            space.execute("A.new.foo")
        with self.raises(space, "NameError", "method `foo' not defined in A"):
            space.execute("""
            class A
              remove_method :foo
            end
            """)
        with self.raises(space, "NameError", "method `bar' not defined in A"):
            space.execute("""
            class A
              remove_method :bar
            end
            """)

    def test_const_set(self, space):
        w_res = space.execute("""
        m = Module.new
        m.const_set 'ZzŻżŹź', :utf_8_is_legal
        last_const = m.constants.last
        return [last_const, m.const_get(last_const)]
        """)
        assert self.unwrap(space, w_res) == ['ZzŻżŹź', 'utf_8_is_legal']

    def test_to_s(self, space):
        w_res = space.execute("return Kernel.class.to_s")
        assert space.str_w(w_res) == "Module"

    def test_anon_module_to_s(self, space):
        w_res = space.execute("return Module.new.to_s")
        assert space.str_w(w_res).startswith("#<Module:0x")

    @pytest.mark.xfail
    def test_singletonclass_to_s(self, space):
        w_res = space.execute("Module.new.singleton_class.to_s")
        assert space.str_w(w_res).startswith("#<Class:#<Module:0x")

    def test_anon_class_name(self, space):
        w_res = space.execute("return Module.new.name")
        assert w_res is space.w_nil

    def test_definedp(self, space):
        w_res = space.execute("""
        module A
          def self.foo_defined?
            defined?(@foo)
          end
        end
        return A.foo_defined? ? 'yes' : 'no'
        """)
        assert self.unwrap(space, w_res) == 'no'
        w_res = space.execute("""
        module A
          @foo = nil

          def foo_defined?
            defined?(@foo)
          end
        end
        return A.foo_defined? ? 'yes' : 'no'
        """)
        assert self.unwrap(space, w_res) == 'yes'


class TestMethodVisibility(object):
    def test_private(self, space):
        space.execute("""
        class X
          def m
          end
          private :m
        end
        """)

    def test_public(self, space):
        space.execute("""
        class X
          def m
          end
          public :m
        end
        """)

    def test_protected(self, space):
        space.execute("""
        class X
          protected
        end
        """)

    def test_private_class_method(self, space):
        space.execute("""
        class X
          def self.m
          end
          private_class_method :m
        end
        """)

    def test_public_class_method(self, space):
        space.execute("""
        class X
          def self.m
          end
          public_class_method :m
        end
        """)

    def test_private_builtin(self, space):
        space.execute("""
        class X < Array
          public :<<
        end
        """)

########NEW FILE########
__FILENAME__ = test_nilobject
from ..base import BaseTopazTest


class TestNilObject(BaseTopazTest):
    def test_name(self, space):
        space.execute("NilClass")

    def test_to_s(self, space):
        w_res = space.execute("return nil.to_s")
        assert space.str_w(w_res) == ""

    def test_inspect(self, space):
        w_res = space.execute("return nil.inspect")
        assert space.str_w(w_res) == "nil"

    def test_nilp(self, space):
        w_res = space.execute("return nil.nil?")
        assert w_res == space.w_true
        w_res = space.execute("return 1.nil?")
        assert w_res == space.w_false

    def test_to_i(self, space):
        w_res = space.execute("return nil.to_i")
        assert space.int_w(w_res) == 0

    def test_to_f(self, space):
        w_res = space.execute("return nil.to_f")
        assert space.float_w(w_res) == 0.0

    def test_to_a(self, space):
        w_res = space.execute("return nil.to_a")
        assert self.unwrap(space, w_res) == []

    def test_and(self, space):
        w_res = space.execute("return nil & true")
        assert w_res is space.w_false

    def test_or(self, space):
        w_res = space.execute("return nil | 4")
        assert w_res is space.w_true
        w_res = space.execute("return nil | false")
        assert w_res is space.w_false

    def test_xor(self, space):
        w_res = space.execute("return nil ^ 4")
        assert w_res is space.w_true
        w_res = space.execute("return nil ^ false")
        assert w_res is space.w_false

    def test_singleton_class(self, space):
        w_res = space.execute("return nil.singleton_class == NilClass")
        assert w_res is space.w_true

########NEW FILE########
__FILENAME__ = test_numericobject
from ..base import BaseTopazTest


class TestNumericObject(BaseTopazTest):
    def test_to_int(self, space):
        w_res = space.execute("""
        class A < Numeric
          def to_i; 1; end
        end
        return A.new.to_int
        """)
        assert space.int_w(w_res) == 1

    def test_comparator_eq(self, space):
        w_res = space.execute("""
        class A < Numeric; end
        a = A.new
        return a <=> a
        """)
        assert space.int_w(w_res) == 0

    def test_comparator_neq(self, space):
        w_res = space.execute("""
        class A < Numeric; end
        return A.new <=> A.new
        """)
        assert w_res == space.w_nil

    def test_less_equal(self, space):
        w_res = space.execute("""
        class A < Numeric; end
        return A.new <= A.new
        """)
        assert w_res == space.w_false
        w_res = space.execute("""
        class A < Numeric; end
        a = A.new
        return a <= a
        """)
        assert w_res == space.w_true

    def test_coerce(self, space):
        w_res = space.execute("return 1.coerce(1)")
        assert self.unwrap(space, w_res) == [1, 1]
        w_res = space.execute("return 1.1.coerce(1)")
        assert self.unwrap(space, w_res) == [1.0, 1.1]
        w_res = space.execute("return 1.coerce(1.1)")
        assert self.unwrap(space, w_res) == [1.1, 1.0]
        w_res = space.execute("return 1.coerce('2')")
        assert self.unwrap(space, w_res) == [2.0, 1.0]

    def test_abs(self, space):
        w_res = space.execute("return 1.abs, -1.abs")
        assert self.unwrap(space, w_res) == [1, 1]
        w_res = space.execute("return 1.1.abs, -1.1.abs")
        assert self.unwrap(space, w_res) == [1.1, 1.1]

########NEW FILE########
__FILENAME__ = test_objectobject
import struct

from topaz.objects.intobject import W_FixnumObject
from topaz.objects.methodobject import W_MethodObject

from ..base import BaseTopazTest


class TestBaseObject(BaseTopazTest):
    def test_instance_eval(self, space):
        w_res = space.execute("""
        class X; end
        X.instance_eval('def foo; 1; end')
        return X.foo
        """)
        assert space.int_w(w_res) == 1

        w_res = space.execute("""
        class X; end
        X.instance_eval { def foo; 1; end }
        return X.foo
        """)
        assert space.int_w(w_res) == 1

        w_res = space.execute("""
        class X; end
        X.instance_eval('def foo; [__FILE__, __LINE__]; end', 'dummy', 123)
        return X.foo
        """)
        assert self.unwrap(space, w_res) == ["dummy", 123]

    def test_instance_eval_scope(self, space):
        w_res = space.execute("""
        module M
          C = proc {
            class X
            end
            X
          }
        end

        class T
        end

        t = T.new
        return t.instance_eval(&M::C).name
        """)
        assert space.str_w(w_res) == "M::X"

    def test___id__(self, space):
        w_res = space.execute("return BasicObject.new.__id__")
        assert isinstance(w_res, W_FixnumObject)

    def test_method_missing(self, space):
        w_res = space.execute("""
        class BasicObject
          def method_missing(name, *args, &block)
            return name, args, block
          end
        end
        return BasicObject.new.foo('bar', 42)
        """)
        assert self.unwrap(space, w_res) == ["foo", ["bar", 42], None]

    def test_eq(self, space):
        w_res = space.execute("""
        a = BasicObject.new
        return [a == a, a == BasicObject.new]
        """)
        assert self.unwrap(space, w_res) == [True, False]
        w_res = space.execute("""
        a = BasicObject.new
        return [a.equal?(a), a.equal?(BasicObject.new)]
        """)
        assert self.unwrap(space, w_res) == [True, False]

    def test_neq(self, space):
        w_res = space.execute("""
        a = BasicObject.new
        return [a != a, a != BasicObject.new]
        """)
        assert self.unwrap(space, w_res) == [False, True]

    def test_not(self, space):
        w_res = space.execute("return !BasicObject.new")
        assert w_res is space.w_false
        w_res = space.execute("return !true")
        assert w_res is space.w_false
        w_res = space.execute("return !false")
        assert w_res is space.w_true
        w_res = space.execute("return !nil")
        assert w_res is space.w_true

    def test___send__(self, space):
        w_res = space.execute("""
        return [BasicObject.new.__send__("!"), BasicObject.new.__send__(:"==", BasicObject.new)]
        """)
        assert self.unwrap(space, w_res) == [False, False]

    def test_dup(self, space):
        w_res = space.execute("""
        class A
          attr_accessor :a, :b
          def initialize_dup(o)
            $dup_ran = true
          end
        end

        module B
        end

        a = A.new
        a.singleton_class.class_eval do
          def a
            10
          end
        end
        a.a = a.b = 3
        a.singleton_class.class_eval("include B")
        b = a.dup
        return a.a, b.a, b.b, $dup_ran, a.singleton_class.ancestors == b.singleton_class.ancestors
        """)
        assert self.unwrap(space, w_res) == [10, 3, 3, True, False]

    def test_clone(self, space):
        w_res = space.execute("""
        class A
          attr_accessor :a, :b
          def initialize_clone(o)
            $copy_ran = true
          end
        end

        module B
        end

        a = A.new
        a.singleton_class.class_eval do
          def a
            10
          end
        end
        a.a = a.b = 3
        a.singleton_class.class_eval("include B")
        b = a.clone
        return a.a, b.a, b.b, $copy_ran, a.singleton_class.ancestors == b.singleton_class.ancestors
        """)
        assert self.unwrap(space, w_res) == [10, 10, 3, True, True]


class TestObjectObject(BaseTopazTest):
    def test_class(self, space):
        w_res = space.execute("return 1.class")
        assert w_res is space.w_fixnum

    def test_initialize(self, space):
        w_res = space.execute("""
        class X
          def initialize
            @a = 3
          end

          def foo
            @a
          end
        end
        return X.new.foo
        """)
        assert space.int_w(w_res) == 3

    def test_initialize_args(self, space):
        w_res = space.execute("""
        class X
          def initialize a, b
            @a = a
            @b = b
          end
          def attrs
            [@a, @b]
          end
        end
        x = X.new 2, 3
        return x.attrs
        """)
        assert self.unwrap(space, w_res) == [2, 3]

    def test_method_missing(self, space):
        w_res = space.execute("""
        class A
          def method_missing(name, *args, &block)
            return name, args, block
          end
        end
        return A.new.foo('bar', 42)
        """)
        assert self.unwrap(space, w_res) == ["foo", ["bar", 42], None]

    def test_instance_variable_get(self, space):
        w_res = space.execute("""
        class Fred
          def initialize(p1, p2)
            @a, @b = p1, p2
          end
        end
        fred = Fred.new('cat', 99)
        return fred.instance_variable_get(:@a), fred.instance_variable_get("@b")
        """)
        assert self.unwrap(space, w_res) == ["cat", 99]

    def test_instance_variable_set(self, space):
        w_res = space.execute("""
        class A
          def foo; @foo; end
        end
        a = A.new
        a.instance_variable_set(:@foo, "bar")
        return a.foo
        """)
        assert space.str_w(w_res) == "bar"

    def test_to_s(self, space):
        w_res = space.execute("""
        obj = Object.new
        return obj.to_s, obj.object_id
        """)
        s, oid = self.unwrap(space, w_res)
        format = "%%0%dx" % (2 * struct.calcsize("P"))
        assert s == ("#<Object:0x%s>" % format) % oid

    def test_inspect(self, space):
        w_res = space.execute("""
        obj = Object.new
        return obj.to_s == obj.inspect
        """)
        assert w_res == space.w_true
        w_res = space.execute("""
        class A
          def to_s
            10
          end
        end
        obj = A.new
        return obj.to_s == obj.inspect
        """)
        assert w_res == space.w_true

    def test_send(self, space):
        w_res = space.execute("return [1.send(:to_s), 1.send('+', 2)]")
        assert self.unwrap(space, w_res) == ['1', 3]

    def test_eqeqeq(self, space):
        w_res = space.execute("""
        class A; end
        a = A.new
        res = [a === A.new]
        class A; def ==(o); true; end; end
        res << (a === A.new)
        return res
        """)
        assert self.unwrap(space, w_res) == [False, True]

    def test_hash(self, space):
        w_res = space.execute("""
        a = Object.new
        return a.hash, a.hash == a.hash, a.hash != Object.new.hash
        """)
        w_int, w_self_hash, w_other_hash = space.listview(w_res)
        assert isinstance(w_int, W_FixnumObject)
        assert w_self_hash is space.w_true
        assert w_other_hash is space.w_true

    def test_is_kind_ofp(self, space):
        w_res = space.execute("""
        r = []
        module M; end
        class A
          include M
        end
        class B < A; end
        class C < B; end
        b = B.new
        r << b.kind_of?(A)
        r << b.kind_of?(B)
        r << b.kind_of?(C)
        r << b.kind_of?(M)
        return r
        """)
        assert self.unwrap(space, w_res) == [True, True, False, True]

    def test_instance_ofp(self, space):
        w_res = space.execute("""
        class A
        end
        class B < A
        end
        class C < B
        end

        b = B.new
        return [b.instance_of?(A), b.instance_of?(B), b.instance_of?(C)]
        """)
        assert self.unwrap(space, w_res) == [False, True, False]

    def test_extend(self, space):
        w_res = space.execute("""
        $res = []
        class A; end
        module B
          def self.extended(base)
            $res << "extended in: #{base.class.name}"
          end
          def self.included(base)
            $res << "included in: #{base.class.name}"
          end
        end
        A.new.extend B
        A.send :include, B
        A.extend B
        return $res
        """)
        assert self.unwrap(space, w_res) == ["extended in: A", "included in: Class", "extended in: Class"]
        with self.raises(space, "TypeError", "wrong argument type Fixnum (expected Module)"):
            space.execute("Object.new.extend 1")
        with self.raises(space, "TypeError", "wrong argument type Class (expected Module)"):
            space.execute("Object.new.extend Class.new")
        w_res = space.execute("""
        class A; end
        class MyModule < Module; end
        B = MyModule.new
        B.instance_eval do
          def self.extended(base)
            $res = "extended in: #{base.class.name}"
          end
        end
        A.new.extend B
        return $res
        """)
        assert self.unwrap(space, w_res) == "extended in: A"

    def test_method(self, space):
        w_res = space.execute("""
        class A; def a; end; end
        return A.new.method(:a).class, A.new.method(:to_s).class
        """)
        assert self.unwrap(space, w_res) == [
            space.getclassfor(W_MethodObject),
            space.getclassfor(W_MethodObject)
        ]
        with self.raises(space, "NameError"):
            space.execute("Object.new.method(:undefined_stuff)")
        w_res = space.execute("""
        class A; def to_str; "to_s"; end; end
        return 'aaa'.method(A.new).class
        """)
        assert self.unwrap(space, w_res) == space.getclassfor(W_MethodObject)

    def test_tap(self, space):
        with self.raises(space, "LocalJumpError"):
            space.execute("1.tap")

        w_res = space.execute("""
        x = nil
        res = 1.tap { |c| x = c + 1 }
        return res, x
        """)
        assert self.unwrap(space, w_res) == [1, 2]


class TestMapDict(BaseTopazTest):
    def test_simple_attr(self, space):
        w_res = space.execute("""
        class X
          def initialize
            @a = 3
            @b = 4
            @c = 5
          end
          def attrs
            [@a, @b, @c]
          end
        end
        return X.new.attrs
        """)
        assert self.unwrap(space, w_res) == [3, 4, 5]

    def test_unitialized_attr(self, space):
        w_res = space.execute("""
        class X
          attr_accessor :a
          def attrs
            [self.a, @b]
          end
        end
        return X.new.attrs
        """)
        assert space.listview(w_res) == [space.w_nil, space.w_nil]

    def test_change_attr_type(self, space):
        w_res = space.execute("""
        class X
          attr_accessor :a, :b
        end
        x = X.new
        x.a = 3.2
        x.b = 5
        x.a = "abc"
        x.b = 3.8
        return [x.a, x.b]
        """)
        assert self.unwrap(space, w_res) == ["abc", 3.8]

    def test_attribute_after_flag(self, space):
        w_res = space.execute("""
        class X
          attr_accessor :a
        end
        x = X.new
        x.taint
        x.a = "abc"
        return x.a
        """)
        assert space.str_w(w_res) == "abc"

########NEW FILE########
__FILENAME__ = test_procobject
from ..base import BaseTopazTest


class TestProcObject(BaseTopazTest):
    def test_new(self, space):
        w_res = space.execute("""
        p = Proc.new { foo }
        return [p.class, p.lambda?]
        """)
        w_cls, w_proc = space.listview(w_res)
        assert w_cls is space.w_proc
        assert w_proc is space.w_false

    def test_call(self, space):
        w_res = space.execute("""
        p = proc { 1 }
        return [p.call, p[]]
        """)
        assert self.unwrap(space, w_res) == [1, 1]

    def test_return(self, space):
        w_res = space.execute("""
        def f(a)
          a << "a"
          a << (lambda { return "r" }.call)
          a << "b"
          proc { return "p" }.call
          a << "f"
        end

        a = []
        a << (f(a))
        return a
        """)
        assert self.unwrap(space, w_res) == ["a", "r", "b", "p"]

    def test_break(self, space):
        w_res = space.execute("""
        return lambda { break 3 }.call
        """)
        assert space.int_w(w_res) == 3
        with self.raises(space, "LocalJumpError"):
            space.execute("""
            proc { break }.call
            """)

    def test_binding(self, space):
        w_res = space.execute("""
        def f(a)
          return proc {}
        end
        return f(2).binding.eval("a")
        """)
        assert space.int_w(w_res) == 2

########NEW FILE########
__FILENAME__ = test_randomobject
from topaz.objects.randomobject import W_RandomObject

from ..base import BaseTopazTest


class TestRandomObject(BaseTopazTest):
    def test_new(self, space):
        w_res = space.execute("return Random.new")
        assert isinstance(w_res, W_RandomObject)

    def test_rand(self, space):
        w_res = space.execute("return Random.new.rand")
        assert 0 < space.float_w(w_res) < 1

    def test_subclass(self, space):
        w_res = space.execute("""
        class SubRandom < Random
          def better_rand
            # http://xkcd.com/221/
            4
          end
        end
        c = SubRandom.new
        return [c.rand, c.better_rand]
        """)
        rand, better_rand = self.unwrap(space, w_res)
        assert 0 < rand < 1
        assert better_rand == 4

########NEW FILE########
__FILENAME__ = test_rangeobject
from ..base import BaseTopazTest


class TestRangeObject(BaseTopazTest):
    def test_name(self, space):
        space.execute("Range")

    def test_map(self, space):
        w_res = space.execute("""
        return (1..3).map do |x|
          x * 5
        end
        """)
        assert self.unwrap(space, w_res) == [5, 10, 15]

    def test_float_iteration(self, space):
        w_res = space.execute("""
        return (1..3.2).map do |x|
          x
        end
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3]
        w_res = space.execute("""
        return (1...3.2).map do |x|
          x
        end
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3]
        with self.raises(space, "TypeError", "can't iterate from Float"):
            space.execute("(1.1..2).each { }")

    def test_starting_point_always_returned(self, space):
        w_res = space.execute("""
        return (1..1).map do |x|
          x
        end
        """)
        assert self.unwrap(space, w_res) == [1]

    def test_exclude_end(self, space):
        w_res = space.execute("return (1..5).exclude_end?")
        assert self.unwrap(space, w_res) is False

        w_res = space.execute("return (1...5).exclude_end?")
        assert self.unwrap(space, w_res) is True

    def test_eqeqeq(self, space):
        w_res = space.execute("return (1..10) === 5")
        assert w_res is space.w_true
        w_res = space.execute("return (1..10) === -1")
        assert w_res is space.w_false

    def test_begin(self, space):
        w_res = space.execute("return (1..10).begin")
        assert space.int_w(w_res) == 1

    def test_end(self, space):
        w_res = space.execute("return (1..10).end")
        assert space.int_w(w_res) == 10

    def test_range_each_chars(self, space):
        w_res = space.execute("""
        a = []
        ('a'..'e').each do |x|
          a << x
        end
        a
        """)
        assert self.unwrap(space, w_res) == ["a", "b", "c", "d", "e"]

    def test_range_each_symbols(self, space):
        w_res = space.execute("""
        a = []
        (:a..:e).each do |x|
          a << x
        end
        a
        """)
        assert self.unwrap(space, w_res) == ["a", "b", "c", "d", "e"]

    def test_each_returns_self(self, space):
        w_res = space.execute("""
        r = (1...3)
        return r.each {}.equal?(r)
        """)
        assert w_res is space.w_true

########NEW FILE########
__FILENAME__ = test_regexpobject
from ..base import BaseTopazTest


class TestRegexpObject(BaseTopazTest):
    def test_source(self, space):
        w_res = space.execute("return /abc/.source")
        assert space.str_w(w_res) == "abc"

    def test_compile_regexps(self, space):
        space.execute("""
        /^/
        /(a|b)/
        /(ab|ac)/
        /(ms|min)/
        /$/
        /[^f]/
        /[a]+/
        /\\(/
        /[()#:]/
        /[^()#:]/
        /([^)]+)?/
        /cy|m/
        /[\\-]/
        /(?!a)/
        /(?=a)/
        /a{1}/
        /a{2,3}/
        /foo(?#comment)bar/
        /abc/i
        /(?<=\d)/
        /(?<foo>.*)/
        /A++/
        /.*?/
        /\\z/
        /[a-z]/
        /\\d+/
        /([a-z])|b/
        /[a-zA-z]|[a-z]/
        /(?<foo>a)\\g<foo>/
        /[^a-z]/
        /[a-z&&[^a-c]]/
        /[a&&[^b]]+/
        /\\G/
        /\\p{digit}/
        /\\P/
        /a{1,}/
        /a{,1}/
        /(?:abc)?/
        /(?:a|b)*/
        /.*/m
        /(.*|.+)/
        /(?<=b)/
        /\\A|\\z/
        /[[:alnum:]]/
        /(?=a)|b/
        /\\d|a/
        """)

    def test_regexp_syntax_errors(self, space):
        with self.raises(space, "SyntaxError"):
            space.execute("/(?~)/")
        with self.raises(space, "RegexpError"):
            space.execute("""
            r = "(?~)"
            /#{r}/
            """)
        with self.raises(space, "RegexpError"):
            space.execute("""
            class Regexp
              def self.new(*args); /foo/; end
              def self.compile(*args); /foo/; end
            end
            r = "(?~)"
            /#{r}/
            """)

    def test_regexp_compile_errors(self, space):
        with self.raises(space, "RegexpError"):
            space.execute("Regexp.compile '?~'")
        with self.raises(space, "RegexpError"):
            space.execute("""
            class Regexp
              def self.new(*args); /foo/; end
            end
            Regexp.compile "(?~)"
            """)

    def test_regexp_new_errors(self, space):
        with self.raises(space, "RegexpError"):
            space.execute("Regexp.new '?~'")
        with self.raises(space, "RegexpError"):
            space.execute("""
            class Regexp
              def self.compile(*args); /foo/; end
            end
            Regexp.new "(?~)"
            """)

    def test_to_s(self, space):
        w_res = space.execute("return /a/.to_s")
        assert space.str_w(w_res) == "(?-mix:a)"

        w_res = space.execute("return /a/i.to_s")
        assert space.str_w(w_res) == "(?i-mx:a)"

    def test_match_operator(self, space):
        w_res = space.execute("""
        idx = /(l)(l)(o)(a)(b)(c)(h)(e)(l)/ =~ 'helloabchello'
        return idx, $1, $2, $3, $4, $5, $6, $7, $8, $9, $&, $+, $`, $'
        """)
        assert self.unwrap(space, w_res) == [2, "l", "l", "o", "a", "b", "c", "h", "e", "l", "lloabchel", "l", "he", "lo"]

    def test_match_method(self, space):
        w_res = space.execute("return /bc/.match('abc').begin(0)")
        assert space.int_w(w_res) == 1

    def test_match_begin(self, space):
        w_res = space.execute("return /a(bc(de))/.match(' abcde').begin(0)")
        assert space.int_w(w_res) == 1
        w_res = space.execute("return /a(bc(de))/.match(' abcde').begin(1)")
        assert space.int_w(w_res) == 2
        w_res = space.execute("return /a(bc(de))/.match(' abcde').begin(2)")
        assert space.int_w(w_res) == 4
        with self.raises(space, "IndexError", "index 3 out of matches"):
            space.execute("/a(bc(de))/.match(' abcde').begin(3)")

    def test_match_end(self, space):
        w_res = space.execute("return /a(bc(de))f/.match(' abcdef').end(0)")
        assert space.int_w(w_res) == 7
        w_res = space.execute("return /a(bc(de))f/.match(' abcdef').end(1)")
        assert space.int_w(w_res) == 6
        w_res = space.execute("return /a(bc(de))f/.match(' abcdef').end(2)")
        assert space.int_w(w_res) == 6
        with self.raises(space, "IndexError", "index 3 out of matches"):
            space.execute("/a(bc(de))/.match(' abcde').end(3)")

    def test_new_regexp(self, space):
        w_res = space.execute("return Regexp.new('..abc..') == Regexp.compile('..abc..')")
        assert w_res is space.w_true
        w_res = space.execute("return Regexp.new(/abc/).source")
        assert space.str_w(w_res) == "abc"

    def test_size(self, space):
        w_res = space.execute("""
        /(a)(b)(c)/ =~ "hey hey, abc, hey hey"
        return $~.size
        """)
        assert space.int_w(w_res) == 4

    def test_set_match_data_wrong_type(self, space):
        with self.raises(space, "TypeError"):
            space.execute("$~ = 12")
        space.execute("$~ = nil")

    def test_atomic_grouping(self, space):
        w_res = space.execute('return /"(?>.*)"/ =~ (\'"Quote"\')')
        assert w_res is space.w_nil

        w_res = space.execute('return /"(?>[A-Za-z]*)"/ =~ \'"Quote"\'')
        assert space.int_w(w_res) == 0

        w_res = space.execute('return /fooA++bar/.match("fooAAAbar").to_a')
        assert self.unwrap(space, w_res) == ["fooAAAbar"]

    def test_set_intersection(self, space):
        w_res = space.execute("return /[a-z&&[^a-c]]+/ =~ 'abcdef'")
        assert space.int_w(w_res) == 3

    def test_to_a(self, space):
        w_res = space.execute("""
        m = /(a)(b)(c)/.match('defabcdef')
        return m.to_a
        """)
        assert self.unwrap(space, w_res) == ["abc", "a", "b", "c"]

    def test_values_at(self, space):
        w_res = space.execute("""
        m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
        return m.values_at(0, 2, -2)
        """)
        assert self.unwrap(space, w_res) == ["HX1138", "X", "113"]

    def test_branch(self, space):
        w_res = space.execute("return /a|b/ =~ 'a'")
        assert space.int_w(w_res) == 0

    def test_dot(self, space):
        w_res = space.execute('return /./ =~ "\\n"')
        assert w_res is space.w_nil

        w_res = space.execute('return /./m =~ "\\n"')
        assert space.int_w(w_res) == 0

    def test_non_capturing_group(self, space):
        w_res = space.execute("return /(?:foo)(bar)/.match('foobar').to_a")
        assert self.unwrap(space, w_res) == ["foobar", "bar"]

    def test_optional_group(self, space):
        w_res = space.execute("return /(foo)?(bar)?/.match('foobar')[1]")
        assert self.unwrap(space, w_res) == "foo"
        w_res = space.execute("return /(foo)?(bar)?/.match('foobar')[2]")
        assert self.unwrap(space, w_res) == "bar"
        w_res = space.execute("return /(foo)?(bar)?/.match('foo')[2]")
        assert self.unwrap(space, w_res) is None

    def test_quantify_set(self, space):
        w_res = space.execute("return /([0-9]){3,5}?/ =~ 'ab12345'")
        assert space.int_w(w_res) == 2

    def test_posix_class(self, space):
        w_res = space.execute("return /[[:digit:]]/ =~ 'abc2'")
        assert space.int_w(w_res) == 3

    def test_quantify(self, space):
        w_res = space.execute("return /a{2,4}/.match('aaaaaa').to_a")
        assert self.unwrap(space, w_res) == ["aaaa"]

    def test_repeated_quantification(self, space):
        w_res = space.execute("return /(A{0,1}+)A/.match('AAA').to_a")
        assert self.unwrap(space, w_res) == ["AAA", "AA"]

    def test_casefoldp(self, space):
        w_res = space.execute("return /a/.casefold?")
        assert w_res is space.w_false
        w_res = space.execute("return /a/i.casefold?")
        assert w_res is space.w_true

    def test_eqeqeq(self, space):
        w_res = space.execute("return /abc/ === 'defabc'")
        assert w_res is space.w_true
        w_res = space.execute("return /abc/ === 'ddddddd'")
        assert w_res is space.w_false

    def test_escape(self, space):
        w_res = space.execute("""
        return Regexp.escape("y1_'\t\n\v\f\r \#$()*+-.?[\\\\]^{|}")
        """)
        assert space.str_w(w_res) == "y1_'\\t\\n\\v\\f\\r\\ \\#\\$\\(\\)\\*\\+\\-\\.\\?\\[\\\\\\]\\^\\{\\|\\}"

    def test_ignore_whitespace(self, space):
        w_res = space.execute("return /\d \d/x =~ '12'")
        assert space.int_w(w_res) == 0

########NEW FILE########
__FILENAME__ = test_stringobject
from rpython.rlib.rbigint import rbigint

from ..base import BaseTopazTest


class TestStringObject(BaseTopazTest):
    def test_new(self, space):
        w_res = space.execute("return String.new('abc')")
        assert space.str_w(w_res) == "abc"
        w_res = space.execute("return String.new")
        assert space.str_w(w_res) == ""

    def test_lshift(self, space):
        w_res = space.execute('return "abc" << "def" << "ghi"')
        assert space.str_w(w_res) == "abcdefghi"
        w_res = space.execute('return "abc".concat("def").concat("ghi")')
        assert space.str_w(w_res) == "abcdefghi"

    def test_plus(self, space):
        w_res = space.execute('return "abc" + "def" + "ghi"')
        assert space.str_w(w_res) == "abcdefghi"

    def test_mul(self, space):
        w_res = space.execute("return 'abc' * 2")
        assert space.str_w(w_res) == "abcabc"
        w_res = space.execute("return ('abc' << 'def') * 3")
        assert space.str_w(w_res) == "abcdefabcdefabcdef"

    def test_to_s(self, space):
        w_res = space.execute('return "ABC".to_s')
        assert space.str_w(w_res) == "ABC"

    def test_inspect(self, space):
        w_res = space.execute('return "abc".inspect')
        assert space.str_w(w_res) == '"abc"'

    def test_to_str(self, space):
        w_res = space.execute('return "ABC".to_str')
        assert space.str_w(w_res) == "ABC"

    def test_ord(self, space):
        w_res = space.execute('return "a".ord')
        assert space.int_w(w_res) == 97
        w_res = space.execute('return "asd".ord')
        assert space.int_w(w_res) == 97
        with self.raises(space, "ArgumentError", "empty string"):
            space.execute("''.ord")

    def test_length(self, space):
        w_res = space.execute("return 'ABC'.length")
        assert space.int_w(w_res) == 3
        w_res = space.execute("return 'ABC'.size")
        assert space.int_w(w_res) == 3

    def test_emptyp(self, space):
        w_res = space.execute("return ''.empty?")
        assert w_res is space.w_true
        w_res = space.execute("return 'a'.empty?")
        assert w_res is space.w_false

    def test_subscript_constant(self, space):
        w_res = space.execute("""
        a = "hello there"
        return [
          a[1],
          a[2, 3],
          a[2..3],
          a[-3, 2],
          a[7..-2],
          a[-4..-2],
          a[-2..-4],
          a[12..-1],
        ]
        """)
        assert self.unwrap(space, w_res) == ["e", "llo", "ll", "er", "her", "her", "", None]

    def test_subscript_mutable(self, space):
        w_res = space.execute("""
        a = "hello" << " " << "there"
        return [
          a[1],
          a[2, 3],
          a[2..3],
          a[-3, 2],
          a[7..-2],
          a[-4..-2],
          a[-2..-4],
          a[12..-1],
        ]
        """)
        assert self.unwrap(space, w_res) == ["e", "llo", "ll", "er", "her", "her", "", None]

    def test_comparator_lt(self, space):
        w_res = space.execute("return 'a' <=> 'b'")
        assert space.int_w(w_res) == -1

    def test_comparator_eq(self, space):
        w_res = space.execute("return 'a' <=> 'a'")
        assert space.int_w(w_res) == 0

    def test_comparator_gt(self, space):
        w_res = space.execute("return 'b' <=> 'a'")
        assert space.int_w(w_res) == 1

    def test_comparator_to_type_without_to_str(self, space):
        w_res = space.execute("return 'b' <=> 1")
        assert w_res is space.w_nil

    def test_comparator_to_type_with_to_str(self, space):
        w_res = space.execute("""
        class A
          def to_str; 'A'; end
          def <=>(other); other <=> self.to_str; end
        end
        return 'A' <=> A.new
        """)
        assert space.int_w(w_res) == 0

    def test_eqlp(self, space):
        w_res = space.execute("return 'abc'.eql? 2")
        assert w_res is space.w_false
        w_res = space.execute("return 'abc'.eql? 'abc'")
        assert w_res is space.w_true

    def test_hash(self, space):
        w_res = space.execute("""
        return ['abc'.hash, ('a' << 'b' << 'c').hash]
        """)
        h1, h2 = self.unwrap(space, w_res)
        assert h1 == h2

    def test_to_sym(self, space):
        w_res = space.execute("return 'abc'.to_sym")
        assert space.symbol_w(w_res) == "abc"

    def test_clear(self, space):
        w_res = space.execute("""
        a = 'hi'
        b = a
        a.clear
        return [a, b]
        """)
        assert self.unwrap(space, w_res) == ["", ""]

        w_res = space.execute("return ('a' << 'b').clear")
        assert self.unwrap(space, w_res) == ""

    def test_ljust(self, space):
        w_res = space.execute("""
        a = 'hi'
        return a, a.ljust(1)
        """)
        w_original, w_adjusted = space.listview(w_res)
        assert w_original is not w_adjusted
        assert space.str_w(w_adjusted) == space.str_w(w_original)

        w_res = space.execute("return 'a'.ljust(3)")
        assert space.str_w(w_res) == "a  "

        w_res = space.execute("return 'a'.ljust(3, 'l')")
        assert space.str_w(w_res) == "all"

        w_res = space.execute("return 'a'.ljust(5, '-_*')")
        assert space.str_w(w_res) == "a-_*-"

        with self.raises(space, "ArgumentError", "zero width padding"):
            space.execute("'hi'.ljust(10, '')")

    def test_index(self, space):
        w_res = space.execute("return 'abc'.index 'a'")
        assert space.int_w(w_res) == 0
        w_res = space.execute("return 'abc'.index 'bc'")
        assert space.int_w(w_res) == 1
        w_res = space.execute("return 'aba'.index 'a', 1")
        assert space.int_w(w_res) == 2
        w_res = space.execute("return 'aba'.index 'c', 1")
        assert space.int_w(w_res) == -1
        w_res = space.execute("return 'aba'.index /ba/")
        assert space.int_w(w_res) == 1
        w_res = space.execute("return 'aba'.index /xyz/")
        assert space.int_w(w_res) == -1
        with self.raises(space, "TypeError", "type mismatch: Fixnum given"):
            space.execute("'a b c'.index 12")

    def test_rindex(self, space):
        w_res = space.execute('"hello".rindex("e")')
        assert space.int_w(w_res) == 1
        w_res = space.execute('"hello".rindex("l")')
        assert space.int_w(w_res) == 3
        w_res = space.execute('"hello".rindex("l", -3)')
        assert space.int_w(w_res) == 2
        w_res = space.execute('"hello".rindex("h", -5)')
        assert space.int_w(w_res) == 0
        w_res = space.execute('"hello".rindex(/[aeiou]/, -2)')
        assert space.int_w(w_res) == 1
        w_res = space.execute('"hello".rindex(/[aeiou]/, 0)')
        assert space.int_w(w_res) == 4
        w_res = space.execute('"hello".rindex(/[aeiou]/, 10)')
        assert space.int_w(w_res) == 4
        w_res = space.execute('"hello".rindex(/[aeiou]/, -1)')
        assert space.int_w(w_res) == 4
        w_res = space.execute('"hello".rindex(/[aeiou]/, -10)')
        assert w_res is space.w_nil
        w_res = space.execute('"hello".rindex(/[x]/)')
        assert w_res is space.w_nil
        w_res = space.execute('"hello".rindex("x")')
        assert w_res is space.w_nil
        with self.raises(space, "TypeError", "type mismatch: Fixnum given"):
            space.execute('"hello".rindex(123)')

    def test_split(self, space):
        w_res = space.execute("return 'a b c'.split")
        assert self.unwrap(space, w_res) == ["a", "b", "c"]
        w_res = space.execute("return 'a-b-c'.split('-')")
        assert self.unwrap(space, w_res) == ["a", "b", "c"]
        w_res = space.execute("return 'a-b-c'.split('-', 2)")
        assert self.unwrap(space, w_res) == ["a", "b-c"]
        w_res = space.execute("return 'a b c'.split(' ', -1)")
        assert self.unwrap(space, w_res) == ["a", "b", "c"]
        with self.raises(space, "TypeError", "wrong argument type Fixnum (expected Regexp)"):
            space.execute("'a b c'.split(12)")

    def test_split_regexp(self, space):
        w_res = space.execute("return \"now's  the time\".split(/ /)")
        assert self.unwrap(space, w_res) == ["now's", "", "the", "time"]
        w_res = space.execute('return "1, 2.34,56, 7".split(%r{,\s*})')
        assert self.unwrap(space, w_res) == ["1", "2.34", "56", "7"]
        w_res = space.execute('return "1, 2.34,56, 7".split(%r{,\s*}, 0)')
        assert self.unwrap(space, w_res) == ["1", "2.34", "56", "7"]
        w_res = space.execute('return "1, 2.34,56, 7".split(%r{,\s*}, -1)')
        assert self.unwrap(space, w_res) == ["1", "2.34", "56", "7", ""]
        w_res = space.execute('return "1, 2.34,56, 7".split(%r{,\s*}, -2)')
        assert self.unwrap(space, w_res) == ["1", "2.34", "56", "7", ""]
        w_res = space.execute('return "1, 2.34,56, 7".split(%r{,\s*}, 4)')
        assert self.unwrap(space, w_res) == ["1", "2.34", "56", "7"]
        w_res = space.execute('return "1, 2.34,56, 7".split(%r{,\s*}, 5)')
        assert self.unwrap(space, w_res) == ["1", "2.34", "56", "7", ""]
        w_res = space.execute('return "1, 2.34,56, 7".split(%r{,\s*}, 6)')
        assert self.unwrap(space, w_res) == ["1", "2.34", "56", "7", ""]
        w_res = space.execute('return "hello".split(//)')
        assert self.unwrap(space, w_res) == ["h", "e", "l", "l", "o"]
        w_res = space.execute('return "hello".split(//, 3)')
        assert self.unwrap(space, w_res) == ["h", "e", "llo"]
        w_res = space.execute('return "hello".split(/((.)(.))/, 3)')
        assert self.unwrap(space, w_res) == ["", "he", "h", "e", "", "ll", "l", "l", "o"]

    def test_dup(self, space):
        w_res = space.execute("""
        x = "abc"
        y = x.dup
        x << "def"
        return [x, y]
        """)
        x, y = self.unwrap(space, w_res)
        assert x == "abcdef"
        assert y == "abc"

    def test_dup_mutable(self, space):
        w_res = space.execute("return ('abc' << 'def').dup")
        assert self.unwrap(space, w_res) == 'abcdef'

    def test_to_i(self, space):
        w_res = space.execute('return "1234".to_i')
        assert space.int_w(w_res) == 1234
        w_res = space.execute('return "1010".to_i(2)')
        assert space.int_w(w_res) == 10
        w_res = space.execute('return "77".to_i(8)')
        assert space.int_w(w_res) == 63
        w_res = space.execute('return "AA".to_i(16)')
        assert space.int_w(w_res) == 170
        w_res = space.execute('return "12a".to_i')
        assert space.int_w(w_res) == 12
        w_res = space.execute('return "-a".to_i')
        assert space.int_w(w_res) == 0
        w_res = space.execute('return "".to_i')
        assert space.int_w(w_res) == 0
        w_res = space.execute('return "-12fdsa".to_i')
        assert space.int_w(w_res) == -12
        w_res = space.execute("return '1_2_3'.to_i")
        assert space.int_w(w_res) == 123
        w_res = space.execute("return '_1_2_3'.to_i")
        assert space.int_w(w_res) == 0
        w_res = space.execute("return '   123'.to_i")
        assert space.int_w(w_res) == 123

        w_res = space.execute("return '234124123123123121231231'.to_i")
        assert space.bigint_w(w_res) == rbigint.fromlong(234124123123123121231231)

        with self.raises(space, "ArgumentError"):
            space.execute('"".to_i(1)')
        with self.raises(space, "ArgumentError"):
            space.execute('"".to_i(37)')

    def test_to_f(self, space):
        w_res = space.execute('return "123.45".to_f')
        assert space.float_w(w_res) == 123.45

        w_res = space.execute('return "45.67 degrees".to_f')
        assert space.float_w(w_res) == 45.67

        w_res = space.execute('return "thx1138".to_f')
        assert space.float_w(w_res) == 0.0

        w_res = space.execute('return "123.45e1".to_f')
        assert space.float_w(w_res) == 1234.5

        w_res = space.execute('return "  123.45e1".to_f')
        assert space.float_w(w_res) == 1234.5

    def test_swapcase(self, space):
        w_res = space.execute("""
        a = "AbC123aBc"
        a.swapcase!
        return a
        """)
        assert self.unwrap(space, w_res) == "aBc123AbC"

        w_res = space.execute("return 'AbC123aBc'.swapcase")
        assert self.unwrap(space, w_res) == "aBc123AbC"

        w_res = space.execute("return '123'.swapcase!")
        assert w_res is space.w_nil

    def test_upcase(self, space):
        w_res = space.execute("""
        a = "AbC123aBc"
        a.upcase!
        return a
        """)
        assert self.unwrap(space, w_res) == "ABC123ABC"

        w_res = space.execute("return 'AbC123aBc'.upcase")
        assert self.unwrap(space, w_res) == "ABC123ABC"

        w_res = space.execute("return '123'.upcase!")
        assert w_res is space.w_nil

    def test_downcase(self, space):
        w_res = space.execute("""
        a = "AbC123aBc"
        a.downcase!
        return a
        """)
        assert self.unwrap(space, w_res) == "abc123abc"

        w_res = space.execute("return 'AbC123aBc'.downcase")
        assert self.unwrap(space, w_res) == "abc123abc"

        w_res = space.execute("return '123'.downcase!")
        assert w_res is space.w_nil

    def test_capitalize(self, space):
        w_res = space.execute("""
        a = "123ABC"
        a.capitalize!
        return a
        """)
        assert self.unwrap(space, w_res) == "123abc"

        w_res = space.execute("return 'hello'.capitalize")
        assert self.unwrap(space, w_res) == "Hello"
        w_res = space.execute("return 'HELLO'.capitalize")
        assert self.unwrap(space, w_res) == "Hello"
        w_res = space.execute("return '123'.capitalize!")
        assert w_res is space.w_nil

    def test_tr(self, space):
        w_res = space.execute("return 'hello'.tr('el', 'ip')")
        assert space.str_w(w_res) == "hippo"
        w_res = space.execute("return 'hello'.tr('aeiou', '*')")
        assert space.str_w(w_res) == "h*ll*"
        w_res = space.execute("return 'hello'.tr('a-y', 'b-z')")
        assert space.str_w(w_res) == "ifmmp"
        w_res = space.execute("return 'hello'.tr('^aieou', '*')")
        assert space.str_w(w_res) == "*e**o"
        w_res = space.execute("return 'hello'.tr!('','').nil?")
        assert self.unwrap(space, w_res) is True
        w_res = space.execute("""
        s = 'hello'
        s.tr!('e', 'a')
        return s
        """)
        assert space.str_w(w_res) == "hallo"

    def test_tr_s(self, space):
        w_res = space.execute("return 'hello'.tr_s('l', 'r')")
        assert space.str_w(w_res) == "hero"
        w_res = space.execute("return 'hello'.tr_s('el', '*')")
        assert space.str_w(w_res) == "h*o"
        w_res = space.execute("return 'hello'.tr_s('el', 'hx')")
        assert space.str_w(w_res) == "hhxo"
        w_res = space.execute("""
        s = 'hello'
        s.tr_s!('el', 'hx')
        return s
        """)
        assert space.str_w(w_res) == "hhxo"
        w_res = space.execute("return 'hello'.tr_s!('','').nil?")
        assert self.unwrap(space, w_res) is True

    def test_match_operator(self, space):
        w_res = space.execute("return 'abc' =~ 1")
        assert w_res is space.w_nil
        w_res = space.execute("return 'abc' =~ /abc/")
        assert space.int_w(w_res) == 0
        w_res = space.execute("""
        '' =~ /()/
        return $1
        """)
        assert space.str_w(w_res) == ""

    def test_match_method(self, space):
        w_res = space.execute("return 'abc'.match('bc').begin 0")
        assert space.int_w(w_res) == 1

    def test_getbyte(self, space):
        w_res = space.execute("return 'abc'.getbyte 0")
        assert space.int_w(w_res) == 97
        w_res = space.execute("return 'abc'.getbyte 2")
        assert space.int_w(w_res) == 99
        w_res = space.execute("return 'abc'.getbyte 3")
        assert w_res is space.w_nil
        w_res = space.execute("return 'abc'.getbyte -1")
        assert space.int_w(w_res) == 99
        w_res = space.execute("return 'abc'.getbyte -3")
        assert space.int_w(w_res) == 97
        w_res = space.execute("return 'abc'.getbyte -4")
        assert w_res is space.w_nil

    def test_chomp(self, space):
        assert space.str_w(space.execute('return "hello".chomp')) == "hello"
        assert space.str_w(space.execute('return "hello\\n".chomp')) == "hello"
        assert space.str_w(space.execute('return "hello\\r\\n".chomp')) == "hello"
        assert space.str_w(space.execute('return "hello\\n\\r".chomp')) == "hello"
        assert space.str_w(space.execute('return "hello\\r".chomp')) == "hello"
        assert space.str_w(space.execute('return "hello\\r".chomp("")')) == "hello\r"
        assert space.str_w(space.execute('return "hello \\n there".chomp')) == "hello \n there"
        assert space.str_w(space.execute('return "hello".chomp("llo")')) == "he"
        w_res = space.execute('return "hello".chomp!')
        assert w_res is space.w_nil
        w_res = space.execute('return "".chomp!')
        assert w_res is space.w_nil
        w_res = space.execute('return "abc".chomp!(nil)')
        assert w_res is space.w_nil
        w_res = space.execute('return "abc\\r".chomp!("")')
        assert w_res is space.w_nil

    def test_chop(self, space):
        assert space.str_w(space.execute('return "string\\r\\n".chop')) == "string"
        assert space.str_w(space.execute('return "string\\n\\r".chop')) == "string\n"
        assert space.str_w(space.execute('return "string\\n".chop')) == "string"
        assert space.str_w(space.execute('return "string".chop')) == "strin"
        assert space.str_w(space.execute('return "x".chop.chop')) == ""
        assert space.str_w(space.execute('return "string".chop!')) == "strin"
        w_res = space.execute("return ''.chop!")
        assert w_res is space.w_nil

    def test_reverse(self, space):
        assert space.str_w(space.execute('return "stressed".reverse')) == "desserts"
        w_res = space.execute("""
        a = "stressed"
        a.reverse!
        return a, a.reverse
        """)
        assert self.unwrap(space, w_res) == ["desserts", "stressed"]

    def test_includep(self, space):
        assert space.execute("return 'abc'.include? 'ab'") is space.w_true
        assert space.execute("return 'abc'.include? 'bc'") is space.w_true
        assert space.execute("return 'abc'.include? 'cd'") is space.w_false

    def test_gsub(self, space):
        w_res = space.execute("""
        return 'hello hello'.gsub("he", "ha")
        """)
        assert space.str_w(w_res) == "hallo hallo"
        w_res = space.execute("""
        return 'hello'.gsub(/(.)/, "ha")
        """)
        assert space.str_w(w_res) == "hahahahaha"
        w_res = space.execute("""
        return 'hello'.gsub(/(.)/, "ha\\\\1ho")
        """)
        assert space.str_w(w_res) == "hahhohaehohalhohalhohaoho"
        w_res = space.execute("""
        return 'hello'.gsub(/(.)/) { |e| e + "1" }
        """)
        assert space.str_w(w_res) == "h1e1l1l1o1"
        w_res = space.execute("""
        return 'hello'.gsub('e') { |e| e + "1" }
        """)
        assert space.str_w(w_res) == "he1llo"
        w_res = space.execute("""
        return 'hello'.gsub(/[eo]/, 'e' => 3, 'o' => '*')
        """)
        assert space.str_w(w_res) == "h3ll*"
        w_res = space.execute("""
        return 'hello'.gsub("e", 'e' => 3, 'o' => '*')
        """)
        assert space.str_w(w_res) == "h3llo"
        w_res = space.execute("""
        replacements = [1, 2]
        return 'helloo'.gsub("l", Hash.new { |h, k| replacements.pop() })
        """)
        assert space.str_w(w_res) == "he21oo"

    def test_sub(self, space):
        w_res = space.execute("""
        return 'hello hello'.sub("he", "ha")
        """)
        assert space.str_w(w_res) == "hallo hello"
        w_res = space.execute("""
        return 'hello'.sub(/(.)/, "ha")
        """)
        assert space.str_w(w_res) == "haello"
        w_res = space.execute("""
        return 'hello'.sub(/(.)/, "ha\\\\1ho")
        """)
        assert space.str_w(w_res) == "hahhoello"
        w_res = space.execute("""
        return 'hello'.sub(/(.)/) { |e| e + "1" }
        """)
        assert space.str_w(w_res) == "h1ello"
        w_res = space.execute("""
        return 'hello'.sub('l') { |e| e + "1" }
        """)
        assert space.str_w(w_res) == "hel1lo"
        w_res = space.execute("""
        return 'hello'.sub(/[eo]/, 'e' => 3, 'o' => '*')
        """)
        assert space.str_w(w_res) == "h3llo"
        w_res = space.execute("""
        return 'hello'.sub("e", 'e' => 3, 'o' => '*')
        """)
        assert space.str_w(w_res) == "h3llo"
        w_res = space.execute("""
        replacements = [1, 2]
        return 'helloo'.sub("l", Hash.new { |h, k| replacements.pop() })
        """)
        assert space.str_w(w_res) == "he2loo"

    def test_succ(self, space):
        w_res = space.execute('return "abcd".succ')
        assert space.str_w(w_res) == "abce"
        w_res = space.execute('return "THX1138".succ')
        assert space.str_w(w_res) == "THX1139"
        w_res = space.execute('return "<<koala>>".succ')
        assert space.str_w(w_res) == "<<koalb>>"
        w_res = space.execute('return "ZZZ9999".succ')
        assert space.str_w(w_res) == "AAAA0000"
        w_res = space.execute('return "***".succ')
        assert space.str_w(w_res) == "**+"

    def test_slice(self, space):
        w_res = space.execute('return "this is a string".slice(2)')
        assert space.str_w(w_res) == "i"
        w_res = space.execute('return "hello".slice(2, 3)')
        assert space.str_w(w_res) == "llo"

    def test_slice_i(self, space):
        w_res = space.execute('return "this is a string".slice!(2)')
        assert space.str_w(w_res) == "i"
        w_res = space.execute('return "this is a string".slice!(2, 5)')
        assert space.str_w(w_res) == "is is"
        w_res = space.execute("""
        string = "this is a string"
        string.slice!(2)
        string.slice!(3..6)
        return string
        """)
        assert space.str_w(w_res) == "thsa string"


class TestStringMod(object):
    def test_s(self, space):
        w_res = space.execute("return '1 %s 1' % 'abc'")
        assert space.str_w(w_res) == "1 abc 1"

    def test_f(self, space):
        w_res = space.execute("return ' %f ' % 1.23")
        assert space.str_w(w_res) == " 1.230000 "

    def test_f_width(self, space):
        w_res = space.execute("return '%04f' % 1.23")
        assert space.str_w(w_res) == "1.230000"

    def test_d(self, space):
        w_res = space.execute("return ' %d ' % 12")
        assert space.str_w(w_res) == " 12 "

    def test_d_width(self, space):
        w_res = space.execute("return ' %05d' % 12")
        assert space.str_w(w_res) == " 00012"
        w_res = space.execute("return ' %01d' % 12")
        assert space.str_w(w_res) == " 12"

    def test_array_param(self, space):
        w_res = space.execute("return '%d-%s' % [12, 'happy']")
        assert space.str_w(w_res) == "12-happy"
        w_res = space.execute("return '1%02d%02d%02d%04d' % [1, 2, 3, 4]")
        assert space.str_w(w_res) == "10102030004"

########NEW FILE########
__FILENAME__ = test_symbolobject
from ..base import BaseTopazTest


class TestSymbolObject(BaseTopazTest):
    def test_name(self, space):
        space.execute("Symbol")

    def test_symbol(self, space):
        w_res = space.execute("return :foo")
        assert space.symbol_w(w_res) == "foo"

    def test_to_s(self, space):
        w_res = space.execute("return :foo.to_s")
        assert space.str_w(w_res) == "foo"

    def test_inspect(self, space):
        w_res = space.execute("return :foo.inspect")
        assert space.str_w(w_res) == ":foo"

    def test_comparator_lt(self, space):
        w_res = space.execute("return :a <=> :b")
        assert space.int_w(w_res) == -1

    def test_comparator_eq(self, space):
        w_res = space.execute("return :a <=> :a")
        assert space.int_w(w_res) == 0

    def test_comparator_gt(self, space):
        w_res = space.execute("return :b <=> :a")
        assert space.int_w(w_res) == 1

    def test_comparator_non_symbol(self, space):
        w_res = space.execute("return :a <=> 12")
        assert w_res is space.w_nil

    def test_identity(self, space):
        w_res = space.execute("return [:x.object_id, :x.object_id]")
        id1, id2 = self.unwrap(space, w_res)
        assert id1 == id2

    def test_to_sym(self, space):
        w_res = space.execute("return :x, :x.to_sym")
        s1, s2 = self.unwrap(space, w_res)
        assert s1 == s2 == "x"

    def test_to_proc(self, space):
        w_res = space.execute("return :+.to_proc.call(2, 3)")
        assert space.int_w(w_res) == 5

    def test_succ(self, space):
        w_res = space.execute('return :abcd.succ')
        assert space.symbol_w(w_res) == "abce"
        w_res = space.execute('return :THX1138.succ')
        assert space.symbol_w(w_res) == "THX1139"
        w_res = space.execute('return :"<<koala>>".succ')
        assert space.symbol_w(w_res) == "<<koalb>>"
        w_res = space.execute('return :"ZZZ9999".succ')
        assert space.symbol_w(w_res) == "AAAA0000"
        w_res = space.execute('return :"***".succ')
        assert space.symbol_w(w_res) == "**+"

########NEW FILE########
__FILENAME__ = test_threadobject
class TestThreadObject(object):
    def test_name(self, space):
        space.execute("Thread")

    def test_current(self, space):
        w_res = space.execute("return Thread.current.class.name")
        assert space.str_w(w_res) == "Thread"

    def test_thread_local_storage(self, space):
        w_res = space.execute("return Thread.current['a']")
        assert w_res is space.w_nil

        w_res = space.execute("""
        Thread.current["a"] = 1
        return Thread.current[:a]
        """)
        assert space.int_w(w_res) == 1

    def test_recursion_guard(self, space):
        w_res = space.execute("""
        def foo(objs, depth = 0)
          obj = objs.shift
          recursion = Thread.current.recursion_guard(:foo, obj) do
            return foo(objs, depth + 1)
          end
          if recursion
            return [depth, obj]
          end
        end
        return foo([:a, :b, :c, :a, :d])
        """)
        w_depth, w_symbol = space.listview(w_res)
        assert space.int_w(w_depth) == 3
        assert space.symbol_w(w_symbol) == "a"

    def test_recursion_guard_nested(self, space):
        w_res = space.execute("""
        def foo(objs, depth = 0)
          obj = objs.shift
          Thread.current.recursion_guard(:foo, obj) do
            return bar(objs, depth + 1)
          end
          return [depth, obj]
        end

        def bar(objs, depth)
          obj = objs.shift
          Thread.current.recursion_guard(:bar, obj) do
            return foo(objs, depth + 1)
          end
          return [depth, obj]
        end

        return foo([:a, :a, :b, :b, :c, :a, :d, :d])
        """)
        w_depth, w_symbol = space.listview(w_res)
        assert space.int_w(w_depth) == 5
        assert space.symbol_w(w_symbol) == "a"

########NEW FILE########
__FILENAME__ = test_timeobject
import time

import pytest


# pytest currently explodes with monkeypatching time.time
@pytest.mark.xfail(run=False)
class TestTimeObject(object):
    def test_now(self, space, monkeypatch):
        monkeypatch.setattr(time, "time", lambda: 342.1)
        w_secs = space.execute("return Time.now.to_f")
        assert space.float_w(w_secs) == 342.1

    def test_subtraction(self, space, monkeypatch):
        monkeypatch.setattr(time, "time", iter([18, 12]).next)
        w_secs = space.execute("return Time.now - Time.now")
        assert space.float_w(w_secs) == 6

########NEW FILE########
__FILENAME__ = test_celldict
from topaz.celldict import CellDict, Cell, GlobalsDict

from .base import BaseTopazTest


class TestCellDict(BaseTopazTest):
    def test_single_set(self, space):
        c = CellDict()
        v = c.version
        c.set(space, "a", 2)
        assert c.version is not v
        assert c._get_cell("a", c.version) == 2

    def test_multi_set(self, space):
        c = CellDict()
        c.set(space, "a", 2)
        v = c.version
        c.set(space, "a", 3)
        assert isinstance(c._get_cell("a", c.version), Cell)
        assert c.version is not v
        v = c.version
        c.set(space, "a", 4)
        assert isinstance(c._get_cell("a", c.version), Cell)
        assert c.version is v

    def test_globals(self, space):
        space.stuff = 4
        g = GlobalsDict()
        g.define_virtual("x", lambda s: s.stuff)
        assert g.get(space, "x") == 4
        with self.raises(space, "NameError"):
            g.set(space, "x", 5)

        g.define_virtual("y", lambda s: s.stuff, lambda s, v: setattr(s, "stuff", v))
        assert g.get(space, "y") == 4
        g.set(space, "y", 5)
        assert g.get(space, "y") == 5

########NEW FILE########
__FILENAME__ = test_compiler
from topaz import consts


class TestCompiler(object):
    def assert_compiles(self, space, source, expected_bytecode_str):
        bc = space.compile(source, None)
        self.assert_compiled(bc, expected_bytecode_str)
        return bc

    def get_lines(self, bc):
        actual = []
        i = 0
        while i < len(bc.code):
            c = ord(bc.code[i])
            line = consts.BYTECODE_NAMES[c]
            i += 1
            for j in xrange(consts.BYTECODE_NUM_ARGS[c]):
                v = ord(bc.code[i]) | (ord(bc.code[i + 1]) * 256)
                line += " %s" % v
                i += 2
            actual.append(line)
        return actual

    def assert_compiled(self, bc, expected_bytecode_str):
        expected = []
        for line in expected_bytecode_str.splitlines():
            if "#" in line:
                line = line[:line.index("#")]
            line = line.strip()
            if line:
                expected.append(line)

        actual = self.get_lines(bc)
        assert actual == expected

    def test_int_constant(self, space):
        bc = self.assert_compiles(space, "1", """
        LOAD_CONST 0
        RETURN
        """)
        [c] = bc.consts_w
        assert space.int_w(c) == 1
        assert bc.max_stackdepth == 1

    def test_float_constant(self, space):
        bc = self.assert_compiles(space, "1.2", """
        LOAD_CONST 0
        RETURN
        """)
        [c] = bc.consts_w
        assert space.float_w(c) == 1.2

    def test_addition(self, space):
        bc = self.assert_compiles(space, "1 + 2", """
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 1
        RETURN
        """)
        assert bc.max_stackdepth == 2
        assert bc.consts_w[2].symbol == "+"

    def test_multi_term_expr(self, space):
        self.assert_compiles(space, "1 + 2 * 3", """
        LOAD_CONST 0
        LOAD_CONST 1
        LOAD_CONST 2
        SEND 3 1
        SEND 4 1
        RETURN
        """)

    def test_multiple_statements(self, space):
        self.assert_compiles(space, "1; 2; 3", """
        LOAD_CONST 0
        DISCARD_TOP
        LOAD_CONST 1
        DISCARD_TOP
        LOAD_CONST 2
        RETURN
        """)

    def test_send(self, space):
        self.assert_compiles(space, "puts 1", """
        LOAD_SELF
        LOAD_CONST 0
        SEND 1 1
        RETURN
        """)
        self.assert_compiles(space, "puts 1, 2, 3", """
        LOAD_SELF
        LOAD_CONST 0
        LOAD_CONST 1
        LOAD_CONST 2
        SEND 3 3
        RETURN
        """)

    def test_assignment(self, space):
        self.assert_compiles(space, "a = 3", """
        LOAD_CONST 0
        STORE_DEREF 0
        RETURN
        """)
        bc = self.assert_compiles(space, "a = 3; a = 4", """
        LOAD_CONST 0
        STORE_DEREF 0
        DISCARD_TOP
        LOAD_CONST 1
        STORE_DEREF 0
        RETURN
        """)
        assert bc.cellvars == ["a"]

    def test_load_var(self, space):
        bc = self.assert_compiles(space, "a", """
        LOAD_SELF
        SEND 0 0

        RETURN
        """)
        assert bc.cellvars == []
        bc = self.assert_compiles(space, "a = 3; a", """
        LOAD_CONST 0
        STORE_DEREF 0
        DISCARD_TOP
        LOAD_DEREF 0
        RETURN
        """)
        assert bc.cellvars == ["a"]

    def test_if(self, space):
        self.assert_compiles(space, "if 3 then puts 2 end", """
        LOAD_CONST 0
        JUMP_IF_FALSE 18
        LOAD_SELF
        LOAD_CONST 1
        SEND 2 1
        JUMP 21
        LOAD_CONST 3

        RETURN
        """)

        self.assert_compiles(space, "x = if 3 then 2 end", """
        LOAD_CONST 0
        JUMP_IF_FALSE 12
        LOAD_CONST 1
        JUMP 15
        LOAD_CONST 2
        STORE_DEREF 0

        RETURN
        """)

        self.assert_compiles(space, "x = if 3; end", """
        LOAD_CONST 0
        JUMP_IF_FALSE 12
        LOAD_CONST 1
        JUMP 15
        LOAD_CONST 1
        STORE_DEREF 0

        RETURN
        """)

    def test_unless(self, space):
        self.assert_compiles(space, "unless 1 == 2 then puts 5 end", """
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 1
        JUMP_IF_FALSE 20
        LOAD_CONST 3
        JUMP 29
        LOAD_SELF
        LOAD_CONST 4
        SEND 5 1

        RETURN
        """)

        self.assert_compiles(space, """
        unless 0
            a = 4
        end
        a
        """, """
        LOAD_CONST 0
        JUMP_IF_FALSE 12
        LOAD_CONST 1
        JUMP 18
        LOAD_CONST 2
        STORE_DEREF 0
        DISCARD_TOP
        LOAD_DEREF 0

        RETURN
        """)

    def test_named_constants(self, space):
        bc = self.assert_compiles(space, "false; true; nil;", """
        LOAD_CONST 0
        DISCARD_TOP
        LOAD_CONST 1
        DISCARD_TOP
        LOAD_CONST 2

        RETURN
        """)
        assert bc.consts_w == [space.w_false, space.w_true, space.w_nil]

    def test_comparison(self, space):
        self.assert_compiles(space, "1 == 1", """
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 1

        RETURN
        """)

    def test_while(self, space):
        self.assert_compiles(space, "while true do end", """
        SETUP_LOOP 20
        LOAD_CONST 0
        JUMP_IF_FALSE 16
        LOAD_CONST 1
        DISCARD_TOP
        JUMP 3
        POP_BLOCK
        LOAD_CONST 1

        RETURN
        """)

        self.assert_compiles(space, "while true do puts 5 end", """
        SETUP_LOOP 26
        LOAD_CONST 0
        JUMP_IF_FALSE 22
        LOAD_SELF
        LOAD_CONST 1
        SEND 2 1
        DISCARD_TOP
        JUMP 3
        POP_BLOCK
        LOAD_CONST 3

        RETURN
        """)

    def test_for_loop(self, space):
        bc = self.assert_compiles(space, "for a, *$b, @c in [] do end", """
        BUILD_ARRAY 0
        LOAD_CONST 0
        LOAD_CLOSURE 0
        BUILD_BLOCK 1
        SEND_BLOCK 1 1

        RETURN
        """)
        self.assert_compiled(bc.consts_w[0], """
        LOAD_DEREF 0
        DUP_TOP
        COERCE_ARRAY 0
        UNPACK_SEQUENCE_SPLAT 3 1

        STORE_DEREF 1
        DISCARD_TOP

        STORE_GLOBAL 0
        DISCARD_TOP

        LOAD_SELF
        ROT_TWO
        STORE_INSTANCE_VAR 1
        DISCARD_TOP

        RETURN
        """)

    def test_for_loop_over_send_block(self, space):
        self.assert_compiles(space, """
        for k in f { 1 }
          2
        end
        """, """
        LOAD_SELF
        LOAD_CONST 0
        LOAD_CLOSURE 0
        BUILD_BLOCK 1
        SEND_BLOCK 1 1

        LOAD_CONST 2
        LOAD_CLOSURE 0
        BUILD_BLOCK 1
        SEND_BLOCK 3 1

        RETURN
        """)

    def test_until(self, space):
        self.assert_compiles(space, "until false do 5 end", """
        SETUP_LOOP 20
        LOAD_CONST 0
        JUMP_IF_TRUE 16
        LOAD_CONST 1
        DISCARD_TOP
        JUMP 3
        POP_BLOCK
        LOAD_CONST 2

        RETURN
        """)

    def test_return(self, space):
        self.assert_compiles(space, "return 4", """
        LOAD_CONST 0
        RETURN
        # this is unreachable
        RETURN
        """)

    def test_array(self, space):
        bc = self.assert_compiles(space, "[[1], [2], [3]]", """
        LOAD_CONST 0
        BUILD_ARRAY 1
        LOAD_CONST 1
        BUILD_ARRAY 1
        LOAD_CONST 2
        BUILD_ARRAY 1
        BUILD_ARRAY 3

        RETURN
        """)
        assert bc.max_stackdepth == 3

        bc = self.assert_compiles(space, "[1, *[2, 3]]", """
        LOAD_CONST 0
        BUILD_ARRAY 1
        LOAD_CONST 1
        LOAD_CONST 2
        BUILD_ARRAY 2
        COERCE_ARRAY 1
        BUILD_ARRAY_SPLAT 2

        RETURN
        """)

    def test_subscript(self, space):
        self.assert_compiles(space, "[1][0]", """
        LOAD_CONST 0
        BUILD_ARRAY 1
        LOAD_CONST 1
        SEND 2 1

        RETURN
        """)

        self.assert_compiles(space, "i = 0; self[i].to_s", """
        LOAD_CONST 0
        STORE_DEREF 0
        DISCARD_TOP
        LOAD_SELF
        LOAD_DEREF 0
        SEND 1 1
        SEND 2 0

        RETURN
        """)

    def test_def_function(self, space):
        bc = self.assert_compiles(space, "def f() end", """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION

        RETURN
        """)

        self.assert_compiled(bc.consts_w[1], """
        LOAD_CONST 0
        RETURN
        """)

        bc = self.assert_compiles(space, "def f(a, b) a + b end", """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION

        RETURN
        """)

        self.assert_compiled(bc.consts_w[1], """
        LOAD_DEREF 0
        LOAD_DEREF 1
        SEND 0 1
        RETURN
        """)

    def test_string(self, space):
        self.assert_compiles(space, '"abc"', """
        LOAD_CONST 0
        COERCE_STRING

        RETURN
        """)

    def test_dynamic_string(self, space):
        self.assert_compiles(space, """
        x = 123
        "abc, #{x}, easy"
        """, """
        LOAD_CONST 0
        STORE_DEREF 0
        DISCARD_TOP
        LOAD_CONST 1
        COERCE_STRING
        LOAD_DEREF 0
        SEND 2 0
        LOAD_CONST 3
        COERCE_STRING
        BUILD_STRING 3

        RETURN
        """)

    def test_dynamic_symbol(self, space):
        self.assert_compiles(space, ':"#{2}"', """
        LOAD_CONST 0
        SEND 1 0
        SEND 2 0

        RETURN
        """)

    def test_class(self, space):
        bc = self.assert_compiles(space, """
        class X
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_CLASS
        LOAD_CONST 2
        EVALUATE_MODULE

        RETURN
        """)

        self.assert_compiled(bc.consts_w[2], """
        LOAD_CONST 0
        RETURN
        """)

        bc = self.assert_compiles(space, """
        class X
            def m
                2
            end
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_CLASS
        LOAD_CONST 2
        EVALUATE_MODULE

        RETURN
        """)

        self.assert_compiled(bc.consts_w[2], """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION

        RETURN
        """)

        self.assert_compiled(bc.consts_w[2].consts_w[1], """
        LOAD_CONST 0
        RETURN
        """)

        self.assert_compiles(space, """
        class X < Object
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_SCOPE
        LOAD_LOCAL_CONSTANT 1
        BUILD_CLASS
        LOAD_CONST 2
        EVALUATE_MODULE

        RETURN
        """)

        self.assert_compiles(space, """
        class ::X
        end
        """, """
        LOAD_CONST 0
        LOAD_CONST 1
        LOAD_CONST 2
        BUILD_CLASS
        LOAD_CONST 3
        EVALUATE_MODULE

        RETURN
        """)

    def test_singleton_class(self, space):
        self.assert_compiles(space, """
        class << self
        end
        """, """
        LOAD_SELF
        LOAD_SINGLETON_CLASS
        LOAD_CONST 0
        EVALUATE_MODULE

        RETURN
        """)

    def test_constants(self, space):
        self.assert_compiles(space, "Abc", """
        LOAD_SCOPE
        LOAD_LOCAL_CONSTANT 0

        RETURN
        """)

        self.assert_compiles(space, "Abc = 5", """
        LOAD_SCOPE
        LOAD_CONST 0
        STORE_CONSTANT 1

        RETURN
        """)

    def test_self(self, space):
        self.assert_compiles(space, "return self", """
        LOAD_SELF
        RETURN
        # this is unreachable
        RETURN
        """)

    def test_instance_variable(self, space):
        self.assert_compiles(space, "@a = @b", """
        LOAD_SELF
        LOAD_SELF
        LOAD_INSTANCE_VAR 0
        STORE_INSTANCE_VAR 1

        RETURN
        """)

    def test_class_variables(self, space):
        self.assert_compiles(space, "@@a = @@b", """
        LOAD_SCOPE
        LOAD_SCOPE
        LOAD_CLASS_VAR 0
        STORE_CLASS_VAR 1

        RETURN
        """)

    def test_send_block(self, space):
        bc = self.assert_compiles(space, """
        [1, 2, 3].map do |x|
            x * 2
        end
        """, """
        LOAD_CONST 0
        LOAD_CONST 1
        LOAD_CONST 2
        BUILD_ARRAY 3
        LOAD_CONST 3
        BUILD_BLOCK 0
        SEND_BLOCK 4 1

        RETURN
        """)

        self.assert_compiled(bc.consts_w[3], """
        LOAD_DEREF 0
        LOAD_CONST 0
        SEND 1 1
        RETURN
        """)

    def test_yield(self, space):
        bc = self.assert_compiles(space, """
        def f a
            yield
            yield 4
            yield 4, 5
            yield *a
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION

        RETURN
        """)

        self.assert_compiled(bc.consts_w[1], """
        YIELD 0
        DISCARD_TOP
        LOAD_CONST 0
        YIELD 1
        DISCARD_TOP
        LOAD_CONST 1
        LOAD_CONST 2
        YIELD 2
        DISCARD_TOP
        LOAD_DEREF 0
        COERCE_ARRAY 1
        YIELD_SPLAT 1
        RETURN
        """)

    def test_constant_symbol(self, space):
        bc = self.assert_compiles(space, ":abc", """
        LOAD_CONST 0

        RETURN
        """)
        [c] = bc.consts_w
        assert space.symbol_w(c) == "abc"

    def test_range(self, space):
        self.assert_compiles(space, "1..10", """
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_RANGE

        RETURN
        """)
        self.assert_compiles(space, "1...10", """
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_RANGE_EXCLUSIVE

        RETURN
        """)

    def test_block_scope(self, space):
        bc = self.assert_compiles(space, """
        x = 5
        [].each do
            x
        end
        """, """
        LOAD_CONST 0
        STORE_DEREF 0
        DISCARD_TOP

        BUILD_ARRAY 0
        LOAD_CONST 1
        LOAD_CLOSURE 0
        BUILD_BLOCK 1
        SEND_BLOCK 2 1

        RETURN
        """)
        assert bc.max_stackdepth == 3
        self.assert_compiled(bc.consts_w[1], """
        LOAD_DEREF 0
        RETURN
        """)

        bc = self.assert_compiles(space, """
        x = nil
        [].each do |y|
            x = y
        end
        """, """
        LOAD_CONST 0
        STORE_DEREF 0
        DISCARD_TOP

        BUILD_ARRAY 0
        LOAD_CONST 1
        LOAD_CLOSURE 0
        BUILD_BLOCK 1
        SEND_BLOCK 2 1

        RETURN
        """)
        self.assert_compiled(bc.consts_w[1], """
        LOAD_DEREF 0
        STORE_DEREF 1
        RETURN
        """)

    def test_multiple_blocks(self, space):
        bc = self.assert_compiles(space, """
        def f obj
            g { obj }
            g { obj }
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION

        RETURN
        """)
        self.assert_compiled(bc.consts_w[1], """
        LOAD_SELF
        LOAD_CONST 0
        LOAD_CLOSURE 0
        BUILD_BLOCK 1
        SEND_BLOCK 1 1
        DISCARD_TOP
        LOAD_SELF
        LOAD_CONST 2
        LOAD_CLOSURE 0
        BUILD_BLOCK 1
        SEND_BLOCK 1 1
        RETURN
        """)

    def test_multiple_blocks_in_block(self, space):
        bc = self.assert_compiles(space, """
        f {
            x = 2
            g { x }
            g { x }
        }
        """, """
        LOAD_SELF
        LOAD_CONST 0
        BUILD_BLOCK 0
        SEND_BLOCK 1 1

        RETURN
        """)
        self.assert_compiled(bc.consts_w[0], """
        LOAD_CONST 0
        STORE_DEREF 0
        DISCARD_TOP

        LOAD_SELF
        LOAD_CONST 1
        LOAD_CLOSURE 0
        BUILD_BLOCK 1
        SEND_BLOCK 2 1
        DISCARD_TOP

        LOAD_SELF
        LOAD_CONST 3
        LOAD_CLOSURE 0
        BUILD_BLOCK 1
        SEND_BLOCK 2 1
        RETURN
        """)
        self.assert_compiled(bc.consts_w[0].consts_w[1], """
        LOAD_DEREF 0
        RETURN
        """)
        self.assert_compiled(bc.consts_w[0].consts_w[3], """
        LOAD_DEREF 0
        RETURN
        """)

    def test_method_assignment(self, space):
        bc = self.assert_compiles(space, "self.abc = 3", """
        LOAD_SELF
        LOAD_CONST 0
        SEND 1 1

        RETURN
        """)
        assert space.symbol_w(bc.consts_w[1]) == "abc="

    def test_parameter_is_cell(self, space):
        bc = self.assert_compiles(space, """
        def sum(arr, start)
            arr.each do |x|
                start = start + x
            end
            start
        end

        sum([], 0)
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION
        DISCARD_TOP

        LOAD_SELF
        BUILD_ARRAY 0
        LOAD_CONST 2
        SEND 0 2

        RETURN
        """)

        self.assert_compiled(bc.consts_w[1], """
        LOAD_DEREF 0
        LOAD_CONST 0
        LOAD_CLOSURE 0
        LOAD_CLOSURE 1
        BUILD_BLOCK 2
        SEND_BLOCK 1 1
        DISCARD_TOP
        LOAD_DEREF 1
        RETURN
        """)
        self.assert_compiled(bc.consts_w[1].consts_w[0], """
        LOAD_DEREF 1
        LOAD_DEREF 0
        SEND 0 1
        STORE_DEREF 1
        RETURN
        """)

    def test_augmented_assignment(self, space):
        self.assert_compiles(space, "i = 0; i += 1", """
        LOAD_CONST 0
        STORE_DEREF 0
        DISCARD_TOP

        LOAD_DEREF 0
        LOAD_CONST 1
        SEND 2 1
        STORE_DEREF 0

        RETURN
        """)

        bc = self.assert_compiles(space, "self.x.y += 1", """
        LOAD_SELF
        SEND 0 0
        DUP_TOP
        SEND 1 0
        LOAD_CONST 2
        SEND 3 1
        SEND 4 1

        RETURN
        """)
        assert space.symbol_w(bc.consts_w[0]) == "x"
        assert space.symbol_w(bc.consts_w[1]) == "y"
        assert space.symbol_w(bc.consts_w[3]) == "+"
        assert space.symbol_w(bc.consts_w[4]) == "y="

        self.assert_compiles(space, "@a += 2", """
        LOAD_SELF
        DUP_TOP
        LOAD_INSTANCE_VAR 0
        LOAD_CONST 1
        SEND 2 1
        STORE_INSTANCE_VAR 0

        RETURN
        """)

    def test_multiple_cells(self, space):
        bc = self.assert_compiles(space, """
        i = 0
        j = 0
        k = 0
        [].each do |x|
            i + j + k + x
        end
        """, """
        LOAD_CONST 0
        STORE_DEREF 0
        DISCARD_TOP

        LOAD_CONST 1
        STORE_DEREF 1
        DISCARD_TOP

        LOAD_CONST 2
        STORE_DEREF 2
        DISCARD_TOP

        BUILD_ARRAY 0
        LOAD_CONST 3
        LOAD_CLOSURE 2
        LOAD_CLOSURE 1
        LOAD_CLOSURE 0
        BUILD_BLOCK 3
        SEND_BLOCK 4 1

        RETURN
        """)

        self.assert_compiled(bc.consts_w[3], """
        LOAD_DEREF 1
        LOAD_DEREF 2
        SEND 0 1
        LOAD_DEREF 3
        SEND 0 1
        LOAD_DEREF 0
        SEND 0 1
        RETURN
        """)

    def test_nested_block(self, space):
        bc = self.assert_compiles(space, """
        sums = []
        [].each do |x|
            [].each do |y|
                sums << x + y
            end
        end
        """, """
        BUILD_ARRAY 0
        STORE_DEREF 0
        DISCARD_TOP

        BUILD_ARRAY 0
        LOAD_CONST 0
        LOAD_CLOSURE 0
        BUILD_BLOCK 1
        SEND_BLOCK 1 1

        RETURN
        """)
        assert bc.freevars == []
        assert bc.cellvars == ["sums"]

        self.assert_compiled(bc.consts_w[0], """
        BUILD_ARRAY 0
        LOAD_CONST 0
        LOAD_CLOSURE 0
        LOAD_CLOSURE 1
        BUILD_BLOCK 2
        SEND_BLOCK 1 1
        RETURN
        """)
        assert bc.consts_w[0].freevars == ["sums"]
        assert bc.consts_w[0].cellvars == ["x"]

        self.assert_compiled(bc.consts_w[0].consts_w[0], """
        LOAD_DEREF 1
        LOAD_DEREF 2
        LOAD_DEREF 0
        SEND 0 1
        SEND 1 1
        RETURN
        """)
        assert bc.consts_w[0].consts_w[0].freevars == ["sums", "x"]
        assert bc.consts_w[0].consts_w[0].cellvars == ["y"]

    def test_unary_op(self, space):
        bc = self.assert_compiles(space, "(-a)", """
        LOAD_SELF
        SEND 0 0
        SEND 1 0

        RETURN
        """)
        [_, sym] = bc.consts_w
        assert space.symbol_w(sym) == "-@"

        bc = self.assert_compiles(space, "~3", """
        LOAD_CONST 0
        SEND 1 0

        RETURN
        """)
        [_, sym] = bc.consts_w
        assert space.symbol_w(sym) == "~"

    def test_assignment_in_block_closure(self, space):
        bc = self.assert_compiles(space, """
        [].each do
            x = 3
            [].each do
                x
            end
        end
        """, """
        BUILD_ARRAY 0
        LOAD_CONST 0
        BUILD_BLOCK 0
        SEND_BLOCK 1 1

        RETURN
        """)
        self.assert_compiled(bc.consts_w[0], """
        LOAD_CONST 0
        STORE_DEREF 0
        DISCARD_TOP
        BUILD_ARRAY 0
        LOAD_CONST 1
        LOAD_CLOSURE 0
        BUILD_BLOCK 1
        SEND_BLOCK 2 1
        RETURN
        """)
        self.assert_compiled(bc.consts_w[0].consts_w[1], """
        LOAD_DEREF 0
        RETURN
        """)

    def test_lookup_constant(self, space):
        self.assert_compiles(space, "Module::Constant", """
        LOAD_SCOPE
        LOAD_LOCAL_CONSTANT 0
        LOAD_CONSTANT 1

        RETURN
        """)
        self.assert_compiles(space, "Module::constant", """
        LOAD_SCOPE
        LOAD_LOCAL_CONSTANT 0
        SEND 1 0

        RETURN
        """)
        bc = self.assert_compiles(space, "::Constant", """
        LOAD_CONST 0
        LOAD_CONSTANT 1

        RETURN
        """)
        assert bc.consts_w[0] is space.w_object

    def test_assign_constant(self, space):
        self.assert_compiles(space, "abc::Constant = 5", """
        LOAD_SELF
        SEND 0 0
        LOAD_CONST 1
        STORE_CONSTANT 2

        RETURN
        """)

    def test___FILE__(self, space):
        self.assert_compiles(space, "__FILE__", """
        LOAD_CODE
        SEND 0 0

        RETURN
        """)

    def test_default_argument(self, space):
        bc = self.assert_compiles(space, """
        def f(a, b=3, c=b)
            [a, b, c]
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION

        RETURN
        """)

        self.assert_compiled(bc.consts_w[1], """
        LOAD_DEREF 0
        LOAD_DEREF 1
        LOAD_DEREF 2
        BUILD_ARRAY 3
        RETURN
        """)

        self.assert_compiled(bc.consts_w[1].defaults[0], """
        LOAD_CONST 0
        RETURN
        """)
        self.assert_compiled(bc.consts_w[1].defaults[1], """
        LOAD_DEREF 1
        RETURN
        """)

    def test_exceptions(self, space):
        self.assert_compiles(space, """
        begin
            1 / 0
        rescue ZeroDivisionError
            puts "zero!"
        end
        """, """
        SETUP_EXCEPT 18
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 1
        POP_BLOCK
        JUMP 51
        DUP_TOP
        LOAD_SCOPE
        LOAD_LOCAL_CONSTANT 3
        ROT_TWO
        SEND 4 1
        JUMP_IF_TRUE 35
        JUMP 50
        DISCARD_TOP
        DISCARD_TOP
        LOAD_SELF
        LOAD_CONST 5
        COERCE_STRING
        SEND 6 1
        JUMP 55
        END_FINALLY
        LOAD_CONST 7
        DISCARD_TOP

        RETURN
        """)
        self.assert_compiles(space, """
        begin
            1 / 0
        rescue ZeroDivisionError => e
            puts e
        end
        """, """
        SETUP_EXCEPT 18
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 1
        POP_BLOCK
        JUMP 53
        DUP_TOP
        LOAD_SCOPE
        LOAD_LOCAL_CONSTANT 3
        ROT_TWO
        SEND 4 1
        JUMP_IF_TRUE 35
        JUMP 52
        STORE_DEREF 0
        DISCARD_TOP
        DISCARD_TOP
        LOAD_SELF
        LOAD_DEREF 0
        SEND 5 1
        JUMP 57
        END_FINALLY
        LOAD_CONST 6
        DISCARD_TOP

        RETURN
        """)

        self.assert_compiles(space, """
        begin
            1 / 0
        rescue
            5
        end
        """, """
        SETUP_EXCEPT 18
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 1
        POP_BLOCK
        JUMP 27
        DISCARD_TOP
        DISCARD_TOP
        LOAD_CONST 3
        JUMP 31
        END_FINALLY
        LOAD_CONST 4
        DISCARD_TOP

        RETURN
        """)
        self.assert_compiles(space, """
        begin
            1 / 0
        ensure
            puts "ensure"
        end
        """, """
        SETUP_FINALLY 18
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 1
        POP_BLOCK
        LOAD_CONST 3
        LOAD_SELF
        LOAD_CONST 4
        COERCE_STRING
        SEND 5 1
        DISCARD_TOP
        END_FINALLY

        RETURN
        """)

        self.assert_compiles(space, """
        begin
            1 / 0
        else
            10
        end
        """, """
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 1
        JUMP 14
        LOAD_CONST 3
        DISCARD_TOP

        RETURN
        """)

    def test_ensure(self, space):
        bc = self.assert_compiles(space, """
        begin
        ensure
            nil
        end
        """, """
        SETUP_FINALLY 10
        LOAD_CONST 0
        POP_BLOCK
        LOAD_CONST 0
        LOAD_CONST 0
        DISCARD_TOP
        END_FINALLY

        RETURN
        """)
        assert bc.max_stackdepth == 4

    def test_block_argument(self, space):
        bc = self.assert_compiles(space, """
        def f(a, &b)
            b
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION

        RETURN
        """)

        w_code = bc.consts_w[1]
        assert w_code.cellvars == ["a", "b"]
        assert w_code.block_arg_pos == 1

    def test_module(self, space):
        bc = self.assert_compiles(space, """
        module M
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        BUILD_MODULE
        LOAD_CONST 1
        EVALUATE_MODULE

        RETURN
        """)

        self.assert_compiled(bc.consts_w[1], """
        LOAD_CONST 0
        RETURN
        """)

        self.assert_compiles(space, """
        module ::M
        end
        """, """
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_MODULE
        LOAD_CONST 2
        EVALUATE_MODULE

        RETURN
        """)

    def test_splat_send(self, space):
        self.assert_compiles(space, """
        puts *1, 2, 3, *x
        """, """
        LOAD_SELF
        LOAD_CONST 0
        COERCE_ARRAY 1
        LOAD_CONST 1
        BUILD_ARRAY 1
        LOAD_CONST 2
        BUILD_ARRAY 1
        LOAD_SELF
        SEND 3 0
        COERCE_ARRAY 1
        SEND_SPLAT 4 4

        RETURN
        """)

    def test_block_splat_send(self, space):
        self.assert_compiles(space, """
        f(*x) { |a| a }
        """, """
        LOAD_SELF
        LOAD_SELF
        SEND 0 0
        COERCE_ARRAY 1
        LOAD_CONST 1
        BUILD_BLOCK 0
        SEND_BLOCK_SPLAT 2 2

        RETURN
        """)

    def test_singleton_method(self, space):
        self.assert_compiles(space, """
        def Array.hello
            "hello world"
        end
        """, """
        LOAD_SCOPE
        LOAD_LOCAL_CONSTANT 0
        LOAD_CONST 1
        LOAD_CONST 1
        LOAD_CONST 2
        BUILD_FUNCTION
        ATTACH_FUNCTION

        RETURN
        """)

    def test_stack_depth_default_arg(self, space):
        bc = self.assert_compiles(space, """
        def f(a=1/2)
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION

        RETURN
        """)
        assert bc.consts_w[1].max_stackdepth == 2

    def test_global_variable(self, space):
        self.assert_compiles(space, """
        $abc = 3
        $abc
        $abc += 1
        """, """
        LOAD_CONST 0
        STORE_GLOBAL 1
        DISCARD_TOP
        LOAD_GLOBAL 1
        DISCARD_TOP
        LOAD_GLOBAL 1
        LOAD_CONST 2
        SEND 3 1
        STORE_GLOBAL 1

        RETURN
        """)

    def test_send_block_argument(self, space):
        self.assert_compiles(space, """
        f(&b)
        """, """
        LOAD_SELF
        LOAD_SELF
        SEND 0 0
        COERCE_BLOCK
        SEND_BLOCK 1 1

        RETURN
        """)

    def test_declare_splat_argument(self, space):
        bc = self.assert_compiles(space, """
        def f(*args)
            args
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION

        RETURN
        """)
        self.assert_compiled(bc.consts_w[1], """
        LOAD_DEREF 0
        RETURN
        """)

        bc = self.assert_compiles(space, """
        def f(*args)
            return lambda { args }
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION

        RETURN
        """)
        self.assert_compiled(bc.consts_w[1], """
        LOAD_SELF
        LOAD_CONST 0
        LOAD_CLOSURE 0
        BUILD_BLOCK 1
        SEND_BLOCK 1 1
        RETURN
        RETURN
        """)

    def test_regexp(self, space):
        self.assert_compiles(space, "/a/", """
        LOAD_CONST 0

        RETURN
        """)

    def test_dynamic_regexp(self, space):
        self.assert_compiles(space, "/#{2}/", """
        LOAD_CONST 0
        SEND 1 0
        LOAD_CONST 2
        BUILD_REGEXP

        RETURN
        """)

    def test_or(self, space):
        self.assert_compiles(space, "3 + 4 || 5 * 6", """
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 1
        DUP_TOP
        JUMP_IF_TRUE 27
        DISCARD_TOP
        LOAD_CONST 3
        LOAD_CONST 4
        SEND 5 1

        RETURN
        """)

    def test_and(self, space):
        self.assert_compiles(space, "3 + 4 && 5 * 6", """
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 1
        DUP_TOP
        JUMP_IF_FALSE 27
        DISCARD_TOP
        LOAD_CONST 3
        LOAD_CONST 4
        SEND 5 1

        RETURN
        """)

    def test_not(self, space):
        self.assert_compiles(space, "!3", """
        LOAD_CONST 0
        SEND 1 0

        RETURN
        """)

    def test_subscript_assignment(self, space):
        self.assert_compiles(space, "self[3] = 5", """
        LOAD_SELF
        LOAD_CONST 0
        BUILD_ARRAY 1
        LOAD_CONST 1
        BUILD_ARRAY 1
        SEND_SPLAT 2 2

        RETURN
        """)
        self.assert_compiles(space, "self[3] += 1", """
        LOAD_SELF
        LOAD_CONST 0
        BUILD_ARRAY 1
        DUP_TWO
        SEND_SPLAT 1 1
        LOAD_CONST 2
        SEND 3 1
        BUILD_ARRAY 1
        SEND_SPLAT 4 2

        RETURN
        """)

    def test_case(self, space):
        self.assert_compiles(space, """
        case self
        when 5
            6
        when self
            76
        end
        """, """
        LOAD_SELF
        DUP_TOP
        LOAD_CONST 0
        ROT_TWO
        SEND 1 1
        JUMP_IF_TRUE 17
        JUMP 24
        DISCARD_TOP
        LOAD_CONST 2
        JUMP 49
        DUP_TOP
        LOAD_SELF
        ROT_TWO
        SEND 1 1
        JUMP_IF_TRUE 38
        JUMP 45
        DISCARD_TOP
        LOAD_CONST 3
        JUMP 49
        DISCARD_TOP
        LOAD_CONST 4

        RETURN
        """)

        self.assert_compiles(space, """
        case 4
        when 5, 6
            7
        end
        """, """
        LOAD_CONST 0
        DUP_TOP
        LOAD_CONST 1
        ROT_TWO
        SEND 2 1
        JUMP_IF_TRUE 32
        DUP_TOP
        LOAD_CONST 3
        ROT_TWO
        SEND 2 1
        JUMP_IF_TRUE 32
        JUMP 39
        DISCARD_TOP
        LOAD_CONST 4
        JUMP 43
        DISCARD_TOP
        LOAD_CONST 5

        RETURN
        """)

    def test_hash(self, space):
        self.assert_compiles(space, "{}", """
        BUILD_HASH

        RETURN
        """)
        self.assert_compiles(space, "{:abc => 4}", """
        BUILD_HASH
        DUP_TOP
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 2
        DISCARD_TOP

        RETURN
        """)
        self.assert_compiles(space, "{:abc => 4, :def => 5}", """
        BUILD_HASH
        DUP_TOP
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 2
        DISCARD_TOP
        DUP_TOP
        LOAD_CONST 3
        LOAD_CONST 4
        SEND 2 2
        DISCARD_TOP

        RETURN
        """)

    def test_or_equal(self, space):
        self.assert_compiles(space, "@a ||= 4", """
        LOAD_SELF
        DUP_TOP
        LOAD_INSTANCE_VAR 0
        DUP_TOP
        JUMP_IF_TRUE 13
        DISCARD_TOP
        LOAD_CONST 1
        STORE_INSTANCE_VAR 0

        RETURN
        """)

        self.assert_compiles(space, "Const ||= 3", """
        LOAD_SCOPE
        DUP_TOP
        LOAD_LOCAL_CONSTANT 0
        DUP_TOP
        JUMP_IF_TRUE 13
        DISCARD_TOP
        LOAD_CONST 1
        STORE_CONSTANT 0

        RETURN
        """)

    def test_and_equal(self, space):
        self.assert_compiles(space, "@a &&= 4", """
        LOAD_SELF
        DUP_TOP
        LOAD_INSTANCE_VAR 0
        DUP_TOP
        JUMP_IF_FALSE 13
        DISCARD_TOP
        LOAD_CONST 1
        STORE_INSTANCE_VAR 0

        RETURN
        """)

    def test_block_return(self, space):
        bc = self.assert_compiles(space, "f { return 5 }", """
        LOAD_SELF
        LOAD_CONST 0
        BUILD_BLOCK 0
        SEND_BLOCK 1 1

        RETURN
        """)

        self.assert_compiled(bc.consts_w[0], """
        LOAD_CONST 0
        RAISE_RETURN
        RETURN
        """)

    def test_multi_assignment(self, space):
        self.assert_compiles(space, """
        a = b = c = d = nil
        a.x, b[:idx], c::Const, d = 3
        """, """
        LOAD_CONST 0
        STORE_DEREF 0
        STORE_DEREF 1
        STORE_DEREF 2
        STORE_DEREF 3
        DISCARD_TOP

        LOAD_CONST 1
        DUP_TOP
        COERCE_ARRAY 0
        UNPACK_SEQUENCE 4

        LOAD_DEREF 3
        ROT_TWO
        SEND 2 1
        DISCARD_TOP

        LOAD_DEREF 2
        LOAD_CONST 3
        BUILD_ARRAY 1
        ROT_THREE
        ROT_THREE
        BUILD_ARRAY 1
        SEND_SPLAT 4 2
        DISCARD_TOP

        LOAD_DEREF 1
        ROT_TWO
        STORE_CONSTANT 5
        DISCARD_TOP

        STORE_DEREF 0
        DISCARD_TOP

        RETURN
        """)

    def test_splat_assignment(self, space):
        self.assert_compiles(space, """
        a, *b, c = 1, 2, 3
        """, """
        LOAD_CONST 0
        LOAD_CONST 1
        LOAD_CONST 2
        BUILD_ARRAY 3
        DUP_TOP
        COERCE_ARRAY 0
        UNPACK_SEQUENCE_SPLAT 3 1

        STORE_DEREF 0
        DISCARD_TOP
        STORE_DEREF 1
        DISCARD_TOP
        STORE_DEREF 2
        DISCARD_TOP

        RETURN
        """)

    def test_discard_splat_assignment(self, space):
        self.assert_compiles(space, """
        * = 1, 2
        """, """
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_ARRAY 2
        DUP_TOP
        COERCE_ARRAY 0
        UNPACK_SEQUENCE_SPLAT 1 0
        DISCARD_TOP

        RETURN
        """)

    def test_alias(self, space):
        bc = self.assert_compiles(space, """
        alias a b
        10
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 1
        SEND 2 2
        DISCARD_TOP

        LOAD_CONST 3

        RETURN
        """)
        [w_a, w_b, w_alias_method, _] = bc.consts_w
        assert space.symbol_w(w_a) == "a"
        assert space.symbol_w(w_b) == "b"
        assert space.symbol_w(w_alias_method) == "alias_method"

    def test_defined(self, space):
        self.assert_compiles(space, """
        defined? Const
        defined? @a
        defined? nil.nil?
        """, """
        LOAD_SCOPE
        DEFINED_LOCAL_CONSTANT 0
        DISCARD_TOP

        LOAD_SELF
        DEFINED_INSTANCE_VAR 1
        DISCARD_TOP

        LOAD_CONST 2
        DEFINED_METHOD 3

        RETURN
        """)

    def test_super(self, space):
        bc = self.assert_compiles(space, """
        super
        """, """
        LOAD_SELF
        LOAD_BLOCK
        SEND_SUPER_BLOCK 0 1

        RETURN
        """)
        assert bc.consts_w[0] is space.w_nil

        bc = self.assert_compiles(space, """
        def f(a, b, c)
            super
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION

        RETURN
        """)
        self.assert_compiled(bc.consts_w[1], """
        LOAD_SELF
        LOAD_DEREF 0
        LOAD_DEREF 1
        LOAD_DEREF 2
        LOAD_BLOCK
        SEND_SUPER_BLOCK 0 4
        RETURN
        """)
        assert space.str_w(bc.consts_w[1].consts_w[0]) == "f"

        bc = self.assert_compiles(space, """
        super(1, 2, 3)
        """, """
        LOAD_SELF
        LOAD_CONST 0
        LOAD_CONST 1
        LOAD_CONST 2
        LOAD_BLOCK
        SEND_SUPER_BLOCK 3 4

        RETURN
        """)

        self.assert_compiles(space, """
        super(&:to_a)
        """, """
        LOAD_SELF
        LOAD_CONST 0
        COERCE_BLOCK
        SEND_SUPER_BLOCK 1 1

        RETURN
        """)
        self.assert_compiles(space, """
        super(*1, &:to_a)
        """, """
        LOAD_SELF
        LOAD_CONST 0
        COERCE_ARRAY 1
        LOAD_CONST 1
        COERCE_BLOCK
        SEND_SUPER_BLOCK_SPLAT 2 2

        RETURN
        """)

        self.assert_compiles(space, """
        super { 3 }
        """, """
        LOAD_SELF
        LOAD_CONST 0
        BUILD_BLOCK 0
        SEND_SUPER_BLOCK 1 1

        RETURN
        """)

        bc = self.assert_compiles(space, """
        def f(a, *b)
            super
        end
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        LOAD_CONST 0
        LOAD_CONST 1
        BUILD_FUNCTION
        DEFINE_FUNCTION

        RETURN
        """)
        self.assert_compiled(bc.consts_w[1], """
        LOAD_SELF
        LOAD_DEREF 0
        BUILD_ARRAY 1
        LOAD_DEREF 1
        COERCE_ARRAY 1
        LOAD_BLOCK
        SEND_SUPER_BLOCK_SPLAT 0 3
        RETURN
        """)

    def test_next_block(self, space):
        bc = self.assert_compiles(space, """
        f {
            next 5
            3 + 4
        }
        """, """
        LOAD_SELF
        LOAD_CONST 0
        BUILD_BLOCK 0
        SEND_BLOCK 1 1

        RETURN
        """)

        self.assert_compiled(bc.consts_w[0], """
        LOAD_CONST 0
        RETURN

        LOAD_CONST 1
        LOAD_CONST 2
        SEND 3 1
        RETURN
        """)

    def test_next_loop(self, space):
        self.assert_compiles(space, """
        while true do
            next
            2 + 2
        end
        """, """
        SETUP_LOOP 34
        LOAD_CONST 0
        JUMP_IF_FALSE 30

        LOAD_CONST 1
        CONTINUE_LOOP 3
        LOAD_CONST 2
        LOAD_CONST 3
        SEND 4 1
        DISCARD_TOP
        JUMP 3
        POP_BLOCK
        LOAD_CONST 1

        RETURN
        """)

    def test_break_loop(self, space):
        self.assert_compiles(space, """
        while true
            break 5
        end
        """, """
        SETUP_LOOP 21
        LOAD_CONST 0
        JUMP_IF_FALSE 17

        LOAD_CONST 1
        BREAK_LOOP
        DISCARD_TOP
        JUMP 3
        POP_BLOCK
        LOAD_CONST 2

        RETURN
        """)

    def test_break_block(self, space):
        bc = self.assert_compiles(space, """
        f { break 5 }
        """, """
        LOAD_SELF
        LOAD_CONST 0
        BUILD_BLOCK 0
        SEND_BLOCK 1 1

        RETURN
        """)

        self.assert_compiled(bc.consts_w[0], """
        LOAD_CONST 0
        RAISE_BREAK
        RETURN
        """)

    def test_undef(self, space):
        self.assert_compiles(space, """
        undef to_s
        10
        """, """
        LOAD_SCOPE
        LOAD_CONST 0
        SEND 1 1
        DISCARD_TOP

        LOAD_CONST 2
        RETURN
        """)

    def test_lambda(self, space):
        self.assert_compiles(space, "->{}", """
        LOAD_CONST 0
        BUILD_BLOCK 0
        BUILD_LAMBDA
        RETURN
        """)

########NEW FILE########
__FILENAME__ = test_executioncontext
class TestExecutionContext(object):
    def test_recursion_guard(self, space):
        f = "my_func"
        x = object()
        y = object()
        with space.getexecutioncontext().recursion_guard(f, x) as in_recursion:
            assert not in_recursion
            with space.getexecutioncontext().recursion_guard(f, y) as ir2:
                assert not ir2
                with space.getexecutioncontext().recursion_guard(f, x) as ir3:
                    assert ir3
            with space.getexecutioncontext().recursion_guard(f, x) as ir3:
                assert ir3

########NEW FILE########
__FILENAME__ = test_interpreter
import math

from topaz.objects.moduleobject import W_ModuleObject

from .base import BaseTopazTest


class TestInterpreter(BaseTopazTest):
    def test_add(self, space):
        space.execute("1 + 1")

    def test_global_send(self, space, capfd):
        space.execute("puts 1")
        out, err = capfd.readouterr()
        assert out == "1\n"
        assert not err

    def test_obj_send(self, space):
        w_res = space.execute("return 1.to_s")
        assert space.str_w(w_res) == "1"

    def test_variables(self, space):
        w_res = space.execute("a = 100; return a")
        assert space.int_w(w_res) == 100

    def test_uninitailized_variables(self, space):
        w_res = space.execute("""
        if false
          x = 5
        end
        return x
        """)
        assert w_res is space.w_nil

    def test_uninitialized_closure_var(self, space):
        w_res = space.execute("""
        if false
          x = 3
        end
        proc { x }
        return x
        """)
        assert w_res is space.w_nil

    def test_if(self, space):
        w_res = space.execute("if 3 then return 2 end")
        assert space.int_w(w_res) == 2

        w_res = space.execute("x = if 3 then 5 end; return x")
        assert space.int_w(w_res) == 5

        w_res = space.execute("x = if false then 5 end; return x")
        assert w_res is space.w_nil

        w_res = space.execute("x = if nil then 5 end; return x")
        assert w_res is space.w_nil

        w_res = space.execute("x = if 3 then end; return x")
        assert w_res is space.w_nil

    def test_while(self, space):
        w_res = space.execute("""
        i = 0
        while i < 1
          i += 1
        end
        return i
        """)
        assert space.int_w(w_res) == 1

        w_res = space.execute("""
        x = while false do end
        return x
        """)
        assert w_res is space.w_nil

    def test_for_loop(self, space):
        w_res = space.execute("""
        i = 0
        for i, *rest, b in [1, 2, 3] do
          bbb = "hello"
        end
        return i, bbb, rest, b
        """)
        assert self.unwrap(space, w_res) == [3, "hello", [], None]

        w_res = space.execute("""
        i = 0
        for i, *rest, b in [[1, 2, 3, 4]] do
          bbb = "hello"
        end
        return i, bbb, rest, b
        """)
        assert self.unwrap(space, w_res) == [1, "hello", [2, 3], 4]

        w_res = space.execute("""
        for i, *$c, @a in [[1, 2, 3, 4]] do
          bbb = "hello"
        end
        return i, bbb, $c, @a
        """)
        assert self.unwrap(space, w_res) == [1, "hello", [2, 3], 4]

        with self.raises(space, "NoMethodError", "undefined method `each' for Fixnum"):
            space.execute("for i in 1; end")

        w_res = space.execute("""
        class A
          def each
            [1, 2, 3]
          end
        end
        for i in A.new; end
        return i
        """)
        assert self.unwrap(space, w_res) is None

        w_res = space.execute("""
        a = []
        i = 0
        for a[i], i in [[1, 1], [2, 2]]; end
        return a, i
        """)
        assert self.unwrap(space, w_res) == [[1, 2], 2]

        w_res = space.execute("""
        for i in [[1, 1]]; end
        for j, in [[1, 1]]; end
        return i, j
        """)
        assert self.unwrap(space, w_res) == [[1, 1], 1]

        w_res = space.execute("""
        i = 15
        for i in []; end
        return i
        """)
        assert self.unwrap(space, w_res) == 15

        w_res = space.execute("""
        for a.bar in []; end
        return defined?(a)
        """)
        assert self.unwrap(space, w_res) is None

        w_res = space.execute("""
        for a.bar in []; end
        for b[i] in []; end
        return defined?(a), defined?(b), defined?(i)
        """)
        assert self.unwrap(space, w_res) == [None, None, None]

    def test_return(self, space):
        w_res = space.execute("return 4")
        assert space.int_w(w_res) == 4

    def test_array(self, space):
        w_res = space.execute("return [[1], [2], [3]]")
        assert self.unwrap(space, w_res) == [[1], [2], [3]]

    def test_def_function(self, space):
        w_res = space.execute("return def f() end")
        assert w_res is space.w_nil

        w_res = space.execute("""
        def f(a, b)
          a + b
        end
        return f 1, 2
        """)
        assert space.int_w(w_res) == 3
        w_res = space.execute("return Object.f(5, -2)")
        assert space.int_w(w_res) == 3

    def test_splat_first_in_def_function(self, space):
        w_res = space.execute("""
        def self.f(*a, b, c, &blk)
          a << b << c << blk.call
        end
        return f(2, 3, 'b', 'c') do
          "blk"
        end
        """)
        assert self.unwrap(space, w_res) == [2, 3, 'b', 'c', 'blk']

        w_res = space.execute("""
        def f(*a, b, c, &blk)
          a << b << c << blk.call
        end
        return f(2, 3, 'b', 'c') do
          "blk"
        end
        """)
        assert self.unwrap(space, w_res) == [2, 3, 'b', 'c', 'blk']

    def test_interpreter(self, space):
        w_res = space.execute('return "abc"')
        assert space.str_w(w_res) == "abc"

        w_res = space.execute("""
        def test
          x = ""
          x << "abc"
        end

        return [test, test]
        """)
        assert self.unwrap(space, w_res) == ["abc", "abc"]

    def test_class(self, space):
        w_res = space.execute("""
        class X
          def m
            self
          end

          def f
            2
          end
        end
        """)
        w_cls = space.w_object.constants_w["X"]
        assert w_cls.methods_w.viewkeys() == {"m", "f"}

        w_res = space.execute("""
        class Z < X
          def g
            3
          end
        end

        z = Z.new
        return [z.f, z.g]
        """)
        assert self.unwrap(space, w_res) == [2, 3]

    def test_reopen_class(self, space):
        space.execute("""
        class X
          def f
            3
          end
        end

        class X
          def m
            5
          end
        end
        """)
        w_cls = space.w_object.constants_w["X"]
        assert w_cls.methods_w.viewkeys() == {"m", "f"}

    def test_reopen_non_class(self, space):
        space.execute("""
        X = 12
        """)
        with self.raises(space, "TypeError", "X is not a class"):
            space.execute("""
            class X
            end
            """)

    def test_attach_class_non_module(self, space):
        with self.raises(space, "TypeError", "nil is not a class/module"):
            space.execute("""
            class nil::Foo
            end
            """)

    def test_shadow_class(self, space):
        w_res = space.execute("""
        class X; class Y; end; end

        class A < X
          OLD_Y = Y
          class Y; end
        end
        return A::OLD_Y.object_id == A::Y.object_id, A::OLD_Y.object_id == X::Y.object_id
        """)
        assert self.unwrap(space, w_res) == [False, True]

    def test_class_returnvalue(self, space):
        w_res = space.execute("""
        return (class X
          5
        end)
        """)
        assert space.int_w(w_res) == 5

    def test_singleton_class(self, space):
        w_res = space.execute("""
        class X
          def initialize
            @a = 3
          end
        end

        x = X.new
        class << x
          def m
            6
          end
        end
        return x.m
        """)
        assert space.int_w(w_res) == 6

        with self.raises(space, "NoMethodError"):
            space.execute("X.new.m")

    def test_singleton_class_return_val(self, space):
        w_res = space.execute("""
        class X
        end

        x = X.new
        return (class << x
          5
        end)
        """)
        assert space.int_w(w_res) == 5

    def test_constant(self, space):
        w_res = space.execute("Abc = 3; return Abc")
        assert space.int_w(w_res)

        assert space.w_object.constants_w["Abc"] is w_res

    def test_class_constant(self, space):
        w_res = space.execute("""
        class X
          Constant = 3
          def f
            return Constant
          end
        end
        return X.new.f
        """)
        assert space.int_w(w_res) == 3
        assert "Constant" not in space.w_object.constants_w

    def test_module_constant(self, space):
        w_res = space.execute("""
        ExternalConst = 10
        module Y
          Constant = 5
          OtherConstant = ExternalConst
        end
        return [Y::Constant, Y::OtherConstant]
        """)
        assert self.unwrap(space, w_res) == [5, 10]

    def test_subclass_constant(self, space):
        w_res = space.execute("""
        GlobalConstant = 5
        class X
          Constant = 3
        end
        class Y < X
          def f
            [Constant, GlobalConstant]
          end
        end
        return Y.new.f
        """)
        assert self.unwrap(space, w_res) == [3, 5]

    def test_subclass_non_class(self, space):
        with self.raises(space, "TypeError", "wrong argument type String (expected Class)"):
            space.execute("""
            class Y < "abc"
            end
            """)

    def test_class_constant_block(self, space):
        w_res = space.execute("""
        class X
          Constant = 5
          def f
            (1..3).map do
              Constant
            end
          end
        end
        return X.new.f
        """)
        assert self.unwrap(space, w_res) == [5, 5, 5]

    def test_nonmodule_constant(self, space):
        with self.raises(space, "TypeError", "3 is not a class/module"):
            space.execute("3::Foo")

    def test_instance_var(self, space):
        w_res = space.execute("""
        class X
          def set val
            @a = val
          end
          def get
            @a
          end
        end
        x = X.new
        x.set 3
        x.set "abc"
        return x.get
        """)
        assert space.str_w(w_res) == "abc"

    def test_send_block(self, space):
        w_res = space.execute("""
        res = []
        [1, 2, 3].each do |x|
          res << (x * 2)
        end
        return res
        """)
        assert self.unwrap(space, w_res) == [2, 4, 6]

    def test_send_block_with_block_arg(self, space):
        w_res = space.execute("""
        res = []
        block = proc do |&b|
          [1, 2, 3].each do |x|
            res << b.call(x)
          end
        end
        block.call { |x| 2 * x }
        return res
        """)
        assert self.unwrap(space, w_res) == [2, 4, 6]

    def test_send_block_with_opt_args(self, space):
        w_res = space.execute("""
        res = []
        block = proc { |b='b'| res << b }
        block.call('a')
        block.call
        return res
        """)
        assert self.unwrap(space, w_res) == ['a', 'b']
        w_res = space.execute("""
        res = []
        [1, 2, 3].each do |x, y="y"|
          res << x << y
        end
        return res
        """)
        assert self.unwrap(space, w_res) == [1, 'y', 2, 'y', 3, 'y']
        w_res = space.execute("""
        res = []
        block = proc do |x, y="y", *rest, &block|
          res << x << y << rest
          block.call(res)
        end
        block.call(1) { |res| res << "block called" }
        return res
        """)
        assert self.unwrap(space, w_res) == [1, 'y', [], "block called"]

    def test_yield(self, space):
        w_res = space.execute("""
        class X
          def f
            yield 2, 3
            yield 4, 5
          end
        end

        res = []
        X.new.f do |x, y|
          res << (x - y)
        end
        return res
        """)
        assert self.unwrap(space, w_res) == [-1, -1]

    def test_range(self, space):
        w_res = space.execute("return (1..10).begin")
        assert space.int_w(w_res) == 1
        w_res = space.execute("return (1..10).end")
        assert space.int_w(w_res) == 10
        w_res = space.execute("return (1...10).end")
        assert space.int_w(w_res) == 10

    def test_augmented_assignment(self, space):
        w_res = space.execute("i = 0; i += 5; return i")
        assert space.int_w(w_res) == 5
        w_res = space.execute("""
        class X
          attr_accessor :a
          def initialize
            self.a = 5
          end
        end
        x = X.new
        x.a += 5
        return x.a
        """)
        assert space.int_w(w_res) == 10

        w_res = space.execute("""
        class Counter
          attr_reader :value
          def initialize start
            @value = start
          end
          def incr
            @value += 1
          end
        end

        c = Counter.new 0
        c.incr
        c.incr
        c.incr
        return c.value
        """)
        assert space.int_w(w_res) == 3

    def test_or_equal(self, space):
        w_res = space.execute("""
        x = nil
        x ||= 5
        v = x
        x ||= 3
        return [v, x]
        """)
        assert self.unwrap(space, w_res) == [5, 5]
        w_res = space.execute("""
        x = [nil]
        x[0] ||= 5
        return x
        """)
        assert self.unwrap(space, w_res) == [5]

    def test_lookup_constant(self, space):
        w_res = space.execute("""
        class X
          Constant = 3
        end
        return X::Constant
        """)
        assert space.int_w(w_res) == 3
        w_res = space.execute("""
        class X
          Constant = 3
          def self.constant
            Constant
          end
        end
        return X.constant
        """)
        assert space.int_w(w_res) == 3
        w_res = space.execute("""
        X = 3
        return ::X
        """)
        assert space.int_w(w_res) == 3

    def test___FILE__(self, space):
        w_res = space.execute("return __FILE__")
        assert space.str_w(w_res) == "-e"

    def test___LINE__(self, space):
        w_res = space.execute("""
        return \\
           [__LINE__,
           __LINE__]
        """)
        assert self.unwrap(space, w_res) == [3, 4]

    def test_default_arguments(self, space):
        w_res = space.execute("""
        def f(a, b=3, c=b)
          [a, b, c]
        end
        return f 1
        """)
        assert self.unwrap(space, w_res) == [1, 3, 3]
        w_res = space.execute("return f 5, 6")
        assert self.unwrap(space, w_res) == [5, 6, 6]
        w_res = space.execute("return f 5, 6, 10")
        assert self.unwrap(space, w_res) == [5, 6, 10]

    def test_module(self, space):
        w_res = space.execute("""
        module M
          def oninstanceonly
            5
          end
        end
        return M
        """)
        assert isinstance(w_res, W_ModuleObject)
        assert w_res.name == "M"

        with self.raises(space, "NoMethodError"):
            space.execute("M.oninstanceonly")

    def test_module_reopen_non_module(self, space):
        space.execute("""
        module Foo
          Const = nil
          class X
          end
        end
        """)
        with self.raises(space, "TypeError", "Const is not a module"):
            space.execute("""
            module Foo::Const
            end
            """)
        with self.raises(space, "TypeError", "X is not a module"):
            space.execute("""
            module Foo::X
            end
            """)

    def test_module_reopen_scope(self, space):
        w_res = space.execute("""
        class Foo
        end

        module Bar
          module Foo
          end
        end
        return Foo, Bar::Foo
        """)
        [w_cls1, w_cls2] = space.listview(w_res)
        assert w_cls1 is not w_cls2

    def test_singleton_method(self, space):
        w_res = space.execute("""
        def Array.hello
          "hello world"
        end

        return Array.hello
        """)
        assert space.str_w(w_res) == "hello world"

        with self.raises(space, "NoMethodError"):
            space.execute("[].hello")

    def test_splat(self, space):
        w_res = space.execute("""
        def f(a, b, c, d, e, f)
          [a, b, c, d, e, f]
        end

        return f(*2, *[5, 3], *[], 7, 8, *[1], *nil)
        """)
        assert self.unwrap(space, w_res) == [2, 5, 3, 7, 8, 1]

        w_res = space.execute("""
        class ToA
          def to_a
            [1, 2, 3, 4, 5, 6]
          end
        end

        return f *ToA.new
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3, 4, 5, 6]

        w_res = space.execute("""
        class ToAry
          def to_ary
            [1, 5, 6, 7, 8, 9]
          end
        end

        return f *ToAry.new
        """)
        assert self.unwrap(space, w_res) == [1, 5, 6, 7, 8, 9]

    def test_send_block_splat(self, space):
        w_res = space.execute("""
        def f(a)
          x = yield
          return a + x
        end

        return f(*2) { 5 }
        """)
        assert space.int_w(w_res) == 7
        w_res = space.execute("""
        def f(&a)
          return a
        end
        return f(*[], &nil)
        """)
        assert w_res is space.w_nil

    def test_global_variables(self, space):
        w_res = space.execute("return $abc")
        assert w_res is space.w_nil
        w_res = space.execute("$abc = 3; return $abc")
        assert space.int_w(w_res) == 3

    def test_assign_constant(self, space):
        w_res = space.execute("""
        class X
        end
        X::Constant = 5
        return X::Constant
        """)
        assert space.int_w(w_res) == 5
        with self.raises(space, "NameError"):
            space.execute("Constant")

    def test_receive_splat_argument(self, space):
        w_res = space.execute("""
        def f(*args)
          args
        end

        return f(1, 2, *[3, 4])
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3, 4]

        w_res = space.execute("""
        def f(*args)
          'hi'
        end

        return f(1, 2, *[3, 4])
        """)
        assert self.unwrap(space, w_res) == 'hi'

        w_res = space.execute("""
        def f(h, *)
          h
        end

        return f(1, 2, *[3, 4])
        """)
        assert self.unwrap(space, w_res) == 1

    def test_or(self, space):
        w_res = space.execute("return 3 + 4 || 5")
        assert space.int_w(w_res) == 7
        w_res = space.execute("return nil || 12")
        assert space.int_w(w_res) == 12

    def test_not(self, space):
        w_res = space.execute("return !3")
        assert w_res is space.w_false
        w_res = space.execute("return !!3")
        assert w_res is space.w_true

    def test_subscript_assignment(self, space):
        w_res = space.execute("""
        x = [0]
        x[0] = 5
        return x[0]
        """)
        assert space.int_w(w_res) == 5
        w_res = space.execute("""
        x = [0]
        x[0] += 2
        return x[0]
        """)
        assert space.int_w(w_res) == 2
        w_res = space.execute("""
        x = [0]
        x[*[0]] = 45
        return x[0]
        """)
        assert space.int_w(w_res) == 45

    def test_empty_hash(self, space):
        space.execute("return {}")

    def test_multiple_assignment(self, space):
        w_res = space.execute("""
        a = [3]
        a[0], Object::Const, b = [5, 4]
        return [a, Object::Const, b]
        """)
        assert self.unwrap(space, w_res) == [[5], 4, None]

    def test_splat_assignment(self, space):
        w_res = space.execute("""
        class X
          def to_a
            return nil
          end
        end
        x = X.new
        a = *x
        return a == [x]
        """)
        assert w_res is space.w_true
        w_res = space.execute("""
        *a = nil
        return a
        """)
        assert self.unwrap(space, w_res) == [None]

    def test_splat_lhs_assignment(self, space):
        w_res = space.execute("""
        a, *b, c = *[1,2]
        return [a, b, c]
        """)
        assert self.unwrap(space, w_res) == [1, [], 2]
        w_res = space.execute("""
        a, *b, c = 1,2,3,4
        return [a, b, c]
        """)
        assert self.unwrap(space, w_res) == [1, [2, 3], 4]
        w_res = space.execute("""
        a, *b, c = 1
        return [a, b, c]
        """)
        assert self.unwrap(space, w_res) == [1, [], None]
        w_res = space.execute("""
        a, = 3, 4
        return a
        """)
        assert space.int_w(w_res) == 3

    def test_destructuring_assignment(self, space):
        w_res = space.execute("""
        (a, b, (c, d, *e)) = [1, 2, [3, 4]]
        return a, b, c, d, e
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3, 4, []]
        w_res = space.execute("""
        a, *b, (c, (d, *, e), ) = 1, 2, 3, [4, [5, "ignored", "ignored", 6], 7]
        return a, b, c, d, e
        """)
        assert self.unwrap(space, w_res) == [1, [2, 3], 4, 5, 6]

    def test_minus(self, space):
        w_res = space.execute("""
        def a(x)
          Math.sin(x)
        end
        b = 1
        c = 1
        return [(a -b), (c -b)]
        """)
        assert self.unwrap(space, w_res) == [math.sin(-1), 0]

    def test_case(self, space):
        w_res = space.execute("""
        res = []
        4.times do |i|
          case i
          when 0, 1
            res << 0
          when 2
            res << 1
          else
            res << 2
          end
        end
        return res
        """)
        assert self.unwrap(space, w_res) == [0, 0, 1, 2]

    def test_dynamic_string(self, space):
        w_res = space.execute("""
        x = 123
        return "abc, #{x}, easy"
        """)
        assert space.str_w(w_res) == "abc, 123, easy"

    def test_dynamic_regexp(self, space):
        w_res = space.execute("""
        x = 123
        return /#{x}/.source
        """)
        assert space.str_w(w_res) == "123"

    def test_regexp_sytnax_error(self, space):
        with self.raises(space, "SyntaxError"):
            space.execute("/(/")

    def test_class_variable_from_module_accessed_from_instance_side(self, space):
        w_res = space.execute("""
        module A
          @@foo = 'a'
        end

        class B
          include A

          def get
            @@foo
          end
        end

        return B.new.get
        """)
        assert space.str_w(w_res) == 'a'

    def test_class_variable_accessed_from_instance_side(self, space):
        w_res = space.execute("""
        class A; end
        class B < A
          @@foo = "B"
          def get; @@foo; end
        end
        in_subclass = [B.new.get]
        class A; @@foo = "A overrides all"; end
        return in_subclass + [B.new.get]
        """)
        assert self.unwrap(space, w_res) == ["B", "A overrides all"]

    def test_class_variables_accessed_from_class_side(self, space):
        w_res = space.execute("""
        class A; @@foo = 'A'; end
        class B < A
          def get; @@foo; end
          def self.get; @@foo; end
        end
        return [B.get, B.new.get]
        """)
        assert self.unwrap(space, w_res) == ['A', 'A']

    def test_class_variable_access_has_static_scope(self, space):
        with self.raises(space, "NameError"):
            space.execute("""
            class A
              def get
                @@foo
              end
            end
            class B < A;
              @@foo = "b"
            end
            B.new.get
            """)

    def test_ancestors(self, space):
        w_res = space.execute("""
        class A
        end

        class B < A
        end

        module C
        end

        module D
          include C
        end

        ary = [A.ancestors, B.ancestors, C.ancestors, D.ancestors]

        B.include D
        ary << B.ancestors
        return ary
        """)
        a = self.find_const(space, 'A')
        b = self.find_const(space, 'B')
        c = self.find_const(space, 'C')
        d = self.find_const(space, 'D')
        assert self.unwrap(space, w_res) == [
            [a, space.w_object, space.w_kernel, space.w_basicobject],
            [b, a, space.w_object, space.w_kernel, space.w_basicobject],
            [c],
            [d, c],
            [b, d, c, a, space.w_object, space.w_kernel, space.w_basicobject]
        ]

    def test_lookup_for_includes(self, space):
        w_res = space.execute("""
        class A
          def self.get; "A.get"; end
          def get; "A#get"; end
          def override; "A#override"; end
        end
        module M
          def get; "M#get"; end
          def override; "M#override"; end
        end
        class B < A
          def override; "B#override"; end
          include M
        end
        res = [B.get, B.new.get, B.new.override]
        module M
          def get; "M#get (2nd ed)"; end
        end
        return res << B.new.get
        """)
        assert self.unwrap(space, w_res) == ["A.get", "M#get", "B#override", "M#get (2nd ed)"]

    def test_find_const(self, space):
        with self.raises(space, "NameError"):
            space.execute("""
            class A
              Const = "A"
              class InnerA; end
            end

            class B < A::InnerA
              # Const lookup in superclass does not
              # traverse lexical scope of superclass,
              # and A::InnerA syntax doesn't put B in
              # the lexical scope of A
              Const
            end
            """)

        w_res = space.execute("""
        class A
          Const = "A"
          class InnerA
            InnerConst = Const
          end
        end

        class B < A::InnerA
          BConst = InnerConst
        end
        return B::BConst
        """)
        assert self.unwrap(space, w_res) == "A"

    def test_module_find_const(self, space):
        w_res = space.execute("""
        module M
          ABC = 1
        end
        Object.send :include, M
        module Y
          ABC
        end
        return Y::ABC
        """)
        assert self.unwrap(space, w_res) == 1

    def test_defined(self, space):
        w_res = space.execute("return [defined? A, defined? Array]")
        assert self.unwrap(space, w_res) == [None, "constant"]
        w_res = space.execute("""
        @a = 3
        return [defined? @a, defined? @b]
        """)
        assert self.unwrap(space, w_res) == ["instance-variable", None]
        w_res = space.execute("""
        return [defined? self, defined? nil, defined? true, defined? false]
        """)
        assert self.unwrap(space, w_res) == ["self", "nil", "true", "false"]
        w_res = space.execute("""
        return [defined? nil.nil?, defined? nil.fdfdafa]
        """)
        assert self.unwrap(space, w_res) == ["method", None]
        w_res = space.execute("""
        return [defined? a = 3]
        """)
        assert self.unwrap(space, w_res) == ["assignment"]
        w_res = space.execute("""
        a = 3
        return defined?(a)
        """)
        assert space.str_w(w_res) == "local-variable"
        w_res = space.execute("""
        a = 3
        return defined?((1; a))
        """)
        assert space.str_w(w_res) == "local-variable"
        w_res = space.execute("""
        return defined?((a, b = 3))
        """)
        assert space.str_w(w_res) == "assignment"
        w_res = space.execute("""
        return defined?((a += 2))
        """)
        assert space.str_w(w_res) == "assignment"
        w_res = space.execute("""
        return [defined?((a ||= 2)), defined?((a &&= 3))]
        """)
        assert self.unwrap(space, w_res) == ["assignment", "assignment"]
        w_res = space.execute("""
        return [defined?(3 and false), defined?(false or true)]
        """)
        assert self.unwrap(space, w_res) == ["expression", "expression"]
        w_res = space.execute("""
        return [defined?('abc'), defined?("abc#{42}")]
        """)
        assert self.unwrap(space, w_res) == ["expression", "expression"]
        w_res = space.execute("""
        return [defined?(/abc/), defined?(/abc#{42}/)]
        """)
        assert self.unwrap(space, w_res) == ["expression", "expression"]
        w_res = space.execute("""
        return defined?(1..2)
        """)
        assert space.str_w(w_res) == "expression"
        w_res = space.execute("""
        return defined?([1, 2, 3])
        """)
        assert space.str_w(w_res) == "expression"
        w_res = space.execute("""
        return defined?({1 => 2})
        """)
        assert space.str_w(w_res) == "expression"
        w_res = space.execute("""
        $abc = 3
        return [defined?($abc), defined?($abd)]
        """)
        assert self.unwrap(space, w_res) == ["global-variable", None]
        w_res = space.execute("""
        class A
          @@abc = 3
          def m
            return [defined?(@@abc), defined?(@@abd)]
          end
        end
        return A.new.m
        """)
        assert self.unwrap(space, w_res) == ["class variable", None]
        w_res = space.execute("""
        def f
          defined?(yield)
        end

        return [f, f(&:a)]
        """)
        assert self.unwrap(space, w_res) == [None, "yield"]
        w_res = space.execute("""
        class B
          def a
          end
        end
        class C < B
          def a
            defined?(super)
          end
          def b
            defined?(super())
          end
        end
        return [C.new.a, C.new.b]
        """)
        assert self.unwrap(space, w_res) == ["super", None]

    def test_defined_unscoped_constant(self, space):
        w_res = space.execute("return defined? ::Foobar")
        assert w_res is space.w_nil
        w_res = space.execute("return defined? ::Fixnum")
        assert self.unwrap(space, w_res) == "constant"

    def test_match(self, space):
        w_res = space.execute("return 3 =~ nil")
        assert self.unwrap(space, w_res) is None

    def test_not_match(self, space):
        w_res = space.execute("return 3 !~ nil")
        assert self.unwrap(space, w_res)

    def test_super(self, space):
        w_res = space.execute("""
        class A
          def f(a, b)
            return [a, b]
          end
        end
        class B < A
          def f(a, b)
            a += 10
            return super
          end
        end
        return B.new.f(4, 5)
        """)
        assert self.unwrap(space, w_res) == [14, 5]

        w_res = space.execute("""
        class C < A
          def f
            super(*[1, 2])
          end
        end
        return C.new.f
        """)
        assert self.unwrap(space, w_res) == [1, 2]

    def test_super_block(self, space):
        w_res = space.execute("""
        class A
          def f a
            a + yield
          end
        end

        class B < A
          def f
            super(2) { 5 }
          end
        end

        return B.new.f
        """)
        assert space.int_w(w_res) == 7
        w_res = space.execute("""
        class C < A
          def f
            super(*[2]) { 12 }
          end
        end

        return C.new.f
        """)
        assert space.int_w(w_res) == 14
        w_res = space.execute("""
        class D < A
          def f a
            super
          end
        end

        return D.new.f(3) { 12 }
        """)
        assert space.int_w(w_res) == 15

    def test_next_loop(self, space):
        w_res = space.execute("""
        res = []
        i = 0
        while i < 10
          i += 1
          if i > 3
            next
          end
          res << i
        end
        return res
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3]

    def test_next_loop_block(self, space):
        w_res = space.execute("""
        a = []
        2.times {
          i = 0
          while i < 3
            i += 1
            a << i
            next
            raise "abc"
          end
        }
        return a
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3, 1, 2, 3]

    def test_break_loop(self, space):
        w_res = space.execute("""
        res = []
        i = 0
        other = while i < 10
          i += 1
          if i > 3
              break 200
          end
          res << i
        end
        res << other
        return res
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3, 200]

    def test_simple_lexical_scope_constant(self, space):
        w_res = space.execute("""
        class A
          CONST = 1

          def get
            CONST
          end
        end

        class B < A
          CONST = 2
        end

        return A.new.get == B.new.get
        """)
        assert space.is_true(w_res)

    def test_complex_lexical_scope_constant(self, space):
        space.execute("""
        class Bar
          module M
          end
        end

        module X
          module M
            FOO = 5
          end

          class Foo < Bar
            def f
              M::FOO
            end
          end
        end

        class X::Foo
          def g
            M::FOO
          end
        end
        """)
        w_res = space.execute("return X::Foo.new.f")
        assert space.int_w(w_res) == 5
        with self.raises(space, "NameError"):
            space.execute("X::Foo.new.g")

    def test_lexical_scope_singletonclass(self, space):
        space.execute("""
        class M
          module NestedModule
          end

          class << self
            include NestedModule
          end
        end
        """)

    def test_constant_lookup_from_trpl_book(self, space):
        w_res = space.execute("""
        module Kernel
          A = B = C = D = E = F = "defined in kernel"
        end
        A = B = C = D = E = "defined at toplevel"

        class Super
          A = B = C = D = "defined in superclass"
        end

        module Included
          A = B = C = "defined in included module"
        end

        module Enclosing
          A = B = "defined in enclosing module"

          class Local < Super
            include Included
            A = "defined Locally"
            RESULT = [A, B, C, D, E, F]
          end
        end
        return Enclosing::Local::RESULT
        """)
        assert self.unwrap(space, w_res) == [
            "defined Locally",
            "defined in enclosing module",
            "defined in included module",
            "defined in superclass",
            "defined at toplevel",
            "defined in kernel"
        ]

    def test_top_level_include(self, space):
        w_res = space.execute("""
        module M
          Foo = 10
        end
        include M
        return Foo
        """)
        assert space.int_w(w_res) == 10

    def test_call_too_few_args(self, space):
        space.execute("""
        def f(a, b=2)
        end
        def g(a, b, *c)
        end
        """)
        with self.raises(space, "ArgumentError", "wrong number of arguments (0 for 1)"):
            space.execute("f")
        with self.raises(space, "ArgumentError", "wrong number of arguments (0 for 2)"):
            space.execute("g")

    def test_call_too_many_args(self, space):
        space.execute("""
        def f
        end
        """)
        with self.raises(space, "ArgumentError", "wrong number of arguments (3 for 0)"):
            space.execute("f 1, 2, 3")

    def test_call_too_few_args_builtin(self, space):
        with self.raises(space, "ArgumentError", "wrong number of arguments (0 for 1)"):
            space.execute("1.send(:+)")

    def test_call_too_many_args_builtin(self, space):
        with self.raises(space, "ArgumentError", "wrong number of arguments (3 for 1)"):
            space.execute("1.send(:+, 2, 3, 4)")

    def test_bignum(self, space):
        w_res = space.execute("return 18446744073709551628.to_s")
        assert space.str_w(w_res) == "18446744073709551628"
        w_res = space.execute("return 18446744073709551628.class")
        assert w_res is space.w_bignum

    def test_lambda(self, space):
        w_res = space.execute("return ->{ 1 + 1 }.call")
        assert space.int_w(w_res) == 2


class TestBlocks(BaseTopazTest):
    def test_self(self, space):
        w_res = space.execute("""
        class X
          def initialize
            @data = []
          end
          def process d
            d.each do |x|
              @data << x * 2
            end
          end
          def data
            @data
          end
        end

        x = X.new
        x.process [1, 2, 3]
        return x.data
        """)
        assert self.unwrap(space, w_res) == [2, 4, 6]

    def test_param_is_cell(self, space):
        w_res = space.execute("""
        def sum(arr, start)
          arr.each do |x|
            start += x
          end
          start
        end

        return sum([1, 2, 3], 4)
        """)
        assert space.int_w(w_res) == 10

    def test_nested_block(self, space):
        w_res = space.execute("""
        result = []
        [1, 2, 3].each do |x|
          [3, 4, 5].each do |y|
            result << x - y
          end
        end
        return result
        """)
        assert self.unwrap(space, w_res) == [-2, -3, -4, -1, -2, -3, 0, -1, -2]

    def test_no_accepted_arguments(self, space):
        w_res = space.execute("""
        result = []
        2.times do
          result << "hello"
        end
        return result
        """)
        assert self.unwrap(space, w_res) == ["hello", "hello"]

    def test_multi_arg_block_array(self, space):
        w_res = space.execute("""
        res = []
        [[1, 2], [3, 4]].each do |x, y|
          res << x - y
        end
        return res
        """)
        assert self.unwrap(space, w_res) == [-1, -1]

    def test_block_argument(self, space):
        w_res = space.execute("""
        def f(&b)
          b.call
        end
        return f { 5 }
        """)
        assert space.int_w(w_res) == 5

        w_res = space.execute("""
        def g(&b)
          b
        end
        return g
        """)
        assert w_res is space.w_nil

        w_res = space.execute("""
        def h(&b)
          [1, 2, 3].map { |x| b.call(x) }
        end
        return h { |x| x * 3 }
        """)
        assert self.unwrap(space, w_res) == [3, 6, 9]

    def test_block_argument_send(self, space):
        w_res = space.execute("""
        f = lambda { |x| x * 2 }
        return [1, 2, 3].map(&f)
        """)
        assert self.unwrap(space, w_res) == [2, 4, 6]
        w_res = space.execute("""
        def x(&b)
          b
        end
        return x(&nil)
        """)
        assert w_res is space.w_nil

        with self.raises(space, "TypeError", "wrong argument type"):
            space.execute("f(&3)")

        w_res = space.execute("""
        return [1, 2, 3].map(&:to_s)
        """)
        assert self.unwrap(space, w_res) == ["1", "2", "3"]

        with self.raises(space, "TypeError", "can't convert String to Proc (String#to_proc gives String)"):
            space.execute("""
            class String; def to_proc; self; end; end
            [1, 2, 3].map(&"to_s")
            """)

    def test_too_few_block_arguments(self, space):
        w_res = space.execute("""
        def f
          yield 1
        end
        return f { |a,b,c| [a,b,c] }
        """)
        assert self.unwrap(space, w_res) == [1, None, None]

    def test_block_return(self, space):
        w_res = space.execute("""
        def f
          yield
          10
        end
        def g
          f { return 15 }
          5
        end
        return g
        """)
        assert space.int_w(w_res) == 15

    def test_nested_block_return(self, space):
        w_res = space.execute("""
        def f
          [1].each do |x|
            [x].each do |y|
              return y
            end
          end
          3
        end
        return f
        """)
        assert space.int_w(w_res) == 1

    def test_nested_block_dead_frame_return(self, space):
        w_res = space.execute("""
        class SavedInnerBlock
          attr_accessor :record

          def outer
            yield
            @block.call
          end

          def inner
            yield
          end

          def start
            outer do
              inner do
                @block = proc do
                  self.record = :before_return
                  return :return_value
                end
              end
            end
            self.record = :bottom_of_start
            return false
          end
        end

        sib = SavedInnerBlock.new
        return [sib.start, sib.record]
        """)
        assert self.unwrap(space, w_res) == ["return_value", "before_return"]

    def test_break_block(self, space):
        w_res = space.execute("""
        def f(res, &a)
          begin
            g(&a)
          ensure
            res << 1
          end
          5
        end

        def g()
          4 + yield
        end

        res = []
        res << (f(res) { break 3})
        return res
        """)
        assert self.unwrap(space, w_res) == [1, 3]

    def test_break_nested_block(self, space):
        w_res = space.execute("""
        def f
          yield
        end

        return f {
          a = []
          3.times do |i|
            begin
              a << :begin
              next if i == 0
              break if i == 2
              a << :begin_end
            ensure
              a << :ensure
            end
            a << :after
          end
          a
        }
        """)
        assert self.unwrap(space, w_res) == ["begin", "ensure", "begin", "begin_end", "ensure", "after", "begin", "ensure"]

    def test_break_block_frame_exited(self, space):
        space.execute("""
        def create_block
          b = capture_block do
            break
          end
        end

        def capture_block(&b)
          b
        end
        """)
        with self.raises(space, "LocalJumpError", "break from proc-closure"):
            space.execute("create_block.call")

    def test_singleton_class_block(self, space):
        w_res = space.execute("""
        def f(o)
          class << o
            yield
          end
        end

        return f(Object.new) { 123 }
        """)
        assert space.int_w(w_res) == 123

    def test_yield_no_block(self, space):
        space.execute("""
        def f
          yield
        end
        """)
        with self.raises(space, "LocalJumpError"):
            space.execute("f")

    def test_splat_arg_block(self, space):
        w_res = space.execute("""
        def f a, b, c
          yield a, b, c
        end

        return f(2, 3, 4) { |*args| args }
        """)
        assert self.unwrap(space, w_res) == [2, 3, 4]

    def test_yield_splat(self, space):
        w_res = space.execute("""
        def f(*args)
          yield *args
        end

        return f(3, 5) { |a, b| a + b }
        """)
        assert space.int_w(w_res) == 8
        w_res = space.execute("""
        def f
          yield 3, *[4, 5]
        end
        return f() { |a, b, c| a * b + c}
        """)
        assert space.int_w(w_res) == 17

    def test_destructuring_arg_block(self, space):
        w_res = space.execute("""
        res = []
        hash = {1 => [2, [3, "ignored", 4]]}
        ky, a, b, c, d = nil, nil, nil, nil, nil
        hash.each_pair do |ky, (a, (b, *c, d))|
          res << ky << a << b << c << d
        end
        res << ky << a << b << c << d
        return res
        """)
        assert self.unwrap(space, w_res) == [
            1, 2, 3, ["ignored"], 4,
            None, None, None, None, None
        ]

    def test_block_local_var(self, space):
        w_res = space.execute("""
        def f
            yield
        end

        x = 3
        f { |;x| x = 5 }
        return x
        """)
        assert space.int_w(w_res) == 3


class TestExceptions(BaseTopazTest):
    def test_simple(self, space):
        w_res = space.execute("""
        return begin
          1 / 0
        rescue ZeroDivisionError
          5
        end
        """)
        assert space.int_w(w_res) == 5

    def test_bind_to_name(self, space):
        w_res = space.execute("""
        return begin
          1 / 0
        rescue ZeroDivisionError => e
          e.to_s
        end
        """)
        assert space.str_w(w_res) == "divided by 0"

    def test_rescue_no_exception(self, space):
        w_res = space.execute("""
        return begin
          1 + 1
        rescue ZeroDivisionError
          5
        end
        """)
        assert space.int_w(w_res) == 2

    def test_uncaught_exception(self, space):
        with self.raises(space, "NoMethodError"):
            space.execute("""
            begin
              [].dsafdsafsa
            rescue ZeroDivisionError
              5
            end
            """)

    def test_multiple_rescues(self, space):
        w_res = space.execute("""
        return begin
          1 / 0
        rescue NoMethodError
          5
        rescue ZeroDivisionError
          10
        end
        """)
        assert space.int_w(w_res) == 10

    def test_nested_rescue(self, space):
        w_res = space.execute("""
        return begin
          begin
            1 / 0
          rescue NoMethodError
            10
          end
        rescue ZeroDivisionError
          5
        end
        """)
        assert space.int_w(w_res) == 5

    def test_simple_ensure(self, space):
        w_res = space.execute("""
        res = []
        begin
          res << 1
          1 / 0
        rescue ZeroDivisionError
          res << 2
        ensure
          res << 3
        end
        return res
        """)
        assert self.unwrap(space, w_res) == [1, 2, 3]

    def test_ensure_return(self, space):
        w_res = space.execute("""
        res = []
        begin
          return res
        ensure
          res << 1
        end
        """)
        assert self.unwrap(space, w_res) == [1]

    def test_ensure_block_return(self, space):
        w_res = space.execute("""
        def h
          yield
        end
        def g(res)
          h {
            begin
              return 5
            ensure
              res << 12
            end
          }
          10
        end
        def f
          res = []
          res << g(res)
          res
        end
        return f
        """)
        assert self.unwrap(space, w_res) == [12, 5]

    def test_ensure_nonlocal_block_return(self, space):
        w_res = space.execute("""
        def h
          yield
        end
        def g(res, &a)
          begin
            yield
          ensure
            res << 1
          end
        end
        def f(res)
          g(res) { return 5 }
        end
        res = []
        res << f(res)
        return res
        """)
        assert self.unwrap(space, w_res) == [1, 5]

    def test_ensure_result(self, space):
        w_res = space.execute("""
        return begin
        ensure
          nil
        end
        """)
        assert w_res is space.w_nil

    def test_rescue_loop(self, space):
        w_res = space.execute("""
        i = 0
        while i < 3
          begin
            [].asdef
          rescue NoMethodError
            i += 1
          end
        end
        return i
        """)
        assert space.int_w(w_res) == 3

    def test_rescue_superclass(self, space):
        w_res = space.execute("""
        begin
          1 / 0
        rescue StandardError
          return 0
        end
        """)
        assert space.int_w(w_res) == 0

    def test_bang_method_call_without_parens(self, space):
        w_res = space.execute("""
        ! respond_to? :asdf
        """)
        assert w_res is space.w_true

########NEW FILE########
__FILENAME__ = test_main
import os
import platform
import subprocess

from topaz.main import _entry_point


class TestMain(object):
    def run(self, space, tmpdir, source=None, status=0, ruby_args=[], argv=[]):
        args = ["topaz"]
        args += ruby_args
        if source is not None:
            f = tmpdir.join("test.rb")
            f.write(source)
            args.append(str(f))
        else:
            f = None
        args += argv
        res = _entry_point(space, args)
        assert res == status
        return f

    def assert_traceback(self, space, tmpdir, capfd, src, expected):
        f = self.run(space, tmpdir, src, status=1)
        out, err = capfd.readouterr()
        assert not out
        actual_lines = err.splitlines()
        expected_lines = []
        for line in expected:
            expected_lines.append(line.format(f))
        assert actual_lines == expected_lines

    def test_simple(self, space, tmpdir, capfd):
        self.run(space, tmpdir, "puts 5")
        out, err = capfd.readouterr()
        assert out == "5\n"
        assert not err

    def test_expr(self, space, tmpdir, capfd):
        self.run(space, tmpdir, None, ruby_args=["-e", "puts 5", "-e", "puts 6"])
        out, err = capfd.readouterr()
        assert out == "5\n6\n"
        self.run(space, tmpdir, None, ruby_args=["-eputs 'hi'"])
        out, err = capfd.readouterr()
        assert out == "hi\n"

    def test_no_expr(self, space, tmpdir, capfd):
        self.run(space, tmpdir, None, ruby_args=["-e"], status=1)
        out, err = capfd.readouterr()
        assert err == u"no code specified for -e (RuntimeError)\n"
        assert out == ""

    def test___FILE__(self, space, tmpdir, capfd):
        f = self.run(space, tmpdir, "puts __FILE__")
        out, err = capfd.readouterr()
        assert out == "{}\n".format(f)

    def test_verbose(self, space, tmpdir, capfd):
        self.run(space, tmpdir, "puts 5", ruby_args=["-v"])
        out, err = capfd.readouterr()
        [version, out] = out.splitlines()
        assert version.startswith("topaz")
        assert "1.9.3" in version
        assert os.uname()[4] in version
        assert platform.system().lower() in version
        assert subprocess.check_output(["git", "rev-parse", "--short", "HEAD"]).rstrip() in version
        assert out == "5"

        self.run(space, tmpdir, ruby_args=["-v"])
        out, err = capfd.readouterr()
        [version] = out.splitlines()
        assert version.startswith("topaz")

    def test_debug_defaults_to_false(self, space, tmpdir, capfd):
        self.run(space, tmpdir, "puts $DEBUG")
        out, _ = capfd.readouterr()
        assert out.strip() == "false"

    def test_debug_sets_verbose(self, space, tmpdir, capfd):
        self.run(space, tmpdir, "puts $VERBOSE", ruby_args=["-d"])
        out, _ = capfd.readouterr()
        assert out.strip() == "true"

    def test_debug_sets_dash_d(self, space, tmpdir, capfd):
        self.run(space, tmpdir, "puts $-d", ruby_args=["-d"])
        out, _ = capfd.readouterr()
        assert out.strip() == "true"

    def test_dash_w_defaults_to_false(self, space, tmpdir, capfd):
        self.run(space, tmpdir, "puts $-w")
        out, _ = capfd.readouterr()
        assert out.strip() == "false"

    def test_warnings_sets_dash_w(self, space, tmpdir, capfd):
        self.run(space, tmpdir, "puts $-w", ruby_args=["-w"])
        out, _ = capfd.readouterr()
        assert out.strip() == "true"

    def test_warning_level_defaults_to_verbose_true(self, space, tmpdir, capfd):
        self.run(space, tmpdir, "puts $VERBOSE", ruby_args=["-W"])
        out, _ = capfd.readouterr()
        assert out.strip() == "true"

    def test_help(self, space, tmpdir, capfd):
        self.run(space, tmpdir, ruby_args=["-h"])
        out, _ = capfd.readouterr()
        assert out.splitlines()[0] == "Usage: topaz [switches] [--] [programfile] [arguments]"

    def test_copyright(self, space, tmpdir, capfd):
        self.run(space, tmpdir, ruby_args=["--copyright"])
        out, _ = capfd.readouterr()
        [copyright] = out.splitlines()
        assert copyright.startswith("topaz")
        assert "Alex Gaynor" in copyright

    def test_version(self, space, tmpdir, capfd):
        self.run(space, tmpdir, ruby_args=["--version"])
        out, _ = capfd.readouterr()
        [version] = out.splitlines()
        assert version.startswith("topaz")
        assert "1.9.3" in version
        assert os.uname()[4] in version
        assert platform.system().lower() in version
        assert subprocess.check_output(["git", "rev-parse", "--short", "HEAD"]).rstrip() in version

    def test_stop_consuming_args(self, space, tmpdir, capfd):
        self.run(space, tmpdir, ruby_args=["-e", "puts ARGV.join(' ')", "--", "--help", "-e"])
        out, _ = capfd.readouterr()
        assert out == "--help -e\n"

    def test_load_path_multiple_args(self, space, tmpdir, capfd):
        d = tmpdir.mkdir("sub")
        f1 = d.join("f.rb")
        f1.write("""
        Const = 5
        """)
        self.run(space, tmpdir, """
        require "f"
        puts Const
        """, ruby_args=["-I", str(d)])
        out, _ = capfd.readouterr()
        assert out == "5\n"

    def test_load_path_joined_args(self, space, tmpdir, capfd):
        d = tmpdir.mkdir("sub")
        f1 = d.join("f.rb")
        f1.write("""
        Const = 10
        """)
        self.run(space, tmpdir, """
        require "f"
        puts Const
        """, ruby_args=["-I%s" % d])
        out, _ = capfd.readouterr()
        assert out == "10\n"

    def test_load_path_path_separated(self, space, tmpdir, capfd):
        d1 = tmpdir.mkdir("sub")
        d2 = tmpdir.mkdir("sub2")
        f1 = d1.join("f1.rb")
        f1.write("""
        Const1 = 20
        """)
        f2 = d2.join("f2.rb")
        f2.write("""
        require "f1"
        Const2 = 3
        """)
        self.run(space, tmpdir, """
        require "f2"
        puts Const1 + Const2
        """, ruby_args=["-I%s:%s" % (d1, d2)])
        out, _ = capfd.readouterr()
        assert out == "23\n"

    def test_require_multiple_args(self, space, tmpdir, capfd):
        d = tmpdir.mkdir("sub")
        f = d.join("zyx.rb")
        f.write("""
        Zyx = 9
        """)
        self.run(space, tmpdir, "puts Zyx", ruby_args=["-r", "zyx", "-I", str(d)])
        out, _ = capfd.readouterr()
        assert out == "9\n"

    def test_require_joined_args(self, space, tmpdir, capfd):
        d = tmpdir.mkdir("sub")
        f = d.join("zyx.rb")
        f.write("""
        Zyx = 7
        """)
        self.run(space, tmpdir, "puts Zyx", ruby_args=["-rzyx", "-I", str(d)])
        out, _ = capfd.readouterr()
        assert out == "7\n"

    def test_search_path(self, space, tmpdir, capfd, monkeypatch):
        f = tmpdir.join("a")
        f.write("puts 17")
        monkeypatch.setenv("PATH", "%s:%s" % (tmpdir, os.environ["PATH"]))
        self.run(space, tmpdir, ruby_args=["-S", "a"])
        out, _ = capfd.readouterr()
        assert out == "17\n"

    def test_arguments(self, space, tmpdir, capfd):
        self.run(space, tmpdir, """
        ARGV.each_with_index do |arg, i|
            puts i.to_s + ": " + arg
        end
        """, argv=["abc", "123", "easy"])
        out, err = capfd.readouterr()
        lines = out.splitlines()
        assert lines == [
            "0: abc",
            "1: 123",
            "2: easy",
        ]

    def test_traceback_printed(self, space, tmpdir, capfd):
        self.assert_traceback(space, tmpdir, capfd, """
        def f
            yield
        end

        f { 1 / 0}
        """, [
            "{}:6:in `/': divided by 0 (ZeroDivisionError)",
            "\tfrom {}:6:in `block in <main>'",
            "\tfrom {}:3:in `f'",
            "\tfrom {}:6:in `<main>'",
        ])

    def test_syntax_error(self, space, tmpdir, capfd):
        self.assert_traceback(space, tmpdir, capfd, """
        while do
        """, [
            "{}: line 2 (SyntaxError)",
        ])

    def test_traceback_load_const(self, space, tmpdir, capfd):
        self.assert_traceback(space, tmpdir, capfd, """
        UnknownConst
        """, [
            "{}:2:in `const_missing': uninitialized constant UnknownConst (NameError)",
            "\tfrom {}:2:in `<main>'",
        ])

    def test_traceback_class(self, space, tmpdir, capfd):
        self.assert_traceback(space, tmpdir, capfd, """
        class X
            1 / 0
        end
        """, [
            "{}:3:in `/': divided by 0 (ZeroDivisionError)",
            "\tfrom {}:3:in `<class:X>'",
            "\tfrom {}:1:in `<main>'",
        ])

    def test_traceback_default_arg(self, space, tmpdir, capfd):
        self.assert_traceback(space, tmpdir, capfd, """
        def f(a=1 / 0)
        end
        f
        """, [
            "{}:2:in `/': divided by 0 (ZeroDivisionError)",
            "\tfrom {}:2:in `f'",
            "\tfrom {}:4:in `<main>'",
        ])

    def test_ruby_engine(self, space, tmpdir, capfd):
        self.run(space, tmpdir, "puts RUBY_ENGINE")
        out, err = capfd.readouterr()
        assert out == "topaz\n"

    def test_ruby_description(self, space, tmpdir, capfd):
        self.run(space, tmpdir, "puts RUBY_DESCRIPTION")
        out1, err1 = capfd.readouterr()
        self.run(space, tmpdir, """
        puts "#{RUBY_ENGINE} (ruby-#{RUBY_VERSION}p#{RUBY_PATCHLEVEL}) (git rev #{RUBY_REVISION}) [#{RUBY_PLATFORM}]"
        """)
        out2, err2 = capfd.readouterr()
        assert out1 == out2

    def test_system_exit(self, space, tmpdir):
        self.run(space, tmpdir, "raise SystemExit", 0)
        self.run(space, tmpdir, "raise SystemExit.new('exit', 1)", 1)

    def test_at_exit(self, space, tmpdir, capfd):
        f = self.run(space, tmpdir, """
        at_exit { puts "1" }
        at_exit { 1 / 0 }
        at_exit { puts "2" }
        1 / 0
        """, status=1)
        out, err = capfd.readouterr()
        assert out.splitlines() == [
            "2",
            "1",
        ]
        assert err.splitlines() == [
            "{}:3:in `/': divided by 0 (ZeroDivisionError)".format(f),
            "\tfrom {}:3:in `block in <main>'".format(f),
            "{}:5:in `/': divided by 0 (ZeroDivisionError)".format(f),
            "\tfrom {}:5:in `<main>'".format(f),
        ]

    def test_program_global(self, space, tmpdir, capfd):
        self.run(space, tmpdir, None, ruby_args=["-e", "puts $0"])
        out1, err1 = capfd.readouterr()
        assert out1 == "-e\n"
        f = self.run(space, tmpdir, "puts $0")
        out2, err2 = capfd.readouterr()
        assert out2 == "{}\n".format(f)
        f = self.run(space, tmpdir, "puts $PROGRAM_NAME")
        out3, _ = capfd.readouterr()
        assert out3 == "{}\n".format(f)

    def test_non_existent_file(self, space, tmpdir, capfd):
        self.run(space, tmpdir, None, ruby_args=[str(tmpdir.join("t.rb"))], status=1)
        out, err = capfd.readouterr()
        assert err == "No such file or directory -- %s (LoadError)\n" % tmpdir.join("t.rb")

########NEW FILE########
__FILENAME__ = test_mapdict
import pytest

from topaz import mapdict


class FakeObject(object):
    def __init__(self, map):
        self.map = map
        self.object_storage = self.unboxed_storage = None


class TestMapDict(object):
    @pytest.mark.parametrize("i", range(10))
    def test_simple_size_estimation(self, space, i):
        class_node = mapdict.ClassNode(i)
        assert class_node.size_estimate.object_size_estimate() == 0
        assert class_node.size_estimate.unboxed_size_estimate() == 0

        for j in range(1000):
            w_obj = FakeObject(class_node)
            for a in "abcdefghij"[:i]:
                w_obj.map = w_obj.map.add(space, mapdict.ObjectAttributeNode, a, w_obj)
        assert class_node.size_estimate.object_size_estimate() == i
        assert class_node.size_estimate.unboxed_size_estimate() == 0

    @pytest.mark.parametrize("i", range(1, 10))
    def test_avg_size_estimation(self, space, i):
        class_node = mapdict.ClassNode(i)
        assert class_node.size_estimate.object_size_estimate() == 0
        assert class_node.size_estimate.unboxed_size_estimate() == 0

        for j in range(1000):
            w_obj = FakeObject(class_node)
            for a in "abcdefghij"[:i]:
                w_obj.map = w_obj.map.add(space, mapdict.ObjectAttributeNode, a, w_obj)
            w_obj = FakeObject(class_node)
            for a in "klmnopqars":
                w_obj.map = w_obj.map.add(space, mapdict.ObjectAttributeNode, a, w_obj)

        assert class_node.size_estimate.object_size_estimate() in [(i + 10) // 2, (i + 11) // 2]
        assert class_node.size_estimate.unboxed_size_estimate() == 0

########NEW FILE########
__FILENAME__ = test_parser
# coding=utf-8

from rpython.rlib.rbigint import rbigint

from topaz import ast
from topaz.utils import regexp

from .base import BaseTopazTest


class TestParser(BaseTopazTest):
    def test_empty(self, space):
        assert space.parse("") == ast.Main(ast.Nil())

    def test_int_constant(self, space):
        assert space.parse("1") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(1))
        ]))
        assert space.parse("-1") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(-1))
        ]))
        assert space.parse("1_1") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(11))
        ]))
        assert space.parse("0d10") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(10))
        ]))
        assert space.parse("0xA") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(10))
        ]))
        assert space.parse("0o10") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(8))
        ]))
        assert space.parse("0b10") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(2))
        ]))
        assert space.parse("0xbe_ef") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(48879))
        ]))
        assert space.parse("0377") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(255))
        ]))
        with self.raises(space, "SyntaxError"):
            space.parse("0378")

    def test_float(self, space):
        assert space.parse("0.2") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantFloat(0.2))
        ]))
        assert space.parse("1E1") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantFloat(10.0))
        ]))
        assert space.parse("1e1") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantFloat(10.0))
        ]))
        assert space.parse("1e-3") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantFloat(0.001))
        ]))
        assert space.parse("1e+3") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantFloat(1000.0))
        ]))
        assert space.parse("-1.2") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantFloat(-1.2))
        ]))

    def test_bignum(self, space):
        assert space.parse("18446744073709551628") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantBigInt(rbigint.fromlong(18446744073709551628)))
        ]))
        assert space.parse("-18446744073709551628") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantBigInt(rbigint.fromlong(-18446744073709551628)))
        ]))

    def test_binary_expression(self, space):
        assert space.parse("1+1") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(1), "+", [ast.ConstantInt(1)], None, 1))
        ]))
        assert space.parse("1/1") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(1), "/", [ast.ConstantInt(1)], None, 1))
        ]))
        assert space.parse("1===1") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(1), "===", [ast.ConstantInt(1)], None, 1))
        ]))
        assert space.parse("2 % 3") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "%", [ast.ConstantInt(3)], None, 1))
        ]))
        assert space.parse("2 =~ 3") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "=~", [ast.ConstantInt(3)], None, 1))
        ]))
        assert space.parse("2 !~ 3") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "!~", [ast.ConstantInt(3)], None, 1))
        ]))
        assert space.parse("1 =~ /v/") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(1), "=~", [ast.ConstantRegexp("v", 0, 1)], None, 1))
        ]))
        assert space.parse("2 & 3 | 5") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.ConstantInt(2), "&", [ast.ConstantInt(3)], None, 1), "|", [ast.ConstantInt(5)], None, 1))
        ]))
        assert space.parse("$a << []") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Global("$a"), "<<", [ast.Array([])], None, 1))
        ]))
        assert space.parse("3 >> 2") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(3), ">>", [ast.ConstantInt(2)], None, 1))
        ]))
        assert space.parse("5 or 3") == ast.Main(ast.Block([
            ast.Statement(ast.Or(ast.ConstantInt(5), ast.ConstantInt(3)))
        ]))
        assert space.parse("puts 5 and 3") == ast.Main(ast.Block([
            ast.Statement(ast.And(ast.Send(ast.Self(1), "puts", [ast.ConstantInt(5)], None, 1), ast.ConstantInt(3)))
        ]))
        assert space.parse("x[0] == ?-") == ast.Main(ast.Block([
            ast.Statement(ast.Send(
                ast.Send(ast.Send(ast.Self(1), "x", [], None, 1), "[]", [ast.ConstantInt(0)], None, 1),
                "==",
                [ast.ConstantString("-")],
                None, 1
            ))
        ]))
        assert space.parse("@x-1") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.InstanceVariable("@x"), "-", [ast.ConstantInt(1)], None, 1))
        ]))
        assert space.parse(":a <=> :a") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantSymbol("a"), "<=>", [ast.ConstantSymbol("a")], None, 1))
        ]))
        assert space.parse(":a != ?-") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantSymbol("a"), "!=", [ast.ConstantString("-")], None, 1))
        ]))
        assert space.parse("1 ^ 2") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(1), "^", [ast.ConstantInt(2)], None, 1))
        ]))
        assert space.parse("1 ** 2") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(1), "**", [ast.ConstantInt(2)], None, 1))
        ]))
        assert space.parse("-1**2") == ast.Main(ast.Block([
            ast.Statement(ast.Send(
                ast.Send(ast.ConstantInt(1), "**", [ast.ConstantInt(2)], None, 1),
                "-@",
                [],
                None,
                1
            ))
        ]))
        assert space.parse("-1.0**2") == ast.Main(ast.Block([
            ast.Statement(ast.Send(
                ast.Send(ast.ConstantFloat(1.0), "**", [ast.ConstantInt(2)], None, 1),
                "-@",
                [],
                None,
                1
            ))
        ]))

    def test_multi_term_expr(self, space):
        assert space.parse("1 + 2 * 3") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(1), "+", [ast.Send(ast.ConstantInt(2), "*", [ast.ConstantInt(3)], None, 1)], None, 1))
        ]))
        assert space.parse("1 * 2 + 3") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.ConstantInt(1), "*", [ast.ConstantInt(2)], None, 1), "+", [ast.ConstantInt(3)], None, 1))
        ]))
        assert space.parse("2 << 3 * 4") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "<<", [ast.Send(ast.ConstantInt(3), "*", [ast.ConstantInt(4)], None, 1)], None, 1))
        ]))

    def test_parens(self, space):
        assert space.parse("1 * (2 - 3)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(1), "*", [ast.Block([ast.Statement(ast.Send(ast.ConstantInt(2), "-", [ast.ConstantInt(3)], None, 1))])], None, 1))
        ]))
        assert space.parse("()") == ast.Main(ast.Block([
            ast.Statement(ast.Nil())
        ]))

    def test_multiple_statements_no_sep(self, space):
        with self.raises(space, "SyntaxError"):
            space.parse("3 3")

    def test_multiple_statements(self, space):
        r = space.parse("""
        1
        2
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(1)),
            ast.Statement(ast.ConstantInt(2)),
        ]))

    def test_multiple_statements_semicolon(self, space):
        assert space.parse("1; 2") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(1)),
            ast.Statement(ast.ConstantInt(2)),
        ]))

        assert space.parse("1; 2; 3") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(1)),
            ast.Statement(ast.ConstantInt(2)),
            ast.Statement(ast.ConstantInt(3)),
        ]))

    def test_send(self, space):
        assert space.parse("puts 2") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "puts", [ast.ConstantInt(2)], None, 1))
        ]))
        assert space.parse("puts 1, 2") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "puts", [ast.ConstantInt(1), ast.ConstantInt(2)], None, 1))
        ]))
        assert space.parse("puts(1, 2)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "puts", [ast.ConstantInt(1), ast.ConstantInt(2)], None, 1))
        ]))
        assert space.parse("2.to_s") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "to_s", [], None, 1))
        ]))
        assert space.parse("2.to_s 10") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "to_s", [ast.ConstantInt(10)], None, 1))
        ]))
        assert space.parse("2.to_s.to_i") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.ConstantInt(2), "to_s", [], None, 1), "to_i", [], None, 1))
        ]))
        assert space.parse("2.to_s()") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "to_s", [], None, 1))
        ]))
        assert space.parse("2.to_s(10)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "to_s", [ast.ConstantInt(10)], None, 1))
        ]))
        assert space.parse("2.to_s(*10)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "to_s", [ast.Splat(ast.ConstantInt(10))], None, 1))
        ]))
        assert space.parse("2.to_s(10, *x)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "to_s", [ast.ConstantInt(10), ast.Splat(ast.Send(ast.Self(1), "x", [], None, 1))], None, 1))
        ]))
        assert space.parse("2.to_s(10, :base => 5)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "to_s", [ast.ConstantInt(10), ast.Hash([(ast.ConstantSymbol("base"), ast.ConstantInt(5))])], None, 1))
        ]))
        assert space.parse("2.to_s(:base => 3)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "to_s", [ast.Hash([(ast.ConstantSymbol("base"), ast.ConstantInt(3))])], None, 1))
        ]))
        assert space.parse("2.to_s(:base=>3)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(2), "to_s", [ast.Hash([(ast.ConstantSymbol("base"), ast.ConstantInt(3))])], None, 1))
        ]))
        assert space.parse("Integer other") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "Integer", [ast.Send(ast.Self(1), "other", [], None, 1)], None, 1))
        ]))
        assert space.parse("Module::constant") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Constant("Module", 1), "constant", [], None, 1))
        ]))
        r = space.parse("""
        nil.
            f
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Nil(), "f", [], None, 3))
        ]))

        with self.raises(space, "SyntaxError"):
            space.parse("2.to_s(:base => 5, 3)")

    def test_colon_send(self, space):
        assert space.parse("CallerSpecs::recurse(2)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Constant("CallerSpecs", 1), "recurse", [ast.ConstantInt(2)], None, 1))
        ]))

    def test_assignment(self, space):
        assert space.parse("a = 3") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Variable("a", 1), ast.ConstantInt(3)))
        ]))
        assert space.parse("a = b = 3") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Variable("a", 1), ast.Assignment(ast.Variable("b", 1), ast.ConstantInt(3))))
        ]))
        assert space.parse("a = method 1") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Variable("a", 1), ast.Send(ast.Self(1), "method", [ast.ConstantInt(1)], None, 1)))
        ]))

    def test_multi_assignment(self, space):
        assert space.parse("a.x, b[:idx], c::Const, d = 3") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([
                    ast.Send(ast.Send(ast.Self(1), "a", [], None, 1), "x", [], None, 1),
                    ast.Subscript(ast.Send(ast.Self(1), "b", [], None, 1), [ast.ConstantSymbol("idx")], 1),
                    ast.LookupConstant(ast.Send(ast.Self(1), "c", [], None, 1), "Const", 1),
                    ast.Variable("d", 1),
                ]),
                ast.ConstantInt(3)
            ))
        ]))
        assert space.parse("a = 2, 3") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Variable("a", 1), ast.Array([ast.ConstantInt(2), ast.ConstantInt(3)])))
        ]))
        assert space.parse("a, b = split 2") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([
                    ast.Variable("a", 1),
                    ast.Variable("b", 1),
                ]),
                ast.Send(ast.Self(1), "split", [ast.ConstantInt(2)], None, 1)
            ))
        ]))
        with self.raises(space, "SyntaxError"):
            space.parse("a, b += 3")
        assert space.parse("a, * = 1, 2") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([
                    ast.Variable("a", 1),
                    ast.Splat(None)
                ]),
                ast.Array([
                    ast.ConstantInt(1),
                    ast.ConstantInt(2)
                ])
            ))
        ]))
        assert space.parse("a, *, b = 1, 2, 3, 4") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([
                    ast.Variable("a", 1),
                    ast.Splat(None),
                    ast.Variable("b", 1)
                ]),
                ast.Array([
                    ast.ConstantInt(1),
                    ast.ConstantInt(2),
                    ast.ConstantInt(3),
                    ast.ConstantInt(4)
                ])
            ))
        ]))
        assert space.parse("a, *b, (c, (d, e, *), ) = 1, 2, 3, [4, [5, 6], 7]") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([
                    ast.Variable("a", 1),
                    ast.Splat(ast.Variable("b", 1)),
                    ast.MultiAssignable([
                        ast.Variable("c", 1),
                        ast.MultiAssignable([
                            ast.Variable("d", 1),
                            ast.Variable("e", 1),
                            ast.Splat(None)
                        ]),
                    ]),
                ]),
                ast.Array([
                    ast.ConstantInt(1),
                    ast.ConstantInt(2),
                    ast.ConstantInt(3),
                    ast.Array([
                        ast.ConstantInt(4),
                        ast.Array([
                            ast.ConstantInt(5),
                            ast.ConstantInt(6)
                        ]),
                        ast.ConstantInt(7)
                    ])
                ])
            ))
        ]))

    def test_colon_attr_assignment(self, space):
        assert space.parse("a::b = nil") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Send(ast.Send(ast.Self(1), "a", [], None, 1), "b", [], None, 1), ast.Nil()))
        ]))

    def test_splat_rhs_assignment(self, space):
        assert space.parse("a,b,c = *[1,2,3]") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([
                    ast.Variable("a", 1),
                    ast.Variable("b", 1),
                    ast.Variable("c", 1),
                ]),
                ast.Array([ast.Splat(ast.Array(
                    [
                        ast.ConstantInt(1),
                        ast.ConstantInt(2),
                        ast.ConstantInt(3),
                    ]
                ))])
            ))
        ]))
        assert space.parse("a = *[1,2,3]") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(
                ast.Variable("a", 1),
                ast.Array([ast.Splat(ast.Array(
                    [
                        ast.ConstantInt(1),
                        ast.ConstantInt(2),
                        ast.ConstantInt(3),
                    ]
                ))])
            ))
        ]))
        assert space.parse("a = 0, *[1,2,3]") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(
                ast.Variable("a", 1),
                ast.Array([
                    ast.ConstantInt(0),
                    ast.Splat(ast.Array([
                        ast.ConstantInt(1),
                        ast.ConstantInt(2),
                        ast.ConstantInt(3),
                    ])),
                ])
            ))
        ]))
        assert space.parse("a = *2, 0") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(
                ast.Variable("a", 1),
                ast.Array([
                    ast.Splat(ast.ConstantInt(2)),
                    ast.ConstantInt(0)
                ])
            ))
        ]))

    def test_splat_lhs_assignment(self, space):
        assert space.parse("a,*b,c = *[1,2]") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([
                    ast.Variable("a", 1),
                    ast.Splat(ast.Variable("b", 1)),
                    ast.Variable("c", 1),
                ]),
                ast.Array([ast.Splat(ast.Array(
                    [
                        ast.ConstantInt(1),
                        ast.ConstantInt(2)
                    ]
                ))]),
            ))
        ]))
        assert space.parse("a, *b, c = 1") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([
                    ast.Variable("a", 1),
                    ast.Splat(ast.Variable("b", 1)),
                    ast.Variable("c", 1),
                ]),
                ast.ConstantInt(1),
            ))
        ]))
        assert space.parse("*b,c = 1") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([
                    ast.Splat(ast.Variable("b", 1)),
                    ast.Variable("c", 1),
                ]),
                ast.ConstantInt(1),
            ))
        ]))
        assert space.parse("b,*c = 1") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([
                    ast.Variable("b", 1),
                    ast.Splat(ast.Variable("c", 1)),
                ]),
                ast.ConstantInt(1),
            ))
        ]))
        assert space.parse("*c = 1") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([
                    ast.Splat(ast.Variable("c", 1)),
                ]),
                ast.ConstantInt(1),
            ))
        ]))
        assert space.parse("* = 1") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([ast.Splat(None)]),
                ast.ConstantInt(1),
            ))
        ]))
        assert space.parse("a, = 3, 4") == ast.Main(ast.Block([
            ast.Statement(ast.MultiAssignment(
                ast.MultiAssignable([ast.Variable("a", 1)]),
                ast.Array([ast.ConstantInt(3), ast.ConstantInt(4)]),
            ))
        ]))
        with self.raises(space, "SyntaxError"):
            space.parse("*b, *c = 1")

    def test_load_variable(self, space):
        assert space.parse("a") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "a", [], None, 1))
        ]))

    def test_tab_indentation(self, space):
        assert space.parse("\ta") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "a", [], None, 1))
        ]))

    def test_if_statement(self, space):
        res = lambda lineno: ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(3), ast.Block([
                ast.Statement(ast.Send(ast.Self(lineno), "puts", [ast.ConstantInt(2)], None, lineno))
            ]), ast.Nil()))
        ]))
        assert space.parse("if 3 then puts 2 end") == res(1)
        assert space.parse("""
        if 3
            puts 2
        end
        """) == res(3)
        assert space.parse("""
        if 3
        then
            puts 2
        end
        """) == res(4)
        assert space.parse("if 3; puts 2 end") == res(1)
        assert space.parse("if 3; end") == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(3), ast.Nil(), ast.Nil()))
        ]))
        r = space.parse("""
        if 0
            puts 2
            puts 3
            puts 4
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(0), ast.Block([
                ast.Statement(ast.Send(ast.Self(3), "puts", [ast.ConstantInt(2)], None, 3)),
                ast.Statement(ast.Send(ast.Self(4), "puts", [ast.ConstantInt(3)], None, 4)),
                ast.Statement(ast.Send(ast.Self(5), "puts", [ast.ConstantInt(4)], None, 5)),
            ]), ast.Nil()))
        ]))

    def test_else(self, space):
        r = space.parse("""if 3 then 5 else 4 end""")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(3), ast.Block([
                ast.Statement(ast.ConstantInt(5))
            ]), ast.Block([
                ast.Statement(ast.ConstantInt(4))
            ])))
        ]))
        assert space.parse("if nil; else; end") == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.Nil(), ast.Nil(), ast.Nil()))
        ]))

    def test_elsif(self, space):
        r = space.parse("""
        if 3
            5
        elsif 4 == 2
            3
        elsif 3 == 1
            2
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(3), ast.Block([
                ast.Statement(ast.ConstantInt(5))
            ]), ast.If(ast.Send(ast.ConstantInt(4), "==", [ast.ConstantInt(2)], None, 4), ast.Block([
                ast.Statement(ast.ConstantInt(3))
            ]), ast.If(ast.Send(ast.ConstantInt(3), "==", [ast.ConstantInt(1)], None, 6), ast.Block([
                ast.Statement(ast.ConstantInt(2))
            ]), ast.Nil()))))
        ]))

    def test_elsif_else(self, space):
        r = space.parse("""
        if nil
            5
        elsif nil
            10
        else
            200
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.Nil(), ast.Block([
                ast.Statement(ast.ConstantInt(5))
            ]), ast.If(ast.Nil(), ast.Block([
                ast.Statement(ast.ConstantInt(10)),
            ]), ast.Block([
                ast.Statement(ast.ConstantInt(200))
            ]))))
        ]))

    def test_comparison_ops(self, space):
        assert space.parse("1 == 2; 1 < 2; 1 > 2; 1 != 2; 1 <= 2; 1 >= 2; 1 <=> 2") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(1), "==", [ast.ConstantInt(2)], None, 1)),
            ast.Statement(ast.Send(ast.ConstantInt(1), "<", [ast.ConstantInt(2)], None, 1)),
            ast.Statement(ast.Send(ast.ConstantInt(1), ">", [ast.ConstantInt(2)], None, 1)),
            ast.Statement(ast.Send(ast.ConstantInt(1), "!=", [ast.ConstantInt(2)], None, 1)),
            ast.Statement(ast.Send(ast.ConstantInt(1), "<=", [ast.ConstantInt(2)], None, 1)),
            ast.Statement(ast.Send(ast.ConstantInt(1), ">=", [ast.ConstantInt(2)], None, 1)),
            ast.Statement(ast.Send(ast.ConstantInt(1), "<=>", [ast.ConstantInt(2)], None, 1)),
        ]))

    def test_while(self, space):
        expected = ast.Main(ast.Block([
            ast.Statement(ast.While(ast.ConstantBool(True), ast.Block([
                ast.Statement(ast.Send(ast.Self(1), "puts", [ast.ConstantInt(5)], None, 1))
            ])))
        ]))
        assert space.parse("while true do puts 5 end") == expected
        assert space.parse("while true do; puts 5 end") == expected
        assert space.parse("while true; puts 5 end") == expected
        assert space.parse("while true; end") == ast.Main(ast.Block([
            ast.Statement(ast.While(ast.ConstantBool(True), ast.Nil()))
        ]))

        res = space.parse("""
        i = 0
        while i < 10 do
            puts i
            puts 1
            puts i
            puts true
        end
        """)
        assert res == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Variable("i", 2), ast.ConstantInt(0))),
            ast.Statement(ast.While(ast.Send(ast.Variable("i", 3), "<", [ast.ConstantInt(10)], None, 3), ast.Block([
                ast.Statement(ast.Send(ast.Self(4), "puts", [ast.Variable("i", 4)], None, 4)),
                ast.Statement(ast.Send(ast.Self(5), "puts", [ast.ConstantInt(1)], None, 5)),
                ast.Statement(ast.Send(ast.Self(6), "puts", [ast.Variable("i", 6)], None, 6)),
                ast.Statement(ast.Send(ast.Self(7), "puts", [ast.ConstantBool(True)], None, 7)),
            ])))
        ]))

    def test_until(self, space):
        r = space.parse("""
        until 3
            5
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Until(ast.ConstantInt(3), ast.Block([
                ast.Statement(ast.ConstantInt(5))
            ])))
        ]))

    def test_for(self, space):
        expected = ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Array([]), "each", [], ast.SendBlock(
                [ast.Argument("0")], None, None, ast.Block([
                    ast.Statement(ast.Assignment(ast.Variable("i", 1), ast.Variable("0", 1))),
                    ast.Statement(ast.Send(ast.Self(1), "puts", [ast.Variable("i", 1)], None, 1))
                ])
            ), 1))
        ]))
        assert space.parse("for i in [] do puts i end") == expected
        assert space.parse("for i in [] do; puts i end") == expected
        assert space.parse("for i in []; puts i end") == expected
        assert space.parse("for i, in []; end") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Array([]), "each", [], ast.SendBlock(
                [ast.Argument("0")], None, None, ast.Block([
                    ast.Statement(ast.MultiAssignment(
                        ast.MultiAssignable([ast.Variable("i", 1)]),
                        ast.Variable("0", 1)
                    ))
                ])
            ), 1))
        ]))

        res = space.parse("""
        a = [0]
        for i in a
            puts i
            puts 1
            puts i
        end
        """)
        assert res == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Variable("a", 2), ast.Array([ast.ConstantInt(0)]))),
            ast.Statement(ast.Send(ast.Variable("a", 3), "each", [], ast.SendBlock(
                [ast.Argument("0")], None, None, ast.Block([
                    ast.Statement(ast.Assignment(ast.Variable("i", 3), ast.Variable("0", 3))),
                    ast.Statement(ast.Send(ast.Self(4), "puts", [ast.Variable("i", 4)], None, 4)),
                    ast.Statement(ast.Send(ast.Self(5), "puts", [ast.ConstantInt(1)], None, 5)),
                    ast.Statement(ast.Send(ast.Self(6), "puts", [ast.Variable("i", 6)], None, 6)),
                ])
            ), 3))
        ]))

        res = space.parse("""
        for @a, *b, $c in []
        end
        """)
        assert res == ast.Main(ast.Block([
            ast.Statement(ast.Send(
                ast.Array([]),
                "each",
                [],
                ast.SendBlock(
                    [ast.Argument("0")], None, None, ast.Block([
                        ast.Statement(ast.MultiAssignment(
                            ast.MultiAssignable([
                                ast.InstanceVariable("@a"),
                                ast.Splat(ast.Variable("b", 2)),
                                ast.Global("$c")
                            ]),
                            ast.Variable("0", 2)
                        ))
                    ])
                ),
                2
            ))
        ]))

    def test_return(self, space):
        assert space.parse("return 4") == ast.Main(ast.Block([
            ast.Return(ast.ConstantInt(4))
        ]))
        assert space.parse("return") == ast.Main(ast.Block([
            ast.Return(ast.Nil())
        ]))
        assert space.parse("return 3, 4, 5") == ast.Main(ast.Block([
            ast.Return(ast.Array([
                ast.ConstantInt(3),
                ast.ConstantInt(4),
                ast.ConstantInt(5),
            ]))
        ]))
        assert space.parse("return *3") == ast.Main(ast.Block([
            ast.Return(ast.Splat(ast.ConstantInt(3)))
        ]))
        assert space.parse("return f 1, 2") == ast.Main(ast.Block([
            ast.Return(ast.Send(ast.Self(1), "f", [ast.ConstantInt(1), ast.ConstantInt(2)], None, 1))
        ]))

    def test_array(self, space):
        assert space.parse("[]") == ast.Main(ast.Block([
            ast.Statement(ast.Array([]))
        ]))

        assert space.parse("[1, 2, 3]") == ast.Main(ast.Block([
            ast.Statement(ast.Array([
                ast.ConstantInt(1),
                ast.ConstantInt(2),
                ast.ConstantInt(3),
            ]))
        ]))

        assert space.parse("[[1], [2], [3]]") == ast.Main(ast.Block([
            ast.Statement(ast.Array([
                ast.Array([ast.ConstantInt(1)]),
                ast.Array([ast.ConstantInt(2)]),
                ast.Array([ast.ConstantInt(3)]),
            ]))
        ]))

        assert space.parse("[1, 2,]") == ast.Main(ast.Block([
            ast.Statement(ast.Array([
                ast.ConstantInt(1),
                ast.ConstantInt(2),
            ]))
        ]))

        r = space.parse("""
        [
            f()
        ]
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Array([
                ast.Send(ast.Self(3), "f", [], None, 3),
            ])),
        ]))
        assert space.parse("[1, *2, *3]") == ast.Main(ast.Block([
            ast.Statement(ast.Array([
                ast.ConstantInt(1),
                ast.Splat(ast.ConstantInt(2)),
                ast.Splat(ast.ConstantInt(3)),
            ]))
        ]))
        assert space.parse("[:abc => 3]") == ast.Main(ast.Block([
            ast.Statement(ast.Array([
                ast.Hash([(ast.ConstantSymbol("abc"), ast.ConstantInt(3))])
            ]))
        ]))
        assert space.parse("[1, :abc => 3]") == ast.Main(ast.Block([
            ast.Statement(ast.Array([
                ast.ConstantInt(1),
                ast.Hash([(ast.ConstantSymbol("abc"), ast.ConstantInt(3))])
            ]))
        ]))

    def test_subscript(self, space):
        assert space.parse("[1][0]") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Array([ast.ConstantInt(1)]), "[]", [ast.ConstantInt(0)], None, 1))
        ]))

        assert space.parse("self[i]") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "[]", [ast.Send(ast.Self(1), "i", [], None, 1)], None, 1))
        ]))

        assert space.parse("self[i].to_s") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(1), "[]", [ast.Send(ast.Self(1), "i", [], None, 1)], None, 1), "to_s", [], None, 1))
        ]))

        assert space.parse("a[:a][:a]") == ast.Main(ast.Block([
            ast.Statement(ast.Send(
                ast.Send(
                    ast.Send(ast.Self(1), "a", [], None, 1),
                    "[]",
                    [ast.ConstantSymbol("a")],
                    None,
                    1
                ),
                "[]",
                [ast.ConstantSymbol("a")],
                None,
                1,
            ))
        ]))
        assert space.parse("x.y[0]") == ast.Main(ast.Block([
            ast.Statement(ast.Send(
                ast.Send(ast.Send(ast.Self(1), "x", [], None, 1), "y", [], None, 1),
                "[]",
                [ast.ConstantInt(0)],
                None,
                1,
            ))
        ]))
        assert space.parse("r[0, 0]") == ast.Main(ast.Block([
            ast.Statement(ast.Send(
                ast.Send(ast.Self(1), "r", [], None, 1),
                "[]",
                [ast.ConstantInt(0), ast.ConstantInt(0)],
                None,
                1,
            ))
        ]))
        assert space.parse("r[]") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(1), "r", [], None, 1), "[]", [], None, 1))
        ]))
        assert space.parse("f()[]") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(1), "f", [], None, 1), "[]", [], None, 1))
        ]))

    def test_subscript_assginment(self, space):
        assert space.parse("x[0] = 5") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Subscript(ast.Send(ast.Self(1), "x", [], None, 1), [ast.ConstantInt(0)], 1), ast.ConstantInt(5)))
        ]))
        assert space.parse("x[] = 5") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Subscript(ast.Send(ast.Self(1), "x", [], None, 1), [], 1), ast.ConstantInt(5)))
        ]))

    def test_subscript_augmented_assignment(self, space):
        assert space.parse("x[] += 5") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("+", ast.Subscript(ast.Send(ast.Self(1), "x", [], None, 1), [], 1), ast.ConstantInt(5)))
        ]))

    def test_def(self, space):
        assert space.parse("def f() end") == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [], None, None, ast.Nil()))
        ]))

        r = space.parse("""
        def
        f
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [], None, None, ast.Nil()))
        ]))

        assert space.parse("def []; end") == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "[]", [], None, None, ast.Nil()))
        ]))

        assert space.parse("def []=; end") == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "[]=", [], None, None, ast.Nil()))
        ]))

        assert space.parse("def f(a, b) a + b end") == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [ast.Argument("a"), ast.Argument("b")], None, None, ast.Block([
                ast.Statement(ast.Send(ast.Variable("a", 1), "+", [ast.Variable("b", 1)], None, 1))
            ])))
        ]))

        r = space.parse("""
        def f(a)
            puts a
            puts a
            puts a
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [ast.Argument("a")], None, None, ast.Block([
                ast.Statement(ast.Send(ast.Self(3), "puts", [ast.Variable("a", 3)], None, 3)),
                ast.Statement(ast.Send(ast.Self(4), "puts", [ast.Variable("a", 4)], None, 4)),
                ast.Statement(ast.Send(ast.Self(5), "puts", [ast.Variable("a", 5)], None, 5)),
            ])))
        ]))

        assert space.parse("x = def f() end") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Variable("x", 1), ast.Function(None, "f", [], None, None, ast.Nil())))
        ]))

        r = space.parse("""
        def f a, b
            a + b
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [ast.Argument("a"), ast.Argument("b")], None, None, ast.Block([
                ast.Statement(ast.Send(ast.Variable("a", 3), "+", [ast.Variable("b", 3)], None, 3))
            ])))
        ]))

        r = space.parse("""
        def f(&b)
            b
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [], None, "b", ast.Block([
                ast.Statement(ast.Variable("b", 3))
            ])))
        ]))
        r = space.parse("""
        def f(a=nil, *b)
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [ast.Argument("a", ast.Nil())], "b", None, ast.Nil()))
        ]))
        r = space.parse("""
        def f(a, b=nil, *c)
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [ast.Argument("a"), ast.Argument("b", ast.Nil())], "c", None, ast.Nil()))
        ]))
        with self.raises(space, "SyntaxError"):
            space.parse("""
            def f(&b, a)
                b
            end
            """)
        with self.raises(space, "SyntaxError"):
            space.parse("""
            def f(&b, &c)
                b
            end
            """)

        assert space.parse("def f(*a,b,&blk); end") == ast.Main(ast.Block([
            ast.Statement(ast.Function(
                None,
                "f",
                [],
                "2",
                "blk",
                ast.Block([ast.Statement(
                    ast.MultiAssignment(
                        ast.MultiAssignable([
                            ast.Splat(ast.Variable("a", -1)),
                            ast.Variable("b", -1),
                        ]),
                        ast.Variable("2", -1)
                    )
                )])
            ))
        ]))

    def test_def_names(self, space):
        def test_name(s):
            r = space.parse("""
            def %s
            end
            """ % s)
            assert r == ast.Main(ast.Block([
                ast.Statement(ast.Function(None, s, [], None, None, ast.Nil()))
            ]))
        test_name("abc")
        test_name("<=>")
        test_name("foo=")
        test_name("===")
        test_name(">")
        test_name("<")
        test_name(">=")
        test_name("<=")
        test_name("==")
        test_name("=~")
        test_name("<<")
        test_name("-")

    def test_string(self, space):
        assert space.parse('"abc"') == ast.Main(ast.Block([
            ast.Statement(ast.ConstantString("abc"))
        ]))
        assert space.parse('"abc".size') == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantString("abc"), "size", [], None, 1))
        ]))
        assert space.parse("'abc'") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantString("abc"))
        ]))
        assert space.parse('"\n"') == ast.Main(ast.Block([
            ast.Statement(ast.ConstantString("\n"))
        ]))
        assert space.parse('"\\n"') == ast.Main(ast.Block([
            ast.Statement(ast.ConstantString("\n"))
        ]))
        assert space.parse("'\\n'") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantString("\\n"))
        ]))
        assert space.parse("?-") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantString("-"))
        ]))
        assert space.parse('""') == ast.Main(ast.Block([
            ast.Statement(ast.ConstantString(""))
        ]))
        assert space.parse("'\\'<>'") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantString("'<>"))
        ]))
        assert space.parse('"\\"<>"') == ast.Main(ast.Block([
            ast.Statement(ast.ConstantString('"<>'))
        ]))

    def test_escape_character(self, space):
        string = lambda content: ast.Main(ast.Block([
            ast.Statement(ast.ConstantString(content))
        ]))

        assert space.parse('?\\\\') == string("\\")
        assert space.parse('?\\n') == string("\n")
        assert space.parse('?\\t') == string("\t")
        assert space.parse('?\\r') == string("\r")
        assert space.parse('?\\f') == string("\f")
        assert space.parse('?\\v') == string("\v")
        assert space.parse('?\\a') == string("\a")
        assert space.parse('?\\b') == string("\b")
        assert space.parse('?\\e') == string("\x1b")
        assert space.parse('?\\s') == string(" ")
        assert space.parse("?\\xa") == string("\x0a")
        assert space.parse('?\\xab') == string("\xab")
        assert space.parse('?\\01') == string("\01")
        assert space.parse('?\\012') == string("\012")
        assert space.parse('?\\M-\a') == string("\x87")
        assert space.parse('?\\M-a') == string("\xe1")
        assert space.parse('?\\C-?') == string("\x7f")
        assert space.parse('?\\c?') == string("\x7f")
        assert space.parse('?\\C-\y') == string("\x19")
        assert space.parse('?\\c\y') == string("\x19")
        assert space.parse('?\\l') == string("l")
        assert space.parse('?\\0') == string("\0")
        assert space.parse('?\\01') == string("\x01")
        assert space.parse('?\\001') == string("\x01")
        assert space.parse('"\\0"') == string("\x00")
        assert space.parse('"\\01"') == string("\x01")
        assert space.parse('"\\012"') == string("\n")
        assert space.parse('"\\0\\1\\2"') == string("\x00\x01\x02")
        assert space.parse('"\\09"') == string("\x009")
        assert space.parse('"\\019"') == string("\x019")
        with self.raises(space, "SyntaxError"):
            space.parse("?\\09")
        with self.raises(space, "SyntaxError"):
            space.parse("?\\019")
        assert space.parse('?\\12') == string("\n")
        assert space.parse('"\\12"') == string("\n")
        assert space.parse('?\\012') == string("\n")
        assert space.parse('"\\342\\234\\224"') == string(u"✔".encode("utf-8"))
        assert space.parse('"\u2603"') == string(u"\u2603".encode("utf-8"))
        assert space.parse('?\u2603') == string(u"\u2603".encode("utf-8"))
        assert space.parse('"\uffff"') == string(u"\uffff".encode("utf-8"))
        assert space.parse('"\u{ff}"') == string(u"\u00ff".encode("utf-8"))
        assert space.parse('?\u{ff}') == string(u"\u00ff".encode("utf-8"))
        assert space.parse('"\u{3042 3044 3046 3048}"') == string(u"\u3042\u3044\u3046\u3048".encode("utf-8"))
        with self.raises(space, "SyntaxError", "line 1 (invalid Unicode escape)"):
            space.parse('"\u123x"')
        with self.raises(space, "SyntaxError", "line 1 (invalid Unicode escape)"):
            space.parse('"\u{}"')
        with self.raises(space, "SyntaxError", "line 1 (invalid Unicode escape)"):
            space.parse('"\u{ 3042}"')
        with self.raises(space, "SyntaxError", "line 1 (unterminated Unicode escape)"):
            space.parse('"\u{123x}"')
        with self.raises(space, "SyntaxError", "line 1 (unterminated Unicode escape)"):
            space.parse('?\u{3042 3044}')
        with self.raises(space, "SyntaxError", "line 1 (invalid Unicode codepoint (too large))"):
            space.parse('"\u{110000}"')

    def test_dynamic_string(self, space):
        const_string = lambda strvalue: ast.Main(ast.Block([
            ast.Statement(ast.ConstantString(strvalue))
        ]))
        dyn_string = lambda *components: ast.Main(ast.Block([
            ast.Statement(ast.DynamicString(list(components)))
        ]))
        assert space.parse('"#{x}"') == dyn_string(ast.Block([ast.Statement(ast.Send(ast.Self(1), "x", [], None, 1))]))
        assert space.parse('"abc #{2} abc"') == dyn_string(ast.ConstantString("abc "), ast.Block([ast.Statement(ast.ConstantInt(2))]), ast.ConstantString(" abc"))
        assert space.parse('"#{"}"}"') == dyn_string(ast.Block([ast.Statement(ast.ConstantString("}"))]))
        assert space.parse('"#{f { 2 }}"') == dyn_string(ast.Block([ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock([], None, None, ast.Block([ast.Statement(ast.ConstantInt(2))])), 1))]))
        assert space.parse('"#{p("")}"') == dyn_string(ast.Block([ast.Statement(ast.Send(ast.Self(1), "p", [ast.ConstantString("")], None, 1))]))
        assert space.parse('"#{"#{2}"}"') == dyn_string(ast.Block([ast.Statement(ast.DynamicString([ast.Block([ast.Statement(ast.ConstantInt(2))])]))]))
        assert space.parse('"#{nil if 2}"') == dyn_string(ast.Block([ast.Statement(ast.If(
            ast.ConstantInt(2),
            ast.Block([ast.Statement(ast.Nil())]),
            ast.Nil(),
        ))]))
        assert space.parse('"\\""') == const_string('"')
        assert space.parse('"\n"') == const_string("\n")
        assert space.parse('"\w"') == const_string("w")
        assert space.parse('"\M-a"') == const_string("\xe1")
        assert space.parse('"#$abc#@a#@@ab"') == dyn_string(ast.Global("$abc"), ast.InstanceVariable("@a"), ast.ClassVariable("@@ab", 1))
        assert space.parse('"#test"') == const_string("#test")

    def test_percent_terms(self, space):
        const_string = lambda strvalue: ast.Main(ast.Block([
            ast.Statement(ast.ConstantString(strvalue))
        ]))
        dyn_string = lambda *components: ast.Main(ast.Block([
            ast.Statement(ast.DynamicString(list(components)))
        ]))
        assert space.parse('%{1}') == const_string("1")
        assert space.parse('%Q{1}') == const_string("1")
        assert space.parse('%Q{#{2}}') == dyn_string(ast.Block([ast.Statement(ast.ConstantInt(2))]))
        assert space.parse('%Q(#{2})') == dyn_string(ast.Block([ast.Statement(ast.ConstantInt(2))]))
        assert space.parse('%Q<#{2}>') == dyn_string(ast.Block([ast.Statement(ast.ConstantInt(2))]))
        assert space.parse('%Q[#{2}]') == dyn_string(ast.Block([ast.Statement(ast.ConstantInt(2))]))
        assert space.parse('%Q^#{2}^') == dyn_string(ast.Block([ast.Statement(ast.ConstantInt(2))]))
        assert space.parse('%{{}}') == const_string("{}")
        assert space.parse('%[[]]') == const_string("[]")
        assert space.parse('%<<>>') == const_string("<>")
        assert space.parse('%(())') == const_string("()")
        assert space.parse('%q{#{2}}') == const_string("#{2}")
        assert space.parse('%{\\{}') == const_string('{')
        assert space.parse('%{\\}}') == const_string('}')
        assert space.parse('%w{\ -}') == ast.Main(ast.Block([
            ast.Statement(ast.Array([ast.ConstantString(" -")]))
        ]))
        assert space.parse('%w{  hello world  }') == ast.Main(ast.Block([
            ast.Statement(ast.Array([
                ast.ConstantString("hello"),
                ast.ConstantString("world"),
            ]))
        ]))
        assert space.parse('%W{hello world  }') == ast.Main(ast.Block([
            ast.Statement(ast.Array([
                ast.ConstantString("hello"),
                ast.ConstantString("world"),
            ]))
        ]))
        assert space.parse('%w{#{"a b" + "#{\'c d\'}"}}') == ast.Main(ast.Block([
            ast.Statement(ast.Array([
                ast.ConstantString('#{"a'),
                ast.ConstantString('b"'),
                ast.ConstantString('+'),
                ast.ConstantString('"#{\'c'),
                ast.ConstantString('d\'}"}'),
            ]))
        ]))
        assert space.parse('%W{#{"a b" + "#{\'c d\'}"}}') == ast.Main(ast.Block([
            ast.Statement(ast.Array([ast.DynamicString([ast.Block([ast.Statement(
                ast.Send(
                    ast.ConstantString("a b"),
                    "+",
                    [ast.DynamicString([ast.Block([ast.Statement(ast.ConstantString("c d"))])])],
                    None,
                    1
                )
            )])])]))
        ]))
        r = space.parse("""
        %w!a!
        nil
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Array([ast.ConstantString("a")])),
            ast.Statement(ast.Nil()),
        ]))

        assert space.parse("f %q[/]") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [ast.ConstantString("/")], None, 1)),
        ]))
        assert space.parse("%w[]") == ast.Main(ast.Block([
            ast.Statement(ast.Array([]))
        ]))

    def test_heredoc(self, space):
        const_heredoc = lambda s: ast.Main(ast.Block([
            ast.Statement(ast.ConstantString(s))
        ]))

        r = space.parse("""
        <<HERE
abc
HERE
        """)

        assert r == const_heredoc("abc\n")
        r = space.parse("""
        <<"HERE"
abc
HERE
        """)
        assert r == const_heredoc("abc\n")

        r = space.parse("""
        <<'HERE'
abc
HERE
        """)
        assert r == const_heredoc("abc\n")

        r = space.parse("""
        <<-HERE
        abc
        HERE
        """)
        assert r == const_heredoc("        abc\n")

        r = space.parse("""
        <<-HERE
        #{false}
        HERE
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.DynamicString([
                ast.ConstantString("        "),
                ast.Block([ast.Statement(ast.ConstantBool(False))]),
                ast.ConstantString("\n"),
                ast.ConstantString(""),
            ]))
        ]))

        r = space.parse("""
        <<HERE
        abc #{123}
HERE
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.DynamicString([
                ast.ConstantString("        abc "),
                ast.Block([ast.Statement(ast.ConstantInt(123))]),
                ast.ConstantString("\n"),
                ast.ConstantString(""),
            ]))
        ]))

        r = space.parse("""
        f(<<-HERE, 3)
        abc
        HERE
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(2), "f", [
                ast.ConstantString("        abc\n"),
                ast.ConstantInt(3),
            ], None, 2))
        ]))

    def test_class(self, space):
        r = space.parse("""
        class X
        end""")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Class(ast.Scope(2), "X", None, ast.Nil()))
        ]))

        r = space.parse("""
        class
        X
        end""")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Class(ast.Scope(3), "X", None, ast.Nil()))
        ]))

        r = space.parse("""
        class X
            def f()
                2
            end
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Class(ast.Scope(2), "X", None, ast.Block([
                ast.Statement(ast.Function(None, "f", [], None, None, ast.Block([
                    ast.Statement(ast.ConstantInt(2))
                ])))
            ])))
        ]))

        assert space.parse("class X < Object; end") == ast.Main(ast.Block([
            ast.Statement(ast.Class(ast.Scope(1), "X", ast.Constant("Object", 1), ast.Nil()))
        ]))

        assert space.parse("class X < Module::Object; end") == ast.Main(ast.Block([
            ast.Statement(ast.Class(ast.Scope(1), "X", ast.LookupConstant(ast.Constant("Module", 1), "Object", 1), ast.Nil()))
        ]))

        r = space.parse("""
        class X < Object; end

        def f
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Class(ast.Scope(2), "X", ast.Constant("Object", 2), ast.Nil())),
            ast.Statement(ast.Function(None, "f", [], None, None, ast.Nil())),
        ]))

    def test_nest_class(self, space):
        r = space.parse("""
        class Foo::Bar
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Class(ast.Constant("Foo", 2), "Bar", None, ast.Nil()))
        ]))

    def test_singleton_class(self, space):
        r = space.parse("class << self; end")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.SingletonClass(ast.Self(1), ast.Nil(), 1))
        ]))

    def test_instance_variable(self, space):
        assert space.parse("@a") == ast.Main(ast.Block([
            ast.Statement(ast.InstanceVariable("@a"))
        ]))
        assert space.parse("@a = 3") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.InstanceVariable("@a"), ast.ConstantInt(3)))
        ]))

    def test_do_block(self, space):
        r = space.parse("""
        x.each do
            puts 1
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(2), "x", [], None, 2), "each", [], ast.SendBlock([], None, None, ast.Block([
                ast.Statement(ast.Send(ast.Self(3), "puts", [ast.ConstantInt(1)], None, 3))
            ])), 2))
        ]))
        r = space.parse("""
        x.each do ||
            puts 1
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(2), "x", [], None, 2), "each", [], ast.SendBlock([], None, None, ast.Block([
                ast.Statement(ast.Send(ast.Self(3), "puts", [ast.ConstantInt(1)], None, 3))
            ])), 2))
        ]))
        r = space.parse("""
        x.each do |a|
            puts a
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(2), "x", [], None, 2), "each", [], ast.SendBlock([ast.Argument("a")], None, None, ast.Block([
                ast.Statement(ast.Send(ast.Self(3), "puts", [ast.Variable("a", 3)], None, 3))
            ])), 2))
        ]))
        r = space.parse("""
        x.meth y.meth do end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(2), "x", [], None, 2), "meth", [ast.Send(ast.Send(ast.Self(2), "y", [], None, 2), "meth", [], None, 2)], ast.SendBlock([], None, None, ast.Nil()), 2))
        ]))
        assert space.parse("each do end") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "each", [], ast.SendBlock([], None, None, ast.Nil()), 1))
        ]))

        r = space.parse("""
        f nil do
        end.foo nil
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(2), "f", [ast.Nil()], ast.SendBlock([], None, None, ast.Nil()), 2), "foo", [ast.Nil()], None, 3))
        ]))

        r = space.parse("""
        run [] do |n|
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(2), "run", [ast.Array([])], ast.SendBlock([ast.Argument("n")], None, None, ast.Nil()), 2))
        ]))

        with self.raises(space, "SyntaxError"):
            space.parse("""
            Mod::Const do end
            """)

    def test_block(self, space):
        assert space.parse("[].map { |x| x }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Array([]), "map", [], ast.SendBlock([ast.Argument("x")], None, None, ast.Block([
                ast.Statement(ast.Variable("x", 1))
            ])), 1))
        ]))
        assert space.parse("[].inject(0) { |x, s| x + s }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Array([]), "inject", [ast.ConstantInt(0)], ast.SendBlock([ast.Argument("x"), ast.Argument("s")], None, None, ast.Block([
                ast.Statement(ast.Send(ast.Variable("x", 1), "+", [ast.Variable("s", 1)], None, 1))
            ])), 1))
        ]))
        assert space.parse("f { 5 }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock([], None, None, ast.Block([
                ast.Statement(ast.ConstantInt(5))
            ])), 1))
        ]))
        assert space.parse("f(3) { 5 }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [ast.ConstantInt(3)], ast.SendBlock([], None, None, ast.Block([
                ast.Statement(ast.ConstantInt(5))
            ])), 1))
        ]))
        assert space.parse("f { |*v| v }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock([], "v", None, ast.Block([
                ast.Statement(ast.Variable("v", 1))
            ])), 1))
        ]))
        assert space.parse("f (:a) { |b| 1 }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [ast.ConstantSymbol("a")], ast.SendBlock([ast.Argument("b")], None, None, ast.Block([
                ast.Statement(ast.ConstantInt(1)),
            ])), 1))
        ]))
        assert space.parse("a.b (:a) { }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(1), "a", [], None, 1), "b", [ast.ConstantSymbol("a")], ast.SendBlock([], None, None, ast.Nil()), 1))
        ]))
        assert space.parse("f { |a,| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock([ast.Argument("a")], "*", None, ast.Nil()), 1))
        ]))
        assert space.parse("f { |a, *s| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock([ast.Argument("a")], "s", None, ast.Nil()), 1))
        ]))
        assert space.parse("f { |&s| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock([], None, "s", ast.Nil()), 1))
        ]))
        assert space.parse("f { |b=1| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock([ast.Argument("b", ast.ConstantInt(1))], None, None, ast.Nil()), 1))
        ]))
        assert space.parse("f { |b=1, &s| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock([ast.Argument("b", ast.ConstantInt(1))], None, "s", ast.Nil()), 1))
        ]))
        assert space.parse("f { |x, b=1| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock([ast.Argument("x"), ast.Argument("b", ast.ConstantInt(1))], None, None, ast.Nil()), 1))
        ]))
        assert space.parse("f { |x, b=1, &s| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock([ast.Argument("x"), ast.Argument("b", ast.ConstantInt(1))], None, "s", ast.Nil()), 1))
        ]))
        assert space.parse("f { |x, b=1, *a, &s| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock([ast.Argument("x"), ast.Argument("b", ast.ConstantInt(1))], "a", "s", ast.Nil()), 1))
        ]))
        assert space.parse("f { |opt1=1, opt2=2| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock(
                [
                    ast.Argument("opt1", ast.ConstantInt(1)),
                    ast.Argument("opt2", ast.ConstantInt(2))
                ],
                None,
                None,
                ast.Nil()
            ), 1))
        ]))
        assert space.parse("f { |opt1=1, *rest, &blk| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock(
                [ast.Argument("opt1", ast.ConstantInt(1))],
                "rest",
                "blk",
                ast.Nil()
            ), 1))
        ]))
        assert space.parse("f { |a, (x, y)| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock(
                [
                    ast.Argument("a"),
                    ast.Argument("1"),
                ],
                None, None,
                ast.Block([ast.Statement(
                    ast.MultiAssignment(
                        ast.MultiAssignable([
                            ast.Variable("x", -1),
                            ast.Variable("y", -1),
                        ]),
                        ast.Variable("1", 1)
                    )
                )])
            ), 1)),
        ]))
        assert space.parse("f { |a, (x, (*, y, z)), d, *r, &b| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock(
                [
                    ast.Argument("a"),
                    ast.Argument("1"),
                    ast.Argument("d")
                ],
                "r",
                "b",
                ast.Block([ast.Statement(
                    ast.MultiAssignment(
                        ast.MultiAssignable([
                            ast.Variable("x", -1),
                            ast.MultiAssignable([
                                ast.Splat(None),
                                ast.Variable("y", -1),
                                ast.Variable("z", -1)
                            ])
                        ]),
                        ast.Variable("1", 1)
                    )
                )])
            ), 1)),
        ]))
        assert space.parse("f { |(x, y)| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock(
                [ast.Argument("0")],
                None,
                None,
                ast.Block([
                    ast.Statement(ast.MultiAssignment(
                        ast.MultiAssignable([
                            ast.Variable("x", -1),
                            ast.Variable("y", -1),
                        ]),
                        ast.Variable("0", 1),
                    ))
                ]),
            ), 1))
        ]))
        assert space.parse("f { |;x, y| }") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.SendBlock(
                [], None, None, ast.Nil(),
            ), 1))
        ]))

    def test_lambda(self, space):
        assert space.parse("->{}") == ast.Main(ast.Block([
            ast.Statement(ast.Lambda(ast.SendBlock([], None, None, ast.Nil())))
        ]))

    def test_parens_call(self, space):
        assert space.parse("blk.(1, 2)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(
                ast.Send(ast.Self(1), "blk", [], None, 1),
                "call",
                [ast.ConstantInt(1), ast.ConstantInt(2)],
                None,
                1
            ))
        ]))
        assert space.parse("blk::(1, 2)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(
                ast.Send(ast.Self(1), "blk", [], None, 1),
                "call",
                [ast.ConstantInt(1), ast.ConstantInt(2)],
                None,
                1
            ))
        ]))

    def test_yield(self, space):
        assert space.parse("yield") == ast.Main(ast.Block([
            ast.Statement(ast.Yield([], 1))
        ]))
        assert space.parse("yield 3, 4") == ast.Main(ast.Block([
            ast.Statement(ast.Yield([ast.ConstantInt(3), ast.ConstantInt(4)], 1))
        ]))
        assert space.parse("yield 4") == ast.Main(ast.Block([
            ast.Statement(ast.Yield([ast.ConstantInt(4)], 1))
        ]))
        assert space.parse("yield(*5)") == ast.Main(ast.Block([
            ast.Statement(ast.Yield([ast.Splat(ast.ConstantInt(5))], 1))
        ]))
        assert space.parse("yield()") == ast.Main(ast.Block([
            ast.Statement(ast.Yield([], 1))
        ]))

    def test_symbol(self, space):
        sym = lambda s: ast.Main(ast.Block([
            ast.Statement(ast.ConstantSymbol(s))
        ]))
        assert space.parse(":abc") == sym("abc")
        assert space.parse(":'abc'") == sym("abc")
        assert space.parse(":abc_abc") == sym("abc_abc")
        assert space.parse(":@abc") == sym("@abc")
        assert space.parse(":@@abc") == sym("@@abc")
        assert space.parse(":$abc") == sym("$abc")
        assert space.parse(':"@abc"') == sym("@abc")
        assert space.parse(':""') == sym("")
        assert space.parse(':"#{2}"') == ast.Main(ast.Block([
            ast.Statement(ast.Symbol(ast.DynamicString([ast.Block([ast.Statement(ast.ConstantInt(2))])]), 1))
        ]))
        assert space.parse("%s{foo bar}") == sym("foo bar")
        assert space.parse(":-@") == sym("-@")
        assert space.parse(":+@") == sym("+@")
        assert space.parse(":$-w") == sym("$-w")
        assert space.parse(u":åäö".encode("utf-8")) == sym(u"åäö".encode("utf-8"))
        assert space.parse(u":８ ９ ＡＢＣ".encode("utf-8")) == sym(u"８ ９ ＡＢＣ".encode("utf-8"))

    def test_do_symbol(self, space):
        r = space.parse("f :do")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [ast.ConstantSymbol("do")], None, 1)),
        ]))

    def test_range(self, space):
        assert space.parse("2..3") == ast.Main(ast.Block([
            ast.Statement(ast.Range(ast.ConstantInt(2), ast.ConstantInt(3), False))
        ]))
        assert space.parse("2...3") == ast.Main(ast.Block([
            ast.Statement(ast.Range(ast.ConstantInt(2), ast.ConstantInt(3), True))
        ]))
        assert space.parse("'abc'..'def'") == ast.Main(ast.Block([
            ast.Statement(ast.Range(ast.ConstantString("abc"), ast.ConstantString("def"), False))
        ]))
        assert space.parse("1..-1") == ast.Main(ast.Block([
            ast.Statement(ast.Range(ast.ConstantInt(1), ast.ConstantInt(-1), False))
        ]))

    def test_assign_method(self, space):
        assert space.parse("self.attribute = 3") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Send(ast.Self(1), "attribute", [], None, 1), ast.ConstantInt(3)))
        ]))

        assert space.parse("self.attribute.other_attr.other = 12") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Send(ast.Send(ast.Send(ast.Self(1), "attribute", [], None, 1), "other_attr", [], None, 1), "other", [], None, 1), ast.ConstantInt(12)))
        ]))

    def test_augmented_assignment(self, space):
        assert space.parse("i += 1") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("+", ast.Variable("i", 1), ast.ConstantInt(1)))
        ]))
        assert space.parse("i -= 1") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("-", ast.Variable("i", 1), ast.ConstantInt(1)))
        ]))
        assert space.parse("i *= 5") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("*", ast.Variable("i", 1), ast.ConstantInt(5)))
        ]))

        assert space.parse("self.x += 2") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("+", ast.Send(ast.Self(1), "x", [], None, 1), ast.ConstantInt(2)))
        ]))

        assert space.parse("@a += 3") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("+", ast.InstanceVariable("@a"), ast.ConstantInt(3)))
        ]))

        assert space.parse("self[1] += 2") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("+", ast.Subscript(ast.Self(1), [ast.ConstantInt(1)], 1), ast.ConstantInt(2)))
        ]))

        assert space.parse("x /= 2") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("/", ast.Variable("x", 1), ast.ConstantInt(2)))
        ]))

        assert space.parse("x %= 2") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("%", ast.Variable("x", 1), ast.ConstantInt(2)))
        ]))

        assert space.parse("x |= 2") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("|", ast.Variable("x", 1), ast.ConstantInt(2)))
        ]))

        assert space.parse("x &= 2") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("&", ast.Variable("x", 1), ast.ConstantInt(2)))
        ]))

        assert space.parse("x += f 2") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("+", ast.Variable("x", 1), ast.Send(ast.Self(1), "f", [ast.ConstantInt(2)], None, 1)))
        ]))

        assert space.parse("x ^= 3") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("^", ast.Variable("x", 1), ast.ConstantInt(3)))
        ]))

        assert space.parse("x <<= 3") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("<<", ast.Variable("x", 1), ast.ConstantInt(3)))
        ]))

        assert space.parse("x >>= 3") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment(">>", ast.Variable("x", 1), ast.ConstantInt(3)))
        ]))

        assert space.parse("@a += []") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("+", ast.InstanceVariable("@a"), ast.Array([])))
        ]))

    def test_block_result(self, space):
        r = space.parse("""
        [].inject(0) do |s, x|
            s + x
        end * 5
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Array([]), "inject", [ast.ConstantInt(0)], ast.SendBlock([ast.Argument("s"), ast.Argument("x")], None, None, ast.Block([
                ast.Statement(ast.Send(ast.Variable("s", 3), "+", [ast.Variable("x", 3)], None, 3))
            ])), 2), "*", [ast.ConstantInt(5)], None, 4))
        ]))

    def test_unary_neg(self, space):
        assert space.parse("-b") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(1), "b", [], None, 1), "-@", [], None, 1))
        ]))
        assert space.parse("Math.exp(-a)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Constant("Math", 1), "exp", [ast.Send(ast.Send(ast.Self(1), "a", [], None, 1), "-@", [], None, 1)], None, 1))
        ]))

    def test_unary_ops(self, space):
        assert space.parse("-yield") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Yield([], 1), "-@", [], None, 1))
        ]))
        assert space.parse("~3") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(3), "~", [], None, 1))
        ]))

    def test_unary_pos(self, space):
        assert space.parse("+100") == ast.Main(ast.Block([
            ast.Statement(ast.ConstantInt(100))
        ]))
        assert space.parse("+yield") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Yield([], 1), "+@", [], None, 1))
        ]))

    def test_unless(self, space):
        r = space.parse("""
        unless 1 == 2 then
            return 4
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.Send(ast.ConstantInt(1), "==", [ast.ConstantInt(2)], None, 2), ast.Nil(), ast.Block([
                ast.Return(ast.ConstantInt(4))
            ])))
        ]))

        r = space.parse("""
        unless 0
            5
        else
            7
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(0),
                ast.Block([ast.Statement(ast.ConstantInt(7))]),
                ast.Block([ast.Statement(ast.ConstantInt(5))]),
            ))
        ]))

    def test_constant_lookup(self, space):
        assert space.parse("Module::Constant") == ast.Main(ast.Block([
            ast.Statement(ast.LookupConstant(ast.Constant("Module", 1), "Constant", 1))
        ]))
        assert space.parse("X::m nil") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Constant("X", 1), "m", [ast.Nil()], None, 1))
        ]))
        assert space.parse("::Const") == ast.Main(ast.Block([
            ast.Statement(ast.LookupConstant(None, "Const", 1))
        ]))
        assert space.parse("abc::Constant = 5") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.LookupConstant(ast.Send(ast.Self(1), "abc", [], None, 1), "Constant", 1), ast.ConstantInt(5)))
        ]))

    def test_constant_assignment(self, space):
        assert space.parse("::Const = 5") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.LookupConstant(None, "Const", 1), ast.ConstantInt(5)))
        ]))

    def test___FILE__(self, space):
        assert space.parse("__FILE__") == ast.Main(ast.Block([
            ast.Statement(ast.File())
        ]))
        with self.raises(space, "SyntaxError"):
            space.parse("__FILE__ = 5")

    def test___LINE__(self, space):
        with self.raises(space, "SyntaxError"):
            space.parse("__LINE__ = 2")

    def test_function_default_arguments(self, space):
        function = lambda name, args: ast.Main(ast.Block([
            ast.Statement(ast.Function(None, name, args, None, None, ast.Nil()))
        ]))

        r = space.parse("""
        def f(a, b=3)
        end
        """)
        assert r == function("f", [ast.Argument("a"), ast.Argument("b", ast.ConstantInt(3))])

        r = space.parse("""
        def f(a, b, c=b)
        end
        """)
        assert r == function("f", [ast.Argument("a"), ast.Argument("b"), ast.Argument("c", ast.Variable("b", 2))])

        r = space.parse("""
        def f(a=3, b)
        end
        """)
        assert r == function("f", [ast.Argument("a", ast.ConstantInt(3)), ast.Argument("b")])

        r = space.parse("""
        def f(a, b=3, c)
        end
        """)
        assert r == function("f", [ast.Argument("a"), ast.Argument("b", ast.ConstantInt(3)), ast.Argument("c")])

        r = space.parse("""
        def f(a=1, b=2)
        end
        """)
        assert r == function("f", [ast.Argument("a", ast.ConstantInt(1)), ast.Argument("b", ast.ConstantInt(2))])

        with self.raises(space, "SyntaxError"):
            space.parse("""
            def f(a, b=3, c, d=5)
            end
            """)

    def test_exceptions(self, space):
        r = space.parse("""
        begin
            1 + 1
        rescue ZeroDivisionError
            puts 'zero'
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.TryExcept(
                ast.Block([
                    ast.Statement(ast.Send(ast.ConstantInt(1), "+", [ast.ConstantInt(1)], None, 3))
                ]),
                [
                    ast.ExceptHandler([ast.Constant("ZeroDivisionError", 4)], None, ast.Block([
                        ast.Statement(ast.Send(ast.Self(5), "puts", [ast.ConstantString("zero")], None, 5))
                    ]))
                ],
                ast.Nil()
            ))
        ]))

        r = space.parse("""
        begin
            1 / 0
        rescue ZeroDivisionError => e
            puts e
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.TryExcept(
                ast.Block([
                    ast.Statement(ast.Send(ast.ConstantInt(1), "/", [ast.ConstantInt(0)], None, 3))
                ]),
                [
                    ast.ExceptHandler([ast.Constant("ZeroDivisionError", 4)], ast.Variable("e", 4), ast.Block([
                        ast.Statement(ast.Send(ast.Self(5), "puts", [ast.Variable("e", 5)], None, 5))
                    ]))
                ],
                ast.Nil()
            ))
        ]))

        r = space.parse("""
        begin
            1 / 0
        rescue ZeroDivisionError => e
            puts e
        rescue NoMethodError
            puts '?'
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.TryExcept(
                ast.Block([
                    ast.Statement(ast.Send(ast.ConstantInt(1), "/", [ast.ConstantInt(0)], None, 3))
                ]),
                [
                    ast.ExceptHandler([ast.Constant("ZeroDivisionError", 4)], ast.Variable("e", 4), ast.Block([
                        ast.Statement(ast.Send(ast.Self(5), "puts", [ast.Variable("e", 5)], None, 5))
                    ])),
                    ast.ExceptHandler([ast.Constant("NoMethodError", 6)], None, ast.Block([
                        ast.Statement(ast.Send(ast.Self(7), "puts", [ast.ConstantString("?")], None, 7))
                    ])),
                ],
                ast.Nil()
            ))
        ]))

        r = space.parse("""
        begin
            1 / 0
        rescue
            5
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.TryExcept(
                ast.Block([
                    ast.Statement(ast.Send(ast.ConstantInt(1), "/", [ast.ConstantInt(0)], None, 3))
                ]),
                [
                    ast.ExceptHandler([], None, ast.Block([
                        ast.Statement(ast.ConstantInt(5))
                    ]))
                ],
                ast.Nil(),
            ))
        ]))

        r = space.parse("""
        begin
            1 / 0
        ensure
            puts 'ensure'
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.TryFinally(
                ast.Block([
                    ast.Statement(ast.Send(ast.ConstantInt(1), "/", [ast.ConstantInt(0)], None, 3))
                ]),
                ast.Block([
                    ast.Statement(ast.Send(ast.Self(5), "puts", [ast.ConstantString("ensure")], None, 5))
                ]),
            ))
        ]))

        r = space.parse("""
        begin
            1 / 0
        rescue ZeroDivisionError
            puts 'rescue'
        ensure
            puts 'ensure'
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.TryFinally(
                ast.TryExcept(
                    ast.Block([
                        ast.Statement(ast.Send(ast.ConstantInt(1), "/", [ast.ConstantInt(0)], None, 3))
                    ]),
                    [
                        ast.ExceptHandler([ast.Constant("ZeroDivisionError", 4)], None, ast.Block([
                            ast.Statement(ast.Send(ast.Self(5), "puts", [ast.ConstantString("rescue")], None, 5)),
                        ])),
                    ],
                    ast.Nil()
                ),
                ast.Block([
                    ast.Statement(ast.Send(ast.Self(7), "puts", [ast.ConstantString("ensure")], None, 7))
                ])
            ))
        ]))

        r = space.parse("""
        begin
            1 + 1
            1 / 0
        rescue
            puts 'rescue'
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.TryExcept(
                ast.Block([
                    ast.Statement(ast.Send(ast.ConstantInt(1), "+", [ast.ConstantInt(1)], None, 3)),
                    ast.Statement(ast.Send(ast.ConstantInt(1), "/", [ast.ConstantInt(0)], None, 4)),
                ]), [
                    ast.ExceptHandler([], None, ast.Block([
                        ast.Statement(ast.Send(ast.Self(6), "puts", [ast.ConstantString("rescue")], None, 6))
                    ]))
                ],
                ast.Nil(),
            ))
        ]))
        r = space.parse("""
        begin
            2
        else
            10
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.TryExcept(
                ast.Block([ast.Statement(ast.ConstantInt(2))]),
                [],
                ast.Block([ast.Statement(ast.ConstantInt(10))])
            ))
        ]))

        r = space.parse("""
        begin
            2
        rescue E1, E2
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.TryExcept(
                ast.Block([ast.Statement(ast.ConstantInt(2))]),
                [
                    ast.ExceptHandler([ast.Constant("E1", 4), ast.Constant("E2", 4)], None, ast.Nil()),
                ],
                ast.Nil(),
            ))
        ]))

        r = space.parse("""
        begin
        rescue Mod::Exc
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.TryExcept(
                ast.Nil(),
                [
                    ast.ExceptHandler(
                        [ast.LookupConstant(ast.Constant("Mod", 3), "Exc", 3)],
                        None,
                        ast.Nil(),
                    )
                ],
                ast.Nil(),
            ))
        ]))

    def test_def_exceptions(self, space):
        r = space.parse("""
        def f
            3
        rescue Exception => e
            5
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [], None, None, ast.TryExcept(
                ast.Block([ast.Statement(ast.ConstantInt(3))]),
                [
                    ast.ExceptHandler([ast.Constant("Exception", 4)], ast.Variable("e", 4), ast.Block([
                        ast.Statement(ast.ConstantInt(5))
                    ]))
                ],
                ast.Nil(),
            )))
        ]))

        r = space.parse("""
        def f
            10
        ensure
            5
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [], None, None, ast.TryFinally(
                ast.Block([ast.Statement(ast.ConstantInt(10))]),
                ast.Block([ast.Statement(ast.ConstantInt(5))]),
            )))
        ]))

    def test_begin(self, space):
        r = space.parse("""
        begin
            3
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Block([ast.Statement(ast.ConstantInt(3))]))
        ]))

    def test_module(self, space):
        r = space.parse("""
        module M
            def method
            end
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Module(ast.Scope(2), "M", ast.Block([
                ast.Statement(ast.Function(None, "method", [], None, None, ast.Nil()))
            ])))
        ]))

    def test_root_scope_module(self, space):
        r = space.parse("""
        module ::M
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Module(None, "M", ast.Nil()))
        ]))

    def test_question_mark(self, space):
        assert space.parse("obj.method?") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(1), "obj", [], None, 1), "method?", [], None, 1))
        ]))
        assert space.parse("def method?() end") == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "method?", [], None, None, ast.Nil()))
        ]))
        assert space.parse("method?") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "method?", [], None, 1))
        ]))
        with self.raises(space, "SyntaxError"):
            space.parse("method? = 4")

    def test_exclamation_point(self, space):
        assert space.parse("obj.method!") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(1), "obj", [], None, 1), "method!", [], None, 1))
        ]))
        assert space.parse("def method!() end") == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "method!", [], None, None, ast.Nil()))
        ]))
        assert space.parse("method!") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "method!", [], None, 1))
        ]))
        with self.raises(space, "SyntaxError"):
            space.parse("method! = 4")

    def test_singleton_method(self, space):
        r = space.parse("""
        def Array.hello
            'hello world'
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(ast.Constant("Array", 2), "hello", [], None, None, ast.Block([
                ast.Statement(ast.ConstantString("hello world")),
            ])))
        ]))
        r = space.parse("""
        def x.r=
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(ast.Send(ast.Self(2), "x", [], None, 2), "r=", [], None, None, ast.Nil()))
        ]))

    def test_global_var(self, space):
        r = space.parse("""
        $abc_123 = 3
        $abc
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Global("$abc_123"), ast.ConstantInt(3))),
            ast.Statement(ast.Global("$abc")),
        ]))
        simple_global = lambda s: ast.Main(ast.Block([
            ast.Statement(ast.Global(s))
        ]))
        assert space.parse("$>") == simple_global("$>")
        assert space.parse("$:") == simple_global("$:")
        assert space.parse("$$") == simple_global("$$")
        assert space.parse("$?") == simple_global("$?")
        assert space.parse("$\\") == simple_global("$\\")
        assert space.parse("$!") == simple_global("$!")
        assert space.parse('$"') == simple_global('$"')
        assert space.parse("$~") == simple_global("$~")
        assert space.parse("$&") == simple_global("$&")
        assert space.parse("$`") == simple_global("$`")
        assert space.parse("$'") == simple_global("$'")
        assert space.parse("$+") == simple_global("$+")
        assert space.parse("$,") == simple_global("$,")
        assert space.parse("$-w") == simple_global("$-w")
        assert space.parse("$@") == simple_global("$@")
        assert space.parse("$;") == simple_global("$;")
        assert space.parse("$<") == simple_global("$<")
        assert space.parse("$.") == simple_global("$.")

    def test_comments(self, space):
        r = space.parse("""
        #abc 123
        1 + 1 # more comment
        # another comment
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(1), "+", [ast.ConstantInt(1)], None, 3))
        ]))

    def test_send_block_argument(self, space):
        r = space.parse("f(&b)")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [], ast.BlockArgument(ast.Send(ast.Self(1), "b", [], None, 1)), 1))
        ]))

        r = space.parse("f(3, 4, &a)")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [ast.ConstantInt(3), ast.ConstantInt(4)], ast.BlockArgument(ast.Send(ast.Self(1), "a", [], None, 1)), 1))
        ]))

        with self.raises(space, "SyntaxError"):
            space.parse("f(&b, &b)")

        with self.raises(space, "SyntaxError"):
            space.parse("f(&b, a)")

        with self.raises(space, "SyntaxError"):
            space.parse("f(&b) {}")

        with self.raises(space, "SyntaxError"):
            space.parse("""
            f(&b) do ||
            end
            """)

    def test_declare_splat_argument(self, space):
        r = space.parse("def f(*args) end")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [], "args", None, ast.Nil()))
        ]))

        r = space.parse("def f(*args, &g) end")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [], "args", "g", ast.Nil()))
        ]))

        r = space.parse("def f(a, *) end")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [ast.Argument("a")], "*", None, ast.Nil()))
        ]))

        with self.raises(space, "SyntaxError"):
            space.parse("def f(*args, g=5)")

    def test_regexp(self, space):
        re = lambda re: ast.Main(ast.Block([
            ast.Statement(ast.ConstantRegexp(re, 0, 1))
        ]))
        dyn_re = lambda re: ast.Main(ast.Block([
            ast.Statement(ast.DynamicRegexp(re, 0))
        ]))
        assert space.parse("//") == re("")
        assert space.parse(r"/a/") == re("a")
        assert space.parse(r"/\w/") == re(r"\w")
        assert space.parse('%r{2}') == re("2")
        assert space.parse('%r{#{2}}') == dyn_re(ast.DynamicString([ast.Block([ast.Statement(ast.ConstantInt(2))])]))
        assert space.parse('/#{2}/') == dyn_re(ast.DynamicString([ast.Block([ast.Statement(ast.ConstantInt(2))])]))
        assert space.parse("%r!a!") == re("a")

    def test_regexp_flags(self, space):
        re = lambda re, flags: ast.Main(ast.Block([
            ast.Statement(ast.ConstantRegexp(re, flags, 1))
        ]))
        assert space.parse('/a/o') == re('a', regexp.ONCE)

    def test_unclosed_regexp(self, space):
        with self.raises(space, "SyntaxError"):
            space.parse("%r{abc")

    def test_or(self, space):
        assert space.parse("3 || 4") == ast.Main(ast.Block([
            ast.Statement(ast.Or(ast.ConstantInt(3), ast.ConstantInt(4)))
        ]))
        assert space.parse("3 + 4 || 4 * 5") == ast.Main(ast.Block([
            ast.Statement(ast.Or(
                ast.Send(ast.ConstantInt(3), "+", [ast.ConstantInt(4)], None, 1),
                ast.Send(ast.ConstantInt(4), "*", [ast.ConstantInt(5)], None, 1),
            ))
        ]))

    def test_and(self, space):
        assert space.parse("3 && 4") == ast.Main(ast.Block([
            ast.Statement(ast.And(ast.ConstantInt(3), ast.ConstantInt(4)))
        ]))
        assert space.parse("4 || 5 && 6") == ast.Main(ast.Block([
            ast.Statement(ast.Or(
                ast.ConstantInt(4),
                ast.And(ast.ConstantInt(5), ast.ConstantInt(6))
            ))
        ]))

    def test_not(self, space):
        assert space.parse("!3") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(3), "!", [], None, 1))
        ]))
        assert space.parse("not 3") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(3), "!", [], None, 1))
        ]))
        assert space.parse("f not(3)") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "f", [ast.Send(ast.ConstantInt(3), "!", [], None, 1)], None, 1))
        ]))
        assert space.parse("not()") == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Nil(), "!", [], None, 1))
        ]))

    def test_inline_if(self, space):
        assert space.parse("return 5 if 3") == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(3), ast.Block([
                ast.Return(ast.ConstantInt(5))
            ]), ast.Nil()))
        ]))

    def test_inline_unless(self, space):
        assert space.parse("return 5 unless 3") == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(3),
                ast.Nil(),
                ast.Block([ast.Return(ast.ConstantInt(5))]),
            ))
        ]))

    def test_inline_until(self, space):
        assert space.parse("i += 1 until 3") == ast.Main(ast.Block([
            ast.Statement(ast.Until(ast.ConstantInt(3), ast.Block([
                ast.Statement(ast.AugmentedAssignment("+", ast.Variable("i", 1), ast.ConstantInt(1)))
            ])))
        ]))

    def test_inline_while(self, space):
        assert space.parse("i += 1 while 3") == ast.Main(ast.Block([
            ast.Statement(ast.While(ast.ConstantInt(3), ast.Block([
                ast.Statement(ast.AugmentedAssignment("+", ast.Variable("i", 1), ast.ConstantInt(1)))
            ])))
        ]))

    def test_inline_rescue(self, space):
        assert space.parse("foo rescue bar") == ast.Main(ast.Block([
            ast.Statement(ast.TryExcept(
                ast.Block([ast.Statement(ast.Send(ast.Self(1), "foo", [], None, 1))]),
                [
                    ast.ExceptHandler([ast.LookupConstant(ast.Scope(1), "StandardError", 1)], None, ast.Block([
                        ast.Statement(ast.Send(ast.Self(1), "bar", [], None, 1))
                    ]))
                ],
                ast.Nil(),
            ))
        ]))
        assert space.parse("a = 2 rescue 3") == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Variable("a", 1), ast.TryExcept(
                ast.ConstantInt(2),
                [
                    ast.ExceptHandler([ast.LookupConstant(ast.Scope(1), "StandardError", 1)], None, ast.ConstantInt(3))
                ],
                ast.Nil(),
            )))
        ]))
        assert space.parse("a += 2 rescue 3") == ast.Main(ast.Block([
            ast.Statement(ast.AugmentedAssignment("+", ast.Variable("a", 1), ast.TryExcept(
                ast.ConstantInt(2),
                [
                    ast.ExceptHandler([ast.LookupConstant(ast.Scope(1), "StandardError", 1)], None, ast.ConstantInt(3))
                ],
                ast.Nil(),
            )))
        ]))

    def test_inline_precedence(self, space):
        assert space.parse("return unless x = 3") == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.Assignment(ast.Variable("x", 1), ast.ConstantInt(3)),
                ast.Nil(),
                ast.Block([
                    ast.Return(ast.Nil()),
                ])
            ))
        ]))
        r = space.parse("""
        def f
            return unless x = 3
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [], None, None, ast.Block([
                ast.Statement(ast.If(ast.Assignment(ast.Variable("x", 3), ast.ConstantInt(3)),
                    ast.Nil(),
                    ast.Block([
                        ast.Return(ast.Nil())
                    ])
                ))
            ])))
        ]))

    def test_ternary_operator(self, space):
        assert space.parse("3 ? 2 : 5") == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(3),
                ast.ConstantInt(2),
                ast.ConstantInt(5),
            ))
        ]))
        assert space.parse("0 ? nil : nil") == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(0),
                ast.Nil(),
                ast.Nil(),
            ))
        ]))
        assert space.parse("empty? ? '[]' : nil") == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.Send(ast.Self(1), "empty?", [], None, 1),
                ast.ConstantString("[]"),
                ast.Nil(),
            ))
        ]))
        assert space.parse("0 ? ?- : ?w") == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(0),
                ast.ConstantString("-"),
                ast.ConstantString("w"),
            ))
        ]))
        assert space.parse("0 ? ?T:0") == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(0),
                ast.ConstantString("T"),
                ast.ConstantInt(0),
            ))
        ]))
        r = space.parse("""
        (0 ? 0 : '')
        0
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Block([ast.Statement(ast.If(ast.ConstantInt(0),
                ast.ConstantInt(0),
                ast.ConstantString(""),
            ))])),
            ast.Statement(ast.ConstantInt(0)),
        ]))
        assert space.parse("0 ? (0) :(0)") == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(0),
                ast.Block([ast.Statement(ast.ConstantInt(0))]),
                ast.Block([ast.Statement(ast.ConstantInt(0))]),
            ))
        ]))
        r = space.parse("""
        0 ? (0) :
                 0
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(0),
                ast.Block([ast.Statement(ast.ConstantInt(0))]),
                ast.ConstantInt(0),
            ))
        ]))
        r = space.parse("""
        0 ?
        (0) : 0
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(0),
                ast.Block([ast.Statement(ast.ConstantInt(0))]),
                ast.ConstantInt(0),
            ))
        ]))

    def test_case(self, space):
        r = space.parse("""
        case 3
        when 5 then
            6
        when 4
            7
        else
            9
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Case(ast.ConstantInt(3), [
                ast.When([ast.ConstantInt(5)], ast.Block([ast.Statement(ast.ConstantInt(6))]), 3),
                ast.When([ast.ConstantInt(4)], ast.Block([ast.Statement(ast.ConstantInt(7))]), 5)
            ], ast.Block([ast.Statement(ast.ConstantInt(9))])))
        ]))
        r = space.parse("""
        case 3
        when 4,5 then
            6
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Case(ast.ConstantInt(3), [
                ast.When([ast.ConstantInt(4), ast.ConstantInt(5)], ast.Block([ast.Statement(ast.ConstantInt(6))]), 3),
            ], ast.Nil()))
        ]))

    def test_case_regexp(self, space):
        r = space.parse("""
        case 0
        when /a/
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Case(ast.ConstantInt(0), [
                ast.When([ast.ConstantRegexp("a", 0, 3)], ast.Nil(), 3)
            ], ast.Nil()))
        ]))

    def test_case_without_expr(self, space):
        r = space.parse("""
        case
        when 3 then
            5
        when 4 == 2
            3
        else
            9
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(3), ast.Block([
                ast.Statement(ast.ConstantInt(5))
            ]),
                ast.If(ast.Send(ast.ConstantInt(4), "==", [ast.ConstantInt(2)], None, 5), ast.Block([
                    ast.Statement(ast.ConstantInt(3))
                ]), ast.Block([
                    ast.Statement(ast.ConstantInt(9))
                ]))
            ))
        ]))
        r = space.parse("""
        case
        when 4,5 then
            6
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.Or(ast.ConstantInt(4), ast.ConstantInt(5)), ast.Block([
                ast.Statement(ast.ConstantInt(6))
            ]), ast.Nil()))
        ]))
        r = space.parse("""
        case
        when 4
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.If(ast.ConstantInt(4), ast.Nil(), ast.Nil()))
        ]))

    def test_and_regexp(self, space):
        assert space.parse("3 && /a/") == ast.Main(ast.Block([
            ast.Statement(ast.And(ast.ConstantInt(3), ast.ConstantRegexp("a", 0, 1)))
        ]))

    def test_hash(self, space):
        assert space.parse("{}") == ast.Main(ast.Block([
            ast.Statement(ast.Hash([]))
        ]))
        assert space.parse("{:abc => 3, :def => 5}") == ast.Main(ast.Block([
            ast.Statement(ast.Hash([
                (ast.ConstantSymbol("abc"), ast.ConstantInt(3)),
                (ast.ConstantSymbol("def"), ast.ConstantInt(5)),
            ]))
        ]))
        r = space.parse("""
        {
            :k => :v
        }
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Hash([
                (ast.ConstantSymbol("k"), ast.ConstantSymbol("v")),
            ]))
        ]))
        assert space.parse("{a = 2 => 3, yield => 5}") == ast.Main(ast.Block([
            ast.Statement(ast.Hash([
                (ast.Assignment(ast.Variable("a", 1), ast.ConstantInt(2)), ast.ConstantInt(3)),
                (ast.Yield([], 1), ast.ConstantInt(5))
            ]))
        ]))
        r = space.parse("""
        x ||= {
        }
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.OrEqual(ast.Variable("x", 2), ast.Hash([])))
        ]))

    def test_new_hash(self, space):
        r = space.parse("{a: 2, :b => 3, c: 4}")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Hash([
                (ast.ConstantSymbol("a"), ast.ConstantInt(2)),
                (ast.ConstantSymbol("b"), ast.ConstantInt(3)),
                (ast.ConstantSymbol("c"), ast.ConstantInt(4)),
            ]))
        ]))

    def test_newline(self, space):
        r = space.parse("""
        x = 123 &&
            456
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.Variable("x", 2), ast.And(ast.ConstantInt(123), ast.ConstantInt(456))))
        ]))

        r = space.parse("""
        f {
        }
        1
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(2), "f", [], ast.SendBlock([], None, None, ast.Nil()), 2)),
            ast.Statement(ast.ConstantInt(1))
        ]))

        r = space.parse("""
        f()\\
            .m()
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Send(ast.Self(2), "f", [], None, 2), "m", [], None, 3))
        ]))

    def test_or_equal(self, space):
        r = space.parse("@a ||= 5")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.OrEqual(ast.InstanceVariable("@a"), ast.ConstantInt(5)))
        ]))

    def test_and_equal(self, space):
        r = space.parse("x &&= 10")
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.AndEqual(ast.Variable("x", 1), ast.ConstantInt(10)))
        ]))

    def test_class_variables(self, space):
        r = space.parse("""
        @@a = @@b
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Assignment(ast.ClassVariable("@@a", 2), ast.ClassVariable("@@b", 2)))
        ]))

    def test_shellout(self, space):
        shellout = lambda *components: ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.Self(1), "`", list(components), None, 1))
        ]))
        assert space.parse("`ls`") == shellout(ast.ConstantString("ls"))
        assert space.parse('%x(ls)') == shellout(ast.ConstantString("ls"))
        assert space.parse("`#{2}`") == shellout(ast.DynamicString([ast.Block([ast.Statement(ast.ConstantInt(2))])]))
        assert space.parse("%x(#{2})") == shellout(ast.DynamicString([ast.Block([ast.Statement(ast.ConstantInt(2))])]))

    def test_strings(self, space):
        cstr = lambda c: ast.Main(ast.Block([
            ast.Statement(ast.ConstantString(c))
        ]))
        assert space.parse("'a' 'b' 'c'") == cstr("abc")
        assert space.parse("'a' \"b\"") == cstr("ab")
        assert space.parse('"a" "b"') == cstr("ab")
        assert space.parse('"a" \'b\'') == cstr("ab")
        assert space.parse("""
        'a' \\
        'b'
        """) == cstr("ab")
        assert space.parse("%{a} 'b'") == cstr("ab")
        with self.raises(space, "SyntaxError"):
            space.parse("%{a} %{b}")
        with self.raises(space, "SyntaxError"):
            space.parse("%{a} 'b' %{b}")
        with self.raises(space, "SyntaxError"):
            space.parse("'b' %{b}")

    def test_alias(self, space):
        assert space.parse("alias a b") == ast.Main(ast.Block([
            ast.Alias(ast.ConstantSymbol("a"), ast.ConstantSymbol("b"), 1)
        ]))
        assert space.parse("alias << b") == ast.Main(ast.Block([
            ast.Alias(ast.ConstantSymbol("<<"), ast.ConstantSymbol("b"), 1)
        ]))
        assert space.parse("alias :a :b") == ast.Main(ast.Block([
            ast.Alias(ast.ConstantSymbol("a"), ast.ConstantSymbol("b"), 1)
        ]))

    def test_defined(self, space):
        assert space.parse("defined? Const") == ast.Main(ast.Block([
            ast.Statement(ast.Defined(ast.Constant("Const", 1), 1))
        ]))
        assert space.parse("defined?(3)") == ast.Main(ast.Block([
            ast.Statement(ast.Defined(ast.ConstantInt(3), 1))
        ]))

    def test_super(self, space):
        assert space.parse("super") == ast.Main(ast.Block([
            ast.Statement(ast.Super([], None, 1))
        ]))
        assert space.parse("super(nil)") == ast.Main(ast.Block([
            ast.Statement(ast.Super([ast.Nil()], None, 1))
        ]))
        assert space.parse("super nil") == ast.Main(ast.Block([
            ast.Statement(ast.Super([ast.Nil()], None, 1))
        ]))
        assert space.parse("super()") == ast.Main(ast.Block([
            ast.Statement(ast.Super([], None, 1))
        ]))

    def test_next(self, space):
        assert space.parse("next") == ast.Main(ast.Block([
            ast.Next(ast.Nil())
        ]))
        assert space.parse("next true") == ast.Main(ast.Block([
            ast.Next(ast.ConstantBool(True))
        ]))
        assert space.parse("next 3, 4") == ast.Main(ast.Block([
            ast.Next(ast.Array([ast.ConstantInt(3), ast.ConstantInt(4)]))
        ]))

    def test_break(self, space):
        assert space.parse("break") == ast.Main(ast.Block([
            ast.Break(ast.Nil())
        ]))
        assert space.parse("break true") == ast.Main(ast.Block([
            ast.Break(ast.ConstantBool(True))
        ]))
        assert space.parse("break 3, 4") == ast.Main(ast.Block([
            ast.Break(ast.Array([ast.ConstantInt(3), ast.ConstantInt(4)]))
        ]))

    def test_undef(self, space):
        r = space.parse("""
        class X
            undef to_s
        end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Class(ast.Scope(2), "X", None, ast.Block([
                ast.Undef([ast.ConstantSymbol("to_s")], 3)
            ])))
        ]))

    def test_custom_lineno(self, space):
        with self.raises(space, "SyntaxError", "line 1"):
            assert space.parse("[]{}[]")
        with self.raises(space, "SyntaxError", "line 10"):
            assert space.parse("[]{}[]", 10)

    def test_lineno(self, space):
        r = space.parse("""
        <<HERE

HERE
        __LINE__
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.ConstantString("\n")),
            ast.Statement(ast.Line(5)),
        ]))

        r = space.parse("""
        %W(hello
           world)
        __LINE__
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Array([ast.ConstantString("hello"), ast.ConstantString("world")])),
            ast.Statement(ast.Line(4)),
        ]))

        r = space.parse("""
        %w(a\\
b)
        __LINE__
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Array([ast.ConstantString("a\nb")])),
            ast.Statement(ast.Line(4)),
        ]))

    def test_multiline_comments(self, space):
        r = space.parse("""
        1 + 1
=begin
foo bar
=end
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(1), "+", [ast.ConstantInt(1)], None, 2))
        ]))

        with self.raises(space, 'SyntaxError'):
            space.parse(" =begin\nfoo\n=end")

        with self.raises(space, 'SyntaxError'):
            space.parse("=begin\nfoo\nbar")

        with self.raises(space, 'SyntaxError'):
            space.parse("=foo\nbar\n=end")

        with self.raises(space, 'SyntaxError'):
            space.parse("=begin\nbar\n=foo")

    def test_multiline_comments_lineno(self, space):
        r = space.parse("""
=begin
some
lines
=end
        1 + 1
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Send(ast.ConstantInt(1), "+", [ast.ConstantInt(1)], None, 6))
        ]))

    def test_call_no_space_symbol(self, space):
        r = space.parse("""
        def f
        end

        f:bar
        """)
        assert r == ast.Main(ast.Block([
            ast.Statement(ast.Function(None, "f", [], None, None, ast.Nil())),
            ast.Statement(ast.Send(ast.Self(5), "f", [ast.ConstantSymbol("bar")], None, 5))
        ]))

########NEW FILE########
__FILENAME__ = test_glob
from topaz.objects.fileobject import FNM_NOESCAPE, FNM_DOTMATCH
from topaz.objects.regexpobject import RegexpCache
from topaz.utils.glob import Glob

from ..base import BaseTopazTest


class GlobHelper(object):
    def __init__(self, space, tmpdir, monkeypatch):
        self.space = space
        self.tmpdir = tmpdir
        monkeypatch.chdir(tmpdir)

    def create_paths(self, mock_files):
        for path in mock_files:
            self.tmpdir.join(path).ensure()

    def glob(self, pattern, flags=0):
        glob = Glob(self.space.fromcache(RegexpCache))
        glob.glob(pattern, flags)
        return glob.matches()

    def sglob(self, pattern, flags=0):
        return sorted(self.glob(pattern, flags))


def pytest_funcarg__glob_helper(request):
    space = request.getfuncargvalue("space")
    tmpdir = request.getfuncargvalue("tmpdir")
    monkeypatch = request.getfuncargvalue("monkeypatch")
    return GlobHelper(space, tmpdir, monkeypatch)


class TestGlob(BaseTopazTest):
    """
    These tests are almost entirely copied from rubyspec. They are included
    separately here because globs are required for running specs.
    """

    def test_absolute(self, glob_helper):
        assert glob_helper.glob("/") == ["/"]

    def test_non_dotfiles_with_star(self, glob_helper):
        glob_helper.create_paths([
            ".dotfile", ".dotsubdir/.dotfile", ".dotsubdir/nondotfile",
            "file_one.ext", "file_two.ext", "nondotfile"
        ])
        assert glob_helper.sglob("*") == [
            "file_one.ext", "file_two.ext", "nondotfile"
        ]
        assert glob_helper.sglob("**") == [
            "file_one.ext", "file_two.ext", "nondotfile"]
        assert glob_helper.sglob("*file") == ["nondotfile"]

    def test_dotfiles_with_star(self, glob_helper):
        glob_helper.create_paths([
            ".dotfile", ".dotsubdir/.dotfile", ".dotsubdir/nondotfile",
            "file_one.ext", "file_two.ext", "nondotfile"
        ])
        assert glob_helper.sglob(".*") == [".", "..", ".dotfile", ".dotsubdir"]
        assert glob_helper.sglob(".**") == [
            ".", "..", ".dotfile", ".dotsubdir"
        ]
        assert glob_helper.sglob(".*file") == [".dotfile"]

    def test_empty_pattern_no_matches(self, glob_helper):
        assert glob_helper.glob("") == []

    def test_regexp_specials(self, glob_helper):
        glob_helper.create_paths([
            "special/+", "special/^", "special/$", "special/(", "special/)",
            "special/[", "special/]", "special/{", "special/}"
        ])
        assert glob_helper.glob("special/+") == ["special/+"]
        assert glob_helper.glob("special/^") == ["special/^"]
        assert glob_helper.glob("special/$") == ["special/$"]
        assert glob_helper.glob("special/(") == ["special/("]
        assert glob_helper.glob("special/)") == ["special/)"]
        assert glob_helper.glob("special/\\[") == ["special/["]
        assert glob_helper.glob("special/]") == ["special/]"]
        assert glob_helper.glob("special/\\{") == ["special/{"]
        assert glob_helper.glob("special/\\}") == ["special/}"]

        # TODO: Skip these on Windows
        glob_helper.create_paths(["special/*", "special/?", "special/|"])
        assert glob_helper.glob("special/\\*") == ["special/*"]
        assert glob_helper.glob("special/\\?") == ["special/?"]
        assert glob_helper.glob("special/|") == ["special/|"]

    def test_matches_paths_with_globs(self, glob_helper):
        glob_helper.create_paths(["special/test{1}/file[1]"])
        assert glob_helper.glob("special/test\\{1\\}/*") == [
            "special/test{1}/file[1]"
        ]

    def test_dstar_recursion(self, glob_helper):
        glob_helper.create_paths([
            ".dotfile", ".dotsubdir/.dotfile", ".dotsubdir/nondotfile",
            "file_one.ext", "file_two.ext", "nondotfile",
            "subdir_one/.dotfile", "subdir_one/nondotfile",
            "subdir_two/nondotfile", "subdir_two/nondotfile.ext",
            "deeply/.dotfile", "deeply/nested/.dotfile.ext",
            "deeply/nested/directory/structure/.ext",
            "deeply/nested/directory/structure/file_one",
            "deeply/nested/directory/structure/file_one.ext",
            "deeply/nested/directory/structure/foo", "deeply/nondotfile"
        ])
        assert glob_helper.sglob("**/") == [
            "deeply/", "deeply/nested/", "deeply/nested/directory/",
            "deeply/nested/directory/structure/", "subdir_one/", "subdir_two/"
        ]
        assert glob_helper.sglob("**/*fil*") == [
            "deeply/nested/directory/structure/file_one",
            "deeply/nested/directory/structure/file_one.ext",
            "deeply/nondotfile", "file_one.ext", "file_two.ext", "nondotfile",
            "subdir_one/nondotfile", "subdir_two/nondotfile",
            "subdir_two/nondotfile.ext"
        ]

    def test_question_mark(self, glob_helper):
        glob_helper.create_paths(["subdir_one", "subdir_two"])
        assert glob_helper.sglob("?ubdir_one") == ["subdir_one"]
        assert glob_helper.sglob("subdir_???") == ["subdir_one", "subdir_two"]

    def test_character_group(self, glob_helper):
        glob_helper.create_paths(["subdir_one", "subdir_two"])
        assert glob_helper.sglob("[stfu]ubdir_one") == ["subdir_one"]
        assert glob_helper.sglob("[A-Za-z]ubdir_one") == ["subdir_one"]
        assert glob_helper.sglob("subdir_[a-z][a-z][a-z]") == [
            "subdir_one", "subdir_two"
        ]

    def test_negated_character_group(self, glob_helper):
        glob_helper.create_paths(["subdir_one", "subdir_two"])
        assert glob_helper.sglob("[^stfu]ubdir_one") == []
        assert glob_helper.sglob("[^wtf]ubdir_one") == ["subdir_one"]
        assert glob_helper.sglob("[^a-zA-Z]ubdir_one") == []
        assert glob_helper.sglob("[^0-9a-fA-F]ubdir_one") == ["subdir_one"]

    def test_braces(self, glob_helper):
        glob_helper.create_paths([
            ".dotfile", ".dotsubdir/.dotfile", ".dotsubdir/nondotfile",
            "subdir_one/.dotfile", "subdir_one/nondotfile",
            "subdir_two/nondotfile", "subdir_two/nondotfile.ext"
        ])
        assert glob_helper.sglob("subdir_{one,two,three}") == [
            "subdir_one", "subdir_two"
        ]
        assert glob_helper.sglob("sub*_{one,two,three}") == [
            "subdir_one", "subdir_two"
        ]
        assert glob_helper.sglob("subdir_two/nondotfile{.ext,}") == [
            "subdir_two/nondotfile", "subdir_two/nondotfile.ext"
        ]
        assert glob_helper.sglob("{,.}*") == [
            ".", "..", ".dotfile", ".dotsubdir", "subdir_one", "subdir_two"
        ]

    def test_braces_ordering(self, glob_helper):
        glob_helper.create_paths([
            "brace/a", "brace/a.js", "brace/a.erb", "brace/a.js.rjs",
            "brace/a.html.erb"
        ])
        assert glob_helper.glob("brace/a{.js,.html}{.erb,.rjs}") == [
            "brace/a.js.rjs", "brace/a.html.erb"
        ]
        assert glob_helper.glob("brace/a{.{js,html},}{.{erb,rjs},}") == [
            "brace/a.js.rjs", "brace/a.js", "brace/a.html.erb", "brace/a.erb",
            "brace/a"
        ]

    def test_escaping(self, glob_helper):
        glob_helper.create_paths(["foo^bar", "nondotfile"])
        assert glob_helper.glob("foo?bar") == ["foo^bar"]
        assert glob_helper.glob("foo\\?bar") == []
        assert glob_helper.glob("nond\\otfile") == ["nondotfile"]

    def test_preserves_separator(self, glob_helper):
        glob_helper.create_paths([
            "deeply/nested/directory/structure/file_one.ext"
        ])
        assert glob_helper.glob("deeply/nested//directory/*/*.ext") == [
            "deeply/nested//directory/structure/file_one.ext"
        ]
        assert glob_helper.glob("deeply/*/directory/structure//**/*.ext") == [
            "deeply/nested/directory/structure//file_one.ext"
        ]

    def test_ignores_missing_dirs(self, glob_helper):
        assert glob_helper.glob("deeply/notthere/blah*/whatever") == []
        assert glob_helper.glob("deeply/notthere/blah/") == []

    def test_multiple_recursives(self, glob_helper):
        glob_helper.create_paths(["a/x/b/y/e", "a/x/b/y/b/z/e"])
        assert glob_helper.sglob("a/**/b/**/e") == [
            "a/x/b/y/b/z/e", "a/x/b/y/e"
        ]

    def test_flag_dotmatch(self, glob_helper):
        glob_helper.create_paths([
            ".dotfile", ".dotsubdir/.dotfile", ".dotsubdir/nondotfile",
            "file_one.ext", "file_two.ext", "nondotfile",
            "deeply/nested/.dotfile.ext"
        ])
        assert glob_helper.sglob("*", FNM_DOTMATCH) == [
            ".", "..", ".dotfile", ".dotsubdir", "deeply", "file_one.ext",
            "file_two.ext", "nondotfile"
        ]
        assert glob_helper.sglob("**", FNM_DOTMATCH) == [
            ".", "..", ".dotfile", ".dotsubdir", "deeply", "file_one.ext",
            "file_two.ext", "nondotfile"
        ]
        assert glob_helper.sglob("*file", FNM_DOTMATCH) == [
            ".dotfile", "nondotfile"
        ]
        assert glob_helper.sglob("**/", FNM_DOTMATCH) == [
            ".dotsubdir/", "deeply/", "deeply/nested/"
        ]
        assert glob_helper.sglob("./**/", FNM_DOTMATCH) == [
            "./", "./.dotsubdir/", "./deeply/", "./deeply/nested/"
        ]

    def test_flag_noescape(self, glob_helper):
        # TODO: Skip this on Windows
        glob_helper.create_paths(["foo?bar"])
        assert glob_helper.glob("foo?bar", FNM_NOESCAPE) == ["foo?bar"]
        assert glob_helper.glob("foo\\?bar", FNM_NOESCAPE) == []
        glob_helper.create_paths(["foo\\?bar"])
        assert glob_helper.glob("foo\\?bar", FNM_NOESCAPE) == ["foo\\?bar"]

########NEW FILE########
__FILENAME__ = test_ordereddict
from rpython.rtyper.test.test_llinterp import interpret

from topaz.utils.ordereddict import OrderedDict


class Runner(object):
    def __init__(self):
        self.functions = []

    def func(self, f):
        self.functions.append(f)
        return f


class Simple(object):
    def __init__(self, x):
        self.x = x

    @staticmethod
    def eq(x, y):
        return x.x == y.x

    @staticmethod
    def hash(x):
        return x.x


class BaseTestOrderedDict(object):
    runner = Runner()

    @runner.func
    def create():
        OrderedDict()
        return 0

    def test_create(self):
        self.create()

    @runner.func
    def simple_get_set():
        o = OrderedDict()
        o["a"] = 2
        return o["a"]

    def test_simple_get_set(self):
        assert self.simple_get_set() == 2

    @runner.func
    def get_set_object(n):
        x = Simple(n)
        o = OrderedDict()
        o[x] = x
        return o[x].x

    def test_get_set_object(self):
        assert self.get_set_object(10) == 10

    @runner.func
    def delitem(n):
        o = OrderedDict()
        o[2] = 3
        o[3] = 4
        del o[n]
        vals = o.values()
        return vals[0] * 10 + len(vals)

    def test_delitem(self):
        assert self.delitem(2) == 41
        assert self.delitem(3) == 31

    @runner.func
    def len(n):
        o = OrderedDict()
        for i in xrange(n):
            o[i] = i
        return len(o)

    def test_len(self):
        assert self.len(2) == 2
        assert self.len(0) == 0

    @runner.func
    def custom_eq_hash(n):
        o = OrderedDict(Simple.eq, Simple.hash)
        o[Simple(n)] = 23
        return o[Simple(n)]

    def test_custom_eq_hash(self):
        assert self.custom_eq_hash(15) == 23

    @runner.func
    def merge_dicts(n):
        if n:
            o = OrderedDict()
            o[5] = 10
        else:
            o = OrderedDict()
            o[2] = 20
        o[3] = 30
        return o[3]

    def test_merge_dicts(self):
        assert self.merge_dicts(1) == 30

    @runner.func
    def grow(n):
        o = OrderedDict()
        for i in xrange(n):
            o[i] = -20
        return o[3]

    def test_grow(self):
        assert self.grow(10) == -20

    @runner.func
    def keys(n):
        o = OrderedDict()
        o[4] = 1
        o[5] = 2
        o[4] = 2
        return o.keys()[n]

    def test_keys(self):
        assert self.keys(0) == 4
        assert self.keys(1) == 5

    @runner.func
    def values(n):
        o = OrderedDict()
        o[4] = 1
        o[5] = 2
        o[4] = 3
        return o.values()[n]

    def test_values(self):
        assert self.values(0) == 3
        assert self.values(1) == 2

    @runner.func
    def keys_object(n):
        o = OrderedDict()
        o[Simple(1)] = None
        o[Simple(2)] = None
        o[Simple(3)] = None
        return o.keys()[n].x

    def test_keys_object(self):
        assert self.keys_object(2) == 3

    @runner.func
    def get(n):
        o = OrderedDict()
        o[4] = 3
        return o.get(n, 123)

    def test_get(self):
        assert self.get(12) == 123
        assert self.get(4) == 3

    @runner.func
    def iteritems(n):
        o = OrderedDict()
        o[0] = 10
        o[2] = 15
        o[3] = 12
        r = []
        for k, v in o.iteritems():
            r.append((k, v))
        p = r[n]
        return p[0] * 100 + p[1]

    def test_iteritems(self):
        assert self.iteritems(0) == 10
        assert self.iteritems(2) == 312
        assert self.iteritems(1) == 215

    @runner.func
    def iteritems_next_method(n):
        o = OrderedDict()
        o[n] = 5
        it = o.iteritems()
        return it.next()[1]

    def test_iteritems_next_method(self):
        assert self.iteritems_next_method(2) == 5

    @runner.func
    def contains(n):
        o = OrderedDict()
        o[4] = 5
        return n in o

    def test_contains(self):
        assert self.contains(4)
        assert not self.contains(5)

    @runner.func
    def pop(n):
        o = OrderedDict()
        o[1] = 12
        o[2] = 3
        return (o.pop(n) * 10) + len(o)

    def test_pop(self):
        assert self.pop(1) == 121
        assert self.pop(2) == 31

    @runner.func
    def pop_default(n, d):
        o = OrderedDict()
        o[1] = 12
        o[2] = 3
        return (o.pop(n, d) * 10) + len(o)

    def test_pop_default(self):
        assert self.pop_default(10, 14) == 142

    @runner.func
    def pop_keyerror(n):
        o = OrderedDict()
        o[3] = 4
        try:
            return o.pop(n)
        except KeyError:
            return 500

    def test_pop_keyerror(self):
        assert self.pop_keyerror(3) == 4
        assert self.pop_keyerror(12) == 500

    @runner.func
    def update(n):
        o = OrderedDict()
        o[3] = 4
        v = OrderedDict()
        v[n] = 5
        o.update(v)
        return o[3]

    def test_update(self):
        assert self.update(3) == 5
        assert self.update(22) == 4

    @runner.func
    def clear():
        o = OrderedDict()
        o[3] = 4
        o.clear()
        return len(o)

    def test_clear(self):
        assert self.clear() == 0

    @runner.func
    def truthy(n):
        o = OrderedDict()
        if n:
            o[n] = n
        return bool(o)

    def test_truthiness(self):
        assert self.truthy(3)
        assert not self.truthy(0)

    @runner.func
    def popitem(n):
        o = OrderedDict()
        if n:
            o[n] = n
        try:
            key, val = o.popitem()
        except KeyError:
            return 400
        else:
            return key * 10 + val

    def test_popitem(self):
        assert self.popitem(0) == 400
        assert self.popitem(4) == 44

    @runner.func
    def copy(n):
        o = OrderedDict(Simple.eq, Simple.hash)
        o[Simple(n)] = n
        d = o.copy()
        return d.values()[0] * 10 + len(d)

    def test_copy(self):
        assert self.copy(3) == 31


class TestPythonOrderedDict(BaseTestOrderedDict):
    def setup_class(cls):
        for func in cls.runner.functions:
            setattr(cls, func.__name__, staticmethod(func))


class TestRPythonOrderedDict(BaseTestOrderedDict):
    def setup_class(cls):
        def f(n, arg0, arg1):
            if arg0 == -1:
                return funcs0[n]()
            else:
                if arg1 == -1:
                    return funcs1[n](arg0)
                else:
                    return funcs2[n](arg0, arg1)

        def make_caller(i):
            def inner(arg0=-1, arg1=-1):
                return interpret(f, [i, arg0, arg1])
            return staticmethod(inner)

        funcs0 = []
        funcs1 = []
        funcs2 = []
        for func in cls.runner.functions:
            args = func.__code__.co_argcount
            if args == 0:
                i = len(funcs0)
                funcs0.append(func)
            elif args == 1:
                i = len(funcs1)
                funcs1.append(func)
            elif args == 2:
                i = len(funcs2)
                funcs2.append(func)
            else:
                raise NotImplementedError(args)
            setattr(cls, func.__name__, make_caller(i))

########NEW FILE########
__FILENAME__ = ast
from __future__ import absolute_import

from rpython.rlib.objectmodel import we_are_translated

from topaz import consts
from topaz.astcompiler import CompilerContext, BlockSymbolTable
from topaz.utils.regexp import RegexpError


class BaseNode(object):
    _attrs_ = []

    def __eq__(self, other):
        if not isinstance(other, BaseNode):
            return NotImplemented
        return type(self) is type(other) and self.__dict__ == other.__dict__

    def compile(self, ctx):
        if we_are_translated():
            raise NotImplementedError
        else:
            raise NotImplementedError(type(self).__name__)


class Node(BaseNode):
    _attrs_ = ["lineno"]

    def __init__(self, lineno):
        self.lineno = lineno


class Main(Node):
    def __init__(self, block):
        self.block = block

    def compile(self, ctx):
        self.block.compile(ctx)
        ctx.emit(consts.RETURN)


class Block(Node):
    def __init__(self, stmts):
        # The last item shouldn't be popped.
        node = stmts[-1]
        assert isinstance(node, BaseStatement)
        node.dont_pop = True

        self.stmts = stmts

    def compile(self, ctx):
        for idx, stmt in enumerate(self.stmts):
            stmt.compile(ctx)

    def compile_defined(self, ctx):
        self.stmts[-1].compile_defined(ctx)


class BaseStatement(Node):
    dont_pop = False


class Statement(BaseStatement):
    def __init__(self, expr):
        self.expr = expr

    def compile(self, ctx):
        self.expr.compile(ctx)
        if not self.dont_pop:
            with ctx.set_lineno(ctx.last_lineno):
                ctx.emit(consts.DISCARD_TOP)

    def compile_defined(self, ctx):
        self.expr.compile_defined(ctx)


class If(Node):
    def __init__(self, cond, body, elsebody):
        self.cond = cond
        self.body = body
        self.elsebody = elsebody

    def compile(self, ctx):
        end = ctx.new_block()
        otherwise = ctx.new_block()
        self.cond.compile(ctx)
        ctx.emit_jump(consts.JUMP_IF_FALSE, otherwise)
        self.body.compile(ctx)
        ctx.emit_jump(consts.JUMP, end)
        ctx.use_next_block(otherwise)
        self.elsebody.compile(ctx)
        ctx.use_next_block(end)


class BaseLoop(Node):
    def __init__(self, cond, body):
        self.cond = cond
        self.body = body

    def compile(self, ctx):
        anchor = ctx.new_block()
        end = ctx.new_block()
        loop = ctx.new_block()

        ctx.emit_jump(consts.SETUP_LOOP, end)
        with ctx.enter_frame_block(ctx.F_BLOCK_LOOP, loop):
            ctx.use_next_block(loop)
            self.cond.compile(ctx)
            ctx.emit_jump(self.cond_instr, anchor)

            self.body.compile(ctx)
            ctx.emit(consts.DISCARD_TOP)
            ctx.emit_jump(consts.JUMP, loop)

            ctx.use_next_block(anchor)
            ctx.emit(consts.POP_BLOCK)
        ctx.emit(consts.LOAD_CONST, ctx.create_const(ctx.space.w_nil))
        ctx.use_next_block(end)


class While(BaseLoop):
    cond_instr = consts.JUMP_IF_FALSE


class Until(BaseLoop):
    cond_instr = consts.JUMP_IF_TRUE


class Next(BaseStatement):
    def __init__(self, expr):
        self.expr = expr

    def compile(self, ctx):
        self.expr.compile(ctx)
        if ctx.in_frame_block(ctx.F_BLOCK_LOOP):
            block = ctx.find_frame_block(ctx.F_BLOCK_LOOP)
            ctx.emit_jump(consts.CONTINUE_LOOP, block)
        elif isinstance(ctx.symtable, BlockSymbolTable):
            ctx.emit(consts.RETURN)
        else:
            raise SystemError


class Break(BaseStatement):
    def __init__(self, expr):
        self.expr = expr

    def compile(self, ctx):
        self.expr.compile(ctx)
        if ctx.in_frame_block(ctx.F_BLOCK_LOOP):
            ctx.emit(consts.BREAK_LOOP)
        elif isinstance(ctx.symtable, BlockSymbolTable):
            ctx.emit(consts.RAISE_BREAK)
        else:
            raise SystemError


class TryExcept(Node):
    def __init__(self, body, except_handlers, else_body):
        self.body = body
        self.except_handlers = except_handlers
        self.else_body = else_body

    def compile(self, ctx):
        exc = ctx.new_block()
        else_block = ctx.new_block()
        end = ctx.new_block()
        if self.except_handlers:
            ctx.emit_jump(consts.SETUP_EXCEPT, exc)
        ctx.use_next_block(ctx.new_block())
        self.body.compile(ctx)
        if self.except_handlers:
            ctx.emit(consts.POP_BLOCK)
        ctx.emit_jump(consts.JUMP, else_block)
        ctx.use_next_block(exc)

        for handler in self.except_handlers:
            assert isinstance(handler, ExceptHandler)
            next_except = ctx.new_block()
            handle_block = ctx.new_block()

            if handler.exceptions:
                for exception in handler.exceptions:
                    next_handle = ctx.new_block()
                    ctx.emit(consts.DUP_TOP)
                    exception.compile(ctx)
                    ctx.emit(consts.ROT_TWO)
                    ctx.emit(consts.SEND, ctx.create_symbol_const("==="), 1)
                    ctx.emit_jump(consts.JUMP_IF_TRUE, handle_block)
                    ctx.use_next_block(next_handle)
                ctx.emit_jump(consts.JUMP, next_except)
            ctx.use_next_block(handle_block)
            if handler.target:
                elems = handler.target.compile_receiver(ctx)
                if elems == 1:
                    ctx.emit(consts.ROT_TWO)
                elif elems == 2:
                    ctx.emit(consts.ROT_THREE)
                    ctx.emit(consts.ROT_THREE)
                handler.target.compile_store(ctx)
            ctx.emit(consts.DISCARD_TOP)
            ctx.emit(consts.DISCARD_TOP)
            handler.body.compile(ctx)
            ctx.emit_jump(consts.JUMP, end)
            ctx.use_next_block(next_except)

        if self.except_handlers:
            ctx.emit(consts.END_FINALLY)
        ctx.use_next_block(else_block)
        self.else_body.compile(ctx)
        ctx.emit(consts.DISCARD_TOP)
        ctx.use_next_block(end)


class ExceptHandler(Node):
    def __init__(self, exceptions, target, body):
        self.exceptions = exceptions
        self.target = target
        self.body = body


class TryFinally(Node):
    def __init__(self, body, finally_body):
        self.body = body
        self.finally_body = finally_body

    def compile(self, ctx):
        end = ctx.new_block()
        ctx.emit_jump(consts.SETUP_FINALLY, end)
        body = ctx.new_block()
        ctx.use_next_block(body)
        with ctx.enter_frame_block(ctx.F_BLOCK_FINALLY, body):
            self.body.compile(ctx)
            ctx.emit(consts.POP_BLOCK)
        # Put a None on the stack where an exception would be.
        ctx.emit(consts.LOAD_CONST, ctx.create_const(ctx.space.w_nil))
        ctx.use_next_block(end)
        with ctx.enter_frame_block(ctx.F_BLOCK_FINALLY_END, end):
            self.finally_body.compile(ctx)
            ctx.emit(consts.DISCARD_TOP)
            ctx.emit(consts.END_FINALLY)


class BaseModule(Node):
    def __init__(self, scope, name, body):
        self.scope = scope
        self.name = name
        self.body = body

    def compile_body(self, ctx, ctxname):
        body_ctx = ctx.get_subctx(ctxname, self)
        self.body.compile(body_ctx)
        body_ctx.emit(consts.RETURN)
        bytecode = body_ctx.create_bytecode([], [], None, None)

        ctx.emit(consts.LOAD_CONST, ctx.create_const(bytecode))
        ctx.emit(consts.EVALUATE_MODULE)


class Class(BaseModule):
    def __init__(self, scope, name, superclass, body):
        BaseModule.__init__(self, scope, name, body)
        self.superclass = superclass

    def compile(self, ctx):
        if self.scope is not None:
            self.scope.compile(ctx)
        else:
            ctx.emit(consts.LOAD_CONST, ctx.create_const(ctx.space.w_object))
        ctx.emit(consts.LOAD_CONST, ctx.create_symbol_const(self.name))
        if self.superclass is None:
            ctx.emit(consts.LOAD_CONST, ctx.create_const(ctx.space.w_nil))
        else:
            self.superclass.compile(ctx)
        ctx.emit(consts.BUILD_CLASS)
        self.compile_body(ctx, "<class:%s>" % self.name)


class SingletonClass(BaseModule):
    def __init__(self, value, body, lineno):
        Node.__init__(self, lineno)
        self.value = value
        self.body = body

    def compile(self, ctx):
        with ctx.set_lineno(self.lineno):
            self.value.compile(ctx)
            ctx.emit(consts.LOAD_SINGLETON_CLASS)
            self.compile_body(ctx, "singletonclass")


class Module(BaseModule):
    def compile(self, ctx):
        if self.scope is not None:
            self.scope.compile(ctx)
        else:
            ctx.emit(consts.LOAD_CONST, ctx.create_const(ctx.space.w_object))
        ctx.emit(consts.LOAD_CONST, ctx.create_symbol_const(self.name))
        ctx.emit(consts.BUILD_MODULE)
        self.compile_body(ctx, "<module:%s>" % self.name)


class Function(Node):
    def __init__(self, parent, name, args, splat_arg, block_arg, body):
        self.parent = parent
        self.name = name
        self.args = args
        self.splat_arg = splat_arg
        self.block_arg = block_arg
        self.body = body

    def compile(self, ctx):
        function_ctx = ctx.get_subctx(self.name, self)
        defaults = []
        arg_names = []
        for arg in self.args:
            assert isinstance(arg, Argument)
            arg_names.append(arg.name)
            function_ctx.symtable.get_cell_num(arg.name)

            arg_ctx = CompilerContext(ctx.space, self.name, function_ctx.symtable, ctx.filepath)
            if arg.defl is not None:
                arg.defl.compile(arg_ctx)
                arg_ctx.emit(consts.RETURN)
                bc = arg_ctx.create_bytecode([], [], None, None)
                defaults.append(bc)
        if self.splat_arg is not None:
            function_ctx.symtable.get_cell_num(self.splat_arg)
        if self.block_arg is not None:
            function_ctx.symtable.get_cell_num(self.block_arg)

        self.body.compile(function_ctx)
        function_ctx.emit(consts.RETURN)
        bytecode = function_ctx.create_bytecode(
            arg_names, defaults, self.splat_arg, self.block_arg
        )

        if self.parent is None:
            ctx.emit(consts.LOAD_SCOPE)
        else:
            self.parent.compile(ctx)
        ctx.emit(consts.LOAD_CONST, ctx.create_symbol_const(self.name))
        ctx.emit(consts.LOAD_CONST, ctx.create_symbol_const(self.name))
        ctx.emit(consts.LOAD_CONST, ctx.create_const(bytecode))
        ctx.emit(consts.BUILD_FUNCTION)
        if self.parent is None:
            ctx.emit(consts.DEFINE_FUNCTION)
        else:
            ctx.emit(consts.ATTACH_FUNCTION)


class Argument(Node):
    def __init__(self, name, defl=None):
        self.name = name
        self.defl = defl


class Lambda(Node):
    def __init__(self, block):
        self.block = block

    def compile(self, ctx):
        self.block.compile(ctx)
        ctx.emit(consts.BUILD_LAMBDA)


class Case(Node):
    def __init__(self, cond, whens, elsebody):
        self.cond = cond
        self.whens = whens
        self.elsebody = elsebody

    def compile(self, ctx):
        end = ctx.new_block()

        self.cond.compile(ctx)
        for when in self.whens:
            assert isinstance(when, When)
            with ctx.set_lineno(when.lineno):
                next_when = ctx.new_block()
                when_block = ctx.new_block()

                for expr in when.conds:
                    next_expr = ctx.new_block()
                    ctx.emit(consts.DUP_TOP)
                    expr.compile(ctx)
                    ctx.emit(consts.ROT_TWO)
                    ctx.emit(consts.SEND, ctx.create_symbol_const("==="), 1)
                    ctx.emit_jump(consts.JUMP_IF_TRUE, when_block)
                    ctx.use_next_block(next_expr)
                ctx.emit_jump(consts.JUMP, next_when)
                ctx.use_next_block(when_block)
                ctx.emit(consts.DISCARD_TOP)
                when.block.compile(ctx)
                ctx.emit_jump(consts.JUMP, end)
                ctx.use_next_block(next_when)
        ctx.emit(consts.DISCARD_TOP)
        self.elsebody.compile(ctx)
        ctx.use_next_block(end)


class When(Node):
    def __init__(self, conds, block, lineno):
        Node.__init__(self, lineno)
        self.conds = conds
        self.block = block


class Return(BaseStatement):
    def __init__(self, expr):
        self.expr = expr

    def compile(self, ctx):
        self.expr.compile(ctx)
        if isinstance(ctx.symtable, BlockSymbolTable):
            ctx.emit(consts.RAISE_RETURN)
        else:
            ctx.emit(consts.RETURN)


class Yield(Node):
    def __init__(self, args, lineno):
        Node.__init__(self, lineno)
        self.args = args

    def compile(self, ctx):
        with ctx.set_lineno(self.lineno):
            if self.is_splat():
                for arg in self.args:
                    arg.compile(ctx)
                    if not isinstance(arg, Splat):
                        ctx.emit(consts.BUILD_ARRAY, 1)
                ctx.emit(consts.YIELD_SPLAT, len(self.args))
            else:
                for arg in self.args:
                    arg.compile(ctx)
                ctx.emit(consts.YIELD, len(self.args))

    def is_splat(self):
        for arg in self.args:
            if isinstance(arg, Splat):
                return True
        return False

    def compile_defined(self, ctx):
        ctx.emit(consts.DEFINED_YIELD)


class Alias(BaseStatement):
    def __init__(self, new_name, old_name, lineno):
        BaseStatement.__init__(self, lineno)
        self.new_name = new_name
        self.old_name = old_name

    def compile(self, ctx):
        Send(
            Scope(self.lineno),
            "alias_method",
            [self.new_name, self.old_name],
            None,
            self.lineno,
        ).compile(ctx)
        if not self.dont_pop:
            ctx.emit(consts.DISCARD_TOP)


class Undef(BaseStatement):
    def __init__(self, undef_list, lineno):
        BaseStatement.__init__(self, lineno)
        self.undef_list = undef_list

    def compile(self, ctx):
        first = True
        for undef in self.undef_list:
            if not first:
                ctx.emit(consts.DISCARD_TOP)
            Send(
                Scope(self.lineno),
                "undef_method",
                [undef],
                None,
                self.lineno
            ).compile(ctx)
        if not self.dont_pop:
            ctx.emit(consts.DISCARD_TOP)


class Defined(Node):
    def __init__(self, node, lineno):
        Node.__init__(self, lineno)
        self.node = node

    def compile(self, ctx):
        self.node.compile_defined(ctx)


class Assignment(Node):
    def __init__(self, target, value):
        self.target = target
        self.value = value

    def compile(self, ctx):
        self.target.compile_receiver(ctx)
        self.value.compile(ctx)
        self.target.compile_store(ctx)

    def compile_defined(self, ctx):
        ConstantString("assignment").compile(ctx)


class AugmentedAssignment(Node):
    def __init__(self, oper, target, value):
        self.oper = oper
        self.target = target
        self.value = value

    def compile(self, ctx):
        dup_needed = self.target.compile_receiver(ctx)
        if dup_needed == 1:
            ctx.emit(consts.DUP_TOP)
        elif dup_needed == 2:
            ctx.emit(consts.DUP_TWO)
        self.target.compile_load(ctx)
        self.value.compile(ctx)
        ctx.emit(consts.SEND, ctx.create_symbol_const(self.oper), 1)
        self.target.compile_store(ctx)

    def compile_defined(self, ctx):
        ConstantString("assignment").compile(ctx)


class OrEqual(Node):
    def __init__(self, target, value):
        self.target = target
        self.value = value

    def compile(self, ctx):
        otherwise = ctx.new_block()
        end = ctx.new_block()

        dup_needed = self.target.compile_receiver(ctx)
        if dup_needed == 1:
            ctx.emit(consts.DUP_TOP)
        elif dup_needed == 2:
            ctx.emit(consts.DUP_TWO)
        self.target.compile_load(ctx)
        ctx.emit(consts.DUP_TOP)
        ctx.emit_jump(consts.JUMP_IF_TRUE, end)
        ctx.use_next_block(otherwise)
        ctx.emit(consts.DISCARD_TOP)
        self.value.compile(ctx)
        ctx.use_next_block(end)
        self.target.compile_store(ctx)

    def compile_defined(self, ctx):
        ConstantString("assignment").compile(ctx)


class AndEqual(Node):
    def __init__(self, target, value):
        self.target = target
        self.value = value

    def compile(self, ctx):
        otherwise = ctx.new_block()
        end = ctx.new_block()

        dup_needed = self.target.compile_receiver(ctx)
        if dup_needed == 1:
            ctx.emit(consts.DUP_TOP)
        elif dup_needed == 2:
            ctx.emit(consts.DUP_TWO)
        self.target.compile_load(ctx)
        ctx.emit(consts.DUP_TOP)
        ctx.emit_jump(consts.JUMP_IF_FALSE, end)
        ctx.use_next_block(otherwise)
        ctx.emit(consts.DISCARD_TOP)
        self.value.compile(ctx)
        ctx.use_next_block(end)
        self.target.compile_store(ctx)

    def compile_defined(self, ctx):
        ConstantString("assignment").compile(ctx)


class MultiAssignable(Node):
    def __init__(self, targets):
        self.targets = targets

    def splat_index(self):
        for i, node in enumerate(self.targets):
            if isinstance(node, Splat):
                return i
        return -1

    def compile_receiver(self, ctx):
        return 0

    def compile_store(self, ctx):
        ctx.emit(consts.DUP_TOP)
        ctx.emit(consts.COERCE_ARRAY, 0)
        splat_index = self.splat_index()
        if splat_index == -1:
            ctx.emit(consts.UNPACK_SEQUENCE, len(self.targets))
        else:
            ctx.emit(consts.UNPACK_SEQUENCE_SPLAT, len(self.targets), splat_index)
        for target in self.targets:
            elems = target.compile_receiver(ctx)
            if elems == 1:
                ctx.emit(consts.ROT_TWO)
            elif elems == 2:
                ctx.emit(consts.ROT_THREE)
                ctx.emit(consts.ROT_THREE)
            target.compile_store(ctx)
            ctx.emit(consts.DISCARD_TOP)


class MultiAssignment(Node):
    def __init__(self, assignable, value):
        self.assignable = assignable
        self.value = value

    def compile(self, ctx):
        self.value.compile(ctx)
        self.assignable.compile_store(ctx)

    def compile_defined(self, ctx):
        ConstantString("assignment").compile(ctx)


class Or(Node):
    def __init__(self, lhs, rhs):
        self.lhs = lhs
        self.rhs = rhs

    def compile(self, ctx):
        end = ctx.new_block()
        otherwise = ctx.new_block()

        self.lhs.compile(ctx)
        ctx.emit(consts.DUP_TOP)
        ctx.emit_jump(consts.JUMP_IF_TRUE, end)
        ctx.use_next_block(otherwise)
        ctx.emit(consts.DISCARD_TOP)
        self.rhs.compile(ctx)
        ctx.use_next_block(end)

    def compile_defined(self, ctx):
        ConstantString("expression").compile(ctx)


class And(Node):
    def __init__(self, lhs, rhs):
        self.lhs = lhs
        self.rhs = rhs

    def compile(self, ctx):
        end = ctx.new_block()
        otherwise = ctx.new_block()

        self.lhs.compile(ctx)
        ctx.emit(consts.DUP_TOP)
        ctx.emit_jump(consts.JUMP_IF_FALSE, end)
        ctx.use_next_block(otherwise)
        ctx.emit(consts.DISCARD_TOP)
        self.rhs.compile(ctx)
        ctx.use_next_block(end)

    def compile_defined(self, ctx):
        ConstantString("expression").compile(ctx)


class BaseSend(Node):
    def __init__(self, receiver, args, block_arg, lineno):
        Node.__init__(self, lineno)
        self.receiver = receiver
        self.args = args
        self.block_arg = block_arg

    def compile(self, ctx):
        with ctx.set_lineno(self.lineno):
            self.receiver.compile(ctx)
            if self.is_splat():
                for arg in self.args:
                    arg.compile(ctx)
                    if not isinstance(arg, Splat):
                        ctx.emit(consts.BUILD_ARRAY, 1)
            else:
                for arg in self.args:
                    arg.compile(ctx)
            block = self.get_block()
            if block is not None:
                block.compile(ctx)

            symbol = self.method_name_const(ctx)
            if self.is_splat() and block is not None:
                ctx.emit(self.send_block_splat, symbol, len(self.args) + 1)
            elif self.is_splat():
                ctx.emit(self.send_splat, symbol, len(self.args))
            elif block is not None:
                ctx.emit(self.send_block, symbol, len(self.args) + 1)
            else:
                ctx.emit(self.send, symbol, len(self.args))

    def is_splat(self):
        for arg in self.args:
            if isinstance(arg, Splat):
                return True
        return False

    def get_block(self):
        return self.block_arg

    def compile_receiver(self, ctx):
        self.receiver.compile(ctx)
        return 1

    def compile_load(self, ctx):
        ctx.emit(consts.SEND, ctx.create_symbol_const(self.method), 0)

    def compile_store(self, ctx):
        ctx.emit(consts.SEND, ctx.create_symbol_const(self.method + "="), 1)

    def compile_defined(self, ctx):
        self.compile_receiver(ctx)
        ctx.emit(self.defined, self.method_name_const(ctx))


class Send(BaseSend):
    send = consts.SEND
    send_block = consts.SEND_BLOCK
    send_splat = consts.SEND_SPLAT
    send_block_splat = consts.SEND_BLOCK_SPLAT
    defined = consts.DEFINED_METHOD

    def __init__(self, receiver, method, args, block_arg, lineno):
        BaseSend.__init__(self, receiver, args, block_arg, lineno)
        self.method = method

    def method_name_const(self, ctx):
        return ctx.create_symbol_const(self.method)


class Super(BaseSend):
    send_block = consts.SEND_SUPER_BLOCK
    send_block_splat = consts.SEND_SUPER_BLOCK_SPLAT
    defined = consts.DEFINED_SUPER

    def __init__(self, args, block_arg, lineno):
        BaseSend.__init__(self, Self(lineno), args, block_arg, lineno)

    def get_block(self):
        return BaseSend.get_block(self) or LoadBlock()

    def method_name_const(self, ctx):
        if ctx.code_name == "<main>":
            return ctx.create_const(ctx.space.w_nil)
        else:
            return ctx.create_symbol_const(ctx.code_name)


class Splat(Node):
    def __init__(self, value):
        self.value = value

    def compile_receiver(self, ctx):
        if self.value is None:
            return 0
        else:
            return self.value.compile_receiver(ctx)

    def compile_store(self, ctx):
        if self.value is not None:
            return self.value.compile_store(ctx)

    def compile(self, ctx):
        self.value.compile(ctx)
        ctx.emit(consts.COERCE_ARRAY, 1)


class SendBlock(Node):
    def __init__(self, block_args, splat_arg, block_arg, block):
        self.block_args = block_args
        self.splat_arg = splat_arg
        self.block_arg = block_arg
        self.block = block

    def compile(self, ctx):
        blockname = "block in %s" % ctx.code_name
        block_ctx = ctx.get_subctx(blockname, self)
        for cellname, kind in block_ctx.symtable.cells.iteritems():
            if kind == block_ctx.symtable.CELLVAR:
                block_ctx.symtable.get_cell_num(cellname)
        block_args = []
        defaults = []
        for arg in self.block_args:
            assert isinstance(arg, Argument)
            block_args.append(arg.name)
            block_ctx.symtable.get_cell_num(arg.name)
            if arg.defl is not None:
                arg_ctx = CompilerContext(ctx.space, blockname, block_ctx.symtable, ctx.filepath)
                arg.defl.compile(arg_ctx)
                arg_ctx.emit(consts.RETURN)
                bc = arg_ctx.create_bytecode([], [], None, None)
                defaults.append(bc)
        if self.splat_arg is not None:
            block_ctx.symtable.get_cell_num(self.splat_arg)
        if self.block_arg is not None:
            block_ctx.symtable.get_cell_num(self.block_arg)

        for name in ctx.symtable.cells:
            if (name not in block_ctx.symtable.cell_numbers and
                name not in block_ctx.symtable.cells):

                block_ctx.symtable.cells[name] = block_ctx.symtable.FREEVAR

        self.block.compile(block_ctx)
        block_ctx.emit(consts.RETURN)
        bc = block_ctx.create_bytecode(block_args, defaults, self.splat_arg, self.block_arg)
        ctx.emit(consts.LOAD_CONST, ctx.create_const(bc))

        cells = [None] * len(block_ctx.symtable.cell_numbers)
        for name, pos in block_ctx.symtable.cell_numbers.iteritems():
            cells[pos] = name
        num_cells = 0
        for name in reversed(cells):
            if block_ctx.symtable.cells[name] == block_ctx.symtable.FREEVAR:
                ctx.emit(consts.LOAD_CLOSURE, ctx.symtable.get_cell_num(name))
                num_cells += 1

        ctx.emit(consts.BUILD_BLOCK, num_cells)


class BlockArgument(Node):
    def __init__(self, value):
        self.value = value

    def compile(self, ctx):
        self.value.compile(ctx)
        ctx.emit(consts.COERCE_BLOCK)


class LoadBlock(BaseNode):
    def compile(self, ctx):
        ctx.emit(consts.LOAD_BLOCK)


class Subscript(Node):
    def __init__(self, target, args, lineno):
        Node.__init__(self, lineno)
        self.target = target
        self.args = args

    def compile(self, ctx):
        Send(self.target, "[]", self.args, None, self.lineno).compile(ctx)

    def compile_receiver(self, ctx):
        self.target.compile(ctx)
        if self.is_splat():
            for arg in self.args:
                arg.compile(ctx)
                if not isinstance(arg, Splat):
                    ctx.emit(consts.BUILD_ARRAY, 1)
            if len(self.args) != 1:
                ctx.emit(consts.BUILD_ARRAY_SPLAT, len(self.args))
        else:
            for arg in self.args:
                arg.compile(ctx)
            ctx.emit(consts.BUILD_ARRAY, len(self.args))
        return 2

    def compile_load(self, ctx):
        ctx.emit(consts.SEND_SPLAT, ctx.create_symbol_const("[]"), 1)

    def compile_store(self, ctx):
        ctx.emit(consts.BUILD_ARRAY, 1)
        ctx.emit(consts.SEND_SPLAT, ctx.create_symbol_const("[]="), 2)

    def is_splat(self):
        for arg in self.args:
            if isinstance(arg, Splat):
                return True
        return False


class Constant(Node):
    def __init__(self, name, lineno):
        Node.__init__(self, lineno)
        self.name = name

    def compile(self, ctx):
        with ctx.set_lineno(self.lineno):
            self.compile_receiver(ctx)
            self.compile_load(ctx)

    def compile_load(self, ctx):
        ctx.emit(consts.LOAD_LOCAL_CONSTANT, ctx.create_symbol_const(self.name))

    def compile_receiver(self, ctx):
        Scope(self.lineno).compile(ctx)
        return 1

    def compile_store(self, ctx):
        ctx.emit(consts.STORE_CONSTANT, ctx.create_symbol_const(self.name))

    def compile_defined(self, ctx):
        self.compile_receiver(ctx)
        ctx.emit(consts.DEFINED_LOCAL_CONSTANT, ctx.create_symbol_const(self.name))


class LookupConstant(Node):
    def __init__(self, scope, name, lineno):
        Node.__init__(self, lineno)
        self.scope = scope
        self.name = name

    def compile(self, ctx):
        with ctx.set_lineno(self.lineno):
            self.compile_receiver(ctx)
            self.compile_load(ctx)

    def compile_receiver(self, ctx):
        if self.scope is not None:
            self.scope.compile(ctx)
        else:
            ctx.emit(consts.LOAD_CONST, ctx.create_const(ctx.space.w_object))
        return 1

    def compile_load(self, ctx):
        ctx.emit(consts.LOAD_CONSTANT, ctx.create_symbol_const(self.name))

    def compile_store(self, ctx):
        ctx.emit(consts.STORE_CONSTANT, ctx.create_symbol_const(self.name))

    def compile_defined(self, ctx):
        self.compile_receiver(ctx)
        ctx.emit(consts.DEFINED_CONSTANT, ctx.create_symbol_const(self.name))


class Self(Node):
    def compile(self, ctx):
        ctx.emit(consts.LOAD_SELF)

    def compile_defined(self, ctx):
        ConstantString("self").compile(ctx)


class Scope(Node):
    def compile(self, ctx):
        ctx.emit(consts.LOAD_SCOPE)


class Variable(Node):
    def __init__(self, name, lineno):
        Node.__init__(self, lineno)
        self.name = name

    def compile(self, ctx):
        ctx.emit(consts.LOAD_DEREF, ctx.symtable.get_cell_num(self.name))

    def compile_receiver(self, ctx):
        return 0

    def compile_load(self, ctx):
        self.compile(ctx)

    def compile_store(self, ctx):
        ctx.emit(consts.STORE_DEREF, ctx.symtable.get_cell_num(self.name))

    def compile_defined(self, ctx):
        ConstantString("local-variable").compile(ctx)


class Global(Node):
    def __init__(self, name):
        self.name = name

    def compile(self, ctx):
        ctx.emit(consts.LOAD_GLOBAL, ctx.create_symbol_const(self.name))

    def compile_receiver(self, ctx):
        return 0

    def compile_load(self, ctx):
        self.compile(ctx)

    def compile_store(self, ctx):
        ctx.emit(consts.STORE_GLOBAL, ctx.create_symbol_const(self.name))

    def compile_defined(self, ctx):
        ctx.emit(consts.DEFINED_GLOBAL, ctx.create_symbol_const(self.name))


class InstanceVariable(Node):
    def __init__(self, name):
        self.name = name

    def compile(self, ctx):
        self.compile_receiver(ctx)
        self.compile_load(ctx)

    def compile_receiver(self, ctx):
        ctx.emit(consts.LOAD_SELF)
        return 1

    def compile_load(self, ctx):
        ctx.emit(consts.LOAD_INSTANCE_VAR, ctx.create_symbol_const(self.name))

    def compile_store(self, ctx):
        ctx.emit(consts.STORE_INSTANCE_VAR, ctx.create_symbol_const(self.name))

    def compile_defined(self, ctx):
        self.compile_receiver(ctx)
        ctx.emit(consts.DEFINED_INSTANCE_VAR, ctx.create_symbol_const(self.name))


class ClassVariable(Node):
    def __init__(self, name, lineno):
        Node.__init__(self, lineno)
        self.name = name

    def compile(self, ctx):
        with ctx.set_lineno(self.lineno):
            self.compile_receiver(ctx)
            self.compile_load(ctx)

    def compile_receiver(self, ctx):
        ctx.emit(consts.LOAD_SCOPE)
        return 1

    def compile_load(self, ctx):
        ctx.emit(consts.LOAD_CLASS_VAR, ctx.create_symbol_const(self.name))

    def compile_store(self, ctx):
        ctx.emit(consts.STORE_CLASS_VAR, ctx.create_symbol_const(self.name))

    def compile_defined(self, ctx):
        self.compile_receiver(ctx)
        ctx.emit(consts.DEFINED_CLASS_VAR, ctx.create_symbol_const(self.name))


class Array(Node):
    def __init__(self, items):
        self.items = items

    def compile(self, ctx):
        n_items = 0
        n_components = 0
        for item in self.items:
            if isinstance(item, Splat):
                ctx.emit(consts.BUILD_ARRAY, n_items)
                item.compile(ctx)
                n_items = 0
                n_components += 2
            else:
                item.compile(ctx)
                n_items += 1
        if n_items or not n_components:
            ctx.emit(consts.BUILD_ARRAY, n_items)
            n_components += 1
        if n_components != 1:
            ctx.emit(consts.BUILD_ARRAY_SPLAT, n_components)

    def compile_defined(self, ctx):
        ConstantString("expression").compile(ctx)


class Hash(Node):
    def __init__(self, items):
        self.items = items

    def compile(self, ctx):
        ctx.emit(consts.BUILD_HASH)
        for k, v in self.items:
            ctx.emit(consts.DUP_TOP)
            k.compile(ctx)
            v.compile(ctx)
            ctx.emit(consts.SEND, ctx.create_symbol_const("[]="), 2)
            ctx.emit(consts.DISCARD_TOP)

    def compile_defined(self, ctx):
        ConstantString("expression").compile(ctx)


class Range(Node):
    def __init__(self, start, stop, exclusive):
        self.start = start
        self.stop = stop
        self.exclusive = exclusive

    def compile(self, ctx):
        self.start.compile(ctx)
        self.stop.compile(ctx)
        if self.exclusive:
            ctx.emit(consts.BUILD_RANGE_EXCLUSIVE)
        else:
            ctx.emit(consts.BUILD_RANGE)

    def compile_defined(self, ctx):
        ConstantString("expression").compile(ctx)


class ConstantNode(Node):
    def compile(self, ctx):
        ctx.emit(consts.LOAD_CONST, self.create_const(ctx))

    def compile_defined(self, ctx):
        ConstantString("expression").compile(ctx)


class ConstantInt(ConstantNode):
    def __init__(self, intvalue):
        self.intvalue = intvalue

    def negate(self):
        return ConstantInt(-self.intvalue)

    def create_const(self, ctx):
        return ctx.create_int_const(self.intvalue)


class ConstantBigInt(ConstantNode):
    def __init__(self, bigint):
        self.bigint = bigint

    def negate(self):
        return ConstantBigInt(self.bigint.neg())

    def create_const(self, ctx):
        return ctx.create_const(ctx.space.newbigint_fromrbigint(self.bigint))


class ConstantFloat(ConstantNode):
    def __init__(self, floatvalue):
        self.floatvalue = floatvalue

    def create_const(self, ctx):
        return ctx.create_float_const(self.floatvalue)


class ConstantSymbol(ConstantNode):
    def __init__(self, symbol):
        self.symbol = symbol

    def create_const(self, ctx):
        return ctx.create_symbol_const(self.symbol)


class ConstantString(ConstantNode):
    def __init__(self, strvalue):
        self.strvalue = strvalue

    def create_const(self, ctx):
        return ctx.create_symbol_const(self.strvalue)

    def compile(self, ctx):
        ConstantNode.compile(self, ctx)
        ctx.emit(consts.COERCE_STRING)


class ConstantRegexp(ConstantNode):
    def __init__(self, regexp, flags, lineno):
        ConstantNode.__init__(self, lineno)
        self.regexp = regexp
        self.flags = flags

    def create_const(self, ctx):
        try:
            w_regexp = ctx.space.newregexp(self.regexp, self.flags)
        except RegexpError as e:
            raise ctx.space.error(ctx.space.w_SyntaxError, "line %d: %s" % (self.lineno, e))
        return ctx.create_const(w_regexp)


class ConstantBool(ConstantNode):
    def __init__(self, boolval):
        self.boolval = boolval

    def create_const(self, ctx):
        return ctx.create_const(ctx.space.newbool(self.boolval))

    def compile_defined(self, ctx):
        ConstantString("true" if self.boolval else "false").compile(ctx)


class DynamicString(Node):
    def __init__(self, strvalues):
        self.strvalues = strvalues

    def compile(self, ctx):
        for strvalue in self.strvalues:
            strvalue.compile(ctx)
            if not isinstance(strvalue, ConstantString):
                ctx.emit(consts.SEND, ctx.create_symbol_const("to_s"), 0)
        if len(self.strvalues) != 1:
            ctx.emit(consts.BUILD_STRING, len(self.strvalues))

    def compile_defined(self, ctx):
        ConstantString("expression").compile(ctx)


class DynamicRegexp(Node):
    def __init__(self, dstring, flags):
        self.dstring = dstring
        self.flags = flags

    def compile(self, ctx):
        self.dstring.compile(ctx)
        ctx.emit(consts.LOAD_CONST, ctx.create_int_const(self.flags))
        ctx.emit(consts.BUILD_REGEXP)

    def compile_defined(self, ctx):
        ConstantString("expression").compile(ctx)


class Symbol(Node):
    def __init__(self, value, lineno):
        Node.__init__(self, lineno)
        self.value = value

    def compile(self, ctx):
        Send(self.value, "to_sym", [], None, self.lineno).compile(ctx)


class Nil(BaseNode):
    def compile(self, ctx):
        ctx.emit(consts.LOAD_CONST, ctx.create_const(ctx.space.w_nil))

    def compile_defined(self, ctx):
        ConstantString("nil").compile(ctx)


class File(BaseNode):
    def compile(self, ctx):
        ctx.emit(consts.LOAD_CODE)
        ctx.emit(consts.SEND, ctx.create_symbol_const("filepath"), 0)


class Line(Node):
    def compile(self, ctx):
        ConstantInt(self.lineno).compile(ctx)

########NEW FILE########
__FILENAME__ = astcompiler
from topaz import consts
from topaz.objects.codeobject import W_CodeObject


class BaseSymbolTable(object):
    FREEVAR = 0
    CELLVAR = 1

    NORMAL_ARG = 0
    SPLAT_ARG = 1
    BLOCK_ARG = 2

    def __init__(self, parent_symtable=None):
        self.parent_symtable = parent_symtable
        self.subscopes = {}
        self.cells = {}
        self.arguments = []

        self.cell_numbers = {}

    def add_subscope(self, node, symtable):
        self.subscopes[node] = symtable

    def get_subscope(self, node):
        return self.subscopes[node]

    def declare_argument(self, name, tp=NORMAL_ARG):
        self.arguments.append((name, tp))
        self.declare_local(name)

    def declare_local(self, name):
        self.cells[name] = self.CELLVAR

    def is_defined(self, name):
        return name in self.cells

    def get_cell_num(self, name):
        if name not in self.cell_numbers:
            self.cell_numbers[name] = len(self.cell_numbers)
        return self.cell_numbers[name]


class SymbolTable(BaseSymbolTable):
    def declare_write(self, name):
        if not self.is_defined(name):
            self.declare_local(name)

    def declare_read(self, name):
        pass

    def upgrade_to_closure(self, name):
        pass


class BlockSymbolTable(BaseSymbolTable):
    def declare_read(self, name):
        if name not in self.cells and self.parent_symtable.is_defined(name):
            self.cells[name] = self.FREEVAR
            self.parent_symtable.upgrade_to_closure(name)

    def declare_write(self, name):
        if name not in self.cells:
            if self.parent_symtable.is_defined(name):
                self.cells[name] = self.FREEVAR
                self.parent_symtable.upgrade_to_closure(name)
            else:
                self.declare_local(name)

    def is_defined(self, name):
        return BaseSymbolTable.is_defined(self, name) or self.parent_symtable.is_defined(name)

    def upgrade_to_closure(self, name):
        if name not in self.cells:
            self.parent_symtable.upgrade_to_closure(name)
            self.cells[name] = self.FREEVAR


class SharedScopeSymbolTable(BlockSymbolTable):
    def declare_write(self, name):
        self.parent_symtable.declare_write(name)
        BlockSymbolTable.declare_write(self, name)


class CompilerContext(object):
    F_BLOCK_LOOP = 0
    F_BLOCK_FINALLY = 1
    F_BLOCK_FINALLY_END = 2

    def __init__(self, space, code_name, symtable, filepath):
        self.space = space
        self.code_name = code_name
        self.symtable = symtable
        self.filepath = filepath
        self.consts = []
        self.const_positions = {}
        self.current_lineno = -1
        self.last_lineno = -1

        self.current_block = self.first_block = self.new_block()
        self.frame_blocks = []

    def create_bytecode(self, args, defaults, splat_arg, block_arg):
        cellvars = []
        freevars = []

        # Make sure that any cell vars have a number.
        for name in self.symtable.cells:
            if name not in self.symtable.cell_numbers:
                self.symtable.get_cell_num(name)

        cells = [None] * len(self.symtable.cell_numbers)
        for name, pos in self.symtable.cell_numbers.iteritems():
            cells[pos] = name

        for name in cells:
            kind = self.symtable.cells[name]
            if kind == self.symtable.CELLVAR:
                cellvars.append(name)
            elif kind == self.symtable.FREEVAR:
                freevars.append(name)
            else:
                assert False

        blocks = self.first_block.post_order()
        code, lineno_table = self.get_code_lineno_table(blocks)
        depth = self.count_stackdepth(blocks)
        for default in defaults:
            depth = max(depth, default.max_stackdepth)
        return W_CodeObject(
            self.code_name,
            self.filepath,
            code,
            depth,
            self.consts[:],
            args,
            splat_arg,
            block_arg,
            defaults,
            cellvars,
            freevars,
            lineno_table,
        )

    def get_code_lineno_table(self, blocks):
        offsets = {}
        code_size = 0
        for block in blocks:
            offsets[block] = code_size
            code = []
            linenos = []
            block.get_code(code, linenos)
            code_size += len(code)
        for block in blocks:
            block.patch_locs(offsets)

        code = []
        linenos = []
        for block in blocks:
            block.get_code(code, linenos)
        return "".join(code), linenos

    def count_stackdepth(self, blocks):
        for b in blocks:
            b.marked = False
            b.initial_depth = -1
        return self._count_stackdepth(blocks[0], 0, 0)

    def _count_stackdepth(self, block, depth, max_depth):
        if block.marked or block.initial_depth >= depth:
            return max_depth

        block.marked = True
        block.initial_depth = depth

        for instr in block.instrs:
            depth += self._instr_stack_effect(instr)
            max_depth = max(max_depth, depth)
            if instr.has_jump():
                target_depth = depth
                jump_op = instr.opcode
                if jump_op in [consts.SETUP_FINALLY, consts.SETUP_EXCEPT]:
                    target_depth += 3
                    max_depth = max(max_depth, target_depth)
                max_depth = self._count_stackdepth(instr.jump, target_depth, max_depth)
        if block.next_block is not None:
            max_depth = self._count_stackdepth(block.next_block, depth, max_depth)
        block.marked = False
        return max_depth

    def _instr_stack_effect(self, instr):
        stack_effect = consts.BYTECODE_STACK_EFFECT[instr.opcode]
        if stack_effect == consts.SEND_EFFECT:
            stack_effect = -instr.arg1
        elif stack_effect == consts.ARRAY_EFFECT:
            stack_effect = -instr.arg0 + 1
        elif stack_effect == consts.BLOCK_EFFECT:
            stack_effect = -instr.arg0
        elif stack_effect == consts.UNPACK_EFFECT:
            stack_effect = instr.arg0 - 1
        return stack_effect

    def set_lineno(self, lineno):
        return SetLinenoConextManager(self, lineno)

    def enter_frame_block(self, block_type, block):
        return EnterFrameBlockContextManager(self, block_type, block)

    def in_frame_block(self, block_type):
        for t, _ in self.frame_blocks:
            if t == block_type:
                return True
        return False

    def find_frame_block(self, block_type):
        for frame_block in reversed(self.frame_blocks):
            if frame_block[0] == block_type:
                return frame_block[1]
        raise SystemError

    def new_block(self):
        return Block()

    def use_block(self, block):
        self.current_block = block

    def use_next_block(self, block):
        self.current_block.next_block = block
        self.use_block(block)

    def emit(self, opcode, arg0=-1, arg1=-1):
        num_args = 0
        if arg0 != -1:
            num_args += 1
            if arg1 != -1:
                num_args += 1
        assert num_args == consts.BYTECODE_NUM_ARGS[opcode]
        instr = Instruction(opcode, arg0, arg1, self.current_lineno)
        self.current_block.instrs.append(instr)
        self.last_lineno = self.current_lineno

    def emit_jump(self, opcode, target):
        instr = Instruction(opcode, 0, -1, self.current_lineno)
        instr.jump = target
        self.current_block.instrs.append(instr)

    def get_subctx(self, name, node):
        subscope = self.symtable.get_subscope(node)
        return CompilerContext(self.space, name, subscope, self.filepath)

    def create_const(self, w_obj):
        if w_obj not in self.const_positions:
            self.const_positions[w_obj] = len(self.consts)
            self.consts.append(w_obj)
        return self.const_positions[w_obj]

    def create_int_const(self, intvalue):
        return self.create_const(self.space.newint(intvalue))

    def create_float_const(self, floatvalue):
        return self.create_const(self.space.newfloat(floatvalue))

    def create_symbol_const(self, symbol):
        return self.create_const(self.space.newsymbol(symbol))


class Block(object):
    def __init__(self):
        self.instrs = []
        self.marked = False
        self.next_block = None

    def post_order(self):
        blocks = []
        self._post_order(blocks)
        blocks.reverse()
        return blocks

    def _post_order(self, blocks):
        if self.marked:
            return
        self.marked = True
        if self.next_block is not None:
            self.next_block._post_order(blocks)
        for instr in self.instrs:
            if instr.has_jump():
                instr.jump._post_order(blocks)
        blocks.append(self)

    def patch_locs(self, offsets):
        for instr in self.instrs:
            instr.patch_loc(offsets)

    def get_code(self, code, linenos):
        for instr in self.instrs:
            instr.emit(code, linenos)
        return "".join(code)


class Instruction(object):
    def __init__(self, opcode, arg0, arg1, lineno):
        assert arg0 < 1 << 16
        assert arg1 < 1 << 16
        self.opcode = opcode
        self.arg0 = arg0
        self.arg1 = arg1
        self.lineno = lineno
        self.jump = None

    def emit(self, code, linenos):
        code.append(chr(self.opcode))
        linenos.append(self.lineno)
        if self.arg0 != -1:
            code.append(chr(self.arg0 & 0xFF))
            code.append(chr(self.arg0 >> 8))
            linenos.append(self.lineno)
            linenos.append(self.lineno)
        if self.arg1 != -1:
            code.append(chr(self.arg1 & 0xFF))
            code.append(chr(self.arg1 >> 8))
            linenos.append(self.lineno)
            linenos.append(self.lineno)

    def has_jump(self):
        return self.jump is not None

    def patch_loc(self, offsets):
        if self.has_jump():
            self.arg0 = offsets[self.jump]


class SetLinenoConextManager(object):
    def __init__(self, ctx, lineno):
        self.ctx = ctx
        self.lineno = lineno

    def __enter__(self):
        self.orig_lineno = self.ctx.current_lineno
        self.ctx.current_lineno = self.lineno

    def __exit__(self, exc_type, exc_value, tb):
        self.ctx.current_lineno = self.orig_lineno


class EnterFrameBlockContextManager(object):
    def __init__(self, ctx, block_type, block):
        self.ctx = ctx
        self.block_type = block_type
        self.block = block

    def __enter__(self):
        self.ctx.frame_blocks.append((self.block_type, self.block))

    def __exit__(self, exc_type, exc_value, tb):
        block_type, block = self.ctx.frame_blocks.pop()
        assert block_type == self.block_type
        assert block is self.block

########NEW FILE########
__FILENAME__ = celldict
import copy

from rpython.rlib import jit

from topaz.objects.objectobject import W_Root


class VersionTag(object):
    def __deepcopy__(self, memo):
        memo[id(self)] = result = VersionTag()
        return result


class BaseCell(W_Root):
    pass


class Cell(BaseCell):
    def __init__(self, w_value):
        self.w_value = w_value

    def __deepcopy__(self, memo):
        obj = super(Cell, self).__deepcopy__(memo)
        obj.w_value = copy.deepcopy(self.w_value, memo)
        return obj

    def getvalue(self, space, name):
        return self.w_value

    def setvalue(self, space, name, w_value):
        self.w_value = w_value


class GetterSetterCell(BaseCell):
    _immutable_fields_ = ["getter", "setter"]

    def __init__(self, getter, setter=None):
        self.getter = getter
        self.setter = setter

    def __deepcopy__(self, memo):
        obj = super(GetterSetterCell, self).__deepcopy__(memo)
        obj.getter = copy.deepcopy(self.getter, memo)
        obj.setter = copy.deepcopy(self.setter, memo)
        return obj

    def getvalue(self, space, name):
        return self.getter(space)

    def setvalue(self, space, name, w_value):
        if self.setter is None:
            raise space.error(space.w_NameError,
                "%s is a read-only variable" % name
            )
        self.setter(space, w_value)


class CellDict(object):
    _immutable_fields_ = ["version?"]

    def __init__(self):
        self.values = {}
        self.version = VersionTag()

    def __deepcopy__(self, memo):
        c = object.__new__(self.__class__)
        c.values = copy.deepcopy(self.values, memo)
        c.version = copy.deepcopy(self.version, memo)
        return c

    def __iter__(self):
        return iter(self.values)

    def mutated(self):
        self.version = VersionTag()

    @jit.elidable
    def _get_cell(self, name, version):
        assert version is self.version
        return self.values.get(name, None)

    def get(self, space, name):
        cell = self._get_cell(name, self.version)
        if isinstance(cell, BaseCell):
            return cell.getvalue(space, name)
        else:
            return cell

    def set(self, space, name, w_value):
        cell = self._get_cell(name, self.version)
        if isinstance(cell, BaseCell):
            cell.setvalue(space, name, w_value)
        else:
            if cell is not None:
                w_value = Cell(w_value)
            self.mutated()
            self.values[name] = w_value

    def delete(self, name):
        try:
            del self.values[name]
        except KeyError:
            pass
        else:
            self.mutated()


class GlobalsDict(CellDict):
    def define_virtual(self, name, getter, setter=None):
        self.mutated()
        self.values[name] = GetterSetterCell(getter, setter)

########NEW FILE########
__FILENAME__ = closure
from topaz.objects.objectobject import W_Root
from topaz.objects.intobject import W_FixnumObject


class BaseCell(W_Root):
    pass


class LocalCell(BaseCell):
    def get(self, space, frame, pos):
        return frame.localsstack_w[pos]

    def set(self, space, frame, pos, w_value):
        frame.localsstack_w[pos] = w_value

    def upgrade_to_closure(self, space, frame, pos):
        w_obj = self.get(space, frame, pos)
        if isinstance(w_obj, W_FixnumObject):
            frame.cells[pos] = result = IntCell(space.int_w(w_obj))
        else:
            frame.cells[pos] = result = ClosureCell(w_obj)
        return result


class ClosureCell(BaseCell):
    def __init__(self, w_value):
        self.w_value = w_value

    def get(self, space, frame, pos):
        return self.w_value

    def set(self, space, frame, pos, w_value):
        self.w_value = w_value

    def upgrade_to_closure(self, space, frame, pos):
        return self


class IntCell(ClosureCell):
    def __init__(self, intvalue):
        ClosureCell.__init__(self, None)
        self.intvalue = intvalue

    def get(self, space, frame, pos):
        if self.w_value is None:
            return space.newint(self.intvalue)
        else:
            return ClosureCell.get(self, space, frame, pos)

    def set(self, space, frame, pos, w_value):
        if isinstance(w_value, W_FixnumObject):
            self.intvalue = space.int_w(w_value)
            self.w_value = None
        else:
            ClosureCell.set(self, space, frame, pos, w_value)

########NEW FILE########
__FILENAME__ = coerce
class Coerce(object):
    @staticmethod
    def bool(space, w_obj):
        return space.is_true(w_obj)

    @staticmethod
    def symbol(space, w_obj):
        if space.is_kind_of(w_obj, space.w_symbol):
            return space.symbol_w(w_obj)
        else:
            w_str = space.convert_type(w_obj, space.w_string, "to_str", raise_error=False)
            if w_str is space.w_nil:
                w_inspect_str = space.send(w_obj, "inspect")
                if not space.is_kind_of(w_inspect_str, space.w_string):
                    inspect_str = space.any_to_s(w_obj)
                else:
                    inspect_str = space.str_w(w_inspect_str)
                raise space.error(space.w_TypeError, "%s is not a symbol" % inspect_str)
            else:
                return space.str_w(w_str)

    @staticmethod
    def int(space, w_obj):
        if space.is_kind_of(w_obj, space.w_fixnum):
            return space.int_w(w_obj)
        else:
            return space.int_w(space.convert_type(w_obj, space.w_integer, "to_int"))

    @staticmethod
    def bigint(space, w_obj):
        return space.bigint_w(space.convert_type(w_obj, space.w_integer, "to_int"))

    @staticmethod
    def float(space, w_obj):
        if space.is_kind_of(w_obj, space.w_float):
            return space.float_w(w_obj)
        else:
            return space.float_w(space.send(w_obj, "Float", [w_obj]))

    @staticmethod
    def str(space, w_obj):
        if space.is_kind_of(w_obj, space.w_string) or space.is_kind_of(w_obj, space.w_symbol):
            return space.str_w(w_obj)
        else:
            return space.str_w(space.convert_type(w_obj, space.w_string, "to_str"))

    @staticmethod
    def path(space, w_obj):
        w_string = space.convert_type(w_obj, space.w_string, "to_path", raise_error=False)
        if w_string is space.w_nil:
            w_string = space.convert_type(w_obj, space.w_string, "to_str")
        return space.str0_w(w_string)

    @staticmethod
    def array(space, w_obj):
        if not space.is_kind_of(w_obj, space.w_array):
            w_obj = space.convert_type(w_obj, space.w_array, "to_ary")
        return space.listview(w_obj)

########NEW FILE########
__FILENAME__ = consts
import sys

from rpython.rlib.unroll import unrolling_iterable


SEND_EFFECT = 0xFF
ARRAY_EFFECT = 0xFE
BLOCK_EFFECT = 0xFD
UNPACK_EFFECT = 0xFC

# Name, number of arguments, stack effect
BYTECODES = [
    ("LOAD_SELF", 0, +1),
    ("LOAD_SCOPE", 0, +1),
    ("LOAD_BLOCK", 0, +1),
    ("LOAD_CODE", 0, +1),
    ("LOAD_CONST", 1, +1),

    ("LOAD_DEREF", 1, +1),
    ("STORE_DEREF", 1, 0),
    ("LOAD_CLOSURE", 1, +1),

    ("LOAD_CONSTANT", 1, 0),
    ("STORE_CONSTANT", 1, 0),
    ("DEFINED_CONSTANT", 1, 0),

    ("LOAD_LOCAL_CONSTANT", 1, +1),
    ("DEFINED_LOCAL_CONSTANT", 1, 0),

    ("LOAD_INSTANCE_VAR", 1, 0),
    ("STORE_INSTANCE_VAR", 1, -1),
    ("DEFINED_INSTANCE_VAR", 1, 0),

    ("LOAD_CLASS_VAR", 1, 0),
    ("STORE_CLASS_VAR", 1, -1),
    ("DEFINED_CLASS_VAR", 1, 0),

    ("LOAD_GLOBAL", 1, +1),
    ("STORE_GLOBAL", 1, 0),
    ("DEFINED_GLOBAL", 1, +1),

    ("BUILD_ARRAY", 1, ARRAY_EFFECT),
    ("BUILD_ARRAY_SPLAT", 1, ARRAY_EFFECT),
    ("BUILD_STRING", 1, ARRAY_EFFECT),
    ("BUILD_HASH", 0, +1),
    ("BUILD_RANGE", 0, -1),
    ("BUILD_RANGE_EXCLUSIVE", 0, -1),
    ("BUILD_FUNCTION", 0, -1),
    ("BUILD_BLOCK", 1, BLOCK_EFFECT),
    ("BUILD_LAMBDA", 0, 0),
    ("BUILD_CLASS", 0, -2),
    ("BUILD_MODULE", 0, -1),
    ("BUILD_REGEXP", 0, -1),

    ("COERCE_ARRAY", 1, 0),
    ("COERCE_BLOCK", 0, 0),
    ("COERCE_STRING", 0, 0),
    ("UNPACK_SEQUENCE", 1, UNPACK_EFFECT),
    ("UNPACK_SEQUENCE_SPLAT", 2, UNPACK_EFFECT),

    ("DEFINE_FUNCTION", 0, -2),
    ("ATTACH_FUNCTION", 0, -2),
    ("EVALUATE_MODULE", 0, -1),
    ("LOAD_SINGLETON_CLASS", 0, 0),

    ("SEND", 2, SEND_EFFECT),
    ("SEND_BLOCK", 2, SEND_EFFECT),
    ("SEND_SPLAT", 2, SEND_EFFECT),
    ("SEND_BLOCK_SPLAT", 2, SEND_EFFECT),
    ("DEFINED_METHOD", 1, 0),

    ("SEND_SUPER_BLOCK", 2, SEND_EFFECT),
    ("SEND_SUPER_BLOCK_SPLAT", 2, SEND_EFFECT),
    ("DEFINED_SUPER", 1, 0),

    ("SETUP_LOOP", 1, 0),
    ("SETUP_EXCEPT", 1, 0),
    ("SETUP_FINALLY", 1, 0),
    ("END_FINALLY", 0, -2),
    ("POP_BLOCK", 0, 0),

    ("JUMP", 1, 0),
    ("JUMP_IF_TRUE", 1, -1),
    ("JUMP_IF_FALSE", 1, -1),

    ("DISCARD_TOP", 0, -1),
    ("DUP_TOP", 0, +1),
    ("DUP_TWO", 0, +2),
    ("ROT_TWO", 0, 0),
    ("ROT_THREE", 0, 0),

    ("YIELD", 1, ARRAY_EFFECT),
    ("YIELD_SPLAT", 1, SEND_EFFECT),
    ("DEFINED_YIELD", 0, +1),

    ("RETURN", 0, -1),
    ("RAISE_RETURN", 0, -1),
    ("CONTINUE_LOOP", 1, -1),
    ("BREAK_LOOP", 0, -1),
    ("RAISE_BREAK", 0, -1),
]

BYTECODE_NAMES = []
BYTECODE_NUM_ARGS = []
BYTECODE_STACK_EFFECT = []

module = sys.modules[__name__]
for i, (name, num_args, stack_effect) in enumerate(BYTECODES):
    setattr(module, name, i)
    BYTECODE_NAMES.append(name)
    BYTECODE_NUM_ARGS.append(num_args)
    BYTECODE_STACK_EFFECT.append(stack_effect)

UNROLLING_BYTECODES = unrolling_iterable(enumerate(BYTECODE_NAMES))

########NEW FILE########
__FILENAME__ = error
import os
import errno


class RubyError(Exception):
    def __init__(self, w_value):
        self.w_value = w_value

    def __str__(self):
        return "<RubyError: %s>" % self.w_value


def format_traceback(space, exc, top_filepath):
    w_bt = space.send(exc, "backtrace")
    bt_w = space.listview(w_bt)
    if bt_w:
        yield "%s: %s (%s)\n" % (space.str_w(bt_w[0]), exc.msg, space.getclass(exc).name)
        for w_line in bt_w[1:]:
            yield "\tfrom %s\n" % space.str_w(w_line)
    else:
        yield "%s: %s (%s)\n" % (top_filepath, exc.msg, space.getclass(exc).name)


def print_traceback(space, w_exc, top_filepath=None):
    for line in format_traceback(space, w_exc, top_filepath):
        os.write(2, line)


_errno_for_oserror_map = {
    errno.ENOENT: "ENOENT",
    errno.EBADF: "EBADF",
    errno.ECHILD: "ECHILD",
    errno.EACCES: "EACCES",
    errno.EEXIST: "EEXIST",
    errno.ENOTDIR: "ENOTDIR",
    errno.EISDIR: "EISDIR",
    errno.EINVAL: "EINVAL",
    errno.ENOTEMPTY: "ENOTEMPTY",
}


def error_for_oserror(space, exc):
    return error_for_errno(space, exc.errno)


def error_for_errno(space, errno):
    try:
        name = _errno_for_oserror_map[errno]
    except KeyError:
        w_type = space.w_SystemCallError
    else:
        w_type = space.find_const(space.find_const(space.w_object, "Errno"), name)
    return space.error(
        w_type,
        os.strerror(errno),
        [space.newint(errno)]
    )

########NEW FILE########
__FILENAME__ = executioncontext
from rpython.rlib import jit

from topaz.error import RubyError
from topaz.frame import Frame
from topaz.objects.fiberobject import W_FiberObject


class ExecutionContextHolder(object):
    # TODO: convert to be a threadlocal store once we have threads.
    def __init__(self):
        self._ec = None

    def get(self):
        return self._ec

    def set(self, ec):
        self._ec = ec

    def clear(self):
        self._ec = None


class ExecutionContext(object):
    _immutable_fields_ = ["w_trace_proc?"]

    def __init__(self):
        self.topframeref = jit.vref_None
        self.last_instr = -1
        self.w_trace_proc = None
        self.in_trace_proc = False
        self.recursive_calls = {}
        self.catch_names = {}

        self.fiber_thread = None
        self.w_main_fiber = None

    def getmainfiber(self, space):
        if self.w_main_fiber is None:
            self.w_main_fiber = W_FiberObject.build_main_fiber(space, self)
        return self.w_main_fiber

    def settraceproc(self, w_proc):
        self.w_trace_proc = w_proc

    def gettraceproc(self):
        return self.w_trace_proc

    def hastraceproc(self):
        return self.w_trace_proc is not None and not self.in_trace_proc

    def invoke_trace_proc(self, space, event, scope_id, classname, frame=None):
        if self.hastraceproc():
            self.in_trace_proc = True
            try:
                if frame is None:
                    frame = self.gettoprubyframe()
                space.send(self.w_trace_proc, "call", [
                    space.newstr_fromstr(event),
                    space.newstr_fromstr(frame.bytecode.filepath),
                    space.newint(frame.bytecode.lineno_table[frame.last_instr]),
                    space.newstr_fromstr(scope_id) if scope_id is not None else space.w_nil,
                    space.newbinding_fromframe(frame),
                    space.newstr_fromstr(classname) if classname is not None else space.w_nil,
                ])
            finally:
                self.in_trace_proc = False

    def enter(self, frame):
        frame.backref = self.topframeref
        if self.last_instr != -1:
            frame.back_last_instr = self.last_instr
        self.topframeref = jit.virtual_ref(frame)

    def leave(self, frame, got_exception):
        frame_vref = self.topframeref
        self.topframeref = frame.backref
        if frame.escaped or got_exception:
            back = frame.backref()
            if back is not None:
                back.escaped = True
            frame_vref()
        jit.virtual_ref_finish(frame_vref, frame)

    def visit_frame(self, frame):
        return _VisitFrameContextManager(self, frame)

    def gettopframe(self):
        return self.topframeref()

    @jit.unroll_safe
    def gettoprubyframe(self):
        frame = self.gettopframe()
        while frame is not None and not isinstance(frame, Frame):
            frame = frame.backref()
        return frame

    def recursion_guard(self, func_id, w_obj):
        # We need independent recursion detection for different blocks of
        # potentially recursive code so that they don't interfere with each
        # other and cause false positives. This is only likely to be a problem
        # if one recursion-guarded function calls another, but we can't
        # guarantee that won't happen.
        return _RecursionGuardContextManager(self, func_id, w_obj)

    def catch_block(self, name):
        return _CatchContextManager(self, name)

    def is_in_catch_block_for_name(self, name):
        return name in self.catch_names


class _VisitFrameContextManager(object):
    def __init__(self, ec, frame):
        self.ec = ec
        self.frame = frame

    def __enter__(self):
        self.ec.enter(self.frame)

    def __exit__(self, exc_type, exc_value, tb):
        if exc_value is not None and isinstance(exc_value, RubyError):
            if exc_value.w_value.frame is None:
                exc_value.w_value.frame = self.frame

        self.ec.leave(self.frame, exc_value is not None)


class _RecursionGuardContextManager(object):
    def __init__(self, ec, func_id, w_obj):
        self.ec = ec
        if func_id not in self.ec.recursive_calls:
            self.ec.recursive_calls[func_id] = {}
        self.recursive_objects = self.ec.recursive_calls[func_id]
        self.func_id = func_id
        self.w_obj = w_obj
        self.added = False

    def __enter__(self):
        if self.w_obj in self.recursive_objects:
            return True
        self.recursive_objects[self.w_obj] = None
        self.added = True
        return False

    def __exit__(self, exc_type, exc_value, tb):
        if self.added:
            del self.recursive_objects[self.w_obj]
            if not self.recursive_objects:
                del self.ec.recursive_calls[self.func_id]


class _CatchContextManager(object):
    """This context manager tracks which symbol names we're in catch blocks for
    so that we can raise an appropriate Ruby exception when app-level code
    tries to throw a symbol we're catching. When catch blocks for the same
    symbol are nested, we only care about the outermost one.
    """
    def __init__(self, ec, catch_name):
        self.ec = ec
        self.catch_name = catch_name
        self.added = False

    def __enter__(self):
        if self.catch_name in self.ec.catch_names:
            return
        self.ec.catch_names[self.catch_name] = None
        self.added = True

    def __exit__(self, exc_type, exc_value, tb):
        if self.added:
            del self.ec.catch_names[self.catch_name]

########NEW FILE########
__FILENAME__ = frame
from rpython.rlib import jit

from topaz.closure import LocalCell
from topaz.objects.arrayobject import W_ArrayObject
from topaz.objects.functionobject import W_FunctionObject


class BaseFrame(object):
    _attrs_ = ["backref", "escaped", "back_last_instr"]

    def __init__(self):
        self.backref = jit.vref_None
        self.escaped = False


class Frame(BaseFrame):
    _virtualizable_ = [
        "bytecode", "localsstack_w[*]", "stackpos", "w_self", "block",
        "cells[*]", "lastblock", "lexical_scope", "last_instr", "parent_interp",
        "top_parent_interp",
    ]

    @jit.unroll_safe
    def __init__(self, bytecode, w_self, lexical_scope, block, parent_interp,
                 top_parent_interp, regexp_match_cell):
        self = jit.hint(self, fresh_virtualizable=True, access_directly=True)
        BaseFrame.__init__(self)
        self.bytecode = bytecode
        self.localsstack_w = [None] * (len(bytecode.cellvars) + bytecode.max_stackdepth)
        self.stackpos = len(bytecode.cellvars)
        self.last_instr = 0
        self.cells = [LocalCell() for _ in bytecode.cellvars] + [None] * len(bytecode.freevars)
        self.regexp_match_cell = regexp_match_cell
        self.w_self = w_self
        self.lexical_scope = lexical_scope
        self.block = block
        self.parent_interp = parent_interp
        self.top_parent_interp = top_parent_interp
        self.visibility = W_FunctionObject.PUBLIC
        self.lastblock = None

    def _set_arg(self, space, pos, w_value):
        assert pos >= 0
        self.cells[pos].set(space, self, pos, w_value)

    def handle_block_args(self, space, bytecode, args_w, block):
        if (len(args_w) == 1 and
            isinstance(args_w[0], W_ArrayObject) and len(bytecode.arg_pos) >= 2):
            w_arg = args_w[0]
            args_w = space.listview(w_arg)
        minargc = len(bytecode.arg_pos) - len(bytecode.defaults)
        if len(args_w) < minargc:
            args_w.extend([space.w_nil] * (minargc - len(args_w)))
        if bytecode.splat_arg_pos == -1:
            if len(args_w) > len(bytecode.arg_pos):
                del args_w[len(bytecode.arg_pos):]
        return self.handle_args(space, bytecode, args_w, block)

    @jit.unroll_safe
    def handle_args(self, space, bytecode, args_w, block):
        from topaz.interpreter import Interpreter

        if (len(args_w) < (len(bytecode.arg_pos) - len(bytecode.defaults)) or
            (bytecode.splat_arg_pos == -1 and len(args_w) > len(bytecode.arg_pos))):
            raise space.error(space.w_ArgumentError,
                "wrong number of arguments (%d for %d)" % (len(args_w), len(bytecode.arg_pos) - len(bytecode.defaults))
            )

        for i in xrange(min(len(args_w), len(bytecode.arg_pos))):
            self._set_arg(space, bytecode.arg_pos[i], args_w[i])
        defl_start = len(args_w) - (len(bytecode.arg_pos) - len(bytecode.defaults))
        for i in xrange(len(bytecode.arg_pos) - len(args_w)):
            bc = bytecode.defaults[i + defl_start]
            self.bytecode = bc
            w_value = Interpreter().interpret(space, self, bc)
            self._set_arg(space, bytecode.arg_pos[i + len(args_w)], w_value)
        self.bytecode = bytecode

        if bytecode.splat_arg_pos != -1:
            if len(bytecode.arg_pos) > len(args_w):
                splat_args_w = []
            else:
                splat_args_w = args_w[len(bytecode.arg_pos):]
            w_splat_args = space.newarray(splat_args_w)
            self._set_arg(space, bytecode.splat_arg_pos, w_splat_args)

        if bytecode.block_arg_pos != -1:
            if block is None:
                w_block = space.w_nil
            else:
                w_block = block.copy(space)
            self._set_arg(space, bytecode.block_arg_pos, w_block)

    def push(self, w_obj):
        stackpos = jit.promote(self.stackpos)
        self.localsstack_w[stackpos] = w_obj
        self.stackpos = stackpos + 1

    def pop(self):
        stackpos = jit.promote(self.stackpos) - 1
        assert stackpos >= 0
        w_res = self.localsstack_w[stackpos]
        self.localsstack_w[stackpos] = None
        self.stackpos = stackpos
        return w_res

    @jit.unroll_safe
    def popitemsreverse(self, n):
        items_w = [None] * n
        for i in xrange(n - 1, -1, -1):
            items_w[i] = self.pop()
        return items_w

    def peek(self):
        stackpos = jit.promote(self.stackpos) - 1
        assert stackpos >= 0
        return self.localsstack_w[stackpos]

    def popblock(self):
        lastblock = self.lastblock
        if lastblock is not None:
            self.lastblock = lastblock.lastblock
        return lastblock

    @jit.unroll_safe
    def unrollstack(self, kind):
        while self.lastblock is not None:
            block = self.popblock()
            if block.handling_mask & kind:
                return block
            block.cleanupstack(self)

    def unrollstack_and_jump(self, space, unroller):
        block = self.unrollstack(unroller.kind)
        return block.handle(space, self, unroller)

    def has_contents(self):
        return True

    def get_filename(self):
        return self.bytecode.filepath

    def get_lineno(self, prev_frame):
        if prev_frame is None:
            instr = self.last_instr
        else:
            instr = prev_frame.back_last_instr - 1
        return self.bytecode.lineno_table[instr]

    def get_code_name(self):
        return self.bytecode.name


class BuiltinFrame(BaseFrame):
    def __init__(self, name):
        BaseFrame.__init__(self)
        self.name = name

    def has_contents(self):
        return self.backref() is not None

    def get_filename(self):
        return self.backref().get_filename()

    def get_lineno(self, prev_frame):
        return self.backref().get_lineno(self)

    def get_code_name(self):
        return self.name

########NEW FILE########
__FILENAME__ = gateway
import functools

from rpython.rlib.unroll import unrolling_iterable

from topaz.coerce import Coerce


class WrapperGenerator(object):
    def __init__(self, name, func, argspec, self_cls):
        self.name = name
        self.func = func
        self.argspec = argspec
        self.self_cls = self_cls

    def generate_wrapper(self):
        if hasattr(self.func, "__wraps__"):
            wrapped_func = self.func.__wraps__
        else:
            wrapped_func = self.func

        code = wrapped_func.__code__
        if wrapped_func.__defaults__ is not None:
            defaults = wrapped_func.__defaults__
            default_start = code.co_argcount - len(defaults)
        else:
            defaults = []
            default_start = None
        argspec = self.argspec
        self_cls = self.self_cls
        func = self.func

        argnames = code.co_varnames[:code.co_argcount]
        argcount = 0
        for arg in argnames:
            argcount += arg.startswith("w_") or arg in argspec
        min_args = argcount
        for arg, default in zip(reversed(argnames), reversed(defaults)):
            min_args -= arg.startswith("w_") or arg in argspec
        unrolling_argnames = unrolling_iterable(enumerate(argnames))
        takes_args_w = "args_w" in argnames

        @functools.wraps(self.func)
        def wrapper(self, space, args_w, block):
            if (len(args_w) < min_args or
                (not takes_args_w and len(args_w) > argcount)):
                raise space.error(space.w_ArgumentError,
                    "wrong number of arguments (%d for %d)" % (len(args_w), min_args)
                )
            args = ()
            arg_count = 0
            args_w_seen = False
            for i, argname in unrolling_argnames:
                if argname == "self":
                    assert isinstance(self, self_cls)
                    args += (self,)
                elif argname == "args_w":
                    if args_w_seen:
                        raise SystemError("args_w cannot be repeated")
                    args += (args_w[arg_count:],)
                    args_w_seen = True
                elif argname == "block":
                    args += (block,)
                elif argname == "space":
                    args += (space,)
                elif argname.startswith("w_") or argname in argspec:
                    if args_w_seen:
                        raise SystemError("args_w must be the last argument accepted")
                    if len(args_w) > arg_count:
                        if argname.startswith("w_"):
                            args += (args_w[arg_count],)
                        elif argname in argspec:
                            args += (getattr(Coerce, argspec[argname])(space, args_w[arg_count]),)
                    elif default_start is not None and i >= default_start:
                        args += (defaults[i - default_start],)
                    else:
                        raise SystemError("bad arg count")
                    arg_count += 1
                else:
                    raise SystemError("%r not implemented" % argname)
            w_res = func(*args)
            if w_res is None:
                w_res = space.w_nil
            return w_res
        return wrapper

########NEW FILE########
__FILENAME__ = interpreter
from rpython.rlib import jit, rstackovf
from rpython.rlib.debug import check_nonneg
from rpython.rlib.objectmodel import we_are_translated, specialize

from topaz import consts
from topaz.error import RubyError
from topaz.objects.arrayobject import W_ArrayObject
from topaz.objects.classobject import W_ClassObject
from topaz.objects.codeobject import W_CodeObject
from topaz.objects.functionobject import W_FunctionObject
from topaz.objects.moduleobject import W_ModuleObject
from topaz.objects.objectobject import W_Root
from topaz.objects.procobject import W_ProcObject
from topaz.scope import StaticScope
from topaz.utils.regexp import RegexpError


def get_printable_location(pc, bytecode, block_bytecode, w_trace_proc):
    return "%s at %s" % (bytecode.name, consts.BYTECODE_NAMES[ord(bytecode.code[pc])])


class Interpreter(object):
    jitdriver = jit.JitDriver(
        greens=["pc", "bytecode", "block_bytecode", "w_trace_proc"],
        reds=["self", "frame"],
        virtualizables=["frame"],
        get_printable_location=get_printable_location,
        check_untranslated=False
    )

    def __init__(self):
        self.finished = False

    def get_block_bytecode(self, block):
        return block.bytecode if block is not None else None

    def interpret(self, space, frame, bytecode):
        pc = 0
        try:
            while True:
                self.jitdriver.jit_merge_point(
                    self=self, bytecode=bytecode, frame=frame, pc=pc,
                    block_bytecode=self.get_block_bytecode(frame.block),
                    w_trace_proc=space.getexecutioncontext().gettraceproc(),
                )
                pc = self._interpret(space, pc, frame, bytecode)
        except RaiseReturn as e:
            if e.parent_interp is self:
                return e.w_value
            raise
        except Return as e:
            return e.w_value
        finally:
            self.finished = True

    def _interpret(self, space, pc, frame, bytecode):
        prev_instr = frame.last_instr
        frame.last_instr = pc
        if (space.getexecutioncontext().hastraceproc() and
            bytecode.lineno_table[pc] != bytecode.lineno_table[prev_instr]):
            space.getexecutioncontext().invoke_trace_proc(space, "line", None, None, frame=frame)
        try:
            pc = self.handle_bytecode(space, pc, frame, bytecode)
        except RubyError as e:
            pc = self.handle_ruby_error(space, pc, frame, bytecode, e)
        except RaiseReturn as e:
            pc = self.handle_raise_return(space, pc, frame, bytecode, e)
        except RaiseBreak as e:
            pc = self.handle_raise_break(space, pc, frame, bytecode, e)
        except Throw as e:
            pc = self.handle_throw(space, pc, frame, bytecode, e)
        except rstackovf.StackOverflow:
            rstackovf.check_stack_overflow()
            pc = self.handle_ruby_error(space, pc, frame, bytecode, space.error(space.w_SystemStackError, "stack level too deep"))
        return pc

    def handle_bytecode(self, space, pc, frame, bytecode):
        instr = ord(bytecode.code[pc])
        pc += 1
        if we_are_translated():
            for i, name in consts.UNROLLING_BYTECODES:
                if i == instr:
                    pc = self.run_instr(space, name, consts.BYTECODE_NUM_ARGS[i], bytecode, frame, pc)
                    break
            else:
                raise SystemError
        else:
            pc = self.run_instr(space, consts.BYTECODE_NAMES[instr], consts.BYTECODE_NUM_ARGS[instr], bytecode, frame, pc)
        return pc

    @specialize.arg(2, 3)
    def run_instr(self, space, name, num_args, bytecode, frame, pc):
        args = ()
        # Do not change these from * 256 to << 8, lshift has defined overflow
        # semantics which cause it to not propogate the nonnegative-ness.
        if num_args >= 1:
            v = ord(bytecode.code[pc]) | (ord(bytecode.code[pc + 1]) * 256)
            check_nonneg(v)
            args += (v,)
            pc += 2
        if num_args >= 2:
            v = ord(bytecode.code[pc]) | (ord(bytecode.code[pc + 1]) * 256)
            check_nonneg(v)
            args += (v,)
            pc += 2
        if num_args >= 3:
            raise NotImplementedError

        method = getattr(self, name)
        try:
            res = method(space, bytecode, frame, pc, *args)
        except RaiseBreak as e:
            if e.parent_interp is not self:
                raise
            frame.push(e.w_value)
            res = None
        if res is not None:
            pc = res
        return pc

    def handle_ruby_error(self, space, pc, frame, bytecode, e):
        block = frame.unrollstack(ApplicationException.kind)
        if block is None:
            raise e
        unroller = ApplicationException(e)
        return block.handle(space, frame, unroller)

    def handle_raise_return(self, space, pc, frame, bytecode, e):
        block = frame.unrollstack(RaiseReturnValue.kind)
        if block is None:
            raise e
        unroller = RaiseReturnValue(e.parent_interp, e.w_value)
        return block.handle(space, frame, unroller)

    def handle_raise_break(self, space, pc, frame, bytecode, e):
        block = frame.unrollstack(RaiseBreakValue.kind)
        if block is None:
            raise e
        unroller = RaiseBreakValue(e.parent_interp, e.w_value)
        return block.handle(space, frame, unroller)

    def handle_throw(self, space, pc, frame, bytecode, e):
        block = frame.unrollstack(ThrowValue.kind)
        if block is None:
            raise e
        unroller = ThrowValue(e.name, e.w_value)
        return block.handle(space, frame, unroller)

    def jump(self, space, bytecode, frame, cur_pc, target_pc):
        if target_pc < cur_pc:
            self.jitdriver.can_enter_jit(
                self=self, bytecode=bytecode, frame=frame, pc=target_pc,
                block_bytecode=self.get_block_bytecode(frame.block),
                w_trace_proc=space.getexecutioncontext().gettraceproc()
            )
        return target_pc

    def LOAD_SELF(self, space, bytecode, frame, pc):
        w_self = frame.w_self
        jit.promote(space.getclass(w_self))
        frame.push(w_self)

    def LOAD_SCOPE(self, space, bytecode, frame, pc):
        if frame.lexical_scope is not None:
            frame.push(frame.lexical_scope.w_mod)
        else:
            frame.push(space.w_object)

    def LOAD_BLOCK(self, space, bytecode, frame, pc):
        frame.push(frame.block or space.w_nil)

    def LOAD_CODE(self, space, bytecode, frame, pc):
        frame.push(bytecode)

    def LOAD_CONST(self, space, bytecode, frame, pc, idx):
        frame.push(bytecode.consts_w[idx])

    def LOAD_DEREF(self, space, bytecode, frame, pc, idx):
        frame.push(frame.cells[idx].get(space, frame, idx) or space.w_nil)

    def STORE_DEREF(self, space, bytecode, frame, pc, idx):
        frame.cells[idx].set(space, frame, idx, frame.peek())

    def LOAD_CLOSURE(self, space, bytecode, frame, pc, idx):
        frame.push(frame.cells[idx].upgrade_to_closure(space, frame, idx))

    def LOAD_CONSTANT(self, space, bytecode, frame, pc, idx):
        space.getexecutioncontext().last_instr = pc
        w_scope = frame.pop()
        w_name = bytecode.consts_w[idx]
        name = space.symbol_w(w_name)
        w_obj = space.find_const(w_scope, name)
        frame.push(w_obj)

    def STORE_CONSTANT(self, space, bytecode, frame, pc, idx):
        space.getexecutioncontext().last_instr = pc
        w_name = bytecode.consts_w[idx]
        name = space.symbol_w(w_name)
        w_value = frame.pop()
        w_scope = frame.pop()
        space.set_const(w_scope, name, w_value)
        frame.push(w_value)

    def DEFINED_CONSTANT(self, space, bytecode, frame, pc, idx):
        space.getexecutioncontext().last_instr = pc
        w_name = bytecode.consts_w[idx]
        w_scope = frame.pop()
        if space.is_true(space.send(w_scope, "const_defined?", [w_name])):
            frame.push(space.newstr_fromstr("constant"))
        else:
            frame.push(space.w_nil)

    def LOAD_LOCAL_CONSTANT(self, space, bytecode, frame, pc, idx):
        space.getexecutioncontext().last_instr = pc
        frame.pop()
        w_name = bytecode.consts_w[idx]
        name = space.symbol_w(w_name)
        frame.push(space.find_lexical_const(jit.promote(frame.lexical_scope), name))

    @jit.unroll_safe
    def DEFINED_LOCAL_CONSTANT(self, space, bytecode, frame, pc, idx):
        space.getexecutioncontext().last_instr = pc
        frame.pop()
        w_name = bytecode.consts_w[idx]
        name = space.symbol_w(w_name)
        w_res = space._find_lexical_const(jit.promote(frame.lexical_scope), name)
        if w_res is None:
            frame.push(space.w_nil)
        else:
            frame.push(space.newstr_fromstr("constant"))

    def LOAD_INSTANCE_VAR(self, space, bytecode, frame, pc, idx):
        w_name = bytecode.consts_w[idx]
        w_obj = frame.pop()
        w_res = (space.find_instance_var(w_obj, space.symbol_w(w_name))
                 or space.w_nil)
        frame.push(w_res)

    def STORE_INSTANCE_VAR(self, space, bytecode, frame, pc, idx):
        w_name = bytecode.consts_w[idx]
        w_value = frame.pop()
        w_obj = frame.pop()
        space.set_instance_var(w_obj, space.symbol_w(w_name), w_value)
        frame.push(w_value)

    def DEFINED_INSTANCE_VAR(self, space, bytecode, frame, pc, idx):
        space.getexecutioncontext().last_instr = pc
        w_name = bytecode.consts_w[idx]
        w_obj = frame.pop()
        if space.is_true(space.send(w_obj, "instance_variable_defined?", [w_name])):
            frame.push(space.newstr_fromstr("instance-variable"))
        else:
            frame.push(space.w_nil)

    def LOAD_CLASS_VAR(self, space, bytecode, frame, pc, idx):
        name = space.symbol_w(bytecode.consts_w[idx])
        w_module = frame.pop()
        assert isinstance(w_module, W_ModuleObject)
        w_value = space.find_class_var(w_module, name)
        frame.push(w_value)

    def STORE_CLASS_VAR(self, space, bytecode, frame, pc, idx):
        name = space.symbol_w(bytecode.consts_w[idx])
        w_value = frame.pop()
        w_module = frame.pop()
        assert isinstance(w_module, W_ModuleObject)
        space.set_class_var(w_module, name, w_value)
        frame.push(w_value)

    def DEFINED_CLASS_VAR(self, space, bytecode, frame, pc, idx):
        space.getexecutioncontext().last_instr = pc
        w_name = bytecode.consts_w[idx]
        w_obj = frame.pop()
        if space.is_true(space.send(w_obj, "class_variable_defined?", [w_name])):
            frame.push(space.newstr_fromstr("class variable"))
        else:
            frame.push(space.w_nil)

    def LOAD_GLOBAL(self, space, bytecode, frame, pc, idx):
        space.getexecutioncontext().last_instr = pc
        name = space.symbol_w(bytecode.consts_w[idx])
        w_value = space.globals.get(space, name) or space.w_nil
        frame.push(w_value)

    def STORE_GLOBAL(self, space, bytecode, frame, pc, idx):
        space.getexecutioncontext().last_instr = pc
        name = space.symbol_w(bytecode.consts_w[idx])
        w_value = frame.peek()
        space.globals.set(space, name, w_value)

    def DEFINED_GLOBAL(self, space, bytecode, frame, pc, idx):
        name = space.symbol_w(bytecode.consts_w[idx])
        if space.globals.get(space, name) is not None:
            frame.push(space.newstr_fromstr("global-variable"))
        else:
            frame.push(space.w_nil)

    def BUILD_ARRAY(self, space, bytecode, frame, pc, n_items):
        items_w = frame.popitemsreverse(n_items)
        frame.push(space.newarray(items_w))

    @jit.unroll_safe
    def BUILD_ARRAY_SPLAT(self, space, bytecode, frame, pc, n_items):
        arrays_w = frame.popitemsreverse(n_items)
        items_w = []
        for w_array in arrays_w:
            items_w.extend(space.listview(w_array))
        frame.push(space.newarray(items_w))

    def BUILD_STRING(self, space, bytecode, frame, pc, n_items):
        items_w = frame.popitemsreverse(n_items)
        frame.push(space.newstr_fromstrs(items_w))

    def BUILD_HASH(self, space, bytecode, frame, pc):
        frame.push(space.newhash())

    def BUILD_RANGE(self, space, bytecode, frame, pc):
        w_end = frame.pop()
        w_start = frame.pop()
        w_range = space.newrange(w_start, w_end, False)
        frame.push(w_range)

    def BUILD_RANGE_EXCLUSIVE(self, space, bytecode, frame, pc):
        w_end = frame.pop()
        w_start = frame.pop()
        w_range = space.newrange(w_start, w_end, True)
        frame.push(w_range)

    def BUILD_FUNCTION(self, space, bytecode, frame, pc):
        w_code = frame.pop()
        w_name = frame.pop()
        w_func = space.newfunction(w_name, w_code, frame.lexical_scope, frame.visibility)
        frame.push(w_func)

    @jit.unroll_safe
    def BUILD_BLOCK(self, space, bytecode, frame, pc, n_cells):
        cells = [frame.pop() for _ in range(n_cells)]
        w_code = frame.pop()
        assert isinstance(w_code, W_CodeObject)
        frame.push(space.newproc(
            w_code, frame.w_self, frame.lexical_scope, cells, frame.block,
            self, frame.top_parent_interp or self, frame.regexp_match_cell
        ))

    def BUILD_LAMBDA(self, space, bytecode, frame, pc):
        block = frame.pop()
        assert isinstance(block, W_ProcObject)
        frame.push(block.copy(space, is_lambda=True))

    def BUILD_CLASS(self, space, bytecode, frame, pc):
        space.getexecutioncontext().last_instr = pc
        superclass = frame.pop()
        w_name = frame.pop()
        w_scope = frame.pop()

        name = space.symbol_w(w_name)
        w_cls = w_scope.find_included_const(space, name)
        if w_cls is None:
            if superclass is space.w_nil:
                superclass = space.w_object
            if not space.is_kind_of(superclass, space.w_class):
                cls_name = space.obj_to_s(space.getclass(superclass))
                raise space.error(space.w_TypeError,
                    "wrong argument type %s (expected Class)" % cls_name
                )
            assert isinstance(superclass, W_ClassObject)
            if superclass.is_singleton:
                raise space.error(space.w_TypeError, "can't make subclass of singleton class")
            w_cls = space.newclass(name, superclass, w_scope=w_scope)
            space.set_const(w_scope, name, w_cls)
        elif not space.is_kind_of(w_cls, space.w_class):
            raise space.error(space.w_TypeError, "%s is not a class" % name)
        else:
            assert isinstance(w_cls, W_ClassObject)
            if superclass is not space.w_nil and w_cls.superclass is not superclass:
                raise space.error(space.w_TypeError,
                    "superclass mismatch for class %s" % w_cls.name
                )

        frame.push(w_cls)

    def BUILD_MODULE(self, space, bytecode, frame, pc):
        space.getexecutioncontext().last_instr = pc
        w_name = frame.pop()
        w_scope = frame.pop()

        name = space.symbol_w(w_name)
        w_mod = w_scope.find_included_const(space, name)

        if w_mod is None:
            w_mod = space.newmodule(name, w_scope=w_scope)
            space.set_const(w_scope, name, w_mod)
        elif not space.is_kind_of(w_mod, space.w_module) or space.is_kind_of(w_mod, space.w_class):
            raise space.error(space.w_TypeError, "%s is not a module" % name)

        frame.push(w_mod)

    def BUILD_REGEXP(self, space, bytecode, frame, pc):
        w_flags = frame.pop()
        w_string = frame.pop()
        try:
            w_regexp = space.newregexp(space.str_w(w_string), space.int_w(w_flags))
        except RegexpError as e:
            raise space.error(space.w_RegexpError, str(e))
        frame.push(w_regexp)

    def COERCE_ARRAY(self, space, bytecode, frame, pc, nil_is_empty):
        w_obj = frame.pop()
        if w_obj is space.w_nil:
            if nil_is_empty:
                frame.push(space.newarray([]))
            else:
                frame.push(space.newarray([space.w_nil]))
        elif isinstance(w_obj, W_ArrayObject):
            frame.push(w_obj)
        else:
            space.getexecutioncontext().last_instr = pc
            if space.respond_to(w_obj, "to_a"):
                w_res = space.send(w_obj, "to_a")
            elif space.respond_to(w_obj, "to_ary"):
                w_res = space.send(w_obj, "to_ary")
            else:
                w_res = space.newarray([w_obj])
            if not isinstance(w_res, W_ArrayObject):
                w_res = space.newarray([w_obj])
            frame.push(w_res)

    def COERCE_BLOCK(self, space, bytecode, frame, pc):
        w_block = frame.pop()
        if w_block is space.w_nil:
            frame.push(w_block)
        elif isinstance(w_block, W_ProcObject):
            frame.push(w_block)
        elif space.respond_to(w_block, "to_proc"):
            space.getexecutioncontext().last_instr = pc
            # Proc implements to_proc, too, but MRI doesn't call it
            w_res = space.convert_type(w_block, space.w_proc, "to_proc")
            assert isinstance(w_res, W_ProcObject)
            frame.push(w_res)
        else:
            raise space.error(space.w_TypeError, "wrong argument type")

    def COERCE_STRING(self, space, bytecode, frame, pc):
        w_symbol = frame.pop()
        frame.push(space.newstr_fromstr(space.symbol_w(w_symbol)))

    @jit.unroll_safe
    def UNPACK_SEQUENCE(self, space, bytecode, frame, pc, n_items):
        w_obj = frame.pop()
        items_w = space.listview(w_obj)
        for i in xrange(n_items - 1, -1, -1):
            try:
                w_obj = items_w[i]
            except IndexError:
                w_obj = space.w_nil
            frame.push(w_obj)

    @jit.unroll_safe
    def UNPACK_SEQUENCE_SPLAT(self, space, bytecode, frame, pc, n_targets, n_pre):
        w_obj = frame.pop()
        items_w = space.listview(w_obj)
        n_items = len(items_w)
        n_post = n_targets - n_pre - 1
        n_splat = max(n_items - n_pre - n_post, 0)
        for i in xrange(n_items, n_pre + n_splat + n_post, 1):
            items_w.append(space.w_nil)

        for i in xrange(n_pre + n_splat + n_post - 1, n_pre + n_splat - 1, -1):
            frame.push(items_w[i])
        splat_array = [items_w[i] for i in xrange(n_pre, n_pre + n_splat, 1)]
        frame.push(space.newarray(splat_array))
        for i in xrange(n_pre - 1, -1, -1):
            frame.push(items_w[i])

    def DEFINE_FUNCTION(self, space, bytecode, frame, pc):
        w_func = frame.pop()
        w_name = frame.pop()
        w_scope = frame.pop()
        assert isinstance(w_func, W_FunctionObject)
        # None is special case. It means that we are trying to define
        # a method on Symbol or Numeric.
        if w_scope is None:
            raise space.error(space.w_TypeError,
                """can't define singleton method "%s" for %s""" % (
                    space.symbol_w(w_name), space.getclass(frame.w_self).name
                )
            )
        w_scope.define_method(space, space.symbol_w(w_name), w_func)
        frame.push(space.w_nil)

    def ATTACH_FUNCTION(self, space, bytecode, frame, pc):
        w_func = frame.pop()
        w_name = frame.pop()
        w_obj = frame.pop()
        if space.is_kind_of(w_obj, space.w_symbol) or space.is_kind_of(w_obj, space.w_numeric):
            raise space.error(space.w_TypeError, "no class/module to add method")
        assert isinstance(w_func, W_FunctionObject)
        w_obj.attach_method(space, space.symbol_w(w_name), w_func)
        frame.push(space.w_nil)

    def EVALUATE_MODULE(self, space, bytecode, frame, pc):
        space.getexecutioncontext().last_instr = pc
        w_bytecode = frame.pop()
        w_mod = frame.pop()
        assert isinstance(w_bytecode, W_CodeObject)

        event = "class" if space.is_kind_of(w_mod, space.w_class) else "module"
        space.getexecutioncontext().invoke_trace_proc(space, event, None, None, frame=frame)
        sub_frame = space.create_frame(w_bytecode, w_mod, StaticScope(w_mod, frame.lexical_scope), block=frame.block)
        with space.getexecutioncontext().visit_frame(sub_frame):
            w_res = space.execute_frame(sub_frame, w_bytecode)

        space.getexecutioncontext().invoke_trace_proc(space, "end", None, None, frame=frame)
        frame.push(w_res)

    def LOAD_SINGLETON_CLASS(self, space, bytecode, frame, pc):
        w_obj = frame.pop()
        if space.is_kind_of(w_obj, space.w_symbol) or space.is_kind_of(w_obj, space.w_fixnum):
            raise space.error(space.w_TypeError, "can't define singleton")
        frame.push(space.getsingletonclass(w_obj))

    def SEND(self, space, bytecode, frame, pc, meth_idx, num_args):
        space.getexecutioncontext().last_instr = pc
        args_w = frame.popitemsreverse(num_args)
        w_receiver = frame.pop()
        w_res = space.send(w_receiver, space.symbol_w(bytecode.consts_w[meth_idx]), args_w)
        frame.push(w_res)

    def SEND_BLOCK(self, space, bytecode, frame, pc, meth_idx, num_args):
        space.getexecutioncontext().last_instr = pc
        w_block = frame.pop()
        args_w = frame.popitemsreverse(num_args - 1)
        w_receiver = frame.pop()
        if w_block is space.w_nil:
            w_block = None
        else:
            assert isinstance(w_block, W_ProcObject)
        w_res = space.send(w_receiver, space.symbol_w(bytecode.consts_w[meth_idx]), args_w, block=w_block)
        frame.push(w_res)

    @jit.unroll_safe
    def SEND_SPLAT(self, space, bytecode, frame, pc, meth_idx, num_args):
        space.getexecutioncontext().last_instr = pc
        arrays_w = frame.popitemsreverse(num_args)
        length = 0
        for w_array in arrays_w:
            length += len(space.listview(w_array))
        args_w = [None] * length
        pos = 0
        for w_array in arrays_w:
            array_w = space.listview(w_array)
            args_w[pos:pos + len(array_w)] = array_w
            pos += len(array_w)
        w_receiver = frame.pop()
        w_res = space.send(w_receiver, space.symbol_w(bytecode.consts_w[meth_idx]), args_w)
        frame.push(w_res)

    @jit.unroll_safe
    def SEND_BLOCK_SPLAT(self, space, bytecode, frame, pc, meth_idx, num_args):
        space.getexecutioncontext().last_instr = pc
        w_block = frame.pop()
        arrays_w = frame.popitemsreverse(num_args - 1)
        args_w = []
        for w_array in arrays_w:
            args_w.extend(space.listview(w_array))
        w_receiver = frame.pop()
        if w_block is space.w_nil:
            w_block = None
        else:
            assert isinstance(w_block, W_ProcObject)
        w_res = space.send(w_receiver, space.symbol_w(bytecode.consts_w[meth_idx]), args_w, block=w_block)
        frame.push(w_res)

    def DEFINED_METHOD(self, space, bytecode, frame, pc, meth_idx):
        space.getexecutioncontext().last_instr = pc
        w_obj = frame.pop()
        if space.respond_to(w_obj, space.symbol_w(bytecode.consts_w[meth_idx])):
            frame.push(space.newstr_fromstr("method"))
        else:
            frame.push(space.w_nil)

    def SEND_SUPER_BLOCK(self, space, bytecode, frame, pc, meth_idx, num_args):
        space.getexecutioncontext().last_instr = pc
        w_block = frame.pop()
        args_w = frame.popitemsreverse(num_args - 1)
        w_receiver = frame.pop()
        if w_block is space.w_nil:
            w_block = None
        else:
            assert isinstance(w_block, W_ProcObject)
        w_res = space.send_super(frame.lexical_scope.w_mod, w_receiver, space.symbol_w(bytecode.consts_w[meth_idx]), args_w, block=w_block)
        frame.push(w_res)

    @jit.unroll_safe
    def SEND_SUPER_BLOCK_SPLAT(self, space, bytecode, frame, pc, meth_idx, num_args):
        space.getexecutioncontext().last_instr = pc
        w_block = frame.pop()
        arrays_w = frame.popitemsreverse(num_args - 1)
        args_w = []
        for w_array in arrays_w:
            args_w.extend(space.listview(w_array))
        w_receiver = frame.pop()
        if w_block is space.w_nil:
            w_block = None
        else:
            assert isinstance(w_block, W_ProcObject)
        w_res = space.send_super(frame.lexical_scope.w_mod, w_receiver, space.symbol_w(bytecode.consts_w[meth_idx]), args_w, block=w_block)
        frame.push(w_res)

    def DEFINED_SUPER(self, space, bytecode, frame, pc, meth_idx):
        space.getexecutioncontext().last_instr = pc
        w_obj = frame.pop()
        name = space.symbol_w(bytecode.consts_w[meth_idx])
        if space.getclass(w_obj).find_method_super(space, name) is not None:
            frame.push(space.newstr_fromstr("super"))
        else:
            frame.push(space.w_nil)

    def SETUP_LOOP(self, space, bytecode, frame, pc, target_pc):
        frame.lastblock = LoopBlock(target_pc, frame.lastblock, frame.stackpos)

    def SETUP_EXCEPT(self, space, bytecode, frame, pc, target_pc):
        frame.lastblock = ExceptBlock(target_pc, frame.lastblock, frame.stackpos)

    def SETUP_FINALLY(self, space, bytecode, frame, pc, target_pc):
        frame.lastblock = FinallyBlock(target_pc, frame.lastblock, frame.stackpos)

    def END_FINALLY(self, space, bytecode, frame, pc):
        frame.pop()
        unroller = frame.pop()
        if isinstance(unroller, SuspendedUnroller):
            block = frame.unrollstack(unroller.kind)
            if block is None:
                unroller.nomoreblocks()
            else:
                return block.handle(space, frame, unroller)
        return pc

    def POP_BLOCK(self, space, bytecode, frame, pc):
        block = frame.popblock()
        block.cleanup(space, frame)

    def JUMP(self, space, bytecode, frame, pc, target_pc):
        return self.jump(space, bytecode, frame, pc, target_pc)

    def JUMP_IF_TRUE(self, space, bytecode, frame, pc, target_pc):
        if space.is_true(frame.pop()):
            return self.jump(space, bytecode, frame, pc, target_pc)
        else:
            return pc

    def JUMP_IF_FALSE(self, space, bytecode, frame, pc, target_pc):
        if space.is_true(frame.pop()):
            return pc
        else:
            return self.jump(space, bytecode, frame, pc, target_pc)

    def DISCARD_TOP(self, space, bytecode, frame, pc):
        frame.pop()

    def DUP_TOP(self, space, bytecode, frame, pc):
        frame.push(frame.peek())

    def DUP_TWO(self, space, bytecode, frame, pc):
        w_1 = frame.pop()
        w_2 = frame.pop()
        frame.push(w_2)
        frame.push(w_1)
        frame.push(w_2)
        frame.push(w_1)

    def ROT_TWO(self, space, bytecode, frame, pc):
        w_1 = frame.pop()
        w_2 = frame.pop()
        frame.push(w_1)
        frame.push(w_2)

    def ROT_THREE(self, space, bytecode, frame, pc):
        w_1 = frame.pop()
        w_2 = frame.pop()
        w_3 = frame.pop()
        frame.push(w_1)
        frame.push(w_3)
        frame.push(w_2)

    def RETURN(self, space, bytecode, frame, pc):
        w_returnvalue = frame.pop()
        block = frame.unrollstack(ReturnValue.kind)
        if block is None:
            raise Return(w_returnvalue)
        unroller = ReturnValue(w_returnvalue)
        return block.handle(space, frame, unroller)

    def RAISE_RETURN(self, space, bytecode, frame, pc):
        w_returnvalue = frame.pop()
        block = frame.unrollstack(RaiseReturnValue.kind)
        if block is None:
            raise RaiseReturn(frame.top_parent_interp, w_returnvalue)
        unroller = RaiseReturnValue(frame.top_parent_interp, w_returnvalue)
        return block.handle(space, frame, unroller)

    def YIELD(self, space, bytecode, frame, pc, n_args):
        if frame.block is None:
            raise space.error(space.w_LocalJumpError, "no block given (yield)")
        space.getexecutioncontext().last_instr = pc
        args_w = frame.popitemsreverse(n_args)
        w_res = space.invoke_block(frame.block, args_w)
        frame.push(w_res)

    @jit.unroll_safe
    def YIELD_SPLAT(self, space, bytecode, frame, pc, num_args):
        if frame.block is None:
            raise space.error(space.w_LocalJumpError, "no block given (yield)")
        space.getexecutioncontext().last_instr = pc
        arrays_w = frame.popitemsreverse(num_args)
        args_w = []
        for w_array in arrays_w:
            args_w.extend(space.listview(w_array))
        w_res = space.invoke_block(frame.block, args_w)
        frame.push(w_res)

    def DEFINED_YIELD(self, space, bytecode, frame, pc):
        if frame.block is not None:
            frame.push(space.newstr_fromstr("yield"))
        else:
            frame.push(space.w_nil)

    def CONTINUE_LOOP(self, space, bytecode, frame, pc, target_pc):
        frame.pop()
        return frame.unrollstack_and_jump(space, ContinueLoop(target_pc))

    def BREAK_LOOP(self, space, bytecode, frame, pc):
        w_obj = frame.pop()
        return frame.unrollstack_and_jump(space, BreakLoop(w_obj))

    def RAISE_BREAK(self, space, bytecode, frame, pc):
        if frame.parent_interp.finished:
            raise space.error(space.w_LocalJumpError, "break from proc-closure")
        w_value = frame.pop()
        block = frame.unrollstack(RaiseBreakValue.kind)
        if block is None:
            raise RaiseBreak(frame.parent_interp, w_value)
        unroller = RaiseBreakValue(frame.parent_interp, w_value)
        return block.handle(space, frame, unroller)


class Return(Exception):
    _immutable_fields_ = ["w_value"]

    def __init__(self, w_value):
        self.w_value = w_value


class RaiseFlow(Exception):
    def __init__(self, parent_interp, w_value):
        self.parent_interp = parent_interp
        self.w_value = w_value


class RaiseReturn(RaiseFlow):
    pass


class RaiseBreak(RaiseFlow):
    pass


class Throw(RaiseFlow):
    def __init__(self, name, w_value):
        self.name = name
        self.w_value = w_value


class SuspendedUnroller(W_Root):
    pass


class ApplicationException(SuspendedUnroller):
    kind = 1 << 1

    def __init__(self, e):
        self.e = e

    def nomoreblocks(self):
        raise self.e


class ReturnValue(SuspendedUnroller):
    kind = 1 << 2

    def __init__(self, w_returnvalue):
        self.w_returnvalue = w_returnvalue

    def nomoreblocks(self):
        raise Return(self.w_returnvalue)


class RaiseReturnValue(SuspendedUnroller):
    kind = 1 << 2

    def __init__(self, parent_interp, w_returnvalue):
        self.parent_interp = parent_interp
        self.w_returnvalue = w_returnvalue

    def nomoreblocks(self):
        raise RaiseReturn(self.parent_interp, self.w_returnvalue)


class ContinueLoop(SuspendedUnroller):
    kind = 1 << 3

    def __init__(self, target_pc):
        self.target_pc = target_pc


class BreakLoop(SuspendedUnroller):
    kind = 1 << 4

    def __init__(self, w_value):
        self.w_value = w_value


class RaiseBreakValue(SuspendedUnroller):
    kind = 1 << 5

    def __init__(self, parent_interp, w_value):
        self.parent_interp = parent_interp
        self.w_value = w_value

    def nomoreblocks(self):
        raise RaiseBreak(self.parent_interp, self.w_value)


class ThrowValue(SuspendedUnroller):
    kind = 1 << 6

    def __init__(self, name, w_value):
        self.name = name
        self.w_value = w_value

    def nomoreblocks(self):
        raise Throw(self.name, self.w_value)


class FrameBlock(object):
    def __init__(self, target_pc, lastblock, stackdepth):
        self.target_pc = target_pc
        self.lastblock = lastblock
        # Leave one extra item on there, as the return value from this suite.
        self.stackdepth = stackdepth + 1

    @jit.unroll_safe
    def cleanupstack(self, frame):
        while frame.stackpos > self.stackdepth:
            frame.pop()


class LoopBlock(FrameBlock):
    handling_mask = ContinueLoop.kind | BreakLoop.kind

    def cleanup(self, space, frame):
        self.cleanupstack(frame)

    def handle(self, space, frame, unroller):
        if isinstance(unroller, ContinueLoop):
            frame.lastblock = self
            return unroller.target_pc
        elif isinstance(unroller, BreakLoop):
            self.cleanupstack(frame)
            frame.push(unroller.w_value)
            return self.target_pc
        else:
            raise SystemError


class ExceptBlock(FrameBlock):
    handling_mask = ApplicationException.kind

    def cleanup(self, space, frame):
        self.cleanupstack(frame)

    def handle(self, space, frame, unroller):
        self.cleanupstack(frame)
        e = unroller.e
        frame.push(unroller)
        frame.push(e.w_value)
        return self.target_pc


class FinallyBlock(FrameBlock):
    # Handles everything.
    handling_mask = -1

    def cleanup(self, space, frame):
        self.cleanupstack(frame)
        frame.push(space.w_nil)

    def handle(self, space, frame, unroller):
        self.cleanupstack(frame)
        frame.push(unroller)
        frame.push(space.w_nil)
        return self.target_pc

########NEW FILE########
__FILENAME__ = lexer
import string

from rpython.rlib.rstring import StringBuilder
from rpython.rlib.runicode import unicode_encode_utf_8

from rply import Token
from rply.token import SourcePosition


class LexerError(Exception):
    def __init__(self, pos, msg=None):
        self.pos = pos
        self.msg = "" if msg is None else msg


class Keyword(object):
    def __init__(self, normal_token, inline_token, state):
        self.normal_token = normal_token
        self.inline_token = inline_token
        self.state = state


class Lexer(object):
    EOF = chr(0)

    EXPR_BEG = 0
    EXPR_END = 1
    EXPR_ARG = 2
    EXPR_CMDARG = 3
    EXPR_ENDARG = 4
    EXPR_MID = 5
    EXPR_FNAME = 6
    EXPR_DOT = 7
    EXPR_CLASS = 8
    EXPR_VALUE = 9
    EXPR_ENDFN = 10

    keywords = {
        "return": Keyword("RETURN", "RETURN", EXPR_MID),
        "yield": Keyword("YIELD", "YIELD", EXPR_ARG),
        "if": Keyword("IF", "IF_MOD", EXPR_BEG),
        "unless": Keyword("UNLESS", "UNLESS_MOD", EXPR_BEG),
        "then": Keyword("THEN", "THEN", EXPR_BEG),
        "elsif": Keyword("ELSIF", "ELSIF", EXPR_BEG),
        "else": Keyword("ELSE", "ELSE", EXPR_BEG),
        "while": Keyword("WHILE", "WHILE_MOD", EXPR_BEG),
        "until": Keyword("UNTIL", "UNTIL_MOD", EXPR_BEG),
        "for": Keyword("FOR", "FOR", EXPR_BEG),
        "in": Keyword("IN", "IN", EXPR_BEG),
        "do": Keyword("DO", "DO", EXPR_BEG),
        "begin": Keyword("BEGIN", "BEGIN", EXPR_BEG),
        "rescue": Keyword("RESCUE", "RESCUE_MOD", EXPR_MID),
        "ensure": Keyword("ENSURE", "ENSURE", EXPR_BEG),
        "def": Keyword("DEF", "DEF", EXPR_FNAME),
        "class": Keyword("CLASS", "CLASS", EXPR_CLASS),
        "module": Keyword("MODULE", "MODULE", EXPR_BEG),
        "case": Keyword("CASE", "CASE", EXPR_BEG),
        "when": Keyword("WHEN", "WHEN", EXPR_BEG),
        "end": Keyword("END", "END", EXPR_END),
        "and": Keyword("AND", "AND", EXPR_BEG),
        "or": Keyword("OR", "OR", EXPR_BEG),
        "not": Keyword("NOT", "NOT", EXPR_BEG),
        "alias": Keyword("ALIAS", "ALIAS", EXPR_FNAME),
        "self": Keyword("SELF", "SELF", EXPR_END),
        "nil": Keyword("NIL", "NIL", EXPR_END),
        "__FILE__": Keyword("__FILE__", "__FILE__", EXPR_END),
        "__LINE__": Keyword("__LINE__", "__LINE__", EXPR_END),
        "true": Keyword("TRUE", "TRUE", EXPR_END),
        "false": Keyword("FALSE", "FALSE", EXPR_END),
        "defined?": Keyword("DEFINED", "DEFINED", EXPR_ARG),
        "super": Keyword("SUPER", "SUPER", EXPR_ARG),
        "undef": Keyword("UNDEF", "UNDEF", EXPR_FNAME),
        "next": Keyword("NEXT", "NEXT", EXPR_MID),
        "break": Keyword("BREAK", "BREAK", EXPR_MID),
    }

    def __init__(self, source, initial_lineno, symtable):
        self.source = source
        self.lineno = initial_lineno
        self.symtable = symtable
        self.current_value = []
        self.idx = 0
        self.columno = 1
        self.state = self.EXPR_BEG
        self.paren_nest = 0
        self.left_paren_begin = 0
        self.command_start = True
        self.condition_state = StackState()
        self.cmd_argument_state = StackState()
        self.str_term = None

    def peek(self):
        ch = self.read()
        self.unread()
        return ch

    def add(self, ch):
        self.current_value.append(ch)

    def clear(self):
        del self.current_value[:]

    def current_pos(self):
        return SourcePosition(self.idx, self.lineno, self.columno)

    def newline(self, ch):
        if ch == "\r" and self.peek() == "\n":
            self.read()
        self.lineno += 1
        self.columno = 1

    def emit(self, token):
        value = "".join(self.current_value)
        self.clear()
        return Token(token, value, self.current_pos())

    def error(self, msg=None):
        raise LexerError(self.current_pos(), msg)

    def tokenize(self):
        space_seen = False
        newline_seen = True
        while True:
            if self.str_term is not None:
                tok = self.str_term.next()
                if tok.gettokentype() in ["STRING_END", "REGEXP_END"]:
                    self.str_term = None
                    self.state = self.EXPR_END
                yield tok
                continue

            command_state = self.command_start
            self.command_start = False
            ch = self.read()
            if ch == self.EOF:
                break
            if ch in " \t":
                space_seen = True
                newline_seen = False
                continue
            elif ch == "#":
                self.comment(ch)
            elif ch in "\r\n":
                space_seen = newline_seen = True
                self.newline(ch)
                if self.state not in [self.EXPR_BEG, self.EXPR_DOT,
                                      self.EXPR_VALUE, self.EXPR_FNAME,
                                      self.EXPR_CLASS]:
                    self.add("\n")
                    while self.peek() in "\r\n ":
                        ch = self.read()
                        if ch in "\r\n":
                            self.newline(ch)
                    self.command_start = True
                    self.state = self.EXPR_BEG
                    yield self.emit("LITERAL_NEWLINE")
                continue
            elif ch == "*":
                for token in self.star(ch, space_seen):
                    yield token
            elif ch == "!":
                for token in self.exclamation(ch):
                    yield token
            elif ch == "=":
                if newline_seen:
                    for token in self.multiline_comment(ch):
                        yield token
                else:
                    for token in self.equal(ch):
                        yield token
            elif ch == "<":
                for token in self.less_than(ch, space_seen):
                    yield token
            elif ch == ">":
                for token in self.greater_than(ch):
                    yield token
            elif ch == '"':
                for token in self.double_quote(ch):
                    yield token
            elif ch == "'":
                for token in self.single_quote(ch):
                    yield token
            elif ch == "?":
                for token in self.question_mark(ch):
                    yield token
            elif ch == "&":
                for token in self.ampersand(ch, space_seen):
                    yield token
            elif ch == "|":
                for token in self.pipe(ch):
                    yield token
            elif ch == "+":
                for token in self.plus(ch, space_seen):
                    yield token
            elif ch == "-":
                for token in self.minus(ch, space_seen):
                    yield token
            elif ch == ".":
                for token in self.dot(ch):
                    yield token
            elif ch.isdigit():
                for token in self.number(ch):
                    yield token
            elif ch == ")":
                for token in self.right_paren(ch):
                    yield token
            elif ch == "]":
                for token in self.right_bracket(ch):
                    yield token
            elif ch == "}":
                for token in self.right_brace(ch):
                    yield token
            elif ch == ":":
                for token in self.colon(ch, space_seen):
                    yield token
            elif ch == "/":
                for token in self.slash(ch, space_seen):
                    yield token
            elif ch == "^":
                for token in self.caret(ch):
                    yield token
            elif ch == ";":
                self.add(ch)
                self.state = self.EXPR_BEG
                yield self.emit("LITERAL_SEMICOLON")
            elif ch == ",":
                self.add(ch)
                self.state = self.EXPR_BEG
                yield self.emit("LITERAL_COMMA")
            elif ch == "~":
                self.add(ch)
                self.state = self.EXPR_BEG
                yield self.emit("TILDE")
            elif ch == "(":
                for token in self.left_paren(ch, space_seen):
                    yield token
            elif ch == "[":
                for token in self.left_bracket(ch, space_seen):
                    yield token
            elif ch == "{":
                for token in self.left_brace(ch):
                    yield token
            elif ch == "\\":
                ch2 = self.read()
                if ch2 in "\r\n":
                    self.newline(ch2)
                    space_seen = True
                    continue
                raise NotImplementedError
            elif ch == "%":
                for token in self.percent(ch, space_seen):
                    yield token
            elif ch == "$":
                for token in self.dollar(ch):
                    yield token
            elif ch == "@":
                for token in self.at(ch):
                    yield token
            elif ch == "`":
                for token in self.backtick(ch, command_state):
                    yield token
            else:
                for token in self.identifier(ch, command_state):
                    yield token
            space_seen = False
            newline_seen = False

    def read(self):
        try:
            ch = self.source[self.idx]
        except IndexError:
            ch = self.EOF
        self.idx += 1
        self.columno += 1
        return ch

    def unread(self):
        idx = self.idx - 1
        assert idx >= 0
        self.idx = idx
        self.columno -= 1

    def is_beg(self):
        return self.state in [self.EXPR_BEG, self.EXPR_MID, self.EXPR_CLASS, self.EXPR_VALUE]

    def is_arg(self):
        return self.state in [self.EXPR_ARG, self.EXPR_CMDARG]

    def is_end(self):
        return self.state in [self.EXPR_END, self.EXPR_ENDARG, self.EXPR_ENDFN]

    def set_expression_state(self):
        if self.state in [self.EXPR_FNAME, self.EXPR_DOT]:
            self.state = self.EXPR_ARG
        else:
            self.state = self.EXPR_BEG

    def emit_identifier(self, command_state, token_name="IDENTIFIER"):
        value = "".join(self.current_value)
        state = self.state
        if value in self.keywords and self.state != self.EXPR_DOT:
            keyword = self.keywords[value]

            if keyword.normal_token == "NOT":
                self.state = self.EXPR_ARG
            else:
                self.state = keyword.state

            if state != self.EXPR_FNAME and keyword.normal_token == "DO":
                return self.emit_do(state)

            if state in [self.EXPR_BEG, self.EXPR_VALUE]:
                token = self.emit(keyword.normal_token)
            else:
                token = self.emit(keyword.inline_token)
                if keyword.inline_token != keyword.normal_token:
                    self.state = self.EXPR_BEG
        else:
            if (state == self.EXPR_BEG and not command_state) or self.is_arg():
                ch = self.read()
                if ch == ":" and self.peek() != ":":
                    self.state = self.EXPR_BEG
                    return self.emit("LABEL")
                self.unread()
            if value[0].isupper():
                token = self.emit("CONSTANT")
            else:
                token = self.emit(token_name)
            if self.is_beg() or self.state == self.EXPR_DOT or self.is_arg():
                if command_state:
                    self.state = self.EXPR_CMDARG
                else:
                    self.state = self.EXPR_ARG
            elif self.state == self.EXPR_ENDFN:
                self.state = self.EXPR_ENDFN
            else:
                self.state = self.EXPR_END
        if token.gettokentype() == "IDENTIFIER" and self.symtable.is_defined(token.getstr()):
            self.state = self.EXPR_END
        return token

    def emit_do(self, state):
        self.command_start = True

        if self.left_paren_begin > 0 and self.left_paren_begin == self.paren_nest:
            self.left_paren_begin = 0
            self.paren_nest -= 1
            return self.emit("DO_LAMBDA")

        if self.condition_state.is_in_state():
            return self.emit("DO_COND")

        if state != self.EXPR_CMDARG and self.cmd_argument_state.is_in_state():
            return self.emit("DO_BLOCK")
        if state in [self.EXPR_ENDARG, self.EXPR_BEG]:
            return self.emit("DO_BLOCK")
        return self.emit("DO")

    def comment(self, ch):
        while True:
            ch = self.read()
            if ch == self.EOF or ch in "\r\n":
                self.unread()
                break

    def multiline_comment(self, ch):
        read = 0
        for ch in "begin":
            read += 1
            if self.read() == ch:
                break
        else:
            for i in xrange(read):
                self.unread()
            for token in self.equal(ch):
                yield token
            return
        while True:
            ch = self.read()
            if ch == self.EOF:
                self.error("embedded document meets end of file")
            if ch in "\r\n":
                self.newline(ch)
                if (self.read() == "=" and
                    self.read() == "e" and
                    self.read() == "n" and
                    self.read() == "d"):
                    break

    def identifier(self, ch, command_state):
        self.add(ch)
        while True:
            ch = self.read()
            if ch == self.EOF:
                yield self.emit_identifier(command_state)
                self.unread()
                break
            if ch in "!?" or (ch == "=" and self.state == self.EXPR_FNAME and self.peek() not in "~>"):
                self.add(ch)
                yield self.emit_identifier(command_state, "FID")
                break
            elif ch.isalnum() or ch == "_" or ord(ch) > 127:
                self.add(ch)
            else:
                self.unread()
                yield self.emit_identifier(command_state)
                break

    def number(self, ch):
        self.state = self.EXPR_END
        self.add(ch)
        first_zero = ch == "0"
        is_hex = False
        is_octal = False
        symbol = "INTEGER"
        while True:
            ch = self.read()
            if ch == self.EOF:
                yield self.emit(symbol)
                self.unread()
                break
            if first_zero and ch.upper() in "XBDO":
                if ch.upper() != "D":
                    self.add(ch.upper())
                is_hex = ch.upper() == "X"
                is_octal = ch.upper() == "O"
            elif first_zero and ch.isdigit():
                is_octal = True
                self.add("O")
                self.add(ch)
            elif ch == ".":
                if not self.peek().isdigit():
                    yield self.emit(symbol)
                    self.unread()
                    break
                self.add(ch)
                symbol = "FLOAT"
            elif ch.isdigit() or (is_hex and ch.upper() in "ABCDEF"):
                if is_octal and ch > "7":
                    self.error()
                self.add(ch)
            elif ch == "_":
                if not (self.peek().isdigit() or (is_hex and self.peek().upper() in "ABCDEF")):
                    self.error()
            elif ch.upper() == "E":
                symbol = "FLOAT"
                self.add(ch.upper())
                if self.peek() in "-+":
                    self.add(self.read())
            else:
                yield self.emit(symbol)
                self.unread()
                break
            first_zero = False

    def double_quote(self, ch):
        self.str_term = StringTerm(self, "\0", ch)
        yield self.emit("STRING_BEG")

    def single_quote(self, ch):
        self.state = self.EXPR_END
        yield self.emit("STRING_BEG")
        while True:
            ch = self.read()
            if ch == self.EOF:
                self.unread()
                break
            elif ch == "'":
                yield self.emit("STRING_CONTENT")
                break
            elif ch == "\\":
                ch2 = self.peek()
                if ch2 in "\\'":
                    ch = self.read()
                self.add(ch)
            else:
                self.add(ch)
        yield self.emit("STRING_END")

    def here_doc(self):
        ch = self.read()

        indent = ch == "-"
        expand = True
        regexp = False
        if indent:
            ch = self.read()

        if ch in "'\"`":
            term = ch
            if term == "'":
                expand = False
            elif term == "`":
                regexp = True

            marker = StringBuilder()
            while True:
                ch = self.read()
                if ch == self.EOF:
                    self.unread()
                    break
                elif ch == term:
                    break
                else:
                    marker.append(ch)
        else:
            if not (ch.isalnum() or ch == "_"):
                self.unread()
                if indent:
                    self.unread()
                return

            marker = StringBuilder()
            marker.append(ch)
            while True:
                ch = self.read()
                if ch == self.EOF or not (ch.isalnum() or ch == "_"):
                    self.unread()
                    break
                marker.append(ch)

        last_line = StringBuilder()
        while True:
            ch = self.read()
            if ch in "\r\n":
                self.newline(ch)
                break
            elif ch == self.EOF:
                self.unread()
                break
            last_line.append(ch)

        self.str_term = HeredocTerm(self, marker.build(), last_line.build(), indent=indent, expand=expand)
        if regexp:
            yield self.emit("XSTRING_BEG")
        else:
            yield self.emit("STRING_BEG")

    def dollar(self, ch):
        self.add(ch)
        self.state = self.EXPR_END
        ch = self.read()
        if ch in "$<>:?\\!\"~&`'+/.,@;":
            self.add(ch)
            yield self.emit("GVAR")
        elif ch == "-" and self.peek().isalnum():
            self.add(ch)
            self.add(self.read())
            yield self.emit("GVAR")
        else:
            self.unread()
            while True:
                ch = self.read()
                if ch.isalnum() or ch == "_":
                    self.add(ch)
                else:
                    self.unread()
                    yield self.emit("GVAR")
                    break

    def at(self, ch):
        self.add(ch)
        ch = self.read()
        if ch == "@":
            self.add(ch)
            token = "CVAR"
        else:
            self.unread()
            token = "IVAR"
        self.state = self.EXPR_END
        while True:
            ch = self.read()
            if ch.isalnum() or ch == "_":
                self.add(ch)
            else:
                self.unread()
                yield self.emit(token)
                break

    def plus(self, ch, space_seen):
        self.add(ch)
        ch2 = self.read()
        if self.state in [self.EXPR_FNAME, self.EXPR_DOT]:
            self.state = self.EXPR_ARG
            if ch2 == "@":
                self.add(ch2)
                yield self.emit("UPLUS")
            else:
                self.unread()
                yield self.emit("PLUS")
        elif ch2 == "=":
            self.add(ch2)
            self.state = self.EXPR_BEG
            yield self.emit("OP_ASGN")
        elif self.is_beg() or (self.is_arg() and space_seen and not ch2.isspace()):
            self.state = self.EXPR_BEG
            if ch2.isdigit():
                self.clear()
                for token in self.number(ch2):
                    yield token
            else:
                self.unread()
                yield self.emit("UPLUS")
        else:
            self.unread()
            self.state = self.EXPR_BEG
            yield self.emit("PLUS")

    def minus(self, ch, space_seen):
        self.add(ch)
        ch2 = self.read()
        if self.state in [self.EXPR_FNAME, self.EXPR_DOT]:
            self.state = self.EXPR_ARG
            if ch2 == "@":
                self.add(ch2)
                yield self.emit("UMINUS")
            else:
                self.unread()
                yield self.emit("MINUS")
        elif ch2 == "=":
            self.add(ch2)
            self.state = self.EXPR_BEG
            yield self.emit("OP_ASGN")
        elif ch2 == ">":
            self.add(ch2)
            self.state = self.EXPR_ARG
            yield self.emit("LAMBDA")
        elif self.is_beg() or (self.is_arg() and space_seen and not ch2.isspace()):
            self.state = self.EXPR_BEG
            self.unread()
            if ch2.isdigit():
                yield self.emit("UMINUS_NUM")
            else:
                yield self.emit("UMINUS")
        else:
            self.state = self.EXPR_BEG
            self.unread()
            yield self.emit("MINUS")

    def star(self, ch, space_seen):
        self.add(ch)
        ch2 = self.read()
        if ch2 == "*":
            self.add(ch2)
            ch3 = self.read()
            if ch3 == "=":
                self.add(ch3)
                self.state = self.EXPR_BEG
                yield self.emit("OP_ASGN")
            else:
                self.unread()
                self.set_expression_state()
                yield self.emit("POW")
        elif ch2 == "=":
            self.add(ch2)
            self.state = self.EXPR_BEG
            yield self.emit("OP_ASGN")
        else:
            self.unread()
            if self.is_arg() and space_seen and not ch2.isspace():
                tok_name = "STAR"
            elif self.is_beg():
                tok_name = "STAR"
            else:
                tok_name = "STAR2"
            self.set_expression_state()
            yield self.emit(tok_name)

    def slash(self, ch, space_seen):
        if self.is_beg():
            self.str_term = StringTerm(self, "\0", "/", is_regexp=True)
            yield self.emit("REGEXP_BEG")
        else:
            ch2 = self.read()
            if ch2 == "=":
                self.add(ch)
                self.add(ch2)
                self.state = self.EXPR_BEG
                yield self.emit("OP_ASGN")
            else:
                self.unread()
                if self.is_arg() and space_seen and not ch2.isspace():
                    self.str_term = StringTerm(self, "\0", "/", is_regexp=True)
                    yield self.emit("REGEXP_BEG")
                else:
                    self.add(ch)
                    self.set_expression_state()
                    yield self.emit("DIVIDE")

    def pipe(self, ch):
        self.add(ch)
        ch2 = self.read()
        if ch2 == "|":
            self.add(ch2)
            self.state = self.EXPR_BEG
            ch3 = self.read()
            if ch3 == "=":
                self.add(ch3)
                yield self.emit("OP_ASGN")
            else:
                self.unread()
                yield self.emit("OROP")
        elif ch2 == "=":
            self.add(ch2)
            self.state = self.EXPR_BEG
            yield self.emit("OP_ASGN")
        else:
            self.unread()
            self.set_expression_state()
            yield self.emit("PIPE")

    def ampersand(self, ch, space_seen):
        self.add(ch)

        ch2 = self.read()
        if ch2 == "&":
            self.add(ch2)
            self.state = self.EXPR_BEG
            ch3 = self.read()
            if ch3 == "=":
                self.add(ch3)
                yield self.emit("OP_ASGN")
            else:
                self.unread()
                yield self.emit("ANDOP")
        elif ch2 == "=":
            self.add(ch2)
            self.state = self.EXPR_BEG
            yield self.emit("OP_ASGN")
        else:
            self.unread()
            if self.is_arg() and space_seen and not ch2.isspace():
                tok = "AMPER"
            elif self.is_beg():
                tok = "AMPER"
            else:
                tok = "AMPER2"
            self.set_expression_state()
            yield self.emit(tok)

    def caret(self, ch):
        self.add(ch)

        ch2 = self.read()
        if ch2 == "=":
            self.add(ch2)
            self.state = self.EXPR_BEG
            yield self.emit("OP_ASGN")
        else:
            self.unread()
            self.set_expression_state()
            yield self.emit("CARET")

    def equal(self, ch):
        self.add(ch)
        self.set_expression_state()
        ch2 = self.read()
        if ch2 == "=":
            self.add(ch2)
            ch3 = self.read()
            if ch3 == "=":
                self.add(ch3)
                yield self.emit("EQQ")
            else:
                self.unread()
                yield self.emit("EQ")
        elif ch2 == "~":
            self.add(ch2)
            yield self.emit("MATCH")
        elif ch2 == ">":
            self.add(ch2)
            yield self.emit("ASSOC")
        else:
            self.unread()
            yield self.emit("LITERAL_EQUAL")

    def less_than(self, ch, space_seen):
        ch2 = self.read()

        if (ch2 == "<" and self.state not in [self.EXPR_DOT, self.EXPR_CLASS] and
            not self.is_end() and (not self.is_arg() or space_seen)):
            tokens_yielded = False
            for token in self.here_doc():
                tokens_yielded = True
                yield token
            if tokens_yielded:
                return

        self.add(ch)
        self.set_expression_state()
        if ch2 == "=":
            self.add(ch2)
            ch3 = self.read()
            if ch3 == ">":
                self.add(ch3)
                yield self.emit("CMP")
            else:
                self.unread()
                yield self.emit("LEQ")
        elif ch2 == "<":
            self.add(ch2)
            ch3 = self.read()
            if ch3 == "=":
                self.add(ch3)
                self.state = self.EXPR_BEG
                yield self.emit("OP_ASGN")
            else:
                self.unread()
                yield self.emit("LSHFT")
        else:
            self.unread()
            yield self.emit("LT")

    def greater_than(self, ch):
        self.add(ch)
        self.set_expression_state()
        ch2 = self.read()
        if ch2 == "=":
            self.add(ch2)
            yield self.emit("GEQ")
        elif ch2 == ">":
            self.add(ch2)
            ch3 = self.read()
            if ch3 == "=":
                self.add(ch3)
                self.state = self.EXPR_BEG
                yield self.emit("OP_ASGN")
            else:
                self.unread()
                yield self.emit("RSHFT")
        else:
            self.unread()
            yield self.emit("GT")

    def dot(self, ch):
        self.add(ch)
        self.state = self.EXPR_BEG
        ch2 = self.read()
        if ch2 == ".":
            self.add(ch2)
            ch3 = self.read()
            if ch3 == ".":
                self.add(ch3)
                yield self.emit("DOT3")
            else:
                self.unread()
                yield self.emit("DOT2")
        else:
            self.unread()
            self.state = self.EXPR_DOT
            yield self.emit("DOT")

    def exclamation(self, ch):
        self.add(ch)
        self.state = self.EXPR_BEG

        ch2 = self.read()
        if ch2 == "=":
            self.add(ch2)
            yield self.emit("NEQ")
        elif ch2 == "~":
            self.add(ch2)
            yield self.emit("NMATCH")
        else:
            self.unread()
            yield self.emit("BANG")

    def question_mark(self, ch):
        if self.is_end():
            self.add(ch)
            self.state = self.EXPR_VALUE
            yield self.emit("LITERAL_QUESTION_MARK")
        else:
            ch2 = self.read()
            if ch2.isspace():
                self.unread()
                self.add(ch)
                self.state = self.EXPR_VALUE
                yield self.emit("LITERAL_QUESTION_MARK")
            else:
                if ch2 == "\\":
                    for ch in self.read_escape(character_escape=True):
                        self.add(ch)
                else:
                    self.add(ch2)
                yield self.emit("CHAR")
                self.state = self.EXPR_END

    def read_escape(self, character_escape=False):
        c = self.read()
        if c == self.EOF:
            self.error()
        elif c == "\\":
            return ["\\"]
        elif c == "n":
            return ["\n"]
        elif c == "t":
            return ["\t"]
        elif c == "r":
            return ["\r"]
        elif c == "f":
            return ["\f"]
        elif c == "v":
            return ["\v"]
        elif c == "a":
            return ["\a"]
        elif c == "b":
            return ["\b"]
        elif c == "e":
            return ["\x1b"]
        elif c == "s":
            return [" "]
        elif c in "\r\n":
            self.newline(c)
            return ["\n"]
        elif c == "u":
            ch = self.peek()
            brace_seen = (ch == "{")
            if brace_seen:
                self.read()
            return self.read_utf_escape(brace_seen=brace_seen, character_escape=character_escape)
        elif c == "x":
            hex_escape = self.read()
            if not hex_escape in string.hexdigits:
                self.error()
            if self.peek() in string.hexdigits:
                hex_escape += self.read()
            return [chr(int(hex_escape, 16))]
        elif c in string.octdigits:
            buf = c
            octal = True
            while self.peek() in string.digits:
                ch2 = self.read()
                if ch2 in string.octdigits:
                    buf += ch2
                elif character_escape:
                    self.error()
                else:
                    octal = False
                    buf += ch2
                if len(buf) > 3 and character_escape:
                    self.error()
            if octal:
                codepoint = int(buf, 8) & 255
                return [chr(codepoint)]
            else:
                buf = "0" * (len(buf) - 3) + buf
                prefix_idx = 3
                for i in xrange(3):
                    if buf[i] not in string.octdigits:
                        prefix_idx = i
                        break
                codepoint = int(buf[:prefix_idx], 8) & 255
                unicode_chars = [chr(codepoint)]
                unicode_chars += buf[prefix_idx:]
                return unicode_chars
        elif c == "M":
            if self.read() != "-":
                self.error()
            c = self.read()
            if c == "\\":
                c = self.read_escape()
                if len(c) != 1:
                    self.error()
                return [chr(ord(c[0]) | 0x80)]
            elif c == self.EOF:
                self.error()
            else:
                return [chr(ord(c) & 0xff | 0x80)]
        elif c == "C" or c == "c":
            if c == "C" and self.read() != "-":
                self.error()
            c = self.read()
            if c == "?":
                return ["\177"]
            elif c == self.EOF:
                self.error()
            else:
                if c == "\\":
                    c = self.read_escape()
                    if len(c) != 1:
                        self.error()
                    [c] = c
                return [chr(ord(c) & 0x9f)]
        return [c]

    def read_utf_escape(self, brace_seen=False, character_escape=False):
        if not brace_seen:
            utf_escape = []
            for i in xrange(4):
                ch = self.read()
                if ch not in string.hexdigits:
                    self.error("invalid Unicode escape")
                utf_escape.append(ch)
            return self.encode_utf_escape(utf_escape)
        elif character_escape:
            ch = self.read()
            if not ch in string.hexdigits:
                self.error("invalid Unicode escape")
            res = self.read_delimited_utf_escape(ch)
            ch = self.read()
            if ch != "}":
                self.error("unterminated Unicode escape")
            return res
        else:
            chars = []
            ch = self.read()
            while ch in string.hexdigits:
                chars += self.read_delimited_utf_escape(ch)
                ch = self.read()
                if ch.isspace():
                    ch = self.read()
                else:
                    break
            if not chars:
                self.error("invalid Unicode escape")
            if ch != "}":
                self.error("unterminated Unicode escape")
            return chars

    def read_delimited_utf_escape(self, ch):
        utf_escape = [ch]
        ch = self.read()
        while ch in string.hexdigits:
            utf_escape.append(ch)
            ch = self.read()
        self.unread()
        return self.encode_utf_escape(utf_escape)

    def encode_utf_escape(self, utf_escape):
        utf_codepoint = int("".join(utf_escape), 16)
        if utf_codepoint > 0x101111:
            self.error("invalid Unicode codepoint (too large)")
        return [c for c in unicode_encode_utf_8(unichr(utf_codepoint), 1, "ignore")]

    def colon(self, ch, space_seen):
        ch2 = self.read()

        self.add(ch)
        if ch2 == ":":
            self.add(ch2)
            if self.is_beg() or self.state == self.EXPR_CLASS or (self.is_arg and space_seen):
                self.state = self.EXPR_BEG
                yield self.emit("COLON3")
            else:
                self.state = self.EXPR_DOT
                yield self.emit("COLON2")
        elif self.is_end() or ch2.isspace():
            self.unread()
            self.state = self.EXPR_BEG
            yield self.emit("LITERAL_COLON")
        else:
            if ch2 == "'":
                self.str_term = StringTerm(self, "\0", ch2, expand=False)
            elif ch2 == '"':
                self.str_term = StringTerm(self, "\0", ch2)
            else:
                self.unread()
            self.state = self.EXPR_FNAME
            yield self.emit("SYMBEG")

    def left_paren(self, ch, space_seen):
        self.add(ch)
        tok_name = "LPAREN2"
        if self.is_beg():
            tok_name = "LPAREN"
        elif space_seen:
            if self.is_arg():
                tok_name = "LPAREN_ARG"
        self.paren_nest += 1
        self.condition_state.stop()
        self.cmd_argument_state.stop()
        self.state = self.EXPR_BEG
        yield self.emit(tok_name)

    def right_paren(self, ch):
        self.paren_nest -= 1
        self.condition_state.restart()
        self.cmd_argument_state.restart()
        self.state = self.EXPR_ENDFN
        yield self.emit("RPAREN")

    def left_bracket(self, ch, space_seen):
        self.paren_nest += 1
        if self.state in [self.EXPR_FNAME, self.EXPR_DOT]:
            self.state = self.EXPR_ARG

            ch2 = self.read()
            if ch2 == "]":
                self.add(ch)
                self.add(ch2)
                ch3 = self.read()
                if ch3 == "=":
                    self.add(ch3)
                    yield self.emit("ASET")
                else:
                    self.unread()
                    yield self.emit("AREF")
            else:
                self.unread()
                yield self.emit("LITERAL_LBRACKET")
        else:
            if (self.is_beg() or (self.is_arg() and space_seen)):
                tok = "LBRACK"
            else:
                tok = "LITERAL_LBRACKET"

            self.state = self.EXPR_BEG
            self.condition_state.stop()
            self.cmd_argument_state.stop()
            yield self.emit(tok)

    def right_bracket(self, ch):
        self.add(ch)
        self.paren_nest -= 1
        self.condition_state.restart()
        self.cmd_argument_state.restart()
        self.state = self.EXPR_ENDARG
        yield self.emit("RBRACK")

    def left_brace(self, ch):
        self.add(ch)
        if self.left_paren_begin > 0 and self.left_paren_begin == self.paren_nest:
            self.state = self.EXPR_BEG
            self.left_paren_begin = 0
            self.paren_nest -= 1
            self.condition_state.stop()
            self.cmd_argument_state.stop()
            yield self.emit("LAMBEG")
        else:
            if self.is_arg() or self.state in [self.EXPR_END, self.EXPR_ENDFN]:
                tok = "LCURLY"
                self.command_start = True
            elif self.state == self.EXPR_ENDARG:
                tok = "LBRACE_ARG"
                self.command_start = True
            else:
                tok = "LBRACE"
            self.condition_state.stop()
            self.cmd_argument_state.stop()
            self.state = self.EXPR_BEG
            yield self.emit(tok)

    def right_brace(self, ch):
        self.add(ch)
        self.condition_state.restart()
        self.cmd_argument_state.restart()
        self.state = self.EXPR_ENDARG
        yield self.emit("RCURLY")

    def backtick(self, ch, command_state):
        self.add(ch)

        if self.state == self.EXPR_FNAME:
            self.state = self.EXPR_ENDFN
            yield self.emit("BACK_REF2")
        elif self.state == self.EXPR_DOT:
            self.state = self.EXPR_CMDARG if command_state else self.EXPR_ARG
            yield self.emit("BACK_REF2")
        else:
            self.str_term = StringTerm(self, "\0", "`")
            yield self.emit("XSTRING_BEG")

    def percent(self, ch, space_seen):
        c = self.read()
        if self.is_beg():
            for token in self.quote(c):
                yield token
        elif c == "=":
            self.add(ch)
            self.add(c)
            self.state = self.EXPR_BEG
            yield self.emit("OP_ASGN")
        elif self.is_arg() and space_seen and not c.isspace():
            for token in self.quote(c):
                yield token
        else:
            self.unread()
            self.add(ch)
            self.set_expression_state()
            yield self.emit("PERCENT")

    def quote(self, ch):
        if not ch.isalnum():
            begin = ch
            ch = "Q"
        else:
            begin = self.read()
            if begin.isalnum():
                self.error()

        if begin == "(":
            end = ")"
        elif begin == "[":
            end = "]"
        elif begin == "{":
            end = "}"
        elif begin == "<":
            end = ">"
        else:
            end = begin
            begin = "\0"

        if ch == "Q":
            self.str_term = StringTerm(self, begin, end)
            yield self.emit("STRING_BEG")
        elif ch == "q":
            self.str_term = StringTerm(self, begin, end, expand=False)
            yield self.emit("STRING_BEG")
        elif ch == "x":
            self.str_term = StringTerm(self, begin, end)
            yield self.emit("XSTRING_BEG")
        elif ch == "W":
            self.str_term = StringTerm(self, begin, end, expand=True, is_qwords=True)
            while True:
                ch = self.read()
                if not ch.isspace():
                    break
            self.unread()
            yield self.emit("WORDS_BEG")
        elif ch == "w":
            self.str_term = StringTerm(self, begin, end, expand=False, is_qwords=True)
            while True:
                ch = self.read()
                if not ch.isspace():
                    break
            self.unread()
            yield self.emit("QWORDS_BEG")
        elif ch == "r":
            self.str_term = StringTerm(self, begin, end, is_regexp=True)
            yield self.emit("REGEXP_BEG")
        elif ch == "s":
            self.str_term = StringTerm(self, begin, end, expand=False)
            self.state = self.EXPR_FNAME
            yield self.emit("SYMBEG")
        else:
            raise NotImplementedError("%" + ch)


class BaseStringTerm(object):
    def __init__(self, lexer, expand):
        self.lexer = lexer
        self.expand = expand
        self.is_end = False


class StringTerm(BaseStringTerm):
    def __init__(self, lexer, begin, end_char, expand=True, is_regexp=False, is_qwords=False):
        BaseStringTerm.__init__(self, lexer, expand=expand)
        self.begin = begin
        self.end_char = end_char
        self.is_regexp = is_regexp
        self.is_qwords = is_qwords
        self.nest = 0

    def next(self):
        if self.is_end:
            return self.lexer.emit("STRING_END")
        ch = self.lexer.read()
        if ch == self.lexer.EOF:
            self.lexer.error()
        space_seen = False
        if self.is_qwords and ch.isspace():
            while ch.isspace():
                if ch in "\r\n":
                    self.lexer.newline(ch)
                ch = self.lexer.read()
            space_seen = True

        if ch == self.end_char and self.nest == 0:
            return self.end_found()

        if space_seen:
            self.lexer.unread()
            return self.lexer.emit("LITERAL_SPACE")

        if self.expand and ch == "#":
            self.lexer.add(ch)
            ch = self.lexer.read()
            if ch in ["$", "@"]:
                self.lexer.unread()
                return self.lexer.emit("STRING_DVAR")
            elif ch == "{":
                self.lexer.add(ch)
                return self.lexer.emit("STRING_DBEG")
        self.lexer.unread()

        while True:
            ch = self.lexer.read()
            if ch == self.lexer.EOF:
                break
            if self.begin != "\0" and ch == self.begin:
                self.lexer.add(ch)
                self.nest += 1
            elif ch == self.end_char:
                if self.nest == 0:
                    self.lexer.unread()
                    break
                self.lexer.add(ch)
                self.nest -= 1
            elif self.expand and ch == "#" and self.lexer.peek() not in "\r\n":
                ch2 = self.lexer.read()

                if ch2 in ["$", "@", "{"]:
                    self.lexer.unread()
                    self.lexer.unread()
                    break
                self.lexer.add(ch)
                self.lexer.unread()
            elif ch == "\\":
                escaped_char = self.lexer.read_escape()
                if (self.is_regexp and len(escaped_char) == 1 and
                    escaped_char[0] in string.printable):
                    self.lexer.add(ch)
                    self.lexer.add(escaped_char[0])
                else:
                    for ch in escaped_char:
                        self.lexer.add(ch)
            elif self.is_qwords and ch.isspace():
                self.lexer.unread()
                break
            elif ch == self.lexer.EOF:
                self.lexer.error()
            else:
                self.lexer.add(ch)
        return self.lexer.emit("STRING_CONTENT")

    def end_found(self):
        if self.is_qwords:
            self.is_end = True
            return self.lexer.emit("LITERAL_SPACE")
        if self.is_regexp:
            flags = ""
            while True:
                ch = self.lexer.read()
                if ch == self.lexer.EOF or not ch.isalpha():
                    self.lexer.unread()
                    break
                elif ch in "ixmouesn":
                    if ch not in flags:
                        flags += ch
                        self.lexer.add(ch)
                else:
                    self.lexer.error()
            return self.lexer.emit("REGEXP_END")
        return self.lexer.emit("STRING_END")


class HeredocTerm(BaseStringTerm):
    def __init__(self, lexer, marker, last_line, indent, expand=True):
        BaseStringTerm.__init__(self, lexer, expand=expand)
        self.marker = marker
        self.last_line = last_line
        self.indent = indent
        self.start_of_line = True

    def next(self):
        if self.is_end:
            if self.last_line:
                # TODO: there should be a real API for this.
                self.lexer.source = self.lexer.source[:self.lexer.idx] + self.last_line + self.lexer.source[self.lexer.idx:]
            return self.lexer.emit("STRING_END")
        if self.start_of_line:
            self.start_of_line = False
            chars = []
            if self.indent:
                while True:
                    ch = self.lexer.read()
                    if ch.isspace():
                        chars.append(ch)
                    else:
                        self.lexer.unread()
                        break
            for c in self.marker:
                ch = self.lexer.read()
                if ch != c:
                    self.lexer.unread()
                    for c in chars:
                        self.lexer.add(c)
                    return self.lexer.emit("STRING_CONTENT")
                chars.append(ch)
            else:
                self.is_end = True
                return self.lexer.emit("STRING_CONTENT")

        ch = self.lexer.read()
        if self.expand and ch == "#":
            self.lexer.add(ch)
            ch = self.lexer.read()
            if ch in ["$", "@"]:
                self.lexer.unread()
                return self.lexer.emit("STRING_DVAR")
            elif ch == "{":
                self.lexer.add(ch)
                return self.lexer.emit("STRING_DBEG")
            else:
                self.lexer.add("#")
        self.lexer.unread()

        while True:
            ch = self.lexer.read()
            if ch in "\r\n":
                self.lexer.newline(ch)
                self.lexer.add("\n")
                self.start_of_line = True
                return self.lexer.emit("STRING_CONTENT")
            elif ch == self.lexer.EOF:
                self.lexer.error()
            elif self.expand and ch == "#" and self.lexer.peek() not in "\r\n":
                ch2 = self.lexer.read()

                if ch2 in ["$", "@", "{"]:
                    self.lexer.unread()
                    self.lexer.unread()
                    return self.lexer.emit("STRING_CONTENT")
                self.lexer.add(ch)
                self.lexer.unread()
            else:
                self.lexer.add(ch)


class StackState(object):
    def __init__(self):
        self._stack = 0

    def begin(self):
        orig = self._stack
        self._stack <<= 1
        self._stack |= 1
        return orig

    def end(self):
        self._stack >>= 1

    def stop(self):
        self._stack <<= 1

    def reset(self, orig):
        self._stack = orig

    def restart(self):
        self._stack |= (self._stack & 1) << 1
        self._stack >>= 1

    def is_in_state(self):
        return (self._stack & 1) != 0

########NEW FILE########
__FILENAME__ = main
from __future__ import absolute_import

import os
import subprocess

from rpython.rlib import jit
from rpython.rlib.objectmodel import specialize
from rpython.rlib.streamio import open_file_as_stream, fdopen_as_stream

from topaz.error import RubyError, print_traceback
from topaz.objects.exceptionobject import W_SystemExit
from topaz.objspace import ObjectSpace
from topaz.system import IS_WINDOWS, IS_64BIT


USAGE = "\n".join([
    """Usage: topaz [switches] [--] [programfile] [arguments]""",
    # """  -0[octal]       specify record separator (\0, if no argument)""",
    # """  -a              autosplit mode with -n or -p (splits $_ into $F)""",
    # """  -c              check syntax only""",
    # """  -Cdirectory     cd to directory, before executing your script""",
    """  -d              set debugging flags (set $DEBUG to true)""",
    """  -e 'command'    one line of script. Several -e's allowed. Omit [programfile]""",
    # """  -Eex[:in]       specify the default external and internal character encodings""",
    # """  -Fpattern       split() pattern for autosplit (-a)""",
    # """  -i[extension]   edit ARGV files in place (make backup if extension supplied)""",
    """  -Idirectory     specify $LOAD_PATH directory (may be used more than once)""",
    # """  -l              enable line ending processing""",
    """  -n              assume 'while gets(); ... end' loop around your script""",
    """  -p              assume loop like -n but print line also like sed""",
    """  -rlibrary       require the library, before executing your script""",
    """  -s              enable some switch parsing for switches after script name""",
    """  -S              look for the script using PATH environment variable""",
    # """  -T[level=1]     turn on tainting checks""",
    """  -v              print version number, then turn on verbose mode""",
    """  -w              turn warnings on for your script""",
    """  -W[level=2]     set warning level; 0=silence, 1=medium, 2=verbose""",
    # """  -x[directory]   strip off text before #!ruby line and perhaps cd to directory""",
    """  --copyright     print the copyright""",
    """  --version       print the version""",
    ""
])
COPYRIGHT = "topaz - Copyright (c) Alex Gaynor and individual contributors\n"
RUBY_REVISION = subprocess.check_output([
    "git",
    "--git-dir", os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir, ".git"),
    "rev-parse", "--short", "HEAD"
]).rstrip()


@specialize.memo()
def getspace(config):
    return ObjectSpace(config)


def get_topaz_config_options():
    return {
        "translation.continuation": True,
    }


def create_entry_point(config):
    def entry_point(argv):
        space = getspace(config)
        space.setup(argv[0])
        return _entry_point(space, argv)
    return entry_point


class CommandLineError(Exception):
    def __init__(self, message):
        self.message = message


class ShortCircuitError(Exception):
    def __init__(self, message):
        self.message = message


def _parse_argv(space, argv):
    flag_globals_w = {
        "$-v": space.w_false,
        "$VERBOSE": space.w_false,
        "$-d": space.w_false,
        "$DEBUG": space.w_false,
        "$-w": space.w_false,
        "$-W": space.newint(1),
        "$-p": space.w_false,
        "$-l": space.w_false,
        "$-a": space.w_false,
    }
    warning_level = None
    do_loop = False
    path = None
    search_path = False
    globalize_switches = False
    globalized_switches = []
    exprs = []
    reqs = []
    load_path_entries = []
    argv_w = []
    idx = 1
    while idx < len(argv):
        arg = argv[idx]
        if arg == "-h" or arg == "--help":
            raise ShortCircuitError(USAGE)
        elif arg == "--copyright":
            raise ShortCircuitError(COPYRIGHT)
        elif arg == "--version":
            raise ShortCircuitError("%s\n" % space.str_w(
                space.send(
                    space.w_object,
                    "const_get",
                    [space.newstr_fromstr("RUBY_DESCRIPTION")]
                )
            ))
        elif arg == "-v":
            flag_globals_w["$-v"] = space.w_true
            flag_globals_w["$VERBOSE"] = space.w_true
        elif arg == "-d":
            flag_globals_w["$-d"] = space.w_true
            flag_globals_w["$VERBOSE"] = space.w_true
            flag_globals_w["$DEBUG"] = space.w_true
        elif arg == "-w":
            flag_globals_w["$-w"] = space.w_true
            flag_globals_w["$VERBOSE"] = space.w_true
        elif arg == "-e":
            idx += 1
            if idx == len(argv):
                raise CommandLineError("no code specified for -e (RuntimeError)\n")
            exprs.append(argv[idx])
        elif arg.startswith("-e"):
            exprs.append(arg[2:])
        elif arg == "-I":
            idx += 1
            load_path_entries += argv[idx].split(os.pathsep)
        elif arg.startswith("-I"):
            load_path_entries += arg[2:].split(os.pathsep)
        elif arg == "-r":
            idx += 1
            reqs.append(argv[idx])
        elif arg.startswith("-r"):
            reqs.append(arg[2:])
        elif arg.startswith("-W"):
            warning_level = arg[2:]
        elif arg == "-S":
            search_path = True
        elif arg == "-s":
            globalize_switches = True
        elif arg == "-n":
            do_loop = True
        elif arg == "-p":
            do_loop = True
            flag_globals_w["$-p"] = space.w_true
        elif arg == "--":
            idx += 1
            break
        else:
            break
        idx += 1
    if idx < len(argv) and not exprs:
        path = argv[idx]
        idx += 1
    while idx < len(argv):
        arg = argv[idx]
        if globalize_switches and arg.startswith("-"):
            globalized_switches.append(arg)
        else:
            argv_w.append(space.newstr_fromstr(arg))
        idx += 1

    if warning_level is not None:
        warning_level_num = 2 if not warning_level.isdigit() else int(warning_level)
        if warning_level_num == 0:
            flag_globals_w["$VERBOSE"] = space.w_nil
        elif warning_level_num == 1:
            flag_globals_w["$VERBOSE"] = space.w_false
        elif warning_level_num >= 2:
            flag_globals_w["$VERBOSE"] = space.w_true

        flag_globals_w["$-W"] = space.newint(warning_level_num)

    return (
        flag_globals_w,
        do_loop,
        path,
        search_path,
        globalized_switches,
        exprs,
        reqs,
        load_path_entries,
        argv_w
    )


def _entry_point(space, argv):
    if IS_WINDOWS:
        system = "Windows"
        cpu = "x86_64" if IS_64BIT else "i686"
    else:
        system, _, _, _, cpu = os.uname()
    platform = "%s-%s" % (cpu, system.lower())
    engine = "topaz"
    version = "1.9.3"
    patchlevel = 125
    description = "%s (ruby-%sp%d) (git rev %s) [%s]" % (engine, version, patchlevel, RUBY_REVISION, platform)
    space.set_const(space.w_object, "RUBY_ENGINE", space.newstr_fromstr(engine))
    space.set_const(space.w_object, "RUBY_VERSION", space.newstr_fromstr(version))
    space.set_const(space.w_object, "RUBY_PATCHLEVEL", space.newint(patchlevel))
    space.set_const(space.w_object, "RUBY_PLATFORM", space.newstr_fromstr(platform))
    space.set_const(space.w_object, "RUBY_DESCRIPTION", space.newstr_fromstr(description))
    space.set_const(space.w_object, "RUBY_REVISION", space.newstr_fromstr(RUBY_REVISION))

    try:
        (
            flag_globals_w,
            do_loop,
            path,
            search_path,
            globalized_switches,
            exprs,
            reqs,
            load_path_entries,
            argv_w
        ) = _parse_argv(space, argv)
    except ShortCircuitError as e:
        os.write(1, e.message)
        return 0
    except CommandLineError as e:
        os.write(2, e.message)
        return 1

    for path_entry in load_path_entries:
        space.send(
            space.w_load_path,
            "<<",
            [space.newstr_fromstr(path_entry)]
        )
    for required_lib in reqs:
        space.send(
            space.w_kernel,
            "require",
            [space.newstr_fromstr(required_lib)]
        )

    space.set_const(space.w_object, "ARGV", space.newarray(argv_w))
    explicitly_verbose = space.is_true(flag_globals_w["$-v"])
    if explicitly_verbose:
        os.write(1, "%s\n" % description)
    for varname, w_value in flag_globals_w.iteritems():
        space.globals.set(space, varname, w_value)

    if exprs:
        source = "\n".join(exprs)
        path = "-e"
    elif path is not None:
        if search_path:
            for dirname in os.environ["PATH"].split(os.pathsep):
                candidate_path = os.sep.join([dirname, path])
                if os.access(candidate_path, os.R_OK):
                    path = candidate_path
                    break
        try:
            f = open_file_as_stream(path, buffering=0)
        except OSError as e:
            os.write(2, "%s -- %s (LoadError)\n" % (os.strerror(e.errno), path))
            return 1
        try:
            source = f.readall()
        finally:
            f.close()
    elif explicitly_verbose:
        return 0
    else:
        if IS_WINDOWS:
            raise NotImplementedError("executing from stdin on Windows")
        else:
            source = fdopen_as_stream(0, "r").readall()
            path = "-"

    for globalized_switch in globalized_switches:
        value = None
        if "=" in globalized_switch:
            globalized_switch, value = globalized_switch.split("=", 1)

        switch_global_var = "$%s" % globalized_switch[1:].replace("-", "_")
        if value is None:
            space.globals.set(space, switch_global_var, space.w_true)
        else:
            space.globals.set(space, switch_global_var, space.newstr_fromstr(value))

    w_program_name = space.newstr_fromstr(path)
    space.globals.set(space, "$0", w_program_name)
    space.globals.set(space, "$PROGRAM_NAME", w_program_name)
    status = 0
    w_exit_error = None
    explicit_status = False
    jit.set_param(None, "trace_limit", 10000)
    try:
        if do_loop:
            print_after = space.is_true(flag_globals_w["$-p"])
            bc = space.compile(source, path)
            frame = space.create_frame(bc)
            while True:
                w_line = space.send(space.w_kernel, "gets")
                if w_line is space.w_nil:
                    break
                with space.getexecutioncontext().visit_frame(frame):
                    w_res = space.execute_frame(frame, bc)
                    if print_after:
                        space.send(space.w_kernel, "print", [w_res])
        else:
            space.execute(source, filepath=path)
    except RubyError as e:
        explicit_status = True
        w_exc = e.w_value
        if isinstance(w_exc, W_SystemExit):
            status = w_exc.status
        else:
            w_exit_error = w_exc
            status = 1
    exit_handler_status = space.run_exit_handlers()
    if not explicit_status and exit_handler_status != -1:
        status = exit_handler_status
    if w_exit_error is not None:
        print_traceback(space, w_exit_error, path)

    return status

########NEW FILE########
__FILENAME__ = mapdict
from rpython.rlib import jit, longlong2float
from rpython.rlib.objectmodel import specialize
from rpython.rlib.rarithmetic import intmask
from rpython.rlib.unroll import unrolling_iterable
from rpython.rtyper.lltypesystem import rffi, lltype


NUM_DIGITS = 4
NUM_DIGITS_POW2 = 1 << NUM_DIGITS


class MapTransitionCache(object):
    def __init__(self, space):
        # {w_cls: ClassNode}
        self.class_nodes = {}
        # {(prev_node, node_cls, name): BaseNode}
        self.transitions = {}

    @jit.elidable
    def get_class_node(self, w_cls):
        return self.class_nodes.setdefault(w_cls, ClassNode(w_cls))

    @jit.elidable
    def get_transition(self, prev, node_cls, name):
        return self.transitions.setdefault((prev, node_cls, name), node_cls(prev, name))


class BaseNode(object):
    _attrs_ = ["size_estimate"]
    _immutable_fields_ = ["size_estimate"]

    @jit.elidable
    def find(self, node_cls, name=None):
        node = self
        while node is not None:
            if node.matches(node_cls, name):
                return node
            node = node.getprev()

    def matches(self, node_cls, name):
        return isinstance(self, node_cls)

    def add(self, space, node_cls, name, w_obj):
        new_node = space.fromcache(MapTransitionCache).get_transition(self, node_cls, name)
        new_node.update_storage_size(w_obj, self)
        return new_node


class ClassNode(BaseNode):
    _immutable_fields_ = ["w_cls"]

    uses_object_storage = uses_unboxed_storage = False

    def __init__(self, w_cls):
        self.w_cls = w_cls
        self.size_estimate = SizeEstimate(0, 0)

    def getclass(self):
        return self.w_cls

    def change_class(self, space, new_cls):
        return space.fromcache(MapTransitionCache).get_class_node(new_cls)

    def copy_attrs(self, space, w_obj, w_target):
        pass

    def getprev(self):
        return None


class StorageNode(BaseNode):
    _immutable_fields_ = ["prev", "name", "pos"]

    def __init__(self, prev, name):
        self.prev = prev
        self.name = name
        self.pos = self.compute_position()

    def length(self):
        return self.pos + 1

    def getprev(self):
        return self.prev

    def change_class(self, space, w_cls):
        new_prev = self.prev.change_class(space, w_cls)
        return space.fromcache(MapTransitionCache).get_transition(new_prev, self.__class__, self.name)

    def matches(self, node_cls, name):
        return BaseNode.matches(self, node_cls, name) and name == self.name

    def update_storage_size(self, w_obj, prev_node):
        if not jit.we_are_jitted():
            prev_node.size_estimate.update_from(self.size_estimate)


class AttributeNode(StorageNode):
    @staticmethod
    def select_type(space, w_value):
        for cls in ATTRIBUTE_CLASSES:
            if cls.correct_type(space, w_value):
                return cls

    def copy_attrs(self, space, w_obj, w_target):
        self.prev.copy_attrs(space, w_obj, w_target)
        w_target.set_instance_var(space, self.name, self.read(space, w_obj))

    def write(self, space, w_obj, w_value):
        if not self.correct_type(space, w_value):
            w_obj.map = w_obj.map.remove_attr(space, self, w_obj)
            w_obj.map = node = w_obj.map.add(space, AttributeNode.select_type(space, w_value), self.name, w_obj)
            node.write(space, w_obj, w_value)
        else:
            self._store(space, w_obj, w_value)

    def remove_attr(self, space, node, w_obj):
        if node is self:
            return self.prev
        w_cur_val = self.read(space, w_obj)
        new_prev = self.prev.remove_attr(space, node, w_obj)
        node = new_prev.add(space, AttributeNode.select_type(space, w_cur_val), self.name, w_obj)
        node.write(space, w_obj, w_cur_val)
        return node


class UnboxedAttributeNode(AttributeNode):
    uses_object_storage = False
    uses_unboxed_storage = True

    def __init__(self, prev, name):
        AttributeNode.__init__(self, prev, name)
        self.size_estimate = SizeEstimate(
            prev.size_estimate._object_size_estimate,
            self.length() * NUM_DIGITS_POW2
        )

    def compute_position(self):
        return compute_position(self, "uses_unboxed_storage")

    def update_storage_size(self, w_obj, prev_node):
        AttributeNode.update_storage_size(self, w_obj, prev_node)
        update_storage(self, w_obj, "unboxed", 0.0)


class IntAttributeNode(UnboxedAttributeNode):
    @staticmethod
    def correct_type(space, w_value):
        return space.is_kind_of(w_value, space.w_fixnum)

    def _store(self, space, w_obj, w_value):
        w_obj.unboxed_storage[self.pos] = longlong2float.longlong2float(rffi.cast(lltype.SignedLongLong, space.int_w(w_value)))

    def read(self, space, w_obj):
        return space.newint(intmask(longlong2float.float2longlong(w_obj.unboxed_storage[self.pos])))


class FloatAttributeNode(UnboxedAttributeNode):
    @staticmethod
    def correct_type(space, w_value):
        return space.is_kind_of(w_value, space.w_float)

    def _store(self, space, w_obj, w_value):
        w_obj.unboxed_storage[self.pos] = space.float_w(w_value)

    def read(self, space, w_obj):
        return space.newfloat(w_obj.unboxed_storage[self.pos])


class ObjectAttributeNode(AttributeNode):
    uses_object_storage = True
    uses_unboxed_storage = False

    def __init__(self, prev, name):
        AttributeNode.__init__(self, prev, name)
        self.size_estimate = SizeEstimate(
            self.length() * NUM_DIGITS_POW2,
            prev.size_estimate._unboxed_size_estimate,
        )

    @staticmethod
    def correct_type(space, w_value):
        return True

    def compute_position(self):
        return compute_position(self, "uses_object_storage")

    def update_storage_size(self, w_obj, prev_node):
        AttributeNode.update_storage_size(self, w_obj, prev_node)
        update_storage(self, w_obj, "object", None)

    def _store(self, space, w_obj, w_value):
        w_obj.object_storage[self.pos] = w_value

    def read(self, space, w_obj):
        return w_obj.object_storage[self.pos]


class FlagNode(StorageNode):
    uses_object_storage = True
    uses_unboxed_storage = False

    def __init__(self, prev, name):
        StorageNode.__init__(self, prev, name)
        self.size_estimate = SizeEstimate(
            self.length() * NUM_DIGITS_POW2,
            prev.size_estimate._unboxed_size_estimate,
        )

    def compute_position(self):
        return compute_position(self, "uses_object_storage")

    def update_storage_size(self, w_obj, prev_node):
        StorageNode.update_storage_size(self, w_obj, prev_node)
        update_storage(self, w_obj, "object", None)

    def copy_attrs(self, space, w_obj, w_target):
        self.prev.copy_attrs(space, w_obj, w_target)

    def write(self, space, w_obj, w_value):
        w_obj.object_storage[self.pos] = w_value

    def read(self, space, w_obj):
        return w_obj.object_storage[self.pos]


ATTRIBUTE_CLASSES = unrolling_iterable([
    IntAttributeNode,
    FloatAttributeNode,
    ObjectAttributeNode,
])


@specialize.arg(2)
@jit.unroll_safe
def update_storage(node, w_obj, storage_name, empty_value):
    storage = getattr(w_obj, storage_name + "_storage")
    if storage is None or node.length() >= len(storage):
        new_storage = [empty_value] * getattr(node.size_estimate, storage_name + "_size_estimate")()
        if storage is not None:
            for i, value in enumerate(storage):
                new_storage[i] = value
        setattr(w_obj, storage_name + "_storage", new_storage)


@specialize.arg(1)
def compute_position(node, predicate):
    node = node.getprev()
    n = 0
    while node is not None:
        if getattr(node, predicate):
            n += 1
        node = node.getprev()
    return n


class SizeEstimate(object):
    def __init__(self, object_size_estimate, unboxed_size_estimate):
        self._object_size_estimate = object_size_estimate
        self._unboxed_size_estimate = unboxed_size_estimate

    @jit.elidable
    def object_size_estimate(self):
        return self._object_size_estimate >> NUM_DIGITS

    @jit.elidable
    def unboxed_size_estimate(self):
        return self._unboxed_size_estimate >> NUM_DIGITS

    def update_from(self, other):
        self._object_size_estimate = self._object_size_estimate + other.object_size_estimate() - self.object_size_estimate()
        self._unboxed_size_estimate = self._unboxed_size_estimate + other.unboxed_size_estimate() - self.unboxed_size_estimate()

########NEW FILE########
__FILENAME__ = module
import functools

from topaz.gateway import WrapperGenerator
from topaz.utils.cache import Cache


class ClassDef(object):
    def __init__(self, name, superclassdef=None):
        self.name = name
        self.methods = {}
        self.singleton_methods = {}
        self.includes = []
        self.setup_class_func = None
        self.superclassdef = superclassdef
        self.cls = None

    def __repr__(self):
        return "<ClassDef: {}>".format(self.name)

    def __deepcopy__(self, memo):
        return self

    def _freeze_(self):
        return True

    def include_module(self, mod):
        self.includes.append(mod)

    def method(self, __name, **argspec):
        name = __name

        def adder(func):
            self.methods[name] = (func, argspec)
            return func
        return adder

    def singleton_method(self, __name, **argspec):
        name = __name

        def adder(func):
            if isinstance(func, staticmethod):
                func = func.__func__
            self.singleton_methods[name] = (func, argspec)
            return staticmethod(func)
        return adder

    def setup_class(self, func):
        self.setup_class_func = func
        return func

    def undefine_allocator(self):
        @self.singleton_method("allocate")
        def method_allocate(self, space):
            raise space.error(space.w_TypeError, "allocator undefined for %s" % self.name)
        return method_allocate

    def notimplemented(self, name):
        @self.method(name)
        def method(self, space):
            raise space.error(space.w_NotImplementedError)

    def singleton_notimplemented(self, name):
        @self.singleton_method(name)
        def method(self, space):
            raise space.error(space.w_NotImplementedError)


class ModuleDef(object):
    def __init__(self, name):
        self.name = name
        self.methods = {}

        self.singleton_methods = {}
        self.setup_module_func = None

    def __deepcopy__(self, memo):
        return self

    def method(self, __name, **argspec):
        name = __name

        def adder(func):
            self.methods[name] = (func, argspec)
            return func
        return adder

    def function(self, __name, **argspec):
        name = __name

        def adder(func):
            # TODO: should be private, once we have visibility
            self.methods[name] = (func, argspec)
            self.singleton_methods[name] = (func, argspec)
            return func
        return adder

    def setup_module(self, func):
        self.setup_module_func = func
        return func


def check_frozen(param="self"):
    def inner(func):
        code = func.__code__
        space_idx = code.co_varnames.index("space")
        obj_idx = code.co_varnames.index(param)

        @functools.wraps(func)
        def wrapper(*args):
            space = args[space_idx]
            w_obj = args[obj_idx]
            if space.is_true(w_obj.get_flag(space, "frozen?")):
                klass = space.getclass(w_obj)
                raise space.error(space.w_RuntimeError, "can't modify frozen %s" % klass.name)
            return func(*args)
        wrapper.__wraps__ = func
        return wrapper
    return inner


class ClassCache(Cache):
    def _build(self, classdef):
        from topaz.objects.classobject import W_ClassObject
        from topaz.objects.functionobject import W_BuiltinFunction

        assert classdef.cls is not None, classdef.name

        if classdef.superclassdef is None:
            superclass = None
        else:
            superclass = self.space.getclassobject(classdef.superclassdef)

        w_class = self.space.newclass(classdef.name, superclass)
        yield w_class
        for name, (method, argspec) in classdef.methods.iteritems():
            func = WrapperGenerator(name, method, argspec, classdef.cls).generate_wrapper()
            w_class.define_method(self.space, name, W_BuiltinFunction(name, w_class, func))

        for name, (method, argspec) in classdef.singleton_methods.iteritems():
            func = WrapperGenerator(name, method, argspec, W_ClassObject).generate_wrapper()
            w_class.attach_method(self.space, name, W_BuiltinFunction(name, w_class, func))

        for mod in reversed(classdef.includes):
            w_mod = self.space.getmoduleobject(mod.moduledef)
            self.space.send(w_class, "include", [w_mod])

        if classdef.setup_class_func is not None:
            classdef.setup_class_func(classdef.cls, self.space, w_class)


class ModuleCache(Cache):
    def _build(self, moduledef):
        from topaz.objects.functionobject import W_BuiltinFunction
        from topaz.objects.moduleobject import W_ModuleObject
        from topaz.objects.objectobject import W_BaseObject

        w_mod = self.space.newmodule(moduledef.name)
        for name, (method, argspec) in moduledef.methods.iteritems():
            func = WrapperGenerator(name, method, argspec, W_BaseObject).generate_wrapper()
            w_mod.define_method(self.space, name, W_BuiltinFunction(name, w_mod, func))
        for name, (method, argspec) in moduledef.singleton_methods.iteritems():
            func = WrapperGenerator(name, method, argspec, W_ModuleObject).generate_wrapper()
            w_mod.attach_method(self.space, name, W_BuiltinFunction(name, w_mod, func))

        if moduledef.setup_module_func is not None:
            moduledef.setup_module_func(self.space, w_mod)

        yield w_mod

########NEW FILE########
__FILENAME__ = comparable
from __future__ import absolute_import

from topaz.module import ModuleDef


class Comparable(object):
    moduledef = ModuleDef("Comparable")

########NEW FILE########
__FILENAME__ = enumerable
from __future__ import absolute_import

from topaz.module import ModuleDef


class Enumerable(object):
    moduledef = ModuleDef("Enumerable")

########NEW FILE########
__FILENAME__ = kernel
from __future__ import absolute_import

import errno
import os
import time

from rpython.rlib.objectmodel import compute_identity_hash
from rpython.rlib.rfloat import round_double
from rpython.rlib.streamio import open_file_as_stream

from topaz.coerce import Coerce
from topaz.error import RubyError, error_for_oserror, error_for_errno
from topaz.module import ModuleDef, check_frozen
from topaz.modules.process import Process
from topaz.objects.bindingobject import W_BindingObject
from topaz.objects.exceptionobject import W_ExceptionObject
from topaz.objects.functionobject import W_FunctionObject
from topaz.objects.moduleobject import W_ModuleObject
from topaz.objects.procobject import W_ProcObject
from topaz.objects.randomobject import W_RandomObject
from topaz.objects.stringobject import W_StringObject


class Kernel(object):
    moduledef = ModuleDef("Kernel")

    @moduledef.method("class")
    def function_class(self, space):
        return space.getnonsingletonclass(self)

    @moduledef.method("singleton_methods", all="bool")
    def method_singleton_methods(self, space, all=True):
        methods = []
        w_cls = space.getclass(self)
        if w_cls.is_singleton:
            methods.extend(w_cls.methods_w.keys())
            w_cls = w_cls.superclass
        if all:
            while w_cls and w_cls.is_singleton:
                methods.extend(w_cls.methods_w.keys())
                w_cls = w_cls.superclass
        return space.newarray([space.newsymbol(m) for m in methods])

    @moduledef.method("methods", inherit="bool")
    def method_methods(self, space, inherit=True):
        w_cls = space.getclass(self)
        return space.newarray([
            space.newsymbol(m)
            for m in w_cls.methods(space, inherit=inherit)
        ])

    @moduledef.method("private_methods", inherit="bool")
    def method_private_methods(self, space, inherit=True):
        w_cls = space.getclass(self)
        return space.newarray([
            space.newsymbol(m)
            for m in w_cls.methods(space, visibility=W_FunctionObject.PRIVATE, inherit=inherit)
        ])

    @moduledef.method("protected_methods", inherit="bool")
    def method_protected_methods(self, space, inherit=True):
        w_cls = space.getclass(self)
        return space.newarray([
            space.newsymbol(m)
            for m in w_cls.methods(space, visibility=W_FunctionObject.PROTECTED, inherit=inherit)
        ])

    @moduledef.method("public_methods", inherit="bool")
    def method_public_methods(self, space, inherit=True):
        w_cls = space.getclass(self)
        return space.newarray([
            space.newsymbol(m)
            for m in w_cls.methods(space, visibility=W_FunctionObject.PUBLIC, inherit=inherit)
        ])

    @moduledef.method("lambda")
    def function_lambda(self, space, block):
        return block.copy(space, is_lambda=True)

    @moduledef.method("proc")
    def function_proc(self, space, block):
        if block is None:
            raise space.error(space.w_ArgumentError,
                "tried to create Proc object without a block"
            )
        return block.copy(space)

    @staticmethod
    def find_feature(space, path):
        assert path is not None
        if os.path.isfile(path):
            return path
        if not path.endswith(".rb"):
            path += ".rb"

        if not (path.startswith("/") or path.startswith("./") or path.startswith("../")):
            w_load_path = space.globals.get(space, "$LOAD_PATH")
            for w_base in space.listview(w_load_path):
                base = Coerce.path(space, w_base)
                full = os.path.join(base, path)
                if os.path.isfile(full):
                    path = os.path.join(base, path)
                    break
        return path

    @staticmethod
    def load_feature(space, path, orig_path):
        if not os.path.exists(path):
            raise space.error(space.w_LoadError, orig_path)

        try:
            f = open_file_as_stream(path, buffering=0)
            try:
                contents = f.readall()
            finally:
                f.close()
        except OSError as e:
            raise error_for_oserror(space, e)

        space.execute(contents, filepath=path)

    @moduledef.function("require", path="path")
    def function_require(self, space, path):
        assert path is not None
        orig_path = path
        path = Kernel.find_feature(space, path)

        w_loaded_features = space.globals.get(space, '$"')
        w_already_loaded = space.send(
            w_loaded_features, "include?", [space.newstr_fromstr(path)]
        )
        if space.is_true(w_already_loaded):
            return space.w_false

        Kernel.load_feature(space, path, orig_path)
        w_loaded_features.method_lshift(space, space.newstr_fromstr(path))
        return space.w_true

    @moduledef.function("load", path="path")
    def function_load(self, space, path):
        assert path is not None
        orig_path = path
        path = Kernel.find_feature(space, path)
        Kernel.load_feature(space, path, orig_path)
        return space.w_true

    @moduledef.method("fail")
    @moduledef.method("raise")
    def method_raise(self, space, w_str_or_exception=None, w_string=None, w_array=None):
        w_exception = None
        if w_str_or_exception is None:
            w_exception = space.globals.get(space, "$!") or space.w_nil
            if w_exception is space.w_nil:
                w_exception = space.w_RuntimeError
        elif isinstance(w_str_or_exception, W_StringObject):
            w_exception = space.w_RuntimeError
            w_string = w_str_or_exception
        else:
            w_exception = w_str_or_exception

        if not space.respond_to(w_exception, "exception"):
            raise space.error(space.w_TypeError,
                "exception class/object expected"
            )

        if w_string is not None:
            w_exc = space.send(w_exception, "exception", [w_string])
        else:
            w_exc = space.send(w_exception, "exception")

        if w_array is not None:
            raise NotImplementedError("custom backtrace for Kernel#raise")

        if not isinstance(w_exc, W_ExceptionObject):
            raise space.error(space.w_TypeError,
                "exception object expected"
            )

        raise RubyError(w_exc)

    @moduledef.function("exit")
    def method_exit(self, space, args_w):
        return space.send(
            space.getmoduleobject(Process.moduledef), "exit", args_w
        )

    @moduledef.function("exit!")
    def method_exit_bang(self, space, args_w):
        return space.send(
            space.getmoduleobject(Process.moduledef), "exit!", args_w
        )

    @moduledef.function("abort")
    def method_abort(self, space):
        return space.send(self, "exit", [space.w_false])

    @moduledef.function("block_given?")
    @moduledef.function("iterator?")
    def method_block_givenp(self, space):
        return space.newbool(
            space.getexecutioncontext().gettoprubyframe().block is not None
        )

    @moduledef.function("binding")
    def method_binding(self, space):
        return space.newbinding_fromframe(space.getexecutioncontext().gettoprubyframe())

    @moduledef.function("__method__")
    @moduledef.function("__callee__")
    def method_callee(self, space):
        frame = space.getexecutioncontext().gettoprubyframe()
        return space.newsymbol(frame.bytecode.name)

    @moduledef.function("exec")
    def method_exec(self, space, args_w):
        if len(args_w) > 1 and space.respond_to(args_w[0], "to_hash"):
            raise space.error(space.w_NotImplementedError, "exec with environment")

        if len(args_w) > 1 and space.respond_to(args_w[-1], "to_hash"):
            raise space.error(space.w_NotImplementedError, "exec with options")

        if space.respond_to(args_w[0], "to_ary"):
            w_cmd = space.convert_type(args_w[0], space.w_array, "to_ary")
            cmd_w = space.listview(w_cmd)
            if len(cmd_w) != 2:
                raise space.error(space.w_ArgumentError, "wrong first argument")
            cmd, argv0 = [
                space.str0_w(space.convert_type(
                    w_e, space.w_string, "to_str"
                )) for w_e in cmd_w
            ]
        else:
            w_cmd = space.convert_type(args_w[0], space.w_string, "to_str")
            cmd = space.str0_w(w_cmd)
            argv0 = None

        if len(args_w) > 1 or argv0 is not None:
            if argv0 is None:
                sepidx = cmd.rfind(os.sep) + 1
                if sepidx > 0:
                    argv0 = cmd[sepidx:]
                else:
                    argv0 = cmd
            args = [argv0]
            args += [
                space.str0_w(space.convert_type(
                    w_arg, space.w_string, "to_str"
                )) for w_arg in args_w[1:]
            ]
            try:
                os.execv(cmd, args)
            except OSError as e:
                raise error_for_oserror(space, e)
        else:
            if not cmd:
                raise error_for_errno(space, errno.ENOENT)
            shell = os.environ.get("RUBYSHELL") or os.environ.get("COMSPEC") or "/bin/sh"
            sepidx = shell.rfind(os.sep) + 1
            if sepidx > 0:
                argv0 = shell[sepidx:]
            else:
                argv0 = shell
            try:
                os.execv(shell, [argv0, "-c", cmd])
            except OSError as e:
                raise error_for_oserror(space, e)

    @moduledef.function("system")
    def method_system(self, space, args_w):
        raise space.error(space.w_NotImplementedError, "Kernel#system()")

    @moduledef.function("fork")
    def method_fork(self, space, block):
        return space.send(
            space.getmoduleobject(Process.moduledef), "fork", block=block
        )

    @moduledef.function("at_exit")
    def method_at_exit(self, space, block):
        space.register_exit_handler(block)
        return block

    @moduledef.function("=~")
    def method_match(self, space, w_other):
        return space.w_nil

    @moduledef.function("!~")
    def method_not_match(self, space, w_other):
        return space.newbool(not space.is_true(space.send(self, "=~", [w_other])))

    @moduledef.function("eql?")
    def method_eqlp(self, space, w_other):
        return space.newbool(self is w_other)

    @moduledef.function("instance_variable_defined?", name="symbol")
    def method_instance_variable_definedp(self, space, name):
        return space.newbool(self.find_instance_var(space, name) is not None)

    @moduledef.method("respond_to?", include_private="bool")
    def method_respond_top(self, space, w_name, include_private=False):
        if space.respond_to(self, space.symbol_w(w_name)):
            return space.newbool(True)

        w_found = space.send(
            self,
            "respond_to_missing?",
            [w_name, space.newbool(include_private)]
        )
        return space.newbool(space.is_true(w_found))

    @moduledef.method("respond_to_missing?")
    def method_respond_to_missingp(self, space, w_name, w_include_private):
        return space.newbool(False)

    @moduledef.method("dup")
    def method_dup(self, space):
        if (self is space.w_nil or self is space.w_true or
            self is space.w_false or space.is_kind_of(self, space.w_symbol) or
            space.is_kind_of(self, space.w_fixnum)):
            raise space.error(space.w_TypeError, "can't dup %s" % space.getclass(self).name)
        w_dup = space.send(space.getnonsingletonclass(self), "allocate")
        w_dup.copy_instance_vars(space, self)
        space.infect(w_dup, self, freeze=False)
        space.send(w_dup, "initialize_dup", [self])
        return w_dup

    @moduledef.method("clone")
    def method_clone(self, space):
        if (self is space.w_nil or self is space.w_true or
            self is space.w_false or space.is_kind_of(self, space.w_symbol) or
            space.is_kind_of(self, space.w_fixnum)):
            raise space.error(space.w_TypeError, "can't dup %s" % space.getclass(self).name)
        w_dup = space.send(space.getnonsingletonclass(self), "allocate")
        w_dup.copy_instance_vars(space, self)
        w_dup.copy_singletonclass(space, space.getsingletonclass(self))
        space.send(w_dup, "initialize_clone", [self])
        space.infect(w_dup, self, freeze=True)
        return w_dup

    @moduledef.method("sleep")
    def method_sleep(self, space, w_duration=None):
        if w_duration is None:
            raise space.error(space.w_NotImplementedError)
        start = time.time()
        time.sleep(space.float_w(w_duration))
        return space.newint(int(round_double(time.time() - start, 0)))

    @moduledef.method("initialize_clone")
    @moduledef.method("initialize_dup")
    def method_initialize_dup(self, space, w_other):
        space.send(self, "initialize_copy", [w_other])
        return self

    @moduledef.method("initialize_copy")
    def method_initialize_copy(self, space, w_other):
        return self

    @moduledef.function("Float")
    def method_Float(self, space, w_arg):
        if w_arg is space.w_nil:
            raise space.error(space.w_TypeError, "can't convert nil into Float")
        elif space.is_kind_of(w_arg, space.w_float):
            return space.newfloat(space.float_w(w_arg))
        elif space.is_kind_of(w_arg, space.w_string):
            string = space.str_w(w_arg).strip(" ")
            try:
                return space.newfloat(float(string))
            except ValueError:
                raise space.error(space.w_ArgumentError, "invalid value for Float(): %s" % string)
        else:
            return space.convert_type(w_arg, space.w_float, "to_f")

    @moduledef.method("kind_of?")
    @moduledef.method("is_a?")
    def method_is_kind_ofp(self, space, w_mod):
        if not isinstance(w_mod, W_ModuleObject):
            raise space.error(space.w_TypeError, "class or module required")
        return space.newbool(self.is_kind_of(space, w_mod))

    @moduledef.method("instance_of?")
    def method_instance_of(self, space, w_mod):
        if not isinstance(w_mod, W_ModuleObject):
            raise space.error(space.w_TypeError, "class or module required")
        return space.newbool(space.getnonsingletonclass(self) is w_mod)

    @moduledef.method("eval")
    def method_eval(self, space, w_source, w_binding=None):
        if w_binding is None:
            frame = space.getexecutioncontext().gettoprubyframe()
            w_binding = space.newbinding_fromframe(frame)
        elif not isinstance(w_binding, W_BindingObject):
            raise space.error(space.w_TypeError,
                "wrong argument type %s (expected Binding)" % space.getclass(w_binding).name
            )
        return space.send(w_binding, "eval", [w_source])

    @moduledef.method("set_trace_func")
    def method_set_trace_func(self, space, w_proc):
        if w_proc is space.w_nil:
            w_proc = None
        else:
            assert isinstance(w_proc, W_ProcObject)
        space.getexecutioncontext().settraceproc(w_proc)

    def new_flag(moduledef, setter, getter, remover):
        @moduledef.method(setter)
        def setter_method(self, space):
            self.set_flag(space, getter)
            return self

        @moduledef.method(getter)
        def getter_method(self, space):
            return self.get_flag(space, getter)

        if remover is None:
            return (setter_method, getter_method)
        else:
            @moduledef.method(remover)
            def remover_method(self, space):
                self.unset_flag(space, getter)
                return self
            return (setter_method, getter_method, remover_method)
    method_untrust, method_untrusted, method_trust = new_flag(moduledef, "untrust", "untrusted?", "trust")
    method_taint, method_tainted, method_untaint = new_flag(moduledef, "taint", "tainted?", "untaint")
    method_freeze, method_frozen = new_flag(moduledef, "freeze", "frozen?", None)

    @moduledef.method("throw", name="symbol")
    def method_throw(self, space, name, w_value=None):
        from topaz.interpreter import Throw
        if not space.getexecutioncontext().is_in_catch_block_for_name(name):
            raise space.error(space.w_ArgumentError, "uncaught throw :%s" % name)
        if w_value is None:
            w_value = space.w_nil
        raise Throw(name, w_value)

    @moduledef.method("catch", name="symbol")
    def method_catch(self, space, name, block):
        from topaz.interpreter import Throw
        with space.getexecutioncontext().catch_block(name):
            try:
                return space.invoke_block(block, [])
            except Throw as e:
                if e.name == name:
                    return e.w_value
                raise

    @moduledef.method("srand")
    def method_srand(self, space, w_seed=None):
        random_class = space.getclassfor(W_RandomObject)
        default = space.find_const(random_class, "DEFAULT")
        return default.srand(space, w_seed)

    @moduledef.method("object_id")
    def method_object_id(self, space):
        return space.send(self, "__id__")

    @moduledef.method("singleton_class")
    def method_singleton_class(self, space):
        return space.getsingletonclass(self)

    @moduledef.method("extend")
    @check_frozen()
    def method_extend(self, space, w_mod):
        if not space.is_kind_of(w_mod, space.w_module) or space.is_kind_of(w_mod, space.w_class):
            if space.is_kind_of(w_mod, space.w_class):
                name = "Class"
            else:
                name = space.obj_to_s(space.getclass(w_mod))
            raise space.error(
                space.w_TypeError,
                "wrong argument type %s (expected Module)" % name
            )
        space.send(w_mod, "extend_object", [self])
        space.send(w_mod, "extended", [self])

    @moduledef.method("inspect")
    def method_inspect(self, space):
        return space.send(self, "to_s")

    @moduledef.method("to_s")
    def method_to_s(self, space):
        return space.newstr_fromstr(space.any_to_s(self))

    @moduledef.method("===")
    def method_eqeqeq(self, space, w_other):
        if self is w_other:
            return space.w_true
        return space.send(self, "==", [w_other])

    @moduledef.method("send")
    def method_send(self, space, args_w, block):
        return space.send(self, "__send__", args_w, block)

    @moduledef.method("nil?")
    def method_nilp(self, space):
        return space.w_false

    @moduledef.method("hash")
    def method_hash(self, space):
        return space.newint(compute_identity_hash(self))

    @moduledef.method("instance_variable_get", name="str")
    def method_instance_variable_get(self, space, name):
        return space.find_instance_var(self, name)

    @moduledef.method("instance_variable_set", name="str")
    @check_frozen()
    def method_instance_variable_set(self, space, name, w_value):
        space.set_instance_var(self, name, w_value)
        return w_value

    @moduledef.method("method")
    def method_method(self, space, w_sym):
        return space.send(
            space.send(space.getclass(self), "instance_method", [w_sym]),
            "bind",
            [self]
        )

    @moduledef.method("tap")
    def method_tap(self, space, block):
        if block is not None:
            space.invoke_block(block, [self])
        else:
            raise space.error(space.w_LocalJumpError, "no block given")
        return self

    @moduledef.method("define_singleton_method", name="symbol")
    @check_frozen()
    def method_define_singleton_method(self, space, name, w_method=None, block=None):
        args_w = [space.newsymbol(name)]
        if w_method is not None:
            args_w.append(w_method)
        return space.send(space.getsingletonclass(self), "define_method", args_w, block)

########NEW FILE########
__FILENAME__ = math
from __future__ import absolute_import

import math

from rpython.rlib import rfloat

from topaz.module import ModuleDef, ClassDef
from topaz.objects.exceptionobject import W_StandardError, new_exception_allocate


class Math(object):
    moduledef = ModuleDef("Math")

    @moduledef.setup_module
    def setup_module(space, w_mod):
        space.set_const(w_mod, "PI", space.newfloat(math.pi))
        space.set_const(w_mod, "E", space.newfloat(math.e))
        space.set_const(w_mod, "DomainError", space.getclassfor(W_DomainError))

    @moduledef.function("acos", value="float")
    def method_acos(self, space, value):
        return space.newfloat(math.acos(value))

    @moduledef.function("acosh", value="float")
    def method_acosh(self, space, value):
        try:
            res = math.acosh(value)
        except ValueError:
            raise space.error(space.getclassfor(W_DomainError), 'Numerical argument is out of domain - "acosh"')
        return space.newfloat(res)

    @moduledef.function("asin", value="float")
    def method_asin(self, space, value):
        return space.newfloat(math.asin(value))

    @moduledef.function("asinh", value="float")
    def method_asinh(self, space, value):
        return space.newfloat(math.asinh(value))

    @moduledef.function("atan", value="float")
    def method_atan(self, space, value):
        return space.newfloat(math.atan(value))

    @moduledef.function("atan2", value1="float", value2="float")
    def method_atan2(self, space, value1, value2):
        return space.newfloat(math.atan2(value1, value2))

    @moduledef.function("atanh", value="float")
    def method_atanh(self, space, value):
        try:
            res = math.atanh(value)
        except ValueError:
            if value == 1.0 or value == -1.0:
                # produce an infinity with the right sign
                res = rfloat.copysign(rfloat.INFINITY, value)
            else:
                raise space.error(space.getclassfor(W_DomainError), 'Numerical argument is out of domain - "atanh"')
        return space.newfloat(res)

    @moduledef.function("cbrt", value="float")
    def method_cbrt(self, space, value):
        if value < 0:
            return space.newfloat(-math.pow(-value, 1.0 / 3.0))
        else:
            return space.newfloat(math.pow(value, 1.0 / 3.0))

    @moduledef.function("cos", value="float")
    def method_cos(self, space, value):
        return space.newfloat(math.cos(value))

    @moduledef.function("cosh", value="float")
    def method_cosh(self, space, value):
        try:
            res = math.cosh(value)
        except OverflowError:
            res = rfloat.copysign(rfloat.INFINITY, value)
        return space.newfloat(res)

    @moduledef.function("exp", value="float")
    def method_exp(self, space, value):
        return space.newfloat(math.exp(value))

    @moduledef.function("frexp", value="float")
    def method_frexp(self, space, value):
        mant, exp = math.frexp(value)
        w_mant = space.newfloat(mant)
        w_exp = space.newint(exp)
        return space.newarray([w_mant, w_exp])

    @moduledef.function("gamma", value="float")
    def method_gamma(self, space, value):
        try:
            res = rfloat.gamma(value)
        except ValueError:
            if value == 0.0:
                # produce an infinity with the right sign
                res = rfloat.copysign(rfloat.INFINITY, value)
            else:
                raise space.error(space.getclassfor(W_DomainError), 'Numerical argument is out of domain - "gamma"')
        except OverflowError:
            res = rfloat.INFINITY
        return space.newfloat(res)

    @moduledef.function("lgamma", value="float")
    def method_lgamma(self, space, value):
        try:
            res = rfloat.lgamma(value)
        except (ValueError, OverflowError):
            res = rfloat.INFINITY
        gamma = (1 if value == -1 or math.isnan(value) else
                 space.float_w(space.send(self, "gamma", [space.newfloat(value)])))
        sign = 1 if gamma > 0 else -1 if gamma < 0 else 0
        return space.newarray([space.newfloat(res), space.newint(sign)])

    @moduledef.function("hypot", value1="float", value2="float")
    def method_hypot(self, space, value1, value2):
        return space.newfloat(math.hypot(value1, value2))

    @moduledef.function("ldexp", value1="float", value2="int")
    def method_ldexp(self, space, value1, value2):
        return space.newfloat(math.ldexp(value1, value2))

    @moduledef.function("log", value="float", base="float")
    def method_log(self, space, value, base=math.e):
        try:
            res = 0.0
            if base == math.e:
                res = math.log(value)
            else:
                res = math.log(value) / math.log(base)
        except ValueError:
            if value == 0.0:
                res = float(-rfloat.INFINITY)
            else:
                raise space.error(space.getclassfor(W_DomainError), 'Numerical argument is out of domain - "log"')

        return space.newfloat(res)

    @moduledef.function("log10", value="float")
    def method_log10(self, space, value):
        try:
            res = math.log10(value)
        except ValueError:
            if value == 0.0:
                res = float(-rfloat.INFINITY)
            else:
                raise space.error(space.getclassfor(W_DomainError), 'Numerical argument is out of domain - "log10"')

        return space.newfloat(res)

    @moduledef.function("log2", value="float")
    def method_log2(self, space, value):
        try:
            res = math.log(value) / math.log(2)
        except ValueError:
            if value == 0.0:
                res = float(-rfloat.INFINITY)
            else:
                raise space.error(space.getclassfor(W_DomainError), 'Numerical argument is out of domain - "log2"')

        return space.newfloat(res)

    @moduledef.function("sin", value="float")
    def method_sin(self, space, value):
        return space.newfloat(math.sin(value))

    @moduledef.function("sinh", value="float")
    def method_sinh(self, space, value):
        try:
            res = math.sinh(value)
        except OverflowError:
            res = rfloat.copysign(rfloat.INFINITY, value)
        return space.newfloat(res)

    @moduledef.function("sqrt", value="float")
    def method_sqrt(self, space, value):
        return space.newfloat(math.sqrt(value))

    @moduledef.function("tan", value="float")
    def method_tan(self, space, value):
        try:
            res = math.tan(value)
        except ValueError:
            res = rfloat.NAN
        return space.newfloat(res)

    @moduledef.function("tanh", value="float")
    def method_tanh(self, space, value):
        return space.newfloat(math.tanh(value))

    @moduledef.function("erf", value="float")
    def method_erf(self, space, value):
        return space.newfloat(rfloat.erf(value))

    @moduledef.function("erfc", value="float")
    def method_erfc(self, space, value):
        return space.newfloat(rfloat.erfc(value))


class W_DomainError(W_StandardError):
    classdef = ClassDef("Math::DomainError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)

########NEW FILE########
__FILENAME__ = objectspace
from __future__ import absolute_import

from rpython.rlib import rgc, jit

from topaz.module import ModuleDef
from topaz.objects.objectobject import W_BaseObject


def try_cast_gcref_to_w_baseobject(gcref):
    return rgc.try_cast_gcref_to_instance(W_BaseObject, gcref)


def clear_gcflag_extra(pending):
    while pending:
        gcref = pending.pop()
        if rgc.get_gcflag_extra(gcref):
            rgc.toggle_gcflag_extra(gcref)
            pending.extend(rgc.get_rpy_referents(gcref))


class ObjectSpace(object):
    moduledef = ModuleDef("ObjectSpace")

    @moduledef.function("each_object")
    def method_each_object(self, space, w_mod, block):
        if block is None:
            return space.send(self, "enum_for", [space.newsymbol("each_object"), w_mod], block)
        match_w = []
        roots = [gcref for gcref in rgc.get_rpy_roots() if gcref]
        pending = roots[:]
        while pending:
            gcref = pending.pop()
            if not rgc.get_gcflag_extra(gcref):
                rgc.toggle_gcflag_extra(gcref)
                w_obj = try_cast_gcref_to_w_baseobject(gcref)
                if w_obj is not None and space.is_kind_of(w_obj, w_mod):
                    match_w.append(w_obj)
                pending.extend(rgc.get_rpy_referents(gcref))
        clear_gcflag_extra(roots)
        for w_obj in match_w:
            space.invoke_block(block, [w_obj])
        return space.newint(len(match_w))

    @moduledef.function("garbage_collect")
    @jit.dont_look_inside
    def method_garbage_collect(self):
        rgc.collect()

########NEW FILE########
__FILENAME__ = process
from __future__ import absolute_import

import errno
import os

from topaz.gateway import Coerce
from topaz.module import ModuleDef
from topaz.modules.signal import SIGNALS
from topaz.system import IS_WINDOWS
from topaz.error import error_for_oserror


if IS_WINDOWS:
    def geteuid():
        # MRI behaviour on windows
        return 0

    def fork():
        raise NotImplementedError("fork on windows")

    def kill(pid, sig):
        raise NotImplementedError("kill on windows")

    def killpg(pid, sigs):
        raise OSError(errno.EINVAL, "group kill not available on windows")

    def WEXITSTATUS(status):
        return status
else:
    geteuid = os.geteuid
    fork = os.fork
    kill = os.kill
    killpg = os.killpg
    WEXITSTATUS = os.WEXITSTATUS


class Process(object):
    moduledef = ModuleDef("Process")

    @moduledef.function("euid")
    def method_euid(self, space):
        return space.newint(geteuid())

    @moduledef.function("pid")
    def method_pid(self, space):
        return space.newint(os.getpid())

    @moduledef.function("waitpid", pid="int")
    def method_waitpid(self, space, pid=-1):
        try:
            pid, status = os.waitpid(pid, 0)
        except OSError as e:
            raise error_for_oserror(space, e)
        status = WEXITSTATUS(status)
        w_status = space.send(
            space.find_const(self, "Status"),
            "new",
            [space.newint(pid), space.newint(status)]
        )
        space.globals.set(space, "$?", w_status)
        return space.newint(pid)

    @moduledef.function("exit", status="int")
    def method_exit(self, space, status=0):
        raise space.error(space.w_SystemExit, "exit", [space.newint(status)])

    @moduledef.function("exit!", status="int")
    def method_exit_bang(self, space, status=0):
        os._exit(status)

    @moduledef.function("fork")
    def method_fork(self, space, block):
        pid = fork()
        if pid == 0:
            if block is not None:
                space.invoke_block(block, [])
                space.send(self, "exit")
            else:
                return space.w_nil
        else:
            return space.newint(pid)

    @moduledef.function("times")
    def method_times(self, space):
        tms = space.find_const(
            space.find_const(space.w_object, "Struct"),
            "Tms"
        )
        return space.send(
            tms,
            "new",
            [space.newfloat(t) for t in list(os.times()[0:4])]
        )

    @moduledef.function("kill")
    def method_kill(self, space, w_signal, args_w):
        if not args_w:
            raise space.error(space.w_ArgumentError,
                "wrong number of arguments (%d for at least 2)" % (len(args_w) + 1)
            )
        if space.is_kind_of(w_signal, space.w_fixnum):
            sig = space.int_w(w_signal)
        else:
            s = Coerce.str(space, w_signal)
            if s.startswith("SIG"):
                s = s[len("SIG"):]
            try:
                sig = SIGNALS[s]
            except KeyError:
                raise space.error(space.w_ArgumentError,
                    "unsupported name `SIG%s'" % s
                )

        if sig < 0:
            for w_arg in args_w:
                pid = space.int_w(w_arg)
                try:
                    killpg(pid, -sig)
                except OSError as e:
                    raise error_for_oserror(space, e)
        else:
            for w_arg in args_w:
                pid = space.int_w(w_arg)
                try:
                    kill(pid, sig)
                except OSError as e:
                    raise error_for_oserror(space, e)
        return space.newint(len(args_w))

########NEW FILE########
__FILENAME__ = signal
from __future__ import absolute_import

from rpython.rlib import rsignal

from topaz.module import ModuleDef
from topaz.system import IS_WINDOWS


RUBY_SIGNALS = set([
    "SIGHUP", "SIGINT", "SIGQUIT", "SIGILL", "SIGTRAP", "SIGIOT", "SIGABRT",
    "SIGEMT", "SIGFPE", "SIGKILL", "SIGBUS", "SIGSEGV", "SIGSYS", "SIGPIPE",
    "SIGALRM", "SIGTERM", "SIGURG", "SIGSTOP", "SIGTSTP", "SIGCONT", "SIGCHLD",
    "SIGCLD", "SIGCHLD", "SIGTTIN", "SIGTTOU", "SIGIO", "SIGXCPU", "SIGXFSZ",
    "SIGVTALRM", "SIGPROF", "SIGWINCH", "SIGUSR1", "SIGUSR2", "SIGLOST",
    "SIGMSG", "SIGPWR", "SIGPOLL", "SIGDANGER", "SIGMIGRATE", "SIGPRE",
    "SIGGRANT", "SIGRETRACT", "SIGSOUND", "SIGINFO",
])

SIGNALS = dict([
    (k[3:], getattr(rsignal, k))
    for k in rsignal.signal_names
    if k in RUBY_SIGNALS
])
SIGNALS["EXIT"] = 0
if not IS_WINDOWS:
    SIGNALS["CLD"] = SIGNALS["CHLD"]


class Signal(object):
    moduledef = ModuleDef("Signal")

    @moduledef.function("trap")
    def method_trap(self, args_w):
        pass

    @moduledef.function("list")
    def method_list(self, space):
        w_res = space.newhash()
        for sig_name, sig_num in SIGNALS.iteritems():
            space.send(w_res, "[]=", [space.newstr_fromstr(sig_name), space.newint(sig_num)])
        return w_res

########NEW FILE########
__FILENAME__ = topaz
from __future__ import absolute_import
import sys

from rpython.rlib.rarithmetic import intmask

from topaz.module import ModuleDef
from topaz.objects.classobject import W_ClassObject


class Topaz(object):
    moduledef = ModuleDef("Topaz")

    @moduledef.setup_module
    def setup_module(space, w_mod):
        space.set_const(w_mod, "FIXNUM_MAX", space.newint(sys.maxint))

    @moduledef.function("intmask")
    def method_intmask(self, space, w_int):
        if space.is_kind_of(w_int, space.w_fixnum):
            return w_int
        elif space.is_kind_of(w_int, space.w_bignum):
            bigint = space.bigint_w(w_int)
            return space.newint(intmask(bigint.uintmask()))

    @moduledef.function("convert_type", method="symbol")
    def method_convert_type(self, space, w_obj, w_type, method):
        if not isinstance(w_type, W_ClassObject):
            raise space.error(space.w_TypeError, "type argument must be a class")
        return space.convert_type(w_obj, w_type, method)

    @moduledef.function("try_convert_type", method="symbol")
    def method_try_convert_type(self, space, w_obj, w_type, method):
        if not isinstance(w_type, W_ClassObject):
            raise space.error(space.w_TypeError, "type argument must be a class")
        return space.convert_type(w_obj, w_type, method, raise_error=False)

    @moduledef.function("compare")
    def method_compare(self, space, w_a, w_b, block=None):
        return space.compare(w_a, w_b, block)

    @moduledef.function("infect", taint="bool", untrust="bool", freeze="bool")
    def method_infect(self, space, w_dest, w_src, taint=True, untrust=True, freeze=False):
        space.infect(w_dest, w_src, taint=taint, untrust=untrust, freeze=freeze)
        return self

########NEW FILE########
__FILENAME__ = arrayobject
import copy

from rpython.rlib import jit
from rpython.rlib.listsort import make_timsort_class
from rpython.rlib.rbigint import rbigint

from topaz.coerce import Coerce
from topaz.module import ClassDef, check_frozen
from topaz.modules.enumerable import Enumerable
from topaz.objects.objectobject import W_Object
from topaz.utils.packing.pack import RPacker


BaseRubySorter = make_timsort_class()
BaseRubySortBy = make_timsort_class()


class RubySorter(BaseRubySorter):
    def __init__(self, space, list, listlength=None, sortblock=None):
        BaseRubySorter.__init__(self, list, listlength=listlength)
        self.space = space
        self.sortblock = sortblock

    def lt(self, w_a, w_b):
        w_cmp_res = self.space.compare(w_a, w_b, self.sortblock)
        if self.space.is_kind_of(w_cmp_res, self.space.w_bignum):
            return self.space.bigint_w(w_cmp_res).lt(rbigint.fromint(0))
        else:
            return self.space.int_w(w_cmp_res) < 0


class RubySortBy(BaseRubySortBy):
    def __init__(self, space, list, listlength=None, sortblock=None):
        BaseRubySortBy.__init__(self, list, listlength=listlength)
        self.space = space
        self.sortblock = sortblock

    def lt(self, w_a, w_b):
        w_cmp_res = self.space.compare(
            self.space.invoke_block(self.sortblock, [w_a]),
            self.space.invoke_block(self.sortblock, [w_b])
        )
        return self.space.int_w(w_cmp_res) < 0


class W_ArrayObject(W_Object):
    classdef = ClassDef("Array", W_Object.classdef)
    classdef.include_module(Enumerable)

    def __init__(self, space, items_w, klass=None):
        W_Object.__init__(self, space, klass)
        self.items_w = items_w

    def __deepcopy__(self, memo):
        obj = super(W_ArrayObject, self).__deepcopy__(memo)
        obj.items_w = copy.deepcopy(self.items_w, memo)
        return obj

    def listview(self, space):
        return self.items_w

    def length(self):
        return len(self.items_w)

    @classdef.singleton_method("allocate")
    def singleton_method_allocate(self, space):
        return W_ArrayObject(space, [], self)

    @classdef.method("initialize_copy", other_w="array")
    @classdef.method("replace", other_w="array")
    @check_frozen()
    def method_replace(self, space, other_w):
        del self.items_w[:]
        self.items_w.extend(other_w)
        return self

    @classdef.method("[]")
    @classdef.method("slice")
    def method_subscript(self, space, w_idx, w_count=None):
        start, end, as_range, nil = space.subscript_access(self.length(), w_idx, w_count=w_count)
        if nil:
            return space.w_nil
        elif as_range:
            assert start >= 0
            assert end >= 0
            return W_ArrayObject(space, self.items_w[start:end], space.getnonsingletonclass(self))
        else:
            return self.items_w[start]

    @classdef.method("[]=")
    @check_frozen()
    def method_subscript_assign(self, space, w_idx, w_count_or_obj, w_obj=None):
        w_count = None
        if w_obj:
            w_count = w_count_or_obj
        else:
            w_obj = w_count_or_obj
        start, end, as_range, _ = space.subscript_access(self.length(), w_idx, w_count=w_count)

        if w_count and end < start:
            raise space.error(space.w_IndexError,
                "negative length (%d)" % (end - start)
            )
        elif start < 0:
            raise space.error(space.w_IndexError,
                "index %d too small for array; minimum: %d" % (
                    start - self.length(),
                    -self.length()
                )
            )
        elif as_range:
            w_converted = space.convert_type(w_obj, space.w_array, "to_ary", raise_error=False)
            if w_converted is space.w_nil:
                rep_w = [w_obj]
            else:
                rep_w = space.listview(w_converted)
            self._subscript_assign_range(space, start, end, rep_w)
        elif start >= self.length():
            self.items_w += [space.w_nil] * (start - self.length() + 1)
            self.items_w[start] = w_obj
        else:
            self.items_w[start] = w_obj
        return w_obj

    def _subscript_assign_range(self, space, start, end, rep_w):
        assert end >= 0
        delta = (end - start) - len(rep_w)
        if delta < 0:
            self.items_w += [None] * -delta
            lim = start + len(rep_w)
            i = self.length() - 1
            while i >= lim:
                self.items_w[i] = self.items_w[i + delta]
                i -= 1
        elif delta > 0:
            del self.items_w[start:start + delta]
        self.items_w[start:start + len(rep_w)] = rep_w

    @classdef.method("slice!")
    @check_frozen()
    def method_slice_i(self, space, w_idx, w_count=None):
        start, end, as_range, nil = space.subscript_access(self.length(), w_idx, w_count=w_count)

        if nil:
            return space.w_nil
        elif as_range:
            start = min(max(start, 0), self.length())
            end = min(max(end, 0), self.length())
            delta = (end - start)
            assert delta >= 0
            w_items = self.items_w[start:start + delta]
            del self.items_w[start:start + delta]
            return space.newarray(w_items)
        else:
            w_item = self.items_w[start]
            del self.items_w[start]
            return w_item

    @classdef.method("size")
    @classdef.method("length")
    def method_length(self, space):
        return space.newint(self.length())

    @classdef.method("empty?")
    def method_emptyp(self, space):
        return space.newbool(self.length() == 0)

    @classdef.method("+", other="array")
    def method_add(self, space, other):
        return space.newarray(self.items_w + other)

    @classdef.method("<<")
    @check_frozen()
    def method_lshift(self, space, w_obj):
        self.items_w.append(w_obj)
        return self

    @classdef.method("concat", other="array")
    @check_frozen()
    def method_concat(self, space, other):
        self.items_w += other
        return self

    @classdef.method("*")
    def method_times(self, space, w_other):
        if space.respond_to(w_other, "to_str"):
            return space.send(self, "join", [w_other])
        n = space.int_w(space.convert_type(w_other, space.w_fixnum, "to_int"))
        if n < 0:
            raise space.error(space.w_ArgumentError, "Count cannot be negative")
        w_res = W_ArrayObject(space, self.items_w * n, space.getnonsingletonclass(self))
        space.infect(w_res, self, freeze=False)
        return w_res

    @classdef.method("push")
    @check_frozen()
    def method_push(self, space, args_w):
        self.items_w.extend(args_w)
        return self

    @classdef.method("shift")
    @check_frozen()
    def method_shift(self, space, w_n=None):
        if w_n is None:
            if self.items_w:
                return self.items_w.pop(0)
            else:
                return space.w_nil
        n = space.int_w(space.convert_type(w_n, space.w_fixnum, "to_int"))
        if n < 0:
            raise space.error(space.w_ArgumentError, "negative array size")
        items_w = self.items_w[:n]
        del self.items_w[:n]
        return space.newarray(items_w)

    @classdef.method("unshift")
    @check_frozen()
    def method_unshift(self, space, args_w):
        for w_obj in reversed(args_w):
            self.items_w.insert(0, w_obj)
        return self

    @classdef.method("join")
    def method_join(self, space, w_sep=None):
        if not self.items_w:
            return space.newstr_fromstr("")
        if w_sep is None:
            separator = ""
        elif space.respond_to(w_sep, "to_str"):
            separator = space.str_w(space.send(w_sep, "to_str"))
        else:
            raise space.error(space.w_TypeError,
                "can't convert %s into String" % space.getclass(w_sep).name
            )
        return space.newstr_fromstr(separator.join([
            space.str_w(space.send(w_o, "to_s"))
            for w_o in self.items_w
        ]))

    @classdef.method("pop")
    @check_frozen()
    def method_pop(self, space, w_num=None):
        if w_num is None:
            if self.items_w:
                return self.items_w.pop()
            else:
                return space.w_nil
        else:
            num = space.int_w(space.convert_type(
                w_num, space.w_fixnum, "to_int"
            ))
            if num < 0:
                raise space.error(space.w_ArgumentError, "negative array size")
            else:
                pop_size = max(0, self.length() - num)
                res_w = self.items_w[pop_size:]
                del self.items_w[pop_size:]
                return space.newarray(res_w)

    @classdef.method("delete_at", idx="int")
    @check_frozen()
    def method_delete_at(self, space, idx):
        if idx < 0:
            idx += self.length()
        if idx < 0 or idx >= self.length():
            return space.w_nil
        else:
            return self.items_w.pop(idx)

    @classdef.method("last")
    def method_last(self, space, w_count=None):
        if w_count is not None:
            count = Coerce.int(space, w_count)
            if count < 0:
                raise space.error(space.w_ArgumentError, "negative array size")
            start = self.length() - count
            if start < 0:
                start = 0
            return space.newarray(self.items_w[start:])

        if self.length() == 0:
            return space.w_nil
        else:
            return self.items_w[self.length() - 1]

    @classdef.method("pack")
    def method_pack(self, space, w_template):
        template = Coerce.str(space, w_template)
        result = RPacker(template, space.listview(self)).operate(space)
        w_result = space.newstr_fromchars(result)
        space.infect(w_result, w_template)
        return w_result

    @classdef.method("to_ary")
    def method_to_ary(self, space):
        return self

    @classdef.method("clear")
    @check_frozen()
    def method_clear(self, space):
        del self.items_w[:]
        return self

    @classdef.method("sort!")
    @check_frozen()
    def method_sort_i(self, space, block):
        RubySorter(space, self.items_w, sortblock=block).sort()
        return self

    @classdef.method("sort_by!")
    @check_frozen()
    def method_sort_by_i(self, space, block):
        if block is None:
            return space.send(self, "enum_for", [space.newsymbol("sort_by!")])
        RubySortBy(space, self.items_w, sortblock=block).sort()
        return self

    @classdef.method("reverse!")
    @check_frozen()
    def method_reverse_i(self, space):
        self.items_w.reverse()
        return self

    @classdef.method("rotate!", n="int")
    @check_frozen()
    def method_rotate_i(self, space, n=1):
        length = self.length()
        if length == 0:
            return self
        if abs(n) >= length:
            n %= length
        if n < 0:
            n += length
        if n == 0:
            return self
        assert n >= 0
        self.items_w.extend(self.items_w[:n])
        del self.items_w[:n]
        return self

    @classdef.method("insert", i="int")
    @check_frozen()
    @jit.look_inside_iff(lambda self, space, i, args_w: jit.isconstant(len(args_w)))
    def method_insert(self, space, i, args_w):
        if not args_w:
            return self
        length = self.length()
        if i > length:
            self._append_nils(space, i - length)
            self.items_w.extend(args_w)
            return self
        if i < 0:
            if i < -length - 1:
                raise space.error(space.w_IndexError,
                    "index %d too small for array; minimum: %d" % (i + 1, -length)
                )
            i += length + 1
        assert i >= 0
        for w_e in args_w:
            self.items_w.insert(i, w_e)
            i += 1
        return self

    def _append_nils(self, space, num):
        for _ in xrange(num):
            self.items_w.append(space.w_nil)

########NEW FILE########
__FILENAME__ = bignumobject
from rpython.rlib.rbigint import rbigint
from rpython.rlib.rfloat import INFINITY
from rpython.rtyper.lltypesystem import lltype, rffi

from topaz.module import ClassDef
from topaz.objects.integerobject import W_IntegerObject
from topaz.objects.numericobject import W_NumericObject


class W_BignumObject(W_IntegerObject):
    classdef = ClassDef("Bignum", W_IntegerObject.classdef)

    def __init__(self, space, bigint):
        W_IntegerObject.__init__(self, space)
        self.bigint = bigint

    @staticmethod
    def newbigint_fromint(space, intvalue):
        return W_BignumObject(space, rbigint.fromint(intvalue))

    @staticmethod
    def newbigint_fromfloat(space, floatvalue):
        return W_BignumObject(space, rbigint.fromfloat(floatvalue))

    @staticmethod
    def newbigint_fromrbigint(space, bigint):
        return W_BignumObject(space, bigint)

    def int_w(self, space):
        try:
            return self.bigint.toint()
        except OverflowError:
            raise space.error(space.w_RangeError, "bignum too big to convert into `long'")

    def bigint_w(self, space):
        return self.bigint

    def float_w(self, space):
        return self.bigint.tofloat()

    def intmask_w(self, space):
        return rffi.cast(lltype.Signed, self.uintmask_w((space)))

    def uintmask_w(self, space):
        return self.bigint.uintmask()

    def longlongmask_w(self, space):
        return rffi.cast(lltype.SignedLongLong, self.ulonglongmask_w((space)))

    def ulonglongmask_w(self, space):
        return self.bigint.ulonglongmask()

    @classdef.method("to_s")
    def method_to_s(self, space):
        return space.newstr_fromstr(self.bigint.str())

    @classdef.method("to_f")
    def method_to_f(self, space):
        return space.newfloat(self.bigint.tofloat())

    @classdef.method("+", other="bigint")
    def method_plus(self, space, other):
        return space.newbigint_fromrbigint(self.bigint.add(other))

    @classdef.method("-", other="bigint")
    def method_sub(self, space, other):
        return space.newbigint_fromrbigint(self.bigint.sub(other))

    @classdef.method("*", other="bigint")
    def method_times(self, space, other):
        return space.newbigint_fromrbigint(self.bigint.mul(other))

    def floordiv(self, space, other):
        try:
            result = self.bigint.div(other)
        except ZeroDivisionError:
            raise space.error(space.w_ZeroDivisionError, "divided by 0")
        try:
            return space.newint(result.toint())
        except OverflowError:
            return space.newbigint_fromrbigint(result)

    @classdef.method("/")
    def method_divide(self, space, w_other):
        if space.is_kind_of(w_other, space.w_fixnum):
            return self.floordiv(space, rbigint.fromint(space.int_w(w_other)))
        elif space.is_kind_of(w_other, space.w_bignum):
            return self.floordiv(space, space.bigint_w(w_other))
        elif space.is_kind_of(w_other, space.w_float):
            return space.send(space.newfloat(space.float_w(self)), "/", [w_other])
        else:
            return W_NumericObject.retry_binop_coercing(space, self, w_other, "/")

    @classdef.method("fdiv")
    def method_fdiv(self, space, w_other):
        raise space.error(space.w_NotImplementedError, "Bignum#fdiv")

    @classdef.method("<<", other="int")
    def method_left_shift(self, space, other):
        return space.newbigint_fromrbigint(self.bigint.lshift(other))

    @classdef.method("&", other="bigint")
    def method_and(self, space, other):
        return space.newbigint_fromrbigint(self.bigint.and_(other))

    @classdef.method("|", other="bigint")
    def method_or(self, space, other):
        return space.newbigint_fromrbigint(self.bigint.or_(other))

    @classdef.method("^", other="bigint")
    def method_xor(self, space, other):
        return space.newbigint_fromrbigint(self.bigint.xor(other))

    @classdef.method("==", other="bigint")
    def method_eq(self, space, other):
        return space.newbool(self.bigint.eq(other))

    @classdef.method("<=>", other="bigint")
    def method_comparator(self, space, other):
        if self.bigint.gt(other):
            return space.newint(1)
        elif self.bigint.eq(other):
            return space.newint(0)
        elif self.bigint.lt(other):
            return space.newint(-1)

    @classdef.method("hash")
    def method_hash(self, space):
        return space.newint(self.bigint.hash())

    @classdef.method("coerce")
    def method_coerce(self, space, w_other):
        if isinstance(w_other, W_BignumObject):
            return space.newarray([w_other, self])
        elif space.getclass(w_other) is space.w_fixnum:
            return space.newarray([
                space.newbigint_fromint(space.int_w(w_other)),
                self,
            ])
        else:
            raise space.error(space.w_TypeError,
                "can't coerce %s to Bignum" %
                    space.obj_to_s(space.getclass(w_other))
            )

    @classdef.method("**")
    def method_pow(self, space, w_other):
        if space.getclass(w_other) is space.w_fixnum or space.getclass(w_other) is space.w_bignum:
            exp = space.bigint_w(w_other)
            negative_exponent = False
            if exp.sign < 0:
                negative_exponent = True
                exp = exp.abs()
            result = self.bigint.pow(exp, None)
            if negative_exponent:
                return space.newfloat(1.0 / result.tofloat())
            else:
                return space.newbigint_fromrbigint(result)
        elif space.getclass(w_other) is space.w_float:
            try:
                float_value = space.float_w(self)
            except OverflowError:
                return space.newfloat(INFINITY)
            return space.send(
                space.newfloat(float_value),
                "**",
                [w_other]
            )
        else:
            raise space.error(
                space.w_TypeError,
                "%s can't be coerced into Bignum" % (
                    space.obj_to_s(space.getclass(w_other))
                )
            )

    @classdef.method("divmod")
    def method_divmod(self, space, w_other):
        if space.is_kind_of(w_other, space.w_float):
            return space.send(self.method_to_f(space), "divmod", [w_other])
        elif(space.is_kind_of(w_other, space.w_bignum) or
             space.is_kind_of(w_other, space.w_fixnum)):
            other = space.bigint_w(w_other)
            if not other.tobool():
                raise space.error(space.w_ZeroDivisionError, "devided by 0")
            div, mod = self.bigint.divmod(other)
            return space.newarray([space.newbigint_fromrbigint(div),
                                   space.newbigint_fromrbigint(mod)])
        else:
            raise space.error(
                space.w_TypeError,
                "%s can't be coerced into Fixnum" % (
                    space.obj_to_s(space.getclass(w_other))
                )
            )

    @classdef.method("%")
    @classdef.method("modulo")
    def method_mod(self, space, w_other):
        if space.getclass(w_other) is space.w_fixnum:
            return space.newint(
                space.int_w(
                    self.method_mod_bigint_impl(
                        space,
                        space.bigint_w(w_other)
                    )
                )
            )
        elif space.getclass(w_other) is space.w_float:
            return space.send(self.method_to_f(space), "%", [w_other])
        elif space.getclass(w_other) is space.w_bignum:
            return self.method_mod_bigint_impl(space, space.bigint_w(w_other))
        else:
            raise space.error(
                space.w_TypeError,
                "%s can't be coerced into Fixnum" % (
                    space.obj_to_s(space.getclass(w_other))
                )
            )

    def method_mod_bigint_impl(self, space, other):
        if not other.tobool():
            raise space.error(space.w_ZeroDivisionError, "devided by 0")
        return space.newbigint_fromrbigint(self.bigint.mod(other))

########NEW FILE########
__FILENAME__ = bindingobject
from topaz.astcompiler import SymbolTable
from topaz.module import ClassDef
from topaz.objects.objectobject import W_Object


class W_BindingObject(W_Object):
    classdef = ClassDef("Binding", W_Object.classdef)

    def __init__(self, space, names, cells, w_self, lexical_scope):
        W_Object.__init__(self, space)
        self.names = names
        self.cells = cells
        self.w_self = w_self
        self.lexical_scope = lexical_scope

    classdef.undefine_allocator()

    @classdef.method("eval", source="str")
    def method_eval(self, space, source):
        symtable = SymbolTable()
        for name in self.names:
            symtable.cells[name] = symtable.FREEVAR
        bc = space.compile(source, "", symtable=symtable)
        frame = space.create_frame(bc, w_self=self.w_self, lexical_scope=self.lexical_scope)
        for idx, cell in enumerate(self.cells):
            frame.cells[idx + len(bc.cellvars)] = cell
        with space.getexecutioncontext().visit_frame(frame):
            return space.execute_frame(frame, bc)

########NEW FILE########
__FILENAME__ = boolobject
from topaz.module import ClassDef
from topaz.objects.objectobject import W_Object


class W_TrueObject(W_Object):
    classdef = ClassDef("TrueClass", W_Object.classdef)

    def getsingletonclass(self, space):
        return space.getclassfor(W_TrueObject)

    @classdef.method("inspect")
    @classdef.method("to_s")
    def method_to_s(self, space):
        return space.newstr_fromstr("true")

    @classdef.method("==")
    def method_eq(self, space, w_other):
        return space.newbool(self is w_other)

    @classdef.method("&")
    def methof_and(self, space, w_other):
        return space.newbool(space.is_true(w_other))

    @classdef.method("|")
    def method_or(self, space, w_other):
        return space.w_true

    @classdef.method("^")
    def method_xor(self, space, w_other):
        return space.newbool(not space.is_true(w_other))


class W_FalseObject(W_Object):
    classdef = ClassDef("FalseClass", W_Object.classdef)

    def is_true(self, space):
        return False

    def getsingletonclass(self, space):
        return space.getclassfor(W_FalseObject)

    @classdef.method("inspect")
    @classdef.method("to_s")
    def method_to_s(self, space):
        return space.newstr_fromstr("false")

    @classdef.method("==")
    def method_eq(self, space, w_other):
        return space.newbool(self is w_other)

    @classdef.method("&")
    def methof_and(self, space, w_other):
        return space.w_false

    @classdef.method("|")
    def method_or(self, space, w_other):
        return space.newbool(space.is_true(w_other))

    @classdef.method("^")
    def method_xor(self, space, w_other):
        return space.newbool(space.is_true(w_other))

########NEW FILE########
__FILENAME__ = classobject
import copy

from rpython.rlib.objectmodel import specialize

from topaz.module import ClassDef
from topaz.objects.moduleobject import UndefMethod, W_ModuleObject
from topaz.objects.objectobject import W_Object


class W_ClassObject(W_ModuleObject):
    _immutable_fields_ = ["superclass?"]

    classdef = ClassDef("Class", W_ModuleObject.classdef)

    def __init__(self, space, name, superclass, is_singleton=False, attached=None):
        W_ModuleObject.__init__(self, space, name)
        self.superclass = superclass
        self.is_singleton = is_singleton
        self.attached = attached

        if self.superclass is not None:
            self.superclass.inherited(space, self)
            # During bootstrap, we cannot create singleton classes, yet
            if not self.is_singleton and not space.bootstrap:
                self.getsingletonclass(space)

    def __deepcopy__(self, memo):
        obj = super(W_ClassObject, self).__deepcopy__(memo)
        obj.is_singleton = self.is_singleton
        obj.attached = copy.deepcopy(self.attached, memo)
        obj.superclass = copy.deepcopy(self.superclass, memo)
        return obj

    def getsingletonclass(self, space):
        if self.klass is None or not self.klass.is_singleton:
            if self.superclass is None:
                singleton_superclass = space.w_class
            else:
                singleton_superclass = self.superclass.getsingletonclass(space)
            if self.name is None:
                name = None
            else:
                name = "#<Class:%s>" % self.name
            self.klass = space.newclass(
                name, singleton_superclass, is_singleton=True, attached=self
            )
        return self.klass

    def find_const(self, space, name):
        w_res = W_ModuleObject.find_included_const(self, space, name)
        if w_res is None and self.superclass is not None:
            w_res = self.superclass.find_const(space, name)
        return w_res

    def inherited_constants(self, space):
        consts = {}
        for const in W_ModuleObject.local_constants(self, space):
            consts[const] = None
        w_cls = self.superclass
        while w_cls is not None:
            for const in w_cls.local_constants(space):
                consts[const] = None
            w_cls = w_cls.superclass

        return consts.keys()

    def find_method(self, space, name):
        method = W_ModuleObject.find_method(self, space, name)
        if method is None and self.superclass is not None:
            method = self.superclass.find_method(space, name)
        return method

    def find_method_super(self, space, name):
        method = W_ModuleObject.find_method_super(self, space, name)
        if method is None and self.superclass is not None:
            method = self.superclass.find_method(space, name)
        return method

    @specialize.argtype(2)
    def methods(self, space, visibility=None, inherit=True):
        methods = {}
        for name in W_ModuleObject.methods(self, space, inherit=inherit, visibility=visibility):
            methods[name] = None
        if inherit and self.superclass is not None:
            for name in self.superclass.methods(space, visibility=visibility):
                method = self._find_method_pure(space, name, self.version)
                if method is None or not isinstance(method, UndefMethod):
                    methods[name] = None
        return methods.keys()

    def ancestors(self, include_singleton=True, include_self=True):
        assert include_self
        ary = W_ModuleObject.ancestors(self,
            include_singleton, not (self.is_singleton and not include_singleton)
        )
        if self.superclass is not None:
            ary += self.superclass.ancestors(include_singleton)
        return ary

    def inherited(self, space, w_mod):
        self.descendants.append(w_mod)
        if not space.bootstrap and space.respond_to(self, "inherited"):
            space.send(self, "inherited", [w_mod])

    def method_removed(self, space, w_name):
        if self.is_singleton:
            space.send(self.attached, "singleton_method_removed", [w_name])
        else:
            W_ModuleObject.method_removed(self, space, w_name)

    def method_added(self, space, w_name):
        if self.is_singleton:
            space.send(self.attached, "singleton_method_added", [w_name])
        else:
            W_ModuleObject.method_added(self, space, w_name)

    def method_undefined(self, space, w_name):
        if self.is_singleton:
            space.send(self.attached, "singleton_method_undefined", [w_name])
        else:
            W_ModuleObject.method_undefined(self, space, w_name)

    @classdef.singleton_method("allocate")
    def singleton_method_allocate(self, space):
        return space.newclass(None, None)

    @classdef.method("new")
    def method_new(self, space, args_w, block):
        w_obj = space.send(self, "allocate")
        space.send(w_obj, "initialize", args_w, block)
        return w_obj

    @classdef.method("allocate")
    def method_allocate(self, space):
        return W_Object(space, self)

    @classdef.method("initialize")
    def method_initialize(self, space, w_superclass=None, block=None):
        if self.superclass is not None or self is space.w_basicobject:
            raise space.error(space.w_TypeError, "already initialized class")
        if w_superclass is not None:
            if not isinstance(w_superclass, W_ClassObject):
                raise space.error(space.w_TypeError,
                    "superclass must be a Class (%s given)" % space.obj_to_s(space.getclass(w_superclass))
                )
            if w_superclass.is_singleton:
                raise space.error(space.w_TypeError,
                    "can't make subclass of singleton class"
                )
        else:
            w_superclass = space.w_object
        self.superclass = w_superclass
        self.superclass.inherited(space, self)
        self.getsingletonclass(space)
        space.send_super(space.getclassfor(W_ClassObject), self, "initialize", [], block=block)

    @classdef.method("initialize_copy")
    def method_initialize_copy(self, space, w_other):
        if self.superclass is not None or self is space.w_basicobject:
            raise space.error(space.w_TypeError, "already initialized class")
        return space.send_super(space.getclassfor(W_ClassObject), self, "initialize_copy", [w_other])

    @classdef.method("superclass")
    def method_superclass(self, space):
        if self.superclass is not None:
            return self.superclass
        if self is space.w_basicobject:
            return space.w_nil
        raise space.error(space.w_TypeError, "uninitialized class")

    @classdef.method("class_variables")
    def method_class_variables(self, space):
        return space.newarray([space.newsymbol(cvar) for cvar in self.class_variables])

    @classdef.method("instance_variables")
    def method_instance_variables(self, space):
        return space.newarray([space.newsymbol(ivar) for ivar in self.instance_variables])

########NEW FILE########
__FILENAME__ = codeobject
import copy

from topaz.module import ClassDef
from topaz.objects.objectobject import W_BaseObject


class W_CodeObject(W_BaseObject):
    _immutable_fields_ = [
        "code", "consts_w[*]", "max_stackdepth", "cellvars[*]", "freevars[*]",
        "arg_pos[*]", "defaults[*]", "block_arg_pos", "splat_arg_pos",
    ]

    classdef = ClassDef("Code", W_BaseObject.classdef)

    def __init__(self, name, filepath, code, max_stackdepth, consts, args,
                 splat_arg, block_arg, defaults, cellvars, freevars,
                 lineno_table):

        self.name = name
        self.filepath = filepath
        self.code = code
        self.max_stackdepth = max_stackdepth
        self.consts_w = consts
        self.defaults = defaults
        self.cellvars = cellvars
        self.freevars = freevars
        self.lineno_table = lineno_table

        n_args = len(args)
        arg_pos = [-1] * n_args
        for idx, arg in enumerate(args):
            arg_pos[idx] = cellvars.index(arg)
        self.arg_pos = arg_pos

        block_arg_pos = -1
        if block_arg is not None:
            block_arg_pos = cellvars.index(block_arg)
        self.block_arg_pos = block_arg_pos

        splat_arg_pos = -1
        if splat_arg is not None:
            splat_arg_pos = cellvars.index(splat_arg)
        self.splat_arg_pos = splat_arg_pos

    def __deepcopy__(self, memo):
        obj = super(W_CodeObject, self).__deepcopy__(memo)
        obj.name = self.name
        obj.filepath = self.filepath
        obj.code = self.code
        obj.max_stackdepth = self.max_stackdepth
        obj.consts_w = copy.deepcopy(self.consts_w, memo)
        obj.defaults = copy.deepcopy(self.defaults, memo)
        obj.cellvars = self.cellvars
        obj.freevars = self.freevars
        obj.lineno_table = self.lineno_table
        obj.arg_pos = self.arg_pos
        obj.block_arg_pos = self.block_arg_pos
        obj.splat_arg_pos = self.splat_arg_pos
        return obj

    def arity(self, negative_defaults=False):
        args_count = len(self.arg_pos) - len(self.defaults)
        if self.splat_arg_pos != -1 or (negative_defaults and len(self.defaults) > 0):
            args_count = -(args_count + 1)
        return args_count

    @classdef.method("filepath")
    def method_filepath(self, space):
        return space.newstr_fromstr(self.filepath)

########NEW FILE########
__FILENAME__ = dirobject
import os

from topaz.error import error_for_oserror
from topaz.module import ClassDef
from topaz.modules.enumerable import Enumerable
from topaz.objects.objectobject import W_Object
from topaz.objects.regexpobject import RegexpCache
from topaz.utils.glob import Glob
from topaz.utils.ll_dir import opendir, readdir, closedir


class W_DirObject(W_Object):
    classdef = ClassDef("Dir", W_Object.classdef)
    classdef.include_module(Enumerable)

    def __init__(self, space, klass=None):
        W_Object.__init__(self, space, klass)
        self.open = False
        self.path = None

    def __del__(self):
        if self.open:
            closedir(self.dirp)

    def ensure_open(self, space):
        if not self.open:
            raise space.error(space.w_IOError, "closed directory")

    @classdef.method("initialize", path="path")
    def method_initialize(self, space, path):
        self.path = path
        try:
            self.dirp = opendir(path)
        except OSError as e:
            raise error_for_oserror(space, e)
        self.open = True

    @classdef.singleton_method("allocate")
    def method_allocate(self, space):
        return W_DirObject(space)

    @classdef.singleton_method("pwd")
    @classdef.singleton_method("getwd")
    def method_pwd(self, space):
        return space.newstr_fromstr(os.getcwd())

    @classdef.singleton_method("chdir", path="path")
    def method_chdir(self, space, path=None, block=None):
        if path is None:
            path = os.environ["HOME"]
        current_dir = os.getcwd()
        try:
            os.chdir(path)
        except OSError as e:
            raise error_for_oserror(space, e)
        if block is not None:
            try:
                return space.invoke_block(block, [space.newstr_fromstr(path)])
            finally:
                try:
                    os.chdir(current_dir)
                except OSError as e:
                    raise error_for_oserror(space, e)
        else:
            return space.newint(0)

    @classdef.singleton_method("delete", path="path")
    @classdef.singleton_method("rmdir", path="path")
    @classdef.singleton_method("unlink", path="path")
    def method_delete(self, space, path):
        try:
            os.rmdir(path if path else "")
        except OSError as e:
            raise error_for_oserror(space, e)
        return space.newint(0)

    @classdef.singleton_method("[]")
    def method_subscript(self, space, args_w):
        if len(args_w) == 1:
            return space.send(self, "glob", args_w)
        else:
            return space.send(self, "glob", [space.newarray(args_w)])

    @classdef.singleton_method("glob", flags="int")
    def method_glob(self, space, w_pattern, flags=0, block=None):
        if space.is_kind_of(w_pattern, space.w_array):
            patterns_w = space.listview(w_pattern)
        else:
            patterns_w = [w_pattern]

        glob = Glob(space.fromcache(RegexpCache))

        for w_pat in patterns_w:
            w_pat2 = space.convert_type(w_pat, space.w_string, "to_path", raise_error=False)
            if w_pat2 is space.w_nil:
                pattern = space.convert_type(w_pat, space.w_string, "to_str")
            pattern = space.str_w(w_pat2)
            if len(patterns_w) == 1:
                for pat in pattern.split("\0"):
                    glob.glob(pat, flags)
            else:
                glob.glob(pattern.split("\0")[0], flags)

        if block:
            for match in glob.matches():
                space.invoke_block(block, [space.newstr_fromstr(match)])
            return space.w_nil
        else:
            return space.newarray([space.newstr_fromstr(s) for s in glob.matches()])

    @classdef.method("read")
    def method_read(self, space, args_w):
        self.ensure_open(space)
        try:
            filename = readdir(self.dirp)
        except OSError as e:
            raise error_for_oserror(space, e)
        if filename is None:
            return space.w_nil
        else:
            return space.newstr_fromstr(filename)

    @classdef.method("close")
    def method_close(self, space):
        self.ensure_open(space)
        closedir(self.dirp)
        self.open = False
        return space.w_nil

    @classdef.method("path")
    def method_path(self, space):
        return space.newstr_fromstr(self.path)

    @classdef.singleton_method("mkdir", path="path", mode="int")
    def method_mkdir(self, space, path, mode=0777):
        try:
            os.mkdir(path, mode)
        except OSError as e:
            raise error_for_oserror(space, e)
        return space.newint(0)

    @classdef.singleton_method("entries", dirname="path")
    def method_entries(self, space, dirname):
        try:
            return space.newarray([space.newstr_fromstr(d) for d in os.listdir(dirname)])
        except OSError as e:
            raise error_for_oserror(space, e)

########NEW FILE########
__FILENAME__ = encodingobject
from topaz.module import ClassDef
from topaz.objects.objectobject import W_Object


class W_EncodingObject(W_Object):
    classdef = ClassDef("Encoding", W_Object.classdef)

    @classdef.singleton_method("default_external")
    def singleton_method_default_external(self, space):
        return W_EncodingObject(space)

    @classdef.singleton_method("default_internal")
    def singleton_method_default_internal(self, space):
        return W_EncodingObject(space)

    @classdef.singleton_method("default_internal=")
    def singleton_method_set_default_internal(self, space, w_enc):
        pass

    @classdef.singleton_method("default_external=")
    def singleton_method_set_default_external(self, space, w_enc):
        pass

    @classdef.singleton_method("aliases")
    def singleton_method_aliases(self, space):
        return space.newarray([])

    @classdef.singleton_method("name_list")
    def singleton_method_name_list(self, space):
        return space.newarray([])

########NEW FILE########
__FILENAME__ = envobject
import errno
import os

from topaz.error import error_for_errno
from topaz.module import ClassDef
from topaz.coerce import Coerce
from topaz.objects.objectobject import W_Object
from topaz.modules.enumerable import Enumerable


class W_EnvObject(W_Object):
    classdef = ClassDef("EnviromentVariables", W_Object.classdef)
    classdef.include_module(Enumerable)

    @classdef.setup_class
    def setup_class(cls, space, w_cls):
        space.set_const(space.w_object, "ENV", cls(space))

    @classdef.method("class")
    def method_class(self, space):
        return space.w_object

    @classdef.method("[]", key="str")
    def method_subscript(self, space, key):
        if "\0" in key:
            raise space.error(space.w_ArgumentError, "bad environment variable name")
        try:
            val = os.environ[key]
        except KeyError:
            return space.w_nil
        s = space.newstr_fromstr(val)
        space.send(s, "freeze")
        return s

    @classdef.method("store", key="str")
    @classdef.method("[]=", key="str")
    def method_subscript_assign(self, space, key, w_value):
        if "\0" in key:
            raise space.error(space.w_ArgumentError, "bad environment variable name")
        if w_value is space.w_nil:
            try:
                del os.environ[key]
            except (KeyError, OSError):
                pass
            return space.w_nil
        if "=" in key or key == "":
            raise error_for_errno(space, errno.EINVAL)
        value = Coerce.str(space, w_value)
        if "\0" in value:
            raise space.error(space.w_ArgumentError, "bad environment variable value")
        os.environ[key] = value
        return w_value

    @classdef.method("each_pair")
    @classdef.method("each")
    def method_each(self, space, block):
        if block is None:
            return space.send(self, "enum_for", [space.newsymbol("each")])
        for k, v in os.environ.items():
            sk = space.newstr_fromstr(k)
            sv = space.newstr_fromstr(v)
            space.send(sk, "freeze")
            space.send(sv, "freeze")
            space.invoke_block(block, [space.newarray([sk, sv])])
        return self

    @classdef.method("length")
    @classdef.method("size")
    def method_size(self, space):
        return space.newint(len(os.environ.items()))

    @classdef.method("key?", key="str")
    @classdef.method("has_key?", key="str")
    @classdef.method("member?", key="str")
    @classdef.method("include?", key="str")
    def method_includep(self, space, key):
        if "\0" in key:
            raise space.error(space.w_ArgumentError, "bad environment variable name")
        try:
            os.environ[key]
        except KeyError:
            return space.newbool(False)
        return space.newbool(True)

########NEW FILE########
__FILENAME__ = exceptionobject
from topaz.module import ClassDef
from topaz.objects.objectobject import W_Object


def new_exception_allocate(classdef):
    @classdef.singleton_method("allocate")
    def method_allocate(self, space):
        return classdef.cls(space, self)


class W_ExceptionObject(W_Object):
    _attrs_ = ["msg", "frame", "last_instructions", "w_backtrace"]

    classdef = ClassDef("Exception", W_Object.classdef)

    def __init__(self, space, klass=None):
        W_Object.__init__(self, space, klass)
        self.msg = ""
        self.frame = None
        self.w_backtrace = None

    def __str__(self):
        return "%s(%s)" % (self.__class__.__name__, self.msg)

    method_allocate = new_exception_allocate(classdef)

    def copy_instance_vars(self, space, w_other):
        """Copies special instance vars after #copy or #dup"""
        assert isinstance(w_other, W_ExceptionObject)
        W_Object.copy_instance_vars(self, space, w_other)
        self.msg = w_other.msg
        self.frame = w_other.frame
        self.w_backtrace = w_other.w_backtrace

    @classdef.method("initialize")
    def method_initialize(self, space, w_msg=None):
        if w_msg is space.w_nil or w_msg is None:
            msg = space.getclass(self).name
        else:
            msg = space.str_w(space.send(w_msg, "to_s"))
        self.msg = msg

    @classdef.method("to_s")
    def method_to_s(self, space):
        return space.newstr_fromstr(self.msg)

    @classdef.singleton_method("exception")
    def singleton_method_exception(self, space, args_w):
        return space.send(self, "new", args_w)

    @classdef.method("exception")
    def method_exception(self, space, w_string=None):
        if w_string is None:
            return self
        else:
            return space.send(space.getclassfor(self.__class__), "new", [w_string])

    @classdef.method("message")
    def method_message(self, space):
        return space.send(self, "to_s")

    @classdef.method("backtrace")
    def method_backtrace(self, space):
        if self.w_backtrace is not None:
            return self.w_backtrace
        frame = self.frame
        results_w = []
        prev_frame = None
        while frame is not None and frame.has_contents():
            results_w.append(space.newstr_fromstr("%s:%d:in `%s'" % (
                frame.get_filename(),
                frame.get_lineno(prev_frame),
                frame.get_code_name(),
            )))
            prev_frame = frame
            frame = frame.backref()
        return space.newarray(results_w)

    @classdef.method("set_backtrace")
    def method_set_backtrace(self, space, w_backtrace):
        if w_backtrace is space.w_nil:
            self.w_backtrace = w_backtrace
            return w_backtrace
        if space.is_kind_of(w_backtrace, space.w_array):
            for w_obj in space.listview(w_backtrace):
                if not space.is_kind_of(w_obj, space.w_string):
                    raise space.error(space.w_TypeError, "backtrace must be Array of String")
            self.w_backtrace = w_backtrace
            return w_backtrace
        if space.is_kind_of(w_backtrace, space.w_string):
            self.w_backtrace = space.newarray([w_backtrace])
            return self.w_backtrace
        raise space.error(space.w_TypeError, "backtrace must be Array of String")

    @classdef.method("==")
    def method_eq(self, space, w_other):
        if not isinstance(w_other, W_ExceptionObject):
            return space.w_false
        if self is w_other:
            return space.w_true

        w_msg = space.send(self, "message")
        w_backtrace = space.send(self, "backtrace")
        return space.newbool(
            space.is_true(space.send(w_msg, "==", [space.send(w_other, "message")])) and
            space.is_true(space.send(w_backtrace, "==", [space.send(w_other, "backtrace")]))
        )


class W_ScriptError(W_ExceptionObject):
    classdef = ClassDef("ScriptError", W_ExceptionObject.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_LoadError(W_ScriptError):
    classdef = ClassDef("LoadError", W_ScriptError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_StandardError(W_ExceptionObject):
    classdef = ClassDef("StandardError", W_ExceptionObject.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_SystemStackError(W_ExceptionObject):
    classdef = ClassDef("SystemStackError", W_ExceptionObject.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_SystemExit(W_ExceptionObject):
    classdef = ClassDef("SystemExit", W_ExceptionObject.classdef)

    def __init__(self, space, klass=None):
        W_ExceptionObject.__init__(self, space, klass)
        self.status = 0

    method_allocate = new_exception_allocate(classdef)

    @classdef.method("initialize", status="int")
    def method_initialize(self, space, w_msg=None, status=0):
        W_ExceptionObject.method_initialize(self, space, w_msg)
        self.status = status

    @classdef.method("success?")
    def method_successp(self, space):
        return space.newbool(self.status == 0)

    @classdef.method("status")
    def method_status(self, space):
        return space.newint(self.status)


class W_TypeError(W_ExceptionObject):
    classdef = ClassDef("TypeError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_NameError(W_StandardError):
    classdef = ClassDef("NameError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_NoMethodError(W_NameError):
    classdef = ClassDef("NoMethodError", W_NameError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_ZeroDivisionError(W_StandardError):
    classdef = ClassDef("ZeroDivisionError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_SyntaxError(W_ScriptError):
    classdef = ClassDef("SyntaxError", W_ScriptError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_NotImplementedError(W_ScriptError):
    classdef = ClassDef("NotImplementedError", W_ScriptError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_ArgumentError(W_StandardError):
    classdef = ClassDef("ArgumentError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_RangeError(W_StandardError):
    classdef = ClassDef("RangeError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_FloatDomainError(W_RangeError):
    classdef = ClassDef("FloatDomainError", W_RangeError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_RuntimeError(W_StandardError):
    classdef = ClassDef("RuntimeError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_SystemCallError(W_StandardError):
    classdef = ClassDef("SystemCallError", W_StandardError.classdef)

    def __init__(self, space, klass=None):
        W_ExceptionObject.__init__(self, space, klass)
        self.errno = 0

    method_allocate = new_exception_allocate(classdef)

    @classdef.method("initialize", errno="int")
    def method_initialize(self, space, w_msg=None, errno=0):
        W_StandardError.method_initialize(self, space, w_msg)
        self.errno = errno

    @classdef.method("errno")
    def method_status(self, space):
        return space.newint(self.errno)


class W_IndexError(W_StandardError):
    classdef = ClassDef("IndexError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_KeyError(W_IndexError):
    classdef = ClassDef("KeyError", W_IndexError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_StopIteration(W_IndexError):
    classdef = ClassDef("StopIteration", W_IndexError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_LocalJumpError(W_StandardError):
    classdef = ClassDef("LocalJumpError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_IOError(W_StandardError):
    classdef = ClassDef("IOError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_EOFError(W_IOError):
    classdef = ClassDef("EOFError", W_IOError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_RegexpError(W_StandardError):
    classdef = ClassDef("RegexpError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_ThreadError(W_StandardError):
    classdef = ClassDef("ThreadError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)


class W_FiberError(W_StandardError):
    classdef = ClassDef("FiberError", W_StandardError.classdef)
    method_allocate = new_exception_allocate(classdef)

########NEW FILE########
__FILENAME__ = fiberobject
import copy

from rpython.rlib import jit
from rpython.rlib.rstacklet import StackletThread

from topaz.interpreter import RaiseReturn, RaiseBreak
from topaz.module import ClassDef
from topaz.objects.objectobject import W_Object


class State(object):
    def __init__(self, space):
        self.current = None

    def get_current(self, space):
        return self.current or space.getexecutioncontext().getmainfiber(space)


class W_FiberObject(W_Object):
    """
    Fibers have a number of possible states:

    * Has not yet begun execution: self.sthread is None
    * Currently execution: self.sthread is not None and self is State.get_current()
    * Suspended execution: self.sthread is not None and self.parent_fiber is None
    * Suspended execution in the stack of fibers: self.sthread is not None and (self.parent_fiber is None or self is space.w_main_fiber)
    * Dead: self.sthread is not None and self.sthread.is_empty_handle(self.h)
    """
    classdef = ClassDef("Fiber", W_Object.classdef)

    def __init__(self, space, klass=None):
        W_Object.__init__(self, space, klass)
        self.w_block = None
        self.sthread = None
        self.parent_fiber = None

    def __deepcopy__(self, memo):
        obj = super(W_FiberObject, self).__deepcopy__(memo)
        obj.w_block = copy.deepcopy(self.w_block, memo)
        obj.sthread = copy.deepcopy(self.sthread, memo)
        obj.parent_fiber = copy.deepcopy(self.parent_fiber, memo)
        return obj

    @staticmethod
    def build_main_fiber(space, ec):
        w_fiber = W_FiberObject(space)
        w_fiber.sthread = W_FiberObject.get_sthread(space, ec)
        return w_fiber

    @staticmethod
    def get_sthread(space, ec):
        sthread = ec.fiber_thread
        if not sthread:
            sthread = ec.fiber_thread = SThread(space.config, ec)
        return sthread

    @classdef.singleton_method("allocate")
    def singleton_method_allocate(self, space):
        return W_FiberObject(space, self)

    @classdef.singleton_method("yield")
    def singleton_method_yield(self, space, args_w):
        current = space.fromcache(State).get_current(space)
        parent_fiber = current.parent_fiber
        if parent_fiber is None:
            raise space.error(space.w_FiberError, "can't yield from root fiber")
        space.fromcache(State).current = parent_fiber

        topframeref = space.getexecutioncontext().topframeref
        current.bottomframe.backref = jit.vref_None
        if len(args_w) == 0:
            global_state.w_result = space.w_nil
        elif len(args_w) == 1:
            global_state.w_result = args_w[0]
        else:
            global_state.w_result = space.newarray(args_w)
        parent_fiber.h = space.getexecutioncontext().fiber_thread.switch(parent_fiber.h)
        assert space.fromcache(State).current is current
        current.bottomframe.backref = space.getexecutioncontext().topframeref
        space.getexecutioncontext().topframeref = topframeref

        return get_result()

    @classdef.method("initialize")
    @jit.unroll_safe
    def method_initialize(self, space, block):
        if block is None:
            raise space.error(space.w_ArgumentError)
        self.w_block = block
        self.bottomframe = space.create_frame(
            self.w_block.bytecode, w_self=self.w_block.w_self,
            lexical_scope=self.w_block.lexical_scope, block=self.w_block.block,
            parent_interp=self.w_block.parent_interp,
            top_parent_interp=self.w_block.top_parent_interp,
            regexp_match_cell=self.w_block.regexp_match_cell,
        )
        for idx, cell in enumerate(self.w_block.cells):
            self.bottomframe.cells[len(self.w_block.bytecode.cellvars) + idx] = cell

    @classdef.method("resume")
    def method_resume(self, space, args_w):
        if self.parent_fiber is not None:
            raise space.error(space.w_FiberError, "double resume")
        if self.sthread is not None and self.sthread.is_empty_handle(self.h):
            raise space.error(space.w_FiberError, "dead fiber called")

        self.parent_fiber = space.fromcache(State).get_current(space)
        try:
            global_state.space = space
            global_state.space.fromcache(State).current = self
            topframeref = space.getexecutioncontext().topframeref
            if self.sthread is None:
                self.bottomframe.handle_block_args(space, self.w_block.bytecode, args_w, self.w_block)
                sthread = self.get_sthread(space, space.getexecutioncontext())
                self.sthread = sthread
                self.h = sthread.new(new_stacklet_callback)
            else:
                if len(args_w) == 1:
                    global_state.w_result = args_w[0]
                else:
                    global_state.w_result = space.newarray(args_w)
                self.h = self.sthread.switch(self.h)
            assert space.fromcache(State).current is self.parent_fiber
            space.getexecutioncontext().topframeref = topframeref
            return get_result()
        finally:
            self.parent_fiber = None


class SThread(StackletThread):
    def __init__(self, config, ec):
        StackletThread.__init__(self, config)
        self.config = config
        self.ec = ec

    def __deepcopy__(self, memo):
        return SThread(self.config, copy.deepcopy(self.ec, memo))


class GlobalState(object):
    def __init__(self):
        self.clear()

    def clear(self):
        self.w_result = None
        self.propagate_exception = None
        self.space = None
# This makes me sad.
global_state = GlobalState()


def new_stacklet_callback(h, arg):
    space = global_state.space
    self = space.fromcache(State).current
    origin = self.parent_fiber
    origin.h = h
    global_state.clear()

    with self.sthread.ec.visit_frame(self.bottomframe):
        try:
            try:
                global_state.w_result = space.execute_frame(self.bottomframe, self.w_block.bytecode)
            except RaiseReturn:
                raise space.error(space.w_LocalJumpError, "unexpected return")
            except RaiseBreak:
                raise space.error(space.w_LocalJumpError, "break from proc-closure")
        except Exception as e:
            global_state.propagate_exception = e

    space.fromcache(State).current = self.parent_fiber
    global_state.space = space
    return origin.h


def get_result():
    if global_state.propagate_exception:
        e = global_state.propagate_exception
        global_state.propagate_exception = None
        raise e
    else:
        w_result = global_state.w_result
        global_state.w_result = None
        return w_result

########NEW FILE########
__FILENAME__ = fileobject
import os
import stat

from topaz.coerce import Coerce
from topaz.error import error_for_oserror
from topaz.module import ClassDef
from topaz.objects.arrayobject import W_ArrayObject
from topaz.objects.hashobject import W_HashObject
from topaz.objects.objectobject import W_Object
from topaz.objects.ioobject import W_IOObject
from topaz.objects.timeobject import W_TimeObject
from topaz.system import IS_WINDOWS
from topaz.utils.ll_file import O_BINARY, ftruncate, isdir, fchmod
from topaz.utils.filemode import map_filemode


FNM_NOESCAPE = 0x01
FNM_PATHNAME = 0x02
FNM_DOTMATCH = 0x04


class W_FileObject(W_IOObject):
    classdef = ClassDef("File", W_IOObject.classdef)

    @classdef.setup_class
    def setup_class(cls, space, w_cls):
        if IS_WINDOWS:
            w_alt_seperator = space.newstr_fromstr("\\")
            w_fnm_syscase = space.newint(0x08)
            w_devnull = space.newstr_fromstr("NUL")
        else:
            w_alt_seperator = space.w_nil
            w_fnm_syscase = space.newint(0)
            w_devnull = space.newstr_fromstr("/dev/null")
        space.set_const(w_cls, "SEPARATOR", space.newstr_fromstr("/"))
        space.set_const(w_cls, "ALT_SEPARATOR", w_alt_seperator)
        space.set_const(w_cls, "PATH_SEPARATOR", space.newstr_fromstr(os.pathsep))
        space.set_const(w_cls, "NULL", w_devnull)
        space.set_const(w_cls, "FNM_SYSCASE", w_fnm_syscase)
        space.set_const(w_cls, "FNM_NOESCAPE", space.newint(FNM_NOESCAPE))
        space.set_const(w_cls, "FNM_PATHNAME", space.newint(FNM_PATHNAME))
        space.set_const(w_cls, "FNM_DOTMATCH", space.newint(FNM_DOTMATCH))
        space.set_const(w_cls, "BINARY", space.newint(O_BINARY))
        space.set_const(w_cls, "RDONLY", space.newint(os.O_RDONLY))
        space.set_const(w_cls, "WRONLY", space.newint(os.O_WRONLY))
        space.set_const(w_cls, "RDWR", space.newint(os.O_RDWR))
        space.set_const(w_cls, "APPEND", space.newint(os.O_APPEND))
        space.set_const(w_cls, "CREAT", space.newint(os.O_CREAT))
        space.set_const(w_cls, "EXCL", space.newint(os.O_EXCL))
        space.set_const(w_cls, "TRUNC", space.newint(os.O_TRUNC))

        space.set_const(w_cls, "Stat", space.getclassfor(W_FileStatObject))

    @classdef.singleton_method("allocate")
    def method_allocate(self, space):
        return W_FileObject(space)

    @classdef.singleton_method("size?", name="path")
    def singleton_method_size_p(self, space, name):
        try:
            stat_val = os.stat(name)
        except OSError:
            return space.w_nil
        return space.w_nil if stat_val.st_size == 0 else space.newint_or_bigint(stat_val.st_size)

    @classdef.singleton_method("unlink")
    @classdef.singleton_method("delete")
    def singleton_method_delete(self, space, args_w):
        for w_path in args_w:
            path = Coerce.path(space, w_path)
            try:
                os.unlink(path)
            except OSError as e:
                raise error_for_oserror(space, e)
        return space.newint(len(args_w))

    @classdef.method("initialize", filename="path")
    def method_initialize(self, space, filename, w_mode=None, w_perm_or_opt=None, w_opt=None):
        if w_mode is None:
            w_mode = space.w_nil
        if w_perm_or_opt is None:
            w_perm_or_opt = space.w_nil
        if w_opt is None:
            w_opt = space.w_nil
        if isinstance(w_perm_or_opt, W_HashObject):
            assert w_opt is space.w_nil
            perm = 0665
            w_opt = w_perm_or_opt
        elif w_opt is not space.w_nil:
            perm = space.int_w(w_perm_or_opt)
        else:
            perm = 0665
        mode, encoding = map_filemode(space, w_mode)
        if w_perm_or_opt is not space.w_nil or w_opt is not space.w_nil:
            raise space.error(space.w_NotImplementedError, "options hash or permissions for File.new")
        try:
            self.fd = os.open(filename, mode, perm)
        except OSError as e:
            raise error_for_oserror(space, e)
        self.filename = filename
        return self

    @classdef.singleton_method("dirname", path="path")
    def method_dirname(self, space, path):
        separators = ["/"]
        if IS_WINDOWS:
            separators.append("\\")

        has_separator = False
        for separator in separators:
            if separator in path:
                has_separator = True
                break
        if not has_separator:
            return space.newstr_fromstr(".")

        if path in separators:
            return space.newstr_fromstr("/")

        while path and path[-1] in separators:
            newlen = len(path) - 1
            assert newlen >= 0
            path = path[:newlen]

        idx = -1
        for separator in separators:
            idx = max(idx, path.rfind(separator))
        while idx > 0 and path[idx - 1] in separators:
            idx -= 1
        if idx <= 0:
            return space.newstr_fromstr("/")
        assert idx >= 0
        return space.newstr_fromstr(path[:idx])

    @classdef.singleton_method("expand_path", path="path")
    def method_expand_path(self, space, path, w_dir=None):
        if path and path[0] == "~":
            try:
                home = os.environ["HOME"]
            except KeyError:
                raise space.error(space.w_ArgumentError, "couldn't find HOME environment -- expanding")
            if not home or (not IS_WINDOWS and home[0] != "/"):
                raise space.error(space.w_ArgumentError, "non-absolute home")
            if len(path) >= 2 and path[1] == "/":
                path = home + path[1:]
            elif len(path) < 2:
                return space.newstr_fromstr(home)
            else:
                raise space.error(space.w_NotImplementedError, "~user for File.expand_path")
        elif not path or path[0] != "/":
            if w_dir is not None and w_dir is not space.w_nil:
                dir = space.str_w(space.send(self, "expand_path", [w_dir]))
            else:
                dir = os.getcwd()

            path = dir + "/" + path

        items = []
        if IS_WINDOWS:
            path = path.replace("\\", "/")
        parts = path.split("/")
        was_letter = False
        first_slash = True
        for part in parts:
            if not part and not was_letter:
                if not first_slash:
                    items.append(part)
                first_slash = False
            elif part == "..":
                if len(items) > 0:
                    items.pop()
            elif part and part != ".":
                was_letter = True
                items.append(part)
        if not IS_WINDOWS:
            root = "/"
        else:
            root = ""
        return space.newstr_fromstr(root + "/".join(items))

    @classdef.singleton_method("join")
    def singleton_method_join(self, space, args_w):
        sep = space.str_w(space.find_const(self, "SEPARATOR"))
        result = []
        for w_arg in args_w:
            if isinstance(w_arg, W_ArrayObject):
                ec = space.getexecutioncontext()
                with ec.recursion_guard("file_singleton_method_join", w_arg) as in_recursion:
                    if in_recursion:
                        raise space.error(space.w_ArgumentError, "recursive array")
                    string = space.str_w(
                        space.send(space.getclassfor(W_FileObject), "join", space.listview(w_arg))
                    )
            else:
                w_string = space.convert_type(w_arg, space.w_string, "to_path", raise_error=False)
                if w_string is space.w_nil:
                    w_string = space.convert_type(w_arg, space.w_string, "to_str")
                string = space.str_w(w_string)

            if string == "" and len(args_w) > 1:
                if (not result) or result[-1] != sep:
                    result += sep
            if string.startswith(sep):
                while result and result[-1] == sep:
                    result.pop()
            elif result and not result[-1] == sep:
                result += sep
            result += string
        return space.newstr_fromchars(result)

    @classdef.singleton_method("exists?", filename="path")
    @classdef.singleton_method("exist?", filename="path")
    def method_existp(self, space, filename):
        return space.newbool(os.path.exists(filename))

    @classdef.singleton_method("file?", filename="path")
    def method_filep(self, space, filename):
        return space.newbool(os.path.isfile(filename))

    @classdef.singleton_method("directory?", filename="path")
    def method_directoryp(self, space, filename):
        return space.newbool(isdir(filename))

    @classdef.singleton_method("symlink?", filename="path")
    def method_symlinkp(self, space, filename):
        return space.newbool(os.path.islink(filename))

    @classdef.singleton_method("executable?", filename="path")
    def method_executablep(self, space, filename):
        return space.newbool(os.path.isfile(filename) and os.access(filename, os.X_OK))

    @classdef.singleton_method("identical?", file="path", other="path")
    def method_identicalp(self, space, file, other):
        try:
            file_stat = os.stat(file)
            other_stat = os.stat(other)
        except OSError:
            return space.w_false
        return space.newbool(file_stat.st_dev == other_stat.st_dev and
                file_stat.st_ino == other_stat.st_ino)

    @classdef.singleton_method("basename", filename="path", suffix="path")
    def method_basename(self, space, filename, suffix=None):
        i = filename.rfind("/") + 1
        assert i >= 0
        filename = filename[i:]
        if suffix is not None and filename.endswith(suffix):
            end = len(filename) - len(suffix)
            assert end >= 0
            filename = filename[:end]
        return space.newstr_fromstr(filename)

    @classdef.singleton_method("umask", mask="int")
    def method_umask(self, space, mask=-1):
        if mask >= 0:
            return space.newint(os.umask(mask))
        else:
            current_umask = os.umask(0)
            os.umask(current_umask)
            return space.newint(current_umask)

    @classdef.method("truncate", length="int")
    def method_truncate(self, space, length):
        self.ensure_not_closed(space)
        try:
            ftruncate(self.fd, length)
        except OSError as e:
            raise error_for_oserror(space, e)
        return space.newint(0)

    @classdef.singleton_method("path", path="path")
    def singleton_method_path(self, space, path):
        w_str = space.newstr_fromstr(path)
        space.send(w_str, "freeze")
        return w_str

    @classdef.method("path")
    def method_path(self, space):
        return space.newstr_fromstr(self.filename)

    @classdef.method("mtime")
    def method_mtime(self, space):
        try:
            stat_val = os.stat(self.filename)
        except OSError as e:
            raise error_for_oserror(space, e)
        return self._time_at(space, stat_val.st_mtime)

    @classdef.method("atime")
    def method_atime(self, space):
        try:
            stat_val = os.stat(self.filename)
        except OSError as e:
            raise error_for_oserror(space, e)
        return self._time_at(space, stat_val.st_atime)

    @classdef.method("ctime")
    def method_ctime(self, space):
        try:
            stat_val = os.stat(self.filename)
        except OSError as e:
            raise error_for_oserror(space, e)
        return self._time_at(space, stat_val.st_ctime)

    def _time_at(self, space, time):
        return space.send(
            space.getclassfor(W_TimeObject), "at", [space.newint(int(time))]
        )

    @classdef.method("chmod", mode="int")
    def method_chmod(self, space, mode):
        try:
            fchmod(self.fd, mode)
        except OSError as e:
            raise error_for_oserror(space, e)
        return space.newint(0)

    @classdef.singleton_method("chmod", mode="int")
    def singleton_method_chmod(self, space, mode, args_w):
        for arg_w in args_w:
            path = Coerce.path(space, arg_w)
            try:
                os.chmod(path, mode)
            except OSError as e:
                raise error_for_oserror(space, e)
        return space.newint(len(args_w))

    @classdef.singleton_method("stat", filename="path")
    def singleton_method_stat(self, space, filename):
        try:
            stat_val = os.stat(filename)
        except OSError as e:
            raise error_for_oserror(space, e)
        stat_obj = W_FileStatObject(space)
        stat_obj.set_stat(stat_val)
        return stat_obj

    @classdef.singleton_method("lstat", filename="path")
    def singleton_method_lstat(self, space, filename):
        try:
            stat_val = os.lstat(filename)
        except OSError as e:
            raise error_for_oserror(space, e)
        stat_obj = W_FileStatObject(space)
        stat_obj.set_stat(stat_val)
        return stat_obj

    if IS_WINDOWS:
        classdef.singleton_notimplemented("symlink")
        classdef.singleton_notimplemented("link")
    else:
        @classdef.singleton_method("symlink", old_name="path", new_name="path")
        def singleton_method_symlink(self, space, old_name, new_name):
            try:
                os.symlink(old_name, new_name)
            except OSError as e:
                raise error_for_oserror(space, e)
            return space.newint(0)

        @classdef.singleton_method("link", old_name="path", new_name="path")
        def singleton_method_link(self, space, old_name, new_name):
            try:
                os.link(old_name, new_name)
            except OSError as e:
                raise error_for_oserror(space, e)
            return space.newint(0)


class W_FileStatObject(W_Object):
    classdef = ClassDef("Stat", W_Object.classdef)

    def __init__(self, space):
        W_Object.__init__(self, space)
        self.is_initialized = False

    def set_stat(self, stat):
        self._stat = stat
        self.is_initialized = True

    def get_stat(self, space):
        if not self.is_initialized:
            raise space.error(space.w_RuntimeError, "uninitialized File::Stat")
        return self._stat

    @classdef.singleton_method("allocate")
    def singleton_method_allocate(self, space):
        return W_FileStatObject(space)

    @classdef.method("initialize", filename="path")
    def method_initialize(self, space, filename):
        try:
            self.set_stat(os.stat(filename))
        except OSError as e:
            raise error_for_oserror(space, e)

    @classdef.method("blockdev?")
    def method_blockdevp(self, space):
        return space.newbool(stat.S_ISBLK(self.get_stat(space).st_mode))

    if IS_WINDOWS:
        def unsupported_attr(name, classdef):
            @classdef.method(name)
            def method(self, space):
                return space.w_nil
            method.__name__ = name
            return method
        method_blksize = unsupported_attr("blksize", classdef)
        method_blocks = unsupported_attr("blocks", classdef)
        method_rdev = unsupported_attr("rdev", classdef)
    else:
        @classdef.method("blksize")
        def method_blksize(self, space):
            return space.newint(self.get_stat(space).st_blksize)

        @classdef.method("rdev")
        def method_rdev(self, space):
            return space.newint(self.get_stat(space).st_rdev)

        @classdef.method("blocks")
        def method_blocks(self, space):
            return space.newint(self.get_stat(space).st_blocks)

    @classdef.method("chardev?")
    def method_chardevp(self, space):
        return space.newbool(stat.S_ISCHR(self.get_stat(space).st_mode))

    @classdef.method("dev")
    def method_dev(self, space):
        return space.newint_or_bigint(self.get_stat(space).st_dev)

    @classdef.method("directory?")
    def method_directoryp(self, space):
        return space.newbool(stat.S_ISDIR(self.get_stat(space).st_mode))

    @classdef.method("file?")
    def method_filep(self, space):
        return space.newbool(stat.S_ISREG(self.get_stat(space).st_mode))

    @classdef.method("ftype")
    def method_ftype(self, space):
        stat_val = self.get_stat(space)
        if stat.S_ISREG(stat_val.st_mode):
            return space.newstr_fromstr("file")
        elif stat.S_ISDIR(stat_val.st_mode):
            return space.newstr_fromstr("directory")
        elif stat.S_ISCHR(stat_val.st_mode):
            return space.newstr_fromstr("characterSpecial")
        elif stat.S_ISBLK(stat_val.st_mode):
            return space.newstr_fromstr("blockSpecial")
        elif stat.S_ISFIFO(stat_val.st_mode):
            return space.newstr_fromstr("fifo")
        elif stat.S_ISLNK(stat_val.st_mode):
            return space.newstr_fromstr("link")
        elif stat.S_ISSOCK(stat_val.st_mode):
            return space.newstr_fromstr("socket")
        else:
            return space.newstr_fromstr("unknown")

    @classdef.method("gid")
    def method_gid(self, space):
        return space.newint(self.get_stat(space).st_gid)

    @classdef.method("ino")
    def method_ino(self, space):
        return space.newint_or_bigint(self.get_stat(space).st_ino)

    def get_w_mode(self, space):
        return space.newint(self.get_stat(space).st_mode)

    @classdef.method("mode")
    def method_mode(self, space):
        return self.get_w_mode(space)

    @classdef.method("nlink")
    def method_nlink(self, space):
        return space.newint(self.get_stat(space).st_nlink)

    @classdef.method("setgid?")
    def method_setgidp(self, space):
        return space.newbool(bool(stat.S_IMODE(self.get_stat(space).st_mode) & stat.S_ISGID))

    @classdef.method("setuid?")
    def method_setuidp(self, space):
        return space.newbool(bool(stat.S_IMODE(self.get_stat(space).st_mode) & stat.S_ISUID))

    @classdef.method("size")
    def method_size(self, space):
        return space.newint_or_bigint(self.get_stat(space).st_size)

    @classdef.method("socket?")
    def method_socketp(self, space):
        return space.newbool(stat.S_ISSOCK(self.get_stat(space).st_mode))

    @classdef.method("sticky?")
    def method_stickyp(self, space):
        return space.newbool(bool(stat.S_IMODE(self.get_stat(space).st_mode) & stat.S_ISVTX))

    @classdef.method("symlink?")
    def method_symlinkp(self, space):
        return space.newbool(stat.S_ISLNK(self.get_stat(space).st_mode))

    @classdef.method("uid")
    def method_uid(self, space):
        return space.newint(self.get_stat(space).st_uid)

    @classdef.method("world_readable?")
    def method_world_readablep(self, space):
        if stat.S_IMODE(self.get_stat(space).st_mode) & stat.S_IROTH:
            return self.get_w_mode(space)
        return space.w_nil

    @classdef.method("world_writable?")
    def method_world_writablep(self, space):
        if stat.S_IMODE(self.get_stat(space).st_mode) & stat.S_IWOTH:
            return self.get_w_mode(space)
        return space.w_nil

########NEW FILE########
__FILENAME__ = floatobject
import operator
import math
import sys

from rpython.rlib.objectmodel import compute_hash
from rpython.rlib.rarithmetic import ovfcheck_float_to_int
from rpython.rlib.rbigint import rbigint
from rpython.rlib.rfloat import (formatd, DTSF_ADD_DOT_0, DTSF_STR_PRECISION,
    NAN, INFINITY, isfinite, round_away)

from topaz.error import RubyError
from topaz.module import ClassDef
from topaz.objects.exceptionobject import W_ArgumentError
from topaz.objects.objectobject import W_RootObject
from topaz.objects.numericobject import W_NumericObject


class W_FloatObject(W_RootObject):
    _immutable_fields_ = ["floatvalue"]

    classdef = ClassDef("Float", W_NumericObject.classdef)

    def __init__(self, space, floatvalue):
        self.floatvalue = floatvalue

    def __deepcopy__(self, memo):
        obj = super(W_FloatObject, self).__deepcopy__(memo)
        obj.floatvalue = self.floatvalue
        return obj

    def float_w(self, space):
        return self.floatvalue

    def bigint_w(self, space):
        return rbigint.fromfloat(self.floatvalue)

    @staticmethod
    def float_to_w_int(space, floatvalue):
        try:
            # the extra case makes sure that this method returns
            # bignums for the same numbers as the parser does.
            # this is checked in rubyspecs
            if floatvalue < 0:
                return space.newint(-ovfcheck_float_to_int(-floatvalue))
            else:
                return space.newint(ovfcheck_float_to_int(floatvalue))
        except OverflowError:
            return space.newbigint_fromfloat(floatvalue)

    @classdef.setup_class
    def setup_class(cls, space, w_cls):
        space.set_const(w_cls, "MAX", space.newfloat(sys.float_info.max))
        space.set_const(w_cls, "MIN", space.newfloat(sys.float_info.min))
        space.set_const(w_cls, "INFINITY", space.newfloat(INFINITY))
        space.set_const(w_cls, "NAN", space.newfloat(NAN))
        space.set_const(w_cls, "DIG", space.newint(sys.float_info.dig))
        space.set_const(w_cls, "EPSILON", space.newfloat(sys.float_info.epsilon))
        space.set_const(w_cls, "MANT_DIG", space.newint(sys.float_info.mant_dig))
        space.set_const(w_cls, "MAX_10_EXP", space.newint(sys.float_info.max_10_exp))
        space.set_const(w_cls, "MIN_10_EXP", space.newint(sys.float_info.min_10_exp))
        space.set_const(w_cls, "MAX_EXP", space.newint(sys.float_info.max_exp))
        space.set_const(w_cls, "MIN_EXP", space.newint(sys.float_info.min_exp))
        space.set_const(w_cls, "RADIX", space.newint(sys.float_info.radix))

    @classdef.method("inspect")
    @classdef.method("to_s")
    def method_to_s(self, space):
        if math.isinf(self.floatvalue):
            if self.floatvalue >= 0:
                return space.newstr_fromstr("Infinity")
            else:
                return space.newstr_fromstr("-Infinity")
        elif math.isnan(self.floatvalue):
            return space.newstr_fromstr("NaN")
        else:
            return space.newstr_fromstr(formatd(self.floatvalue, "g", DTSF_STR_PRECISION, DTSF_ADD_DOT_0))

    @classdef.method("to_f")
    def method_to_f(self, space):
        return self

    @classdef.method("to_i")
    def method_to_i(self, space):
        if math.isnan(self.floatvalue) or math.isinf(self.floatvalue):
            raise space.error(
                space.w_FloatDomainError,
                space.str_w(space.send(self, "to_s"))
            )
        return self.float_to_w_int(space, self.floatvalue)

    @classdef.method("+", other="float")
    def method_add(self, space, other):
        return space.newfloat(self.floatvalue + other)

    @classdef.method("-", other="float")
    def method_sub(self, space, other):
        return space.newfloat(self.floatvalue - other)

    @classdef.method("*", other="float")
    def method_mul(self, space, other):
        return space.newfloat(self.floatvalue * other)

    @classdef.method("/", other="float")
    def method_div(self, space, other):
        if other == 0.0:
            if self.floatvalue == 0.0:
                return space.newfloat(NAN)
            else:
                inf = math.copysign(INFINITY, other)
                if self.floatvalue < 0.0:
                    return space.newfloat(-inf)
                else:
                    return space.newfloat(inf)
        else:
            return space.newfloat(self.floatvalue / other)

    def new_bool_op(classdef, name, func):
        @classdef.method(name)
        def method(self, space, w_other):
            if space.is_kind_of(w_other, space.w_float):
                return space.newbool(func(self.floatvalue, space.float_w(w_other)))
            else:
                return W_NumericObject.retry_binop_coercing(space, self, w_other, name)
        method.__name__ = "method_%s" % func.__name__
        return method
    method_lt = new_bool_op(classdef, "<", operator.lt)
    method_lte = new_bool_op(classdef, "<=", operator.le)
    method_gt = new_bool_op(classdef, ">", operator.gt)
    method_gte = new_bool_op(classdef, ">=", operator.ge)

    @classdef.method("==")
    def method_eq(self, space, w_other):
        if space.is_kind_of(w_other, space.w_float):
            return space.newbool(self.floatvalue == space.float_w(w_other))

        try:
            return W_NumericObject.retry_binop_coercing(space, self, w_other, "==")
        except RubyError as e:
            if isinstance(e.w_value, W_ArgumentError):
                return space.send(w_other, "==", [self])
            else:
                raise

    @classdef.method("equal?")
    def method_equalp(self, space, w_other):
        if space.is_kind_of(w_other, space.w_float):
            other = space.float_w(w_other)
            return space.newbool(
                self.floatvalue == other or
                (math.isnan(self.floatvalue) and math.isnan(other))
            )

        try:
            return W_NumericObject.retry_binop_coercing(space, self, w_other, "equal?")
        except RubyError as e:
            if isinstance(e.w_value, W_ArgumentError):
                return space.send(w_other, "equal?", [self])
            else:
                raise

    @classdef.method("<=>")
    def method_comparator(self, space, w_other):
        if space.is_kind_of(w_other, space.w_numeric):
            other = space.float_w(w_other)
            if self.floatvalue < other:
                return space.newint(-1)
            elif self.floatvalue == other:
                return space.newint(0)
            elif self.floatvalue > other:
                return space.newint(1)
            return space.newint(1)
        else:
            return space.w_nil

    @classdef.method("hash")
    def method_hash(self, space):
        return space.newint(compute_hash(self.floatvalue))

    @classdef.method("coerce")
    def method_coerce(self, space, w_other):
        if space.getclass(w_other) is space.getclass(self):
            return space.newarray([w_other, self])
        else:
            return space.newarray([space.send(self, "Float", [w_other]), self])

    @classdef.method("abs")
    def method_abs(self, space):
        return space.newfloat(abs(self.floatvalue))

    @classdef.method("**")
    def method_pow(self, space, w_other):
        if space.is_kind_of(w_other, space.w_numeric):
            x = self.floatvalue
            y = space.float_w(w_other)
            negate_result = False

            if y == 2.0:
                return space.newfloat(x * x)
            elif y == 0.0:
                return space.newfloat(1.0)
            elif math.isnan(x):
                return space.newfloat(x)
            elif math.isnan(y):
                if x == 1.0:
                    return space.newfloat(1.0)
                elif x < 0.0:
                    raise NotImplementedError("Complex numbers as results")
                else:
                    return space.newfloat(y)
            elif math.isinf(y):
                if x == 1.0 or x == -1.0:
                    return space.newfloat(x)
                elif x < -1.0 or x > 1.0:
                    return space.newfloat(INFINITY if y > 0.0 else 0.0)
                else:
                    return space.newfloat(0.0 if y > 0.0 else INFINITY)
            elif x == 0.0 and y < 0.0:
                return space.newfloat(INFINITY)

            if x < 0.0:
                x = -x
                negate_result = math.fmod(abs(y), 2.0) == 1.0

            if math.isinf(x):
                if y > 0.0:
                    return space.newfloat(-INFINITY if negate_result else INFINITY)
                else:
                    return space.newfloat(-0.0 if negate_result else 0.0)
            elif x == 1.0:
                return space.newfloat(-1.0 if negate_result else 1.0)
            else:
                try:
                    # OverflowError raised in math.pow, but not overflow.pow
                    z = math.pow(x, y)
                except OverflowError:
                    return space.newfloat(-INFINITY if negate_result else INFINITY)
                except ValueError:
                    return space.newfloat(NAN)
                return space.newfloat(-z if negate_result else z)
        else:
            raise space.error(
                space.w_TypeError,
                "%s can't be coerced into Float" % space.getclass(w_other).name
            )

    @classdef.method("floor")
    def method_floor(self, space):
        return self.float_to_w_int(space, math.floor(self.floatvalue))

    @classdef.method("ceil")
    def method_ceil(self, space):
        return self.float_to_w_int(space, math.ceil(self.floatvalue))

    @classdef.method("infinite?")
    def method_infinity(self, space):
        if math.isinf(self.floatvalue):
            return space.newint(int(math.copysign(1, self.floatvalue)))
        return space.w_nil

    @classdef.method("finite?")
    def method_finite(self, space):
        return space.newbool(isfinite(self.floatvalue))

    @classdef.method("nan?")
    def method_nan(self, space):
        return space.newbool(math.isnan(self.floatvalue))

    @classdef.method("round")
    def method_round(self, space):
        return space.newint(int(round_away(self.floatvalue)))

    @classdef.method("quo")
    def method_quo(self, space):
        raise space.error(space.w_NotImplementedError, "Numeric#quo")

    @classdef.method("divmod")
    def method_divmod(self, space, w_other):
        if math.isnan(self.floatvalue) or math.isinf(self.floatvalue):
            raise space.error(
                space.w_FloatDomainError,
                space.obj_to_s(space.getclass(w_other))
            )
        if (space.is_kind_of(w_other, space.w_fixnum) or
            space.is_kind_of(w_other, space.w_bignum) or
            space.is_kind_of(w_other, space.w_float)):
            y = space.float_w(w_other)
            if math.isnan(y):
                raise space.error(
                    space.w_FloatDomainError,
                    space.obj_to_s(space.getclass(w_other))
                )
            x = self.floatvalue
            mod = space.float_w(self.method_mod_float_impl(space, y))
            # TAKEN FROM: pypy/module/cpytext/floatobject.py
            div = (x - mod) / y
            if (mod):
                # ensure the remainder has the same sign as the denominator
                if ((y < 0.0) != (mod < 0.0)):
                    mod += y
                    div -= 1.0
            else:
                mod *= mod  # hide "mod = +0" from optimizer
                if y < 0.0:
                    mod = -mod
            # snap quotient to nearest integral value
            if div:
                floordiv = math.floor(div)
                if (div - floordiv > 0.5):
                    floordiv += 1.0
            else:
                # div is zero - get the same sign as the true quotient
                div *= div  # hide "div = +0" from optimizers
                floordiv = div * x / y  # zero w/ sign of vx/wx
            try:
                return space.newarray([self.float_to_w_int(space, round_away(div)), space.newfloat(mod)])
            except OverflowError:
                return space.newarray([space.newbigint_fromfloat(div), space.newfloat(mod)])
        else:
            raise space.error(
                space.w_TypeError,
                "%s can't be coerced into Float" % (
                    space.obj_to_s(space.getclass(w_other))
                )
            )

    @classdef.method("%")
    @classdef.method("modulo")
    def method_mod(self, space, w_other):
        if (space.is_kind_of(w_other, space.w_fixnum) or
            space.is_kind_of(w_other, space.w_bignum) or
            space.is_kind_of(w_other, space.w_float)):
            return self.method_mod_float_impl(space, space.float_w(w_other))
        else:
            raise space.error(
                space.w_TypeError,
                "%s can't be coerced into Float" % (
                    space.obj_to_s(space.getclass(w_other))
                )
            )

    def method_mod_float_impl(self, space, other):
        if other == 0.0:
            raise space.error(space.w_ZeroDivisionError, "devided by 0")
        elif self.floatvalue == -0.0:
            return space.newfloat(-0.0)
        elif math.isinf(other) and other < 0.0:
            return space.newfloat(other)
        elif math.isnan(self.floatvalue) or math.isinf(self.floatvalue):
            return space.newfloat(NAN)
        return space.newfloat(math.fmod(self.floatvalue, other))

########NEW FILE########
__FILENAME__ = functionobject
import copy

from topaz.objects.objectobject import W_BaseObject


class W_FunctionObject(W_BaseObject):
    _immutable_fields_ = ["name", "w_class", "visibility?"]

    PUBLIC = 0
    PROTECTED = 1
    PRIVATE = 2
    MODULE_FUNCTION = 3

    def __init__(self, name, w_class=None, visibility=PUBLIC):
        self.name = name
        self.w_class = w_class
        self.visibility = visibility

    def __deepcopy__(self, memo):
        obj = super(W_FunctionObject, self).__deepcopy__(memo)
        obj.name = self.name
        obj.w_class = copy.deepcopy(self.w_class, memo)
        obj.visibility = copy.deepcopy(self.visibility, memo)
        return obj

    def update_visibility(self, visibility):
        self.visibility = visibility

    def arity(self, space):
        return space.newint(0)


class W_UserFunction(W_FunctionObject):
    _immutable_fields_ = ["bytecode", "lexical_scope"]

    def __init__(self, name, bytecode, lexical_scope, visibility=W_FunctionObject.PUBLIC):
        W_FunctionObject.__init__(self, name, visibility=visibility)
        self.bytecode = bytecode
        self.lexical_scope = lexical_scope

    def __deepcopy__(self, memo):
        obj = super(W_UserFunction, self).__deepcopy__(memo)
        obj.bytecode = copy.deepcopy(self.bytecode, memo)
        obj.lexical_scope = copy.deepcopy(self.lexical_scope, memo)
        return obj

    def call(self, space, w_receiver, args_w, block):
        frame = space.create_frame(
            self.bytecode,
            w_self=w_receiver,
            lexical_scope=self.lexical_scope,
            block=block,
        )
        with space.getexecutioncontext().visit_frame(frame):
            frame.handle_args(space, self.bytecode, args_w, block)
            return space.execute_frame(frame, self.bytecode)

    def arity(self, space):
        return space.newint(self.bytecode.arity(negative_defaults=True))


class W_BuiltinFunction(W_FunctionObject):
    _immutable_fields_ = ["func"]

    def __init__(self, name, w_class, func, visibility=W_FunctionObject.PUBLIC):
        W_FunctionObject.__init__(self, name, w_class, visibility=visibility)
        self.func = func

    def __deepcopy__(self, memo):
        obj = super(W_BuiltinFunction, self).__deepcopy__(memo)
        obj.func = self.func
        return obj

    def call(self, space, w_receiver, args_w, block):
        from topaz.frame import BuiltinFrame

        frame = BuiltinFrame(self.name)
        ec = space.getexecutioncontext()
        ec.invoke_trace_proc(space, "c-call", self.name, self.w_class.name)
        with ec.visit_frame(frame):
            w_res = self.func(w_receiver, space, args_w, block)
        ec.invoke_trace_proc(space, "c-return", self.name, self.w_class.name)
        return w_res

########NEW FILE########
__FILENAME__ = hashobject
from rpython.rlib.rerased import new_static_erasing_pair

from topaz.module import ClassDef, check_frozen
from topaz.modules.enumerable import Enumerable
from topaz.objects.objectobject import W_Object
from topaz.utils.ordereddict import OrderedDict
from topaz.objects.procobject import W_ProcObject


class BaseDictStrategy(object):
    def __init__(self, space):
        pass


class TypedDictStrategyMixin(object):
    _mixin_ = True

    def getitem(self, storage, w_key):
        return self.wrap(self.unerase(storage)[w_key])

    def setitem(self, storage, w_key, w_value):
        self.unerase(storage)[self.unwrap(w_key)] = w_value

    def contains(self, storage, w_key):
        return self.unwrap(w_key) in self.unerase(storage)

    def copy(self, storage):
        return self.erase(self.unerase(storage).copy())

    def clear(self, storage):
        self.unerase(storage).clear()

    def len(self, storage):
        return len(self.unerase(storage))

    def bool(self, storage):
        return bool(self.unerase(storage))

    def pop(self, storage, w_key, default):
        return self.unerase(storage).pop(self.unwrap(w_key), default)

    def popitem(self, storage):
        key, value = self.unerase(storage).popitem()
        return self.wrap(key), value

    def keys(self, storage):
        return [self.wrap(k) for k in self.unerase(storage).keys()]

    def values(self, storage):
        return self.unerase(storage).values()

    def iteritems(self, storage):
        return self.iter_erase(self.unerase(storage).iteritems())

    def iternext(self, storage):
        key, value = self.iter_unerase(storage).next()
        return self.wrap(key), value


class ObjectDictStrategy(BaseDictStrategy, TypedDictStrategyMixin):
    erase, unerase = new_static_erasing_pair("ObjectDictStrategy")
    iter_erase, iter_unerase = new_static_erasing_pair("ObjectDictStrategyIterator")

    def get_empty_storage(self, space):
        return self.erase(OrderedDict(space.eq_w, space.hash_w))

    def wrap(self, w_key):
        return w_key

    def unwrap(self, w_key):
        return w_key


class IdentityDictStrategy(BaseDictStrategy, TypedDictStrategyMixin):
    erase, unerase = new_static_erasing_pair("IdentityDictStrategy")
    iter_erase, iter_unerase = new_static_erasing_pair("IdentityDictStrategyIterator")

    def get_empty_storage(self, space):
        return self.erase(OrderedDict())

    def wrap(self, w_key):
        return w_key

    def unwrap(self, w_key):
        return w_key


class W_HashObject(W_Object):
    classdef = ClassDef("Hash", W_Object.classdef)
    classdef.include_module(Enumerable)

    def __init__(self, space, klass=None):
        W_Object.__init__(self, space, klass)
        self.strategy = space.fromcache(ObjectDictStrategy)
        self.dict_storage = self.strategy.get_empty_storage(space)
        self.w_default = space.w_nil
        self.default_proc = None

    @classdef.singleton_method("allocate")
    def method_allocate(self, space):
        return W_HashObject(space, self)

    @classdef.method("initialize")
    @check_frozen()
    def method_initialize(self, space, w_default=None, block=None):
        if w_default is not None:
            if block is not None:
                raise space.error(space.w_ArgumentError, "wrong number of arguments")
            self.w_default = w_default
        if block is not None:
            self.default_proc = block
        return self

    @classdef.method("default")
    def method_default(self, space, w_key=None):
        if self.default_proc is not None and w_key is not None:
            return space.invoke_block(self.default_proc, [self, w_key])
        else:
            return self.w_default

    @classdef.method("default=")
    @check_frozen()
    def method_set_default(self, space, w_defl):
        self.default_proc = None
        self.w_default = w_defl

    @classdef.method("default_proc")
    def method_default_proc(self, space):
        if self.default_proc is None:
            return space.w_nil
        return self.default_proc

    @classdef.method("default_proc=")
    def method_set_default_proc(self, space, w_proc):
        w_new_proc = space.convert_type(w_proc, space.w_proc, "to_proc")
        assert isinstance(w_new_proc, W_ProcObject)
        arity = space.int_w(space.send(w_new_proc, "arity"))
        if arity != 2 and space.is_true(space.send(w_new_proc, "lambda?")):
            raise space.error(space.w_TypeError, "default_proc takes two arguments (2 for %s)" % arity)
        self.default_proc = w_new_proc
        self.w_default = space.w_nil
        return w_proc

    @classdef.method("compare_by_identity")
    @check_frozen()
    def method_compare_by_identity(self, space):
        strategy = space.fromcache(IdentityDictStrategy)
        storage = strategy.get_empty_storage(space)

        iter = self.strategy.iteritems(self.dict_storage)
        while True:
            try:
                w_key, w_value = self.strategy.iternext(iter)
            except StopIteration:
                break
            strategy.setitem(storage, w_key, w_value)
        self.strategy = strategy
        self.dict_storage = storage
        return self

    @classdef.method("compare_by_identity?")
    def method_compare_by_identityp(self, space):
        return space.newbool(self.strategy is space.fromcache(IdentityDictStrategy))

    @classdef.method("rehash")
    @check_frozen()
    def method_rehash(self, space):
        storage = self.strategy.get_empty_storage(space)

        iter = self.strategy.iteritems(self.dict_storage)
        while True:
            try:
                w_key, w_value = self.strategy.iternext(iter)
            except StopIteration:
                break
            self.strategy.setitem(storage, w_key, w_value)
        self.dict_storage = storage
        return self

    @classdef.method("[]")
    def method_subscript(self, space, w_key):
        try:
            return self.strategy.getitem(self.dict_storage, w_key)
        except KeyError:
            return space.send(self, "default", [w_key])

    @classdef.method("fetch")
    def method_fetch(self, space, w_key, w_value=None, block=None):
        try:
            return self.strategy.getitem(self.dict_storage, w_key)
        except KeyError:
            if block is not None:
                return space.invoke_block(block, [w_key])
            elif w_value is not None:
                return w_value
            else:
                raise space.error(space.w_KeyError, "key not found: %s" % space.send(w_key, "inspect"))

    @classdef.method("store")
    @classdef.method("[]=")
    @check_frozen()
    def method_subscript_assign(self, space, w_key, w_value):
        if (space.is_kind_of(w_key, space.w_string) and
            not space.is_true(space.send(w_key, "frozen?"))):

            w_key = space.send(w_key, "dup")
            w_key = space.send(w_key, "freeze")
        self.strategy.setitem(self.dict_storage, w_key, w_value)
        return w_value

    @classdef.method("length")
    @classdef.method("size")
    def method_size(self, space):
        return space.newint(self.strategy.len(self.dict_storage))

    @classdef.method("empty?")
    def method_emptyp(self, space):
        return space.newbool(not self.strategy.bool(self.dict_storage))

    @classdef.method("delete")
    @check_frozen()
    def method_delete(self, space, w_key, block):
        w_res = self.strategy.pop(self.dict_storage, w_key, None)
        if w_res is None:
            if block:
                return space.invoke_block(block, [w_key])
            w_res = space.w_nil
        return w_res

    @classdef.method("clear")
    @check_frozen()
    def method_clear(self, space):
        self.strategy.clear(self.dict_storage)
        return self

    @classdef.method("shift")
    @check_frozen()
    def method_shift(self, space):
        if not self.strategy.bool(self.dict_storage):
            return space.send(self, "default", [space.w_nil])
        w_key, w_value = self.strategy.popitem(self.dict_storage)
        return space.newarray([w_key, w_value])

    @classdef.method("initialize_copy")
    @classdef.method("replace")
    @check_frozen()
    def method_replace(self, space, w_hash):
        w_hash = space.convert_type(w_hash, space.w_hash, "to_hash")
        assert isinstance(w_hash, W_HashObject)
        self.strategy = w_hash.strategy
        self.dict_storage = self.strategy.copy(w_hash.dict_storage)
        self.w_default = w_hash.w_default
        self.default_proc = w_hash.default_proc
        return self

    @classdef.method("keys")
    def method_keys(self, space):
        return space.newarray(self.strategy.keys(self.dict_storage))

    @classdef.method("values")
    def method_values(self, space):
        return space.newarray(self.strategy.values(self.dict_storage))

    @classdef.method("to_hash")
    def method_to_hash(self, space):
        return self

    @classdef.method("key?")
    @classdef.method("has_key?")
    @classdef.method("member?")
    @classdef.method("include?")
    def method_includep(self, space, w_key):
        return space.newbool(self.strategy.contains(self.dict_storage, w_key))


class W_HashIterator(W_Object):
    classdef = ClassDef("HashIterator", W_Object.classdef)

    def __init__(self, space):
        W_Object.__init__(self, space)

    @classdef.singleton_method("allocate")
    def method_allocate(self, space):
        return W_HashIterator(space)

    @classdef.method("initialize")
    def method_initialize(self, w_obj):
        assert isinstance(w_obj, W_HashObject)
        self.strategy = w_obj.strategy
        self.iterator = self.strategy.iteritems(w_obj.dict_storage)
        return self

    @classdef.method("next")
    def method_next(self, space):
        try:
            w_k, w_v = self.strategy.iternext(self.iterator)
        except StopIteration:
            raise space.error(space.w_StopIteration)
        return space.newarray([w_k, w_v])

########NEW FILE########
__FILENAME__ = integerobject
from topaz.module import ClassDef
from topaz.objects.numericobject import W_NumericObject


class W_IntegerObject(W_NumericObject):
    classdef = ClassDef("Integer", W_NumericObject.classdef)

########NEW FILE########
__FILENAME__ = intobject
import math
import operator

from rpython.rlib import rfloat
from rpython.rlib.debug import check_regular_int
from rpython.rlib.objectmodel import specialize
from rpython.rlib.rarithmetic import (r_uint, r_longlong, r_ulonglong,
    ovfcheck, LONG_BIT)
from rpython.rlib.rbigint import rbigint
from rpython.rlib.rfloat import round_away
from rpython.rtyper.lltypesystem import lltype, rffi

from topaz.coerce import Coerce
from topaz.module import ClassDef
from topaz.objects.floatobject import W_FloatObject
from topaz.objects.integerobject import W_IntegerObject
from topaz.objects.numericobject import W_NumericObject
from topaz.objects.objectobject import W_RootObject
from topaz.system import IS_WINDOWS


class FixnumStorage(object):
    def __init__(self, space):
        self.storages = {}

    def get_or_create(self, space, intvalue):
        try:
            storage = self.storages[intvalue]
        except KeyError:
            self.storages[intvalue] = storage = space.send(space.w_object, "new")
        return storage


class W_FixnumObject(W_RootObject):
    _immutable_fields_ = ["intvalue"]

    classdef = ClassDef("Fixnum", W_IntegerObject.classdef)

    def __init__(self, space, intvalue):
        check_regular_int(intvalue)
        self.intvalue = intvalue

    def __deepcopy__(self, memo):
        obj = super(W_FixnumObject, self).__deepcopy__(memo)
        obj.intvalue = self.intvalue
        return obj

    def int_w(self, space):
        return self.intvalue

    def bigint_w(self, space):
        return rbigint.fromint(self.intvalue)

    def float_w(self, space):
        return float(self.intvalue)

    def intmask_w(self, space):
        return self.intvalue

    def uintmask_w(self, space):
        return r_uint(self.intvalue)

    def longlongmask_w(self, space):
        return r_longlong(self.intvalue)

    def ulonglongmask_w(self, space):
        return r_ulonglong(self.intvalue)

    def find_instance_var(self, space, name):
        storage = space.fromcache(FixnumStorage).get_or_create(space, self.intvalue)
        return storage.find_instance_var(space, name)

    def set_instance_var(self, space, name, w_value):
        storage = space.fromcache(FixnumStorage).get_or_create(space, self.intvalue)
        storage.set_instance_var(space, name, w_value)

    @classdef.method("extend")
    @classdef.method("singleton_class")
    def method_singleton_class(self, space):
        raise space.error(space.w_TypeError, "can't define singleton")

    @classdef.method("inspect")
    @classdef.method("to_s")
    def method_to_s(self, space):
        return space.newstr_fromstr(str(self.intvalue))

    @classdef.method("to_f")
    def method_to_f(self, space):
        return space.newfloat(float(self.intvalue))

    @classdef.method("to_i")
    @classdef.method("to_int")
    def method_to_i(self, space):
        return self

    def new_binop(classdef, name, func):
        @classdef.method(name)
        def method(self, space, w_other):
            if space.is_kind_of(w_other, space.w_fixnum):
                other = space.int_w(w_other)
                try:
                    value = ovfcheck(func(self.intvalue, other))
                except OverflowError:
                    return space.send(
                        space.newbigint_fromint(self.intvalue), name,
                        [w_other]
                    )
                else:
                    return space.newint(value)
            elif space.is_kind_of(w_other, space.w_bignum):
                return space.send(space.newbigint_fromint(self.intvalue), name, [w_other])
            elif space.is_kind_of(w_other, space.w_float):
                return space.newfloat(func(self.intvalue, space.float_w(w_other)))
            else:
                return W_NumericObject.retry_binop_coercing(space, self, w_other, name)
        method.__name__ = "method_%s" % func.__name__
        return method
    method_add = new_binop(classdef, "+", operator.add)
    method_sub = new_binop(classdef, "-", operator.sub)
    method_mul = new_binop(classdef, "*", operator.mul)

    def raise_zero_division_error(self, space):
        raise space.error(space.w_ZeroDivisionError, "divided by 0")

    def divide(self, space, w_other):
        if space.is_kind_of(w_other, space.w_fixnum):
            other = space.int_w(w_other)
            try:
                return space.newint(self.intvalue / other)
            except ZeroDivisionError:
                self.raise_zero_division_error(space)
        elif space.is_kind_of(w_other, space.w_bignum):
            return space.send(space.newbigint_fromint(self.intvalue), "/", [w_other])
        elif space.is_kind_of(w_other, space.w_float):
            return space.send(space.newfloat(space.float_w(self)), "/", [w_other])
        else:
            return W_NumericObject.retry_binop_coercing(space, self, w_other, "/")

    @classdef.method("/")
    def method_divide(self, space, w_other):
        return self.divide(space, w_other)

    @classdef.method("div")
    def method_div(self, space, w_other):
        if space.is_kind_of(w_other, space.w_float):
            if space.float_w(w_other) == 0.0:
                self.raise_zero_division_error(space)
            else:
                w_float = space.send(
                    space.newfloat(space.float_w(self)),
                    "/",
                    [w_other]
                )
                w_float = space.newfloat(math.floor(Coerce.float(space, w_float)))
                return space.send(w_float, "to_i")
        else:
            return self.divide(space, w_other)

    @classdef.method("fdiv")
    def method_fdiv(self, space, w_other):
        if space.is_kind_of(w_other, space.w_fixnum):
            other = space.int_w(w_other)
            try:
                res = float(self.intvalue) / float(other)
            except ZeroDivisionError:
                return space.newfloat(rfloat.copysign(rfloat.INFINITY, float(self.intvalue)))
            else:
                return space.newfloat(res)
        elif space.is_kind_of(w_other, space.w_bignum):
            return space.send(space.newbigint_fromint(self.intvalue), "fdiv", [w_other])
        elif space.is_kind_of(w_other, space.w_float):
            other = space.float_w(w_other)
            try:
                res = float(self.intvalue) / other
            except ZeroDivisionError:
                return space.newfloat(rfloat.copysign(rfloat.INFINITY, float(self.intvalue)))
            else:
                return space.newfloat(res)
        else:
            return W_NumericObject.retry_binop_coercing(space, self, w_other, "fdiv")

    @classdef.method("**")
    def method_pow(self, space, w_other):
        if space.is_kind_of(w_other, space.w_fixnum):
            return self.method_pow_int_impl(space, w_other)
        elif space.getclass(w_other) is space.w_float:
            return space.send(
                space.newfloat(float(self.intvalue)), "**", [w_other]
            )
        elif space.getclass(w_other) is space.w_bignum:
            return space.send(
                space.newbigint_fromint(self.intvalue), "**",
                [w_other]
            )
        else:
            raise space.error(space.w_TypeError,
                "%s can't be coerced into Fixnum" % space.obj_to_s(space.getclass(w_other))
            )

    def method_pow_int_impl(self, space, w_other):
        exp = space.int_w(w_other)
        temp = self.intvalue
        if exp > 0:
            ix = 1
            try:
                while exp > 0:
                    if exp & 1:
                        ix = ovfcheck(ix * temp)
                    exp >>= 1
                    if exp == 0:
                        break
                    temp = ovfcheck(temp * temp)
            except OverflowError:
                return space.send(
                    space.newbigint_fromint(self.intvalue), "**",
                    [w_other]
                )
            return space.newint(ix)
        else:
            return space.send(space.newfloat(float(temp)), "**", [w_other])

    @classdef.method("divmod")
    def method_divmod(self, space, w_other):
        if space.is_kind_of(w_other, space.w_float):
            return space.send(self.method_to_f(space), "divmod", [w_other])
        elif space.is_kind_of(w_other, space.w_bignum):
            return space.send(space.newbigint_fromint(self.intvalue), "divmod", [w_other])
        elif space.is_kind_of(w_other, space.w_fixnum):
            y = space.int_w(w_other)
            if y == 0:
                raise space.error(
                    space.w_ZeroDivisionError,
                    "devided by 0"
                )
            mod = space.int_w(self.method_mod_int_impl(space, y))
            div = (self.intvalue - mod) / y
            return space.newarray([space.newint(int(round_away(div))), space.newfloat(mod)])
        else:
            raise space.error(
                space.w_TypeError,
                "%s can't be coerced into Fixnum" % (
                    space.obj_to_s(space.getclass(w_other))
                )
            )

    @classdef.method("%")
    @classdef.method("modulo")
    def method_mod(self, space, w_other):
        if space.is_kind_of(w_other, space.w_fixnum):
            return self.method_mod_int_impl(space, space.int_w(w_other))
        elif space.is_kind_of(w_other, space.w_float):
            return space.send(self.method_to_f(space), "%", [w_other])
        elif space.is_kind_of(w_other, space.w_bignum):
            return space.send(space.newbigint_fromint(self.intvalue), "%", [w_other])
        else:
            raise space.error(
                space.w_TypeError,
                "%s can't be coerced into Fixnum" % (
                    space.obj_to_s(space.getclass(w_other))
                )
            )

    def method_mod_int_impl(self, space, other):
        if other == 0:
            raise space.error(space.w_ZeroDivisionError, "devided by 0")
        return space.newint(self.intvalue % other)

    @classdef.method("<<", other="int")
    def method_left_shift(self, space, other):
        if other < 0:
            return space.newint(self.intvalue >> -other)
        elif other >= LONG_BIT:
            return space.send(
                space.newbigint_fromint(self.intvalue), "<<",
                [space.newint(other)]
            )
        else:
            try:
                value = ovfcheck(self.intvalue << other)
            except OverflowError:
                return space.send(
                    space.newbigint_fromint(self.intvalue), "<<",
                    [space.newint(other)]
                )
            else:
                return space.newint(value)

    @classdef.method(">>", other="int")
    def method_right_shift(self, space, other):
        if other < 0:
            return space.newint(self.intvalue << -other)
        else:
            return space.newint(self.intvalue >> other)

    def new_bitwise_op(classdef, name, func):
        @classdef.method(name)
        def method(self, space, w_other):
            w_other = space.convert_type(w_other, space.w_integer, "to_int")
            if space.is_kind_of(w_other, space.w_fixnum):
                other = space.int_w(w_other)
                return space.newint(func(self.intvalue, other))
            elif space.is_kind_of(w_other, space.w_bignum):
                return space.send(space.newbigint_fromint(self.intvalue), name, [w_other])
            else:
                return W_NumericObject.retry_binop_coercing(space, self, w_other, name)
        method.__name__ = "method_%s" % func.__name__
        return method
    method_and = new_bitwise_op(classdef, "&", operator.and_)
    method_or = new_bitwise_op(classdef, "|", operator.or_)
    method_xor = new_bitwise_op(classdef, "^", operator.xor)

    @classdef.method("~")
    def method_invert(self, space):
        return space.newint(~self.intvalue)

    @classdef.method("==")
    @classdef.method("equal?")
    def method_eq(self, space, w_other):
        if isinstance(w_other, W_FixnumObject):
            return space.newbool(self.comparator(space, space.int_w(w_other)) == 0)
        elif isinstance(w_other, W_FloatObject):
            return space.newbool(self.comparator(space, space.float_w(w_other)) == 0)
        else:
            return space.send(w_other, "==", [self])

    @classdef.method("!=")
    def method_ne(self, space, w_other):
        return space.newbool(space.send(self, "==", [w_other]) is space.w_false)

    def new_bool_op(classdef, name, func):
        @classdef.method(name)
        def method(self, space, w_other):
            if space.is_kind_of(w_other, space.w_float):
                return space.newbool(func(self.intvalue, space.float_w(w_other)))
            elif space.is_kind_of(w_other, space.w_fixnum):
                return space.newbool(func(self.intvalue, space.int_w(w_other)))
            else:
                return W_NumericObject.retry_binop_coercing(space, self, w_other, name, raise_error=True)
        method.__name__ = "method_%s" % func.__name__
        return method
    method_lt = new_bool_op(classdef, "<", operator.lt)
    method_lte = new_bool_op(classdef, "<=", operator.le)
    method_gt = new_bool_op(classdef, ">", operator.gt)
    method_gte = new_bool_op(classdef, ">=", operator.ge)

    @classdef.method("<=>")
    def method_comparator(self, space, w_other):
        if isinstance(w_other, W_FixnumObject):
            return space.newint(self.comparator(space, space.int_w(w_other)))
        elif isinstance(w_other, W_FloatObject):
            return space.newint(self.comparator(space, space.float_w(w_other)))
        else:
            return space.w_nil

    @specialize.argtype(2)
    def comparator(self, space, other):
        if self.intvalue < other:
            return -1
        elif self.intvalue == other:
            return 0
        elif self.intvalue > other:
            return 1
        return 1

    @classdef.method("hash")
    def method_hash(self, space):
        return self

    if IS_WINDOWS:
        @classdef.method("size")
        def method_size(self, space):
            # RPython translation is always 32bit on Windows
            return space.newint(4)
    else:
        @classdef.method("size")
        def method_size(self, space):
            return space.newint(rffi.sizeof(lltype.typeOf(self.intvalue)))

    @classdef.method("coerce")
    def method_coerce(self, space, w_other):
        if space.getclass(w_other) is space.getclass(self):
            return space.newarray([w_other, self])
        else:
            return space.newarray([space.send(self, "Float", [w_other]), self])

    @classdef.method("chr")
    def method_chr(self, space):
        if self.intvalue > 255 or self.intvalue < 0:
            raise space.error(space.w_RangeError, "%d out of char range" % self.intvalue)
        else:
            return space.newstr_fromstr(chr(self.intvalue))

    @classdef.method("[]", idx="int")
    def method_subscript(self, space, idx):
        if not 0 <= idx < LONG_BIT:
            return space.newint(0)
        return space.newint(int(bool(self.intvalue & (1 << idx))))

########NEW FILE########
__FILENAME__ = ioobject
import os

from topaz.coerce import Coerce
from topaz.error import error_for_oserror
from topaz.module import ClassDef
from topaz.objects.objectobject import W_Object
from topaz.objects.stringobject import W_StringObject
from topaz.utils.filemode import map_filemode


class W_IOObject(W_Object):
    classdef = ClassDef("IO", W_Object.classdef)

    def __init__(self, space):
        W_Object.__init__(self, space)
        self.fd = -1

    def __del__(self):
        # Do not close standard file streams
        if self.fd > 3:
            os.close(self.fd)

    def __deepcopy__(self, memo):
        obj = super(W_IOObject, self).__deepcopy__(memo)
        obj.fd = self.fd
        return obj

    def ensure_not_closed(self, space):
        if self.fd < 0:
            raise space.error(space.w_IOError, "closed stream")

    def getfd(self):
        return self.fd

    @classdef.setup_class
    def setup_class(cls, space, w_cls):
        w_stdin = space.send(w_cls, "new", [space.newint(0)])
        space.globals.set(space, "$stdin", w_stdin)
        space.set_const(space.w_object, "STDIN", w_stdin)

        w_stdout = space.send(w_cls, "new", [space.newint(1)])
        space.globals.set(space, "$stdout", w_stdout)
        space.globals.set(space, "$>", w_stdout)
        space.globals.set(space, "$/", space.newstr_fromstr("\n"))
        space.set_const(space.w_object, "STDOUT", w_stdout)

        w_stderr = space.send(w_cls, "new", [space.newint(2)])
        space.globals.set(space, "$stderr", w_stderr)
        space.set_const(space.w_object, "STDERR", w_stderr)

        space.set_const(w_cls, "SEEK_CUR", space.newint(os.SEEK_CUR))
        space.set_const(w_cls, "SEEK_END", space.newint(os.SEEK_END))
        space.set_const(w_cls, "SEEK_SET", space.newint(os.SEEK_SET))

    @classdef.singleton_method("allocate")
    def method_allocate(self, space, args_w):
        return W_IOObject(space)

    @classdef.singleton_method("sysopen")
    def method_sysopen(self, space, w_path, w_mode_str_or_int=None, w_perm=None):
        perm = 0666
        mode = os.O_RDONLY
        if w_mode_str_or_int is not None:
            mode, encoding = map_filemode(space, w_mode_str_or_int)
        if w_perm is not None and w_perm is not space.w_nil:
            perm = space.int_w(w_perm)
        path = Coerce.path(space, w_path)
        try:
            fd = os.open(path, mode, perm)
        except OSError as e:
            raise error_for_oserror(space, e)
        else:
            return space.newint(fd)

    @classdef.method("initialize")
    def method_initialize(self, space, w_fd_or_io, w_mode_str_or_int=None, w_opts=None):
        if isinstance(w_fd_or_io, W_IOObject):
            fd = w_fd_or_io.fd
        else:
            fd = Coerce.int(space, w_fd_or_io)
        if isinstance(w_mode_str_or_int, W_StringObject):
            mode = space.str_w(w_mode_str_or_int)
        elif w_mode_str_or_int is None:
            mode = None
        else:
            raise space.error(space.w_NotImplementedError, "int mode for IO.new")
        if w_opts is not None:
            raise space.error(space.w_NotImplementedError, "options hash for IO.new")
        if mode is None:
            mode = "r"
        self.fd = fd
        return self

    @classdef.method("read")
    def method_read(self, space, w_length=None, w_str=None):
        self.ensure_not_closed(space)
        if w_length:
            length = space.int_w(w_length)
            if length < 0:
                raise space.error(space.w_ArgumentError,
                    "negative length %d given" % length
                )
        else:
            length = -1
        read_bytes = 0
        read_chunks = []
        while length < 0 or read_bytes < length:
            if length > 0:
                max_read = int(length - read_bytes)
            else:
                max_read = 8192
            try:
                current_read = os.read(self.fd, max_read)
            except OSError as e:
                raise error_for_oserror(space, e)
            if len(current_read) == 0:
                break
            read_bytes += len(current_read)
            read_chunks += current_read
        # Return nil on EOF if length is given
        if read_bytes == 0:
            return space.w_nil
        w_read_str = space.newstr_fromchars(read_chunks)
        if w_str is not None:
            w_str.clear(space)
            w_str.extend(space, w_read_str)
            return w_str
        else:
            return w_read_str

    @classdef.method("write")
    def method_write(self, space, w_str):
        self.ensure_not_closed(space)
        string = space.str_w(space.send(w_str, "to_s"))
        try:
            bytes_written = os.write(self.fd, string)
        except OSError as e:
            raise error_for_oserror(space, e)
        return space.newint(bytes_written)

    @classdef.method("flush")
    def method_flush(self, space):
        # We have no internal buffers to flush!
        self.ensure_not_closed(space)
        return self

    @classdef.method("seek", amount="int", whence="int")
    def method_seek(self, space, amount, whence=os.SEEK_SET):
        self.ensure_not_closed(space)
        os.lseek(self.fd, amount, whence)
        return space.newint(0)

    @classdef.method("pos")
    @classdef.method("tell")
    def method_pos(self, space):
        self.ensure_not_closed(space)
        # TODO: this currently truncates large values, switch this to use a
        # Bignum in those cases
        return space.newint(int(os.lseek(self.fd, 0, os.SEEK_CUR)))

    @classdef.method("rewind")
    def method_rewind(self, space):
        self.ensure_not_closed(space)
        os.lseek(self.fd, 0, os.SEEK_SET)
        return space.newint(0)

    @classdef.method("print")
    def method_print(self, space, args_w):
        self.ensure_not_closed(space)
        if not args_w:
            w_last = space.globals.get(space, "$_")
            if w_last is not None:
                args_w.append(w_last)
        w_sep = space.globals.get(space, "$,")
        if w_sep:
            sep = space.str_w(space.send(w_sep, "to_s"))
        else:
            sep = ""
        w_end = space.globals.get(space, "$\\")
        if w_end:
            end = space.str_w(space.send(w_end, "to_s"))
        else:
            end = ""
        strings = [space.str_w(space.send(w_arg, "to_s")) for w_arg in args_w]
        os.write(self.fd, sep.join(strings))
        os.write(self.fd, end)
        return space.w_nil

    @classdef.method("getc")
    def method_getc(self, space):
        self.ensure_not_closed(space)
        try:
            c = os.read(self.fd, 1)
        except OSError as e:
            raise error_for_oserror(space, e)
        if not c:
            return space.w_nil
        return space.newstr_fromstr(c)

    @classdef.singleton_method("pipe")
    def method_pipe(self, space, block=None):
        r, w = os.pipe()
        pipes_w = [
            space.send(self, "new", [space.newint(r)]),
            space.send(self, "new", [space.newint(w)])
        ]
        if block is not None:
            try:
                return space.invoke_block(block, pipes_w)
            finally:
                for pipe_w in pipes_w:
                    if not space.is_true(space.send(pipe_w, "closed?")):
                        space.send(pipe_w, "close")
        else:
            return space.newarray(pipes_w)

    @classdef.method("reopen")
    def method_reopen(self, space, w_arg, w_mode=None):
        self.ensure_not_closed(space)
        w_io = space.convert_type(w_arg, space.w_io, "to_io", raise_error=False)
        if w_io is space.w_nil:
            from topaz.objects.fileobject import W_FileObject
            args = [w_arg] if w_mode is None else [w_arg, w_mode]
            w_io = space.send(space.getclassfor(W_FileObject), "new", args)
        assert isinstance(w_io, W_IOObject)
        w_io.ensure_not_closed(space)
        os.close(self.fd)
        os.dup2(w_io.getfd(), self.fd)
        return self

    @classdef.method("to_io")
    def method_to_io(self):
        return self

    @classdef.method("fileno")
    @classdef.method("to_i")
    def method_to_i(self, space):
        self.ensure_not_closed(space)
        return space.newint(self.fd)

    @classdef.method("close")
    def method_close(self, space):
        self.ensure_not_closed(space)
        os.close(self.fd)
        self.fd = -1
        return self

    @classdef.method("closed?")
    def method_closedp(self, space):
        return space.newbool(self.fd == -1)

    @classdef.method("stat")
    def method_stat(self, space):
        from topaz.objects.fileobject import W_FileStatObject
        try:
            stat_val = os.fstat(self.fd)
        except OSError as e:
            raise error_for_oserror(space, e)
        stat_obj = W_FileStatObject(space)
        stat_obj.set_stat(stat_val)
        return stat_obj

    @classdef.method("isatty")
    @classdef.method("tty?")
    def method_isatty(self, space):
        self.ensure_not_closed(space)
        return space.newbool(os.isatty(self.fd))

########NEW FILE########
__FILENAME__ = methodobject
from topaz.module import ClassDef
from topaz.objects.objectobject import W_Object


def create_owner(classdef):
    @classdef.method("owner")
    def method_owner(self, space):
        return self.w_owner
    return method_owner


def create_to_s(classdef):
    @classdef.method("to_s")
    def method_to_s(self, space):
        return space.newstr_fromstr(
            "#<%s: %s#%s>" % (classdef.name, self.w_owner.name, self.w_function.name)
        )
    return method_to_s


class W_MethodObject(W_Object):
    classdef = ClassDef("Method", W_Object.classdef)

    def __init__(self, space, w_owner, w_function, w_receiver):
        W_Object.__init__(self, space)
        self.w_owner = w_owner
        self.w_function = w_function
        self.w_receiver = w_receiver

    method_allocate = classdef.undefine_allocator()
    method_owner = create_owner(classdef)
    method_to_s = create_to_s(classdef)

    @classdef.method("[]")
    @classdef.method("call")
    def method_call(self, space, args_w, block):
        return space.invoke_function(
            self.w_function,
            self.w_receiver,
            args_w,
            block
        )

    @classdef.method("unbind")
    def method_unbind(self, space):
        return W_UnboundMethodObject(space, self.w_owner, self.w_function)

    @classdef.method("receiver")
    def method_receiver(self, space):
        return self.w_receiver

    @classdef.method("==")
    def method_eql(self, space, w_other):
        if isinstance(w_other, W_MethodObject):
            return space.newbool(
                self.w_function is w_other.w_function and self.w_receiver is w_other.w_receiver
            )
        else:
            return space.w_false

    @classdef.method("arity")
    def method_arity(self, space):
        return self.w_function.arity(space)


class W_UnboundMethodObject(W_Object):
    classdef = ClassDef("UnboundMethod", W_Object.classdef)

    def __init__(self, space, w_owner, w_function):
        W_Object.__init__(self, space)
        self.w_owner = w_owner
        self.w_function = w_function

    method_allocator = classdef.undefine_allocator()
    method_owner = create_owner(classdef)
    method_to_s = create_to_s(classdef)

    @classdef.method("bind")
    def method_bind(self, space, w_receiver):
        if not self.w_owner.is_ancestor_of(space.getclass(w_receiver)):
            raise space.error(space.w_TypeError,
                "bind argument must be an instance of %s" % self.w_owner.name
            )
        else:
            return W_MethodObject(space, self.w_owner, self.w_function, w_receiver)

    @classdef.method("==")
    def method_eql(self, space, w_other):
        if isinstance(w_other, W_UnboundMethodObject):
            return space.newbool(self.w_function is w_other.w_function)
        else:
            return space.w_false

    @classdef.method("arity")
    def method_arity(self, space):
        return self.w_function.arity(space)

########NEW FILE########
__FILENAME__ = moduleobject
import copy

from rpython.rlib import jit
from rpython.rlib.objectmodel import specialize

from topaz.celldict import CellDict, VersionTag
from topaz.coerce import Coerce
from topaz.module import ClassDef, check_frozen
from topaz.objects.functionobject import W_FunctionObject
from topaz.objects.objectobject import W_RootObject
from topaz.objects.procobject import W_ProcObject
from topaz.scope import StaticScope


class AttributeReader(W_FunctionObject):
    _immutable_fields_ = ["varname"]

    def __init__(self, varname):
        W_FunctionObject.__init__(self, varname)
        self.varname = varname

    def __deepcopy__(self, memo):
        obj = super(W_FunctionObject, self).__deepcopy__(memo)
        obj.varname = self.varname
        return obj

    def call(self, space, w_obj, args_w, block):
        return space.find_instance_var(w_obj, self.varname)


class AttributeWriter(W_FunctionObject):
    _immutable_fields_ = ["varname"]

    def __init__(self, varname):
        W_FunctionObject.__init__(self, varname)
        self.varname = varname

    def __deepcopy__(self, memo):
        obj = super(W_FunctionObject, self).__deepcopy__(memo)
        obj.varname = self.varname
        return obj

    def call(self, space, w_obj, args_w, block):
        [w_value] = args_w
        space.set_instance_var(w_obj, self.varname, w_value)
        return w_value

    def arity(self, space):
        return space.newint(1)


class UndefMethod(W_FunctionObject):
    _immutable_fields_ = ["name"]

    def __init__(self, name):
        W_FunctionObject.__init__(self, name)
        self.name = name

    def call(self, space, w_obj, args_w, block):
        args_w.insert(0, space.newsymbol(self.name))
        return space.send(w_obj, "method_missing", args_w, block)


class DefineMethodBlock(W_FunctionObject):
    _immutable_fields_ = ["name", "block"]

    def __init__(self, name, block):
        W_FunctionObject.__init__(self, name)
        self.name = name
        self.block = block

    def call(self, space, w_obj, args_w, block):
        from topaz.interpreter import RaiseReturn

        method_block = self.block.copy(space, w_self=w_obj, is_lambda=True)
        try:
            return space.invoke_block(method_block, args_w, block)
        except RaiseReturn as e:
            return e.w_value

    def arity(self, space):
        return space.newint(self.block.bytecode.arity(negative_defaults=True))


class DefineMethodMethod(W_FunctionObject):
    _immutable_fields_ = ["name", "w_unbound_method"]

    def __init__(self, name, w_unbound_method):
        W_FunctionObject.__init__(self, name)
        self.name = name
        self.w_unbound_method = w_unbound_method

    def call(self, space, w_obj, args_w, block):
        w_bound_method = space.send(self.w_unbound_method, "bind", [w_obj])
        return space.send(w_bound_method, "call", args_w, block)


class W_ModuleObject(W_RootObject):
    _immutable_fields_ = ["version?", "included_modules?[*]", "klass?", "name?"]

    classdef = ClassDef("Module", W_RootObject.classdef)

    def __init__(self, space, name, klass=None):
        self.name = name
        self.klass = klass
        self.version = VersionTag()
        self.methods_w = {}
        self.constants_w = {}
        self.class_variables = CellDict()
        self.instance_variables = CellDict()
        self.flags = CellDict()
        self.included_modules = []
        self.descendants = []

    def __deepcopy__(self, memo):
        obj = super(W_ModuleObject, self).__deepcopy__(memo)
        obj.name = self.name
        obj.klass = copy.deepcopy(self.klass, memo)
        obj.version = copy.deepcopy(self.version, memo)
        obj.methods_w = copy.deepcopy(self.methods_w, memo)
        obj.constants_w = copy.deepcopy(self.constants_w, memo)
        obj.class_variables = copy.deepcopy(self.class_variables, memo)
        obj.instance_variables = copy.deepcopy(self.instance_variables, memo)
        obj.flags = copy.deepcopy(self.flags, memo)
        obj.included_modules = copy.deepcopy(self.included_modules, memo)
        obj.descendants = copy.deepcopy(self.descendants, memo)
        return obj

    def getclass(self, space):
        if self.klass is not None:
            return jit.promote(self).klass
        return W_RootObject.getclass(self, space)

    def getsingletonclass(self, space):
        if self.klass is None or not self.klass.is_singleton:
            self.klass = space.newclass(
                "#<Class:%s>" % self.name, self.klass or space.w_module, is_singleton=True, attached=self
            )
        return self.klass

    def mutated(self):
        self.version = VersionTag()

    def define_method(self, space, name, method):
        if (name == "initialize" or name == "initialize_copy" or
            method.visibility == W_FunctionObject.MODULE_FUNCTION):
            method.update_visibility(W_FunctionObject.PRIVATE)
        self.mutated()
        self.methods_w[name] = method
        if not space.bootstrap:
            if isinstance(method, UndefMethod):
                self.method_undefined(space, space.newsymbol(name))
            else:
                self.method_added(space, space.newsymbol(name))

    @jit.unroll_safe
    def find_method(self, space, name):
        method = self._find_method_pure(space, name, self.version)
        if method is None:
            for module in self.included_modules:
                method = module.find_method(space, name)
                if method is not None:
                    return method
        return method

    @jit.unroll_safe
    def find_method_super(self, space, name):
        for module in self.included_modules:
            method = module.find_method(space, name)
            if method is not None:
                return method
        return None

    @jit.elidable
    def _find_method_pure(self, space, method, version):
        return self.methods_w.get(method, None)

    @specialize.argtype(2)
    def methods(self, space, visibility=None, inherit=True):
        methods = {}
        for name, method in self.methods_w.iteritems():
            if (not isinstance(method, UndefMethod) and
                (visibility is None or method.visibility == visibility)):
                methods[name] = None

        if inherit:
            for w_mod in self.included_modules:
                for name in w_mod.methods(space, visibility=visibility):
                    method = self._find_method_pure(space, name, self.version)
                    if method is None or not isinstance(method, UndefMethod):
                        methods[name] = None
        return methods.keys()

    def set_const(self, space, name, w_obj):
        self.mutated()
        self.constants_w[name] = w_obj
        if isinstance(w_obj, W_ModuleObject) and w_obj.name is None and self.name is not None:
            w_obj.set_name_in_scope(space, name, self)

    def find_const(self, space, name):
        w_res = self.find_included_const(space, name)
        if w_res is None:
            return space.w_object.find_const(space, name)
        else:
            return w_res

    @jit.unroll_safe
    def find_included_const(self, space, name):
        w_res = self.find_local_const(space, name)
        if w_res is None:
            for w_mod in self.included_modules:
                w_res = w_mod.find_local_const(space, name)
                if w_res is not None:
                    break
        return w_res

    def included_constants(self, space):
        consts = {}
        for const in self.constants_w:
            consts[const] = None
        for w_mod in self.included_modules:
            for const in w_mod.included_constants(space):
                consts[const] = None
        return consts.keys()

    def lexical_constants(self, space):
        consts = {}
        frame = space.getexecutioncontext().gettoprubyframe()
        scope = frame.lexical_scope

        while scope is not None:
            assert isinstance(scope, W_ModuleObject)
            for const in scope.w_mod.constants_w:
                consts[const] = None
            scope = scope.backscope

        return consts.keys()

    def local_constants(self, space):
        return self.constants_w.keys()

    def inherited_constants(self, space):
        return self.local_constants(space)

    def find_local_const(self, space, name):
        return self._find_const_pure(name, self.version)

    @jit.elidable
    def _find_const_pure(self, name, version):
        return self.constants_w.get(name, None)

    @jit.unroll_safe
    def set_class_var(self, space, name, w_obj):
        for module in reversed(self.ancestors()):
            assert isinstance(module, W_ModuleObject)
            w_res = module.class_variables.get(space, name)
            if w_res is not None or module is self:
                module.class_variables.set(space, name, w_obj)
                if module is self:
                    for descendant in self.descendants:
                        descendant.remove_class_var(space, name)

    @jit.unroll_safe
    def find_class_var(self, space, name):
        w_res = self.class_variables.get(space, name)
        if w_res is None:
            ancestors = self.ancestors()
            for idx in xrange(1, len(ancestors)):
                module = ancestors[idx]
                assert isinstance(module, W_ModuleObject)
                w_res = module.class_variables.get(space, name)
                if w_res is not None:
                    break
        return w_res

    @jit.unroll_safe
    def remove_class_var(self, space, name):
        self.class_variables.delete(name)
        for descendant in self.descendants:
            descendant.remove_class_var(space, name)

    def set_instance_var(self, space, name, w_value):
        return self.instance_variables.set(space, name, w_value)

    def find_instance_var(self, space, name):
        return self.instance_variables.get(space, name)

    def copy_instance_vars(self, space, w_other):
        assert isinstance(w_other, W_ModuleObject)
        for key in w_other.instance_variables:
            w_value = w_other.instance_variables.get(space, key)
            self.set_instance_var(space, key, w_value)

    def set_flag(self, space, name):
        self.flags.set(space, name, space.w_true)

    def unset_flag(self, space, name):
        self.flags.set(space, name, space.w_false)

    def get_flag(self, space, name):
        return self.flags.get(space, name) or space.w_false

    def ancestors(self, include_singleton=True, include_self=True):
        if include_self:
            return [self] + self.included_modules
        else:
            return self.included_modules[:]

    @jit.unroll_safe
    def is_ancestor_of(self, w_cls):
        if self is w_cls:
            return True
        for w_mod in w_cls.included_modules:
            if self is w_mod:
                return True
        if w_cls.superclass is not None:
            return self.is_ancestor_of(w_cls.superclass)
        return False

    def include_module(self, space, w_mod):
        assert isinstance(w_mod, W_ModuleObject)
        if w_mod not in self.ancestors():
            self.included_modules = [w_mod] + self.included_modules
            w_mod.included(space, self)

    def included(self, space, w_mod):
        self.descendants.append(w_mod)
        if space.respond_to(self, "included"):
            space.send(self, "included", [w_mod])

    def extend_object(self, space, w_mod):
        if self not in w_mod.ancestors():
            self.descendants.append(w_mod)
            w_mod.included_modules = [self] + w_mod.included_modules

    def set_visibility(self, space, names_w, visibility):
        names = [space.symbol_w(w_name) for w_name in names_w]
        if names:
            for name in names:
                self.set_method_visibility(space, name, visibility)
        else:
            self.set_default_visibility(space, visibility)

    def set_default_visibility(self, space, visibility):
        frame = space.getexecutioncontext().gettoprubyframe()
        frame.visibility = visibility

    def set_method_visibility(self, space, name, visibility):
        w_method = self.find_method(space, name)
        if w_method is None or isinstance(w_method, UndefMethod):
            w_method = space.w_object.find_method(space, name)

        if w_method is None or isinstance(w_method, UndefMethod):
            cls_name = space.obj_to_s(self)
            raise space.error(space.w_NameError,
                "undefined method `%s' for class `%s'" % (name, cls_name)
            )
        w_method.update_visibility(visibility)

    def method_added(self, space, w_name):
        space.send(self, "method_added", [w_name])

    def method_undefined(self, space, w_name):
        space.send(self, "method_undefined", [w_name])

    def method_removed(self, space, w_name):
        space.send(self, "method_removed", [w_name])

    def set_name_in_scope(self, space, name, w_scope):
        self.name = space.buildname(name, w_scope)
        for name, w_const in self.constants_w.iteritems():
            if isinstance(w_const, W_ModuleObject):
                w_const.set_name_in_scope(space, name, self)

    @classdef.singleton_method("nesting")
    def singleton_method_nesting(self, space):
        frame = space.getexecutioncontext().gettoprubyframe()
        modules_w = []
        scope = frame.lexical_scope
        while scope is not None:
            modules_w.append(scope.w_mod)
            scope = scope.backscope
        return space.newarray(modules_w)

    @classdef.singleton_method("allocate")
    def method_allocate(self, space):
        return W_ModuleObject(space, None, self)

    @classdef.method("initialize")
    def method_initialize(self, space, block):
        if block is not None:
            space.send(self, "module_exec", [self], block)

    @classdef.method("to_s")
    def method_to_s(self, space):
        name = self.name
        if name is None:
            return space.newstr_fromstr(space.any_to_s(self))
        return space.newstr_fromstr(name)

    @classdef.method("include")
    def method_include(self, space, args_w):
        for w_mod in args_w:
            if type(w_mod) is not W_ModuleObject:
                raise space.error(
                    space.w_TypeError,
                    "wrong argument type %s (expected Module)" % space.obj_to_s(space.getclass(w_mod))
                )

        for w_mod in reversed(args_w):
            space.send(w_mod, "append_features", [self])

        return self

    @classdef.method("include?")
    def method_includep(self, space, w_mod):
        if type(w_mod) is not W_ModuleObject:
            raise space.error(
                space.w_TypeError,
                "wrong argument type %s (expected Module)" % space.obj_to_s(space.getclass(w_mod))
            )
        if w_mod is self:
            return space.w_false
        return space.newbool(w_mod in self.ancestors())

    @classdef.method("append_features")
    def method_append_features(self, space, w_mod):
        if w_mod in self.ancestors():
            raise space.error(space.w_ArgumentError, "cyclic include detected")
        for module in reversed(self.ancestors()):
            w_mod.include_module(space, module)

    @classdef.method("define_method", name="symbol")
    @check_frozen()
    def method_define_method(self, space, name, w_method=None, block=None):
        if w_method is not None:
            if space.is_kind_of(w_method, space.w_method):
                w_method = space.send(w_method, "unbind")

            if space.is_kind_of(w_method, space.w_unbound_method):
                self.define_method(space, name, DefineMethodMethod(name, w_method))
                return w_method
            elif space.is_kind_of(w_method, space.w_proc):
                assert isinstance(w_method, W_ProcObject)
                self.define_method(space, name, DefineMethodBlock(name, w_method))
                return w_method.copy(space, is_lambda=True)
            else:
                raise space.error(space.w_TypeError,
                    "wrong argument type %s (expected Proc/Method)" % space.obj_to_s(space.getclass(w_method))
                )
        elif block is not None:
            self.define_method(space, name, DefineMethodBlock(name, block))
            return block.copy(space, is_lambda=True)
        else:
            raise space.error(space.w_ArgumentError, "tried to create Proc object without a block")

    @classdef.method("attr_accessor")
    def method_attr_accessor(self, space, args_w):
        self.method_attr_reader(space, args_w)
        self.method_attr_writer(space, args_w)

    @classdef.method("attr_reader")
    def method_attr_reader(self, space, args_w):
        for w_arg in args_w:
            varname = Coerce.symbol(space, w_arg)
            self.define_method(space, varname, AttributeReader("@" + varname))

    @classdef.method("attr_writer")
    def method_attr_writer(self, space, args_w):
        for w_arg in args_w:
            varname = Coerce.symbol(space, w_arg)
            self.define_method(space, varname + "=", AttributeWriter("@" + varname))

    @classdef.method("attr")
    def method_attr(self, space, args_w):
        if len(args_w) == 2 and (args_w[1] is space.w_true or args_w[1] is space.w_false):
            [w_name, w_writable] = args_w
            if space.is_true(w_writable):
                self.method_attr_accessor(space, [w_name])
            else:
                self.method_attr_reader(space, [w_name])
        else:
            self.method_attr_reader(space, args_w)

    @classdef.method("module_function")
    def method_module_function(self, space, args_w):
        if not args_w:
            self.set_default_visibility(space, W_FunctionObject.MODULE_FUNCTION)
            return self
        for w_arg in args_w:
            name = Coerce.symbol(space, w_arg)
            w_method = self.find_method(space, name)
            if w_method is None or isinstance(w_method, UndefMethod):
                cls_name = space.obj_to_s(self)
                raise space.error(space.w_NameError,
                    "undefined method `%s' for class `%s'" % (name, cls_name)
                )
            self.attach_method(space, name, w_method)
            self.set_method_visibility(space, name, W_FunctionObject.PRIVATE)
        return self

    @classdef.method("private_class_method")
    def method_private_class_method(self, space, args_w):
        w_cls = self.getsingletonclass(space)
        return space.send(w_cls, "private", args_w)

    @classdef.method("public_class_method")
    def method_public_class_method(self, space, args_w):
        w_cls = self.getsingletonclass(space)
        return space.send(w_cls, "public", args_w)

    @classdef.method("alias_method", new_name="symbol", old_name="symbol")
    @check_frozen()
    def method_alias_method(self, space, new_name, old_name):
        w_method = self.find_method(space, old_name)
        if w_method is None:
            w_method = space.w_object.find_method(space, old_name)
        if w_method is None or isinstance(w_method, UndefMethod):
            cls_name = space.obj_to_s(self)
            raise space.error(space.w_NameError,
                "undefined method `%s' for class `%s'" % (old_name, cls_name)
            )
        self.define_method(space, new_name, w_method)

    @classdef.method("ancestors")
    def method_ancestors(self, space):
        return space.newarray(self.ancestors(include_singleton=False))

    @classdef.method("included")
    def method_included(self, space, w_mod):
        # TODO: should be private
        pass

    @classdef.method("extended")
    def method_extended(self, space, w_mod):
        # TODO: should be private
        pass

    @classdef.method("extend_object")
    def method_extend_object(self, space, w_obj):
        self.extend_object(space, space.getsingletonclass(w_obj))

    @classdef.method("name")
    def method_name(self, space):
        if self.name is None:
            return space.w_nil
        return space.newstr_fromstr(self.name)

    @classdef.method("private")
    def method_private(self, space, args_w):
        self.set_visibility(space, args_w, W_FunctionObject.PRIVATE)
        return self

    @classdef.method("public")
    def method_public(self, space, args_w):
        self.set_visibility(space, args_w, W_FunctionObject.PUBLIC)
        return self

    @classdef.method("protected")
    def method_protected(self, space, args_w):
        self.set_visibility(space, args_w, W_FunctionObject.PROTECTED)
        return self

    @classdef.method("private_constant")
    def method_private_constant(self, space, args_w):
        pass

    @classdef.method("constants")
    def method_constants(self, space, w_inherit=None):
        if self is space.w_module and w_inherit is None:
            consts = {}
            for const in self.lexical_constants(space):
                consts[const] = None
            for const in self.inherited_constants(space):
                consts[const] = None
            return space.newarray([space.newsymbol(n) for n in consts])

        if w_inherit is None or space.is_true(w_inherit):
            return space.newarray([space.newsymbol(n) for n in self.included_constants(space)])
        else:
            return space.newarray([space.newsymbol(n) for n in self.constants_w])

    @classdef.method("const_missing", name="symbol")
    def method_const_missing(self, space, name):
        if self is space.w_object:
            raise space.error(space.w_NameError, "uninitialized constant %s" % (name))
        else:
            self_name = space.obj_to_s(self)
            raise space.error(space.w_NameError, "uninitialized constant %s::%s" % (self_name, name))

    @classdef.method("class_eval", string="str", filename="str")
    @classdef.method("module_eval", string="str", filename="str")
    def method_module_eval(self, space, string=None, filename=None, w_lineno=None, block=None):
        if string is not None and block is not None:
            raise space.error(space.w_ArgumentError, "wrong number of arguments")
        if string is not None:
            if filename is None:
                filename = "module_eval"
            if w_lineno is not None:
                lineno = space.int_w(w_lineno)
            else:
                lineno = 1
            return space.execute(string, self, lexical_scope=StaticScope(self, None), filepath=filename, initial_lineno=lineno)
        elif block is None:
            raise space.error(space.w_ArgumentError, "block not supplied")
        else:
            return space.invoke_block(block.copy(space, w_self=self, lexical_scope=StaticScope(self, block.lexical_scope)), [])

    @classdef.method("const_defined?", const="str", inherit="bool")
    def method_const_definedp(self, space, const, inherit=True):
        space._check_const_name(const)
        if inherit:
            return space.newbool(self.find_const(space, const) is not None)
        else:
            return space.newbool(self.find_local_const(space, const) is not None)

    @classdef.method("const_get", const="symbol", inherit="bool")
    def method_const_get(self, space, const, inherit=True):
        space._check_const_name(const)
        if inherit:
            w_res = self.find_const(space, const)
        else:
            w_res = self.find_local_const(space, const)
        if w_res is None:
            return space.send(self, "const_missing", [space.newsymbol(const)])
        return w_res

    @classdef.method("const_set", const="symbol")
    def method_const_set(self, space, const, w_value):
        space.set_const(self, const, w_value)
        return w_value

    @classdef.method("remove_const", name="str")
    def method_remove_const(self, space, name):
        space._check_const_name(name)
        w_res = self.find_local_const(space, name)
        if w_res is None:
            self_name = space.obj_to_s(self)
            raise space.error(space.w_NameError,
                "uninitialized constant %s::%s" % (self_name, name)
            )
        del self.constants_w[name]
        self.mutated()
        return w_res

    @classdef.method("class_variable_defined?", name="symbol")
    def method_class_variable_definedp(self, space, name):
        return space.newbool(self.find_class_var(space, name) is not None)

    @classdef.method("class_variable_get", name="symbol")
    def method_class_variable_get(self, space, name):
        return space.find_class_var(self, name)

    @classdef.method("class_variable_set", name="symbol")
    @check_frozen()
    def method_class_variable_set(self, space, name, w_value):
        self.set_class_var(space, name, w_value)
        return w_value

    @classdef.method("remove_class_variable", name="symbol")
    def method_remove_class_variable(self, space, name):
        w_value = self.class_variables.get(space, name)
        if w_value is not None:
            self.class_variables.delete(name)
            return w_value
        if self.find_class_var(space, name) is not None:
            raise space.error(space.w_NameError,
                "cannot remove %s for %s" % (name, space.obj_to_s(self))
            )
        raise space.error(space.w_NameError,
            "class variable %s not defined for %s" % (name, space.obj_to_s(self))
        )

    @classdef.method("method_defined?", name="str")
    def method_method_definedp(self, space, name):
        return space.newbool(self.find_method(space, name) is not None)

    @classdef.method("===")
    def method_eqeqeq(self, space, w_obj):
        return space.newbool(self.is_ancestor_of(space.getclass(w_obj)))

    @classdef.method("<=")
    def method_lte(self, space, w_other):
        if not isinstance(w_other, W_ModuleObject):
            raise space.error(space.w_TypeError, "compared with non class/module")
        for w_mod in self.ancestors():
            if w_other is w_mod:
                return space.w_true
        for w_mod in w_other.ancestors():
            if self is w_mod:
                return space.w_false
        return space.w_nil

    @classdef.method("<")
    def method_lt(self, space, w_other):
        if self is w_other:
            return space.w_false
        return space.send(self, "<=", [w_other])

    @classdef.method(">=")
    def method_gte(self, space, w_other):
        if not isinstance(w_other, W_ModuleObject):
            raise space.error(space.w_TypeError, "compared with non class/module")
        return space.send(w_other, "<=", [self])

    @classdef.method(">")
    def method_gt(self, space, w_other):
        if not isinstance(w_other, W_ModuleObject):
            raise space.error(space.w_TypeError, "compared with non class/module")
        if self is w_other:
            return space.w_false
        return space.send(w_other, "<=", [self])

    @classdef.method("<=>")
    def method_comparison(self, space, w_other):
        if not isinstance(w_other, W_ModuleObject):
            return space.w_nil

        if self is w_other:
            return space.newint(0)

        other_is_subclass = space.send(self, "<", [w_other])

        if space.is_true(other_is_subclass):
            return space.newint(-1)
        elif other_is_subclass is space.w_nil:
            return space.w_nil
        else:
            return space.newint(1)

    @classdef.method("instance_method", name="symbol")
    def method_instance_method(self, space, name):
        return space.newmethod(name, self)

    @classdef.method("instance_methods", inherit="bool")
    def method_instance_methods(self, space, inherit=True):
        return space.newarray([
            space.newsymbol(sym)
            for sym in self.methods(space, inherit=inherit)
        ])

    @classdef.method("public_instance_methods", inherit="bool")
    def method_public_instance_methods(self, space, inherit=True):
        return space.newarray([
            space.newsymbol(sym)
            for sym in self.methods(space, visibility=W_FunctionObject.PUBLIC, inherit=inherit)
        ])

    @classdef.method("protected_instance_methods", inherit="bool")
    def method_protected_instance_methods(self, space, inherit=True):
        return space.newarray([
            space.newsymbol(sym)
            for sym in self.methods(space, visibility=W_FunctionObject.PROTECTED, inherit=inherit)
        ])

    @classdef.method("private_instance_methods", inherit="bool")
    def method_private_instance_methods(self, space, inherit=True):
        return space.newarray([
            space.newsymbol(sym)
            for sym in self.methods(space, visibility=W_FunctionObject.PRIVATE, inherit=inherit)
        ])

    @classdef.method("undef_method", name="symbol")
    def method_undef_method(self, space, name):
        w_method = self.find_method(space, name)
        if w_method is None or isinstance(w_method, UndefMethod):
            cls_name = space.obj_to_s(self)
            raise space.error(space.w_NameError,
                "undefined method `%s' for class `%s'" % (name, cls_name)
            )
        self.define_method(space, name, UndefMethod(name))
        return self

    @classdef.method("remove_method", name="symbol")
    @check_frozen()
    def method_remove_method(self, space, name):
        w_method = self._find_method_pure(space, name, self.version)
        if w_method is None or isinstance(w_method, UndefMethod):
            cls_name = space.obj_to_s(self)
            raise space.error(space.w_NameError,
                "method `%s' not defined in %s" % (name, cls_name)
            )
        del self.methods_w[name]
        self.mutated()
        self.method_removed(space, space.newsymbol(name))
        return self

    @classdef.method("method_added")
    def method_method_added(self, space, w_name):
        return space.w_nil

    @classdef.method("method_undefined")
    def method_method_undefined(self, space, w_name):
        return space.w_nil

    @classdef.method("method_removed")
    def method_method_removed(self, space, w_name):
        return space.w_nil

    @classdef.method("class_exec")
    @classdef.method("module_exec")
    def method_module_exec(self, space, args_w, block):
        if block is None:
            raise space.error(space.w_LocalJumpError, "no block given")
        return space.invoke_block(
            block.copy(
                space,
                w_self=self,
                lexical_scope=StaticScope(self, None)
            ),
            args_w
        )

########NEW FILE########
__FILENAME__ = nilobject
from topaz.module import ClassDef
from topaz.objects.objectobject import W_Object


class W_NilObject(W_Object):
    classdef = ClassDef("NilClass", W_Object.classdef)

    def is_true(self, space):
        return False

    def getsingletonclass(self, space):
        return space.getclassfor(W_NilObject)

    @classdef.method("nil?")
    def method_nilp(self, space):
        return space.w_true

    @classdef.method("to_s")
    def method_to_s(self, space):
        return space.newstr_fromstr("")

    @classdef.method("inspect")
    def method_inspect(self, space):
        return space.newstr_fromstr("nil")

    @classdef.method("to_i")
    def method_to_i(self, space):
        return space.newint(0)

    @classdef.method("to_f")
    def method_to_f(self, space):
        return space.newfloat(0.0)

    @classdef.method("to_a")
    def method_to_a(self, space):
        return space.newarray([])

    @classdef.method("&")
    def method_and(self, space, w_other):
        return space.w_false

    @classdef.method("|")
    @classdef.method("^")
    def method_or(self, space, w_other):
        return space.newbool(space.is_true(w_other))

########NEW FILE########
__FILENAME__ = numericobject
import math

from rpython.rlib.rfloat import round_away

from topaz.coerce import Coerce
from topaz.error import RubyError
from topaz.module import ClassDef
from topaz.modules.comparable import Comparable
from topaz.objects.objectobject import W_Object


class W_NumericObject(W_Object):
    classdef = ClassDef("Numeric", W_Object.classdef)
    classdef.include_module(Comparable)

    @staticmethod
    def retry_binop_coercing(space, w_recv, w_arg, binop, raise_error=True):
        w_ary = None
        try:
            w_ary = space.send(w_recv, "coerce", [w_arg])
        except RubyError as e:
            if not space.is_kind_of(e.w_value, space.w_StandardError):
                raise
            if raise_error:
                raise space.error(space.w_ArgumentError,
                    "comparison of %s with %s failed" % (
                        space.obj_to_s(space.getclass(w_recv)),
                        space.obj_to_s(space.getclass(w_arg))
                    )
                )
        if space.getclass(w_ary) is space.w_array:
            ary = space.listview(w_ary)
            if len(ary) == 2:
                return space.send(ary[1], binop, ary[:1])
        elif raise_error:
            raise space.error(space.w_TypeError, "coerce must return [x, y]")
        else:
            return None

    @classdef.singleton_method("allocate")
    def method_allocate(self, space):
        return W_NumericObject(space, self)

    @classdef.method("<=>")
    def method_comparator(self, space, w_other):
        if self == w_other:
            return space.newint(0)
        else:
            return space.w_nil

    @classdef.method("<=")
    def method_lte(self, space, w_other):
        w_result = space.send(self, "<=>", [w_other])
        return space.newbool(not (w_result is space.w_nil or space.int_w(w_result) > 0))

    @classdef.method("coerce")
    def method_coerce(self, space, w_other):
        if space.getclass(w_other) is space.getclass(self):
            return space.newarray([w_other, self])
        else:
            return space.newarray([space.send(self, "Float", [w_other]), self])

    @classdef.method("ceil")
    def method_ceil(self, space):
        return space.newint(int(math.ceil(Coerce.float(space, self))))

    @classdef.method("floor")
    def method_floor(self, space):
        return space.newint(int(math.floor(Coerce.float(space, self))))

    @classdef.method("round")
    def method_round(self, space):
        return space.newint(int(round_away(Coerce.float(space, self))))

    @classdef.method("quo")
    def method_quo(self, space):
        raise space.error(space.w_NotImplementedError, "Numeric#quo")

########NEW FILE########
__FILENAME__ = objectobject
import copy

from rpython.rlib import jit
from rpython.rlib.objectmodel import compute_unique_id

from topaz import mapdict
from topaz.module import ClassDef
from topaz.scope import StaticScope


class ObjectMetaclass(type):
    def __new__(cls, name, bases, attrs):
        new_cls = super(ObjectMetaclass, cls).__new__(cls, name, bases, attrs)
        if "classdef" in attrs:
            attrs["classdef"].cls = new_cls
        return new_cls


class W_Root(object):
    _attrs_ = []
    __metaclass__ = ObjectMetaclass

    def __deepcopy__(self, memo):
        obj = object.__new__(self.__class__)
        memo[id(self)] = obj
        return obj


class W_BaseObject(W_Root):
    _attrs_ = []

    classdef = ClassDef("BasicObject")

    def getclass(self, space):
        return space.getclassobject(self.classdef)

    def is_kind_of(self, space, w_cls):
        return w_cls.is_ancestor_of(self.getclass(space))

    def attach_method(self, space, name, func):
        w_cls = space.getsingletonclass(self)
        w_cls.define_method(space, name, func)

    def is_true(self, space):
        return True

    def find_const(self, space, name):
        raise space.error(space.w_TypeError,
            "%s is not a class/module" % space.str_w(space.send(self, "inspect"))
        )
    find_included_const = find_local_const = find_const

    @classdef.method("initialize")
    def method_initialize(self):
        return self

    @classdef.method("__id__")
    def method___id__(self, space):
        return space.newint(compute_unique_id(self))

    @classdef.method("method_missing")
    def method_method_missing(self, space, w_name, args_w):
        name = space.symbol_w(w_name)
        class_name = space.str_w(space.send(self.getclass(space), "to_s"))
        raise space.error(space.w_NoMethodError,
            "undefined method `%s' for %s" % (name, class_name)
        )

    @classdef.method("==")
    @classdef.method("equal?")
    def method_eq(self, space, w_other):
        return space.newbool(self is w_other)

    @classdef.method("!")
    def method_not(self, space):
        return space.newbool(not space.is_true(self))

    @classdef.method("!=")
    def method_ne(self, space, w_other):
        return space.newbool(
            not space.is_true(space.send(self, "==", [w_other]))
        )

    @classdef.method("__send__", method="str")
    def method_send(self, space, method, args_w, block):
        return space.send(self, method, args_w, block)

    @classdef.method("instance_eval", string="str", filename="str")
    def method_instance_eval(self, space, string=None, filename=None, w_lineno=None, block=None):
        if string is not None:
            if filename is None:
                filename = "instance_eval"
            if w_lineno is not None:
                lineno = space.int_w(w_lineno)
            else:
                lineno = 1
            return space.execute(string, self, StaticScope(space.getclass(self), None), filename, lineno)
        else:
            return space.invoke_block(block.copy(space, w_self=self), [])

    @classdef.method("singleton_method_removed")
    def method_singleton_method_removed(self, space, w_name):
        return space.w_nil

    @classdef.method("singleton_method_added")
    def method_singleton_method_added(self, space, w_name):
        return space.w_nil

    @classdef.method("singleton_method_undefined")
    def method_singleton_method_undefined(self, space, w_name):
        return space.w_nil

    @classdef.method("instance_exec")
    def method_instance_exec(self, space, args_w, block):
        if block is None:
            raise space.error(space.w_LocalJumpError, "no block given")

        if space.is_kind_of(self, space.w_symbol) or space.is_kind_of(self, space.w_numeric):
            self_klass = None
        else:
            self_klass = space.getsingletonclass(self)

        return space.invoke_block(
            block.copy(
                space,
                w_self=self,
                lexical_scope=StaticScope(self_klass, block.lexical_scope)
            ),
            args_w
        )


class W_RootObject(W_BaseObject):
    _attrs_ = []

    classdef = ClassDef("Object", W_BaseObject.classdef)

    @classdef.setup_class
    def setup_class(cls, space, w_cls):
        space.w_top_self = W_Object(space, w_cls)


class W_Object(W_RootObject):
    _attrs_ = ["map", "object_storage", "unboxed_storage"]

    def __init__(self, space, klass=None):
        if klass is None:
            klass = space.getclassfor(self.__class__)
        self.map = space.fromcache(mapdict.MapTransitionCache).get_class_node(klass)
        self.object_storage = None
        self.unboxed_storage = None

    def __deepcopy__(self, memo):
        obj = super(W_Object, self).__deepcopy__(memo)
        obj.map = copy.deepcopy(self.map, memo)
        obj.object_storage = copy.deepcopy(self.object_storage, memo)
        obj.unboxed_storage = copy.deepcopy(self.unboxed_storage, memo)
        return obj

    def getclass(self, space):
        return jit.promote(self.map).find(mapdict.ClassNode).getclass()

    def getsingletonclass(self, space):
        w_cls = jit.promote(self.map).find(mapdict.ClassNode).getclass()
        if w_cls.is_singleton:
            return w_cls
        w_cls = space.newclass(w_cls.name, w_cls, is_singleton=True, attached=self)
        self.map = self.map.change_class(space, w_cls)
        return w_cls

    def copy_singletonclass(self, space, w_other):
        w_cls = jit.promote(self.map).find(mapdict.ClassNode).getclass()
        assert not w_cls.is_singleton
        w_copy = space.newclass(w_cls.name, w_cls, is_singleton=True, attached=self)
        w_copy.methods_w.update(w_other.methods_w)
        w_copy.constants_w.update(w_other.constants_w)
        w_copy.included_modules = w_copy.included_modules + w_other.included_modules
        w_copy.mutated()

        self.map = self.map.change_class(space, w_copy)
        return w_cls

    def find_instance_var(self, space, name):
        node = jit.promote(self.map).find(mapdict.AttributeNode, name)
        if node is None:
            return None
        return node.read(space, self)

    def set_instance_var(self, space, name, w_value):
        node = jit.promote(self.map).find(mapdict.AttributeNode, name)
        if node is None:
            self.map = node = self.map.add(space, mapdict.AttributeNode.select_type(space, w_value), name, self)
        node.write(space, self, w_value)

    def copy_instance_vars(self, space, w_other):
        assert isinstance(w_other, W_Object)
        w_other.map.copy_attrs(space, w_other, self)

    def get_flag(self, space, name):
        node = jit.promote(self.map).find(mapdict.FlagNode, name)
        return space.w_false if node is None else node.read(space, self)

    def set_flag(self, space, name):
        node = jit.promote(self.map).find(mapdict.FlagNode, name)
        if node is None:
            self.map = node = self.map.add(space, mapdict.FlagNode, name, self)
        node.write(space, self, space.w_true)

    def unset_flag(self, space, name):
        node = jit.promote(self.map).find(mapdict.FlagNode, name)
        # Flags are by default unset, no need to add if unsetting
        if node is not None:
            node.write(space, self, space.w_false)

########NEW FILE########
__FILENAME__ = procobject
from topaz.module import ClassDef
from topaz.objects.objectobject import W_Object


class W_ProcObject(W_Object):
    classdef = ClassDef("Proc", W_Object.classdef)

    def __init__(self, space, bytecode, w_self, lexical_scope, cells, block,
                 parent_interp, top_parent_interp, regexp_match_cell,
                 is_lambda):
        W_Object.__init__(self, space)
        self.bytecode = bytecode
        self.w_self = w_self
        self.lexical_scope = lexical_scope
        self.cells = cells
        self.block = block
        self.parent_interp = parent_interp
        self.top_parent_interp = top_parent_interp
        self.regexp_match_cell = regexp_match_cell
        self.is_lambda = is_lambda

    def copy(self, space, w_self=None, lexical_scope=None, is_lambda=False):
        return W_ProcObject(
            space, self.bytecode,
            w_self or self.w_self,
            lexical_scope or self.lexical_scope,
            self.cells, self.block, self.parent_interp, self.top_parent_interp,
            self.regexp_match_cell,
            is_lambda or self.is_lambda
        )

    @classdef.singleton_method("new")
    def method_new(self, space, block):
        if block is None:
            raise space.error(space.w_ArgumentError, "tried to create Proc object without a block")
        return block.copy(space)

    method_allocate = classdef.undefine_allocator()

    @classdef.method("yield")
    @classdef.method("===")
    @classdef.method("[]")
    @classdef.method("call")
    def method_call(self, space, args_w, block):
        from topaz.interpreter import RaiseReturn, RaiseBreak

        try:
            return space.invoke_block(self, args_w, block_arg=block)
        except RaiseReturn as e:
            if self.is_lambda:
                return e.w_value
            else:
                raise
        except RaiseBreak as e:
            if self.is_lambda:
                return e.w_value
            else:
                raise space.error(space.w_LocalJumpError, "break from proc-closure")

    @classdef.method("lambda?")
    def method_lambda(self, space):
        return space.newbool(self.is_lambda)

    @classdef.method("arity")
    def method_arity(self, space):
        return space.newint(self.bytecode.arity(negative_defaults=self.is_lambda))

    @classdef.method("binding")
    def method_binding(self, space):
        return space.newbinding_fromblock(self)

########NEW FILE########
__FILENAME__ = randomobject
import os
import time

from rpython.rlib.rarithmetic import intmask
from rpython.rlib.rrandom import Random

from topaz.module import ClassDef
from topaz.objects.objectobject import W_Object
from topaz.objects.rangeobject import W_RangeObject
from topaz.coerce import Coerce


class W_RandomObject(W_Object):
    classdef = ClassDef("Random", W_Object.classdef)

    def __init__(self, space, seed=0, klass=None):
        W_Object.__init__(self, space, klass)
        self.w_seed = None
        self.random = Random(abs(seed))

    @classdef.setup_class
    def setup_class(cls, space, w_cls):
        default = space.send(w_cls, "new")
        space.set_const(w_cls, "DEFAULT", default)

    @classdef.singleton_method("allocate")
    def method_allocate(self, space):
        return W_RandomObject(space, 0, self)

    @classdef.method("initialize")
    def method_initialize(self, space, w_seed=None):
        self.srand(space, w_seed)

    @classdef.method("seed")
    def method_seed(self, space):
        return self.w_seed

    def srand(self, space, seed=None):
        previous_seed = self.w_seed
        if seed is None:
            seed = intmask(self._generate_seed())
        else:
            seed = Coerce.int(space, seed)
        self.w_seed = space.newint(seed)
        if previous_seed is None:
            value = space.newfloat(self.random.random())
        else:
            value = previous_seed
        self.random = Random(abs(seed))
        return value

    @classdef.method("rand")
    def method_rand(self, space, w_max=None):
        if w_max is None:
            return space.newfloat(self.random.random())
        elif space.is_kind_of(w_max, space.w_float):
            return self._rand_float(space, w_max)
        elif space.is_kind_of(w_max, space.getclassfor(W_RangeObject)):
            return self._rand_range(space, w_max)
        else:
            return self._rand_int(space, w_max)

    @classdef.singleton_method("rand")
    def method_singleton_rand(self, space, args_w):
        default = space.find_const(self, "DEFAULT")
        return space.send(default, "rand", args_w)

    def _rand_range(self, space, range):
        random = self.random.random()
        first = space.send(range, "first")
        last = space.send(range, "last")
        if space.is_true(space.send(range, "include?", [last])):
            last = space.send(last, "+", [space.newint(1)])
        diff = space.send(last, "-", [first])
        offset = space.send(diff, "*", [space.newfloat(random)])
        choice = space.send(offset, "+", [first])
        if (not space.is_kind_of(first, space.w_float) and
            not space.is_kind_of(last, space.w_float)):
            choice = space.send(choice, "to_i")
        return choice

    def _rand_float(self, space, float):
        random = self.random.random()
        max = Coerce.float(space, float)
        if max <= 0:
            raise space.error(space.w_ArgumentError, "invalid argument")
        return space.newfloat(random * max)

    def _rand_int(self, space, integer):
        random = self.random.random()
        max = Coerce.int(space, integer)
        if max <= 0:
            raise space.error(space.w_ArgumentError, "invalid argument")
        else:
            return space.newint(int(random * max))

    def _generate_seed(self):
        seed = 0
        if os.access('/dev/urandom', os.R_OK):
            file = os.open('/dev/urandom', os.R_OK, 0644)
            bytes = os.read(file, 4)
            os.close(file)
            for b in bytes:
                seed = seed * 0xff + ord(b)
        return seed + int(time.time()) + os.getpid()

########NEW FILE########
__FILENAME__ = rangeobject
from topaz.module import ClassDef
from topaz.modules.enumerable import Enumerable
from topaz.objects.objectobject import W_Object


class W_RangeObject(W_Object):
    classdef = ClassDef("Range", W_Object.classdef)
    classdef.include_module(Enumerable)

    def __init__(self, space, w_start, w_end, exclusive):
        W_Object.__init__(self, space)
        self.w_start = w_start
        self.w_end = w_end
        self.exclusive = exclusive

    @classdef.singleton_method("allocate")
    def method_allocate(self, space):
        return W_RangeObject(space, None, None, False)

    @classdef.method("initialize", excl="bool")
    def method_initialize(self, space, w_start, w_end, excl=False):
        if self.w_start is not None or self.w_end is not None:
            raise space.error(space.w_NameError, "`initialize' called twice")
        if space.send(w_start, "<=>", [w_end]) is space.w_nil:
            raise space.error(space.w_ArgumentError, "bad value for range")

        self.w_start = w_start
        self.w_end = w_end
        self.exclusive = excl

    @classdef.method("begin")
    def method_begin(self, space):
        return self.w_start

    @classdef.method("end")
    def method_end(self, space):
        return self.w_end

    @classdef.method("exclude_end?")
    def method_exclude_end(self, space):
        return space.newbool(self.exclusive)

########NEW FILE########
__FILENAME__ = regexpobject
from rpython.rlib.rsre import rsre_core

from topaz.coerce import Coerce
from topaz.module import ClassDef
from topaz.objects.objectobject import W_Object
from topaz.utils import regexp


RE_ESCAPE_TABLE = [chr(i) for i in xrange(256)]
RE_ESCAPE_TABLE[ord("\t")] = "\\t"
RE_ESCAPE_TABLE[ord("\n")] = "\\n"
RE_ESCAPE_TABLE[ord("\v")] = "\\v"
RE_ESCAPE_TABLE[ord("\f")] = "\\f"
RE_ESCAPE_TABLE[ord("\r")] = "\\r"
RE_ESCAPE_TABLE[ord(" ")] = "\\ "
RE_ESCAPE_TABLE[ord("#")] = "\\#"
RE_ESCAPE_TABLE[ord("$")] = "\\$"
RE_ESCAPE_TABLE[ord("(")] = "\\("
RE_ESCAPE_TABLE[ord(")")] = "\\)"
RE_ESCAPE_TABLE[ord("*")] = "\\*"
RE_ESCAPE_TABLE[ord("+")] = "\\+"
RE_ESCAPE_TABLE[ord("-")] = "\\-"
RE_ESCAPE_TABLE[ord(".")] = "\\."
RE_ESCAPE_TABLE[ord("?")] = "\\?"
RE_ESCAPE_TABLE[ord("[")] = "\\["
RE_ESCAPE_TABLE[ord("\\")] = "\\\\"
RE_ESCAPE_TABLE[ord("]")] = "\\]"
RE_ESCAPE_TABLE[ord("^")] = "\\^"
RE_ESCAPE_TABLE[ord("{")] = "\\{"
RE_ESCAPE_TABLE[ord("|")] = "\\|"
RE_ESCAPE_TABLE[ord("}")] = "\\}"


class RegexpCache(object):
    # TODO: this should use an LRU cache, and be elidable for the JIT.
    def __init__(self, space):
        self._contents = {}

    def contains(self, pattern, flags):
        return (pattern, flags) in self._contents

    def get(self, pattern, flags):
        return self._contents[pattern, flags]

    def set(self, pattern, flags, compiled_regexp):
        self._contents[pattern, flags] = compiled_regexp


class W_RegexpObject(W_Object):
    classdef = ClassDef("Regexp", W_Object.classdef)

    def __init__(self, space, source, flags):
        W_Object.__init__(self, space)
        self.set_source(space, source, flags)

    @classdef.setup_class
    def setup_class(cls, space, w_cls):
        space.globals.define_virtual("$~",
            cls._get_regexp_match,
            cls._set_regexp_match,
        )
        space.globals.define_virtual("$1", cls._create_regexp_match_getter(1))
        space.globals.define_virtual("$2", cls._create_regexp_match_getter(2))
        space.globals.define_virtual("$3", cls._create_regexp_match_getter(3))
        space.globals.define_virtual("$4", cls._create_regexp_match_getter(4))
        space.globals.define_virtual("$5", cls._create_regexp_match_getter(5))
        space.globals.define_virtual("$6", cls._create_regexp_match_getter(6))
        space.globals.define_virtual("$7", cls._create_regexp_match_getter(7))
        space.globals.define_virtual("$8", cls._create_regexp_match_getter(8))
        space.globals.define_virtual("$9", cls._create_regexp_match_getter(9))
        space.globals.define_virtual("$&", cls._create_regexp_match_getter(0))
        space.globals.define_virtual("$+", cls._get_last_match)
        space.globals.define_virtual("$`", cls._get_pre_match)
        space.globals.define_virtual("$'", cls._get_post_match)
        space.set_const(w_cls, "IGNORECASE", space.newint(regexp.IGNORE_CASE))
        space.set_const(w_cls, "EXTENDED", space.newint(regexp.EXTENDED))
        space.set_const(w_cls, "MULTILINE", space.newint(regexp.DOT_ALL))
        space.set_const(w_cls, "FIXEDENCODING", space.newint(regexp.FIXED_ENCODING))
        space.set_const(w_cls, "NOENCODING", space.newint(regexp.NO_ENCODING))

    @staticmethod
    def _get_regexp_cell(space):
        return space.getexecutioncontext().gettoprubyframe().regexp_match_cell

    @staticmethod
    def _get_regexp_match(space):
        return W_RegexpObject._get_regexp_cell(space).get(space, None, 0)

    @staticmethod
    def _set_regexp_match(space, w_match):
        if (w_match is not space.w_nil and
            not space.is_kind_of(w_match, space.getclassfor(W_MatchDataObject))):
            raise space.error(space.w_TypeError, "wrong argument type %s (expected MatchData)" % space.getclass(w_match).name)
        W_RegexpObject._get_regexp_cell(space).set(space, None, 0, w_match)

    @staticmethod
    def _create_regexp_match_getter(n):
        def getter(space):
            w_match = W_RegexpObject._get_regexp_match(space)
            if w_match is None:
                return space.w_nil
            else:
                return space.send(w_match, "[]", [space.newint(n)])
        return getter

    @staticmethod
    def _get_last_match(space):
        w_match = W_RegexpObject._get_regexp_match(space)
        if w_match is None:
            return space.w_nil
        else:
            w_size = space.send(w_match, "size")
            w_last = space.send(w_size, "-", [space.newint(1)])
            return space.send(w_match, "[]", [w_last])

    @staticmethod
    def _get_pre_match(space):
        w_match = W_RegexpObject._get_regexp_match(space)
        if w_match is None:
            return space.w_nil
        else:
            return space.send(w_match, "pre_match")

    @staticmethod
    def _get_post_match(space):
        w_match = W_RegexpObject._get_regexp_match(space)
        if w_match is None:
            return space.w_nil
        else:
            return space.send(w_match, "post_match")

    def _check_initialized(self, space):
        if self.source is None:
            raise space.error(space.w_TypeError, "uninitialized Regexp")

    def set_source(self, space, source, flags):
        if source is not None:
            cache = space.fromcache(RegexpCache)
            self.source = source
            code, flags, groupcount, groupindex, indexgroup, group_offsets = regexp.compile(cache, source, flags)
            self.code = code
            self.flags = flags
            self.groupcount = groupcount
            self.groupindex = groupindex
            self.indexgroup = indexgroup
            self.group_offsets = group_offsets

    def make_ctx(self, s, offset=0):
        assert offset >= 0
        endpos = len(s)
        return rsre_core.StrMatchContext(self.code, s, offset, endpos, self.flags)

    def get_match_result(self, space, ctx, target, found):
        if found:
            w_match = W_MatchDataObject(space, self, ctx, target)
        else:
            w_match = space.w_nil
        space.globals.set(space, "$~", w_match)
        return w_match

    @classdef.singleton_method("allocate")
    def method_allocate(self, space):
        return W_RegexpObject(space, None, 0)

    @classdef.singleton_method("compile")
    def method_compile(self, space, args_w):
        w_obj = space.send(self, "allocate")
        return space.send(w_obj, "initialize", args_w)

    @classdef.method("initialize", flags="int")
    def method_initialize(self, space, w_source, flags=0):
        if isinstance(w_source, W_RegexpObject):
            self.set_source(space, w_source.source, w_source.flags)
        else:
            try:
                self.set_source(space, Coerce.str(space, w_source), flags)
            except regexp.RegexpError as e:
                raise space.error(space.w_RegexpError, str(e))
        return self

    @classdef.method("to_s")
    def method_to_s(self, space):
        flags = missing_flags = ""
        for c, f in regexp.FLAGS_MAP:
            if self.flags & f:
                flags += c
            else:
                missing_flags += c
        return space.newstr_fromstr("(?%s-%s:%s)" % (flags, missing_flags, self.source))

    @classdef.method("eql?")
    @classdef.method("==")
    def method_equal(self, space, w_other):
        if self is w_other:
            return space.w_true
        if not isinstance(w_other, W_RegexpObject):
            return space.w_false
        self._check_initialized(space)
        w_other._check_initialized(space)
        return space.newbool(self.source == w_other.source and (self.flags | regexp.NO_ENCODING) == (w_other.flags | regexp.NO_ENCODING))

    @classdef.method("source")
    def method_source(self, space):
        self._check_initialized(space)
        return space.newstr_fromstr(self.source)

    @classdef.method("=~")
    def method_match_operator(self, space, w_s):
        if w_s is space.w_nil:
            return space.w_nil
        s = Coerce.str(space, w_s)
        ctx = self.make_ctx(s)
        matched = rsre_core.search_context(ctx)
        self.get_match_result(space, ctx, s, matched)
        if matched:
            return space.newint(ctx.match_start)
        else:
            return space.w_nil

    @classdef.method("match")
    def method_match(self, space, w_s, w_offset=None):
        if w_s is space.w_nil:
            return space.w_nil
        s = Coerce.str(space, w_s)
        if w_offset is not None:
            offset = Coerce.int(space, w_offset)
        else:
            offset = 0
        ctx = self.make_ctx(s, offset)
        matched = rsre_core.search_context(ctx)
        return self.get_match_result(space, ctx, s, matched)

    @classdef.method("===", s="str")
    def method_eqeqeq(self, space, s):
        ctx = self.make_ctx(s)
        matched = rsre_core.search_context(ctx)
        self.get_match_result(space, ctx, s, matched)
        return space.newbool(matched)

    @classdef.method("casefold?")
    def method_casefoldp(self, space):
        return space.newbool(bool(self.flags & regexp.IGNORE_CASE))

    @classdef.singleton_method("quote", string="str")
    @classdef.singleton_method("escape", string="str")
    def method_escape(self, space, string):
        result = []
        for ch in string:
            result += RE_ESCAPE_TABLE[ord(ch)]
        return space.newstr_fromchars(result)

    @classdef.method("options")
    def method_options(self, space):
        return space.newint(self.flags)

    @classdef.method("fixed_encoding?")
    def method_fixed_encodingp(self, space):
        return space.newbool(bool(self.flags & regexp.FIXED_ENCODING))


class W_MatchDataObject(W_Object):
    classdef = ClassDef("MatchData", W_Object.classdef)

    def __init__(self, space, regexp, ctx, target):
        W_Object.__init__(self, space)
        self.regexp = regexp
        self.ctx = ctx
        self.target = target
        self._flatten_cache = None

    def size(self):
        offset = self.regexp.group_offsets[-1] if self.regexp.group_offsets else 0
        return self.regexp.groupcount + 1 - offset

    def flatten_marks(self):
        if self._flatten_cache is None:
            self._flatten_cache = self._build_flattened_marks(self.ctx, self.regexp.groupcount)
        return self._flatten_cache

    def _build_flattened_marks(self, ctx, num_groups):
        if num_groups == 0:
            return None
        result = [-1] * (2 * num_groups)
        mark = ctx.match_marks
        while mark is not None:
            index = mark.gid
            if result[index] == -1:
                result[index] = mark.position
            mark = mark.prev
        return result

    def get_span(self, n):
        n += self.regexp.group_offsets[n - 1]
        fmarks = self.flatten_marks()
        idx = 2 * (n - 1)
        assert idx >= 0
        return fmarks[idx], fmarks[idx + 1]

    @classdef.method("regexp")
    def method_regexp(self, space):
        return self.regexp

    @classdef.method("string")
    def method_string(self, space):
        res = space.newstr_fromstr(self.target)
        space.send(res, "freeze")
        return res

    @classdef.method("[]", n="int")
    def method_subscript(self, space, n):
        if n == 0:
            start, end = self.ctx.match_start, self.ctx.match_end
        elif 1 <= n < self.size():
            start, end = self.get_span(n)
        else:
            return space.w_nil
        if 0 <= start <= end:
            return space.newstr_fromstr(self.ctx._string[start:end])
        else:
            return space.w_nil

    @classdef.method("captures")
    def method_captures(self, space):
        res_w = []
        for i in xrange(1, self.size()):
            res_w.append(space.send(self, "[]", [space.newint(i)]))
        return space.newarray(res_w)

    @classdef.method("to_a")
    def method_to_a(self, space):
        res_w = []
        for i in xrange(self.size()):
            res_w.append(space.send(self, "[]", [space.newint(i)]))
        return space.newarray(res_w)

    @classdef.method("begin", n="int")
    def method_begin(self, space, n):
        if n == 0:
            start, _ = self.ctx.match_start, self.ctx.match_end
        elif 1 <= n < self.size():
            start, _ = self.get_span(n)
        else:
            raise space.error(space.w_IndexError, "index %d out of matches" % n)
        return space.newint(start)

    @classdef.method("end", n="int")
    def method_end(self, space, n):
        if n == 0:
            _, end = self.ctx.match_start, self.ctx.match_end
        elif 1 <= n < self.size():
            _, end = self.get_span(n)
        else:
            raise space.error(space.w_IndexError, "index %d out of matches" % n)
        return space.newint(end)

    @classdef.method("length")
    @classdef.method("size")
    def method_size(self, space):
        return space.newint(self.size())

    @classdef.method("pre_match")
    def method_pre_match(self, space):
        stop = self.ctx.match_start
        assert stop > 0
        return space.newstr_fromstr(self.ctx._string[:stop])

    @classdef.method("post_match")
    def method_post_match(self, space):
        return space.newstr_fromstr(self.ctx._string[self.ctx.match_end:])

    @classdef.method("values_at")
    def method_values_at(self, space, args_w):
        return space.send(
            space.send(self, "to_a"), "values_at", args_w
        )

########NEW FILE########
__FILENAME__ = stringobject
import copy
import string
import math

from rpython.rlib import jit
from rpython.rlib.objectmodel import newlist_hint, compute_hash
from rpython.rlib.rarithmetic import intmask, ovfcheck
from rpython.rlib.rbigint import rbigint
from rpython.rlib.rerased import new_static_erasing_pair
from rpython.rlib.rsre import rsre_core
from rpython.rlib.rstring import split

from topaz.coerce import Coerce
from topaz.module import ClassDef, check_frozen
from topaz.modules.comparable import Comparable
from topaz.objects.objectobject import W_Object
from topaz.utils.formatting import StringFormatter


RADIX_MAP = {
    "X": 16,
    "x": 16,

    "D": 10,
    "d": 10,

    "O": 8,
    "o": 8,

    "B": 2,
    "b": 2,
}


def create_trans_table(source, replacement, inv=False):
    src = expand_trans_str(source, len(source), inv)
    repl = expand_trans_str(replacement, len(src))
    table = [chr(i) for i in xrange(256)]
    for i, c in enumerate(src):
        table[ord(c)] = repl[i]
    return table


def expand_trans_str(source, res_len, inv=False):
    # check the source for range definitions
    # and insert the missing characters
    expanded_source = []
    char = ""
    for i in range(res_len):
        if i < len(source):
            char = source[i]
        if char == "-":
            # expand the range
            assert 0 < i < len(source) - 1
            range_beg = ord(source[i - 1])
            range_end = ord(source[i + 1])
            for j in range(range_beg + 1, range_end - 1):
                expanded_source.append(chr(j))
        elif char:
            expanded_source.append(char[0])

    if inv:
        inverted_source = []
        # invert the source
        for i in range(256):
            if chr(i) not in expanded_source:
                inverted_source.append(chr(i))
        return inverted_source

    return expanded_source


class StringStrategy(object):
    def __init__(self, space):
        pass

    def __deepcopy__(self, memo):
        memo[id(self)] = result = object.__new__(self.__class__)
        return result


class ConstantStringStrategy(StringStrategy):
    erase, unerase = new_static_erasing_pair("constant")

    def str_w(self, storage):
        return self.unerase(storage)

    def liststr_w(self, storage):
        strvalue = self.unerase(storage)
        return [c for c in strvalue]

    def length(self, storage):
        return len(self.unerase(storage))

    def getitem(self, storage, idx):
        return self.unerase(storage)[idx]

    def getslice(self, space, storage, start, end):
        return space.newstr_fromstr(self.unerase(storage)[start:end])

    def hash(self, storage):
        return compute_hash(self.unerase(storage))

    def copy(self, storage):
        return storage

    def to_mutable(self, space, s):
        s.strategy = strategy = space.fromcache(MutableStringStrategy)
        s.str_storage = strategy.erase(self.liststr_w(s.str_storage))

    def extend_into(self, src_storage, dst_storage):
        dst_storage += self.unerase(src_storage)

    def mul(self, space, storage, times):
        return space.newstr_fromstr(self.unerase(storage) * times)


class MutableStringStrategy(StringStrategy):
    erase, unerase = new_static_erasing_pair("mutable")

    def str_w(self, storage):
        return "".join(self.unerase(storage))

    def liststr_w(self, storage):
        return self.unerase(storage)

    def length(self, storage):
        return len(self.unerase(storage))

    def getitem(self, storage, idx):
        return self.unerase(storage)[idx]

    def getslice(self, space, storage, start, end):
        return space.newstr_fromchars(self.unerase(storage)[start:end])

    def delslice(self, space, storage, start, end):
        del self.unerase(storage)[start:end]

    def hash(self, storage):
        storage = self.unerase(storage)
        length = len(storage)
        if length == 0:
            return -1
        x = ord(storage[0]) << 7
        i = 0
        while i < length:
            x = intmask((1000003 * x) ^ ord(storage[i]))
            i += 1
        x ^= length
        return intmask(x)

    def copy(self, storage):
        return self.erase(self.unerase(storage)[:])

    def to_mutable(self, space, s):
        pass

    def extend_into(self, src_storage, dst_storage):
        dst_storage += self.unerase(src_storage)

    def clear(self, s):
        storage = self.unerase(s.str_storage)
        del storage[:]

    def mul(self, space, storage, times):
        return space.newstr_fromchars(self.unerase(storage) * times)

    def reverse(self, storage):
        storage = self.unerase(storage)
        storage.reverse()

    def swapcase(self, storage):
        storage = self.unerase(storage)
        changed = False
        for i, c in enumerate(storage):
            if ord("A") <= ord(c) <= ord("Z"):
                new_c = c.lower()
                changed = True
            elif ord("a") <= ord(c) <= ord("z"):
                new_c = c.upper()
                changed = True
            else:
                new_c = c
            storage[i] = new_c
        return changed

    def downcase(self, storage):
        storage = self.unerase(storage)
        changed = False
        for i, c in enumerate(storage):
            new_c = c.lower()
            changed |= (c != new_c)
            storage[i] = new_c
        return changed

    def upcase(self, storage):
        storage = self.unerase(storage)
        changed = False
        for i, c in enumerate(storage):
            new_c = c.upper()
            changed |= (c != new_c)
            storage[i] = new_c
        return changed

    def capitalize(self, storage):
        storage = self.unerase(storage)
        changed = False
        for i, c in enumerate(storage):
            if i == 0:
                new_c = c.upper()
            else:
                new_c = c.lower()
            changed |= (c != new_c)
            storage[i] = new_c
        return changed

    def chomp(self, storage, newline=None):
        storage = self.unerase(storage)
        changed = False
        linebreaks = ["\n", "\r"]
        if len(storage) == 0:
            return changed
        elif newline is not None and len(newline) == 0:
            ch = storage[-1]
            i = len(storage) - 1
            if ch != "\r":
                while i >= 1 and ch in linebreaks:
                    i -= 1
                    ch = storage[i]
            if i < len(storage) - 1:
                i += 1
                changed = True
                if i > 0:
                    del storage[i:]
                else:
                    del storage[:]
        elif newline is not None and len(storage) >= len(newline):
            for i in xrange(len(newline) - 1, -1, -1):
                if newline[i] != storage[len(storage) - len(newline) + i]:
                    return changed
            start = len(storage) - len(newline)
            assert start >= 0
            del storage[start:]
            changed = True
        elif newline is None:
            ch = storage[-1]
            i = len(storage) - 1
            while i >= 0 and linebreaks and ch in linebreaks:
                linebreaks.remove(ch)
                i -= 1
                ch = storage[i]
            if i < len(storage) - 1:
                i += 1
                changed = True
                if i > 0:
                    del storage[i:]
                else:
                    del storage[:]
        return changed

    def chop(self, storage):
        storage = self.unerase(storage)
        if len(storage) == 0:
            return False
        elif storage[-1] == "\n" and len(storage) >= 2 and storage[-2] == "\r":
            idx = len(storage) - 2
            assert idx >= 0
            del storage[idx:]
            return True
        else:
            del storage[-1]
            return True

    def succ(self, storage):
        storage = self.unerase(storage)
        if len(storage) == 0:
            return

        carry = "\0"
        has_alnums = False
        last_alnum = 0
        start = len(storage) - 1

        while start >= 0:
            ch = storage[start]
            if ch in string.letters or ch in string.digits:
                has_alnums = True
                if ch == "9":
                    carry = "1"
                    storage[start] = "0"
                elif ch == "z":
                    carry = "a"
                    storage[start] = "a"
                elif ch == "Z":
                    carry = "A"
                    storage[start] = "A"
                else:
                    storage[start] = chr(ord(ch) + 1)
                    carry = "\0"

                if carry == "\0":
                    break
                last_alnum = start
            start -= 1

        if not has_alnums:
            start = len(storage) - 1
            carry = "\1"

            while start >= 0:
                ch = storage[start]
                if ord(ch) >= 255:
                    storage[start] = "\0"
                else:
                    storage[start] = chr(ord(ch) + 1)
                    break
                start -= 1

        if start < 0 and carry != "\0":
            last_alnum_ch = storage[last_alnum]
            storage[last_alnum] = carry
            storage.insert(last_alnum + 1, last_alnum_ch)

    def insert(self, storage, idx, other):
        storage = self.unerase(storage)
        for char in other:
            storage.insert(idx, char)
            idx += 1

    def replaceitem(self, storage, idx, char):
        storage = self.unerase(storage)
        storage[idx] = char

    def strip(self, storage):
        storage = self.unerase(storage)
        if not storage:
            return False

        shift = 0
        while shift < len(storage) and storage[shift].isspace():
            shift += 1
        if shift == len(storage):
            del storage[:]
            return True

        pop = len(storage)
        while pop > 0 and storage[pop - 1].isspace() or storage[pop - 1] == '\0':
            pop -= 1

        if pop < len(storage) or shift > 0:
            end = pop
            new_len = end - shift
            assert end >= 0
            assert new_len >= 0
            storage[0:new_len] = storage[shift:end]
            del storage[new_len:]
            return True
        else:
            return False


class W_StringObject(W_Object):
    classdef = ClassDef("String", W_Object.classdef)
    classdef.include_module(Comparable)

    def __init__(self, space, storage, strategy, klass=None):
        W_Object.__init__(self, space, klass)
        self.str_storage = storage
        self.strategy = strategy

    def __deepcopy__(self, memo):
        obj = super(W_StringObject, self).__deepcopy__(memo)
        obj.str_storage = copy.deepcopy(self.str_storage, memo)
        obj.strategy = copy.deepcopy(self.strategy, memo)
        return obj

    @staticmethod
    def newstr_fromstr(space, strvalue):
        strategy = space.fromcache(ConstantStringStrategy)
        storage = strategy.erase(strvalue)
        return W_StringObject(space, storage, strategy)

    @staticmethod
    @jit.look_inside_iff(lambda space, strs_w: jit.isconstant(len(strs_w)))
    def newstr_fromstrs(space, strs_w):
        total_length = 0
        for w_item in strs_w:
            assert isinstance(w_item, W_StringObject)
            total_length += w_item.length()

        storage = newlist_hint(total_length)
        for w_item in strs_w:
            assert isinstance(w_item, W_StringObject)
            w_item.strategy.extend_into(w_item.str_storage, storage)
        return space.newstr_fromchars(storage)

    @staticmethod
    def newstr_fromchars(space, chars):
        strategy = space.fromcache(MutableStringStrategy)
        storage = strategy.erase(chars)
        return W_StringObject(space, storage, strategy)

    def str_w(self, space):
        return self.strategy.str_w(self.str_storage)

    def symbol_w(self, space):
        return self.str_w(space)

    def liststr_w(self, space):
        return self.strategy.liststr_w(self.str_storage)

    def length(self):
        return self.strategy.length(self.str_storage)

    def copy(self, space):
        return W_StringObject(space, self.strategy.copy(self.str_storage), self.strategy)

    def replace(self, space, chars):
        strategy = space.fromcache(MutableStringStrategy)
        self.str_storage = strategy.erase(chars)
        self.strategy = strategy

    def extend(self, space, w_other):
        self.strategy.to_mutable(space, self)
        strategy = self.strategy
        assert isinstance(strategy, MutableStringStrategy)
        storage = strategy.unerase(self.str_storage)
        w_other.strategy.extend_into(w_other.str_storage, storage)

    def clear(self, space):
        self.strategy.to_mutable(space, self)
        self.strategy.clear(self)

    def tr_trans(self, space, source, replacement, squeeze):
        change_made = False
        string = space.str_w(self)
        new_string = []
        is_negative_set = len(source) > 1 and source[0] == "^"
        if is_negative_set:
            source = source[1:]

        trans_table = create_trans_table(source, replacement, is_negative_set)

        if squeeze:
            last_repl = ""
            for char in string:
                repl = trans_table[ord(char)]
                if last_repl == repl:
                    continue
                if repl != char:
                    last_repl = repl
                    if not change_made:
                        change_made = True
                new_string.append(repl)
        else:
            for char in string:
                repl = trans_table[ord(char)]
                if not change_made and repl != char:
                    change_made = True
                new_string.append(repl)

        return new_string if change_made else None

    @classdef.singleton_method("allocate")
    def singleton_method_allocate(self, space):
        strategy = space.fromcache(ConstantStringStrategy)
        storage = strategy.erase("")
        return W_StringObject(space, storage, strategy, self)

    @classdef.method("initialize")
    @check_frozen()
    def method_initialize(self, space, w_s=None):
        if w_s is not None:
            w_s = space.convert_type(w_s, space.w_string, "to_str")
            assert isinstance(w_s, W_StringObject)
            self.strategy = w_s.strategy
            self.str_storage = w_s.strategy.copy(w_s.str_storage)
        return self

    @classdef.method("initialize_copy")
    def method_initialize_copy(self, space, w_other):
        assert isinstance(w_other, W_StringObject)
        self.strategy = w_other.strategy
        self.str_storage = w_other.strategy.copy(w_other.str_storage)
        return self

    @classdef.method("to_str")
    @classdef.method("to_s")
    def method_to_s(self, space):
        return self

    @classdef.method("ord")
    def method_ord(self, space):
        if self.length() == 0:
            raise space.error(space.w_ArgumentError, "empty string")
        return space.newint(ord(self.strategy.getitem(self.str_storage, 0)))

    @classdef.method("inspect")
    def method_inspect(self, space):
        s = space.newstr_fromstr('"%s"' % self.str_w(space))
        space.infect(s, self)
        return s

    @classdef.method("+")
    def method_plus(self, space, w_obj):
        w_other = space.convert_type(w_obj, space.w_string, "to_str")
        assert isinstance(w_other, W_StringObject)
        total_size = self.length() + w_other.length()
        s = space.newstr_fromchars(newlist_hint(total_size))
        s.extend(space, self)
        s.extend(space, w_other)
        space.infect(s, self)
        space.infect(s, w_other)
        return s

    @classdef.method("*", times="int")
    def method_times(self, space, times):
        if times < 0:
            raise space.error(space.w_ArgumentError, "negative argument")
        res = self.strategy.mul(space, self.str_storage, times)
        space.infect(res, self)
        return res

    @classdef.method("<<")
    @classdef.method("concat")
    @check_frozen()
    def method_lshift(self, space, w_other):
        if space.is_kind_of(w_other, space.w_fixnum):
            w_other = space.send(w_other, "chr")
        else:
            w_other = space.convert_type(w_other, space.w_string, "to_str")
        assert isinstance(w_other, W_StringObject)
        self.extend(space, w_other)
        space.infect(self, w_other)
        return self

    @classdef.method("bytesize")
    @classdef.method("size")
    @classdef.method("length")
    def method_length(self, space):
        return space.newint(self.length())

    @classdef.method("hash")
    def method_hash(self, space):
        return space.newint(self.strategy.hash(self.str_storage))

    @classdef.method("[]")
    @classdef.method("slice")
    def method_subscript(self, space, w_idx, w_count=None):
        start, end, as_range, nil = space.subscript_access(self.length(), w_idx, w_count=w_count)
        if nil:
            return space.w_nil
        elif as_range:
            assert start >= 0
            assert end >= 0
            return self.strategy.getslice(space, self.str_storage, start, end)
        else:
            return space.newstr_fromstr(self.strategy.getitem(self.str_storage, start))

    @classdef.method("slice!")
    @check_frozen()
    def method_slice_i(self, space, w_idx, w_count=None):
        start, end, as_range, nil = space.subscript_access(self.length(), w_idx, w_count=w_count)
        if nil:
            return space.w_nil
        elif as_range:
            assert start >= 0
            assert end >= 0
            self.strategy.to_mutable(space, self)
            w_string = self.strategy.getslice(space, self.str_storage, start, end)
            self.strategy.delslice(space, self.str_storage, start, end)
            return w_string
        else:
            assert start >= 0
            self.strategy.to_mutable(space, self)
            w_string = self.strategy.getslice(space, self.str_storage, start, start + 1)
            self.strategy.delslice(space, self.str_storage, start, start + 1)
            return w_string

    @classdef.method("<=>")
    def method_comparator(self, space, w_other):
        if isinstance(w_other, W_StringObject):
            s1 = space.str_w(self)
            s2 = space.str_w(w_other)
            if s1 < s2:
                return space.newint(-1)
            elif s1 == s2:
                return space.newint(0)
            elif s1 > s2:
                return space.newint(1)
        else:
            if space.respond_to(w_other, "to_str") and space.respond_to(w_other, "<=>"):
                tmp = space.send(w_other, "<=>", [self])
                if tmp is not space.w_nil:
                    return space.newint(-space.int_w(tmp))
            return space.w_nil

    @classdef.method("to_sym")
    @classdef.method("intern")
    def method_to_sym(self, space):
        return space.newsymbol(space.str_w(self))

    @classdef.method("clear")
    @check_frozen()
    def method_clear(self, space):
        self.clear(space)
        return self

    @classdef.method("ljust", integer="int", padstr="str")
    def method_ljust(self, space, integer, padstr=" "):
        if not padstr:
            raise space.error(space.w_ArgumentError, "zero width padding")
        elif integer <= self.length():
            return self.copy(space)
        else:
            pad_len = integer - self.length() - 1
            assert pad_len >= 0
            chars = []
            chars += space.str_w(self)
            for i in xrange(pad_len / len(padstr)):
                chars += padstr
            chars += padstr[:pad_len % len(padstr) + 1]
            return space.newstr_fromchars(chars)

    @classdef.method("rjust", integer="int", padstr="str")
    def method_rjust(self, space, integer, padstr=" "):
        if not padstr:
            raise space.error(space.w_ArgumentError, "zero width padding")
        elif integer <= self.length():
            return self.copy(space)
        else:
            pad_len = integer - self.length() - 1
            assert pad_len >= 0
            chars = []
            for i in xrange(pad_len / len(padstr)):
                chars += padstr
            chars += padstr[:pad_len % len(padstr) + 1]
            chars += space.str_w(self)
            return space.newstr_fromchars(chars)

    def search_context(self, space, ctx):
        try:
            return rsre_core.search_context(ctx)
        except rsre_core.Error, e:
            raise space.error(space.w_RuntimeError, e.msg)

    @classdef.method("index", offset="int")
    def method_index(self, space, w_sub, offset=0):
        if offset < 0 or offset >= self.length():
            return space.w_nil
        elif space.is_kind_of(w_sub, space.w_string):
            return space.newint(space.str_w(self).find(space.str_w(w_sub), offset))
        elif space.is_kind_of(w_sub, space.w_regexp):
            ctx = w_sub.make_ctx(space.str_w(self), offset=offset)
            if self.search_context(space, ctx):
                return space.newint(ctx.match_start)
            else:
                return space.newint(-1)
        else:
            raise space.error(
                space.w_TypeError,
                "type mismatch: %s given" % space.obj_to_s(space.getclass(w_sub))
            )

    @classdef.method("rindex", end="int")
    def method_rindex(self, space, w_sub, end=0):
        if end < 0:
            end += self.length()
        else:
            end = self.length()
        if end < 0:
            return space.w_nil

        idx = -1
        if space.is_kind_of(w_sub, space.w_string):
            idx = space.str_w(self).rfind(space.str_w(w_sub), 0, end + 1)
        elif space.is_kind_of(w_sub, space.w_regexp):
            ctx = w_sub.make_ctx(space.str_w(self))
            idx = -1
            while self.search_context(space, ctx):
                if ctx.match_start > end:
                    break
                else:
                    idx = ctx.match_start
                ctx.reset(idx + 1)
        else:
            raise space.error(
                space.w_TypeError,
                "type mismatch: %s given" % space.obj_to_s(space.getclass(w_sub))
            )
        if idx < 0:
            return space.w_nil
        else:
            return space.newint(idx)

    @classdef.method("split", limit="int")
    def method_split(self, space, w_sep=None, limit=0):
        if w_sep is None:
            res_w = []
            i = 0
            limit -= 1
            s = space.str_w(self)
            while True:
                while i < len(s):
                    if not s[i].isspace():
                        break
                    i += 1
                else:
                    break
                if limit == 0:
                    j = len(s)
                else:
                    j = i + 1
                    while j < len(s) and not s[j].isspace():
                        j += 1
                    limit -= 1
                res_w.append(space.newstr_fromstr(s[i:j]))
                i = j + 1
            return space.newarray(res_w)
        elif space.is_kind_of(w_sep, space.w_string):
            sep = space.str_w(w_sep)
            if sep:
                return space.newarray([
                    space.newstr_fromstr(s) for s in split(space.str_w(self), sep, limit - 1)
                ])
            else:
                if limit:
                    raise space.error(space.w_NotImplementedError, "String#split with empty string and limit")
                return space.newarray([
                    space.newstr_fromstr(self.strategy.getitem(self.str_storage, i))
                    for i in xrange(self.length())
                ])
        elif space.is_kind_of(w_sep, space.w_regexp):
            results_w = []
            n = 0
            last = 0
            string = space.str_w(self)
            ctx = w_sep.make_ctx(string)
            w_match = w_sep.get_match_result(space, ctx, string, found=True)

            while limit <= 0 or n + 1 < limit:
                if not self.search_context(space, ctx):
                    break
                elif ctx.match_start == ctx.match_end:
                    if ctx.match_start == ctx.end:
                        break
                    results_w.append(space.newstr_fromstr(string[last]))
                    last = ctx.match_end + 1
                else:
                    results_w.append(space.newstr_fromstr(string[last:ctx.match_start]))
                    for num in xrange(1, w_match.size(), 1):
                        begin, end = w_match.get_span(num)
                        begin += last
                        end += last
                        assert begin >= 0
                        assert end >= 0
                        results_w.append(space.newstr_fromstr(string[begin:end]))
                    last = ctx.match_end
                n += 1
                ctx.reset(last)

            if len(string) > last:
                results_w.append(space.newstr_fromstr(string[last:]))
            if limit < 0 or len(results_w) < limit:
                results_w.append(space.newstr_fromstr(""))
            return space.newarray(results_w)

        else:
            raise space.error(
                space.w_TypeError,
                "wrong argument type %s (expected Regexp)" % (
                    space.obj_to_s(space.getclass(w_sep))
                )
            )

    @classdef.method("swapcase!")
    @check_frozen()
    def method_swapcase_i(self, space):
        self.strategy.to_mutable(space, self)
        changed = self.strategy.swapcase(self.str_storage)
        return self if changed else space.w_nil

    @classdef.method("upcase!")
    @check_frozen()
    def method_upcase_i(self, space):
        self.strategy.to_mutable(space, self)
        changed = self.strategy.upcase(self.str_storage)
        return self if changed else space.w_nil

    @classdef.method("downcase!")
    @check_frozen()
    def method_downcase_i(self, space):
        self.strategy.to_mutable(space, self)
        changed = self.strategy.downcase(self.str_storage)
        return self if changed else space.w_nil

    @classdef.method("capitalize!")
    @check_frozen()
    def method_capitalize_i(self, space):
        self.strategy.to_mutable(space, self)
        changed = self.strategy.capitalize(self.str_storage)
        return self if changed else space.w_nil

    def _digits(self, s, i, radix):
        number_seen = False
        while i < len(s):
            c = ord(s[i])
            if c == ord("_") and number_seen:
                i += 1
                continue
            if ord("a") <= c <= ord("z"):
                digit = c - ord("a") + 10
            elif ord("A") <= c <= ord("Z"):
                digit = c - ord("A") + 10
            elif ord("0") <= c <= ord("9"):
                digit = c - ord("0")
            else:
                break
            if digit >= radix:
                break
            number_seen = True
            yield digit
            i += 1

    def to_int(self, s, neg, i, radix):
        val = 0
        for digit in self._digits(s, i, radix):
            val = ovfcheck(val * radix + digit)
        if neg:
            val = -val
        return val

    def to_bigint(self, s, neg, i, radix):
        val = rbigint.fromint(0)
        bigint_radix = rbigint.fromint(radix)
        for digit in self._digits(s, i, radix):
            val = val.mul(bigint_radix).add(rbigint.fromint(digit))
        if neg:
            val = val.neg()
        return val

    @classdef.method("to_i")
    def method_to_i(self, space, w_radix=None):
        if w_radix is None:
            is_radix = False
            radix = 10
        else:
            is_radix = True
            radix = Coerce.int(space, w_radix)
        s = space.str_w(self)
        i = 0
        length = len(s)
        while i < length:
            if not s[i].isspace():
                break
            i += 1
        neg = i < length and s[i] == "-"
        if neg:
            i += 1
        if i < length and s[i] == "+":
            i += 1
        if i < length and s[i] == "0":
            if i + 1 < length:
                try:
                    r = RADIX_MAP[s[i + 1]]
                except KeyError:
                    if radix == 0:
                        radix = 8
                else:
                    if not is_radix or radix == r or radix == 0:
                        radix = r
                        i += 2
        if radix == 0:
            radix = 10
        if not 2 <= radix <= 36:
            raise space.error(space.w_ArgumentError, "invalid radix %d" % radix)
        try:
            value = self.to_int(s, neg, i, radix)
        except OverflowError:
            value = self.to_bigint(s, neg, i, radix)
            return space.newbigint_fromrbigint(value)
        else:
            return space.newint(value)

    @classdef.method("to_f")
    def method_to_f(self, space):
        value = 0.0
        precision = False
        pointer = 0.1
        negative = False
        exponent = False
        multi = 0
        number = False

        for char in space.str_w(self):
            c = ord(char)
            if ord("0") <= c <= ord("9"):
                if exponent:
                    multi = multi * 10 + c - ord("0")
                elif precision:
                    value = value + pointer * (c - ord("0"))
                    pointer /= 10
                else:
                    value = value * 10 + c - ord("0")

                number = True
            elif c == ord("-"):
                if value != 0.0:
                    break
                negative = not negative
            elif c == ord("+"):
                if value != 0.0:
                    break
                pass
            elif c == ord("."):
                if precision or exponent:
                    break
                precision = True
            elif c == ord("e"):
                if exponent:
                    break
                exponent = True
            elif char.isspace():
                if number:
                    break
            else:
                break

        if exponent:
            value = value * math.pow(10, multi)

        return space.newfloat(value)

    @classdef.method("tr", source="str", replacement="str")
    def method_tr(self, space, source, replacement):
        string = self.copy(space)
        new_string = self.tr_trans(space, source, replacement, False)
        return space.newstr_fromchars(new_string) if new_string else string

    @classdef.method("tr!", source="str", replacement="str")
    @check_frozen()
    def method_tr_i(self, space, source, replacement):
        new_string = self.tr_trans(space, source, replacement, False)
        self.replace(space, new_string)
        return self if new_string else space.w_nil

    @classdef.method("tr_s", source="str", replacement="str")
    def method_tr_s(self, space, source, replacement):
        string = self.copy(space)
        new_string = self.tr_trans(space, source, replacement, True)
        return space.newstr_fromchars(new_string) if new_string else string

    @classdef.method("tr_s!", source="str", replacement="str")
    @check_frozen()
    def method_tr_s_i(self, space, source, replacement):
        new_string = self.tr_trans(space, source, replacement, True)
        self.replace(space, new_string)
        return self if new_string else space.w_nil

    @classdef.method("=~")
    def method_match_operator(self, space, w_obj):
        if space.is_kind_of(w_obj, space.w_string):
            raise space.error(space.w_TypeError, "type mismatch: String given")
        else:
            return space.send(w_obj, "=~", [self])

    @classdef.method("%")
    def method_mod(self, space, w_arg):
        if space.is_kind_of(w_arg, space.w_array):
            args_w = space.listview(w_arg)
        else:
            args_w = [w_arg]
        elements_w = StringFormatter(space.str_w(self), args_w).format(space)
        return space.newstr_fromstrs(elements_w)

    @classdef.method("getbyte", pos="int")
    def method_getbyte(self, space, pos):
        if pos >= self.length() or pos < -self.length():
            return space.w_nil
        if pos < 0:
            pos += self.length()
        ch = self.strategy.getitem(self.str_storage, pos)
        return space.newint(ord(ch))

    @classdef.method("setbyte", pos="int", replacement="int")
    @check_frozen()
    def method_setbyte(self, space, pos, replacement):
        if pos >= self.length() or pos < -self.length():
            raise space.error(space.w_IndexError,
                "index %d out of string" % pos
            )
        if pos < 0:
            pos += self.length()
        self.strategy.to_mutable(space, self)
        self.strategy.replaceitem(self.str_storage, pos, chr(replacement))
        return space.newint(replacement)

    @classdef.method("include?", substr="str")
    def method_includep(self, space, substr):
        return space.newbool(substr in space.str_w(self))

    def scan_string(self, space, w_pattern):
        string = space.str_w(self)
        pattern = space.str_w(w_pattern)
        idx = string.find(pattern, 0)
        while idx >= 0:
            w_match = space.newstr_fromstr(string[idx:idx + len(pattern)])
            space.infect(w_match, self)
            space.infect(w_match, w_pattern)
            yield w_match
            if not pattern:
                idx += 1
            else:
                idx += len(pattern)
            idx = string.find(pattern, idx)

    def scan_regexp(self, space, w_pattern):
        last = -1
        string = space.str_w(self)
        ctx = w_pattern.make_ctx(string)

        while last < len(string) and self.search_context(space, ctx):
            w_matchdata = w_pattern.get_match_result(space, ctx, string, found=True)
            if w_matchdata.size() > 1:
                matches_w = []
                for num in xrange(1, w_matchdata.size(), 1):
                    begin, end = w_matchdata.get_span(num)
                    assert begin >= 0
                    assert end >= 0
                    w_str = space.newstr_fromstr(string[begin:end])
                    space.infect(w_str, self)
                    space.infect(w_str, w_pattern)
                    matches_w.append(w_str)
                w_match = space.newarray(matches_w)
            else:
                w_match = space.newstr_fromstr(string[ctx.match_start:ctx.match_end])
                space.infect(w_match, self)
                space.infect(w_match, w_pattern)

            yield w_match

            if ctx.match_start == ctx.match_end:
                last += 1
            else:
                last = ctx.match_end
            assert last >= 0
            ctx.reset(last)

    def scan_process_result(self, space, w_match, results_w, block):
        if block:
            space.invoke_block(block, [w_match])
        else:
            results_w.append(w_match)

    @classdef.method("scan")
    def method_scan(self, space, w_pattern, block):
        results_w = []
        w_str_pattern = space.convert_type(w_pattern, space.w_string, "to_str", raise_error=False)
        if w_str_pattern is not space.w_nil:
            for w_match in self.scan_string(space, w_str_pattern):
                self.scan_process_result(space, w_match, results_w, block)
        elif space.is_kind_of(w_pattern, space.w_regexp):
            for w_match in self.scan_regexp(space, w_pattern):
                self.scan_process_result(space, w_match, results_w, block)
        else:
            raise space.error(
                space.w_TypeError,
                "wrong argument type %s (expected Regexp)" % (
                    space.obj_to_s(space.getclass(w_pattern))
                )
            )
        if block:
            return self
        else:
            return space.newarray(results_w)

    @classdef.method("gsub")
    def method_gsub(self, space, w_pattern, w_replacement=None, block=None):
        return self.gsub_main(space, w_pattern, w_replacement, block, first_only=False)

    @classdef.method("sub")
    def method_sub(self, space, w_pattern, w_replacement=None, block=None):
        return self.gsub_main(space, w_pattern, w_replacement, block, first_only=True)

    def gsub_main(self, space, w_pattern, w_replacement, block, first_only):
        if w_replacement is None and block is None:
            raise NotImplementedError("gsub enumerator")

        w_hash = None
        replacement = None
        if w_replacement:
            w_hash = space.convert_type(w_replacement, space.w_hash, "to_hash", raise_error=False)
            if w_hash is space.w_nil:
                w_hash = None
                replacement = space.str_w(
                    space.convert_type(w_replacement, space.w_string, "to_str")
                )

        if space.is_kind_of(w_pattern, space.w_regexp):
            return self.gsub_regexp(space, w_pattern, replacement, w_hash, block, first_only)
        elif space.is_kind_of(w_pattern, space.w_string):
            return self.gsub_string(space, w_pattern, replacement, w_hash, block, first_only)
        else:
            raise space.error(
                space.w_TypeError,
                "wrong argument type %s (expected Regexp)" % (
                    space.obj_to_s(space.getclass(w_replacement))
                )
            )

    def gsub_regexp(self, space, w_pattern, replacement, w_hash, block, first_only):
        result = []
        pos = 0
        string = space.str_w(self)
        ctx = w_pattern.make_ctx(string)

        w_matchdata = w_pattern.get_match_result(space, ctx, string, found=True)
        replacement_parts = None
        if replacement is not None and "\\" in replacement:
            replacement_parts = [s for s in replacement.split("\\") if s]

        while pos < len(string) and self.search_context(space, ctx):
            result += string[pos:ctx.match_start]
            if replacement_parts is not None:
                result += self.gsub_regexp_subst_string(
                    space, replacement_parts, w_matchdata, pos
                )
            elif replacement is not None:
                result += replacement
            elif block:
                result += self.gsub_regexp_block(space, block, w_matchdata)
            elif w_hash:
                result += self.gsub_regexp_hash(space, w_hash, w_matchdata)
            pos = ctx.match_end
            ctx.reset(pos)
            if first_only:
                break
        result += string[pos:]
        return space.newstr_fromchars(result)

    def gsub_regexp_subst_string(self, space, parts_w, w_match, pos=0):
        result = []
        string = space.str_w(self)
        result += parts_w[0]
        for s in parts_w[1:]:
            if s[0].isdigit():
                group = int(s[0])
                if group < w_match.size():
                    begin, end = w_match.get_span(group)
                    begin += pos
                    end += pos
                    assert begin >= 0
                    assert end >= 0
                    result += string[begin:end]
                result += s[1:]
            else:
                result += s
        return result

    def gsub_regexp_block(self, space, block, w_match):
        w_arg = space.send(w_match, "[]", [space.newint(0)])
        return self.gsub_yield_block(space, block, w_arg)

    def gsub_regexp_hash(self, space, w_hash, w_match):
        w_arg = space.send(w_match, "[]", [space.newint(0)])
        return self.gsub_lookup_hash(space, w_hash, w_arg)

    def gsub_string(self, space, w_pattern, replacement, w_hash, block, first_only):
        result = []
        pos = 0
        string = space.str_w(self)
        pattern = space.str_w(w_pattern)
        while pos + len(pattern) < len(string):
            idx = string.find(pattern, pos)
            if idx >= 0:
                result += string[pos:idx]
                if replacement is not None:
                    result += replacement
                elif block:
                    result += self.gsub_yield_block(space, block, w_pattern)
                elif w_hash:
                    result += self.gsub_lookup_hash(space, w_hash, w_pattern)
                pos = idx + len(pattern)
            else:
                break
            if first_only:
                break
        result += string[pos:]
        return space.newstr_fromchars(result)

    def gsub_yield_block(self, space, block, w_matchstr):
        w_value = space.invoke_block(block, [w_matchstr])
        return self.gsub_replacement_to_s(space, w_value)

    def gsub_lookup_hash(self, space, w_hash, w_matchstr):
        w_value = space.send(w_hash, "[]", [w_matchstr])
        return self.gsub_replacement_to_s(space, w_value)

    def gsub_replacement_to_s(self, space, w_replacement):
        if space.is_kind_of(w_replacement, space.w_string):
            return space.str_w(w_replacement)
        else:
            w_replacement = space.send(w_replacement, "to_s")
            if space.is_kind_of(w_replacement, space.w_string):
                return space.str_w(w_replacement)
            else:
                return space.any_to_s(w_replacement)

    @classdef.method("chomp!")
    @check_frozen()
    def method_chomp_i(self, space, w_newline=None):
        if w_newline is None:
            w_newline = space.globals.get(space, "$/")
        if w_newline is space.w_nil:
            return space.w_nil
        newline = space.str_w(space.convert_type(w_newline, space.w_string, "to_str"))
        if newline and newline in "\n\r":
            newline = None
        self.strategy.to_mutable(space, self)
        changed = self.strategy.chomp(self.str_storage, newline)
        return self if changed else space.w_nil

    @classdef.method("chop!")
    @check_frozen()
    def method_chop_i(self, space):
        self.strategy.to_mutable(space, self)
        changed = self.strategy.chop(self.str_storage)
        return self if changed else space.w_nil

    @classdef.method("reverse!")
    @check_frozen()
    def method_reverse_i(self, space):
        self.strategy.to_mutable(space, self)
        self.strategy.reverse(self.str_storage)
        return self

    @classdef.method("next!")
    @classdef.method("succ!")
    @check_frozen()
    def method_succ_i(self, space):
        self.strategy.to_mutable(space, self)
        self.strategy.succ(self.str_storage)
        return self

    @classdef.method("insert", index="int", other="str")
    @check_frozen()
    def method_insert(self, space, index, other):
        if index < 0:
            index += self.length() + 1
        if not 0 <= index <= self.length():
            raise space.error(space.w_IndexError,
                "index %d out of string" % index
            )
        self.strategy.to_mutable(space, self)
        self.strategy.insert(self.str_storage, index, other)
        return self

    @classdef.method("prepend", other="str")
    @check_frozen()
    def method_prepend(self, space, other):
        self.strategy.to_mutable(space, self)
        self.strategy.insert(self.str_storage, 0, other)
        return self

    @classdef.method("strip!")
    @check_frozen()
    def method_strip_i(self, space):
        self.strategy.to_mutable(space, self)
        changed = self.strategy.strip(self.str_storage)
        if changed:
            return self
        else:
            return space.w_nil

########NEW FILE########
__FILENAME__ = symbolobject
from topaz.module import ClassDef
from topaz.modules.comparable import Comparable
from topaz.objects.objectobject import W_Object


class W_SymbolObject(W_Object):
    _immutable_fields_ = ["symbol"]
    classdef = ClassDef("Symbol", W_Object.classdef)
    classdef.include_module(Comparable)

    def __init__(self, space, symbol):
        W_Object.__init__(self, space)
        self.symbol = symbol

    def __deepcopy__(self, memo):
        obj = super(W_SymbolObject, self).__deepcopy__(memo)
        obj.symbol = self.symbol
        return obj

    def symbol_w(self, space):
        return self.symbol

    def str_w(self, space):
        return self.symbol

    @classdef.singleton_method("all_symbols")
    def singleton_method_all_symbols(self, space):
        return space.newarray(space.symbol_cache.values())

    @classdef.method("extend")
    @classdef.method("singleton_class")
    def method_singleton_class(self, space):
        raise space.error(space.w_TypeError, "can't define singleton")

    @classdef.method("to_s")
    def method_to_s(self, space):
        return space.newstr_fromstr(self.symbol)

    @classdef.method("inspect")
    def method_inspect(self, space):
        string_format = (not self.symbol or not self.symbol[0].isalpha() or
            not self.symbol.isalnum())
        if string_format:
            result = [":", '"']
            for c in self.symbol:
                if c == '"':
                    result.append("\\")
                result.append(c)
            result.append('"')
            return space.newstr_fromchars(result)
        else:
            return space.newstr_fromstr(":%s" % self.symbol)

    @classdef.method("length")
    @classdef.method("size")
    def method_size(self, space):
        return space.newint(len(self.symbol))

    @classdef.method("empty?")
    def method_emptyp(self, space):
        return space.newbool(not self.symbol)

    @classdef.method("<=>")
    def method_comparator(self, space, w_other):
        if not space.is_kind_of(w_other, space.w_symbol):
            return space.w_nil
        s1 = self.symbol
        s2 = space.symbol_w(w_other)
        if s1 < s2:
            return space.newint(-1)
        elif s1 == s2:
            return space.newint(0)
        elif s1 > s2:
            return space.newint(1)

    @classdef.method("downcase")
    def method_downcase(self, space):
        return space.newsymbol(self.symbol.lower())

    @classdef.method("upcase")
    def method_upcase(self, space):
        return space.newsymbol(self.symbol.upper())

########NEW FILE########
__FILENAME__ = threadobject
import copy

from topaz.module import ClassDef
from topaz.objects.objectobject import W_Object


class W_ThreadObject(W_Object):
    classdef = ClassDef("Thread", W_Object.classdef)

    def __init__(self, space):
        W_Object.__init__(self, space)
        # TODO: This should be a map dict.
        self.local_storage = {}

    def __deepcopy__(self, memo):
        obj = super(W_ThreadObject, self).__deepcopy__(memo)
        obj.local_storage = copy.deepcopy(self.local_storage, memo)
        return obj

    @classdef.singleton_method("current")
    def method_current(self, space):
        return space.w_main_thread

    @classdef.method("[]", key="str")
    def method_subscript(self, space, key):
        return self.local_storage.get(key, space.w_nil)

    @classdef.method("[]=", key="str")
    def method_subscript_assign(self, space, key, w_value):
        self.local_storage[key] = w_value
        return w_value

    @classdef.method("recursion_guard")
    def method_recursion_guard(self, space, w_identifier, w_obj, block):
        """
        Calls the block with true if recursion is detected, false otherwise.
        It is up to the block to decide what to do in either case.
        """
        ec = space.getexecutioncontext()
        identifier = space.symbol_w(w_identifier)
        with ec.recursion_guard(identifier, w_obj) as in_recursion:
            if not in_recursion:
                space.invoke_block(block, [])
            return space.newbool(in_recursion)

########NEW FILE########
__FILENAME__ = timeobject
import time

from topaz.module import ClassDef
from topaz.coerce import Coerce
from topaz.objects.objectobject import W_Object
from topaz.modules.comparable import Comparable


class W_TimeObject(W_Object):
    classdef = ClassDef("Time", W_Object.classdef)
    classdef.include_module(Comparable)

    def __init__(self, space, klass):
        W_Object.__init__(self, space, klass)
        self._set_epoch_seconds(0.0)

    @classdef.singleton_method("allocate")
    def method_allocate(self, space):
        return W_TimeObject(space, self)

    @classdef.singleton_method("now")
    def method_now(self, space):
        return space.send(self, "new")

    @classdef.singleton_method("at")
    def method_at(self, space, w_time, w_microtime=None):
        if not (w_time.is_kind_of(space, space.w_numeric) or
                w_time.is_kind_of(space, space.getclassfor(W_TimeObject))):
            raise space.error(space.w_TypeError)
        if w_microtime is not None:
            microtime = Coerce.float(space, w_microtime) * 0.000001
        else:
            microtime = 0.0
        timestamp = Coerce.float(space, w_time)
        w_time = space.send(self, "new")
        w_time._set_epoch_seconds(timestamp + microtime)
        return w_time

    @classdef.method("initialize")
    def method_initialize(self, space):
        self._set_epoch_seconds(time.time())

    @classdef.method("to_f")
    def method_to_f(self, space):
        return space.newfloat(self.epoch_seconds)

    @classdef.method("to_i")
    def method_to_i(self, space):
        return space.newint(int(self.epoch_seconds))

    @classdef.method("-")
    def method_sub(self, space, w_other):
        assert isinstance(w_other, W_TimeObject)
        return space.newfloat(self.epoch_seconds - w_other.epoch_seconds)

    def _set_epoch_seconds(self, timestamp):
        self.epoch_seconds = timestamp

########NEW FILE########
__FILENAME__ = objspace
from __future__ import absolute_import

import gc
import os
import sys
import weakref

from rpython.rlib import jit, rpath, types
from rpython.rlib.cache import Cache
from rpython.rlib.objectmodel import specialize, compute_unique_id
from rpython.rlib.signature import signature
from rpython.rlib.rarithmetic import intmask
from rpython.rlib.rbigint import rbigint
from rpython.rtyper.lltypesystem import llmemory, rffi

from rply.errors import ParsingError

from topaz import system
from topaz.astcompiler import CompilerContext, SymbolTable
from topaz.celldict import GlobalsDict
from topaz.closure import ClosureCell
from topaz.error import RubyError, print_traceback
from topaz.executioncontext import ExecutionContext, ExecutionContextHolder
from topaz.frame import Frame
from topaz.interpreter import Interpreter
from topaz.lexer import LexerError, Lexer
from topaz.module import ClassCache, ModuleCache
from topaz.modules.comparable import Comparable
from topaz.modules.enumerable import Enumerable
from topaz.modules.math import Math
from topaz.modules.kernel import Kernel
from topaz.modules.objectspace import ObjectSpace as ObjectSpaceModule
from topaz.modules.process import Process
from topaz.modules.signal import Signal
from topaz.modules.topaz import Topaz
from topaz.objects.arrayobject import W_ArrayObject
from topaz.objects.bignumobject import W_BignumObject
from topaz.objects.bindingobject import W_BindingObject
from topaz.objects.boolobject import W_TrueObject, W_FalseObject
from topaz.objects.classobject import W_ClassObject
from topaz.objects.codeobject import W_CodeObject
from topaz.objects.dirobject import W_DirObject
from topaz.objects.encodingobject import W_EncodingObject
from topaz.objects.envobject import W_EnvObject
from topaz.objects.exceptionobject import (W_ExceptionObject, W_NoMethodError,
    W_ZeroDivisionError, W_SyntaxError, W_LoadError, W_TypeError,
    W_ArgumentError, W_RuntimeError, W_StandardError, W_SystemExit,
    W_SystemCallError, W_NameError, W_IndexError, W_KeyError, W_StopIteration,
    W_NotImplementedError, W_RangeError, W_LocalJumpError, W_IOError,
    W_RegexpError, W_ThreadError, W_FiberError, W_EOFError, W_FloatDomainError,
    W_SystemStackError)
from topaz.objects.fiberobject import W_FiberObject
from topaz.objects.fileobject import W_FileObject
from topaz.objects.floatobject import W_FloatObject
from topaz.objects.functionobject import W_UserFunction
from topaz.objects.hashobject import W_HashObject, W_HashIterator
from topaz.objects.integerobject import W_IntegerObject
from topaz.objects.intobject import W_FixnumObject
from topaz.objects.ioobject import W_IOObject
from topaz.objects.methodobject import W_MethodObject, W_UnboundMethodObject
from topaz.objects.moduleobject import W_ModuleObject
from topaz.objects.nilobject import W_NilObject
from topaz.objects.numericobject import W_NumericObject
from topaz.objects.objectobject import W_Object, W_BaseObject, W_Root
from topaz.objects.procobject import W_ProcObject
from topaz.objects.randomobject import W_RandomObject
from topaz.objects.rangeobject import W_RangeObject
from topaz.objects.regexpobject import W_RegexpObject, W_MatchDataObject
from topaz.objects.stringobject import W_StringObject
from topaz.objects.symbolobject import W_SymbolObject
from topaz.objects.threadobject import W_ThreadObject
from topaz.objects.timeobject import W_TimeObject
from topaz.parser import Parser
from topaz.utils.ll_file import isdir


class SpaceCache(Cache):
    def __init__(self, space):
        Cache.__init__(self)
        self.space = space

    def _build(self, obj):
        return obj(self.space)


class ObjectSpace(object):
    def __init__(self, config):
        self.config = config

        self.cache = SpaceCache(self)
        self.symbol_cache = {}
        self._executioncontexts = ExecutionContextHolder()
        self.globals = GlobalsDict()
        self.bootstrap = True
        self.exit_handlers_w = []

        self.w_true = W_TrueObject(self)
        self.w_false = W_FalseObject(self)
        self.w_nil = W_NilObject(self)

        # Force the setup of a few key classes, we create a fake "Class" class
        # for the initial bootstrap.
        self.w_class = self.newclass("FakeClass", None)
        cls_reference = weakref.ref(self.w_class)
        self.w_basicobject = self.getclassfor(W_BaseObject)
        self.w_object = self.getclassfor(W_Object)
        self.w_class = self.getclassfor(W_ClassObject)
        # We replace the one reference to our FakeClass with the real class.
        self.w_basicobject.klass.superclass = self.w_class

        gc.collect()
        assert cls_reference() is None

        self.w_symbol = self.getclassfor(W_SymbolObject)
        self.w_array = self.getclassfor(W_ArrayObject)
        self.w_proc = self.getclassfor(W_ProcObject)
        self.w_binding = self.getclassfor(W_BindingObject)
        self.w_numeric = self.getclassfor(W_NumericObject)
        self.w_fixnum = self.getclassfor(W_FixnumObject)
        self.w_float = self.getclassfor(W_FloatObject)
        self.w_bignum = self.getclassfor(W_BignumObject)
        self.w_integer = self.getclassfor(W_IntegerObject)
        self.w_module = self.getclassfor(W_ModuleObject)
        self.w_string = self.getclassfor(W_StringObject)
        self.w_regexp = self.getclassfor(W_RegexpObject)
        self.w_hash = self.getclassfor(W_HashObject)
        self.w_method = self.getclassfor(W_MethodObject)
        self.w_unbound_method = self.getclassfor(W_UnboundMethodObject)
        self.w_io = self.getclassfor(W_IOObject)
        self.w_NoMethodError = self.getclassfor(W_NoMethodError)
        self.w_ArgumentError = self.getclassfor(W_ArgumentError)
        self.w_LocalJumpError = self.getclassfor(W_LocalJumpError)
        self.w_NameError = self.getclassfor(W_NameError)
        self.w_NotImplementedError = self.getclassfor(W_NotImplementedError)
        self.w_IndexError = self.getclassfor(W_IndexError)
        self.w_KeyError = self.getclassfor(W_KeyError)
        self.w_IOError = self.getclassfor(W_IOError)
        self.w_EOFError = self.getclassfor(W_EOFError)
        self.w_FiberError = self.getclassfor(W_FiberError)
        self.w_LoadError = self.getclassfor(W_LoadError)
        self.w_RangeError = self.getclassfor(W_RangeError)
        self.w_FloatDomainError = self.getclassfor(W_FloatDomainError)
        self.w_RegexpError = self.getclassfor(W_RegexpError)
        self.w_RuntimeError = self.getclassfor(W_RuntimeError)
        self.w_StandardError = self.getclassfor(W_StandardError)
        self.w_StopIteration = self.getclassfor(W_StopIteration)
        self.w_SyntaxError = self.getclassfor(W_SyntaxError)
        self.w_SystemCallError = self.getclassfor(W_SystemCallError)
        self.w_SystemExit = self.getclassfor(W_SystemExit)
        self.w_SystemStackError = self.getclassfor(W_SystemStackError)
        self.w_TypeError = self.getclassfor(W_TypeError)
        self.w_ZeroDivisionError = self.getclassfor(W_ZeroDivisionError)
        self.w_kernel = self.getmoduleobject(Kernel.moduledef)

        self.w_topaz = self.getmoduleobject(Topaz.moduledef)

        for w_cls in [
            self.w_basicobject, self.w_object, self.w_array, self.w_proc,
            self.w_numeric, self.w_fixnum, self.w_bignum, self.w_float,
            self.w_string, self.w_symbol, self.w_class, self.w_module,
            self.w_hash, self.w_regexp, self.w_method, self.w_unbound_method,
            self.w_io, self.w_binding,

            self.w_NoMethodError, self.w_ArgumentError, self.w_TypeError,
            self.w_ZeroDivisionError, self.w_SystemExit, self.w_RangeError,
            self.w_RegexpError, self.w_RuntimeError, self.w_SystemCallError,
            self.w_LoadError, self.w_StopIteration, self.w_SyntaxError,
            self.w_NameError, self.w_StandardError, self.w_LocalJumpError,
            self.w_IndexError, self.w_IOError, self.w_NotImplementedError,
            self.w_EOFError, self.w_FloatDomainError, self.w_FiberError,
            self.w_SystemStackError, self.w_KeyError,

            self.w_kernel, self.w_topaz,

            self.getclassfor(W_NilObject),
            self.getclassfor(W_TrueObject),
            self.getclassfor(W_FalseObject),
            self.getclassfor(W_RangeObject),
            self.getclassfor(W_FileObject),
            self.getclassfor(W_DirObject),
            self.getclassfor(W_EncodingObject),
            self.getclassfor(W_IntegerObject),
            self.getclassfor(W_RandomObject),
            self.getclassfor(W_ThreadObject),
            self.getclassfor(W_TimeObject),
            self.getclassfor(W_MethodObject),
            self.getclassfor(W_UnboundMethodObject),
            self.getclassfor(W_FiberObject),
            self.getclassfor(W_MatchDataObject),

            self.getclassfor(W_ExceptionObject),
            self.getclassfor(W_ThreadError),

            self.getmoduleobject(Comparable.moduledef),
            self.getmoduleobject(Enumerable.moduledef),
            self.getmoduleobject(Math.moduledef),
            self.getmoduleobject(Process.moduledef),
            self.getmoduleobject(Signal.moduledef),
            self.getmoduleobject(ObjectSpaceModule.moduledef),
        ]:
            self.set_const(
                self.w_object,
                self.str_w(self.send(w_cls, "name")),
                w_cls
            )

        for w_cls in [
            self.getclassfor(W_EnvObject), self.getclassfor(W_HashIterator),
        ]:
            self.set_const(
                self.w_topaz,
                self.str_w(self.send(w_cls, "name")),
                w_cls
            )

        self.set_const(self.w_basicobject, "BasicObject", self.w_basicobject)

        # This is bootstrap. We have to delay sending until true, false and nil
        # are defined
        self.send(self.w_object, "include", [self.w_kernel])
        self.bootstrap = False

        self.w_load_path = self.newarray([])
        self.globals.define_virtual("$LOAD_PATH", lambda space: space.w_load_path)
        self.globals.define_virtual("$:", lambda space: space.w_load_path)

        self.globals.define_virtual("$$", lambda space: space.send(space.getmoduleobject(Process.moduledef), "pid"))

        self.w_loaded_features = self.newarray([])
        self.globals.define_virtual("$LOADED_FEATURES", lambda space: space.w_loaded_features)
        self.globals.define_virtual('$"', lambda space: space.w_loaded_features)

        self.w_main_thread = W_ThreadObject(self)

        self.w_load_path = self.newarray([])
        self.base_lib_path = os.path.abspath(os.path.join(os.path.join(os.path.dirname(__file__), os.path.pardir), "lib-ruby"))

    def _freeze_(self):
        self._executioncontexts.clear()
        return True

    def find_executable(self, executable):
        if os.sep in executable or (system.IS_WINDOWS and ":" in executable):
            return executable
        path = os.environ.get("PATH")
        if path:
            for dir in path.split(os.pathsep):
                f = os.path.join(dir, executable)
                if os.path.isfile(f):
                    executable = f
                    break
        return rpath.rabspath(executable)

    def setup(self, executable):
        """
        Performs runtime setup.
        """
        path = rpath.rabspath(self.find_executable(executable))
        # Fallback to a path relative to the compiled location.
        lib_path = self.base_lib_path
        kernel_path = os.path.join(os.path.join(lib_path, os.path.pardir), "lib-topaz")
        while True:
            par_path = rpath.rabspath(os.path.join(path, os.path.pardir))
            if par_path == path:
                break
            path = par_path
            if isdir(os.path.join(path, "lib-ruby")):
                lib_path = os.path.join(path, "lib-ruby")
                kernel_path = os.path.join(path, "lib-topaz")
                break
        self.send(self.w_load_path, "unshift", [self.newstr_fromstr(lib_path)])
        self.load_kernel(kernel_path)

    def load_kernel(self, kernel_path):
        self.send(
            self.w_kernel,
            "load",
            [self.newstr_fromstr(os.path.join(kernel_path, "bootstrap.rb"))]
        )

    @specialize.memo()
    def fromcache(self, key):
        return self.cache.getorbuild(key)

    # Methods for dealing with source code.

    def parse(self, source, initial_lineno=1, symtable=None):
        if symtable is None:
            symtable = SymbolTable()
        parser = Parser(Lexer(source, initial_lineno=initial_lineno, symtable=symtable))
        try:
            return parser.parse().getast()
        except ParsingError as e:
            source_pos = e.getsourcepos()
            if source_pos is not None:
                msg = "line %d" % source_pos.lineno
            else:
                msg = ""
            raise self.error(self.w_SyntaxError, msg)
        except LexerError as e:
            raise self.error(self.w_SyntaxError, "line %d (%s)" % (e.pos.lineno, e.msg))

    def compile(self, source, filepath, initial_lineno=1, symtable=None):
        if symtable is None:
            symtable = SymbolTable()
        astnode = self.parse(source, initial_lineno=initial_lineno, symtable=symtable)
        ctx = CompilerContext(self, "<main>", symtable, filepath)
        with ctx.set_lineno(initial_lineno):
            astnode.compile(ctx)
        return ctx.create_bytecode([], [], None, None)

    def execute(self, source, w_self=None, lexical_scope=None, filepath="-e",
                initial_lineno=1):
        bc = self.compile(source, filepath, initial_lineno=initial_lineno)
        frame = self.create_frame(bc, w_self=w_self, lexical_scope=lexical_scope)
        with self.getexecutioncontext().visit_frame(frame):
            return self.execute_frame(frame, bc)

    @jit.loop_invariant
    def getexecutioncontext(self):
        ec = self._executioncontexts.get()
        if ec is None:
            ec = ExecutionContext()
            self._executioncontexts.set(ec)
        return ec

    def create_frame(self, bc, w_self=None, lexical_scope=None, block=None,
                     parent_interp=None, top_parent_interp=None,
                     regexp_match_cell=None):

        if w_self is None:
            w_self = self.w_top_self
        if regexp_match_cell is None:
            regexp_match_cell = ClosureCell(None)
        return Frame(
            jit.promote(bc), w_self, lexical_scope, block, parent_interp,
            top_parent_interp, regexp_match_cell
        )

    def execute_frame(self, frame, bc):
        return Interpreter().interpret(self, frame, bc)

    # Methods for allocating new objects.

    @signature(types.any(), types.bool(), returns=types.instance(W_Root))
    def newbool(self, boolvalue):
        if boolvalue:
            return self.w_true
        else:
            return self.w_false

    @signature(types.any(), types.int(), returns=types.instance(W_FixnumObject))
    def newint(self, intvalue):
        return W_FixnumObject(self, intvalue)

    def newbigint_fromint(self, intvalue):
        return W_BignumObject.newbigint_fromint(self, intvalue)

    def newbigint_fromfloat(self, floatvalue):
        return W_BignumObject.newbigint_fromfloat(self, floatvalue)

    def newbigint_fromrbigint(self, bigint):
        return W_BignumObject.newbigint_fromrbigint(self, bigint)

    @specialize.argtype(1)
    def newint_or_bigint(self, someinteger):
        if -sys.maxint <= someinteger <= sys.maxint:
            # The smallest int -sys.maxint - 1 has to be a Bignum,
            # because parsing gives a Bignum in that case
            return self.newint(intmask(someinteger))
        else:
            return self.newbigint_fromrbigint(rbigint.fromrarith_int(someinteger))

    def newfloat(self, floatvalue):
        return W_FloatObject(self, floatvalue)

    @jit.elidable
    def newsymbol(self, symbol):
        try:
            w_sym = self.symbol_cache[symbol]
        except KeyError:
            w_sym = self.symbol_cache[symbol] = W_SymbolObject(self, symbol)
        return w_sym

    def newstr_fromchars(self, chars):
        return W_StringObject.newstr_fromchars(self, chars)

    def newstr_fromstr(self, strvalue):
        assert strvalue is not None
        return W_StringObject.newstr_fromstr(self, strvalue)

    def newstr_fromstrs(self, strs_w):
        return W_StringObject.newstr_fromstrs(self, strs_w)

    def newarray(self, items_w):
        return W_ArrayObject(self, items_w)

    def newhash(self):
        return W_HashObject(self)

    def newrange(self, w_start, w_end, exclusive):
        return W_RangeObject(self, w_start, w_end, exclusive)

    def newregexp(self, regexp, flags):
        return W_RegexpObject(self, regexp, flags)

    def newmodule(self, name, w_scope=None):
        complete_name = self.buildname(name, w_scope)
        return W_ModuleObject(self, complete_name)

    def newclass(self, name, superclass, is_singleton=False, w_scope=None, attached=None):
        complete_name = self.buildname(name, w_scope)
        return W_ClassObject(self, complete_name, superclass, is_singleton=is_singleton, attached=attached)

    def newfunction(self, w_name, w_code, lexical_scope, visibility):
        name = self.symbol_w(w_name)
        assert isinstance(w_code, W_CodeObject)
        return W_UserFunction(name, w_code, lexical_scope, visibility)

    def newmethod(self, name, w_cls):
        w_function = w_cls.find_method(self, name)
        if w_function is None:
            raise self.error(
                self.w_NameError,
                "undefined method `%s' for class `%s'" % (name,
                                                          self.obj_to_s(w_cls))
            )
        else:
            return W_UnboundMethodObject(self, w_cls, w_function)

    def newproc(self, bytecode, w_self, lexical_scope, cells, block,
                parent_interp, top_parent_interp, regexp_match_cell,
                is_lambda=False):
        return W_ProcObject(
            self, bytecode, w_self, lexical_scope, cells, block, parent_interp,
            top_parent_interp, regexp_match_cell, is_lambda=False
        )

    @jit.unroll_safe
    def newbinding_fromframe(self, frame):
        names = frame.bytecode.cellvars + frame.bytecode.freevars
        cells = [None] * len(frame.cells)
        for i in xrange(len(frame.cells)):
            cells[i] = frame.cells[i].upgrade_to_closure(self, frame, i)
        return W_BindingObject(self, names, cells, frame.w_self, frame.lexical_scope)

    @jit.unroll_safe
    def newbinding_fromblock(self, block):
        names = block.bytecode.cellvars + block.bytecode.freevars
        cells = block.cells[:]
        return W_BindingObject(self, names, cells, block.w_self, block.lexical_scope)

    def buildname(self, name, w_scope):
        complete_name = name
        if w_scope is not None:
            assert isinstance(w_scope, W_ModuleObject)
            if w_scope is not self.w_object:
                complete_name = "%s::%s" % (self.obj_to_s(w_scope), name)
        return complete_name

    def int_w(self, w_obj):
        return w_obj.int_w(self)

    def bigint_w(self, w_obj):
        return w_obj.bigint_w(self)

    def float_w(self, w_obj):
        return w_obj.float_w(self)

    def symbol_w(self, w_obj):
        return w_obj.symbol_w(self)

    def str_w(self, w_obj):
        """Unpacks a string object as an rstr."""
        return w_obj.str_w(self)

    def str0_w(self, w_obj):
        string = w_obj.str_w(self)
        if "\x00" in string:
            raise self.error(self.w_ArgumentError, "string contains null byte")
        else:
            return string

    def listview(self, w_obj):
        return w_obj.listview(self)

    # Methods for implementing the language semantics.

    def is_true(self, w_obj):
        return w_obj.is_true(self)

    def getclass(self, w_receiver):
        return w_receiver.getclass(self)

    def getsingletonclass(self, w_receiver):
        return w_receiver.getsingletonclass(self)

    def getscope(self, w_receiver):
        if isinstance(w_receiver, W_ModuleObject):
            return w_receiver
        else:
            return self.getclass(w_receiver)

    @jit.unroll_safe
    def getnonsingletonclass(self, w_receiver):
        cls = self.getclass(w_receiver)
        while cls.is_singleton:
            cls = cls.superclass
        return cls

    def getclassfor(self, cls):
        return self.getclassobject(cls.classdef)

    def getclassobject(self, classdef):
        return self.fromcache(ClassCache).getorbuild(classdef)

    def getmoduleobject(self, moduledef):
        return self.fromcache(ModuleCache).getorbuild(moduledef)

    def find_const(self, w_module, name):
        w_res = w_module.find_const(self, name)
        if w_res is None:
            w_res = self.send(w_module, "const_missing", [self.newsymbol(name)])
        return w_res

    @jit.elidable
    def _valid_const_name(self, name):
        if not name[0].isupper():
            return False
        for i in range(1, len(name)):
            ch = name[i]
            if not (ch.isalnum() or ch == "_" or ord(ch) > 127):
                return False
        return True

    def _check_const_name(self, name):
        if not self._valid_const_name(name):
            raise self.error(self.w_NameError,
                "wrong constant name %s" % name
            )

    def set_const(self, module, name, w_value):
        self._check_const_name(name)
        module.set_const(self, name, w_value)

    @jit.unroll_safe
    def _find_lexical_const(self, lexical_scope, name):
        w_res = None
        scope = lexical_scope
        # perform lexical search but skip Object
        while scope is not None:
            w_mod = scope.w_mod
            if w_mod is self.w_top_self:
                break
            w_res = w_mod.find_local_const(self, name)
            if w_res is not None:
                return w_res
            scope = scope.backscope

        object_seen = False
        fallback_scope = self.w_object

        if lexical_scope is not None:
            w_mod = lexical_scope.w_mod
            while w_mod is not None:
                object_seen = w_mod is self.w_object
                # BasicObject was our starting point, do not use Object
                # as fallback
                if w_mod is self.w_basicobject and not object_seen:
                    fallback_scope = None
                w_res = w_mod.find_const(self, name)
                if w_res is not None:
                    return w_res
                if isinstance(w_mod, W_ClassObject):
                    w_mod = w_mod.superclass
                else:
                    break

        if fallback_scope is not None:
            w_res = fallback_scope.find_const(self, name)
        return w_res

    @jit.unroll_safe
    def find_lexical_const(self, lexical_scope, name):
        w_res = self._find_lexical_const(lexical_scope, name)
        if w_res is None:
            if lexical_scope is not None:
                w_mod = lexical_scope.w_mod
            else:
                w_mod = self.w_object
            w_res = self.send(w_mod, "const_missing", [self.newsymbol(name)])
        return w_res

    def find_instance_var(self, w_obj, name):
        w_res = w_obj.find_instance_var(self, name)
        return w_res if w_res is not None else self.w_nil

    def set_instance_var(self, w_obj, name, w_value):
        w_obj.set_instance_var(self, name, w_value)

    def find_class_var(self, w_module, name):
        w_res = w_module.find_class_var(self, name)
        if w_res is None:
            module_name = self.obj_to_s(w_module)
            raise self.error(self.w_NameError,
                "uninitialized class variable %s in %s" % (name, module_name)
            )
        return w_res

    def set_class_var(self, w_module, name, w_value):
        w_module.set_class_var(self, name, w_value)

    def send(self, w_receiver, name, args_w=None, block=None):
        if args_w is None:
            args_w = []

        w_cls = self.getclass(w_receiver)
        raw_method = w_cls.find_method(self, name)
        return self._send_raw(name, raw_method, w_receiver, w_cls, args_w, block)

    def send_super(self, w_cls, w_receiver, name, args_w, block=None):
        raw_method = w_cls.find_method_super(self, name)
        return self._send_raw(name, raw_method, w_receiver, w_cls, args_w, block)

    def _send_raw(self, name, raw_method, w_receiver, w_cls, args_w, block):
        if raw_method is None:
            method_missing = w_cls.find_method(self, "method_missing")
            if method_missing is None:
                class_name = self.str_w(self.send(w_cls, "to_s"))
                raise self.error(self.w_NoMethodError,
                    "undefined method `%s' for %s" % (name, class_name)
                )
            else:
                args_w = [self.newsymbol(name)] + args_w
                return method_missing.call(self, w_receiver, args_w, block)
        return raw_method.call(self, w_receiver, args_w, block)

    def respond_to(self, w_receiver, name):
        w_cls = self.getclass(w_receiver)
        raw_method = w_cls.find_method(self, name)
        return raw_method is not None

    def is_kind_of(self, w_obj, w_cls):
        return w_obj.is_kind_of(self, w_cls)

    @jit.unroll_safe
    def invoke_block(self, block, args_w, block_arg=None):
        bc = block.bytecode
        frame = self.create_frame(
            bc, w_self=block.w_self, lexical_scope=block.lexical_scope,
            block=block.block, parent_interp=block.parent_interp,
            top_parent_interp=block.top_parent_interp,
            regexp_match_cell=block.regexp_match_cell,
        )
        if block.is_lambda:
            frame.handle_args(self, bc, args_w, block_arg)
        else:
            if len(bc.arg_pos) != 0 or bc.splat_arg_pos != -1 or bc.block_arg_pos != -1:
                frame.handle_block_args(self, bc, args_w, block_arg)
        assert len(block.cells) == len(bc.freevars)
        for i in xrange(len(bc.freevars)):
            frame.cells[len(bc.cellvars) + i] = block.cells[i]

        with self.getexecutioncontext().visit_frame(frame):
            return self.execute_frame(frame, bc)

    def invoke_function(self, w_function, w_receiver, args_w, block):
        return self._send_raw(w_function.name, w_function, w_receiver, self.getclass(w_receiver), args_w, block)

    def error(self, w_type, msg="", optargs=None):
        if not optargs:
            optargs = []
        args_w = [self.newstr_fromstr(msg)] + optargs
        w_exc = self.send(w_type, "new", args_w)
        assert isinstance(w_exc, W_ExceptionObject)
        return RubyError(w_exc)

    def hash_w(self, w_obj):
        return self.int_w(self.send(w_obj, "hash"))

    def eq_w(self, w_obj1, w_obj2):
        return self.is_true(self.send(w_obj2, "eql?", [w_obj1]))

    def register_exit_handler(self, w_proc):
        self.exit_handlers_w.append(w_proc)

    def run_exit_handlers(self):
        status = -1
        while self.exit_handlers_w:
            w_proc = self.exit_handlers_w.pop()
            try:
                self.send(w_proc, "call")
            except RubyError as e:
                w_exc = e.w_value
                if isinstance(w_exc, W_SystemExit):
                    status = w_exc.status
                else:
                    print_traceback(self, e.w_value)
        return status

    def subscript_access(self, length, w_idx, w_count):
        inclusive = False
        as_range = False
        end = 0
        nil = False

        if isinstance(w_idx, W_RangeObject) and not w_count:
            start = self.int_w(self.convert_type(w_idx.w_start, self.w_fixnum, "to_int"))
            end = self.int_w(self.convert_type(w_idx.w_end, self.w_fixnum, "to_int"))
            inclusive = not w_idx.exclusive
            as_range = True
        else:
            start = self.int_w(self.convert_type(w_idx, self.w_fixnum, "to_int"))
            if w_count:
                end = self.int_w(self.convert_type(w_count, self.w_fixnum, "to_int"))
                if end >= 0:
                    as_range = True
                else:
                    if start < 0:
                        start += length
                    return (start, end, False, True)

        if start < 0:
            start += length

        if as_range:
            if w_count:
                end += start
            if end < 0:
                end += length
            if inclusive:
                end += 1
            if end < start:
                end = start
            elif end > length:
                end = length
            nil = start < 0 or end < 0 or start > length
        else:
            nil = start < 0 or start >= length

        return (start, end, as_range, nil)

    def convert_type(self, w_obj, w_cls, method, raise_error=True):
        if self.is_kind_of(w_obj, w_cls):
            return w_obj

        try:
            w_res = self.send(w_obj, method)
        except RubyError:
            if not raise_error:
                return self.w_nil
            src_cls_name = self.obj_to_s(self.getclass(w_obj))
            w_cls_name = self.obj_to_s(w_cls)
            raise self.error(
                self.w_TypeError, "can't convert %s into %s" % (src_cls_name, w_cls_name)
            )

        if not w_res or w_res is self.w_nil and not raise_error:
            return self.w_nil
        elif not self.is_kind_of(w_res, w_cls):
            src_cls = self.obj_to_s(self.getclass(w_obj))
            res_cls = self.obj_to_s(self.getclass(w_res))
            w_cls_name = self.obj_to_s(w_cls)
            raise self.error(self.w_TypeError,
                "can't convert %s to %s (%s#%s gives %s)" % (
                    src_cls, w_cls_name, src_cls, method, res_cls
                )
            )
        else:
            return w_res

    def infect(self, w_dest, w_src, taint=True, untrust=True, freeze=False):
        """
        By default copies tainted and untrusted state from src to dest.
        Frozen state isn't copied by default, as this is the rarer case MRI.
        """
        if taint and self.is_true(w_src.get_flag(self, "tainted?")):
            w_dest.set_flag(self, "tainted?")
        if untrust and self.is_true(w_src.get_flag(self, "untrusted?")):
            w_dest.set_flag(self, "untrusted?")
        if freeze and self.is_true(w_src.get_flag(self, "frozen?")):
            w_dest.set_flag(self, "frozen?")

    def getaddrstring(self, w_obj):
        w_id = self.newint_or_bigint(compute_unique_id(w_obj))
        w_4 = self.newint(4)
        w_0x0F = self.newint(0x0F)
        i = 2 * rffi.sizeof(llmemory.Address)
        addrstring = [" "] * i
        while True:
            n = self.int_w(self.send(w_id, "&", [w_0x0F]))
            n += ord("0")
            if n > ord("9"):
                n += (ord("a") - ord("9") - 1)
            i -= 1
            addrstring[i] = chr(n)
            if i == 0:
                break
            w_id = self.send(w_id, ">>", [w_4])
        return "".join(addrstring)

    def any_to_s(self, w_obj):
        return "#<%s:0x%s>" % (
            self.obj_to_s(self.getnonsingletonclass(w_obj)),
            self.getaddrstring(w_obj)
        )

    def obj_to_s(self, w_obj):
        return self.str_w(self.send(w_obj, "to_s"))

    def compare(self, w_a, w_b, block=None):
        if block is None:
            w_cmp_res = self.send(w_a, "<=>", [w_b])
        else:
            w_cmp_res = self.invoke_block(block, [w_a, w_b])
        if w_cmp_res is self.w_nil:
            raise self.error(self.w_ArgumentError,
                "comparison of %s with %s failed" % (
                    self.obj_to_s(self.getclass(w_a)),
                    self.obj_to_s(self.getclass(w_b)),
                )
            )
        else:
            return w_cmp_res

########NEW FILE########
__FILENAME__ = parser
from rpython.rlib.objectmodel import specialize
from rpython.rlib.rbigint import rbigint

from rply import ParserGenerator, Token, ParsingError
from rply.token import BaseBox, SourcePosition

from topaz import ast
from topaz.astcompiler import SymbolTable, BlockSymbolTable, SharedScopeSymbolTable
from topaz.utils import regexp


class Parser(object):
    def __init__(self, lexer):
        self.lexer = lexer
        self._hidden_scopes = []

    def parse(self):
        l = LexerWrapper(self.lexer.tokenize())
        return self.parser.parse(l, state=self)

    def error(self, msg):
        # TODO: this should use a real SourcePosition
        return ParsingError(msg, SourcePosition(-1, -1, -1))

    def push_local_scope(self):
        self.lexer.symtable = SymbolTable(self.lexer.symtable)

    def push_block_scope(self):
        self.lexer.symtable = BlockSymbolTable(self.lexer.symtable)

    def push_shared_scope(self):
        self.lexer.symtable = SharedScopeSymbolTable(self.lexer.symtable)

    def save_and_pop_scope(self, node):
        child_symtable = self.lexer.symtable
        child_symtable.parent_symtable.add_subscope(node, child_symtable)
        self.lexer.symtable = child_symtable.parent_symtable

    def hide_scope(self):
        self._hidden_scopes.append(self.lexer.symtable)
        self.lexer.symtable = self.lexer.symtable.parent_symtable

    def unhide_scope(self):
        self.lexer.symtable = self._hidden_scopes.pop()

    def new_token(self, orig, name, value):
        return Token(name, value, orig.getsourcepos())

    def new_list(self, box=None):
        if box is None:
            contents = []
        else:
            contents = [box.getast()]
        return self._new_list(contents)

    def _new_list(self, nodes):
        return BoxASTList(nodes)

    def append_to_list(self, box_list, box):
        base = box_list.getastlist() if box_list is not None else []
        return BoxASTList(base + [box.getast()])

    def new_stmt(self, box):
        return self._new_stmt(box.getast())

    def _new_stmt(self, node):
        if not isinstance(node, ast.BaseStatement):
            node = ast.Statement(node)
        return BoxAST(node)

    def new_assignable_list(self, boxes):
        return self._new_assignable_list([box.getast() for box in boxes])

    def _new_assignable_list(self, nodes):
        return BoxAssignableList(nodes)

    def append_to_assignable_list(self, box_list, box):
        return self._append_to_assignable_list(box_list.getvars(), [box.getast()])

    def _append_to_assignable_list(self, vars, nodes):
        return BoxAssignableList(vars + nodes)

    def new_augmented_assignment(self, op, lhs, rhs):
        op = op.getstr()[:-1]
        target = lhs.getast()
        value = rhs.getast()
        if op == "||":
            node = ast.OrEqual(target, value)
        elif op == "&&":
            node = ast.AndEqual(target, value)
        else:
            node = ast.AugmentedAssignment(op, target, value)
        return BoxAST(node)

    def assignable(self, box):
        node = box.getast()
        if isinstance(node, ast.File):
            raise self.error("Can't assign to __FILE__")
        elif isinstance(node, ast.Line):
            raise self.error("Can't assign to __LINE__")
        elif isinstance(node, ast.Variable):
            self.lexer.symtable.declare_write(node.name)
        return box

    def _arg_to_variable(self, node):
        if isinstance(node, ast.Argument):
            self.lexer.symtable.declare_local(node.name)
            return ast.Variable(node.name, -1)
        elif isinstance(node, ast.MultiAssignable):
            return node
        else:
            raise SystemError

    def arg_to_variable(self, box):
        return self._arg_to_variable(box.getast())

    def args_to_variables(self, listbox):
        astlist = listbox.getastlist()
        variables = [None] * len(astlist)
        for i, node in enumerate(astlist):
            variables[i] = self._arg_to_variable(node)
        return variables

    def new_binary_call(self, lhs, op, rhs):
        return self._new_call(lhs.getast(), op, [rhs.getast()], None)

    def new_call(self, receiver, method, box_args):
        args = box_args.getcallargs() if box_args is not None else []
        block = box_args.getcallblock() if box_args is not None else None
        return self._new_call(receiver.getast(), method, args, block)

    def new_fcall(self, method, args):
        receiver = ast.Self(method.getsourcepos().lineno)
        return self._new_call(
            receiver, method,
            args.getcallargs() if args is not None else [],
            args.getcallblock() if args is not None else None,
        )

    def _new_call(self, receiver, method, args, block):
        return BoxAST(ast.Send(receiver, method.getstr(), args, block, method.getsourcepos().lineno))

    def new_and(self, lhs, rhs):
        return BoxAST(ast.And(lhs.getast(), rhs.getast()))

    def new_or(self, lhs, rhs):
        return BoxAST(ast.Or(lhs.getast(), rhs.getast()))

    def new_args(self, args=None, splat_arg=None, block_arg=None):
        return BoxArgs(
            args.getastlist() if args is not None else [],
            splat_arg.getstr() if splat_arg is not None else None,
            block_arg.getstr() if block_arg is not None else None,
        )

    def new_call_args(self, box_arg=None, box_block=None):
        args = [box_arg.getast()] if box_arg else []
        block = box_block.getast() if box_block is not None else None
        return self._new_call_args(args, block)

    def _new_call_args(self, args, block):
        return BoxCallArgs(args, block)

    def call_arg_block_pass(self, box_args, box_block_pass):
        if box_block_pass is None:
            return box_args
        return self._new_call_args(box_args.getcallargs(), box_block_pass.getast())

    def append_call_arg(self, box_arg, box):
        return self._new_call_args(box_arg.getcallargs() + [box.getast()], box_arg.getcallblock())

    def new_send_block(self, lineno, params, body):
        stmts = body.getastlist() if body is not None else []
        args = params.getargs(include_multi=True) if params is not None else []
        splat = params.getsplatarg() if params is not None else None
        block_arg = params.getblockarg() if params is not None else None

        extra_stmts = []
        for idx, arg in enumerate(args):
            if isinstance(arg, ast.MultiAssignable):
                new_arg = ast.Argument(str(idx))
                asgn = ast.MultiAssignment(arg, ast.Variable(new_arg.name, lineno))
                args[idx] = new_arg
                self.lexer.symtable.declare_argument(new_arg.name)
                extra_stmts.append(ast.Statement(asgn))

        extra_stmts.reverse()
        stmts = extra_stmts + stmts

        block = ast.Block(stmts) if stmts else ast.Nil()
        return BoxAST(ast.SendBlock(args, splat, block_arg, block))

    def combine_send_block(self, send_box, block_box):
        send = send_box.getast(ast.BaseSend)
        block = block_box.getast()
        if send.block_arg is not None:
            raise self.error("Both block arg and actual block given.")
        if isinstance(send, ast.Send):
            node = ast.Send(
                send.receiver,
                send.method,
                send.args,
                block,
                send.lineno
            )
        elif isinstance(send, ast.Super):
            node = ast.Super(
                send.args,
                block,
                send.lineno,
            )
        else:
            raise SystemError
        return BoxAST(node)

    def _array_or_node(self, box):
        args = box.getcallargs()
        if len(args) == 1:
            [node] = args
        else:
            node = ast.Array(args)
        return node

    def new_return(self, box):
        return BoxAST(ast.Return(self._array_or_node(box)))

    def new_next(self, box):
        return BoxAST(ast.Next(self._array_or_node(box)))

    def new_break(self, box):
        return BoxAST(ast.Break(self._array_or_node(box)))

    def new_super(self, args, token):
        return BoxAST(ast.Super(
            args.getcallargs() if args is not None else [],
            args.getcallblock() if args is not None else None,
            token.getsourcepos().lineno
        ))

    def new_splat(self, box):
        return BoxAST(ast.Splat(box.getast()))

    def new_colon2(self, box, constant):
        return BoxAST(ast.LookupConstant(box.getast(), constant.getstr(), constant.getsourcepos().lineno))

    def new_colon3(self, constant):
        return BoxAST(ast.LookupConstant(None, constant.getstr(), constant.getsourcepos().lineno))

    def new_defined(self, box, token):
        return BoxAST(ast.Defined(box.getast(), token.getsourcepos().lineno))

    def new_symbol(self, token):
        return BoxAST(ast.ConstantSymbol(token.getstr()))

    def new_hash(self, box):
        items = []
        raw_items = box.getastlist()
        for i in xrange(0, len(raw_items), 2):
            items.append((raw_items[i], raw_items[i + 1]))
        return BoxAST(ast.Hash(items))

    def new_global(self, box):
        return BoxAST(ast.Global(box.getstr()))

    def new_instance_var(self, box):
        return BoxAST(ast.InstanceVariable(box.getstr()))

    def new_class_var(self, box):
        return BoxAST(ast.ClassVariable(box.getstr(), box.getsourcepos().lineno))

    def concat_literals(self, head, tail):
        if head is None:
            return tail
        if tail is None:
            return head

        dynamic = False
        const_str = ""
        dyn_str_components = []
        for part in [head.getast(), tail.getast()]:
            if not dynamic:
                if isinstance(part, ast.ConstantString):
                    const_str += part.strvalue
                else:
                    dynamic = True
                    if const_str:
                        dyn_str_components.append(ast.ConstantString(const_str))
                    if isinstance(part, ast.DynamicString):
                        dyn_str_components.extend(part.strvalues)
                    else:
                        dyn_str_components.append(part)
            else:
                if isinstance(part, ast.DynamicString):
                    dyn_str_components.extend(part.strvalues)
                else:
                    dyn_str_components.append(part)
        if dynamic:
            node = ast.DynamicString(dyn_str_components)
        else:
            node = ast.ConstantString(const_str)
        return BoxAST(node)

    def _parse_int(self, box):
        s = box.getstr()
        if "X" in s:
            base = 16
        elif "O" in s:
            base = 8
        elif "B" in s:
            base = 2
        else:
            base = 10
        if base != 10:
            # Strip off the leading 0[xob]
            s = s[2:]

        val = rbigint()
        i = 0
        while i < len(s):
            c = ord(s[i])
            if ord("a") <= c <= ord("z"):
                digit = c - ord("a") + 10
            elif ord("A") <= c <= ord("Z"):
                digit = c - ord("A") + 10
            elif ord("0") <= c <= ord("9"):
                digit = c - ord("0")
            else:
                break
            if digit >= base:
                break
            val = val.mul(rbigint.fromint(base)).add(rbigint.fromint(digit))
            i += 1
        try:
            return ast.ConstantInt(val.toint())
        except OverflowError:
            return ast.ConstantBigInt(val)

    pg = ParserGenerator([
        "CLASS", "MODULE", "DEF", "UNDEF", "BEGIN", "RESCUE", "ENSURE", "END",
        "IF", "UNLESS", "THEN", "ELSIF", "ELSE", "CASE", "WHEN", "WHILE",
        "UNTIL", "FOR", "BREAK", "NEXT", "REDO", "RETRY", "IN", "DO",
        "DO_COND", "DO_BLOCK", "RETURN", "YIELD", "SUPER", "SELF", "NIL",
        "TRUE", "FALSE", "AND", "OR", "NOT", "IF_MOD", "UNLESS_MOD",
        "WHILE_MOD", "UNTIL_MOD", "RESCUE_MOD", "ALIAS", "DEFINED",
        "lBEGIN", "lEND", "__LINE__", "__FILE__", "__ENCODING__", "DO_LAMBDA",

        "IDENTIFIER", "FID", "GVAR", "IVAR", "CONSTANT", "CVAR", "LABEL",
        "CHAR", "UPLUS", "UMINUS", "UMINUS_NUM", "POW", "CMP", "EQ", "EQQ",
        "NEQ", "GEQ", "LEQ", "ANDOP", "OROP", "MATCH", "NMATCH", "DOT", "DOT2",
        "DOT3", "AREF", "ASET", "LSHFT", "RSHFT", "COLON2", "COLON3",
        "OP_ASGN", "ASSOC", "LPAREN", "LPAREN2", "RPAREN", "LPAREN_ARG",
        "LBRACK", "RBRACK", "LBRACE", "LBRACE_ARG", "STAR", "STAR2", "AMPER",
        "AMPER2", "TILDE", "PERCENT", "DIVIDE", "PLUS", "MINUS", "LT", "GT",
        "PIPE", "BANG", "CARET", "LCURLY", "RCURLY", "BACK_REF2", "SYMBEG",
        "STRING_BEG", "XSTRING_BEG", "REGEXP_BEG", "WORDS_BEG", "QWORDS_BEG",
        "STRING_DBEG", "STRING_DVAR", "STRING_END", "LAMBDA", "LAMBEG",
        "NTH_REF", "BACK_REF", "STRING_CONTENT", "INTEGER", "FLOAT",
        "REGEXP_END",

        "LITERAL_EQUAL", "LITERAL_COLON", "LITERAL_COMMA", "LITERAL_LBRACKET",
        "LITERAL_SEMICOLON", "LITERAL_QUESTION_MARK", "LITERAL_SPACE",
        "LITERAL_NEWLINE",
    ], precedence=[
        ("nonassoc", ["LOWEST"]),
        ("nonassoc", ["LBRACE_ARG"]),
        ("nonassoc", ["IF_MOD", "UNLESS_MOD", "WHILE_MOD", "UNTIL_MOD"]),
        ("left", ["OR", "AND"]),
        ("right", ["NOT"]),
        ("nonassoc", ["DEFINED"]),
        ("right", ["LITERAL_EQUAL", "OP_ASGN"]),
        ("left", ["RESCUE_MOD"]),
        ("right", ["LITERAL_QUESTION_MARK", "LITERAL_COLON"]),
        ("nonassoc", ["DOT2", "DOT3"]),
        ("left", ["OROP"]),
        ("left", ["ANDOP"]),
        ("nonassoc", ["CMP", "EQ", "EQQ", "NEQ", "MATCH", "NMATCH"]),
        ("left", ["GT", "GEQ", "LT", "LEQ"]),
        ("left", ["PIPE", "CARET"]),
        ("left", ["AMPER2"]),
        ("left", ["LSHFT", "RSHFT"]),
        ("left", ["PLUS", "MINUS"]),
        ("left", ["STAR2", "DIVIDE", "PERCENT"]),
        ("right", ["UMINUS_NUM", "UMINUS"]),
        ("right", ["POW"]),
        ("right", ["BANG", "TILDE", "UPLUS"]),
    ], cache_id="topaz")

    @pg.production("program : top_compstmt")
    def program(self, p):
        """
        program       : {
                  lexer.setState(LexState.EXPR_BEG);
                  support.initTopLocalVariables();
              } top_compstmt {
  // ENEBO: Removed !compile_for_eval which probably is to reduce warnings
                  if ($2 != null) {
                      /* last expression should not be void */
                      if ($2 instanceof BlockNode) {
                          support.checkUselessStatement($<BlockNode>2.getLast());
                      } else {
                          support.checkUselessStatement($2);
                      }
                  }
                  support.getResult().setAST(support.addRootNode($2, support.getPosition($2)));
              }
        """
        # TODO: sym table setup, and useless statement
        return BoxAST(ast.Main(ast.Block(p[0].getastlist()) if p[0] is not None else ast.Nil()))

    @pg.production("top_compstmt : top_stmts opt_terms")
    def top_compstmt(self, p):
        return p[0]

    @pg.production("top_stmts : none")
    def top_stmts_none(self, p):
        return p[0]

    @pg.production("top_stmts : top_stmt")
    def top_stmts_top_stmt(self, p):
        return self.new_list(p[0])

    @pg.production("top_stmts : top_stmts terms top_stmt")
    def top_stmts(self, p):
        return self.append_to_list(p[0], p[2])

    @pg.production("top_stmts : error top_stmt")
    def top_stmts_error(self, p):
        return p[1]

    @pg.production("top_stmt : stmt")
    def top_stmt_stmt(self, p):
        return p[0]

    @pg.production("top_stmt : lBEGIN LCURLY top_compstmt RCURLY")
    def top_stmt_lbegin(self, p):
        """
        top_stmt      : stmt
              | klBEGIN {
                    if (support.isInDef() || support.isInSingle()) {
                        support.yyerror("BEGIN in method");
                    }
              } tLCURLY top_compstmt tRCURLY {
                    support.getResult().addBeginNode(new PreExe19Node($1.getPosition(), support.getCurrentScope(), $4));
                    $$ = null;
              }
        """
        raise NotImplementedError(p)

    @pg.production("bodystmt : compstmt opt_rescue opt_else opt_ensure")
    def bodystmt(self, p):
        body = ast.Block(p[0].getastlist()) if p[0] is not None else ast.Nil()
        if p[1] is not None:
            except_handlers = p[1].getastlist()
            body = ast.TryExcept(body, except_handlers, ast.Nil())
        elif p[2] is not None:
            body = ast.TryExcept(body, [], p[2].getast())
        if p[3] is not None:
            body = ast.TryFinally(body, ast.Block(p[3].getastlist()))
        return BoxAST(body)

    @pg.production("compstmt : stmts opt_terms")
    def compstmt(self, p):
        """
        compstmt        : stmts opt_terms {
                    if ($1 instanceof BlockNode) {
                        support.checkUselessStatements($<BlockNode>1);
                    }
                    $$ = $1;
                }
        """
        # TODO: checkUslessStatements?
        return p[0]

    @pg.production("stmts : none")
    def stmts_none(self, p):
        return p[0]

    @pg.production("stmts : stmt")
    def stmts_stmt(self, p):
        return self.new_list(p[0])

    @pg.production("stmts : stmts term stmt")
    def stmts(self, p):
        return self.append_to_list(p[0], p[2])

    @pg.production("stmts : error stmt")
    def stmts_error(self, p):
        return p[1]

    @pg.production("stmt : ALIAS fitem alias_after_fitem fitem")
    def stmt_alias_fitem(self, p):
        return BoxAST(ast.Alias(p[1].getast(), p[3].getast(), p[0].getsourcepos().lineno))

    @pg.production("alias_after_fitem : ")
    def alias_after_fitem(self, p):
        self.lexer.state = self.lexer.EXPR_FNAME

    @pg.production("stmt : ALIAS GVAR GVAR")
    def stmt_alias_gvar(self, p):
        """
        kALIAS tGVAR tGVAR {
                    $$ = new VAliasNode($1.getPosition(), (String) $2.getValue(), (String) $3.getValue());
                }
        """
        raise NotImplementedError(p)

    @pg.production("stmt : ALIAS GVAR BACK_REF")
    def stmt_alias_gvar_backref(self, p):
        """
        kALIAS tGVAR tBACK_REF {
                    $$ = new VAliasNode($1.getPosition(), (String) $2.getValue(), "$" + $<BackRefNode>3.getType());
                }
        """
        raise NotImplementedError(p)

    @pg.production("stmt : ALIAS GVAR NTH_REF")
    def stmt_alias_gvar_nref(self, p):
        """
        kALIAS tGVAR tNTH_REF {
                    support.yyerror("can't make alias for the number variables");
                }
        """
        raise NotImplementedError(p)

    @pg.production("stmt : UNDEF undef_list")
    def stmt_undef(self, p):
        return BoxAST(ast.Undef(p[1].getastlist(), p[0].getsourcepos().lineno))

    @pg.production("stmt : stmt IF_MOD expr_value")
    def stmt_ifmod(self, p):
        return self._new_stmt(ast.If(
            p[2].getast(),
            ast.Block([p[0].getast()]),
            ast.Nil(),
        ))

    @pg.production("stmt : stmt UNLESS_MOD expr_value")
    def stmt_unlessmod(self, p):
        return self._new_stmt(ast.If(
            p[2].getast(),
            ast.Nil(),
            ast.Block([p[0].getast()]),
        ))

    @pg.production("stmt : stmt WHILE_MOD expr_value")
    def stmt_while_mod(self, p):
        return self._new_stmt(ast.While(
            p[2].getast(),
            ast.Block([p[0].getast()])
        ))

    @pg.production("stmt : stmt UNTIL_MOD expr_value")
    def stmt_until_mod(self, p):
        return self._new_stmt(ast.Until(
            p[2].getast(),
            ast.Block([p[0].getast()])
        ))

    @pg.production("stmt : stmt RESCUE_MOD stmt")
    def stmt_rescue_mod(self, p):
        lineno = p[1].getsourcepos().lineno
        return self._new_stmt(ast.TryExcept(
            ast.Block([p[0].getast()]),
            [
                ast.ExceptHandler(
                    [ast.LookupConstant(ast.Scope(lineno), "StandardError", lineno)],
                    None,
                    ast.Block([p[2].getast()]),
                )
            ],
            ast.Nil()
        ))

    @pg.production("stmt : lEND LCURLY compstmt RCURLY")
    def stmt_lend(self, p):
        """
        klEND tLCURLY compstmt tRCURLY {
                    if (support.isInDef() || support.isInSingle()) {
                        support.warn(ID.END_IN_METHOD, $1.getPosition(), "END in method; use at_exit");
                    }
                    $$ = new PostExeNode($1.getPosition(), $3);
                }
        """
        raise NotImplementedError(p)

    @pg.production("stmt : command_asgn")
    def stmt_command_assign(self, p):
        return self.new_stmt(p[0])

    @pg.production("stmt : mlhs LITERAL_EQUAL command_call")
    def stmt_mlhs_equal_command_call(self, p):
        return self._new_stmt(ast.MultiAssignment(
            p[0].getassignment(),
            p[2].getast()
        ))

    @pg.production("stmt : var_lhs OP_ASGN command_call")
    def stmt_var_lhs_op_asgn_command_call(self, p):
        return self.new_stmt(self.new_augmented_assignment(p[1], p[0], p[2]))

    @pg.production("stmt : primary_value LITERAL_LBRACKET opt_call_args rbracket OP_ASGN command_call")
    def stmt_subscript_op_asgn_command_call(self, p):
        """
        primary_value '[' opt_call_args rbracket tOP_ASGN command_call {
  // FIXME: arg_concat logic missing for opt_call_args
                    $$ = support.new_opElementAsgnNode(support.getPosition($1), $1, (String) $5.getValue(), $3, $6);
                }
        """
        raise NotImplementedError(p)

    @pg.production("stmt : primary_value DOT IDENTIFIER OP_ASGN command_call")
    def stmt_method_op_asgn_command_call(self, p):
        """
        primary_value tDOT tIDENTIFIER tOP_ASGN command_call {
                    $$ = new OpAsgnNode(support.getPosition($1), $1, $5, (String) $3.getValue(), (String) $4.getValue());
                }
        """
        raise NotImplementedError(p)

    @pg.production("stmt : primary_value DOT CONSTANT OP_ASGN command_call")
    def stmt_method_constant_op_asgn_command_call(self, p):
        """
        primary_value tDOT tCONSTANT tOP_ASGN command_call {
                    $$ = new OpAsgnNode(support.getPosition($1), $1, $5, (String) $3.getValue(), (String) $4.getValue());
                }
        """
        raise NotImplementedError(p)

    @pg.production("stmt : primary_value COLON2 CONSTANT OP_ASGN command_call")
    def stmt_primary_value_colon_constant_op_asgn_command_call(self, p):
        self.error("can't make alias for the number variables")

    @pg.production("stmt : primary_value COLON2 IDENTIFIER OP_ASGN command_call")
    def stmt_constant_op_asgn_command_call(self, p):
        """
        primary_value tCOLON2 tIDENTIFIER tOP_ASGN command_call {
                    $$ = new OpAsgnNode(support.getPosition($1), $1, $5, (String) $3.getValue(), (String) $4.getValue());
                }
        """
        raise NotImplementedError(p)

    @pg.production("stmt : backref OP_ASGN command_call")
    def stmt_backref_op_asgn_command_call(self, p):
        raise NotImplementedError(p)
        self.backref_assign_error(p[0])

    @pg.production("stmt : lhs LITERAL_EQUAL mrhs")
    def stmt_lhs_equal_mrhs(self, p):
        return self._new_stmt(ast.Assignment(p[0].getast(), ast.Array(p[2].getastlist())))

    @pg.production("stmt : mlhs LITERAL_EQUAL arg_value")
    def stmt_mlhs_equal_arg_value(self, p):
        return self._new_stmt(ast.MultiAssignment(
            p[0].getassignment(),
            p[2].getast()
        ))

    @pg.production("stmt : mlhs LITERAL_EQUAL mrhs")
    def stmt_mlhs_equal_mrhs(self, p):
        return self._new_stmt(ast.MultiAssignment(
            p[0].getassignment(),
            ast.Array(p[2].getastlist()),
        ))

    @pg.production("stmt : expr")
    def stmt_expr(self, p):
        return self.new_stmt(p[0])

    @pg.production("command_asgn : lhs LITERAL_EQUAL command_call")
    def command_asgn_lhs_equal_command_call(self, p):
        return BoxAST(ast.Assignment(
            p[0].getast(),
            p[2].getast()
        ))

    @pg.production("command_asgn : lhs LITERAL_EQUAL command_asgn")
    def command_asgn_lhs_equal_command_asgn(self, p):
        """
        lhs '=' command_asgn {
                    support.checkExpression($3);
                    $$ = support.node_assign($1, $3);
                }
        """
        raise NotImplementedError(p)

    @pg.production("expr : command_call")
    def expr_command_call(self, p):
        return p[0]

    @pg.production("expr : expr AND expr")
    def expr_and(self, p):
        return self.new_and(p[0], p[2])

    @pg.production("expr : expr OR expr")
    def expr_or(self, p):
        return self.new_or(p[0], p[2])

    @pg.production("expr : NOT opt_nl expr")
    def expr_not(self, p):
        return self.new_call(p[2], self.new_token(p[0], "!", "!"), None)

    @pg.production("expr : BANG command_call")
    def expr_bang_command_call(self, p):
        return self.new_call(p[1], self.new_token(p[0], "!", "!"), None)

    @pg.production("expr : arg")
    def expr_arg(self, p):
        return p[0]

    @pg.production("expr_value : expr")
    def expr_value(self, p):
        """
        expr {
                    support.checkExpression($1);
                }
        """
        # TODO: checkExpression?
        return p[0]

    @pg.production("command_call : command")
    def command_call_command(self, p):
        return p[0]

    @pg.production("command_call : block_command")
    def command_call_block_command(self, p):
        return p[0]

    @pg.production("block_command : block_call")
    def block_command_block_call(self, p):
        return p[0]

    @pg.production("block_command : block_call DOT operation2 command_args")
    def block_command_dot(self, p):
        return self.new_call(p[0], p[2], p[3])

    @pg.production("block_command : block_call COLON2 operation2 command_args")
    def block_command_colon(self, p):
        """
        block_call tCOLON2 operation2 command_args {
                    $$ = support.new_call($1, $3, $4, null);
                }

        """
        raise NotImplementedError(p)

    @pg.production("cmd_brace_block : LBRACE_ARG push_block_scope opt_block_param compstmt RCURLY")
    def cmd_brace_block(self, p):
        box = self.new_send_block(p[0].getsourcepos().lineno, p[2], p[3])
        self.save_and_pop_scope(box.getast())
        return box

    @pg.production("command : operation command_args", precedence="LOWEST")
    def command_operation_command_args(self, p):
        return self.new_fcall(p[0], p[1])

    @pg.production("command : operation command_args cmd_brace_block")
    def command_operation_command_args_cmd_brace_block(self, p):
        return self.combine_send_block(self.new_fcall(p[0], p[1]), p[2])

    @pg.production("command : primary_value DOT operation2 command_args", precedence="LOWEST")
    def command_method_call_args(self, p):
        return self.new_call(p[0], p[2], p[3])

    @pg.production("command : primary_value DOT operation2 command_args cmd_brace_block")
    def command_method_call_args_brace_block(self, p):
        return self.combine_send_block(self.new_call(p[0], p[2], p[3]), p[4])

    @pg.production("command : primary_value COLON2 operation2 command_args", precedence="LOWEST")
    def command_colon_call_args(self, p):
        return self.new_call(p[0], p[2], p[3])

    @pg.production("command : primary_value COLON2 operation2 command_args cmd_brace_block")
    def command_colon_call_args_brace_block(self, p):
        """
        primary_value tCOLON2 operation2 command_args cmd_brace_block {
                    $$ = support.new_call($1, $3, $4, $5);
                }
        """
        raise NotImplementedError(p)

    @pg.production("command : SUPER command_args")
    def command_super(self, p):
        return self.new_super(p[1], p[0])

    @pg.production("command : YIELD command_args")
    def command_yield(self, p):
        return BoxAST(ast.Yield(p[1].getcallargs(), p[0].getsourcepos().lineno))

    @pg.production("command : RETURN call_args")
    def command_call_return(self, p):
        return self.new_return(p[1])

    @pg.production("command : BREAK call_args")
    def command_call_break(self, p):
        return self.new_break(p[1])

    @pg.production("command : NEXT call_args")
    def command_call_next(self, p):
        return self.new_next(p[1])

    @pg.production("mlhs : mlhs_basic")
    def mlhs(self, p):
        return p[0]

    @pg.production("mlhs : LPAREN mlhs_inner rparen")
    def mlhs_paren(self, p):
        return p[1]

    @pg.production("mlhs_inner : mlhs_basic")
    def mlhs_inner(self, p):
        return p[0]

    @pg.production("mlhs_inner : LPAREN mlhs_inner rparen")
    def mlhs_inner_paren(self, p):
        """
        tLPAREN mlhs_inner rparen {
                    $$ = new MultipleAsgn19Node($1.getPosition(), support.newArrayNode($1.getPosition(), $2), null, null);
                }
        """
        raise NotImplementedError(p)

    @pg.production("mlhs_basic : mlhs_head")
    def mlhs_basic_mlhs_head(self, p):
        return p[0]

    @pg.production("mlhs_basic : mlhs_head mlhs_item")
    def mlhs_basic_mlhs_head_mlhs_item(self, p):
        return self.append_to_assignable_list(p[0], p[1])

    @pg.production("mlhs_basic : mlhs_head STAR mlhs_node")
    def mlhs_basic_mlhs_head_star_node(self, p):
        return self.append_to_assignable_list(p[0], self.new_splat(p[2]))

    @pg.production("mlhs_basic : mlhs_head STAR mlhs_node LITERAL_COMMA mlhs_post")
    def mlhs_basic_mlhs_head_star_node_comma_post(self, p):
        box = self.append_to_assignable_list(p[0], self.new_splat(p[2]))
        return self._append_to_assignable_list(box.getvars(), p[4].getastlist())

    @pg.production("mlhs_basic : mlhs_head STAR")
    def mlhs_basic_mlhs_head_star(self, p):
        return self._append_to_assignable_list(p[0].getvars(), [ast.Splat(None)])

    @pg.production("mlhs_basic : mlhs_head STAR LITERAL_COMMA mlhs_post")
    def mlhs_basic_mlhs_head_star_comma_post(self, p):
        return self._append_to_assignable_list(p[0].getvars(), [ast.Splat(None)] + p[3].getastlist())

    @pg.production("mlhs_basic : STAR mlhs_node")
    def mlhs_basic_star_mlhs_node(self, p):
        return self.new_assignable_list([self.new_splat(p[1])])

    @pg.production("mlhs_basic : STAR mlhs_node LITERAL_COMMA mlhs_post")
    def mlhs_basic_star_mlhs_node_comma_post(self, p):
        return self._new_assignable_list([self.new_splat(p[1]).getast()] + p[3].getastlist())

    @pg.production("mlhs_basic : STAR")
    def mlhs_basic_star(self, p):
        return self._new_assignable_list([ast.Splat(None)])

    @pg.production("mlhs_basic : STAR LITERAL_COMMA mlhs_post")
    def mlhs_basic_star_comma_post(self, p):
        """
        tSTAR ',' mlhs_post {
                      $$ = new MultipleAsgn19Node($1.getPosition(), null, new StarNode(lexer.getPosition()), $3);
                }
        """
        raise NotImplementedError(p)

    @pg.production("mlhs_item : mlhs_node")
    def mlhs_item_node(self, p):
        return p[0]

    @pg.production("mlhs_item : LPAREN mlhs_inner rparen")
    def mlhs_item_paren(self, p):
        return BoxAST(p[1].getassignment())

    @pg.production("mlhs_head : mlhs_item LITERAL_COMMA")
    def mlhs_head_item(self, p):
        return self.new_assignable_list([p[0]])

    @pg.production("mlhs_head : mlhs_head mlhs_item LITERAL_COMMA")
    def mlhs_head_head_item(self, p):
        return self.append_to_assignable_list(p[0], p[1])

    @pg.production("mlhs_post : mlhs_item")
    def mlhs_post_item(self, p):
        return self.new_list(p[0])

    @pg.production("mlhs_post : mlhs_post LITERAL_COMMA mlhs_item")
    def mlhs_post_post_item(self, p):
        return self.append_to_list(p[0], p[2])

    @pg.production("mlhs_node : keyword_variable")
    @pg.production("mlhs_node : user_variable")
    def mlhs_node_variable(self, p):
        return self.assignable(p[0])

    @pg.production("mlhs_node : primary_value LITERAL_LBRACKET opt_call_args rbracket")
    def mlhs_node_subscript(self, p):
        return BoxAST(ast.Subscript(
            p[0].getast(),
            p[2].getcallargs(),
            p[1].getsourcepos().lineno
        ))

    @pg.production("mlhs_node : primary_value DOT IDENTIFIER")
    def mlhs_node_attr(self, p):
        return self.new_call(p[0], p[2], None)

    @pg.production("mlhs_node : primary_value COLON2 IDENTIFIER")
    def mlhs_node_colon_attr(self, p):
        """
        primary_value tCOLON2 tIDENTIFIER {
                    $$ = support.attrset($1, (String) $3.getValue());
                }
        """
        raise NotImplementedError(p)

    @pg.production("mlhs_node : primary_value DOT CONSTANT")
    def mlhs_node_attr_constant(self, p):
        """
        primary_value tDOT tCONSTANT {
                    $$ = support.attrset($1, (String) $3.getValue());
                }
        """
        raise NotImplementedError(p)

    @pg.production("mlhs_node : primary_value COLON2 CONSTANT")
    def mlhs_node_constant(self, p):
        return BoxAST(ast.LookupConstant(p[0].getast(), p[2].getstr(), p[1].getsourcepos().lineno))

    @pg.production("mlhs_node : COLON3 CONSTANT")
    def mlhs_node_colon_constant(self, p):
        """
        tCOLON3 tCONSTANT {
                    if (support.isInDef() || support.isInSingle()) {
                        support.yyerror("dynamic constant assignment");
                    }

                    ISourcePosition position = $1.getPosition();

                    $$ = new ConstDeclNode(position, null, support.new_colon3(position, (String) $2.getValue()), NilImplicitNode.NIL);
                }
        """
        raise NotImplementedError(p)

    @pg.production("mlhs_node : backref")
    def mlhs_node_backref(self, p):
        """
        backref {
                    support.backrefAssignError($1);
                }
        """
        raise NotImplementedError(p)

    @pg.production("lhs : keyword_variable")
    @pg.production("lhs : user_variable")
    def lhs_variable(self, p):
        return self.assignable(p[0])

    @pg.production("lhs : primary_value LITERAL_LBRACKET opt_call_args rbracket")
    def lhs_subscript(self, p):
        args = p[2].getcallargs() if p[2] is not None else []
        return BoxAST(ast.Subscript(p[0].getast(), args, p[1].getsourcepos().lineno))

    @pg.production("lhs : primary_value DOT IDENTIFIER")
    def lhs_dot_identifier(self, p):
        return self.new_call(p[0], p[2], None)

    @pg.production("lhs : primary_value COLON2 IDENTIFIER")
    def lhs_colon_identifier(self, p):
        return self.new_call(p[0], p[2], None)

    @pg.production("lhs : primary_value DOT CONSTANT")
    def lhs_dot_constant(self, p):
        """
        primary_value tDOT tCONSTANT {
                    $$ = support.attrset($1, (String) $3.getValue());
                }
        """
        raise NotImplementedError(p)

    @pg.production("lhs : primary_value COLON2 CONSTANT")
    def lhs_colon_constant(self, p):
        return self.new_colon2(p[0], p[2])

    @pg.production("lhs : COLON3 CONSTANT")
    def lhs_unbound_colon_constant(self, p):
        return self.new_colon3(p[1])

    @pg.production("lhs : backref")
    def lhs_backref(self, p):
        raise NotImplementedError(p)
        self.backref_assign_error()

    @pg.production("cname : IDENTIFIER")
    def cname_identifier(self, p):
        raise self.error("class/module name must be CONSTANT")

    @pg.production("cname : CONSTANT")
    def cname_constant(self, p):
        return p[0]

    @pg.production("cpath : COLON3 cname")
    def cpath_unbound_colon_cname(self, p):
        return self.new_colon3(p[1])

    @pg.production("cpath : cname")
    def cpath_cname(self, p):
        lineno = p[0].getsourcepos().lineno
        return BoxAST(ast.LookupConstant(ast.Scope(lineno), p[0].getstr(), lineno))

    @pg.production("cpath : primary_value COLON2 cname")
    def cpath_colon_cname(self, p):
        return BoxAST(ast.LookupConstant(p[0].getast(), p[2].getstr(), p[1].getsourcepos().lineno))

    @pg.production("fname : IDENTIFIER")
    def fname_identifier(self, p):
        return p[0]

    @pg.production("fname : CONSTANT")
    def fname_constant(self, p):
        return p[0]

    @pg.production("fname : FID")
    def fname_fid(self, p):
        return p[0]

    @pg.production("fname : op")
    def fname_op(self, p):
        self.lexer.state = self.lexer.EXPR_ENDFN
        return p[0]

    @pg.production("fname : reswords")
    def fname_reswords(self, p):
        self.lexer.state = self.lexer.EXPR_ENDFN
        return p[0]

    @pg.production("fsym : fname")
    def fsym_fname(self, p):
        return self.new_symbol(p[0])

    @pg.production("fsym : symbol")
    def fsym_symbol(self, p):
        return self.new_symbol(p[0])

    @pg.production("fitem : fsym")
    def fitem_fsym(self, p):
        return p[0]

    @pg.production("fitem : dsym")
    def fitem_dsym(self, p):
        return p[0]

    @pg.production("undef_list : fitem")
    def undef_list_fitem(self, p):
        return self.new_list(p[0])

    @pg.production("undef_list : undef_list LITERAL_COMMA fitem")
    def undef_list_undef_list(self, p):
        """
        undef_list ',' {
                    lexer.setState(LexState.EXPR_FNAME);
                } fitem {
                    $$ = support.appendToBlock($1, support.newUndef($1.getPosition(), $4));
                }
        """
        raise NotImplementedError(p)

    @pg.production("op : PIPE")
    @pg.production("op : CARET")
    @pg.production("op : AMPER2")
    @pg.production("op : CMP")
    @pg.production("op : EQ")
    @pg.production("op : EQQ")
    @pg.production("op : MATCH")
    @pg.production("op : NMATCH")
    @pg.production("op : GT")
    @pg.production("op : GEQ")
    @pg.production("op : LT")
    @pg.production("op : LEQ")
    @pg.production("op : NEQ")
    @pg.production("op : LSHFT")
    @pg.production("op : RSHFT")
    @pg.production("op : PLUS")
    @pg.production("op : MINUS")
    @pg.production("op : STAR2")
    @pg.production("op : STAR")
    @pg.production("op : DIVIDE")
    @pg.production("op : PERCENT")
    @pg.production("op : POW")
    @pg.production("op : BANG")
    @pg.production("op : TILDE")
    @pg.production("op : UPLUS")
    @pg.production("op : UMINUS")
    @pg.production("op : AREF")
    @pg.production("op : ASET")
    @pg.production("op : BACK_REF2")
    def op(self, p):
        return p[0]

    @pg.production("reswords : __LINE__")
    @pg.production("reswords : __FILE__")
    @pg.production("reswords : __ENCODING__")
    @pg.production("reswords : lBEGIN")
    @pg.production("reswords : lEND")
    @pg.production("reswords : ALIAS")
    @pg.production("reswords : AND")
    @pg.production("reswords : BEGIN")
    @pg.production("reswords : BREAK")
    @pg.production("reswords : CASE")
    @pg.production("reswords : CLASS")
    @pg.production("reswords : DEF")
    @pg.production("reswords : DEFINED")
    @pg.production("reswords : DO")
    @pg.production("reswords : ELSE")
    @pg.production("reswords : ELSIF")
    @pg.production("reswords : END")
    @pg.production("reswords : ENSURE")
    @pg.production("reswords : FALSE")
    @pg.production("reswords : FOR")
    @pg.production("reswords : IN")
    @pg.production("reswords : MODULE")
    @pg.production("reswords : NEXT")
    @pg.production("reswords : NIL")
    @pg.production("reswords : NOT")
    @pg.production("reswords : OR")
    @pg.production("reswords : REDO")
    @pg.production("reswords : RESCUE")
    @pg.production("reswords : RETRY")
    @pg.production("reswords : RETURN")
    @pg.production("reswords : SELF")
    @pg.production("reswords : SUPER")
    @pg.production("reswords : THEN")
    @pg.production("reswords : TRUE")
    @pg.production("reswords : UNDEF")
    @pg.production("reswords : WHEN")
    @pg.production("reswords : YIELD")
    @pg.production("reswords : IF_MOD")
    @pg.production("reswords : UNLESS_MOD")
    @pg.production("reswords : WHILE_MOD")
    @pg.production("reswords : UNTIL_MOD")
    @pg.production("reswords : RESCUE_MOD")
    def reswords(self, p):
        return p[0]

    @pg.production("arg : lhs LITERAL_EQUAL arg")
    def arg_lhs_equal_arg(self, p):
        return BoxAST(ast.Assignment(p[0].getast(), p[2].getast()))

    @pg.production("arg : lhs LITERAL_EQUAL arg RESCUE_MOD arg")
    def arg_lhs_equal_arg_rescue_mod(self, p):
        lineno = p[1].getsourcepos().lineno
        return BoxAST(ast.Assignment(
            p[0].getast(),
            ast.TryExcept(
                p[2].getast(),
                [
                    ast.ExceptHandler(
                        [ast.LookupConstant(ast.Scope(lineno), "StandardError", lineno)],
                        None,
                        p[4].getast()
                    )
                ],
                ast.Nil()
            )
        ))

    @pg.production("arg : var_lhs OP_ASGN arg")
    def arg_var_lhs_op_asgn_arg(self, p):
        return self.new_augmented_assignment(p[1], p[0], p[2])

    @pg.production("arg : var_lhs OP_ASGN arg RESCUE_MOD arg")
    def arg_var_lhs_op_asgn_arg_rescue_mod(self, p):
        lineno = p[3].getsourcepos().lineno
        return self.new_augmented_assignment(
            p[1],
            p[0],
            BoxAST(ast.TryExcept(
                p[2].getast(),
                [
                    ast.ExceptHandler(
                        [ast.LookupConstant(ast.Scope(lineno), "StandardError", lineno)],
                        None,
                        p[4].getast()
                    )
                ],
                ast.Nil()
            ))
        )

    @pg.production("arg : primary_value LITERAL_LBRACKET opt_call_args rbracket OP_ASGN arg")
    def arg_subscript_op_asgn_arg(self, p):
        args = p[2].getcallargs() if p[2] is not None else []
        return self.new_augmented_assignment(
            p[4],
            BoxAST(ast.Subscript(p[0].getast(), args, p[1].getsourcepos().lineno)),
            p[5],
        )

    @pg.production("arg : primary_value DOT IDENTIFIER OP_ASGN arg")
    def arg_method_op_asgn_arg(self, p):
        return self.new_augmented_assignment(
            p[3],
            self.new_call(p[0], p[2], None),
            p[4]
        )

    @pg.production("arg : primary_value DOT CONSTANT OP_ASGN arg")
    def arg_method_constant_op_asgn_arg(self, p):
        """
        primary_value tDOT tCONSTANT tOP_ASGN arg {
                    $$ = new OpAsgnNode(support.getPosition($1), $1, $5, (String) $3.getValue(), (String) $4.getValue());
                }
        """
        raise NotImplementedError(p)

    @pg.production("arg : primary_value COLON2 IDENTIFIER OP_ASGN arg")
    def arg_colon_method_op_asgn_arg(self, p):
        """
        primary_value tCOLON2 tIDENTIFIER tOP_ASGN arg {
                    $$ = new OpAsgnNode(support.getPosition($1), $1, $5, (String) $3.getValue(), (String) $4.getValue());
                }
        """
        raise NotImplementedError(p)

    @pg.production("arg : primary_value COLON2 CONSTANT OP_ASGN arg")
    def arg_constant_op_asgn_arg(self, p):
        raise self.error("constant re-assignment")

    @pg.production("arg : COLON3 CONSTANT OP_ASGN arg")
    def arg_unbound_constant_op_asgn_arg(self, p):
        raise self.error("constant re-assignment")

    @pg.production("arg : backref OP_ASGN arg")
    def arg_backref_op_asgn_arg(self, p):
        raise NotImplementedError(p)
        self.backref_assign_error()

    @pg.production("arg : arg DOT2 arg")
    def arg_dot2(self, p):
        return BoxAST(ast.Range(p[0].getast(), p[2].getast(), False))

    @pg.production("arg : arg DOT3 arg")
    def arg_dot3(self, p):
        return BoxAST(ast.Range(p[0].getast(), p[2].getast(), True))

    @pg.production("arg : arg POW arg")
    @pg.production("arg : arg PERCENT arg")
    @pg.production("arg : arg DIVIDE arg")
    @pg.production("arg : arg STAR2 arg")
    @pg.production("arg : arg MINUS arg")
    @pg.production("arg : arg PLUS arg")
    def arg_binop(self, p):
        return self.new_binary_call(p[0], p[1], p[2])

    @pg.production("arg : UMINUS_NUM INTEGER POW arg")
    def arg_uminus_num_integer_pow_arg(self, p):
        lineno = p[0].getsourcepos().lineno
        return BoxAST(ast.Send(
            self.new_binary_call(BoxAST(self._parse_int(p[1])), p[2], p[3]).getast(),
            "-@",
            [],
            None,
            lineno
        ))

    @pg.production("arg : UMINUS_NUM FLOAT POW arg")
    def arg_uminus_num_float_pow_arg(self, p):
        lineno = p[0].getsourcepos().lineno
        return BoxAST(ast.Send(
            self.new_binary_call(BoxAST(ast.ConstantFloat(float(p[1].getstr()))), p[2], p[3]).getast(),
            "-@",
            [],
            None,
            lineno
        ))

    @pg.production("arg : UPLUS arg")
    def arg_uplus_arg(self, p):
        return BoxAST(ast.Send(p[1].getast(), "+@", [], None, p[0].getsourcepos().lineno))

    @pg.production("arg : UMINUS arg")
    def arg_uminus_arg(self, p):
        return BoxAST(ast.Send(p[1].getast(), "-@", [], None, p[0].getsourcepos().lineno))

    @pg.production("arg : arg NEQ arg")
    @pg.production("arg : arg EQQ arg")
    @pg.production("arg : arg EQ arg")
    @pg.production("arg : arg LEQ arg")
    @pg.production("arg : arg LT arg")
    @pg.production("arg : arg GEQ arg")
    @pg.production("arg : arg GT arg")
    @pg.production("arg : arg CMP arg")
    @pg.production("arg : arg AMPER2 arg")
    @pg.production("arg : arg CARET arg")
    @pg.production("arg : arg PIPE arg")
    def arg_binop2(self, p):
        return self.new_binary_call(p[0], p[1], p[2])

    @pg.production("arg : arg NMATCH arg")
    @pg.production("arg : arg MATCH arg")
    def arg_match_arg(self, p):
        return self.new_binary_call(p[0], p[1], p[2])

    @pg.production("arg : BANG arg")
    def arg_bang_arg(self, p):
        return self.new_call(p[1], p[0], None)

    @pg.production("arg : TILDE arg")
    def arg_tilde_arg(self, p):
        return self.new_call(p[1], p[0], None)

    @pg.production("arg : arg RSHFT arg")
    @pg.production("arg : arg LSHFT arg")
    def arg_binop3(self, p):
        return self.new_binary_call(p[0], p[1], p[2])

    @pg.production("arg : arg ANDOP arg")
    def arg_andop_arg(self, p):
        return self.new_and(p[0], p[2])

    @pg.production("arg : arg OROP arg")
    def arg_orop_arg(self, p):
        return self.new_or(p[0], p[2])

    @pg.production("arg : DEFINED opt_nl arg")
    def arg_defined(self, p):
        return self.new_defined(p[2], p[0])

    @pg.production("arg : arg LITERAL_QUESTION_MARK arg opt_nl LITERAL_COLON arg")
    def arg_ternary(self, p):
        return BoxAST(ast.If(
            p[0].getast(),
            p[2].getast(),
            p[5].getast()
        ))

    @pg.production("arg : primary")
    def arg_primary(self, p):
        return p[0]

    @pg.production("arg_value : arg")
    def arg_value(self, p):
        """
        arg {
                    support.checkExpression($1);
                    $$ = $1 != null ? $1 : NilImplicitNode.NIL;
                }
        """
        # TODO: check_expression, none handling
        return p[0]

    @pg.production("aref_args : none")
    def aref_args_none(self, p):
        return p[0]

    @pg.production("aref_args : args trailer")
    def aref_args_args_trailer(self, p):
        return p[0]

    @pg.production("aref_args : args LITERAL_COMMA assocs trailer")
    def aref_args_args_comma_assocs_trailer(self, p):
        return self.append_call_arg(p[0], self.new_hash(p[2]))

    @pg.production("aref_args : assocs trailer")
    def aref_args_assocs_trailer(self, p):
        return self.new_call_args(self.new_hash(p[0]))

    @pg.production("paren_args : LPAREN2 opt_call_args rparen")
    def paren_args(self, p):
        return p[1]

    @pg.production("opt_paren_args : none")
    def opt_paren_args_none(self, p):
        return p[0]

    @pg.production("opt_paren_args : paren_args")
    def opt_paren_args(self, p):
        return p[0]

    @pg.production("opt_call_args : none")
    def opt_call_args_none(self, p):
        return p[0]

    @pg.production("opt_call_args : call_args")
    def opt_call_args(self, p):
        return p[0]

    @pg.production("opt_call_args : args LITERAL_COMMA")
    def opt_call_args_args_comma(self, p):
        return p[0]

    @pg.production("opt_call_args : args LITERAL_COMMA assocs LITERAL_COMMA")
    def opt_call_args_args_comma_assocs_comma(self, p):
        return self.append_call_arg(p[0], self.new_hash(p[2]))

    @pg.production("opt_call_args : assocs LITERAL_COMMA")
    def opt_call_args_assocs_comma(self, p):
        return self.new_call_args(self.new_hash(p[0]))

    @pg.production("call_args : command")
    def call_args_command(self, p):
        return self.new_call_args(p[0])

    @pg.production("call_args : args opt_block_arg")
    def call_args_args_opt_block_arg(self, p):
        return self.call_arg_block_pass(p[0], p[1])

    @pg.production("call_args : assocs opt_block_arg")
    def call_args_assocs_opt_block_arg(self, p):
        box = self.new_call_args(self.new_hash(p[0]))
        return self.call_arg_block_pass(box, p[1])

    @pg.production("call_args : args LITERAL_COMMA assocs opt_block_arg")
    def call_args_args_comma_assocs_opt_block_arg(self, p):
        box = self.append_call_arg(p[0], self.new_hash(p[2]))
        return self.call_arg_block_pass(box, p[3])

    @pg.production("call_args : block_arg")
    def call_args_block_arg(self, p):
        return self.new_call_args(None, box_block=p[0])

    @pg.production("command_args : start_command_args call_args")
    def command_args(self, p):
        self.lexer.cmd_argument_state.reset(p[0].getint())
        return p[1]

    @pg.production("start_command_args : ")
    def start_command_args(self, p):
        return BoxInt(self.lexer.cmd_argument_state.begin())

    @pg.production("block_arg : AMPER arg_value")
    def block_arg(self, p):
        return BoxAST(ast.BlockArgument(p[1].getast()))

    @pg.production("opt_block_arg : LITERAL_COMMA block_arg")
    def opt_block_arg(self, p):
        return p[1]

    @pg.production("opt_block_arg : none_block_pass")
    def opt_block_arg_none(self, p):
        return p[0]

    @pg.production("args : arg_value")
    def args_arg_value(self, p):
        return self.new_call_args(p[0])

    @pg.production("args : STAR arg_value")
    def args_star_arg_value(self, p):
        return self.new_call_args(self.new_splat(p[1]))

    @pg.production("args : args LITERAL_COMMA arg_value")
    def args_comma_arg_value(self, p):
        return self.append_call_arg(p[0], p[2])

    @pg.production("args : args LITERAL_COMMA STAR arg_value")
    def args_comma_star_arg_value(self, p):
        return self.append_call_arg(p[0], self.new_splat(p[3]))

    @pg.production("mrhs : args LITERAL_COMMA arg_value")
    def mrhs_args_comma_arg_value(self, p):
        return self.append_to_list(self._new_list(p[0].getcallargs()), p[2])

    @pg.production("mrhs : args LITERAL_COMMA STAR arg_value")
    def mrhs_args_comma_star_arg_value(self, p):
        return self.append_to_list(self._new_list(p[0].getcallargs()), self.new_splat(p[3]))

    @pg.production("mrhs : STAR arg_value")
    def mrhs_star_arg_value(self, p):
        return self.new_list(self.new_splat(p[1]))

    @pg.production("primary : literal")
    def primary_literal(self, p):
        return p[0]

    @pg.production("primary : strings")
    def primary_strings(self, p):
        return p[0]

    @pg.production("primary : xstring")
    def primary_xstring(self, p):
        return p[0]

    @pg.production("primary : regexp")
    def primary_regexp(self, p):
        return p[0]

    @pg.production("primary : words")
    def primary_words(self, p):
        return p[0]

    @pg.production("primary : qwords")
    def primary_qwords(self, p):
        return p[0]

    @pg.production("primary : var_ref")
    def primary_var_ref(self, p):
        return p[0]

    @pg.production("primary : backref")
    def primary_backref(self, p):
        return p[0]

    @pg.production("primary : FID")
    def primary_fid(self, p):
        return self.new_fcall(p[0], None)

    @pg.production("primary : BEGIN bodystmt END")
    def primary_begin_end(self, p):
        return p[1]

    @pg.production("primary : LPAREN_ARG expr paren_post_expr rparen")
    def primary_paren_arg(self, p):
        return p[1]

    @pg.production("paren_post_expr : ")
    def paren_post_expr(self, p):
        self.lexer.state = self.lexer.EXPR_ENDARG

    @pg.production("primary : LPAREN compstmt RPAREN")
    def primary_lparen(self, p):
        node = ast.Block(p[1].getastlist()) if p[1] is not None else ast.Nil()
        return BoxAST(node)

    @pg.production("primary : primary_value COLON2 CONSTANT")
    def primary_constant_lookup(self, p):
        return self.new_colon2(p[0], p[2])

    @pg.production("primary : COLON3 CONSTANT")
    def primary_unbound_constant(self, p):
        return self.new_colon3(p[1])

    @pg.production("primary : LBRACK aref_args RBRACK")
    def primary_array(self, p):
        if p[1] is None:
            items = []
        else:
            items = p[1].getcallargs()
        return BoxAST(ast.Array(items))

    @pg.production("primary : LBRACE assoc_list RCURLY")
    def primary_hash(self, p):
        return self.new_hash(p[1])

    @pg.production("primary : RETURN")
    def primary_return(self, p):
        return BoxAST(ast.Return(ast.Nil()))

    @pg.production("primary : YIELD LPAREN2 call_args rparen")
    def primary_yield_paren_args(self, p):
        return BoxAST(ast.Yield(p[2].getcallargs(), p[0].getsourcepos().lineno))

    @pg.production("primary : YIELD LPAREN2 rparen")
    def primary_yield_paren(self, p):
        return BoxAST(ast.Yield([], p[0].getsourcepos().lineno))

    @pg.production("primary : YIELD")
    def primary_yield(self, p):
        return BoxAST(ast.Yield([], p[0].getsourcepos().lineno))

    @pg.production("primary : DEFINED opt_nl LPAREN2 expr rparen")
    def primary_defined(self, p):
        return self.new_defined(p[3], p[0])

    @pg.production("primary : NOT LPAREN2 expr rparen")
    def primary_not_paren_expr(self, p):
        return self.new_call(p[2], self.new_token(p[0], "!", "!"), None)

    @pg.production("primary : NOT LPAREN2 rparen")
    def primary_not_paren(self, p):
        return self.new_call(BoxAST(ast.Nil()), self.new_token(p[0], "!", "!"), None)

    @pg.production("primary : operation brace_block")
    def primary_operation_brace_block(self, p):
        return self.new_fcall(p[0], self.new_call_args(box_block=p[1]))

    @pg.production("primary : method_call")
    def primary_method_call(self, p):
        return p[0]

    @pg.production("primary : method_call brace_block")
    def primary_method_call_brace_block(self, p):
        return self.combine_send_block(p[0], p[1])

    @pg.production("primary : LAMBDA lambda")
    def primary_lambda(self, p):
        return p[1]

    @pg.production("primary : IF expr_value then compstmt if_tail END")
    def primary_if(self, p):
        return BoxAST(ast.If(
            p[1].getast(),
            ast.Block(p[3].getastlist()) if p[3] else ast.Nil(),
            p[4].getast() if p[4] else ast.Nil()
        ))

    @pg.production("primary : UNLESS expr_value then compstmt opt_else END")
    def primary_unless(self, p):
        return BoxAST(ast.If(
            p[1].getast(),
            p[4].getast() if p[4] is not None else ast.Nil(),
            ast.Block(p[3].getastlist()) if p[3] else ast.Nil(),
        ))

    @pg.production("primary : while expr_value do post_while_do compstmt END")
    def primary_while(self, p):
        body = ast.Block(p[4].getastlist()) if p[4] is not None else ast.Nil()
        return BoxAST(ast.While(p[1].getast(), body))

    @pg.production("while : WHILE")
    def while_token(self, p):
        self.lexer.condition_state.begin()

    @pg.production("post_while_do : ")
    def post_while_do(self, p):
        self.lexer.condition_state.end()

    @pg.production("primary : until expr_value do post_while_do compstmt END")
    def primary_until(self, p):
        body = ast.Block(p[4].getastlist()) if p[4] is not None else ast.Nil()
        return BoxAST(ast.Until(p[1].getast(), body))

    @pg.production("until : UNTIL")
    def until_token(self, p):
        self.lexer.condition_state.begin()

    @pg.production("primary : CASE expr_value opt_terms case_body END")
    def primary_case_expr_value(self, p):
        elsebody = p[3].getastlist()[-1]
        assert isinstance(elsebody, ast.When)
        assert elsebody.conds is None
        return BoxAST(ast.Case(
            p[1].getast(),
            p[3].getastlist()[:-1],
            elsebody.block,
        ))

    @pg.production("primary : CASE opt_terms case_body END")
    def primary_case(self, p):
        elsebody = p[2].getastlist()[-1]
        assert isinstance(elsebody, ast.When)
        assert elsebody.conds is None

        conditions = []
        for when in p[2].getastlist()[:-1]:
            assert isinstance(when, ast.When)
            cond = when.conds[0]
            for expr in when.conds[1:]:
                cond = ast.Or(cond, expr)
            conditions.append((cond, when.block))

        else_block = elsebody.block
        for idx in range(len(conditions) - 1, 0, -1):
            cond, block = conditions[idx]
            else_block = ast.If(cond, block, else_block)

        return BoxAST(ast.If(conditions[0][0], conditions[0][1], else_block))

    @pg.production("primary : for for_var IN post_for_in expr_value do post_for_do compstmt END")
    def primary_for(self, p):
        lineno = p[0].getsourcepos().lineno
        for_vars = p[1].get_for_var()
        arg = p[1].getargument()

        target = ast.Variable(arg.name, lineno)
        if isinstance(for_vars, BoxAST):
            asgn = ast.Assignment(for_vars.getast(), target)
        elif isinstance(for_vars, BoxAssignableList):
            asgn = ast.MultiAssignment(for_vars.getassignment(), target)
        else:
            raise SystemError

        stmts = p[7].getastlist() if p[7] is not None else []
        stmts = [ast.Statement(asgn)] + stmts
        block = ast.SendBlock([arg], None, None, ast.Block(stmts))

        self.save_and_pop_scope(block)
        return BoxAST(ast.Send(p[4].getast(), "each", [], block, lineno))

    @pg.production("for : FOR")
    def for_prod(self, p):
        self.push_shared_scope()
        return p[0]

    @pg.production("post_for_in : ")
    def post_for_in(self, p):
        self.lexer.condition_state.begin()
        self.hide_scope()

    @pg.production("post_for_do : ")
    def post_for_do(self, p):
        self.lexer.condition_state.end()
        self.unhide_scope()

    @pg.production("primary : CLASS cpath superclass push_local_scope bodystmt END")
    def primary_class(self, p):
        node = p[1].getast(ast.LookupConstant)
        node = ast.Class(
            node.scope,
            node.name,
            p[2].getast() if p[2] is not None else None,
            p[4].getast(),
        )
        self.save_and_pop_scope(node)
        return BoxAST(node)

    @pg.production("push_local_scope : ")
    def push_local_scope_prod(self, p):
        self.push_local_scope()

    @pg.production("primary : CLASS LSHFT expr term push_local_scope bodystmt END")
    def primary_singleton_class(self, p):
        node = ast.SingletonClass(
            p[2].getast(),
            p[5].getast(),
            p[0].getsourcepos().lineno
        )
        self.save_and_pop_scope(node)
        return BoxAST(node)

    @pg.production("primary : MODULE cpath push_local_scope bodystmt END")
    def primary_module(self, p):
        node = p[1].getast(ast.LookupConstant)
        node = ast.Module(node.scope, node.name, p[3].getast())
        self.save_and_pop_scope(node)
        return BoxAST(node)

    @pg.production("primary : DEF fname push_local_scope f_arglist bodystmt END")
    def primary_def(self, p):
        body = p[3].getfullbody(p[4].getast())
        node = ast.Function(
            None,
            p[1].getstr(),
            p[3].getargs(),
            p[3].getsplatarg(),
            p[3].getblockarg(),
            body
        )
        self.save_and_pop_scope(node)
        return BoxAST(node)

    @pg.production("primary : DEF singleton dot_or_colon singleton_method_post_dot_colon fname push_local_scope singleton_method_post_fname f_arglist bodystmt END")
    def primary_def_singleton(self, p):
        body = p[7].getfullbody(p[8].getast())
        node = ast.Function(
            p[1].getast(),
            p[4].getstr(),
            p[7].getargs(),
            p[7].getsplatarg(),
            p[7].getblockarg(),
            body,
        )
        self.save_and_pop_scope(node)
        return BoxAST(node)

    @pg.production("singleton_method_post_dot_colon : ")
    def singleton_method_post_dot_colon(self, p):
        self.lexer.state = self.lexer.EXPR_FNAME

    @pg.production("singleton_method_post_fname : ")
    def singleton_method_post_fname(self, p):
        self.lexer.state = self.lexer.EXPR_ENDFN

    @pg.production("primary : BREAK")
    def primary_break(self, p):
        return BoxAST(ast.Break(ast.Nil()))

    @pg.production("primary : NEXT")
    def primary_next(self, p):
        return BoxAST(ast.Next(ast.Nil()))

    @pg.production("primary : REDO")
    def primary_redo(self, p):
        """
        kREDO {
                    $$ = new RedoNode($1.getPosition());
                }
        """
        raise NotImplementedError(p)

    @pg.production("primary : RETRY")
    def primary_retry(self, p):
        """
        kRETRY {
                    $$ = new RetryNode($1.getPosition());
                }
        """
        raise NotImplementedError(p)

    @pg.production("primary_value : primary")
    def primary_value(self, p):
        """
        primary {
                    support.checkExpression($1);
                    $$ = $1;
                    if ($$ == null) $$ = NilImplicitNode.NIL;
                }
        """
        # TODO: checkExpression, implicit Nil
        return p[0]

    @pg.production("then : term THEN")
    @pg.production("then : THEN")
    @pg.production("then : term")
    def then(self, p):
        return p[0]

    @pg.production("do : DO_COND")
    @pg.production("do : term")
    def do(self, p):
        return p[0]

    @pg.production("if_tail : opt_else")
    def if_tail_opt_else(self, p):
        return p[0]

    @pg.production("if_tail : ELSIF expr_value then compstmt if_tail")
    def if_tail_elsif(self, p):
        return BoxAST(ast.If(
            p[1].getast(),
            ast.Block(p[3].getastlist()),
            p[4].getast() if p[4] else ast.Nil(),
        ))

    @pg.production("opt_else : none")
    def opt_else_none(self, p):
        return p[0]

    @pg.production("opt_else : ELSE compstmt")
    def opt_else(self, p):
        return BoxAST(ast.Block(p[1].getastlist()) if p[1] is not None else ast.Nil())

    @pg.production("for_var : mlhs")
    @pg.production("for_var : lhs")
    def for_var(self, p):
        box = BoxForVars(p[0])
        self.lexer.symtable.declare_local(box.getargument().name)
        return box

    @pg.production("f_marg : f_norm_arg")
    def f_marg_f_norm_arg(self, p):
        return p[0]

    @pg.production("f_marg : LPAREN f_margs rparen")
    def f_marg_paren(self, p):
        return BoxAST(p[1].getassignment())

    @pg.production("f_marg_list : f_marg")
    def f_marg_list_f_marg(self, p):
        return self.new_list(p[0])

    @pg.production("f_marg_list : f_marg_list LITERAL_COMMA f_marg")
    def f_marg_list(self, p):
        return self.append_to_list(p[0], p[2])

    @pg.production("f_margs : f_marg_list")
    def f_margs_f_marg_list(self, p):
        return self._new_assignable_list(self.args_to_variables(p[0]))

    @pg.production("f_margs : f_marg_list LITERAL_COMMA STAR f_norm_arg")
    def f_margs_f_marg_list_comma_star_f_norm_Arg(self, p):
        return self._new_assignable_list(self.args_to_variables(p[0]) + [ast.Splat(self.arg_to_variable(p[3]))])

    @pg.production("f_margs : f_marg_list LITERAL_COMMA STAR f_norm_arg LITERAL_COMMA f_marg_list")
    def f_margs_f_marg_list_comma_star_f_norm_arg_comm_f_marg_list(self, p):
        return self._new_assignable_list(
            self.args_to_variables(p[0]) +
            [ast.Splat(self.arg_to_variable(p[3]))] +
            [self._arg_to_variable(node) for node in p[5].getastlist()]
        )

    @pg.production("f_margs : f_marg_list LITERAL_COMMA STAR")
    def f_margs_f_marg_list_comma_star(self, p):
        return self._new_assignable_list(self.args_to_variables(p[0]) + [ast.Splat(None)])

    @pg.production("f_margs : f_marg_list LITERAL_COMMA STAR LITERAL_COMMA f_marg_list")
    def f_margs_f_marg_list_comma_star_comma_f_marg_list(self, p):
        return self._new_assignable_list(
            self.args_to_variables(p[0]) +
            [ast.Splat(None)] +
            [self._arg_to_variable(node) for node in p[4].getastlist()]
        )

    @pg.production("f_margs : STAR f_norm_arg")
    def f_margs_star_f_norm_arg(self, p):
        return self._new_assignable_list([ast.Splat(self.arg_to_variable(p[1]))])

    @pg.production("f_margs : STAR f_norm_arg LITERAL_COMMA f_marg_list")
    def f_margs_star_f_norm_arg_comma_f_marg_list(self, p):
        return self._new_assignable_list(
            [ast.Splat(self.arg_to_variable(p[1]))] +
            [self._arg_to_variable(node) for node in p[3].getastlist()]
        )

    @pg.production("f_margs : STAR")
    def f_margs_star(self, p):
        return self._new_assignable_list([ast.Splat(None)])

    @pg.production("f_margs : STAR LITERAL_COMMA f_marg_list")
    def f_margs_star_comma_f_marg_list(self, p):
        return self._new_assignable_list(
            [ast.Splat(None)] +
            [self._arg_to_variable(node) for node in p[2].getastlist()]
        )

    @pg.production("block_param : f_arg LITERAL_COMMA f_block_optarg LITERAL_COMMA f_rest_arg opt_f_block_arg")
    def block_param_f_arg_comma_f_block_optarg_comma_f_rest_arg_opt_f_block_arg(self, p):
        return self.new_args(
            args=self._new_list(p[0].getastlist() + p[2].getastlist()),
            splat_arg=p[4],
            block_arg=p[5]
        )

    @pg.production("block_param : f_arg LITERAL_COMMA f_block_optarg LITERAL_COMMA f_rest_arg LITERAL_COMMA f_arg opt_f_block_arg")
    def block_param_f_arg_comma_f_block_optarg_comma_f_rest_arg_comma_f_arg_opt_f_block_arg(self, p):
        return self.new_args(
            args=self._new_list(p[0].getastlist() + p[2].getastlist()),
            splat_arg=p[4],
            block_arg=p[5]
        )

    @pg.production("block_param : f_arg LITERAL_COMMA f_block_optarg opt_f_block_arg")
    def block_param_f_arg_comma_f_block_optarg_opt_f_block_arg(self, p):
        return self.new_args(self._new_list(p[0].getastlist() + p[2].getastlist()), None, p[3])

    @pg.production("block_param : f_arg LITERAL_COMMA f_block_optarg LITERAL_COMMA f_arg opt_f_block_arg")
    def block_param_f_arg_comma_f_block_optarg_comma_f_arg_opt_f_block_arg(self, p):
        """
        f_arg ',' f_block_optarg ',' f_arg opt_f_block_arg {
                    $$ = support.new_args($1.getPosition(), $1, $3, null, $5, $6);
                }
        """
        raise NotImplementedError(p)

    @pg.production("block_param : f_arg LITERAL_COMMA f_rest_arg opt_f_block_arg")
    def block_param_f_arg_comma_f_rest_arg_opt_f_block_arg(self, p):
        return self.new_args(p[0], splat_arg=p[2], block_arg=p[3])

    @pg.production("block_param : f_arg LITERAL_COMMA")
    def block_param_f_arg_comma(self, p):
        self.lexer.symtable.declare_argument("*")
        tok = self.new_token(p[1], "IDENTIFIER", "*")
        return self.new_args(p[0], splat_arg=tok)

    @pg.production("block_param : f_arg LITERAL_COMMA f_rest_arg LITERAL_COMMA f_arg opt_f_block_arg")
    def block_param_f_arg_comma_f_rest_arg_comma_f_arg_opt_f_block_arg(self, p):
        """
        f_arg ',' f_rest_arg ',' f_arg opt_f_block_arg {
                    $$ = support.new_args($1.getPosition(), $1, null, $3, $5, $6);
                }
        """
        raise NotImplementedError(p)

    @pg.production("block_param : f_arg opt_f_block_arg")
    def block_param_f_arg_opt_f_block_arg(self, p):
        return self.new_args(p[0], block_arg=p[1])

    @pg.production("block_param : f_block_optarg LITERAL_COMMA f_rest_arg opt_f_block_arg")
    def block_param_f_block_optarg_comma_f_rest_arg_opt_f_block_arg(self, p):
        return self.new_args(p[0], splat_arg=p[2], block_arg=p[3])

    @pg.production("block_param : f_block_optarg LITERAL_COMMA f_rest_arg LITERAL_COMMA f_arg opt_f_block_arg")
    def block_param_f_block_optarg_comma_f_rest_arg_comma_f_arg_opt_f_block_arg(self, p):
        """
        f_block_optarg ',' f_rest_arg ',' f_arg opt_f_block_arg {
                    $$ = support.new_args(support.getPosition($1), null, $1, $3, $5, $6);
                }
        """
        raise NotImplementedError(p)

    @pg.production("block_param : f_block_optarg opt_f_block_arg")
    def block_param_f_block_optarg_opt_f_block_arg(self, p):
        return self.new_args(p[0], None, p[1])

    @pg.production("block_param : f_block_optarg LITERAL_COMMA f_arg opt_f_block_arg")
    def block_param_f_block_optarg_comma_f_arg_opt_f_block_arg(self, p):
        """
        f_block_optarg ',' f_arg opt_f_block_arg {
                    $$ = support.new_args($1.getPosition(), null, $1, null, $3, $4);
                }
        """
        raise NotImplementedError(p)

    @pg.production("block_param : f_rest_arg opt_f_block_arg")
    def block_param_f_rest_arg_opt_f_block_arg(self, p):
        return self.new_args(splat_arg=p[0], block_arg=p[1])

    @pg.production("block_param : f_rest_arg LITERAL_COMMA f_arg opt_f_block_arg")
    def block_param_f_rest_arg_comma_f_arg_opt_f_block_arg(self, p):
        """
        f_rest_arg ',' f_arg opt_f_block_arg {
                    $$ = support.new_args($1.getPosition(), null, null, $1, $3, $4);
                }
        """
        raise NotImplementedError(p)

    @pg.production("block_param : f_block_arg")
    def block_param_f_block_arg(self, p):
        return self.new_args(block_arg=p[0])

    @pg.production("opt_block_param : none")
    def opt_block_param_none(self, p):
        return self.new_args()

    @pg.production("opt_block_param : block_param_def")
    def opt_block_param(self, p):
        self.lexer.command_start = True
        return p[0]

    @pg.production("block_param_def : PIPE opt_bv_decl PIPE")
    def block_param_def_pipe_opt_bv_decl_pipe(self, p):
        return self.new_args()

    @pg.production("block_param_def : OROP")
    def block_param_def_orop(self, p):
        return self.new_args()

    @pg.production("block_param_def : PIPE block_param opt_bv_decl PIPE")
    def block_param_def_pipe_block_param_opt_bv_decl_pipe(self, p):
        return p[1]

    @pg.production("opt_bv_decl : opt_nl")
    def opt_bv_decl_opt_nl(self, p):
        return None

    @pg.production("opt_bv_decl : opt_nl LITERAL_SEMICOLON bv_decls opt_nl")
    def opt_bv_decl(self, p):
        return None

    @pg.production("bv_decls : bvar")
    def bv_decls_bvar(self, p):
        return None

    @pg.production("bv_decls : bv_decls LITERAL_COMMA bvar")
    def bv_decls(self, p):
        return None

    @pg.production("bvar : IDENTIFIER")
    def bvar_identifier(self, p):
        self.lexer.symtable.declare_local(p[0].getstr())

    @pg.production("bvar : f_bad_arg")
    def bvar_f_bad_arg(self, p):
        return None

    @pg.production("lambda : PRE_LAMBDA f_larglist lambda_body")
    def lambda_prod(self, p):
        self.lexer.left_paren_begin = p[0].getint()
        node = ast.SendBlock(
            p[1].getargs(),
            p[1].getsplatarg(),
            p[1].getblockarg(),
            ast.Block(p[2].getastlist()) if p[2] is not None else ast.Nil()
        )
        self.save_and_pop_scope(node)
        return BoxAST(ast.Lambda(node))

    @pg.production("PRE_LAMBDA :")
    def pre_lambda(self, p):
        self.push_block_scope()
        left_paren_begin = self.lexer.left_paren_begin
        self.lexer.paren_nest += 1
        self.lexer.left_paren_begin = self.lexer.paren_nest
        return BoxInt(left_paren_begin)

    @pg.production("f_larglist : LPAREN2 f_args opt_bv_decl RPAREN")
    def f_larglist_parens(self, p):
        return p[1]

    @pg.production("f_larglist : f_args opt_bv_decl")
    def f_larglist(self, p):
        return p[0]

    @pg.production("lambda_body : LAMBEG compstmt RCURLY")
    def lambda_body_lambeg(self, p):
        return p[1]

    @pg.production("lambda_body : DO_LAMBDA compstmt END")
    def lambda_body_do(self, p):
        return p[1]

    @pg.production("do_block : DO_BLOCK push_block_scope opt_block_param compstmt END")
    def do_block(self, p):
        box = self.new_send_block(p[0].getsourcepos().lineno, p[2], p[3])
        self.save_and_pop_scope(box.getast())
        return box

    @pg.production("push_block_scope : ")
    def push_block_scope_prod(self, p):
        self.push_block_scope()

    @pg.production("block_call : command do_block")
    def block_call_command_do_block(self, p):
        return self.combine_send_block(p[0], p[1])

    @pg.production("block_call : block_call DOT operation2 opt_paren_args")
    def block_call_dot_operation_opt_paren_args(self, p):
        """
        block_call tDOT operation2 opt_paren_args {
                    $$ = support.new_call($1, $3, $4, null);
                }
        """
        raise NotImplementedError(p)

    @pg.production("block_call : block_call COLON2 operation2 opt_paren_args")
    def block_call_colon_operation_opt_paren_args(self, p):
        """
        block_call tCOLON2 operation2 opt_paren_args {
                    $$ = support.new_call($1, $3, $4, null);
                }

        """
        raise NotImplementedError(p)

    @pg.production("method_call : operation paren_args")
    def method_call_operation_paren_args(self, p):
        return self.new_fcall(p[0], p[1])

    @pg.production("method_call : primary_value DOT operation2 opt_paren_args")
    def method_call_primary_value_dot_operation_opt_paren_args(self, p):
        return self.new_call(p[0], p[2], p[3])

    @pg.production("method_call : primary_value COLON2 operation2 paren_args")
    def method_call_primary_value_colon_operation_paren_args(self, p):
        return self.new_call(p[0], p[2], p[3])

    @pg.production("method_call : primary_value COLON2 operation3")
    def method_call_primary_value_colon_operation(self, p):
        return self.new_call(p[0], p[2], None)

    @pg.production("method_call : primary_value DOT paren_args")
    def method_call_primary_value_dot_paren_args(self, p):
        return self.new_call(p[0], self.new_token(p[1], "call", "call"), p[2])

    @pg.production("method_call : primary_value COLON2 paren_args")
    def method_call_primary_value_colon_paren_args(self, p):
        return self.new_call(p[0], self.new_token(p[1], "call", "call"), p[2])

    @pg.production("method_call : SUPER paren_args")
    def method_call_super_paren_args(self, p):
        return self.new_super(p[1], p[0])

    @pg.production("method_call : SUPER")
    def method_call_super(self, p):
        lineno = p[0].getsourcepos().lineno
        args = []
        for n, tp in self.lexer.symtable.arguments:
            if tp == self.lexer.symtable.BLOCK_ARG:
                continue
            node = ast.Variable(n, lineno)
            if tp == self.lexer.symtable.SPLAT_ARG:
                node = ast.Splat(node)
            args.append(node)
        return BoxAST(ast.Super(args, None, lineno))

    @pg.production("method_call : primary_value LITERAL_LBRACKET opt_call_args rbracket")
    def method_call_primary_value_lbracket_opt_call_args_rbracket(self, p):
        return self.new_call(p[0], self.new_token(p[1], "[]", "[]"), p[2])

    @pg.production("brace_block : LCURLY push_block_scope opt_block_param compstmt RCURLY")
    def brace_block_curly(self, p):
        box = self.new_send_block(p[0].getsourcepos().lineno, p[2], p[3])
        self.save_and_pop_scope(box.getast())
        return box

    @pg.production("brace_block : DO push_block_scope opt_block_param compstmt END")
    def brace_block_do(self, p):
        box = self.new_send_block(p[0].getsourcepos().lineno, p[2], p[3])
        self.save_and_pop_scope(box.getast())
        return box

    @pg.production("case_body : WHEN args then compstmt cases")
    def case_body(self, p):
        body = ast.Block(p[3].getastlist()) if p[3] is not None else ast.Nil()
        items = [
            ast.When(p[1].getcallargs(), body, p[0].getsourcepos().lineno)
        ]
        items.extend(p[4].getastlist())
        return self._new_list(items)

    @pg.production("cases : opt_else")
    def cases_opt_else(self, p):
        body = p[0].getast() if p[0] is not None else ast.Nil()
        # TODO: a real line number here
        return self.new_list(BoxAST(ast.When(None, body, -1)))

    @pg.production("cases : case_body")
    def cases_case_body(self, p):
        return p[0]

    @pg.production("opt_rescue : RESCUE exc_list exc_var then compstmt opt_rescue")
    def opt_rescue(self, p):
        handlers = [
            ast.ExceptHandler(
                p[1].getastlist() if p[1] is not None else [],
                p[2].getast() if p[2] is not None else None,
                ast.Block(p[4].getastlist()) if p[4] is not None else ast.Nil(),
            )
        ]
        if p[5] is not None:
            handlers.extend(p[5].getastlist())
        return BoxASTList(handlers)

    @pg.production("opt_rescue : ")
    def opt_rescue_empty(self, p):
        return None

    @pg.production("exc_list : arg_value")
    def exc_list_arg_value(self, p):
        return self.new_list(p[0])

    @pg.production("exc_list : mrhs")
    def exc_list_mrhs(self, p):
        return p[0]

    @pg.production("exc_list : none")
    def exc_list_none(self, p):
        return p[0]

    @pg.production("exc_var  : ASSOC lhs")
    def exc_var(self, p):
        return p[1]

    @pg.production("exc_var : none")
    def exc_var_none(self, p):
        return p[0]

    @pg.production("opt_ensure : ENSURE compstmt")
    def opt_ensure(self, p):
        return p[1]

    @pg.production("opt_ensure : none")
    def opt_ensure_none(self, p):
        return p[0]

    @pg.production("literal : numeric")
    def literal_numeric(self, p):
        return p[0]

    @pg.production("literal : symbol")
    def literal_symbol(self, p):
        return self.new_symbol(p[0])

    @pg.production("literal : dsym")
    def literal_dsym(self, p):
        return p[0]

    @pg.production("strings : string")
    def strings(self, p):
        return p[0]

    @pg.production("string : CHAR")
    def string_char(self, p):
        # TODO: encoding
        return BoxAST(ast.ConstantString(p[0].getstr()))

    @pg.production("string : string1")
    def string_string1(self, p):
        return p[0]

    @pg.production("string : string string1")
    def string_string_string1(self, p):
        return self.concat_literals(p[0], p[1])

    @pg.production("string1 : STRING_BEG string_contents STRING_END")
    def string1(self, p):
        return p[1]

    @pg.production("xstring : XSTRING_BEG xstring_contents STRING_END")
    def xstring(self, p):
        return self.new_fcall(self.new_token(p[0], "`", "`"), self.new_call_args(p[1]))

    @pg.production("regexp : REGEXP_BEG xstring_contents REGEXP_END")
    def regexp(self, p):
        str_flags = p[2].getstr()
        flags = 0
        for f in str_flags:
            flags |= regexp.OPTIONS_MAP[f]
        if p[1] is not None:
            n = p[1].getast()
            if isinstance(n, ast.ConstantString):
                node = ast.ConstantRegexp(n.strvalue, flags, p[0].getsourcepos().lineno)
            else:
                node = ast.DynamicRegexp(n, flags)
        else:
            node = ast.ConstantRegexp("", flags, p[0].getsourcepos().lineno)
        return BoxAST(node)

    @pg.production("words : WORDS_BEG LITERAL_SPACE STRING_END")
    def words_space(self, p):
        """
        tWORDS_BEG ' ' tSTRING_END {
                    $$ = new ZArrayNode($1.getPosition());
                }
        """
        raise NotImplementedError(p)

    @pg.production("words : WORDS_BEG word_list STRING_END")
    def words_word_list(self, p):
        return BoxAST(ast.Array(p[1].getastlist()))

    @pg.production("word_list : ")
    def word_list_empty(self, p):
        return self.new_list()

    @pg.production("word_list : word_list word LITERAL_SPACE")
    def word_list(self, p):
        return self.append_to_list(p[0], p[1])

    @pg.production("word : string_content")
    def word_string_content(self, p):
        return p[0]

    @pg.production("word : word string_content")
    def word(self, p):
        """
        word string_content {
                     $$ = support.literal_concat(support.getPosition($1), $1, $2);
                }
        """
        raise NotImplementedError(p)

    @pg.production("qwords : QWORDS_BEG LITERAL_SPACE STRING_END")
    def qwords_space(self, p):
        return BoxAST(ast.Array([]))

    @pg.production("qwords : QWORDS_BEG qword_list STRING_END")
    def qwords_qword_list(self, p):
        return BoxAST(ast.Array(p[1].getastlist()))

    @pg.production("qword_list : ")
    def qword_list_empty(self, p):
        return self.new_list()

    @pg.production("qword_list : qword_list STRING_CONTENT LITERAL_SPACE")
    def qword_list(self, p):
        return self.append_to_list(p[0], BoxAST(ast.ConstantString(p[1].getstr())))

    @pg.production("string_contents : ")
    def string_contents_empty(self, p):
        # TODO: Encoding?
        return BoxAST(ast.ConstantString(""))

    @pg.production("string_contents : string_contents string_content")
    def string_contents(self, p):
        return self.concat_literals(p[0], p[1])

    @pg.production("xstring_contents : ")
    def xstring_contents_empty(self, p):
        return None

    @pg.production("xstring_contents : xstring_contents string_content")
    def xstring_contents(self, p):
        return self.concat_literals(p[0], p[1])

    @pg.production("string_content : STRING_CONTENT")
    def string_content_string_content(self, p):
        return BoxAST(ast.ConstantString(p[0].getstr()))

    @pg.production("string_content : string_dvar_prod string_dvar")
    def string_content_string_dvar(self, p):
        self.lexer.str_term = p[0].getstrterm()
        return p[1]

    @pg.production("string_dvar_prod : STRING_DVAR")
    def string_dvar_prod(self, p):
        str_term = self.lexer.str_term
        self.lexer.str_term = None
        self.lexer.state = self.lexer.EXPR_BEG
        return BoxStrTerm(str_term)

    @pg.production("string_content : string_dbeg compstmt RCURLY")
    def string_content_string_dbeg(self, p):
        self.lexer.condition_state.restart()
        self.lexer.cmd_argument_state.restart()
        self.lexer.str_term = p[0].getstrterm()
        if p[1]:
            return BoxAST(ast.DynamicString([ast.Block(p[1].getastlist())]))
        else:
            return None

    @pg.production("string_dbeg : STRING_DBEG")
    def string_dbeg(self, p):
        str_term = self.lexer.str_term
        self.lexer.condition_state.stop()
        self.lexer.cmd_argument_state.stop()
        self.lexer.str_term = None
        self.lexer.state = self.lexer.EXPR_BEG
        return BoxStrTerm(str_term)

    @pg.production("string_dvar : GVAR")
    def string_dvar_gvar(self, p):
        return self.new_global(p[0])

    @pg.production("string_dvar : IVAR")
    def string_dvar_ivar(self, p):
        return self.new_instance_var(p[0])

    @pg.production("string_dvar : CVAR")
    def string_dvar_cvar(self, p):
        return self.new_class_var(p[0])

    @pg.production("string_dvar : backref")
    def string_dvar_backref(self, p):
        return p[0]

    @pg.production("symbol : SYMBEG sym")
    def symbol(self, p):
        self.lexer.state = self.lexer.EXPR_END
        return p[1]

    @pg.production("sym : CVAR")
    @pg.production("sym : GVAR")
    @pg.production("sym : IVAR")
    @pg.production("sym : fname")
    def sym(self, p):
        return p[0]

    @pg.production("dsym : SYMBEG xstring_contents STRING_END")
    def dsym(self, p):
        box = p[1]
        if box is None:
            return BoxAST(ast.ConstantSymbol(""))
        node = box.getast()
        if isinstance(node, ast.ConstantString):
            return BoxAST(ast.ConstantSymbol(node.strvalue))
        else:
            return BoxAST(ast.Symbol(node, p[0].getsourcepos().lineno))

    @pg.production("numeric : INTEGER")
    def numeric_integer(self, p):
        return BoxAST(self._parse_int(p[0]))

    @pg.production("numeric : FLOAT")
    def numeric_float(self, p):
        return BoxAST(ast.ConstantFloat(float(p[0].getstr())))

    @pg.production("numeric : UMINUS_NUM INTEGER", precedence="LOWEST")
    def numeric_minus_integer(self, p):
        return BoxAST(self._parse_int(p[1]).negate())

    @pg.production("numeric : UMINUS_NUM FLOAT", precedence="LOWEST")
    def numeric_minus_float(self, p):
        return BoxAST(ast.ConstantFloat(-float(p[1].getstr())))

    @pg.production("user_variable : IDENTIFIER")
    def variable_identifier(self, p):
        return BoxAST(ast.Variable(p[0].getstr(), p[0].getsourcepos().lineno))

    @pg.production("user_variable : IVAR")
    def variable_ivar(self, p):
        return self.new_instance_var(p[0])

    @pg.production("user_variable : GVAR")
    def variable_gvar(self, p):
        return self.new_global(p[0])

    @pg.production("user_variable : CONSTANT")
    def variable_constant(self, p):
        return BoxAST(ast.Constant(
            p[0].getstr(),
            p[0].getsourcepos().lineno
        ))

    @pg.production("user_variable : CVAR")
    def variable_cvar(self, p):
        return self.new_class_var(p[0])

    @pg.production("keyword_variable : NIL")
    def variable_nil(self, p):
        return BoxAST(ast.Nil())

    @pg.production("keyword_variable : SELF")
    def variable_self(self, p):
        return BoxAST(ast.Self(p[0].getsourcepos().lineno))

    @pg.production("keyword_variable : TRUE")
    def variable_true(self, p):
        return BoxAST(ast.ConstantBool(True))

    @pg.production("keyword_variable : FALSE")
    def variable_false(self, p):
        return BoxAST(ast.ConstantBool(False))

    @pg.production("keyword_variable : __FILE__")
    def variable__file__(self, p):
        return BoxAST(ast.File())

    @pg.production("keyword_variable : __LINE__")
    def variable__line__(self, p):
        return BoxAST(ast.Line(p[0].getsourcepos().lineno))

    @pg.production("keyword_variable : __ENCODING__")
    def variable__encoding__(self, p):
        raise NotImplementedError(p)
        return BoxAST(ast.Encoding())

    @pg.production("var_ref : keyword_variable")
    @pg.production("var_ref : user_variable")
    def var_ref(self, p):
        node = p[0].getast()
        if isinstance(node, ast.Variable):
            if self.lexer.symtable.is_defined(node.name):
                self.lexer.symtable.declare_read(node.name)
                return p[0]
            else:
                return BoxAST(ast.Send(ast.Self(node.lineno), node.name, [], None, node.lineno))
        else:
            return p[0]

    @pg.production("var_lhs : user_variable")
    @pg.production("var_lhs : keyword_variable")
    def var_lhs(self, p):
        return self.assignable(p[0])

    @pg.production("backref : BACK_REF")
    @pg.production("backref : NTH_REF")
    def backref(self, p):
        return p[0]

    @pg.production("superclass : term")
    def superclass_term(self, p):
        return None

    @pg.production("superclass : superclass_lt expr_value term")
    def superclass(self, p):
        return p[1]

    @pg.production("superclass_lt : LT")
    def superclass_lt(self, p):
        self.lexer.state = self.lexer.EXPR_BEG

    @pg.production("superclass : error term")
    def superclass_error(self, p):
        return None

    @pg.production("f_arglist : LPAREN2 f_args rparen")
    def f_arglist_parens(self, p):
        self.lexer.state = self.lexer.EXPR_BEG
        self.lexer.command_start = True
        return p[1]

    @pg.production("f_arglist : f_args term")
    def f_arglist(self, p):
        self.lexer.state = self.lexer.EXPR_BEG
        self.lexer.command_start = True
        return p[0]

    @pg.production("f_args : f_arg LITERAL_COMMA f_optarg LITERAL_COMMA f_rest_arg opt_f_block_arg")
    def f_args_f_arg_comma_f_optarg_comma_f_rest_arg_opt_f_block_arg(self, p):
        return self.new_args(
            self._new_list(p[0].getastlist() + p[2].getastlist()),
            splat_arg=p[4],
            block_arg=p[5],
        )

    @pg.production("f_args : f_arg LITERAL_COMMA f_optarg LITERAL_COMMA f_rest_arg LITERAL_COMMA f_arg opt_f_block_arg")
    def f_args_f_arg_comma_f_optarg_comma_f_rest_arg_comma_f_arg_opt_f_block_arg(self, p):
        """
        f_arg ',' f_optarg ',' f_rest_arg ',' f_arg opt_f_block_arg {
                    $$ = support.new_args($1.getPosition(), $1, $3, $5, $7, $8);
                }
        """
        raise NotImplementedError(p)

    @pg.production("f_args : f_arg LITERAL_COMMA f_optarg opt_f_block_arg")
    def f_args_f_arg_comma_f_optarg_opt_f_block_arg(self, p):
        return self.new_args(
            self._new_list(p[0].getastlist() + p[2].getastlist()),
            block_arg=p[3],
        )

    @pg.production("f_args : f_arg LITERAL_COMMA f_optarg LITERAL_COMMA f_arg opt_f_block_arg")
    def f_args_f_arg_comma_f_optarg_comma_f_arg_opt_f_block_arg(self, p):
        return self.new_args(
            self._new_list(p[0].getastlist() + p[2].getastlist() + p[4].getastlist()),
            block_arg=p[5],
        )

    @pg.production("f_args : f_arg LITERAL_COMMA f_rest_arg opt_f_block_arg")
    def f_args_f_arg_comma_f_rest_arg_opt_f_block_arg(self, p):
        return self.new_args(
            p[0],
            splat_arg=p[2],
            block_arg=p[3],
        )

    @pg.production("f_args : f_arg LITERAL_COMMA f_rest_arg LITERAL_COMMA f_arg opt_f_block_arg")
    def f_args_f_arg_comma_f_rest_arg_comma_f_arg_opt_f_block_arg(self, p):
        """
        f_arg ',' f_rest_arg ',' f_arg opt_f_block_arg {
                    $$ = support.new_args($1.getPosition(), $1, null, $3, $5, $6);
                }
        """
        raise NotImplementedError(p)

    @pg.production("f_args : f_arg opt_f_block_arg")
    def f_args_f_arg_opt_f_block_arg(self, p):
        return self.new_args(p[0], block_arg=p[1])

    @pg.production("f_args : f_optarg LITERAL_COMMA f_rest_arg opt_f_block_arg")
    def f_args_f_optarg_comma_f_rest_arg_opt_f_block_arg(self, p):
        return self.new_args(p[0], splat_arg=p[2], block_arg=p[3])

    @pg.production("f_args : f_optarg LITERAL_COMMA f_rest_arg LITERAL_COMMA f_arg opt_f_block_arg")
    def f_args_f_optarg_comma_f_rest_arg_comma_f_arg_opt_f_block_arg(self, p):
        """
        f_optarg ',' f_rest_arg ',' f_arg opt_f_block_arg {
                    $$ = support.new_args($1.getPosition(), null, $1, $3, $5, $6);
                }
        """
        raise NotImplementedError(p)

    @pg.production("f_args : f_optarg opt_f_block_arg")
    def f_args_f_optarg_opt_f_block_arg(self, p):
        return self.new_args(p[0], block_arg=p[1])

    @pg.production("f_args : f_optarg LITERAL_COMMA f_arg opt_f_block_arg")
    def f_args_f_optarg_comma_f_arg_opt_f_block_arg(self, p):
        return self.new_args(
            self._new_list(p[0].getastlist() + p[2].getastlist()),
            block_arg=p[3]
        )

    @pg.production("f_args : f_rest_arg opt_f_block_arg")
    def f_args_f_rest_arg_opt_f_block_arg(self, p):
        return self.new_args(splat_arg=p[0], block_arg=p[1])

    @pg.production("f_args : f_rest_arg LITERAL_COMMA f_arg opt_f_block_arg")
    def f_args_f_rest_arg_comma_f_arg_opt_f_block_arg(self, p):
        self.lexer.symtable.declare_argument("2", self.lexer.symtable.SPLAT_ARG)
        splat = ast.Splat(ast.Variable(p[0].getstr(), -1))
        assignable = self._new_assignable_list([splat] + self.args_to_variables(p[2]))
        return BoxArgs([assignable.getassignment()], "2", p[3].getstr() if p[3] is not None else None)

    @pg.production("f_args : f_block_arg")
    def f_args_f_block_arg(self, p):
        return self.new_args(block_arg=p[0])

    @pg.production("f_args : ")
    def f_args_none(self, p):
        return self.new_args()

    @pg.production("f_bad_arg : CONSTANT")
    def f_bad_arg_constant(self, p):
        raise self.error("formal argument cannot be a constant")

    @pg.production("f_bad_arg : IVAR")
    def f_bad_arg_ivar(self, p):
        raise self.error("formal argument cannot be an instance variable")

    @pg.production("f_bad_arg : GVAR")
    def f_bad_arg_gvar(self, p):
        raise self.error("formal argument cannot be a global variable")

    @pg.production("f_bad_arg : CVAR")
    def f_bad_arg_cvar(self, p):
        raise self.error("formal argument cannot be a class variable")

    @pg.production("f_norm_arg : f_bad_arg")
    def f_norm_arg_f_bad_arg(self, p):
        return p[0]

    @pg.production("f_norm_arg : IDENTIFIER")
    def f_norm_arg_identifier(self, p):
        return BoxAST(ast.Argument(p[0].getstr()))

    @pg.production("f_arg_item : f_norm_arg")
    def f_arg_item_f_norm_arg(self, p):
        node = p[0].getast(ast.Argument)
        self.lexer.symtable.declare_argument(node.name)
        return p[0]

    @pg.production("f_arg_item : LPAREN f_margs rparen")
    def f_arg_item_paren(self, p):
        return BoxAST(p[1].getassignment())

    @pg.production("f_arg : f_arg_item")
    def f_arg_f_arg_item(self, p):
        return self.new_list(p[0])

    @pg.production("f_arg : f_arg LITERAL_COMMA f_arg_item")
    def f_arg(self, p):
        return self.append_to_list(p[0], p[2])

    @pg.production("f_opt : IDENTIFIER LITERAL_EQUAL arg_value")
    def f_opt(self, p):
        self.lexer.symtable.declare_argument(p[0].getstr())
        return BoxAST(ast.Argument(p[0].getstr(), p[2].getast()))

    @pg.production("f_block_opt : IDENTIFIER LITERAL_EQUAL primary_value")
    def f_block_opt(self, p):
        self.lexer.symtable.declare_argument(p[0].getstr())
        return BoxAST(ast.Argument(p[0].getstr(), p[2].getast()))

    @pg.production("f_block_optarg : f_block_opt")
    def f_block_optarg_f_block_opt(self, p):
        return self.new_list(p[0])

    @pg.production("f_block_optarg : f_block_optarg LITERAL_COMMA f_block_opt")
    def f_block_optarg(self, p):
        return self.append_to_list(p[0], p[2])

    @pg.production("f_optarg : f_opt")
    def f_optarg_f_opt(self, p):
        return self.new_list(p[0])

    @pg.production("f_optarg : f_optarg LITERAL_COMMA f_opt")
    def f_optarg(self, p):
        return self.append_to_list(p[0], p[2])

    @pg.production("restarg_mark : STAR")
    @pg.production("restarg_mark : STAR2")
    def restarg_mark(self, p):
        return p[0]

    @pg.production("f_rest_arg : restarg_mark IDENTIFIER")
    def f_rest_arg_restarg_mark_identifer(self, p):
        self.lexer.symtable.declare_argument(p[1].getstr(), self.lexer.symtable.SPLAT_ARG)
        return p[1]

    @pg.production("f_rest_arg : restarg_mark")
    def f_rest_arg_restarg_mark(self, p):
        self.lexer.symtable.declare_argument("*", self.lexer.symtable.SPLAT_ARG)
        return self.new_token(p[0], "IDENTIFIER", "*")

    @pg.production("blkarg_mark : AMPER")
    @pg.production("blkarg_mark : AMPER2")
    def blkarg_mark(self, p):
        return p[0]

    @pg.production("f_block_arg : blkarg_mark IDENTIFIER")
    def f_block_arg(self, p):
        self.lexer.symtable.declare_argument(p[1].getstr(), self.lexer.symtable.BLOCK_ARG)
        return p[1]

    @pg.production("opt_f_block_arg : LITERAL_COMMA f_block_arg")
    def opt_f_block_arg(self, p):
        return p[1]

    @pg.production("opt_f_block_arg : ")
    def opt_f_block_arg_empty(self, p):
        return None

    @pg.production("singleton : var_ref")
    def singleton_var_ref(self, p):
        return p[0]

    @pg.production("singleton : LPAREN expr rparen")
    def singleton_paren(self, p):
        """
        tLPAREN2 {
                    lexer.setState(LexState.EXPR_BEG);
                } expr rparen {
                    if ($3 == null) {
                        support.yyerror("can't define single method for ().");
                    } else if ($3 instanceof ILiteralNode) {
                        support.yyerror("can't define single method for literals.");
                    }
                    support.checkExpression($3);
                    $$ = $3;
                }
        """
        raise NotImplementedError(p)

    @pg.production("assoc_list : none")
    def assoc_list_none(self, p):
        return self.new_list()

    @pg.production("assoc_list : assocs trailer")
    def assoc_list(self, p):
        return p[0]

    @pg.production("assocs : assoc")
    def assocs_assoc(self, p):
        return p[0]

    @pg.production("assocs : assocs LITERAL_COMMA assoc")
    def assocs(self, p):
        return self._new_list(p[0].getastlist() + p[2].getastlist())

    @pg.production("assoc : arg_value ASSOC arg_value")
    def assoc_arg_value(self, p):
        return self.append_to_list(self.new_list(p[0]), p[2])

    @pg.production("assoc : LABEL arg_value")
    def assoc_label(self, p):
        return self.append_to_list(self.new_list(self.new_symbol(p[0])), p[1])

    @pg.production("operation : FID")
    @pg.production("operation : CONSTANT")
    @pg.production("operation : IDENTIFIER")
    def operation(self, p):
        return p[0]

    @pg.production("operation2 : op")
    @pg.production("operation2 : FID")
    @pg.production("operation2 : CONSTANT")
    @pg.production("operation2 : IDENTIFIER")
    def operation2(self, p):
        return p[0]

    @pg.production("operation3 : op")
    @pg.production("operation3 : FID")
    @pg.production("operation3 : IDENTIFIER")
    def operation3(self, p):
        return p[0]

    @pg.production("dot_or_colon : COLON2")
    @pg.production("dot_or_colon : DOT")
    def dot_or_colon(self, p):
        return p[0]

    @pg.production("opt_terms : ")
    def opt_terms_none(self, p):
        return None

    @pg.production("opt_terms : terms")
    def opt_terms(self, p):
        return p[0]

    @pg.production("opt_nl : ")
    def opt_nl_none(self, p):
        return None

    @pg.production("opt_nl : LITERAL_NEWLINE")
    def opt_nl(self, p):
        return None

    @pg.production("rparen : opt_nl RPAREN")
    def rparen(self, p):
        return p[1]

    @pg.production("rbracket : opt_nl RBRACK")
    def rbracket(self, p):
        return p[1]

    @pg.production("trailer : ")
    def trailer_none(self, p):
        return None

    @pg.production("trailer : LITERAL_COMMA")
    @pg.production("trailer : LITERAL_NEWLINE")
    def trailer(self, p):
        return p[0]

    @pg.production("term : LITERAL_NEWLINE")
    @pg.production("term : LITERAL_SEMICOLON")
    def term(self, p):
        return p[0]

    @pg.production("terms : term")
    def terms_term(self, p):
        return p[0]

    @pg.production("terms : terms LITERAL_SEMICOLON")
    def terms(self, p):
        return p[0]

    @pg.production("none : ")
    def none(self, p):
        return None

    @pg.production("none_block_pass : ")
    def none_block_pass(self, p):
        return None

    parser = pg.build()


class LexerWrapper(object):
    def __init__(self, lexer):
        self.lexer = lexer

    def next(self):
        try:
            return self.lexer.next()
        except StopIteration:
            return None


class BoxAST(BaseBox):
    def __init__(self, node):
        self.node = node

    @specialize.arg(1)
    def getast(self, cls=None):
        node = self.node
        if cls is not None:
            assert isinstance(node, cls)
        return node


class BoxASTList(BaseBox):
    def __init__(self, nodes):
        self.nodes = nodes

    def getastlist(self):
        return self.nodes


class BoxCallArgs(BaseBox):
    """
    A box for the arguments of a call/send.
    """
    def __init__(self, args, block):
        self.args = args
        self.block = block

    def getcallargs(self):
        return self.args

    def getcallblock(self):
        return self.block


class BoxInt(BaseBox):
    def __init__(self, intvalue):
        self.intvalue = intvalue

    def getint(self):
        return self.intvalue


class BoxArgs(BaseBox):
    """
    A box for the arguments of a function/block definition.
    """
    def __init__(self, args, splat_arg, block_arg):
        self.args = args
        self.splat_arg = splat_arg
        self.block_arg = block_arg

    def getargs(self, include_multi=False):
        if self.is_multiassignment() and not include_multi:
            return []
        else:
            return self.args

    def getsplatarg(self):
        return self.splat_arg

    def getblockarg(self):
        return self.block_arg

    def is_multiassignment(self):
        return len(self.args) == 1 and isinstance(self.args[0], ast.MultiAssignable)

    def getfullbody(self, block):
        if self.is_multiassignment():
            prebody = ast.Statement(ast.MultiAssignment(self.args[0], ast.Variable("2", -1)))
            if isinstance(block, ast.Nil):
                return ast.Block([prebody])
            elif isinstance(block, ast.Block):
                return ast.Block([prebody] + block.stmts)
            else:
                raise SystemError
        else:
            return block


class BoxStrTerm(BaseBox):
    def __init__(self, str_term):
        self.str_term = str_term

    def getstrterm(self):
        return self.str_term


class BoxAssignableList(BaseBox):
    def __init__(self, vars):
        self.vars = vars

    def getassignment(self):
        return ast.MultiAssignable(self.vars)

    def getvars(self):
        return self.vars


class BoxForVars(BaseBox):
    def __init__(self, for_var):
        self.for_var = for_var
        self.argument = ast.Argument("0")

    def getargument(self):
        return self.argument

    def get_for_var(self):
        return self.for_var

########NEW FILE########
__FILENAME__ = scope
import copy


class StaticScope(object):
    _immutable_fields_ = ["w_mod", "backscope"]

    def __init__(self, w_mod, backscope):
        self.w_mod = w_mod
        self.backscope = backscope

    def __deepcopy__(self, memo):
        return StaticScope(copy.deepcopy(self.w_mod, memo), copy.deepcopy(self.backscope, memo))

########NEW FILE########
__FILENAME__ = system
import sys
import os
import platform

IS_POSIX = os.name == "posix"
IS_WINDOWS = os.name == "nt"
IS_LINUX = "linux" in sys.platform
IS_64BIT = "64bit" in platform.architecture()[0]
IS_CYGWIN = "cygwin" == sys.platform

########NEW FILE########
__FILENAME__ = make_release
import os
import sys
import tarfile


PROJECT_ROOT = os.path.join(os.path.dirname(__file__), os.path.pardir, os.path.pardir)


def main(argv):
    target = argv[0]
    t = tarfile.open(target, mode="w:bz2")
    for name in [
        "bin/topaz.exe" if sys.platform == "win32" else "bin/topaz",
        "lib-ruby",
        "lib-topaz",
        "AUTHORS.rst",
        "LICENSE",
        "README.rst"
    ]:
        t.add(os.path.join(PROJECT_ROOT, name), arcname="topaz/%s" % name)
    t.add(
        os.path.join(PROJECT_ROOT, "docs"), "topaz/docs",
        filter=lambda info: info if "_build" not in info.name else None
    )
    t.close()


if __name__ == "__main__":
    main(sys.argv[1:])

########NEW FILE########
__FILENAME__ = cache
from rpython.rlib.objectmodel import specialize


class Cache(object):
    def __init__(self, space):
        self.space = space
        self.contents = {}

    @specialize.memo()
    def getorbuild(self, key):
        try:
            return self.contents[key]
        except KeyError:
            builder = self._build(key)
            self.contents[key] = builder.next()
            try:
                builder.next()
            except StopIteration:
                pass
            else:
                raise RuntimeError("generator didn't stop")
            return self.contents[key]

    def _freeze_(self):
        return True

########NEW FILE########
__FILENAME__ = filemode
import os

from topaz.objects.stringobject import W_StringObject
from topaz.utils.ll_file import O_BINARY


def map_filemode(space, w_mode):
    encoding = ""
    if w_mode is space.w_nil:
        mode = os.O_RDONLY
    elif isinstance(w_mode, W_StringObject):
        mode_str = space.str_w(w_mode)
        mode = 0
        invalid_error = space.error(space.w_ArgumentError,
            "invalid access mode %s" % mode_str
        )
        major_mode_seen = False
        readable = writeable = append = False

        pos = 0
        for ch in mode_str:
            pos += 1
            if ch == "b":
                mode |= O_BINARY
            elif ch == "+":
                readable = writeable = True
            elif ch == "r":
                if major_mode_seen:
                    raise invalid_error
                major_mode_seen = True
                readable = True
            elif ch == "a":
                if major_mode_seen:
                    raise invalid_error
                major_mode_seen = True
                mode |= os.O_CREAT
                append = writeable = True
            elif ch == "w":
                if major_mode_seen:
                    raise invalid_error
                major_mode_seen = True
                mode |= os.O_TRUNC | os.O_CREAT
                writeable = True
            elif ch == ":":
                encoding = mode_str[pos + 1:]
                break
            else:
                raise invalid_error
        if readable and writeable:
            mode |= os.O_RDWR
        elif readable:
            mode |= os.O_RDONLY
        elif writeable:
            mode |= os.O_WRONLY
        if append:
            mode |= os.O_APPEND
    else:
        mode = space.int_w(w_mode)
    return (mode, encoding)

########NEW FILE########
__FILENAME__ = formatting
from rpython.rlib import jit
from rpython.rlib.rfloat import formatd
from rpython.rlib.unroll import unrolling_iterable


FORMAT_CHARS = unrolling_iterable([
    "s", "d", "f"
])


class StringFormatter(object):
    def __init__(self, fmt, items_w):
        self.fmt = fmt
        self.items_w = items_w
        self.item_index = 0

    @jit.look_inside_iff(lambda self, space: jit.isconstant(self.fmt))
    def format(self, space):
        i = 0
        result_w = []
        while True:
            start = i
            while i < len(self.fmt):
                if self.fmt[i] == "%":
                    break
                i += 1
            else:
                result_w.append(space.newstr_fromstr(self.fmt[start:i]))
                break
            result_w.append(space.newstr_fromstr(self.fmt[start:i]))
            i += 1
            width = 0
            while self.fmt[i].isdigit():
                width = width * 10 + (ord(self.fmt[i]) - ord("0"))
                i += 1
            format_char = self.fmt[i]
            w_item = self.items_w[self.item_index]
            self.item_index += 1
            i += 1
            for c in FORMAT_CHARS:
                if c == format_char:
                    w_res = getattr(self, "fmt_" + c)(space, w_item, width)
                    result_w.append(w_res)
                    break
            else:
                raise NotImplementedError(format_char)
        return result_w

    def _fmt_num(self, space, num, width):
        return space.newstr_fromstr((width - len(num)) * "0" + num)

    def fmt_s(self, space, w_item, width):
        return space.send(w_item, "to_s")

    def fmt_d(self, space, w_item, width):
        num = space.int_w(w_item)
        return self._fmt_num(space, str(num), width)

    def fmt_f(self, space, w_item, width):
        num = space.float_w(w_item)
        return self._fmt_num(space, formatd(num, "f", 6), width)

########NEW FILE########
__FILENAME__ = glob
import os

from rpython.rlib.rsre import rsre_core
from rpython.rlib.rstring import StringBuilder

from topaz.objects.fileobject import FNM_NOESCAPE, FNM_DOTMATCH
from topaz.utils import regexp
from topaz.utils.ll_file import isdir
from topaz.utils.ordereddict import OrderedDict


def regexp_match(cache, re, string):
    pos = 0
    endpos = len(string)
    code, flags, _, _, _, _ = regexp.compile(cache, re)
    return rsre_core.StrMatchContext(code, string, pos, endpos, flags)


def path_split(string):
    if not string:
        return [""]
    parts = []
    for part in string.split("/"):
        parts.append("/")
        if part:
            parts.append(part)
    return parts[1:]


def combine_segments(old_segments, suffix, new_segments=[""]):
    segments = []
    for old_seg in old_segments:
        for new_seg in new_segments:
            segments.append(old_seg + suffix + new_seg)
    return segments


class Glob(object):
    def __init__(self, cache, matches=None):
        self.cache = cache
        self._matches = OrderedDict()
        for match in (matches or []):
            self.append_match(match)

    def matches(self):
        return self._matches.keys()

    def append_match(self, match):
        self._matches[match] = None

    def is_constant(self, part, flags):
        special_chars = "?*["
        if not (flags & FNM_NOESCAPE):
            special_chars += "\\"
        for ch in part:
            if ch in special_chars:
                return False
        return True

    def single_compile(self, glob, flags=0):
        parts = path_split(glob)

        if parts[-1] == "/":
            last = DirectoriesOnly(None, flags)
        else:
            file = parts.pop()
            if self.is_constant(file, flags):
                last = ConstantEntry(None, flags, file)
            else:
                last = EntryMatch(None, flags, file)

        while parts:
            sep_parts = []
            while parts and parts[-1] == "/":
                sep_parts.append(parts.pop())
            last.separator = "".join(sep_parts)
            if not parts:
                last = RootDirectory(last, flags)
            else:
                dir = parts.pop()
                if dir == "**":
                    if parts:
                        last = RecursiveDirectories(last, flags)
                    else:
                        last = StartRecursiveDirectories(last, flags)
                elif self.is_constant(dir, flags):
                    last = ConstantDirectory(last, flags, dir)
                else:
                    last = DirectoryMatch(last, flags, dir)

        return last

    def run(self, node):
        node.call(self, None)

    def glob(self, pattern, flags):
        if "{" in pattern:
            patterns = self.compile(pattern, flags)
            for node in patterns:
                self.run(node)
        else:
            node = self.single_compile(pattern, flags)
            if node:
                self.run(node)

    def process_braces(self, pattern, flags, i=0):
        should_escape = flags & FNM_NOESCAPE == 0
        patterns = []

        escaped = False
        pattern_start = i
        segments = [""]
        while i < len(pattern):
            ch = pattern[i]
            if ch == "\\" and should_escape and not escaped:
                escaped = True
            elif ch == ",":
                if escaped:
                    escaped = False
                else:
                    suffix = pattern[pattern_start:i]
                    patterns.extend(combine_segments(segments, suffix))
                    segments = [""]
                    pattern_start = i + 1
            elif ch == "}":
                if escaped:
                    escaped = False
                else:
                    suffix = pattern[pattern_start:i]
                    patterns.extend(combine_segments(segments, suffix))
                    return i, patterns
            elif ch == "{":
                if escaped:
                    escaped = False
                else:
                    suffix = pattern[pattern_start:i]
                    i, new_segs = self.process_braces(pattern, flags, i + 1)
                    segments = combine_segments(segments, suffix, new_segs)
                    pattern_start = i + 1
            else:
                escaped = False
            i += 1

        suffix = pattern[pattern_start:]
        patterns.extend(combine_segments(segments, suffix))
        return i, patterns

    def compile(self, pattern, flags=0):
        i, patterns = self.process_braces(pattern, flags)
        return [self.single_compile(p) for p in patterns]


class Node(object):
    def __init__(self, nxt, flags):
        self.flags = flags
        self.next = nxt
        self.separator = "/"

    def allow_dots(self):
        return self.flags & FNM_DOTMATCH != 0

    def path_join(self, parent, ent):
        if not parent:
            return ent
        if parent == "/":
            return "/" + ent
        else:
            return parent + self.separator + ent


class ConstantDirectory(Node):
    def __init__(self, nxt, flags, dir):
        Node.__init__(self, nxt, flags)
        self.dir = dir

    def call(self, glob, path):
        full = self.path_join(path, self.dir)
        self.next.call(glob, full)


class ConstantEntry(Node):
    def __init__(self, nxt, flags, name):
        Node.__init__(self, nxt, flags)
        self.name = name

    def call(self, glob, parent):
        path = self.path_join(parent, self.name)
        if os.path.exists(path):
            glob.append_match(path)


class RootDirectory(Node):
    def call(self, glob, path):
        self.next.call(glob, "/")


class RecursiveDirectories(Node):
    def call(self, glob, start):
        if not (start and os.path.exists(start)):
            return
        self.call_with_stack(glob, start, [start])

    def call_with_stack(self, glob, start, stack):
        old_sep = self.next.separator
        self.next.separator = self.separator
        self.next.call(glob, start)
        self.next.separator = old_sep

        while stack:
            path = stack.pop()
            try:
                entries = os.listdir(path)
            except OSError:
                continue
            for ent in entries:
                full = self.path_join(path, ent)
                if isdir(full) and (self.allow_dots() or ent[0] != "."):
                    stack.append(full)
                    self.next.call(glob, full)


class StartRecursiveDirectories(RecursiveDirectories):
    def call(self, glob, start):
        stack = []
        for ent in os.listdir("."):
            if isdir(ent) and (self.allow_dots() or ent[0] != "."):
                stack.append(ent)
                self.next.call(glob, ent)
        self.call_with_stack(glob, None, stack)


class Match(Node):
    def __init__(self, nxt, flags, glob_pattern):
        Node.__init__(self, nxt, flags)
        self.match_dotfiles = self.allow_dots() or glob_pattern[0] == "."
        self.regexp = self.translate(glob_pattern, flags)

    def translate(self, pattern, flags):
        pattern = os.path.normcase(pattern)
        should_escape = flags & FNM_NOESCAPE == 0
        escaped = False
        i = 0
        n = len(pattern)
        res = StringBuilder(n)
        res.append("^")
        while i < n:
            c = pattern[i]
            i += 1
            if c == "\\":
                if should_escape and not escaped:
                    escaped = True
                else:
                    res.append("\\\\")
                    escaped = False
            elif c == "*":
                if escaped:
                    escaped = False
                    res.append("\\*")
                else:
                    res.append(".*")
                    # skip second `*' in directory wildcards
                    if i < n and pattern[i] == "*":
                        i += 1
            elif c == "?":
                if escaped:
                    escaped = False
                    res.append("\\?")
                else:
                    res.append(".")
            elif c == "[":
                if escaped:
                    escaped = False
                    res.append("\\[")
                else:
                    j = i
                    if j < n and pattern[j] == "^":
                        j += 1
                    if j < n and pattern[j] == "]":
                        j += 1
                    while j < n and pattern[j] != "]":
                        j += 1
                    if j >= n:
                        res.append("\\[")
                    else:
                        res.append("[")
                        if pattern[i] == "^":
                            res.append("^")
                            i += 1
                        elif pattern[i] == "^":
                            res.append("\\^")
                            i += 1
                        for ch in pattern[i:j]:
                            if ch == "\\":
                                res.append("\\\\")
                            else:
                                res.append(ch)
                        res.append("]")
                        i = j + 1
            else:
                escaped = False
                if not c.isalnum():
                    res.append("\\")
                res.append(c)
        res.append("$")
        return res.build()

    def ismatch(self, cache, string):
        string = os.path.normcase(string)
        if string.startswith(".") and not self.match_dotfiles:
            return False
        ctx = regexp_match(cache, self.regexp, string)
        return rsre_core.search_context(ctx)


class DirectoryMatch(Match):
    def call(self, glob, path):
        if path and not os.path.exists(path):
            return

        for ent in [".", ".."] + os.listdir(path if path else "."):
            if self.ismatch(glob.cache, ent):
                full = self.path_join(path, ent)
                if isdir(full):
                    self.next.call(glob, full)


class EntryMatch(Match):
    def call(self, glob, path):
        if path and not os.path.exists(path + "/."):
            return

        try:
            entries = [".", ".."] + os.listdir(path if path else ".")
        except OSError:
            return

        for ent in entries:
            if self.ismatch(glob.cache, ent):
                glob.append_match(self.path_join(path, ent))


class DirectoriesOnly(Node):
    def call(self, glob, path):
        if path and os.path.exists(path + "/."):
            if path == "/":
                glob.append_match("/")
            else:
                glob.append_match(path + "/")

########NEW FILE########
__FILENAME__ = ll_dir
from rpython.rlib import rposix
from rpython.rtyper.lltypesystem import rffi, lltype
from rpython.rtyper.tool import rffi_platform as platform
from rpython.translator.tool.cbuild import ExternalCompilationInfo

from topaz.system import IS_WINDOWS


if IS_WINDOWS:
    def opendir(_):
        raise NotImplementedError("directory operations on windows")
    readdir = closedir = opendir
else:
    eci = ExternalCompilationInfo(
        includes=["sys/types.h", "dirent.h"]
    )

    class CConfig:
        _compilation_info_ = eci
        DIRENT = platform.Struct("struct dirent", [
            ("d_name", lltype.FixedSizeArray(rffi.CHAR, 1))
        ])
    config = platform.configure(CConfig)
    DIRP = rffi.COpaquePtr("DIR")
    DIRENT = config["DIRENT"]
    DIRENTP = lltype.Ptr(DIRENT)

    # XXX macro=True is hack to make sure we get the correct kind of
    # dirent struct (which depends on defines)
    os_opendir = rffi.llexternal("opendir",
        [rffi.CCHARP], DIRP,
        compilation_info=eci,
        macro=True
    )
    os_readdir = rffi.llexternal("readdir",
        [DIRP], DIRENTP,
        compilation_info=eci,
        macro=True
    )
    os_closedir = rffi.llexternal("closedir",
        [DIRP], rffi.INT,
        compilation_info=eci,
        macro=True
    )

    def opendir(path):
        dirp = os_opendir(path)
        if not dirp:
            raise OSError(rposix.get_errno(), "error in opendir")
        return dirp

    def closedir(dirp):
        os_closedir(dirp)

    def readdir(dirp):
        rposix.set_errno(0)
        direntp = os_readdir(dirp)
        if not direntp:
            if rposix.get_errno() == 0:
                return None
            else:
                raise OSError(rposix.get_errno(), "error in readdir")
        namep = rffi.cast(rffi.CCHARP, direntp.c_d_name)
        return rffi.charp2str(namep)

########NEW FILE########
__FILENAME__ = ll_file
import os

from rpython.rtyper.lltypesystem import rffi
from rpython.rtyper.tool import rffi_platform as platform
from rpython.translator.tool.cbuild import ExternalCompilationInfo

from topaz.system import IS_WINDOWS


if IS_WINDOWS:
    O_BINARY = os.O_BINARY

    eci = ExternalCompilationInfo(includes=["windows.h"])

    class CConfig:
        _compilation_info_ = eci
    config = platform.configure(CConfig)

    _chsize = rffi.llexternal("_chsize",
        [rffi.INT, rffi.LONG], rffi.INT,
        compilation_info=eci,
    )

    def ftruncate(fd, size):
        _chsize(fd, size)

    def fchmod(fd, mode):
        raise NotImplementedError("chmod on windows")

    # This imports the definition of isdir that uses stat. On Windows
    # this is replaced in the path module with a version that isn't
    # RPython
    from genericpath import isdir
else:
    O_BINARY = 0
    ftruncate = os.ftruncate
    isdir = os.path.isdir
    fchmod = os.fchmod

########NEW FILE########
__FILENAME__ = ordereddict
import operator
from collections import OrderedDict as PyOrderedDict

from rpython.annotator import model
from rpython.annotator.bookkeeper import getbookkeeper
from rpython.rlib.objectmodel import hlinvoke
from rpython.rlib.rarithmetic import r_uint, intmask, LONG_BIT
from rpython.rtyper.extregistry import ExtRegistryEntry
from rpython.rtyper.lltypesystem import lltype
from rpython.rtyper.rmodel import Repr, IteratorRepr, externalvsinternal
from rpython.tool.pairtype import pairtype


MARKER = object()


class OrderedDict(object):
    def __init__(self, eq_func=None, hash_func=None):
        self.contents = PyOrderedDict()
        self.eq_func = eq_func or operator.eq
        self.hash_func = hash_func or hash

    def __getitem__(self, key):
        return self.contents[self._key(key)]

    def __setitem__(self, key, value):
        self.contents[self._key(key)] = value

    def __delitem__(self, key):
        del self.contents[self._key(key)]

    def __contains__(self, key):
        return self._key(key) in self.contents

    def __len__(self):
        return len(self.contents)

    def _key(self, key):
        return DictKey(self, key)

    def keys(self):
        return [k.key for k in self.contents.keys()]

    def values(self):
        return self.contents.values()

    def iteritems(self):
        for k, v in self.contents.iteritems():
            yield k.key, v

    def get(self, key, default):
        return self.contents.get(self._key(key), default)

    def pop(self, key, default=MARKER):
        if default is MARKER:
            return self.contents.pop(self._key(key))
        else:
            return self.contents.pop(self._key(key), default)

    def popitem(self):
        if not self:
            raise KeyError
        k, v = self.contents.popitem()
        return k.key, v

    def update(self, d):
        self.contents.update(d.contents)

    def clear(self):
        self.contents.clear()

    def copy(self):
        d = OrderedDict(self.eq_func, self.hash_func)
        for k, v in self.iteritems():
            d[k] = v
        return d


class DictKey(object):
    def __init__(self, d, key):
        self.d = d
        self.key = key
        self.hash = None

    def __eq__(self, other):
        return self.d.eq_func(self.key, other.key)

    def __hash__(self):
        if self.hash is None:
            self.hash = self.d.hash_func(self.key)
        return self.hash


class OrderedDictEntry(ExtRegistryEntry):
    _about_ = OrderedDict

    def compute_result_annotation(self, s_eq_func=None, s_hash_func=None):
        assert s_eq_func is None or s_eq_func.is_constant()
        assert s_hash_func is None or s_hash_func.is_constant()

        if s_eq_func is None and s_hash_func is None:
            dictdef = getbookkeeper().getdictdef()
        else:
            dictdef = getbookkeeper().getdictdef(is_r_dict=True)
            dictdef.dictkey.update_rdict_annotations(s_eq_func, s_hash_func)

        return SomeOrderedDict(getbookkeeper(), dictdef,)

    def specialize_call(self, hop):
        return hop.r_result.rtyper_new(hop)


class SomeOrderedDict(model.SomeObject):
    def __init__(self, bookkeeper, dictdef):
        self.bookkeeper = bookkeeper
        self.dictdef = dictdef

    def __eq__(self, other):
        if not isinstance(other, SomeOrderedDict):
            return NotImplemented
        return self.dictdef.same_as(other.dictdef)

    def rtyper_makerepr(self, rtyper):
        key_repr = rtyper.getrepr(self.dictdef.dictkey.s_value)
        value_repr = rtyper.getrepr(self.dictdef.dictvalue.s_value)
        if self.dictdef.dictkey.custom_eq_hash:
            eq_func_repr = rtyper.getrepr(self.dictdef.dictkey.s_rdict_eqfn)
            hash_func_repr = rtyper.getrepr(self.dictdef.dictkey.s_rdict_hashfn)
        else:
            eq_func_repr = None
            hash_func_repr = None
        return OrderedDictRepr(rtyper, key_repr, value_repr, eq_func_repr, hash_func_repr)

    def rtyper_makekey(self):
        return (type(self), self.dictdef.dictkey, self.dictdef.dictvalue)

    def method_keys(self):
        return self.bookkeeper.newlist(self.dictdef.read_key())

    def method_values(self):
        return self.bookkeeper.newlist(self.dictdef.read_value())

    def method_iteritems(self):
        return SomeOrderedDictIterator(self)

    def method_get(self, s_key, s_default):
        self.dictdef.generalize_key(s_key)
        self.dictdef.generalize_value(s_default)
        return self.dictdef.read_value()

    def method_pop(self, s_key, s_default=None):
        self.dictdef.generalize_key(s_key)
        if s_default is not None:
            self.dictdef.generalize_value(s_default)
        return self.dictdef.read_value()

    def method_popitem(self):
        s_key = self.dictdef.read_key()
        s_value = self.dictdef.read_value()
        if (isinstance(s_key, model.SomeImpossibleValue) or
            isinstance(s_value, model.SomeImpossibleValue)):
            return model.s_ImpossibleValue
        return model.SomeTuple((s_key, s_value))

    def method_update(self, s_dict):
        assert isinstance(s_dict, SomeOrderedDict)
        self.dictdef.union(s_dict.dictdef)

    def method_copy(self):
        return SomeOrderedDict(self.bookkeeper, self.dictdef)

    def method_clear(self):
        pass


class SomeOrderedDictIterator(model.SomeObject):
    def __init__(self, d):
        super(SomeOrderedDictIterator, self).__init__()
        self.d = d

    def rtyper_makerepr(self, rtyper):
        return OrderedDictIteratorRepr(rtyper.getrepr(self.d))

    def rtyper_makekey(self):
        return (type(self), self.d)

    def iter(self):
        return self

    def next(self):
        s_key = self.d.dictdef.read_key()
        s_value = self.d.dictdef.read_value()
        if (isinstance(s_key, model.SomeImpossibleValue) or
            isinstance(s_value, model.SomeImpossibleValue)):
            return model.s_ImpossibleValue
        return model.SomeTuple((s_key, s_value))
    method_next = next


class __extend__(pairtype(SomeOrderedDict, SomeOrderedDict)):
    def union((d1, d2)):
        return SomeOrderedDict(getbookkeeper(), d1.dictdef.union(d2.dictdef))


class __extend__(pairtype(SomeOrderedDict, model.SomeObject)):
    def setitem((self, key), s_value):
        self.dictdef.generalize_key(key)
        self.dictdef.generalize_value(s_value)

    def getitem((self, key)):
        self.dictdef.generalize_key(key)
        return self.dictdef.read_value()

    def delitem((self, key)):
        self.dictdef.generalize_key(key)

    def contains((self, key)):
        self.generalize_key(key)
        return model.s_Bool


class OrderedDictRepr(Repr):
    def __init__(self, rtyper, key_repr, value_repr, eq_func_repr, hash_func_repr):
        self.rtyper = rtyper
        self.eq_func_repr = eq_func_repr
        self.hash_func_repr = hash_func_repr
        self.external_key_repr, self.key_repr = self.pickrepr(key_repr)
        self.external_value_repr, self.value_repr = self.pickrepr(value_repr)

        self.lowleveltype = self.create_lowlevel_type()

    def pickrepr(self, item_repr):
        if self.eq_func_repr and self.hash_func_repr:
            return item_repr, item_repr
        else:
            return externalvsinternal(self.rtyper, item_repr)

    def _must_clear(self, ll_tp):
        return isinstance(ll_tp, lltype.Ptr) and ll_tp._needsgc()

    def create_lowlevel_type(self):
        entry_methods = {
            "valid": LLOrderedDict.ll_valid_from_flag,
            "everused": LLOrderedDict.ll_everused_from_flag,
            "mark_deleted": LLOrderedDict.ll_mark_deleted_in_flag,
            "must_clear_key": self._must_clear(self.key_repr.lowleveltype),
            "must_clear_value": self._must_clear(self.value_repr.lowleveltype),
        }
        fields = [
            ("key", self.key_repr.lowleveltype),
            ("value", self.value_repr.lowleveltype),
            ("next", lltype.Signed),
            ("prev", lltype.Signed),
            ("everused", lltype.Bool),
            ("valid", lltype.Bool),
        ]
        fast_hash_func = None
        if not self.hash_func_repr:
            fast_hash_func = self.key_repr.get_ll_hash_function()
        if fast_hash_func is None:
            fields.append(("hash", lltype.Signed))
            entry_methods["hash"] = LLOrderedDict.ll_hash_from_cache
        else:
            entry_methods["hash"] = LLOrderedDict.ll_hash_recompute
            entry_methods["fast_hash_func"] = fast_hash_func
        DICTENTRY = lltype.Struct("ORDEREDDICTENTRY", *fields)

        fields = [
            ("num_items", lltype.Signed),
            ("resize_counter", lltype.Signed),
            ("first_entry", lltype.Signed),
            ("last_entry", lltype.Signed),
            ("entries", lltype.Ptr(lltype.GcArray(DICTENTRY, adtmeths=entry_methods))),
        ]
        dict_methods = {}
        if self.eq_func_repr and self.hash_func_repr:
            dict_methods["paranoia"] = True
            dict_methods["hashkey"] = LLOrderedDict.ll_hashkey_custom
            dict_methods["keyeq"] = LLOrderedDict.ll_keyeq_custom

            dict_methods["r_hashkey"] = self.hash_func_repr
            dict_methods["r_keyeq"] = self.eq_func_repr

            fields.append(("hashkey_func", self.hash_func_repr.lowleveltype))
            fields.append(("keyeq_func", self.eq_func_repr.lowleveltype))
        else:
            dict_methods["paranoia"] = False
            dict_methods["hashkey"] = lltype.staticAdtMethod(self.key_repr.get_ll_hash_function())
            ll_keyeq = self.key_repr.get_ll_eq_function()
            if ll_keyeq is not None:
                ll_keyeq = lltype.staticAdtMethod(ll_keyeq)
            dict_methods["keyeq"] = ll_keyeq

        DICT = lltype.GcStruct("ORDEREDDICT", *fields, adtmeths=dict_methods)
        return lltype.Ptr(DICT)

    def recast_value(self, hop, v):
        return hop.llops.convertvar(v, self.value_repr, self.external_value_repr)

    def rtyper_new(self, hop):
        hop.exception_cannot_occur()
        c_TP = hop.inputconst(lltype.Void, self.lowleveltype.TO)
        v_res = hop.gendirectcall(LLOrderedDict.ll_newdict, c_TP)
        if self.eq_func_repr and self.hash_func_repr:
            v_eq = hop.inputarg(self.eq_func_repr, arg=0)
            v_hash = hop.inputarg(self.hash_func_repr, arg=1)
            cname = hop.inputconst(lltype.Void, "keyeq_func")
            hop.genop("setfield", [v_res, cname, v_eq])
            cname = hop.inputconst(lltype.Void, "hashkey_func")
            hop.genop("setfield", [v_res, cname, v_hash])
        return v_res

    def rtype_len(self, hop):
        [v_dict] = hop.inputargs(self)
        return hop.gendirectcall(LLOrderedDict.ll_len, v_dict)

    def rtype_method_keys(self, hop):
        [v_dict] = hop.inputargs(self)
        r_list = hop.r_result
        c_LIST = hop.inputconst(lltype.Void, r_list.lowleveltype.TO)
        return hop.gendirectcall(LLOrderedDict.ll_keys, c_LIST, v_dict)

    def rtype_method_values(self, hop):
        [v_dict] = hop.inputargs(self)
        r_list = hop.r_result
        c_LIST = hop.inputconst(lltype.Void, r_list.lowleveltype.TO)
        return hop.gendirectcall(LLOrderedDict.ll_values, c_LIST, v_dict)

    def rtype_method_iteritems(self, hop):
        return OrderedDictIteratorRepr(self).newiter(hop)

    def rtype_method_get(self, hop):
        v_dict, v_key, v_default = hop.inputargs(self, self.key_repr, self.value_repr)
        return hop.gendirectcall(LLOrderedDict.ll_get, v_dict, v_key, v_default)

    def rtype_method_pop(self, hop):
        if hop.nb_args == 2:
            v_args = hop.inputargs(self, self.key_repr)
            target = LLOrderedDict.ll_pop
        elif hop.nb_args == 3:
            v_args = hop.inputargs(self, self.key_repr, self.value_repr)
            target = LLOrderedDict.ll_pop_default
        hop.exception_is_here()
        v_res = hop.gendirectcall(target, *v_args)
        return self.recast_value(hop, v_res)

    def rtype_method_popitem(self, hop):
        hop.exception_is_here()
        [v_dict] = hop.inputargs(self)
        c_TP = hop.inputconst(lltype.Void, hop.r_result.lowleveltype)
        return hop.gendirectcall(LLOrderedDict.ll_popitem, c_TP, v_dict)

    def rtype_method_update(self, hop):
        [v_dict, v_other] = hop.inputargs(self, self)
        return hop.gendirectcall(LLOrderedDict.ll_update, v_dict, v_other)

    def rtype_method_clear(self, hop):
        [v_dict] = hop.inputargs(self)
        return hop.gendirectcall(LLOrderedDict.ll_clear, v_dict)

    def rtype_method_copy(self, hop):
        [v_dict] = hop.inputargs(self)
        return hop.gendirectcall(LLOrderedDict.ll_copy, v_dict)


class OrderedDictIteratorRepr(IteratorRepr):
    def __init__(self, r_dict):
        super(OrderedDictIteratorRepr, self).__init__()
        self.r_dict = r_dict

        self.lowleveltype = self.create_lowlevel_type()

    def create_lowlevel_type(self):
        return lltype.Ptr(lltype.GcStruct("ORDEREDDICTITER",
            ("d", self.r_dict.lowleveltype),
            ("index", lltype.Signed),
        ))

    def newiter(self, hop):
        [v_dict] = hop.inputargs(self.r_dict)
        c_TP = hop.inputconst(lltype.Void, self.lowleveltype.TO)
        return hop.gendirectcall(LLOrderedDict.ll_newdictiter, c_TP, v_dict)

    def rtype_next(self, hop):
        [v_iter] = hop.inputargs(self)
        c_TP = hop.inputconst(lltype.Void, hop.r_result.lowleveltype)
        hop.exception_is_here()
        return hop.gendirectcall(LLOrderedDict.ll_dictiternext, c_TP, v_iter)


class __extend__(pairtype(OrderedDictRepr, Repr)):
    def rtype_setitem((self, r_key), hop):
        v_dict, v_key, v_value = hop.inputargs(
            self, self.key_repr, self.value_repr
        )
        hop.gendirectcall(LLOrderedDict.ll_setitem, v_dict, v_key, v_value)

    def rtype_getitem((self, r_key), hop):
        v_dict, v_key = hop.inputargs(self, self.key_repr)
        hop.exception_is_here()
        v_res = hop.gendirectcall(LLOrderedDict.ll_getitem, v_dict, v_key)
        return self.recast_value(hop, v_res)

    def rtype_delitem((self, r_key), hop):
        v_dict, v_key = hop.inputargs(self, self.key_repr)
        hop.exception_is_here()
        hop.gendirectcall(LLOrderedDict.ll_delitem, v_dict, v_key)

    def rtype_contains((self, r_key), hop):
        v_dict, v_key = hop.inputargs(self, self.key_repr)
        return hop.gendirectcall(LLOrderedDict.ll_contains, v_dict, v_key)


class __extend__(pairtype(OrderedDictRepr, OrderedDictRepr)):
    def convert_from_to((d1, d2), v, llops):
        if (d1.key_repr is not d2.key_repr or
            d1.value_repr is not d2.value_repr or
            d1.eq_func_repr is not d2.eq_func_repr or
            d1.hash_func_repr is not d2.hash_func_repr):
            return NotImplemented
        return v


class LLOrderedDict(object):
    INIT_SIZE = 8
    HIGHEST_BIT = intmask(1 << (LONG_BIT - 1))
    MASK = intmask(HIGHEST_BIT - 1)
    PERTURB_SHIFT = 5

    @staticmethod
    def ll_valid_from_flag(entries, i):
        return entries[i].valid

    @staticmethod
    def ll_everused_from_flag(entries, i):
        return entries[i].everused

    @staticmethod
    def ll_mark_deleted_in_flag(entries, i):
        entries[i].valid = False

    @staticmethod
    def ll_hashkey_custom(d, key):
        DICT = lltype.typeOf(d).TO
        return hlinvoke(DICT.r_hashkey, d.hashkey_func, key)

    @staticmethod
    def ll_keyeq_custom(d, key1, key2):
        DICT = lltype.typeOf(d).TO
        return hlinvoke(DICT.r_keyeq, d.keyeq_func, key1, key2)

    @staticmethod
    def ll_hash_recompute(entries, i):
        ENTRIES = lltype.typeOf(entries).TO
        return ENTRIES.fast_hash_func(entries[i].key)

    @staticmethod
    def ll_hash_from_cache(entries, i):
        return entries[i].hash

    @staticmethod
    def recast(P, v):
        if isinstance(P, lltype.Ptr):
            return lltype.cast_pointer(P, v)
        else:
            return v

    @staticmethod
    def ll_newdict(DICT):
        d = lltype.malloc(DICT)
        d.entries = lltype.malloc(DICT.entries.TO, LLOrderedDict.INIT_SIZE, zero=True)
        d.num_items = 0
        d.first_entry = -1
        d.last_entry = -1
        d.resize_counter = LLOrderedDict.INIT_SIZE * 2
        return d

    @staticmethod
    def ll_len(d):
        return d.num_items

    @staticmethod
    def ll_lookup(d, key, hash):
        entries = d.entries
        mask = len(entries) - 1
        i = hash & mask
        if entries.valid(i):
            checkingkey = entries[i].key
            if checkingkey == key:
                return i
            if d.keyeq is not None and entries.hash(i) == hash:
                found = d.keyeq(checkingkey, key)
                if d.paranoia:
                    if (entries != d.entries or
                        not entries.valid(i) or entries[i].key != checkingkey):
                        return LLOrderedDict.ll_lookup(d, key, hash)
                if found:
                    return i
            freeslot = -1
        elif entries.everused(i):
            freeslot = i
        else:
            return i | LLOrderedDict.HIGHEST_BIT

        perturb = r_uint(hash)
        while True:
            i = r_uint(i)
            i = (i << 2) + i + perturb + 1
            i = intmask(i) & mask
            if not entries.everused(i):
                if freeslot == -1:
                    freeslot = i
                return freeslot | LLOrderedDict.HIGHEST_BIT
            elif entries.valid(i):
                checkingkey = entries[i].key
                if checkingkey == key:
                    return i
                if d.keyeq is not None and entries.hash(i) == hash:
                    found = d.keyeq(checkingkey, key)
                    if d.paranoia:
                        if (entries != d.entries or
                            not entries.valid(i) or entries[i].key != checkingkey):
                            return LLOrderedDict.ll_lookup(d, key, hash)
                    if found:
                        return i
            elif freeslot == -1:
                freeslot = i
            perturb >>= LLOrderedDict.PERTURB_SHIFT

    @staticmethod
    def ll_setitem(d, key, value):
        hash = d.hashkey(key)
        i = LLOrderedDict.ll_lookup(d, key, hash)
        LLOrderedDict.ll_setitem_lookup_done(d, key, value, hash, i)

    @staticmethod
    def ll_setitem_lookup_done(d, key, value, hash, i):
        valid = (i & LLOrderedDict.HIGHEST_BIT) == 0
        i &= LLOrderedDict.MASK
        everused = d.entries.everused(i)
        ENTRY = lltype.typeOf(d.entries).TO.OF
        entry = d.entries[i]
        entry.value = value
        if valid:
            return
        entry.key = key
        if hasattr(ENTRY, "hash"):
            entry.hash = hash
        if hasattr(ENTRY, "valid"):
            entry.valid = True
        d.num_items += 1
        if d.first_entry == -1:
            d.first_entry = i
        else:
            d.entries[d.last_entry].next = i
        entry.prev = d.last_entry
        d.last_entry = i
        entry.next = -1
        if not everused:
            if hasattr(ENTRY, "everused"):
                entry.everused = True
            d.resize_counter -= 3
            if d.resize_counter <= 0:
                LLOrderedDict.ll_resize(d)

    @staticmethod
    def ll_getitem(d, key):
        i = LLOrderedDict.ll_lookup(d, key, d.hashkey(key))
        if not i & LLOrderedDict.HIGHEST_BIT:
            return d.entries[i].value
        else:
            raise KeyError

    @staticmethod
    def ll_delitem(d, key):
        i = LLOrderedDict.ll_lookup(d, key, d.hashkey(key))
        if i & LLOrderedDict.HIGHEST_BIT:
            raise KeyError
        LLOrderedDict._ll_del(d, i)

    @staticmethod
    def _ll_del(d, i):
        d.entries.mark_deleted(i)
        d.num_items -= 1
        entry = d.entries[i]
        if entry.prev == -1:
            d.first_entry = entry.next
        else:
            d.entries[entry.prev].next = entry.next
        if entry.next == -1:
            d.last_entry = entry.prev
        else:
            d.entries[entry.next].prev = entry.prev

        ENTRIES = lltype.typeOf(d.entries).TO
        ENTRY = ENTRIES.OF
        if ENTRIES.must_clear_key:
            entry.key = lltype.nullptr(ENTRY.key.TO)
        if ENTRIES.must_clear_value:
            entry.value = lltype.nullptr(ENTRY.value.TO)

    @staticmethod
    def ll_contains(d, key):
        i = LLOrderedDict.ll_lookup(d, key, d.hashkey(key))
        return not bool(i & LLOrderedDict.HIGHEST_BIT)

    @staticmethod
    def ll_resize(d):
        old_entries = d.entries
        if d.num_items > 50000:
            new_estimate = d.num_items * 2
        else:
            new_estimate = d.num_items * 4

        new_size = LLOrderedDict.INIT_SIZE
        while new_size <= new_estimate:
            new_size *= 2

        d.entries = lltype.malloc(lltype.typeOf(old_entries).TO, new_size, zero=True)
        d.num_items = 0
        d.resize_counter = new_size * 2

        i = d.first_entry
        d.first_entry = -1
        d.last_entry = -1

        while i != -1:
            hash = old_entries.hash(i)
            entry = old_entries[i]
            LLOrderedDict.ll_insert_clean(d, entry.key, entry.value, hash)
            i = entry.next

    @staticmethod
    def ll_insert_clean(d, key, value, hash):
        i = LLOrderedDict.ll_lookup_clean(d, hash)
        ENTRY = lltype.typeOf(d.entries).TO.OF
        entry = d.entries[i]
        entry.value = value
        entry.key = key
        if hasattr(ENTRY, "hash"):
            entry.hash = hash
        if hasattr(ENTRY, "valid"):
            entry.valid = True
        if hasattr(ENTRY, "everused"):
            entry.everused = True
        d.num_items += 1
        if d.first_entry == -1:
            d.first_entry = i
        else:
            d.entries[d.last_entry].next = i
        entry.prev = d.last_entry
        d.last_entry = i
        entry.next = -1
        d.resize_counter -= 3

    @staticmethod
    def ll_lookup_clean(d, hash):
        entries = d.entries
        mask = len(entries) - 1
        i = hash & mask
        perturb = r_uint(hash)
        while entries.everused(i):
            i = r_uint(i)
            i = (i << 2) + i + perturb + 1
            i = intmask(i) & mask
            perturb >>= LLOrderedDict.PERTURB_SHIFT
        return i

    @staticmethod
    def ll_keys(LIST, d):
        res = LIST.ll_newlist(d.num_items)
        ELEM = lltype.typeOf(res.ll_items()).TO.OF
        i = 0
        idx = d.first_entry
        while idx != -1:
            res.ll_items()[i] = LLOrderedDict.recast(ELEM, d.entries[idx].key)
            idx = d.entries[idx].next
            i += 1
        return res

    @staticmethod
    def ll_values(LIST, d):
        res = LIST.ll_newlist(d.num_items)
        ELEM = lltype.typeOf(res.ll_items()).TO.OF
        i = 0
        idx = d.first_entry
        while idx != -1:
            res.ll_items()[i] = LLOrderedDict.recast(ELEM, d.entries[idx].value)
            idx = d.entries[idx].next
            i += 1
        return res

    @staticmethod
    def ll_get(d, key, default):
        i = LLOrderedDict.ll_lookup(d, key, d.hashkey(key))
        if not i & LLOrderedDict.HIGHEST_BIT:
            return d.entries[i].value
        else:
            return default

    @staticmethod
    def ll_pop(d, key):
        i = LLOrderedDict.ll_lookup(d, key, d.hashkey(key))
        if not i & LLOrderedDict.HIGHEST_BIT:
            value = d.entries[i].value
            LLOrderedDict._ll_del(d, i)
            return value
        else:
            raise KeyError

    @staticmethod
    def ll_pop_default(d, key, default):
        try:
            return LLOrderedDict.ll_pop(d, key)
        except KeyError:
            return default

    @staticmethod
    def ll_popitem(RESTYPE, d):
        if not d.num_items:
            raise KeyError
        entry = d.entries[d.first_entry]

        r = lltype.malloc(RESTYPE.TO)
        r.item0 = LLOrderedDict.recast(RESTYPE.TO.item0, entry.key)
        r.item1 = LLOrderedDict.recast(RESTYPE.TO.item1, entry.value)

        LLOrderedDict._ll_del(d, d.first_entry)

        return r

    @staticmethod
    def ll_update(d, other):
        idx = other.first_entry
        while idx != -1:
            entry = other.entries[idx]
            i = LLOrderedDict.ll_lookup(d, entry.key, other.entries.hash(idx))
            LLOrderedDict.ll_setitem_lookup_done(d, entry.key, entry.value, other.entries.hash(idx), i)
            idx = entry.next

    @staticmethod
    def ll_clear(d):
        if d.num_items == 0:
            return
        d.entries = lltype.malloc(lltype.typeOf(d.entries).TO, LLOrderedDict.INIT_SIZE, zero=True)
        d.num_items = 0
        d.first_entry = -1
        d.last_entry = -1
        d.resize_counter = LLOrderedDict.INIT_SIZE * 2

    @staticmethod
    def ll_copy(d):
        DICT = lltype.typeOf(d).TO
        new_d = lltype.malloc(DICT)
        new_d.entries = lltype.malloc(DICT.entries.TO, len(d.entries), zero=True)
        new_d.num_items = d.num_items
        new_d.resize_counter = d.resize_counter
        new_d.first_entry = d.first_entry
        new_d.last_entry = d.last_entry
        if hasattr(DICT, "hashkey_func"):
            new_d.hashkey_func = d.hashkey_func
        if hasattr(DICT, "keyeq_func"):
            new_d.keyeq_func = d.keyeq_func
        for i in xrange(len(d.entries)):
            entry = d.entries[i]
            new_entry = new_d.entries[i]
            new_entry.key = entry.key
            new_entry.value = entry.value
            new_entry.next = entry.next
            new_entry.prev = entry.prev
            new_entry.everused = entry.everused
            new_entry.valid = entry.valid
            if hasattr(DICT.entries.TO.OF, "hash"):
                new_entry.hash = entry.hash
        return new_d

    @staticmethod
    def ll_newdictiter(ITER, d):
        it = lltype.malloc(ITER)
        it.d = d
        it.index = d.first_entry
        return it

    @staticmethod
    def ll_dictiternext(RESTYPE, it):
        if it.index == -1:
            raise StopIteration
        r = lltype.malloc(RESTYPE.TO)
        entry = it.d.entries[it.index]
        r.item0 = LLOrderedDict.recast(RESTYPE.TO.item0, entry.key)
        r.item1 = LLOrderedDict.recast(RESTYPE.TO.item1, entry.value)
        it.index = entry.next
        return r

########NEW FILE########
__FILENAME__ = floatpacking
from rpython.rlib import rfloat
from rpython.rlib.rstruct.ieee import float_pack

from topaz.objects.floatobject import W_FloatObject
from topaz.objects.intobject import W_FixnumObject


def make_float_packer(size, bigendian):
    def pack_float(space, packer, repetitions):
        if repetitions > len(packer.args_w) - packer.args_index:
            raise space.error(space.w_ArgumentError, "too few arguments")
        for i in xrange(packer.args_index, repetitions + packer.args_index):
            w_item = packer.args_w[i]
            if not (isinstance(w_item, W_FloatObject) or isinstance(w_item, W_FixnumObject)):
                raise space.error(space.w_TypeError,
                    "can't convert %s into Float" % space.obj_to_s(space.getclass(w_item))
                )
            doubleval = space.float_w(w_item)
            l = ["\0"] * size
            try:
                unsigned = float_pack(doubleval, size)
            except OverflowError:
                unsigned = float_pack(rfloat.copysign(rfloat.INFINITY, doubleval), size)
            for i in xrange(size):
                l[i] = chr((unsigned >> (i * 8)) & 0xff)
            if bigendian:
                l.reverse()
            packer.result.extend(l)
        packer.args_index += repetitions
    return pack_float

########NEW FILE########
__FILENAME__ = intpacking
from rpython.rtyper.lltypesystem import rffi, lltype


def select_conversion_method(size, signed):
    if signed:
        if size <= rffi.sizeof(lltype.Signed):
            return "intmask_w"
        else:
            return "longlongmask_w"
    else:
        if size < rffi.sizeof(lltype.Signed):
            return "intmask_w"
        elif size == rffi.sizeof(lltype.Signed):
            return "uintmask_w"
        else:
            return "ulonglongmask_w"


def make_int_packer(size, signed, bigendian):
    conversion_method = select_conversion_method(size, signed)

    def pack_int(space, packer, repetitions):
        if repetitions > len(packer.args_w) - packer.args_index:
            raise space.error(space.w_ArgumentError, "too few arguments")

        for i in xrange(packer.args_index, repetitions + packer.args_index):
            w_num = space.convert_type(packer.args_w[i], space.w_integer, "to_int")
            num = getattr(w_num, conversion_method)(space)
            if bigendian:
                for i in xrange(size - 1, -1, -1):
                    x = (num >> (8 * i)) & 0xff
                    packer.result.append(chr(x))
            else:
                for i in xrange(size - 1, -1, -1):
                    packer.result.append(chr(num & 0xff))
                    num >>= 8
        packer.args_index += repetitions
    return pack_int

########NEW FILE########
__FILENAME__ = pack
from rpython.rlib import jit
from rpython.rlib.rarithmetic import ovfcheck
from rpython.rlib.rstruct.nativefmttable import native_is_bigendian

from topaz.utils.packing.floatpacking import make_float_packer
from topaz.utils.packing.intpacking import make_int_packer
from topaz.utils.packing.stringpacking import make_string_packer, pack_pointer


codes = "CcSsIiLlQqNnVvUwDdFfEeGgAaZBbHhuMmPp@Xx"
mappable_codes = "SsIiLlQq"
native_codes = "SsIiLl"
starrable_codes = "Z"
endianess_codes = "<>"
native_endian_codes = "!_"
moving_chars = "@Xx"

BE_modifier = ">"
LE_offset = ord("<") if native_is_bigendian else 0
BE_offset = 0 if native_is_bigendian else ord(">")
non_native_endianess_offset = LE_offset if native_is_bigendian else BE_offset


class RPacker(object):
    def __init__(self, fmt, args_w):
        self.fmt = fmt
        self.args_w = args_w
        self.args_index = 0
        self.result = []

    def native_code_count(self, space, idx, ch):
        end = idx + 1
        while end < len(self.fmt) and self.fmt[end] in native_endian_codes:
            end += 1
        native_chars = end - idx - 1
        if native_chars > 0 and ch not in native_codes:
            raise space.error(space.w_ArgumentError,
                "%s allowed only after types %s" % (self.fmt[idx + 1], native_codes)
            )
        return native_chars

    def check_for_bigendianess_code(self, space, idx, ch):
        end = idx + 1
        while end < len(self.fmt) and self.fmt[end] in endianess_codes:
            end += 1
        endian_chars = end - idx - 1
        if endian_chars > 0 and ch not in mappable_codes:
            raise space.error(space.w_ArgumentError,
                "%s allowed only after types %s" % (self.fmt[idx + 1], mappable_codes)
            )
        elif endian_chars > 1:
            raise space.error(space.w_RangeError, "Can't use both '<' and '>'")
        elif endian_chars == 1:
            bigendian = (self.fmt[end - 1] == BE_modifier)
        else:
            bigendian = native_is_bigendian
        return bigendian

    def check_for_star(self, idx, ch):
        return (
            idx + 1 < len(self.fmt) and
            ch in starrable_codes and
            self.fmt[idx + 1] == "*"
        )

    def determine_repetitions(self, space, idx):
        end = idx + 1
        repetitions = 0
        while end < len(self.fmt) and self.fmt[end].isdigit():
            try:
                repetitions = ovfcheck(repetitions * 10 + (ord(self.fmt[end]) - ord("0")))
            except OverflowError:
                raise space.error(space.w_RangeError, "pack length too big")
            end += 1
        if end == idx + 1:
            # No explicit repetitions definition
            repetitions = 1
        return (repetitions, end - 1)

    @jit.unroll_safe
    def interpret(self, space):
        idx = 0
        indices = []

        while idx < len(self.fmt):
            ch = self.fmt[idx]

            # Skip any garbage
            if ch not in codes:
                idx += 1
                continue

            native_code_count = self.native_code_count(space, idx, ch)
            idx += native_code_count

            bigendian = self.check_for_bigendianess_code(space, idx, ch)
            if bigendian:
                idx += 1

            starred = self.check_for_star(idx, ch)
            if starred:
                idx += 1

            repetitions, idx = self.determine_repetitions(space, idx)

            converter_idx = ord(ch)
            if starred:
                converter_idx -= 1

            if bigendian != native_is_bigendian:
                converter_idx += non_native_endianess_offset

            indices.append((converter_idx, repetitions))
            idx += 1
        return indices

    @jit.look_inside_iff(lambda self, space: jit.isconstant(self.fmt))
    def operate(self, space):
        indices = self.interpret(space)
        for idx, reps in indices:
            op = pack_operators[idx]
            if op is None:
                raise space.error(space.w_NotImplementedError, "Operator %s" % chr(idx))
            op(space, self, reps)
        return self.result


def pack_move_to(space, packer, position):
    if len(packer.result) < position:
        packer.result.extend(["\0"] * (position - len(packer.result)))
    else:
        assert position >= 0
        del packer.result[position:]


def pack_back_up(space, packer, repetitions):
    size = len(packer.result)
    if size < repetitions:
        raise space.error(space.w_ArgumentError, "X outside of string")
    else:
        begin = size - repetitions
        assert begin >= 0
        del packer.result[begin:]


def pack_padding(space, packer, repetitions):
    packer.result.extend(["\0"] * repetitions)


def make_pack_operators():
    ops = [None] * 255

    # Int Basics
    int_sizes = "csiq"
    for size, code in enumerate(int_sizes):
        sidx = ord(code)
        uidx = ord(code.upper())
        ops[sidx] = make_int_packer(size=2 ** size, signed=True, bigendian=native_is_bigendian)
        ops[uidx] = make_int_packer(size=2 ** size, signed=False, bigendian=native_is_bigendian)
        if size > 0:
            ops[sidx + BE_offset] = make_int_packer(size=2 ** size, signed=True, bigendian=True)
            ops[uidx + BE_offset] = make_int_packer(size=2 ** size, signed=False, bigendian=True)
            ops[sidx + LE_offset] = make_int_packer(size=2 ** size, signed=True, bigendian=False)
            ops[uidx + LE_offset] = make_int_packer(size=2 ** size, signed=False, bigendian=False)
    # Int Aliases
    ops[ord("L")] = ops[ord("I")]
    ops[ord("L") + BE_offset] = ops[ord("N")] = ops[ord("I") + BE_offset]
    ops[ord("L") + LE_offset] = ops[ord("V")] = ops[ord("I") + LE_offset]
    ops[ord("l")] = ops[ord("i")]
    ops[ord("l") + BE_offset] = ops[ord("i") + BE_offset]
    ops[ord("l") + LE_offset] = ops[ord("i") + LE_offset]
    ops[ord("n")] = ops[ord("S") + BE_offset]
    ops[ord("v")] = ops[ord("S") + LE_offset]

    # ops[ord("U")] # pack UTF-8 sequence
    # ops[ord("w")] # BER-compressed integer

    ops[ord("f")] = ops[ord("F")] = make_float_packer(size=4, bigendian=native_is_bigendian)
    ops[ord("d")] = ops[ord("D")] = make_float_packer(size=8, bigendian=native_is_bigendian)
    ops[ord("E")] = make_float_packer(size=8, bigendian=False)
    ops[ord("e")] = make_float_packer(size=4, bigendian=False)
    ops[ord("G")] = make_float_packer(size=8, bigendian=True)
    ops[ord("g")] = make_float_packer(size=4, bigendian=True)

    ops[ord("A")] = make_string_packer(padding=" ")
    ops[ord("a")] = ops[ord("Z")] = make_string_packer(padding="\0")
    ops[ord("Z") - 1] = make_string_packer(nullterminated=True)

    # ops[ord("B")] # bitstring (msb first)
    # ops[ord("b")] # bitstring (lsb first)
    # ops[ord("H")] # hexstring (high first)
    # ops[ord("h")] # hexstring (low first)
    # ops[ord("u")] # UU-encoding
    # ops[ord("M")] # MIME-encoding
    # ops[ord("m")] # base64-encoding
    ops[ord("P")] = ops[ord("p")] = pack_pointer

    ops[ord("@")] = pack_move_to
    ops[ord("X")] = pack_back_up
    ops[ord("x")] = pack_padding

    return ops

pack_operators = make_pack_operators()

########NEW FILE########
__FILENAME__ = stringpacking
from rpython.rtyper.lltypesystem import rffi


def make_string_packer(padding=" ", nullterminated=False):
    def pack_string(space, packer, width):
        try:
            w_s = packer.args_w[packer.args_index]
        except IndexError:
            raise space.error(space.w_ArgumentError, "too few arguments")
        string = space.str_w(space.convert_type(w_s, space.w_string, "to_str"))
        if nullterminated:
            packer.result += string
            packer.result.append("\0")
        else:
            assert width >= 0
            string = string[:width]
            packer.result += string
            packer.result.extend([padding] * (width - len(string)))
        packer.args_index += 1
    return pack_string


def pack_pointer(space, packer, repetitions):
    # Should return a C pointer string to a char* or struct*, but we
    # fake it to return just the right length, just as Rubinius does
    if repetitions > len(packer.args_w) - packer.args_index:
        raise space.error(space.w_ArgumentError, "too few arguments")
    for i in xrange(repetitions):
        for i in xrange(packer.args_index, repetitions + packer.args_index):
            packer.result.extend(["\0"] * rffi.sizeof(rffi.INTPTR_T))
    packer.args_index += repetitions

########NEW FILE########
__FILENAME__ = regexp
import sys

from rpython.rlib.listsort import make_timsort_class
from rpython.rlib.objectmodel import specialize
from rpython.rlib.rstring import StringBuilder
from rpython.rlib.rsre.rsre_core import (
    OPCODE_LITERAL, OPCODE_LITERAL_IGNORE, OPCODE_SUCCESS, OPCODE_ASSERT,
    OPCODE_MARK, OPCODE_REPEAT, OPCODE_ANY, OPCODE_ANY_ALL, OPCODE_MAX_UNTIL,
    OPCODE_MIN_UNTIL, OPCODE_GROUPREF, OPCODE_AT, OPCODE_BRANCH, OPCODE_RANGE,
    OPCODE_JUMP, OPCODE_ASSERT_NOT, OPCODE_CATEGORY, OPCODE_FAILURE, OPCODE_IN,
    OPCODE_NEGATE
)


IGNORE_CASE = 1 << 0
EXTENDED = 1 << 1
DOT_ALL = 1 << 2
ONCE = 1 << 3

FIXED_ENCODING = 1 << 4
NO_ENCODING = 1 << 5

OPTIONS_MAP = {
    "i": IGNORE_CASE,
    "x": EXTENDED,
    "m": DOT_ALL,
    "o": ONCE,
    "u": FIXED_ENCODING,
    "n": NO_ENCODING,
    "e": FIXED_ENCODING,
    "s": FIXED_ENCODING,
}

FLAGS_MAP = [
    ("m", DOT_ALL),
    ("i", IGNORE_CASE),
    ("x", EXTENDED),
]

SPECIAL_CHARS = "()|?*+{^$.[\\#"

CHARACTER_ESCAPES = {
    "a": "\a",
    "b": "\b",
    "f": "\f",
    "n": "\n",
    "r": "\r",
    "t": "\t",
    "v": "\v",
}

MAX_REPEAT = 65535

AT_BEGINNING = 0
AT_BEGINNING_LINE = 1
AT_BEGINNING_STRING = 2
AT_BOUNDARY = 3
AT_NON_BOUNDARY = 4
AT_END = 5
AT_END_LINE = 6
AT_END_STRING = 7
AT_LOC_BOUNDARY = 8
AT_LOC_NON_BOUNDARY = 9
AT_UNI_BOUNDARY = 10
AT_UNI_NON_BOUNDARY = 11

CATEGORY_DIGIT = 0
CATEGORY_NOT_DIGIT = 1
CATEGORY_SPACE = 2
CATEGORY_NOT_SPACE = 3
CATEGORY_WORD = 4
CATEGORY_NOT_WORD = 5
CATEGORY_LINEBREAK = 6
CATEGORY_NOT_LINEBREAK = 7
CATEGORY_LOC_WORD = 8
CATEGORY_LOC_NOT_WORD = 9
CATEGORY_UNI_DIGIT = 10
CATEGORY_UNI_NOT_DIGIT = 11
CATEGORY_UNI_SPACE = 12
CATEGORY_UNI_NOT_SPACE = 13
CATEGORY_UNI_WORD = 14
CATEGORY_UNI_NOT_WORD = 15
CATEGORY_UNI_LINEBREAK = 16
CATEGORY_UNI_NOT_LINEBREAK = 17


class UnscopedFlagSet(Exception):
    def __init__(self, global_flags):
        Exception.__init__(self)
        self.global_flags = global_flags


class RegexpError(Exception):
    pass


class ParseError(Exception):
    pass


class Source(object):
    def __init__(self, s):
        self.pos = 0
        self.s = s

        self.ignore_space = False

    def at_end(self):
        s = self.s
        pos = self.pos

        if self.ignore_space:
            while True:
                if pos >= len(s):
                    break
                elif s[pos].isspace():
                    pos += 1
                elif s[pos] == "#":
                    pos = s.find("\n", pos)
                    if pos < 0:
                        pos = len(s)
                else:
                    break
        return pos >= len(s)

    def get(self):
        s = self.s
        pos = self.pos
        if self.ignore_space:
            while True:
                if pos >= len(s):
                    return ""
                elif s[pos].isspace():
                    pos += 1
                elif s[pos] == "#":
                    pos = s.find("\n", pos)
                    if pos < 0:
                        pos = len(s)
                else:
                    break
        try:
            ch = s[pos]
            self.pos = pos + 1
            return ch
        except IndexError:
            self.pos = pos
            return ""
        except ValueError:
            self.pos = len(s)
            return ""

    def match(self, substr):
        s = self.s
        pos = self.pos

        if self.ignore_space:
            for c in substr:
                while True:
                    if pos >= len(s):
                        return False
                    elif s[pos].isspace():
                        pos += 1
                    elif s[pos] == "#":
                        pos = s.find("\n", pos)
                        if pos < 0:
                            pos = len(s)
                    else:
                        break

                if s[pos] != c:
                    return False
                pos += 1
            self.pos = pos
            return True
        else:
            if pos + len(substr) <= len(s):
                matches = True
                for i in xrange(len(substr)):
                    if s[pos + i] != substr[i]:
                        matches = False
            else:
                matches = False
            if not matches:
                return False
            self.pos = pos + len(substr)
            return True

    def expect(self, substr):
        if not self.match(substr):
            raise RegexpError("Missing %s" % substr)


class Info(object):
    OPEN = 0
    CLOSED = 1

    def __init__(self, flags):
        self.flags = flags

        self.group_count = 0
        self.used_groups = {}
        self.group_state = {}
        self.group_index = {}
        self.group_name = {}
        self.named_lists_used = {}
        self.defined_groups = {}

        self.group_offsets = []

    def new_group(self, name=None):
        if name in self.group_index:
            group = self.group_index[name]
        else:
            while True:
                self.group_count += 1
                if name is None or self.group_count not in self.group_name:
                    break
            group = self.group_count
            if name is not None:
                self.group_index[name] = group
                self.group_name[group] = name
        self.used_groups[group] = None
        self.group_state[group] = self.OPEN
        return group

    def close_group(self, group, hidden=False):
        last_group_offset = self.group_offsets[-1] if self.group_offsets else 0
        if hidden:
            last_group_offset += 1
        self.group_offsets.append(last_group_offset)
        self.group_state[group] = self.CLOSED

    def normalize_group(self, name):
        if name.isdigit():
            return int(name)
        else:
            return self.group_index[name]

    def is_open_group(self, name):
        group = self.normalize_group(name)
        return group in self.group_state and self.group_state[group] == self.OPEN


BaseSorter = make_timsort_class()


class BranchSorter(BaseSorter):
    def __init__(self, items, order):
        BaseSorter.__init__(self, items)
        self.order = order

    def lt(self, a, b):
        return self.order[a[0]] < self.order[b[0]]


class CompilerContext(object):
    def __init__(self):
        self.data = []

    def emit(self, opcode):
        self.data.append(opcode)

    def tell(self):
        return len(self.data)

    def patch(self, pos, value):
        self.data[pos] = value

    def build(self):
        return self.data[:]


class Counts(object):
    def __init__(self, min_count, max_count=MAX_REPEAT, limited_quantifier=False):
        self.min_count = min_count
        self.max_count = max_count
        self.limited_quantifier = limited_quantifier


class RegexpBase(object):
    _attrs_ = ["positive", "case_insensitive", "zerowidth"]

    def __init__(self, positive=True, case_insensitive=False, zerowidth=False):
        self.positive = positive
        self.case_insensitive = case_insensitive
        self.zerowidth = zerowidth

    @specialize.argtype(1, 2, 3)
    def with_flags(self, positive=None, case_insensitive=None, zerowidth=None):
        positive = positive if positive is not None else self.positive
        case_insensitive = case_insensitive if case_insensitive is not None else self.case_insensitive
        zerowidth = zerowidth if zerowidth is not None else self.zerowidth
        if (positive == self.positive and
            case_insensitive == self.case_insensitive and
            zerowidth == self.zerowidth):
            return self
        return self.rebuild(positive, case_insensitive, zerowidth)


class Character(RegexpBase):
    def __init__(self, value, case_insensitive=False, positive=True, zerowidth=False):
        RegexpBase.__init__(self, case_insensitive=case_insensitive, positive=positive, zerowidth=zerowidth)
        self.value = value

    def rebuild(self, positive, case_insensitive, zerowidth):
        return Character(self.value, positive=positive, case_insensitive=case_insensitive, zerowidth=zerowidth)

    def getwidth(self):
        return 1, 1

    def fix_groups(self):
        pass

    def optimize(self, info, in_set=False):
        return self

    def can_be_affix(self):
        return True

    def is_empty(self):
        return False

    def compile(self, ctx):
        ctx.emit(OPCODE_LITERAL_IGNORE if self.case_insensitive else OPCODE_LITERAL)
        ctx.emit(self.value)


class Any(RegexpBase):
    def is_empty(self):
        return False

    def fix_groups(self):
        pass

    def optimize(self, info, in_set=False):
        return self

    def compile(self, ctx):
        ctx.emit(OPCODE_ANY)


class AnyAll(RegexpBase):
    def is_empty(self):
        return False

    def fix_groups(self):
        pass

    def optimize(self, info, in_set=False):
        return self

    def compile(self, ctx):
        ctx.emit(OPCODE_ANY_ALL)


class ZeroWidthBase(RegexpBase):
    def fix_groups(self):
        pass

    def optimize(self, info, in_set=False):
        return self


class AtPosition(ZeroWidthBase):
    def __init__(self, code):
        ZeroWidthBase.__init__(self)
        self.code = code

    def can_be_affix(self):
        return True

    def compile(self, ctx):
        ctx.emit(OPCODE_AT)
        ctx.emit(self.code)


class Property(RegexpBase):
    def __init__(self, value, positive=True, case_insensitive=False, zerowidth=False):
        RegexpBase.__init__(self, positive=positive, case_insensitive=case_insensitive, zerowidth=zerowidth)
        self.value = value

    def rebuild(self, positive, case_insensitive, zerowidth):
        return Property(self.value, positive, case_insensitive, zerowidth)

    def getwidth(self):
        return 1, 1

    def is_empty(self):
        return False

    def fix_groups(self):
        pass

    def optimize(self, info, in_set=False):
        return self

    def can_be_affix(self):
        return True

    def compile(self, ctx):
        ctx.emit(OPCODE_CATEGORY)
        ctx.emit(self.value)


class Range(RegexpBase):
    def __init__(self, lower, upper, positive=True, case_insensitive=False, zerowidth=False):
        RegexpBase.__init__(self, positive=positive, case_insensitive=case_insensitive, zerowidth=zerowidth)
        self.lower = lower
        self.upper = upper

    def rebuild(self, positive, case_insensitive, zerowidth):
        return Range(self.lower, self.upper, positive, case_insensitive, zerowidth)

    def fix_groups(self):
        pass

    def optimize(self, info, in_set=False):
        return self

    def can_be_affix(self):
        return True

    def compile(self, ctx):
        if not self.positive:
            ctx.emit(OPCODE_NEGATE)
        ctx.emit(OPCODE_RANGE)
        ctx.emit(self.lower)
        ctx.emit(self.upper)


class Sequence(RegexpBase):
    def __init__(self, items):
        RegexpBase.__init__(self)
        self.items = items

    def is_empty(self):
        for item in self.items:
            if not item.is_empty():
                return False
        return True

    def fix_groups(self):
        for item in self.items:
            item.fix_groups()

    def optimize(self, info, in_set=False):
        items = []
        for item in self.items:
            item = item.optimize(info)
            if isinstance(item, Sequence):
                items.extend(item.items)
            else:
                items.append(item)
        return make_sequence(items)

    def compile(self, ctx):
        for item in self.items:
            item.compile(ctx)


class Branch(RegexpBase):
    def __init__(self, branches):
        RegexpBase.__init__(self)
        self.branches = branches

    def fix_groups(self):
        for b in self.branches:
            b.fix_groups()

    def is_empty(self):
        for b in self.branches:
            if not b.is_empty():
                return False
        return True

    def _flatten_branches(self, info, branches):
        new_branches = []
        for b in branches:
            b = b.optimize(info)
            if isinstance(b, Branch):
                new_branches.extend(b.branches)
            else:
                new_branches.append(b)
        return new_branches

    def _split_common_prefix(self, info, branches):
        alternatives = []
        for b in branches:
            if isinstance(b, Sequence):
                alternatives.append(b.items)
            else:
                alternatives.append([b])
        max_count = sys.maxint
        for a in alternatives:
            max_count = min(max_count, len(a))
        prefix = alternatives[0]
        pos = 0
        end_pos = max_count
        while (pos < end_pos and prefix[pos].can_be_affix() and
            [None for a in alternatives if a[pos] == prefix[pos]]):
            pos += 1
        if pos == 0:
            return [], branches
        new_branches = []
        for a in alternatives:
            new_branches.append(make_sequence(a[pos:]))
        return prefix[:pos], new_branches

    def _split_common_suffix(self, info, branches):
        alternatives = []
        for b in branches:
            if isinstance(b, Sequence):
                alternatives.append(b.items)
            else:
                alternatives.append([b])
        max_count = sys.maxint
        for a in alternatives:
            max_count = min(max_count, len(a))
        suffix = alternatives[0]
        pos = -1
        end_pos = -1 - max_count
        while (pos > end_pos and suffix[pos].can_be_affix() and
            [None for a in alternatives if a[pos] == suffix[pos]]):
            pos -= 1
        count = -1 - pos
        if count == 0:
            return [], branches
        new_branches = []
        for a in alternatives:
            end = len(a) - count
            assert end >= 0
            new_branches.append(make_sequence(a[:end]))
        start = len(suffix) - count
        assert start >= 0
        return suffix[start:], new_branches

    def _is_simple_character(self, c):
        return isinstance(c, Character) and c.positive and not c.case_insensitive

    def _flush_char_prefix(self, info, prefixed, order, new_branches):
        if not prefixed:
            return
        items = prefixed.items()
        sorter = BranchSorter(items, order)
        sorter.sort()
        for value, branches in items:
            if len(branches) == 1:
                new_branches.append(make_sequence(branches[0]))
            else:
                subbranches = []
                optional = False
                for b in branches:
                    if len(b) > 1:
                        subbranches.append(make_sequence(b[1:]))
                    elif not optional:
                        subbranches.append(Sequence([]))
                        optional = True
                sequence = Sequence([Character(value), Branch(subbranches)])
                new_branches.append(sequence.optimize(info))
        prefixed.clear()
        order.clear()

    def _merge_common_prefixes(self, info, branches):
        prefixed = {}
        order = {}
        new_branches = []
        for b in branches:
            if self._is_simple_character(b):
                assert isinstance(b, Character)
                prefixed.setdefault(b.value, []).append([b])
                order.setdefault(b.value, len(order))
            elif isinstance(b, Sequence) and b.items and self._is_simple_character(b.items[0]):
                item = b.items[0]
                assert isinstance(item, Character)
                prefixed.setdefault(item.value, []).append(b.items)
                order.setdefault(item.value, len(order))
            else:
                self._flush_char_prefix(info, prefixed, order, new_branches)
                new_branches.append(b)
        self._flush_char_prefix(info, prefixed, order, new_branches)
        return new_branches

    def _flush_set_members(self, info, items, case_insensitive, new_branches):
        if not items:
            return
        if len(items) == 1:
            [item] = items.keys()
        else:
            item = SetUnion(info, items.keys()).optimize(info)
        new_branches.append(item.with_flags(case_insensitive=case_insensitive))
        items.clear()

    def _reduce_to_set(self, info, branches):
        new_branches = []
        items = {}
        case_insensitive = False
        for b in branches:
            if isinstance(b, Character) or isinstance(b, Property) or isinstance(b, SetBase):
                if b.case_insensitive != case_insensitive:
                    self._flush_set_members(info, items, case_insensitive, new_branches)
                    case_insensitive = b.case_insensitive
                items[b.with_flags(case_insensitive=False)] = False
            else:
                self._flush_set_members(info, items, case_insensitive, new_branches)
                new_branches.append(b)
        self._flush_set_members(info, items, case_insensitive, new_branches)
        return new_branches

    def optimize(self, info, in_set=False):
        branches = self._flatten_branches(info, self.branches)

        prefix, branches = self._split_common_prefix(info, branches)
        suffix, branches = self._split_common_suffix(info, branches)

        branches = self._merge_common_prefixes(info, branches)
        branches = self._reduce_to_set(info, branches)
        if len(branches) > 1:
            sequence = prefix + [Branch(branches)] + suffix
        else:
            sequence = prefix + branches + suffix
        return make_sequence(sequence)

    def compile(self, ctx):
        ctx.emit(OPCODE_BRANCH)
        tail = []
        for b in self.branches:
            pos = ctx.tell()
            ctx.emit(0)
            b.compile(ctx)
            ctx.emit(OPCODE_JUMP)
            tail.append(ctx.tell())
            ctx.emit(0)
            ctx.patch(pos, ctx.tell() - pos)
        ctx.emit(0)
        for t in tail:
            ctx.patch(t, ctx.tell() - t)


class BaseRepeat(RegexpBase):
    def __init__(self, subpattern, min_count, max_count):
        RegexpBase.__init__(self)
        self.subpattern = subpattern
        self.min_count = min_count
        self.max_count = max_count

    def fix_groups(self):
        self.subpattern.fix_groups()

    def is_empty(self):
        return self.subpattern.is_empty()

    def compile(self, ctx):
        ctx.emit(OPCODE_REPEAT)
        pos = ctx.tell()
        ctx.emit(0)
        ctx.emit(self.min_count)
        ctx.emit(self.max_count)
        self.subpattern.compile(ctx)
        ctx.patch(pos, ctx.tell() - pos)
        ctx.emit(self.UNTIL_OPCODE)


class GreedyRepeat(BaseRepeat):
    UNTIL_OPCODE = OPCODE_MAX_UNTIL

    def can_be_affix(self):
        return True

    def optimize(self, info, in_set=False):
        subpattern = self.subpattern.optimize(info)
        return GreedyRepeat(subpattern, self.min_count, self.max_count)


class LazyRepeat(BaseRepeat):
    UNTIL_OPCODE = OPCODE_MIN_UNTIL

    def optimize(self, info, in_set=False):
        subpattern = self.subpattern.optimize(info)
        return LazyRepeat(subpattern, self.min_count, self.max_count)


class LookAround(RegexpBase):
    def __init__(self, subpattern, behind, positive):
        RegexpBase.__init__(self, positive=positive)
        self.subpattern = subpattern
        self.behind = behind

    def fix_groups(self):
        self.subpattern.fix_groups()

    def can_be_affix(self):
        return self.subpattern.can_be_affix()

    def optimize(self, info, in_set=False):
        return LookAround(self.subpattern.optimize(info), self.behind, self.positive)

    def compile(self, ctx):
        ctx.emit(OPCODE_ASSERT if self.positive else OPCODE_ASSERT_NOT)
        pos = ctx.tell()
        ctx.emit(0)
        if self.behind:
            lo, hi = self.subpattern.getwidth()
            if lo != hi:
                raise RegexpError("look-behind requires fixed-width pattern")
            ctx.emit(lo)
        else:
            ctx.emit(0)
        self.subpattern.compile(ctx)
        ctx.emit(OPCODE_SUCCESS)
        ctx.patch(pos, ctx.tell() - pos)


class Group(RegexpBase):
    def __init__(self, info, group, subpattern):
        RegexpBase.__init__(self)
        self.info = info
        self.group = group
        self.subpattern = subpattern

    def fix_groups(self):
        self.info.defined_groups[self.group] = self
        self.subpattern.fix_groups()

    def can_be_affix(self):
        return False

    def optimize(self, info, in_set=False):
        return Group(self.info, self.group, self.subpattern.optimize(info))

    def is_empty(self):
        return False

    def compile(self, ctx):
        ctx.emit(OPCODE_MARK)
        ctx.emit((self.group - 1) * 2)
        self.subpattern.compile(ctx)
        ctx.emit(OPCODE_MARK)
        ctx.emit((self.group - 1) * 2 + 1)


class RefGroup(RegexpBase):
    def __init__(self, info, group, case_insensitive=False):
        RegexpBase.__init__(self, case_insensitive=case_insensitive)
        self.info = info
        self.group = group

    def fix_groups(self):
        if not 1 <= self.group <= self.info.group_count:
            raise RegexpError("unknown group")

    def optimize(self, info, in_set=False):
        return self

    def compile(self, ctx):
        assert not self.case_insensitive
        ctx.emit(OPCODE_GROUPREF)
        ctx.emit(self.group - 1)


class SetBase(RegexpBase):
    def __init__(self, info, items, positive=True, case_insensitive=False, zerowidth=False):
        RegexpBase.__init__(self, positive=positive, case_insensitive=case_insensitive, zerowidth=zerowidth)
        self.info = info
        self.items = items

    def is_empty(self):
        return False

    def can_be_affix(self):
        return True

    def fix_groups(self):
        pass


class SetUnion(SetBase):
    def optimize(self, info, in_set=False):
        items = []
        for item in self.items:
            item = item.optimize(info, in_set=True)
            if isinstance(item, SetUnion) and item.positive:
                items.extend(item.items)
            else:
                items.append(item)
        if len(items) == 1 and not isinstance(items[0], Range):
            return items[0].with_flags(
                positive=items[0].positive == self.positive,
                case_insensitive=self.case_insensitive,
                zerowidth=self.zerowidth
            ).optimize(info, in_set=in_set)
        return SetUnion(self.info, items, positive=self.positive, case_insensitive=self.case_insensitive, zerowidth=self.zerowidth)

    def rebuild(self, positive, case_insensitive, zerowidth):
        return SetUnion(self.info, self.items, positive, case_insensitive, zerowidth).optimize(self.info)

    def compile(self, ctx):
        ctx.emit(OPCODE_IN)
        pos = ctx.tell()
        ctx.emit(0)
        if not self.positive:
            ctx.emit(OPCODE_NEGATE)
        for item in self.items:
            item.compile(ctx)
        ctx.emit(OPCODE_FAILURE)
        ctx.patch(pos, ctx.tell() - pos)


class SetIntersection(SetBase):
    def rebuild(self, positive, case_insensitive, zerowidth):
        return SetIntersection(self.info, self.items, positive=positive, case_insensitive=case_insensitive, zerowidth=zerowidth)

    def optimize(self, info, in_set=False):
        items = []
        for item in self.items:
            item = item.optimize(info, in_set=True)
            if isinstance(item, SetIntersection) and item.positive:
                items.extend(item.items)
            else:
                items.append(item)
        if len(items) == 1:
            return items[0].with_flags(
                case_insensitive=self.case_insensitive,
                zerowidth=self.zerowidth,
            ).optimize(info, in_set)
        return SetIntersection(info, items)

    def compile(self, ctx):
        Sequence([
            LookAround(item, behind=False, positive=True)
            for item in self.items[:-1]
        ] + [self.items[-1]]).compile(ctx)


POSITION_ESCAPES = {
    "A": AtPosition(AT_BEGINNING_STRING),
    "z": AtPosition(AT_END_STRING),

    "b": AtPosition(AT_BOUNDARY),
    "B": AtPosition(AT_NON_BOUNDARY),
}
CHARSET_ESCAPES = {
    "d": Property(CATEGORY_DIGIT),
    "w": Property(CATEGORY_WORD),
}
PROPERTIES = {
    "digit": CATEGORY_DIGIT,
    "alnum": CATEGORY_WORD,
}


def make_character(info, value, in_set=False):
    if in_set:
        return Character(value)
    return Character(value, case_insensitive=info.flags & IGNORE_CASE)


def make_sequence(items):
    if len(items) == 1:
        return items[0]
    return Sequence(items)


def make_atomic(info, subpattern):
    group = info.new_group()
    info.close_group(group, hidden=True)
    return Sequence([
        LookAround(Group(info, group, subpattern), behind=False, positive=True),
        RefGroup(info, group),
    ])


def make_ref_group(info, name):
    return RefGroup(info, name, case_insensitive=info.flags & IGNORE_CASE)


def _parse_pattern(source, info):
    previous_groups = info.used_groups.copy()
    branches = [_parse_sequence(source, info)]
    all_groups = info.used_groups
    while source.match("|"):
        info.used_groups = previous_groups.copy()
        branches.append(_parse_sequence(source, info))
        all_groups.update(info.used_groups)
    info.used_groups = all_groups

    if len(branches) == 1:
        return branches[0]
    return Branch(branches)


def _parse_sequence(source, info):
    sequence = []
    item = _parse_item(source, info)
    while item:
        sequence.append(item)
        item = _parse_item(source, info)

    return make_sequence(sequence)


def _parse_item(source, info):
    element = _parse_element(source, info)
    counts = _parse_quantifier(source, info)
    if counts is not None:
        min_count, max_count = counts.min_count, counts.max_count

        if element.is_empty() or min_count == max_count == 1:
            return element

        if source.match("?"):
            return LazyRepeat(element, min_count, max_count)
        elif source.match("+"):
            if counts.limited_quantifier:
                return GreedyRepeat(GreedyRepeat(element, min_count, max_count), 1, MAX_REPEAT)
            else:
                return make_atomic(info, GreedyRepeat(element, min_count, max_count))
        else:
            return GreedyRepeat(element, min_count, max_count)
    return element


def _parse_element(source, info):
    here = source.pos
    ch = source.get()
    if ch in SPECIAL_CHARS:
        if ch in ")|":
            source.pos = here
            return None
        elif ch == "\\":
            return _parse_escape(source, info, in_set=False)
        elif ch == "(":
            element = _parse_paren(source, info)
            if element is not None:
                return element
        elif ch == ".":
            if info.flags & DOT_ALL:
                return AnyAll()
            else:
                return Any()
        elif ch == "[":
            return _parse_set(source, info)
        elif ch == "^":
            return AtPosition(AT_BEGINNING_STRING)
        elif ch == "$":
            return AtPosition(AT_END_STRING)
        elif ch == "{":
            here2 = source.pos
            counts = _parse_quantifier(source, info)
            if counts is not None:
                raise RegexpError("nothing to repeat")
            source.pos = here2
            return make_character(info, ord(ch[0]))
        elif ch in "?*+":
            raise RegexpError("nothing to repeat")
        else:
            return make_character(info, ord(ch[0]))
    else:
        return make_character(info, ord(ch[0]))


def _parse_quantifier(source, info):
    while True:
        here = source.pos
        if source.match("?"):
            return Counts(0, 1)
        elif source.match("*"):
            return Counts(0)
        elif source.match("+"):
            return Counts(1)
        elif source.match("{"):
            try:
                return _parse_limited_quantifier(source)
            except ParseError:
                pass
        elif source.match("(?#"):
            _parse_comment(source)
            continue
        break
    source.pos = here
    return None


def _parse_paren(source, info):
    if source.match("?"):
        if source.match("<"):
            if source.match("="):
                return _parse_lookaround(source, info, behind=True, positive=True)
            elif source.match("!"):
                return _parse_lookaround(source, info, behind=True, positive=False)
            name = _parse_name(source)
            group = info.new_group(name)
            source.expect(">")
            saved_flags = info.flags
            saved_ignore = source.ignore_space
            try:
                subpattern = _parse_pattern(source, info)
            finally:
                source.ignore_space = saved_ignore
                info.flags = saved_flags
            source.expect(")")
            info.close_group(group)
            return Group(info, group, subpattern)
        elif source.match("="):
            return _parse_lookaround(source, info, behind=False, positive=True)
        elif source.match("!"):
            return _parse_lookaround(source, info, behind=False, positive=False)
        elif source.match("#"):
            _parse_comment(source)
            return
        elif source.match(">"):
            return _parse_atomic(source, info)
        elif source.match(":"):
            subpattern = _parse_pattern(source, info)
            source.expect(")")
            return subpattern
        elif source.match("-") or source.match("m") or source.match("i") or source.match("x"):
            # TODO: parse plain here flags = _parse_plain_flags(source)
            subpattern = _parse_pattern(source, info)
            source.expect(")")
            return subpattern
        else:
            raise RegexpError("undefined group option")
    group = info.new_group()
    saved_flags = info.flags
    saved_ignore = source.ignore_space
    try:
        subpattern = _parse_pattern(source, info)
    finally:
        source.ignore_space = saved_ignore
        info.flags = saved_flags
    source.expect(")")
    info.close_group(group)
    return Group(info, group, subpattern)


def _parse_atomic(source, info):
    saved_flags = info.flags
    saved_ignore = source.ignore_space
    try:
        subpattern = _parse_pattern(source, info)
    finally:
        source.ignore_space = saved_ignore
        info.flags = saved_flags
    source.expect(")")
    return make_atomic(info, subpattern)


def _parse_set(source, info):
    saved_ignore = source.ignore_space
    source.ignore_space = False
    negate = source.match("^")
    try:
        item = _parse_set_intersect(source, info)
        source.expect("]")
    finally:
        source.ignore_space = saved_ignore

    if negate:
        item = item.with_flags(positive=not item.positive)
    return item.with_flags(case_insensitive=info.flags & IGNORE_CASE)


def _parse_set_intersect(source, info):
    items = [_parse_set_implicit_union(source, info)]
    while source.match("&&"):
        items.append(_parse_set_implicit_union(source, info))

    if len(items) == 1:
        return items[0]
    return SetIntersection(info, items)


def _parse_set_implicit_union(source, info):
    items = [_parse_set_member(source, info)]
    while True:
        here = source.pos
        if source.match("]") or source.match("&&"):
            source.pos = here
            break
        items.append(_parse_set_member(source, info))
    if len(items) == 1 and not isinstance(items[0], Range):
        return items[0]
    return SetUnion(info, items)


def _parse_set_member(source, info):
    start = _parse_set_item(source, info)
    if (not isinstance(start, Character) or not start.positive or
        not source.match("-")):
        return start

    here = source.pos
    if source.match("]"):
        source.pos = here
        return SetUnion(info, [start, Character(ord("-"))])
    end = _parse_set_item(source, info)
    if not isinstance(end, Character) or not end.positive:
        return SetUnion(info, [start, Character(ord("-")), end])
    if start.value > end.value:
        raise RegexpError("bad character range")
    if start.value == end.value:
        return start
    return Range(start.value, end.value)


def _parse_set_item(source, info):
    if source.match("\\"):
        return _parse_escape(source, info, in_set=True)

    here = source.pos
    if source.match("[:"):
        try:
            return _parse_posix_class(source, info)
        except ParseError:
            source.pos = here
    if source.match("["):
        negate = source.match("^")
        item = _parse_set_intersect(source, info)
        source.expect("]")
        if negate:
            item = item.with_flags(positive=not item.positive)
        return item
    ch = source.get()
    if not ch:
        raise RegexpError("bad set")
    return Character(ord(ch[0]))


def _parse_escape(source, info, in_set):
    saved_ignore = source.ignore_space
    source.ignore_space = False
    ch = source.get()
    source.ignore_space = saved_ignore
    if not ch:
        raise RegexpError("bad escape")
    if ch == "g" and not in_set:
        here = source.pos
        try:
            return _parse_group_ref(source, info)
        except RegexpError:
            source.pos = here
        return make_character(info, ord(ch[0]), in_set)
    elif ch == "G" and not in_set:
        return AtPosition(AT_BEGINNING)
    elif ch in "pP":
        return _parse_property(source, info, ch == "p", in_set)
    elif ch.isalpha():
        if not in_set:
            if ch in POSITION_ESCAPES:
                return POSITION_ESCAPES[ch]
        if ch in CHARSET_ESCAPES:
            return CHARSET_ESCAPES[ch]
        elif ch in CHARACTER_ESCAPES:
            return Character(ord(CHARACTER_ESCAPES[ch]))
        return make_character(info, ord(ch[0]), in_set)
    elif ch.isdigit():
        return _parse_numeric_escape(source, info, ch, in_set)
    else:
        return make_character(info, ord(ch[0]), in_set)


def _parse_lookaround(source, info, behind, positive):
    saved_flags = info.flags
    saved_ignore = source.ignore_space
    try:
        subpattern = _parse_pattern(source, info)
    finally:
        source.ignore_space = saved_ignore
        info.flags = saved_flags
    source.expect(")")
    return LookAround(subpattern, behind=behind, positive=positive)


def _parse_limited_quantifier(source):
    min_count = _parse_count(source)
    ch = source.get()
    if ch == ",":
        max_count = _parse_count(source)
        if not source.match("}"):
            raise ParseError
        min_count = int(min_count) if min_count else 0
        max_count = int(max_count) if max_count else MAX_REPEAT
        if min_count > max_count:
            raise RegexpError("min repeat gereater than max repeat")
        if max_count > MAX_REPEAT:
            raise RegexpError("repeat count too big")
        return Counts(min_count, max_count, limited_quantifier=True)
    if ch != "}":
        raise ParseError
    if not min_count:
        raise ParseError
    min_count = int(min_count)
    if min_count > MAX_REPEAT:
        raise RegexpError("repeat count too big")
    return Counts(min_count, min_count, limited_quantifier=True)


def _parse_count(source):
    b = StringBuilder(2)
    while True:
        here = source.pos
        ch = source.get()
        if ch.isdigit():
            b.append(ch)
        else:
            source.pos = here
            break
    return b.build()


def _parse_comment(source):
    while True:
        ch = source.get()
        if ch == ")":
            break
        elif not ch:
            break


def _parse_name(source):
    b = StringBuilder(5)
    while True:
        here = source.pos
        ch = source.get()
        if ch in ")>":
            source.pos = here
            break
        elif not ch:
            break
        else:
            b.append(ch)
    return b.build()


def _parse_plain_flags(source):
    b = StringBuilder(4)
    while True:
        ch = source.get()
        if ch == ":":
            break
        else:
            b.append(ch)
    return b.build()


def _parse_group_ref(source, info):
    source.expect("<")
    name = _parse_name(source)
    source.expect(">")
    if info.is_open_group(name):
        raise RegexpError("can't refer to an open group")
    return make_ref_group(info, info.normalize_group(name))


def _parse_property(source, info, positive, in_set):
    here = source.pos
    if source.match("{"):
        negate = source.match("^")
        prop_name, name = _parse_property_name(source)
        if source.match("}"):
            if name in PROPERTIES:
                return Property(PROPERTIES[name], positive != negate)
    source.pos = here
    return make_character(info, ord("p" if positive else "P"), in_set)


def _parse_property_name(source):
    b = StringBuilder(5)
    while True:
        here = source.pos
        ch = source.get()
        if ch.isalnum():
            b.append(ch)
        else:
            source.pos = here
            break
    name = b.build()
    return name, name


def _parse_numeric_escape(source, info, ch, in_set):
    raise NotImplementedError("_parse_numeric_escape")


def _parse_posix_class(source, info):
    negate = source.match("^")
    prop_name, name = _parse_property_name(source)
    if not source.match(":]"):
        raise ParseError
    return Property(PROPERTIES[name], negate)


def _compile_no_cache(pattern, flags):
    source = Source(pattern)
    if flags & EXTENDED:
        source.ignore_space = True
    info = Info(flags)
    parsed = _parse_pattern(source, info)

    if not source.at_end():
        raise RegexpError("trailing characters in pattern")

    parsed.fix_groups()
    parsed = parsed.optimize(info)

    ctx = CompilerContext()
    parsed.compile(ctx)
    ctx.emit(OPCODE_SUCCESS)
    code = ctx.build()

    index_group = {}
    for n, v in info.group_index.iteritems():
        index_group[v] = n
    return code, info.flags, info.group_count, info.group_index, index_group, info.group_offsets


def compile(cache, pattern, flags=0):
    if not cache.contains(pattern, flags):
        cache.set(pattern, flags, _compile_no_cache(pattern, flags))
    return cache.get(pattern, flags)

########NEW FILE########
__FILENAME__ = __main__
import sys

import py
py.log.setconsumer("platform", None)

from rpython.config.translationoption import get_combined_translation_config

from topaz.main import create_entry_point, get_topaz_config_options


entry_point = create_entry_point(get_combined_translation_config(
    overrides=get_topaz_config_options(),
))
sys.exit(entry_point(sys.argv))

########NEW FILE########
