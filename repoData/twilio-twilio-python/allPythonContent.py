__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# twilio-python2 documentation build configuration file, created by
# sphinx-quickstart on Mon Dec 13 16:47:32 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
from datetime import datetime

from twilio import __version_info__

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.intersphinx',
]

RTD_NEW_THEME = True

# Load the source for autodoc
sys.path.insert(0, os.path.abspath(os.path.join(os.getcwd(), '..')))

# So links to Python default docs work
intersphinx_mapping = {'python': ('http://docs.python.org/2.7', None)}

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'twilio-python'
copyright = unicode(datetime.utcnow().year) + u', Twilio Inc'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '.'.join(__version_info__[:2])
# The full version, including alpha/beta/rc tags.
release = '.'.join(__version_info__)

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.

sys.path.append(os.path.abspath('_themes'))
#html_theme_path = ['_themes']
#html_theme = 'kr'


# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'twilio-pythondoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'twilio-python.tex', u'twilio-python Documentation',
   u'Twilio Inc.', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'twilio-python', u'twilio-python Documentation',
     [u'Twilio Inc.'], 1)
]


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'twilio-python'
epub_author = u'kyle@twilio.com'
epub_publisher = u'Twilio Inc.'
epub_copyright = u'2013, Twilio Inc.'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        #Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929", # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902", # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902", # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000", # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }

########NEW FILE########
__FILENAME__ = process
#!/usr/bin/env python
from __future__ import with_statement
import re
import os

sid = "ed59a5733d2c1c1c69a83a28"


def twilio_clean(contents):
    contents = re.sub(r"([A-Z]{2}\w{8})\w{24}", r"\1%s" % sid, contents)
    contents = re.sub(r"\"[a-z0-9]{32}\"", "\"AUTHTOKEN\"", contents)
    contents = re.sub(r"\+\d{10}", r"+14158675309", contents)
    contents = re.sub(r"[0-9\- \(\)]{14}", r"(415) 867-5309", contents)
    return contents


def main():
    for f in os.listdir(os.path.abspath(os.path.dirname(__file__))):
        path, ext = os.path.splitext(f)
        if ext == ".json":
            with open(f) as g:
                contents = g.read()
            contents = twilio_clean(contents)
            with open(f, "w") as g:
                g.write(contents.strip())
                g.write("\n")


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = test_accounts
import unittest

from mock import Mock, patch

from tools import create_mock_json
from twilio.rest.resources import Account


class AccountTest(unittest.TestCase):

    @patch("twilio.rest.resources.base.make_twilio_request")
    def test_usage_records_subresource(self, request):
        resp = create_mock_json("tests/resources/usage_records_list.json")
        request.return_value = resp

        mock = Mock()
        mock.uri = "/base"
        account = Account(mock, 'AC123')
        account.load_subresources()
        records = account.usage_records.list()
        self.assertEquals(len(records), 2)

    @patch("twilio.rest.resources.base.make_twilio_request")
    def test_usage_triggers_subresource(self, request):
        resp = create_mock_json("tests/resources/usage_triggers_list.json")
        request.return_value = resp

        mock = Mock()
        mock.uri = "/base"
        account = Account(mock, 'AC123')
        account.load_subresources()
        triggers = account.usage_triggers.list()
        self.assertEquals(len(triggers), 2)

########NEW FILE########
__FILENAME__ = test_applications
import unittest

from mock import Mock, patch

from twilio.rest.resources import Applications, Application


class ApplicationsTest(unittest.TestCase):
    def setUp(self):
        self.parent = Mock()
        self.resource = Applications("http://api.twilio.com", ("user", "pass"))

    def test_create_application_sms_url_method(self):
        self.resource.create_instance = Mock()
        self.resource.create(sms_method="hey")
        self.resource.create_instance.assert_called_with({"sms_method": "hey"})

    def test_create_application_sms_url(self):
        self.resource.create_instance = Mock()
        self.resource.create(sms_url="hey")
        self.resource.create_instance.assert_called_with({"sms_url": "hey"})

    def test_update_application_sms_url_method(self):
        self.resource.update_instance = Mock()
        self.resource.update("123", sms_method="hey")
        self.resource.update_instance.assert_called_with(
            "123", {"sms_method": "hey"})

    def test_update_application_sms_url(self):
        self.resource.update_instance = Mock()
        self.resource.update("123", sms_url="hey")
        self.resource.update_instance.assert_called_with(
            "123", {"sms_url": "hey"})

    def test_update(self):
        request = Mock()
        request.return_value = (Mock(), {"sid": "123"})
        self.resource.request = request

        self.resource.update("123", voice_url="hey")

        uri = "http://api.twilio.com/Applications/123"
        request.assert_called_with("POST", uri, data={"VoiceUrl": "hey"})

    def test_create(self):
        request = Mock()
        request.return_value = (request, {"sid": "123"})
        request.status_code = 201

        self.resource.request = request

        self.resource.create(friendly_name="hey")

        uri = "http://api.twilio.com/Applications"
        request.assert_called_with("POST", uri, data={"FriendlyName": "hey"})

    @patch("twilio.rest.resources.base.Resource.request")
    def test_delete(self, req):
        """ Deleting an application should work """
        resp = Mock()
        resp.content = ""
        resp.status_code = 204
        req.return_value = resp, {}

        app = Application(self.resource, "AP123")
        app.delete()
        uri = "http://api.twilio.com/Applications/AP123"
        req.assert_called_with("DELETE", uri)

########NEW FILE########
__FILENAME__ = test_authorized_connect_apps
from __future__ import with_statement
import unittest

from mock import Mock, patch
from nose.tools import assert_equal

from twilio.rest.resources import AuthorizedConnectApps
from twilio.rest.resources import AuthorizedConnectApp


class AuthorizedConnectAppTest(unittest.TestCase):

    def setUp(self):
        self.parent = Mock()
        self.uri = "/base"
        self.auth = ("AC123", "token")
        self.resource = AuthorizedConnectApps(self.uri, self.auth)

    @patch("twilio.rest.resources.base.make_twilio_request")
    def test_get(self, mock):
        mock.return_value = Mock()
        mock.return_value.content = '{"connect_app_sid": "SID"}'

        self.resource.get("SID")
        mock.assert_called_with("GET", "/base/AuthorizedConnectApps/SID",
                                auth=self.auth)

    @patch("twilio.rest.resources.base.make_twilio_request")
    def test_list(self, mock):
        mock.return_value = Mock()
        mock.return_value.content = '{"authorized_connect_apps": []}'

        self.resource.list()
        mock.assert_called_with("GET", "/base/AuthorizedConnectApps",
                                params={}, auth=self.auth)

    def test_load(self):
        instance = AuthorizedConnectApp(Mock(), "sid")
        instance.load({
            "connect_app_sid": "SID",
            "account_sid": "AC8dfe2f2358cf421cb6134cf6f217c6a3",
            "permissions": ["get-all"],
            "connect_app_friendly_name": "foo",
            "connect_app_description": "bat",
            "connect_app_company_name": "bar",
            "connect_app_homepage_url": "http://www.google.com",
            "uri": "/2010-04-01/Accounts/",
        })

        assert_equal(instance.permissions, ["get-all"])
        assert_equal(instance.sid, "SID")
        assert_equal(instance.friendly_name, "foo")
        assert_equal(instance.description, "bat")
        assert_equal(instance.homepage_url, "http://www.google.com")
        assert_equal(instance.company_name, "bar")

    def test_delete(self):
        self.assertRaises(AttributeError, getattr, self.resource, 'delete')

    def test_create(self):
        self.assertRaises(AttributeError, getattr, self.resource, 'create')

    def test_update(self):
        self.assertRaises(AttributeError, getattr, self.resource, 'update')

########NEW FILE########
__FILENAME__ = test_available_phonenumber
import unittest

from mock import Mock
from nose.tools import assert_equal, assert_true

from twilio import TwilioException
from twilio.rest.resources import AvailablePhoneNumber
from twilio.rest.resources import AvailablePhoneNumbers
from twilio.rest.resources import PhoneNumbers
from twilio.rest.resources import UNSET_TIMEOUT


class AvailablePhoneNumberTest(unittest.TestCase):

    def setUp(self):
        self.parent = Mock()
        self.instance = AvailablePhoneNumber(self.parent)

    def test_init(self):
        assert_equal(self.instance.name, "")

    def test_purchase(self):
        self.instance.phone_number = "+123"
        self.instance.purchase(voice_url="http://www.google.com")

        self.parent.purchase.assert_called_with(
            voice_url="http://www.google.com",
            phone_number="+123")


class AvailablePhoneNumbersTest(unittest.TestCase):

    def setUp(self):
        self.resource = AvailablePhoneNumbers("http://api.twilio.com",
                                              ("user", "pass"), UNSET_TIMEOUT, Mock())

    def test_get(self):
        self.assertRaises(TwilioException, self.resource.get, "PN123")

    def test_list(self):
        request = Mock()
        request.return_value = (Mock(), {"available_phone_numbers": []})
        self.resource.request = request

        self.resource.list()

        uri = "http://api.twilio.com/AvailablePhoneNumbers/US/Local"
        request.assert_called_with("GET", uri, params={})

    def test_load_instance(self):
        instance = self.resource.load_instance({"hey": "you"})
        assert_true(isinstance(instance.parent, Mock))
        assert_equal(instance.hey, "you")

    def test_purchase_status_callback(self):
        request = Mock()
        request.return_value = (Mock(), {"available_phone_numbers": []})
        self.resource.request = request

        self.resource.list()

        uri = "http://api.twilio.com/AvailablePhoneNumbers/US/Local"
        request.assert_called_with("GET", uri, params={})

    def test_mobile(self):
        request = Mock()
        request.return_value = (Mock(), {"available_phone_numbers": []})
        self.resource.request = request

        self.resource.list(type='mobile', country='GB')

        uri = "http://api.twilio.com/AvailablePhoneNumbers/GB/Mobile"
        request.assert_called_with("GET", uri, params={})


class PhoneNumbersTest(unittest.TestCase):

    def setUp(self):
        self.resource = PhoneNumbers("http://api.twilio.com",
                                     ("user", "pass"))

    def test_reference(self):
        assert_equal(self.resource.available_phone_numbers.phone_numbers,
                     self.resource)

    def test_purchase_status_callback(self):
        request = Mock()
        response = Mock()
        response.status_code = 201
        request.return_value = (response, {"sid": ""})
        self.resource.request = request

        self.resource.purchase(area_code="530", status_callback_url="http://",
                               status_callback_method="POST")

        uri = "http://api.twilio.com/IncomingPhoneNumbers"

        data = {
            "AreaCode": "530",
            "StatusCallback": "http://",
            "StatusCallbackMethod": "POST",
            }

        request.assert_called_with("POST", uri, data=data)

########NEW FILE########
__FILENAME__ = test_base_resource
# -*- coding: utf-8 -*-
import unittest

from mock import Mock, sentinel, patch, ANY
from nose.tools import assert_equal, assert_true
from six import advance_iterator

from twilio.rest.resources.imports import json
from twilio.rest.resources import Resource
from twilio.rest.resources import ListResource
from twilio.rest.resources import InstanceResource

base_uri = "https://api.twilio.com/2010-04-01"
account_sid = "AC123"
auth = (account_sid, "token")


def test_resource_init():
    r = Resource(base_uri, auth)
    uri = "%s/%s" % (base_uri, r.name)

    assert_equal(r.base_uri, base_uri)
    assert_equal(r.auth, auth)
    assert_equal(r.uri, uri)


def test_equivalence():
    p = ListResource(base_uri, auth)
    r1 = p.load_instance({"sid": "AC123"})
    r2 = p.load_instance({"sid": "AC123"})
    assert_equal(r1, r2)


class ListResourceTest(unittest.TestCase):

    def setUp(self):
        self.r = ListResource(base_uri, auth)

    def testListResourceInit(self):
        uri = "%s/%s" % (base_uri, self.r.name)
        assert_equal(self.r.uri, uri)

    def testKeyValueLower(self):
        assert_equal(self.r.key, self.r.name.lower())

    def testIterNoKey(self):
        self.r.request = Mock()
        self.r.request.return_value = Mock(), {}

        self.assertRaises(StopIteration, advance_iterator, self.r.iter())

    def testRequest(self):
        self.r.request = Mock()
        self.r.request.return_value = Mock(), {self.r.key: [{'sid': 'foo'}]}
        advance_iterator(self.r.iter())
        self.r.request.assert_called_with("GET", "https://api.twilio.com/2010-04-01/Resources", params={})

    def testIterOneItem(self):
        self.r.request = Mock()
        self.r.request.return_value = Mock(), {self.r.key: [{'sid': 'foo'}]}

        items = self.r.iter()
        advance_iterator(items)

        self.assertRaises(StopIteration, advance_iterator, items)

    def testIterNoNextPage(self):
        self.r.request = Mock()
        self.r.request.return_value = Mock(), {self.r.key: []}

        self.assertRaises(StopIteration, advance_iterator, self.r.iter())

    def testKeyValue(self):
        self.r.key = "Hey"
        assert_equal(self.r.key, "Hey")

    def testInstanceLoading(self):
        instance = self.r.load_instance({"sid": "foo"})

        assert_true(isinstance(instance, InstanceResource))
        assert_equal(instance.sid, "foo")

    def testListResourceCreateResponse200(self):
        """We should accept 200 OK in response to a POST creating a resource."""
        self.r.request = Mock()
        return_value = Mock()
        return_value.status_code = 200
        self.r.request.return_value = return_value, {'sid': 'foo'}
        self.r.create_instance({})
        self.r.request.assert_called_with("POST", "https://api.twilio.com/2010-04-01/Resources", data={})

    def testListResourceCreateResponse201(self):
        """We should accept 201 Created in response to a POST creating a resource."""
        self.r.request = Mock()
        return_value = Mock()
        return_value.status_code = 201
        self.r.request.return_value = return_value, {'sid': 'foo'}
        self.r.create_instance({})
        self.r.request.assert_called_with("POST", "https://api.twilio.com/2010-04-01/Resources", data={})


class testInstanceResourceInit(unittest.TestCase):

    def setUp(self):
        self.parent = ListResource(base_uri, auth)
        self.r = InstanceResource(self.parent, "123")
        self.uri = "%s/%s" % (self.parent.uri, "123")

    def testInit(self):
        assert_equal(self.r.uri, self.uri)

    def testLoad(self):
        self.r.load({"hey": "you"})
        assert_equal(self.r.hey, "you")

    def testLoadWithUri(self):
        self.r.load({"hey": "you", "uri": "foobar"})
        assert_equal(self.r.hey, "you")
        assert_equal(self.r.uri, self.uri)

    def testLoadDateCreated(self):
        self.r.load({"date_created": "Sat, 29 Sep 2012 12:47:54 +0000",
                     "uri": "foobar"})
        try:
            assert_true(hasattr(self.r.date_created, "day"))
            assert_equal(self.r.date_created.day, 29)
        except AttributeError:
            pass

    def testLoadNullDate(self):
        self.r.load({"date_created": None, "uri": "foobar"})
        assert self.r.date_created is None

    def testLoadWithFrom(self):
        self.r.load({"from": "foo"})
        assert_equal(self.r.from_, "foo")

    def testLoadSubresources(self):
        m = Mock()
        self.r.subresources = [m]
        self.r.load_subresources()
        m.assert_called_with(self.r.uri, self.r.auth, self.r.timeout)


class testTimeoutPropagation(unittest.TestCase):
    def setUp(self):
        self.parent = ListResource(base_uri, auth, timeout=sentinel.timeout)
        self.r = InstanceResource(self.parent, "123")
        self.uri = "%s/%s" % (self.parent.uri, "123")

    @patch('twilio.rest.resources.base.make_request')
    def testPassThrough(self, mock_request):
        mock_response = Mock()
        mock_response.ok = True,
        mock_response.content = json.dumps({'key': 'value'})
        mock_request.return_value = mock_response

        assert_equal(self.r.timeout, sentinel.timeout)
        assert_equal((mock_response, {'key': 'value'}), self.r.request('GET', base_uri))

        mock_request.assert_called_once_with(
            'GET',
            base_uri + '.json',
            headers=ANY,
            timeout=sentinel.timeout,
            auth=ANY
        )

########NEW FILE########
__FILENAME__ = test_calls
from datetime import date
from mock import patch
from nose.tools import raises, assert_true
from twilio.rest.resources import Calls
from tools import create_mock_json

BASE_URI = "https://api.twilio.com/2010-04-01/Accounts/AC123"
ACCOUNT_SID = "AC123"
AUTH = (ACCOUNT_SID, "token")
CALL_SID = "CA47e13748ed59a5733d2c1c1c69a83a28"

list_resource = Calls(BASE_URI, AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_create_call(mock):
    resp = create_mock_json("tests/resources/calls_instance.json")
    resp.status_code = 201
    mock.return_value = resp

    uri = "%s/Calls" % (BASE_URI)
    list_resource.create("TO", "FROM", "url", record=True, application_sid='APPSID')
    exp_params = {
        'To': "TO",
        'From': "FROM",
        'Url': "url",
        'Record': "true",
        'ApplicationSid': 'APPSID',
        }

    mock.assert_called_with("POST", uri, data=exp_params, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_paging(mock):
    resp = create_mock_json("tests/resources/calls_list.json")
    mock.return_value = resp

    uri = "%s/Calls" % (BASE_URI)
    list_resource.list(started_before=date(2010, 12, 5))
    exp_params = {'StartTime<': '2010-12-05'}

    mock.assert_called_with("GET", uri, params=exp_params, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_get(mock):
    resp = create_mock_json("tests/resources/calls_instance.json")
    mock.return_value = resp

    uri = "%s/Calls/%s" % (BASE_URI, CALL_SID)
    list_resource.get(CALL_SID)

    mock.assert_called_with("GET", uri, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_hangup(mock):
    resp = create_mock_json("tests/resources/calls_instance.json")
    resp.status_code = 204
    mock.return_value = resp

    uri = "%s/Calls/%s" % (BASE_URI, CALL_SID)
    r = list_resource.hangup(CALL_SID)
    exp_data = {"Status": "completed"}

    mock.assert_called_with("POST", uri, data=exp_data, auth=AUTH)
    assert_true(r)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_cancel(mock):
    resp = create_mock_json("tests/resources/calls_instance.json")
    resp.status_code = 204
    mock.return_value = resp

    uri = "%s/Calls/%s" % (BASE_URI, CALL_SID)
    r = list_resource.cancel(CALL_SID)
    exp_data = {"Status": "canceled"}

    mock.assert_called_with("POST", uri, data=exp_data, auth=AUTH)
    assert_true(r)


@raises(AttributeError)
def test_create():
    list_resource.delete

########NEW FILE########
__FILENAME__ = test_client
import unittest

from mock import patch, Mock, sentinel, ANY
from nose.tools import assert_equal, assert_true

from twilio.rest.resources.imports import json
from twilio.rest import TwilioRestClient, resources
from tools import create_mock_json

AUTH = ("ACCOUNT_SID", "AUTH_TOKEN")


class RestClientTest(unittest.TestCase):

    def setUp(self):
        self.client = TwilioRestClient("ACCOUNT_SID", "AUTH_TOKEN")

    @patch("twilio.rest.make_request")
    def test_request(self, mock):
        self.client.request("2010-04-01", method="GET")
        mock.assert_called_with("GET", "https://api.twilio.com/2010-04-01",
                                headers={"User-Agent": ANY,
                                         'Accept-Charset': 'utf-8'},
                                params={}, auth=AUTH, data=None)
        called_kwargs = mock.mock_calls[0][2]
        self.assertTrue(
            'twilio-python' in called_kwargs['headers']['User-Agent']
        )

    def test_connect_apps(self):
        assert_true(isinstance(self.client.connect_apps, resources.ConnectApps))

    def test_authorized_apps(self):
        assert_true(isinstance(self.client.authorized_connect_apps,
                    resources.AuthorizedConnectApps))

    @patch("twilio.rest.resources.base.make_request")
    def test_conferences(self, mock):
        mock.return_value = Mock()
        mock.return_value.ok = True
        mock.return_value.content = '{"conferences": []}'
        self.client.conferences.list()

    @patch("twilio.rest.resources.base.make_twilio_request")
    def test_members(self, mock):
        resp = create_mock_json("tests/resources/members_list.json")
        mock.return_value = resp
        self.client.members("QU123").list()
        uri = "https://api.twilio.com/2010-04-01/Accounts/ACCOUNT_SID/Queues/QU123/Members"
        mock.assert_called_with("GET", uri, params={}, auth=AUTH)


class RestClientTimeoutTest(unittest.TestCase):
    def setUp(self):
        self.client = TwilioRestClient("ACCOUNT_SID", "AUTH_TOKEN", timeout=sentinel.timeout)

    @patch("twilio.rest.resources.base.make_twilio_request")
    def test_members(self, mock_request):
        resp = create_mock_json("tests/resources/members_list.json")
        mock_request.return_value = resp
        self.client.members("QU123").list()
        mock_request.assert_called_with("GET", ANY, params=ANY, auth=AUTH, timeout=sentinel.timeout)

    @patch("twilio.rest.resources.base.make_twilio_request")
    def test_arbitrary_member(self, mock_request):
        mock_response = Mock()
        mock_response.ok = True
        mock_response.content = json.dumps({"short_codes": []})
        mock_request.return_value = mock_response
        assert_equal([], self.client.sms.short_codes.list())
        mock_request.assert_called_once_with("GET", ANY, params=ANY, auth=AUTH, timeout=sentinel.timeout)

########NEW FILE########
__FILENAME__ = test_conferences
from datetime import date
import unittest

from mock import Mock
from twilio.rest.resources import Conferences

DEFAULT = {
    'DateUpdated<': None,
    'DateUpdated>': None,
    'DateUpdated': None,
    'DateCreated<': None,
    'DateCreated>': None,
    'DateCreated': None,
}


class ConferenceTest(unittest.TestCase):

    def setUp(self):
        self.resource = Conferences("foo", ("sid", "token"))
        self.params = DEFAULT.copy()

    def test_list(self):
        self.resource.get_instances = Mock()
        self.resource.list()
        self.resource.get_instances.assert_called_with(self.params)

    def test_list_after(self):
        self.resource.get_instances = Mock()
        self.resource.list(created_after=date(2011, 1, 1))
        self.params["DateCreated>"] = "2011-01-01"
        self.resource.get_instances.assert_called_with(self.params)

    def test_list_on(self):
        self.resource.get_instances = Mock()
        self.resource.list(created=date(2011, 1, 1))
        self.params["DateCreated"] = "2011-01-01"
        self.resource.get_instances.assert_called_with(self.params)

    def test_list_before(self):
        self.resource.get_instances = Mock()
        self.resource.list(created_before=date(2011, 1, 1))
        self.params["DateCreated<"] = "2011-01-01"
        self.resource.get_instances.assert_called_with(self.params)

########NEW FILE########
__FILENAME__ = test_connect_apps
import unittest

from mock import Mock, patch

from twilio.rest.resources import ConnectApps


class ConnectAppTest(unittest.TestCase):

    def setUp(self):
        self.parent = Mock()
        self.uri = "/base"
        self.auth = ("AC123", "token")
        self.resource = ConnectApps(self.uri, self.auth)

    @patch("twilio.rest.resources.base.make_twilio_request")
    def test_get(self, mock):
        mock.return_value = Mock()
        mock.return_value.content = '{"sid": "SID"}'

        self.resource.get("SID")
        mock.assert_called_with("GET", "/base/ConnectApps/SID",
            auth=self.auth)

    @patch("twilio.rest.resources.base.make_twilio_request")
    def test_list_with_paging(self, mock):
        mock.return_value = Mock()
        mock.return_value.content = '{"connect_apps": []}'

        self.resource.list(page=1, page_size=50)
        mock.assert_called_with("GET", "/base/ConnectApps",
                params={"Page": 1, "PageSize": 50}, auth=self.auth)

    @patch("twilio.rest.resources.base.make_twilio_request")
    def test_list(self, mock):
        mock.return_value = Mock()
        mock.return_value.content = '{"connect_apps": []}'

        self.resource.list()
        mock.assert_called_with("GET", "/base/ConnectApps",
            params={}, auth=self.auth)

    def test_create(self):
        self.assertRaises(AttributeError, getattr, self.resource, 'create')

    def test_delete(self):
        self.assertRaises(AttributeError, getattr, self.resource, 'delete')

    def test_update(self):
        self.assertRaises(AttributeError, getattr, self.resource, 'update')

########NEW FILE########
__FILENAME__ = test_core
from datetime import datetime
from datetime import date

from nose.tools import assert_equal

from twilio.rest.resources import parse_date
from twilio.rest.resources import transform_params
from twilio.rest.resources import convert_keys
from twilio.rest.resources import convert_case
from twilio.rest.resources import convert_boolean
from twilio.rest.resources import normalize_dates


def test_date():
    d = date(2009, 10, 10)
    assert_equal(parse_date(d), "2009-10-10")


def test_datetime():
    d = datetime(2009, 10, 10)
    assert_equal(parse_date(d), "2009-10-10")


def test_string_date():
    d = "2009-10-10"
    assert_equal(parse_date(d), "2009-10-10")


def test_string_date_none():
    d = None
    assert_equal(parse_date(d), None)


def test_string_date_false():
    d = False
    assert_equal(parse_date(d), None)


def test_fparam():
    d = {"HEY": None, "YOU": 3}
    ed = {"YOU": 3}
    assert_equal(transform_params(d), ed)


def test_multi_param():
    d = {"Normal": 3, "Multiple": ["One", "Two"]}
    ed = {"Normal": 3, "Multiple": ["One", "Two"]}
    assert_equal(transform_params(d), ed)


def test_fparam_booleans():
    d = {"HEY": None, "YOU": 3, "Activated": False}
    ed = {"YOU": 3, "Activated": "false"}
    assert_equal(transform_params(d), ed)


def test_normalize_dates():

    @normalize_dates
    def foo(on=None, before=None, after=None):
        return {
            "on": on,
            "before": before,
            "after": after,
        }

    d = foo(on="2009-10-10", before=date(2009, 10, 10),
            after=datetime(2009, 10, 10))

    assert_equal(d["on"], "2009-10-10")
    assert_equal(d["after"], "2009-10-10")
    assert_equal(d["before"], "2009-10-10")


def test_convert_case():
    assert_equal(convert_case("from_"), "From")
    assert_equal(convert_case("to"), "To")
    assert_equal(convert_case("friendly_name"), "FriendlyName")


def test_convert_bool():
    assert_equal(convert_boolean(False), "false")
    assert_equal(convert_boolean(True), "true")
    assert_equal(convert_boolean(1), 1)


def test_convert_keys():
    d = {
        "from_": 0,
        "to": 0,
        "friendly_name": 0,
        "ended": 0,
    }

    ed = {
        "From": 0,
        "To": 0,
        "FriendlyName": 0,
        "EndTime": 0,
    }

    assert_equal(ed, convert_keys(d))

########NEW FILE########
__FILENAME__ = test_credentials
from nose.tools import assert_equal, assert_raises
from mock import patch

from twilio import TwilioException
from twilio.rest import TwilioRestClient, find_credentials


def test_creds_not_found():
    """ I shouldn't find credentials if they are not there """
    assert_equal(find_credentials({'foo': 'bar'}), (None, None))


def test_find_creds():
    """ I should find the credentials if they are there """
    env = {
        'TWILIO_ACCOUNT_SID': 'AC123',
        'foo': 'bar',
        'TWILIO_AUTH_TOKEN': '456',
    }
    assert_equal(find_credentials(env), ('AC123', '456'))


@patch("twilio.rest.find_credentials")
def test_creds_error(creds):
    creds.return_value = (None, None)
    assert_raises(TwilioException, TwilioRestClient)

########NEW FILE########
__FILENAME__ = test_jwt
import time
import unittest

from nose.tools import assert_true, assert_equal

from twilio import jwt
from twilio.util import TwilioCapability


class JwtTest(unittest.TestCase):

    def assertIn(self, foo, bar, msg=None):
        """backport for 2.6"""
        return assert_true(foo in bar, msg=(msg or "%s not found in %s"
            % (foo, bar)))

    def test_no_permissions(self):
        token = TwilioCapability("AC123", "XXXXX")
        payload = token.payload()
        assert_equal(len(payload), 1)
        assert_equal(payload["scope"], '')

    def test_inbound_permissions(self):
        token = TwilioCapability("AC123", "XXXXX")
        token.allow_client_incoming("andy")
        payload = token.payload()

        eurl = "scope:client:incoming?clientName=andy"
        assert_equal(len(payload), 1)
        assert_equal(payload['scope'], eurl)

    def test_outbound_permissions(self):
        token = TwilioCapability("AC123", "XXXXX")
        token.allow_client_outgoing("AP123")
        payload = token.payload()

        eurl = "scope:client:outgoing?appSid=AP123"

        assert_equal(len(payload), 1)
        self.assertIn(eurl, payload['scope'])

    def test_outbound_permissions_params(self):
        token = TwilioCapability("AC123", "XXXXX")
        token.allow_client_outgoing("AP123", foobar=3)
        payload = token.payload()

        eurl = "scope:client:outgoing?appParams=foobar%3D3&appSid=AP123"
        assert_equal(payload["scope"], eurl)

    def test_events(self):
        token = TwilioCapability("AC123", "XXXXX")
        token.allow_event_stream()
        payload = token.payload()

        event_uri = "scope:stream:subscribe?path=%2F2010-04-01%2FEvents"
        assert_equal(payload["scope"], event_uri)

    def test_events_with_filters(self):
        token = TwilioCapability("AC123", "XXXXX")
        token.allow_event_stream(foobar="hey")
        payload = token.payload()

        event_uri = "scope:stream:subscribe?params=foobar%3Dhey&path=%2F2010-04-01%2FEvents"
        assert_equal(payload["scope"], event_uri)

    def test_decode(self):
        token = TwilioCapability("AC123", "XXXXX")
        token.allow_client_outgoing("AP123", foobar=3)
        token.allow_client_incoming("andy")
        token.allow_event_stream()

        outgoing_uri = "scope:client:outgoing?appParams=foobar%3D3&appSid=AP123&clientName=andy"
        incoming_uri = "scope:client:incoming?clientName=andy"
        event_uri = "scope:stream:subscribe?path=%2F2010-04-01%2FEvents"

        result = jwt.decode(token.generate(), "XXXXX")
        scope = result["scope"].split(" ")

        self.assertIn(outgoing_uri, scope)
        self.assertIn(incoming_uri, scope)
        self.assertIn(event_uri, scope)

    def setUp(self):
        self.payload = {"iss": "jeff", "exp": int(time.time()), "claim": "insanity"}

    def test_encode_decode(self):
        secret = 'secret'
        jwt_message = jwt.encode(self.payload, secret)
        decoded_payload = jwt.decode(jwt_message, secret)
        self.assertEqual(decoded_payload, self.payload)

    def test_bad_secret(self):
        right_secret = 'foo'
        bad_secret = 'bar'
        jwt_message = jwt.encode(self.payload, right_secret)
        self.assertRaises(jwt.DecodeError, jwt.decode, jwt_message, bad_secret)

    def test_decodes_valid_jwt(self):
        example_payload = {"hello": "world"}
        example_secret = "secret"
        example_jwt = "eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJoZWxsbyI6ICJ3b3JsZCJ9.tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8"
        decoded_payload = jwt.decode(example_jwt, example_secret)
        self.assertEqual(decoded_payload, example_payload)

    def test_allow_skip_verification(self):
        right_secret = 'foo'
        jwt_message = jwt.encode(self.payload, right_secret)
        decoded_payload = jwt.decode(jwt_message, verify=False)
        self.assertEqual(decoded_payload, self.payload)

    def test_no_secret(self):
        right_secret = 'foo'
        jwt_message = jwt.encode(self.payload, right_secret)
        self.assertRaises(jwt.DecodeError, jwt.decode, jwt_message)

    def test_invalid_crypto_alg(self):
        self.assertRaises(NotImplementedError, jwt.encode, self.payload, "secret", "HS1024")

########NEW FILE########
__FILENAME__ = test_make_request
"""
Test that make+request is making correct HTTP requests

Uses the awesome httpbin.org to validate responses
"""
import platform

import twilio
from nose.tools import assert_equal, raises
from mock import patch, Mock, ANY
from twilio import TwilioRestException
from twilio.rest.resources.base import make_request, make_twilio_request
from twilio.rest.resources.connection import Connection
from twilio.rest.resources.connection import PROXY_TYPE_SOCKS5

get_headers = {
    "User-Agent": "twilio-python/{version} (Python {python_version})".format(
        version=twilio.__version__,
        python_version=platform.python_version(),
    ),
    "Accept-Charset": "utf-8",
    "Accept": "application/json",
}

post_headers = get_headers.copy()
post_headers["Content-Type"] = "application/x-www-form-urlencoded"


@patch('twilio.rest.resources.base.Response')
@patch('httplib2.Http')
def test_get_params(http_mock, response_mock):
    http = Mock()
    http.request.return_value = (Mock(), Mock())
    http_mock.return_value = http
    make_request("GET", "http://httpbin.org/get", params={"hey": "you"})
    http.request.assert_called_with("http://httpbin.org/get?hey=you", "GET",
                                    body=None, headers=None)


@patch('twilio.rest.resources.base.Response')
@patch('httplib2.Http')
def test_get_extra_params(http_mock, response_mock):
    http = Mock()
    http.request.return_value = (Mock(), Mock())
    http_mock.return_value = http
    make_request("GET", "http://httpbin.org/get?foo=bar", params={"hey": "you"})
    http.request.assert_called_with("http://httpbin.org/get?foo=bar&hey=you", "GET",
                                    body=None, headers=None)


@patch('twilio.rest.resources.base.Response')
@patch('httplib2.Http')
def test_resp_uri(http_mock, response_mock):
    http = Mock()
    http.request.return_value = (Mock(), Mock())
    http_mock.return_value = http
    make_request("GET", "http://httpbin.org/get")
    http.request.assert_called_with("http://httpbin.org/get", "GET",
                                    body=None, headers=None)


@patch('twilio.rest.resources.base.Response')
@patch('httplib2.Http')
def test_sequence_data(http_mock, response_mock):
    http = Mock()
    http.request.return_value = (Mock(), Mock())
    http_mock.return_value = http
    make_request(
        "POST",
        "http://httpbin.org/post",
        data={"a_list": ["here", "is", "some", "stuff"]},
    )
    http.request.assert_called_with(
        "http://httpbin.org/post",
        "POST",
        body="a_list=here&a_list=is&a_list=some&a_list=stuff",
        headers=None,
    )


@patch('twilio.rest.resources.base.make_request')
def test_make_twilio_request_headers(mock):
    url = "http://random/url"
    make_twilio_request("POST", url)
    mock.assert_called_with("POST", "http://random/url.json",
                            headers=post_headers)


@raises(TwilioRestException)
@patch('twilio.rest.resources.base.make_request')
def test_make_twilio_request_bad_data(mock):
    resp = Mock()
    resp.ok = False
    resp.return_value = "error"
    mock.return_value = resp

    url = "http://random/url"
    make_twilio_request("POST", url)
    mock.assert_called_with("POST", "http://random/url.json",
                            headers=post_headers)


@patch('twilio.rest.resources.base.Response')
@patch('httplib2.Http')
def test_proxy_info(http_mock, resp_mock):
    http = Mock()
    http.request.return_value = (Mock(), Mock())
    http_mock.return_value = http
    Connection.set_proxy_info(
        'example.com',
        8080,
        proxy_type=PROXY_TYPE_SOCKS5,
    )
    make_request("GET", "http://httpbin.org/get")
    http_mock.assert_called_with(timeout=None, ca_certs=ANY, proxy_info=ANY)
    http.request.assert_called_with("http://httpbin.org/get", "GET",
                                    body=None, headers=None)
    proxy_info = http_mock.call_args[1]['proxy_info']
    assert_equal(proxy_info.proxy_host, 'example.com')
    assert_equal(proxy_info.proxy_port, 8080)
    assert_equal(proxy_info.proxy_type, PROXY_TYPE_SOCKS5)

########NEW FILE########
__FILENAME__ = test_media
from datetime import date
import unittest

from mock import Mock
from nose.tools import assert_equal

from twilio.rest.resources import MediaList

DEFAULT = {
    'DateCreated<': None,
    'DateCreated>': None,
    'DateCreated': None,
}


class MediaTest(unittest.TestCase):

    def setUp(self):
        self.resource = MediaList("foo", ("sid", "token"))
        self.params = DEFAULT.copy()

    def test_list_on(self):
        self.resource.get_instances = Mock()
        self.resource.list(date_created=date(2011, 1, 1))
        self.params['DateCreated'] = "2011-01-01"
        self.resource.get_instances.assert_called_with(self.params)

    def test_list_after(self):
        self.resource.get_instances = Mock()
        self.resource.list(after=date(2011, 1, 1))
        self.params['DateCreated>'] = "2011-01-01"
        self.resource.get_instances.assert_called_with(self.params)

    def test_list_before(self):
        self.resource.get_instances = Mock()
        self.resource.list(before=date(2011, 1, 1))
        self.params['DateCreated<'] = "2011-01-01"
        self.resource.get_instances.assert_called_with(self.params)

    def test_call(self):
        base_uri = self.resource.base_uri
        message_media = self.resource('MM123')
        assert_equal(message_media.base_uri, "%s/Messages/%s" % (base_uri, 'MM123'))

########NEW FILE########
__FILENAME__ = test_members
from mock import patch
from tools import create_mock_json
from twilio.rest.resources import Members

QUEUE_SID = "QU1b9faddec3d54ec18488f86c83019bf0"
ACCOUNT_SID = "AC123"
AUTH = (ACCOUNT_SID, "token")
CALL_SID = "CAaaf2e9ded94aba3e57c42a3d55be6ff2"
BASE_URI = "https://api.twilio.com/2010-04-01/Accounts/AC123/Queues/%s" % (
    QUEUE_SID)
TWIML_URL = "example_twiml_url"

list_resource = Members(BASE_URI, AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_members_list(mock):
    resp = create_mock_json("tests/resources/members_list.json")
    mock.return_value = resp

    uri = "%s/Members" % (BASE_URI)
    list_resource.list()

    mock.assert_called_with("GET", uri, params={}, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_members_dequeue_front(mock):
    resp = create_mock_json("tests/resources/members_instance.json")
    mock.return_value = resp

    uri = "%s/Members/Front" % (BASE_URI)
    list_resource.dequeue(TWIML_URL)

    mock.assert_called_with("POST", uri, data={"Url": TWIML_URL}, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_members_dequeue_call(mock):
    resp = create_mock_json("tests/resources/members_instance.json")
    mock.return_value = resp

    uri = "%s/Members/%s" % (BASE_URI, CALL_SID)
    list_resource.dequeue(TWIML_URL, call_sid=CALL_SID)

    mock.assert_called_with("POST", uri, data={"Url": TWIML_URL}, auth=AUTH)

########NEW FILE########
__FILENAME__ = test_messages
from datetime import date
import unittest

from mock import Mock
from six import u

from twilio.rest.resources import Messages

DEFAULT = {
    'From': None,
    'DateSent<': None,
    'DateSent>': None,
    'DateSent': None,
}


class MessageTest(unittest.TestCase):

    def setUp(self):
        self.resource = Messages("foo", ("sid", "token"))
        self.params = DEFAULT.copy()

    def test_list_on(self):
        self.resource.get_instances = Mock()
        self.resource.list(date_sent=date(2011, 1, 1))
        self.params['DateSent'] = "2011-01-01"
        self.resource.get_instances.assert_called_with(self.params)

    def test_list_after(self):
        self.resource.get_instances = Mock()
        self.resource.list(after=date(2011, 1, 1))
        self.params['DateSent>'] = "2011-01-01"
        self.resource.get_instances.assert_called_with(self.params)

    def test_list_before(self):
        self.resource.get_instances = Mock()
        self.resource.list(before=date(2011, 1, 1))
        self.params['DateSent<'] = "2011-01-01"
        self.resource.get_instances.assert_called_with(self.params)

    def test_create(self):
        self.resource.create_instance = Mock()
        self.resource.create(
            from_='+14155551234',
            to='+14155556789',
            body=u('ahoy hoy'),
        )
        self.resource.create_instance.assert_called_with(
            {
                'from': '+14155551234',
                'to': '+14155556789',
                'body': u('ahoy hoy'),
            },
        )

########NEW FILE########
__FILENAME__ = test_notifications
from datetime import date
from mock import patch
from nose.tools import raises, assert_true
from twilio.rest.resources import Notifications
from tools import create_mock_json

BASE_URI = "https://api.twilio.com/2010-04-01/Accounts/AC123"
ACCOUNT_SID = "AC123"
AUTH = (ACCOUNT_SID, "token")

RE_SID = "RE19e96a31ed59a5733d2c1c1c69a83a28"

list_resource = Notifications(BASE_URI, AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_paging(mock):
    resp = create_mock_json("tests/resources/notifications_list.json")
    mock.return_value = resp

    uri = "%s/Notifications" % (BASE_URI)
    list_resource.list(before=date(2010, 12, 5))
    exp_params = {'MessageDate<': '2010-12-05'}

    mock.assert_called_with("GET", uri, params=exp_params, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_get(mock):
    resp = create_mock_json("tests/resources/notifications_instance.json")
    mock.return_value = resp

    uri = "%s/Notifications/%s" % (BASE_URI, RE_SID)
    list_resource.get(RE_SID)

    mock.assert_called_with("GET", uri, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_get2(mock):
    resp = create_mock_json("tests/resources/notifications_instance.json")
    resp.status_code = 204
    mock.return_value = resp

    uri = "%s/Notifications/%s" % (BASE_URI, RE_SID)
    r = list_resource.delete(RE_SID)

    mock.assert_called_with("DELETE", uri, auth=AUTH)
    assert_true(r)


@raises(AttributeError)
def test_create():
    list_resource.create


@raises(AttributeError)
def test_update():
    list_resource.update

########NEW FILE########
__FILENAME__ = test_phone_numbers
from __future__ import with_statement
import json
import unittest

from mock import Mock

from twilio.rest.resources import PhoneNumbers
from twilio.rest.resources import PhoneNumber


class PhoneNumberTest(unittest.TestCase):

    def setUp(self):
        self.parent = Mock()
        self.uri = "/base"
        self.auth = ("AC123", "token")

    def test_update_rename_status_callback_url(self):
        mock = Mock()
        mock.uri = "/base"
        instance = PhoneNumber(mock, "SID")
        instance.update(status_callback_url="http://www.example.com")
        mock.update.assert_called_with("SID", status_callback="http://www.example.com")

    def test_update_instance_rename_status_callback_url(self):
        resource = PhoneNumbers(self.uri, self.auth)
        resource.update_instance = Mock()
        resource.update("SID", status_callback_url="http://www.example.com")
        resource.update_instance.assert_called_with("SID", {"status_callback": "http://www.example.com"})

    def test_application_sid(self):
        resource = PhoneNumbers(self.uri, self.auth)
        resource.update_instance = Mock()
        resource.update("SID", application_sid="foo")
        resource.update_instance.assert_called_with(
                "SID", {"voice_application_sid": "foo", "sms_application_sid": "foo"})

    def test_voice_application_sid(self):
        resource = PhoneNumbers(self.uri, self.auth)
        resource.update_instance = Mock()
        resource.update("SID", voice_application_sid="foo")
        resource.update_instance.assert_called_with(
                "SID", {"voice_application_sid": "foo"})

    def test_sms_application_sid(self):
        resource = PhoneNumbers(self.uri, self.auth)
        resource.update_instance = Mock()
        resource.update("SID", sms_application_sid="foo")
        resource.update_instance.assert_called_with(
                "SID", {"sms_application_sid": "foo"})

    def test_status_callback_url(self):
        resource = PhoneNumbers(self.uri, self.auth)
        resource.update_instance = Mock()
        resource.update("SID", status_callback="foo")
        resource.update_instance.assert_called_with(
                "SID", {"status_callback": "foo"})

    def test_transfer(self):
        resource = PhoneNumbers(self.uri, self.auth)
        resource.update = Mock()
        resource.transfer("SID", "AC123")
        resource.update.assert_called_with("SID", account_sid="AC123")

    def test_instance_transfer(self):
        mock = Mock()
        mock.uri = "/base"
        instance = PhoneNumber(mock, "SID")
        instance.transfer("AC123")
        mock.transfer.assert_called_with("SID", "AC123")

    def test_base_uri(self):
        parent = Mock()
        parent.base_uri = ("https://api.twilio.com/2010-04-01/Accounts/"
            "AC123")
        resource = PhoneNumber(parent, "PNd2ae06cced59a5733d2c1c1c69a83a28")

        with open("tests/resources/incoming_phone_numbers_instance.json") as f:
            entry = json.load(f)
            resource.load(entry)

        self.assertEquals(resource.parent.base_uri,
            ("https://api.twilio.com/2010-04-01/Accounts/AC4bf2dafbed59a573"
             "3d2c1c1c69a83a28"))

    def test_purchase_type(self):

        types = {'local': 'Local', 'mobile': 'Mobile', 'tollfree': 'TollFree'}
        for type in ('local', 'mobile', 'tollfree'):
            resource = PhoneNumbers(self.uri, self.auth)
            resource.request = Mock()
            resource.request.return_value = (None, None)
            resource.load_instance = Mock()
            resource.purchase(type=type, phone_number='888')
            resource.request.assert_called_with('POST', self.uri + '/IncomingPhoneNumbers/' + types[type],
                                                data={'PhoneNumber': '888'})


class IncomingPhoneNumbersTest(unittest.TestCase):

    def setUp(self):
        self.resource = PhoneNumbers("http://api.twilio.com",
                                     ("user", "pass"))

    def test_mobile(self):
        request = Mock()
        request.return_value = (Mock(), {"incoming_phone_numbers": []})
        self.resource.request = request
        self.resource.list(type='mobile')

        uri = "http://api.twilio.com/IncomingPhoneNumbers/Mobile"
        request.assert_called_with("GET", uri, params={})

    def test_local(self):
        request = Mock()
        request.return_value = (Mock(), {"incoming_phone_numbers": []})
        self.resource.request = request
        self.resource.list(type='local')

        uri = "http://api.twilio.com/IncomingPhoneNumbers/Local"
        request.assert_called_with("GET", uri, params={})

    def test_toll_free(self):
        request = Mock()
        request.return_value = (Mock(), {"incoming_phone_numbers": []})
        self.resource.request = request
        self.resource.list(type='tollfree')

        uri = "http://api.twilio.com/IncomingPhoneNumbers/TollFree"
        request.assert_called_with("GET", uri, params={})

########NEW FILE########
__FILENAME__ = test_queues
from mock import patch
from tools import create_mock_json
from twilio.rest.resources import Queues, Queue

BASE_URI = "https://api.twilio.com/2010-04-01/Accounts/AC123"
ACCOUNT_SID = "AC123"
AUTH = (ACCOUNT_SID, "token")
QUEUE_SID = "QU1b9faddec3d54ec18488f86c83019bf0"
CALL_SID = "CAaaf2e9ded94aba3e57c42a3d55be6ff2"

list_resource = Queues(BASE_URI, AUTH)
instance_resource = Queue(list_resource, QUEUE_SID)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_queues_list(mock):
    resp = create_mock_json("tests/resources/queues_list.json")
    mock.return_value = resp

    uri = "%s/Queues" % (BASE_URI)
    list_resource.list()

    mock.assert_called_with("GET", uri, params={}, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_queues_create(mock):
    resp = create_mock_json("tests/resources/queues_instance.json")
    resp.status_code = 201
    mock.return_value = resp

    uri = "%s/Queues" % (BASE_URI)
    list_resource.create('test', max_size=9001)

    mock.assert_called_with("POST", uri,
                            data={'FriendlyName': 'test', 'MaxSize': 9001},
                            auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_queues_get(mock):
    resp = create_mock_json("tests/resources/queues_instance.json")
    mock.return_value = resp

    uri = "%s/Queues/%s" % (BASE_URI, QUEUE_SID)
    list_resource.get(QUEUE_SID)
    mock.assert_called_with("GET", uri, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_queue_update(mock):
    resp = create_mock_json("tests/resources/queues_instance.json")
    mock.return_value = resp

    uri = "%s/Queues/%s" % (BASE_URI, QUEUE_SID)
    instance_resource.update(friendly_name='QQ')

    mock.assert_called_with("POST", uri,
        data={'FriendlyName': 'QQ'}, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_queue_delete(mock):
    resp = create_mock_json("tests/resources/queues_instance.json")
    mock.return_value = resp

    uri = "%s/Queues/%s" % (BASE_URI, QUEUE_SID)
    instance_resource.delete()

    mock.assert_called_with("DELETE", uri, auth=AUTH)

########NEW FILE########
__FILENAME__ = test_recordings
from datetime import date
from mock import patch
from nose.tools import raises, assert_equals, assert_true

from tools import create_mock_json
from twilio.rest.resources import Recordings, Recording

BASE_URI = "https://api.twilio.com/2010-04-01/Accounts/AC123"
ACCOUNT_SID = "AC123"
AUTH = (ACCOUNT_SID, "token")

RE_SID = "RE19e96a31ed59a5733d2c1c1c69a83a28"

recordings = Recordings(BASE_URI, AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_paging(mock):
    resp = create_mock_json("tests/resources/recordings_list.json")
    mock.return_value = resp

    uri = "%s/Recordings" % (BASE_URI)
    recordings.list(call_sid="CA123", before=date(2010, 12, 5))
    exp_params = {'CallSid': 'CA123', 'DateCreated<': '2010-12-05'}

    mock.assert_called_with("GET", uri, params=exp_params, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_get(mock):
    resp = create_mock_json("tests/resources/recordings_instance.json")
    mock.return_value = resp

    uri = "%s/Recordings/%s" % (BASE_URI, RE_SID)
    r = recordings.get(RE_SID)

    mock.assert_called_with("GET", uri, auth=AUTH)

    truri = "%s/Recordings/%s/Transcriptions" % (BASE_URI, RE_SID)
    assert_equals(r.transcriptions.uri, truri)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_delete_list(mock):
    resp = create_mock_json("tests/resources/recordings_instance.json")
    resp.status_code = 204
    mock.return_value = resp

    uri = "%s/Recordings/%s" % (BASE_URI, RE_SID)
    r = recordings.delete(RE_SID)

    mock.assert_called_with("DELETE", uri, auth=AUTH)
    assert_true(r)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_delete_instance(mock):
    resp = create_mock_json("tests/resources/recordings_instance.json")
    resp.status_code = 204
    mock.return_value = resp

    uri = "%s/Recordings/%s" % (BASE_URI, RE_SID)
    rec = Recording(recordings, RE_SID)
    r = rec.delete()

    mock.assert_called_with("DELETE", uri, auth=AUTH)
    assert_true(r)


@raises(AttributeError)
def test_create():
    recordings.create


@raises(AttributeError)
def test_update():
    recordings.update

########NEW FILE########
__FILENAME__ = test_sms_messages
from datetime import date
import unittest

from mock import Mock

from twilio.rest.resources import SmsMessages

DEFAULT = {
    'From': None,
    'DateSent<': None,
    'DateSent>': None,
    'DateSent': None,
}


class SmsTest(unittest.TestCase):

    def setUp(self):
        self.resource = SmsMessages("foo", ("sid", "token"))
        self.params = DEFAULT.copy()

    def test_list_on(self):
        self.resource.get_instances = Mock()
        self.resource.list(date_sent=date(2011, 1, 1))
        self.params['DateSent'] = "2011-01-01"
        self.resource.get_instances.assert_called_with(self.params)

    def test_list_after(self):
        self.resource.get_instances = Mock()
        self.resource.list(after=date(2011, 1, 1))
        self.params['DateSent>'] = "2011-01-01"
        self.resource.get_instances.assert_called_with(self.params)

    def test_list_before(self):
        self.resource.get_instances = Mock()
        self.resource.list(before=date(2011, 1, 1))
        self.params['DateSent<'] = "2011-01-01"
        self.resource.get_instances.assert_called_with(self.params)

########NEW FILE########
__FILENAME__ = test_transcriptions
from mock import patch, Mock
from nose.tools import raises
from twilio.rest.resources import Transcriptions, Transcription
from tools import create_mock_json

BASE_URI = "https://api.twilio.com/2010-04-01/Accounts/AC123"
ACCOUNT_SID = "AC123"
AUTH = (ACCOUNT_SID, "token")

transcriptions = Transcriptions(BASE_URI, AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_paging(mock):
    resp = create_mock_json("tests/resources/transcriptions_list.json")
    mock.return_value = resp

    uri = "%s/Transcriptions" % (BASE_URI)
    transcriptions.list(page=2)

    mock.assert_called_with("GET", uri, params={"Page": 2}, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_get(mock):
    resp = create_mock_json("tests/resources/transcriptions_instance.json")
    mock.return_value = resp

    uri = "%s/Transcriptions/TR123" % (BASE_URI)
    transcriptions.get("TR123")

    mock.assert_called_with("GET", uri, auth=AUTH)


@patch("twilio.rest.resources.base.Resource.request")
def test_delete_transcription(req):
    """ Deleting a transcription should work """
    resp = Mock()
    resp.content = ""
    resp.status_code = 204
    req.return_value = resp, {}

    app = Transcription(transcriptions, "TR123")
    app.delete()
    uri = "https://api.twilio.com/2010-04-01/Accounts/AC123/Transcriptions/TR123"
    req.assert_called_with("DELETE", uri)


@raises(AttributeError)
def test_create():
    transcriptions.create


@raises(AttributeError)
def test_update():
    transcriptions.update

########NEW FILE########
__FILENAME__ = test_twiml
# -*- coding: utf-8 -*-
from __future__ import with_statement
import unittest
import xml.etree.ElementTree as ET

from nose.tools import assert_equal
from six import u, text_type

from twilio import twiml
from twilio.twiml import TwimlException
from twilio.twiml import Response


class TwilioTest(unittest.TestCase):
    def strip(self, xml):
        return text_type(xml)

    def improperAppend(self, verb):
        self.assertRaises(TwimlException, verb.append, twiml.Say(""))
        self.assertRaises(TwimlException, verb.append, twiml.Gather())
        self.assertRaises(TwimlException, verb.append, twiml.Play(""))
        self.assertRaises(TwimlException, verb.append, twiml.Record())
        self.assertRaises(TwimlException, verb.append, twiml.Hangup())
        self.assertRaises(TwimlException, verb.append, twiml.Reject())
        self.assertRaises(TwimlException, verb.append, twiml.Redirect())
        self.assertRaises(TwimlException, verb.append, twiml.Dial())
        self.assertRaises(TwimlException, verb.append, twiml.Enqueue(""))
        self.assertRaises(TwimlException, verb.append, twiml.Queue(""))
        self.assertRaises(TwimlException, verb.append, twiml.Leave())
        self.assertRaises(TwimlException, verb.append, twiml.Conference(""))
        self.assertRaises(TwimlException, verb.append, twiml.Client(""))
        self.assertRaises(TwimlException, verb.append, twiml.Sms(""))
        self.assertRaises(TwimlException, verb.append, twiml.Pause())


class TestResponse(TwilioTest):

    def testEmptyResponse(self):
        r = Response()
        assert_equal(self.strip(r), '<?xml version="1.0" encoding="UTF-8"?><Response />')

    def testResponseAddAttribute(self):
        r = Response(foo="bar")
        assert_equal(self.strip(r), '<?xml version="1.0" encoding="UTF-8"?><Response foo="bar" />')


class TestSay(TwilioTest):

    def testEmptySay(self):
        """ should be a say with no text """
        r = Response()
        r.append(twiml.Say(""))
        assert_equal(self.strip(r), '<?xml version="1.0" encoding="UTF-8"?><Response><Say /></Response>')

    def testSayHelloWorld(self):
        """ should say hello monkey """
        r = Response()
        r.append(twiml.Say("Hello World"))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Say>Hello World</Say></Response>')

    def testSayFrench(self):
        """ should say hello monkey """
        r = Response()
        r.append(twiml.Say(u("n\xe9cessaire et d'autres")))  # it works on python 2.6 with the from __future__ import unicode_literal
        assert_equal(text_type(r),
                     '<?xml version="1.0" encoding="UTF-8"?><Response><Say>n&#233;cessaire et d\'autres</Say></Response>')

    def testSayLoop(self):
        """ should say hello monkey and loop 3 times """
        r = Response()
        r.append(twiml.Say("Hello Monkey", loop=3))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Say loop="3">Hello Monkey</Say></Response>')

    def testSayLoopGreatBritian(self):
        """ should say have a woman say hello monkey and loop 3 times """
        r = Response()
        r.append(twiml.Say("Hello Monkey", language="en-gb"))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Say language="en-gb">Hello Monkey</Say></Response>')

    def testSayLoopWoman(self):
        """ should say have a woman say hello monkey and loop 3 times """
        r = Response()
        r.append(twiml.Say("Hello Monkey", loop=3, voice=twiml.Say.WOMAN))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Say loop="3" voice="woman">Hello Monkey</Say></Response>')

    def testSayConvienceMethod(self):
        """ convenience method: should say have a woman say hello monkey and loop 3 times and be in french """
        r = Response()
        r.addSay("Hello Monkey", loop=3, voice=twiml.Say.MAN, language=twiml.Say.FRENCH)
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Say language="fr" loop="3" voice="man">Hello Monkey</Say></Response>')

    def testSayAddAttribute(self):
        """ add attribute """
        r = twiml.Say("", foo="bar")
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Say foo="bar" />')

    def testSayBadAppend(self):
        """ should raise exceptions for wrong appending """
        self.improperAppend(twiml.Say(""))


class TestPlay(TwilioTest):

    def testEmptyPlay(self):
        """ should play hello monkey """
        r = Response()
        r.append(twiml.Play(""))
        r = self.strip(r)
        self.assertEqual(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Play /></Response>')

    def testPlayHello(self):
        """ should play hello monkey """
        r = Response()
        r.append(twiml.Play("http://hellomonkey.mp3"))
        r = self.strip(r)
        self.assertEqual(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Play>http://hellomonkey.mp3</Play></Response>')

    def testPlayHelloLoop(self):
        """ should play hello monkey loop """
        r = Response()
        r.append(twiml.Play("http://hellomonkey.mp3", loop=3))
        r = self.strip(r)
        self.assertEqual(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Play loop="3">http://hellomonkey.mp3</Play></Response>')

    def testPlayConvienceMethod(self):
        """ convenience method: should play hello monkey """
        r = Response()
        r.addPlay("http://hellomonkey.mp3", loop=3)
        r = self.strip(r)
        self.assertEqual(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Play loop="3">http://hellomonkey.mp3</Play></Response>')

    def testPlayAddAttribute(self):
        """ add attribute """
        r = twiml.Play("", foo="bar")
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Play foo="bar" />')

    def testPlayBadAppend(self):
        """ should raise exceptions for wrong appending """
        self.improperAppend(twiml.Play(""))

    def testPlayDigits(self):
        """ should play digits """
        r = Response()
        r.append(twiml.Play(digits='w123'))
        r = self.strip(r)
        self.assertEqual(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Play digits="w123" /></Response>')

    def testUrlOrDigitsRequired(self):
        self.assertRaises(TwimlException, twiml.Play)


class TestRecord(TwilioTest):

    def testRecordEmpty(self):
        """ should record """
        r = Response()
        r.append(twiml.Record())
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Record /></Response>')

    def testRecordActionMethod(self):
        """ should record with an action and a get method """
        r = Response()
        r.append(twiml.Record(action="example.com", method="GET"))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Record action="example.com" method="GET" /></Response>')

    def testRecordMaxlengthFinishTimeout(self):
        """ should record with an maxlength, finishonkey, and timeout """
        r = Response()
        r.append(twiml.Record(timeout=4, finishOnKey="#", maxLength=30))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Record finishOnKey="#" maxLength="30" timeout="4" /></Response>')

    def testRecordTranscribeCallback(self):
        """ should record with a transcribe and transcribeCallback """
        r = Response()
        r.append(twiml.Record(transcribeCallback="example.com"))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Record transcribeCallback="example.com" /></Response>')

    def testRecordAddAttribute(self):
        """ add attribute """
        r = twiml.Record(foo="bar")
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Record foo="bar" />')

    def testRecordBadAppend(self):
        """ should raise exceptions for wrong appending """
        self.improperAppend(twiml.Record())


class TestRedirect(TwilioTest):

    def testRedirectEmpty(self):
        r = Response()
        r.append(twiml.Redirect())
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Redirect /></Response>')

    def testRedirectMethod(self):
        r = Response()
        r.append(twiml.Redirect(url="example.com", method="POST"))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Redirect method="POST">example.com</Redirect></Response>')

    def testRedirectMethodGetParams(self):
        r = Response()
        r.append(twiml.Redirect(url="example.com?id=34&action=hey", method="POST"))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Redirect method="POST">example.com?id=34&amp;action=hey</Redirect></Response>')

    def testAddAttribute(self):
        """ add attribute """
        r = twiml.Redirect("", foo="bar")
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Redirect foo="bar" />')

    def testBadAppend(self):
        """ should raise exceptions for wrong appending """
        self.improperAppend(twiml.Redirect())


class TestHangup(TwilioTest):

    def testHangup(self):
        """ convenience: should Hangup to a url via POST """
        r = Response()
        r.append(twiml.Hangup())
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Hangup /></Response>')

    def testHangupConvience(self):
        """ should raises exceptions for wrong appending """
        r = Response()
        r.addHangup()
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Hangup /></Response>')

    def testBadAppend(self):
        """ should raise exceptions for wrong appending """
        self.improperAppend(twiml.Hangup())


class TestLeave(TwilioTest):

    def testLeave(self):
        """ convenience: should Hangup to a url via POST """
        r = Response()
        r.append(twiml.Leave())
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Leave /></Response>')

    def testBadAppend(self):
        """ should raise exceptions for wrong appending """
        self.improperAppend(twiml.Leave())


class TestReject(TwilioTest):

    def testReject(self):
        """ should be a Reject with default reason """
        r = Response()
        r.append(twiml.Reject())
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Reject /></Response>')

    def testRejectConvenience(self):
        """ should be a Reject with reason Busy """
        r = Response()
        r.addReject(reason='busy')
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Reject reason="busy" /></Response>')

    def testBadAppend(self):
        """ should raise exceptions for wrong appending """
        self.improperAppend(twiml.Reject())


class TestSms(TwilioTest):

    def testEmpty(self):
        """ Test empty sms verb """
        r = Response()
        r.append(twiml.Sms(""))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Sms /></Response>')

    def testBody(self):
        """ Test hello world """
        r = Response()
        r.append(twiml.Sms("Hello, World"))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Sms>Hello, World</Sms></Response>')

    def testToFromAction(self):
        """ Test the to, from, and status callback """
        r = Response()
        r.append(twiml.Sms("Hello, World", to=1231231234, sender=3453453456,
            statusCallback="example.com?id=34&action=hey"))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Sms from="3453453456" statusCallback="example.com?id=34&amp;action=hey" to="1231231234">Hello, World</Sms></Response>')

    def testActionMethod(self):
        """ Test the action and method parameters on Sms """
        r = Response()
        r.append(twiml.Sms("Hello", method="POST", action="example.com?id=34&action=hey"))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Sms action="example.com?id=34&amp;action=hey" method="POST">Hello</Sms></Response>')

    def testConvience(self):
        """ should raises exceptions for wrong appending """
        r = Response()
        r.addSms("Hello")
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Sms>Hello</Sms></Response>')

    def testBadAppend(self):
        """ should raise exceptions for wrong appending """
        self.improperAppend(twiml.Sms("Hello"))


class TestConference(TwilioTest):

    def setUp(self):
        r = Response()
        with r.dial() as dial:
            dial.conference("TestConferenceAttributes", beep=False, waitUrl="",
                startConferenceOnEnter=True, endConferenceOnExit=True)
        xml = r.toxml()

        #parse twiml XML string with Element Tree and inspect structure
        tree = ET.fromstring(xml)
        self.conf = tree.find(".//Conference")

    def test_conf_text(self):
        self.assertEqual(self.conf.text.strip(), "TestConferenceAttributes")

    def test_conf_beep(self):
        self.assertEqual(self.conf.get('beep'), "false")

    def test_conf_waiturl(self):
        self.assertEqual(self.conf.get('waitUrl'), "")

    def test_conf_start_conference(self):
        self.assertEqual(self.conf.get('startConferenceOnEnter'), "true")

    def test_conf_end_conference(self):
        self.assertEqual(self.conf.get('endConferenceOnExit'), "true")


class TestQueue(TwilioTest):

    def setUp(self):
        r = Response()
        with r.dial() as dial:
            dial.queue("TestQueueAttribute", url="", method='GET')
            xml = r.toxml()

        #parse twiml XML string with Element Tree and inspect
            #structure
            tree = ET.fromstring(xml)
            self.conf = tree.find(".//Queue")

    def test_conf_text(self):
        self.assertEqual(self.conf.text.strip(), "TestQueueAttribute")

    def test_conf_waiturl(self):
        self.assertEqual(self.conf.get('url'), "")

    def test_conf_method(self):
        self.assertEqual(self.conf.get('method'), "GET")


class TestEnqueue(TwilioTest):

    def setUp(self):
        r = Response()
        r.enqueue("TestEnqueueAttribute", action="act", method='GET',
                  waitUrl='wait', waitUrlMethod='POST')
        xml = r.toxml()

        #parse twiml XML string with Element Tree and inspect
        #structure
        tree = ET.fromstring(xml)
        self.conf = tree.find("./Enqueue")

    def test_conf_text(self):
        self.assertEqual(self.conf.text.strip(), "TestEnqueueAttribute")

    def test_conf_waiturl(self):
        self.assertEqual(self.conf.get('waitUrl'), "wait")

    def test_conf_method(self):
        self.assertEqual(self.conf.get('method'), "GET")

    def test_conf_action(self):
        self.assertEqual(self.conf.get('action'), "act")

    def test_conf_waitmethod(self):
        self.assertEqual(self.conf.get('waitUrlMethod'), "POST")


class TestDial(TwilioTest):

    def testDial(self):
        """ should redirect the call """
        r = Response()
        r.append(twiml.Dial("1231231234"))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Dial>1231231234</Dial></Response>')

    def testSip(self):
        """ should redirect the call """
        r = Response()
        d = r.dial()
        d.sip('foo@example.com')
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Dial><Sip>foo@example.com</Sip></Dial></Response>')

    def testSipUsernamePass(self):
        """ should redirect the call """
        r = Response()
        d = r.dial()
        d.sip('foo@example.com', username='foo', password='bar')
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Dial><Sip password="bar" username="foo">foo@example.com</Sip></Dial></Response>')

    def testSipUri(self):
        """ should redirect the call """
        r = Response()
        d = r.dial()
        s = d.sip()
        s.uri('foo@example.com')
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Dial><Sip><Uri>foo@example.com</Uri></Sip></Dial></Response>')

    def testConvienceMethod(self):
        """ should dial to a url via post """
        r = Response()
        r.addDial()
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Dial /></Response>')

    def testAddNumber(self):
        """ add a number to a dial """
        r = Response()
        d = twiml.Dial()
        d.append(twiml.Number("1231231234"))
        r.append(d)
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Dial><Number>1231231234</Number></Dial></Response>')

    def testAddNumberConvience(self):
        """ add a number to a dial, convience method """
        r = Response()
        d = r.addDial()
        d.addNumber("1231231234")
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Dial><Number>1231231234</Number></Dial></Response>')

    def testAddConference(self):
        """ add a conference to a dial """
        r = Response()
        d = twiml.Dial()
        d.append(twiml.Conference("My Room"))
        r.append(d)
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Dial><Conference>My Room</Conference></Dial></Response>')

    def test_add_queue(self):
        """ add a queue to a dial """
        r = Response()
        d = r.dial()
        d.append(twiml.Queue("The Cute Queue"))
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Dial><Queue>The Cute Queue</Queue></Dial></Response>')

    def test_add_empty_client(self):
        """ add an empty client to a dial """
        r = Response()
        d = r.dial()
        d.client("")
        assert_equal(str(r), '<?xml version="1.0" encoding="UTF-8"?><Response><Dial><Client /></Dial></Response>')

    def test_add_client(self):
        """ add a client to a dial """
        r = Response()
        d = r.dial()
        d.client("alice")
        assert_equal(str(r), '<?xml version="1.0" encoding="UTF-8"?><Response><Dial><Client>alice</Client></Dial></Response>')

    def testAddConferenceConvenceMethod(self):
        """ add a conference to a dial, conviently """
        r = Response()
        d = r.addDial()
        d.addConference("My Room")
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Dial><Conference>My Room</Conference></Dial></Response>')

    def testAddAttribute(self):
        """ add attribute """
        r = twiml.Conference("MyRoom", foo="bar")
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Conference foo="bar">MyRoom</Conference>')

    def testBadAppend(self):
        """ should raise exceptions for wrong appending """
        self.improperAppend(twiml.Conference("Hello"))


class TestGather(TwilioTest):

    def testEmpty(self):
        """ a gather with nothing inside """
        r = Response()
        r.append(twiml.Gather())
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Gather /></Response>')

    def test_context_manager(self):
        with Response() as r:
            with r.gather() as g:
                g.say("Hello")

            assert_equal(str(r), '<?xml version="1.0" encoding="UTF-8"?><Response><Gather><Say>Hello</Say></Gather></Response>')

    def testNestedSayPlayPause(self):
        """ a gather with a say, play, and pause """
        r = Response()
        g = twiml.Gather()
        g.append(twiml.Say("Hey"))
        g.append(twiml.Play("hey.mp3"))
        g.append(twiml.Pause())
        r.append(g)
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Gather><Say>Hey</Say><Play>hey.mp3</Play><Pause /></Gather></Response>')

    def testNestedSayPlayPauseConvience(self):
        """ a gather with a say, play, and pause """
        r = Response()
        g = r.addGather()
        g.addSay("Hey")
        g.addPlay("hey.mp3")
        g.addPause()
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Response><Gather><Say>Hey</Say><Play>hey.mp3</Play><Pause /></Gather></Response>')

    def testAddAttribute(self):
        """ add attribute """
        r = twiml.Gather(foo="bar")
        r = self.strip(r)
        assert_equal(r, '<?xml version="1.0" encoding="UTF-8"?><Gather foo="bar" />')

    def testNoDeclaration(self):
        """ add attribute """
        r = twiml.Gather(foo="bar")
        assert_equal(r.toxml(xml_declaration=False), '<Gather foo="bar" />')

    def testImproperNesting(self):
        """ bad nesting """
        verb = twiml.Gather()
        self.assertRaises(TwimlException, verb.append, twiml.Gather())
        self.assertRaises(TwimlException, verb.append, twiml.Record())
        self.assertRaises(TwimlException, verb.append, twiml.Hangup())
        self.assertRaises(TwimlException, verb.append, twiml.Redirect())
        self.assertRaises(TwimlException, verb.append, twiml.Dial())
        self.assertRaises(TwimlException, verb.append, twiml.Conference(""))
        self.assertRaises(TwimlException, verb.append, twiml.Sms(""))

########NEW FILE########
__FILENAME__ = test_unicode
# -*- coding: utf-8 -*-
from mock import patch, Mock
from six import u
from twilio.rest import resources


@patch("httplib2.Http")
@patch("twilio.rest.resources.base.Response")
def test_ascii_encode(resp_mock, mock):
    http = mock.return_value
    http.request.return_value = (Mock(), Mock())

    data = {
        "body": "HeyHey".encode('utf-8')
    }

    resources.make_request("GET", "http://www.example.com", data=data)

    http.request.assert_called_with("http://www.example.com", "GET",
                                    headers=None, body="body=HeyHey")


@patch("httplib2.Http")
@patch("twilio.rest.resources.base.Response")
def test_ascii(resp_mock, mock):
    http = mock.return_value
    http.request.return_value = (Mock(), Mock())

    data = {
        "body": "HeyHey"
    }

    resources.make_request("GET", "http://www.example.com", data=data)

    http.request.assert_called_with("http://www.example.com", "GET",
                                    headers=None, body="body=HeyHey")


@patch("httplib2.Http")
@patch("twilio.rest.resources.base.Response")
def test_double_encoding(resp_mock, mock):
    http = mock.return_value
    http.request.return_value = (Mock(), Mock())

    body = u('Chlo\xe9\xf1')

    data = {
        "body": body.encode('utf-8'),
    }

    resources.make_request("GET", "http://www.example.com", data=data)

    http.request.assert_called_with("http://www.example.com", "GET",
                                    headers=None, body="body=Chlo%C3%A9%C3%B1")


@patch("httplib2.Http")
@patch("twilio.rest.resources.base.Response")
def test_paging(resp_mock, mock):
    http = mock.return_value
    http.request.return_value = (Mock(), Mock())

    data = {
        "body": u('Chlo\xe9\xf1'),
    }

    resources.make_request("GET", "http://www.example.com", data=data)

    http.request.assert_called_with("http://www.example.com", "GET",
                                    headers=None, body="body=Chlo%C3%A9%C3%B1")


@patch("httplib2.Http")
@patch("twilio.rest.resources.base.Response")
def test_unicode_sequence_form_value(resp_mock, mock):
    http = mock.return_value
    http.request.return_value = (Mock(), Mock())

    data = {
        "body": [u('\xe5'), u('\xe7')],
    }

    resources.make_request("POST", "http://www.example.com", data=data)

    http.request.assert_called_with(
        "http://www.example.com",
        "POST",
        headers=None,
        body="body=%C3%A5&body=%C3%A7",
    )

########NEW FILE########
__FILENAME__ = test_usage
from mock import patch, Mock
from nose.tools import raises

from tools import create_mock_json
from twilio.rest.resources import Usage
from twilio.rest.resources.usage import UsageTriggers, UsageTrigger

BASE_URI = "https://api.twilio.com/2010-04-01/Accounts/AC123"
ACCOUNT_SID = "AC123"
AUTH = (ACCOUNT_SID, "token")

usage = Usage(BASE_URI, AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_triggers_create(request):
    resp = create_mock_json("tests/resources/usage_triggers_instance.json")
    resp.status_code = 201
    request.return_value = resp

    usage.triggers.create(
        friendly_name="foo",
        usage_category="sms",
        trigger_by="count",
        recurring="price",
        trigger_value="10.00",
        callback_url="http://www.example.com",
        callback_method="POST"
    )

    uri = "%s/Usage/Triggers" % BASE_URI
    request.assert_called_with("POST", uri, data={
        "FriendlyName": "foo",
        "UsageCategory": "sms",
        "TriggerBy": "count",
        "Recurring": "price",
        "TriggerValue": "10.00",
        "CallbackUrl": "http://www.example.com",
        "CallbackMethod": "POST"
    }, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_triggers_paging(request):
    resp = create_mock_json("tests/resources/usage_triggers_list.json")
    request.return_value = resp

    uri = "%s/Usage/Triggers" % BASE_URI
    usage.triggers.list(
        recurring="daily",
        usage_category="sms",
        trigger_by="count")

    request.assert_called_with("GET", uri, params={
        "Recurring": "daily",
        "UsageCategory": "sms",
        "TriggerBy": "count"
    }, auth=AUTH)


@patch("twilio.rest.resources.base.make_twilio_request")
def test_records_paging(request):
    resp = create_mock_json("tests/resources/usage_records_list.json")
    request.return_value = resp

    uri = "%s/Usage/Records" % BASE_URI
    usage.records.list(
        start_date="2012-10-12",
        end_date="2012-10-13",
        category="sms")

    request.assert_called_with("GET", uri, params={
        "StartDate": "2012-10-12",
        "EndDate": "2012-10-13",
        "Category": "sms"
    }, auth=AUTH)


@patch("twilio.rest.resources.base.Resource.request")
def test_delete_trigger(req):
    resp = Mock()
    resp.content = ""
    resp.status_code = 204
    req.return_value = resp, {}

    triggers = UsageTriggers("https://api.twilio.com", None)
    trigger = UsageTrigger(triggers, "UT123")
    trigger.delete()
    uri = "https://api.twilio.com/Usage/Triggers/UT123"
    req.assert_called_with("DELETE", uri)


@raises(AttributeError)
def test_records_create():
    usage.records.all.create


@raises(AttributeError)
def test_records_delete():
    usage.records.all.delete


@raises(AttributeError)
def test_records_get():
    usage.records.all.get('abc')

########NEW FILE########
__FILENAME__ = test_validation
# -*- coding: utf-8 -*-
import unittest

from nose.tools import assert_equal, assert_true
from six import b

from twilio.util import RequestValidator


class ValidationTest(unittest.TestCase):

    def test_validation(self):
        token = "1c892n40nd03kdnc0112slzkl3091j20"
        validator = RequestValidator(token)

        uri = "http://www.postbin.org/1ed898x"
        params = {
            "AccountSid": "AC9a9f9392lad99kla0sklakjs90j092j3",
            "ApiVersion": "2010-04-01",
            "CallSid": "CAd800bb12c0426a7ea4230e492fef2a4f",
            "CallStatus": "ringing",
            "Called": "+15306384866",
            "CalledCity": "OAKLAND",
            "CalledCountry": "US",
            "CalledState": "CA",
            "CalledZip": "94612",
            "Caller": "+15306666666",
            "CallerCity": "SOUTH LAKE TAHOE",
            "CallerCountry": "US",
            "CallerName": "CA Wireless Call",
            "CallerState": "CA",
            "CallerZip": "89449",
            "Direction": "inbound",
            "From": "+15306666666",
            "FromCity": "SOUTH LAKE TAHOE",
            "FromCountry": "US",
            "FromState": "CA",
            "FromZip": "89449",
            "To": "+15306384866",
            "ToCity": "OAKLAND",
            "ToCountry": "US",
            "ToState": "CA",
            "ToZip": "94612",
            }

        expected = b("fF+xx6dTinOaCdZ0aIeNkHr/ZAA=")

        assert_equal(validator.compute_signature(uri, params), expected)
        assert_true(validator.validate(uri, params, expected))

########NEW FILE########
__FILENAME__ = tools
from __future__ import with_statement
from mock import Mock


def create_mock_json(path):
    with open(path) as f:
        resp = Mock()
        resp.content = f.read()
        return resp

########NEW FILE########
__FILENAME__ = accounts
from . import InstanceResource, ListResource
from .applications import Applications
from .notifications import Notifications
from .recordings import Transcriptions, Recordings
from .calls import Calls
from .sms_messages import Sms
from .caller_ids import CallerIds
from .phone_numbers import PhoneNumbers
from .conferences import Conferences
from .connect_apps import ConnectApps, AuthorizedConnectApps
from .queues import Queues
from .usage import UsageRecords, UsageTriggers
from .messages import Messages
from .media import MediaList
from .sip import Sip


class Account(InstanceResource):
    """ An Account resource

    """

    ACTIVE = "active"        #: A constant representing an active account
    SUSPENDED = "suspended"  #: A constant representing a suspended account
    CLOSED = "closed"        #: A constant representing a closed account

    subresources = [
        Applications,
        Notifications,
        Transcriptions,
        Recordings,
        Calls,
        Sms,
        CallerIds,
        PhoneNumbers,
        Conferences,
        ConnectApps,
        Queues,
        AuthorizedConnectApps,
        UsageRecords,
        UsageTriggers,
        MediaList,
        Messages,
        Sip,
    ]

    def update(self, **kwargs):
        """
        Update the status of an account.

        :param friendly_name: Update the description of this account.
        :param status: Alter the status of this account

        Use :const:`CLOSED` to irreversibly close this account,
        :const:`SUSPENDED` to temporarily suspend it, or :const:`ACTIVE`
        to reactivate it.
        """
        self.update_instance(**kwargs)

    def close(self):
        """
        Permenently deactivate this account
        """
        return self.update_instance(status=Account.CLOSED)

    def suspend(self):
        """
        Temporarily suspend this account
        """
        return self.update_instance(status=Account.SUSPENDED)

    def activate(self):
        """
        Reactivate this account
        """
        return self.update_instance(status=Account.ACTIVE)


class Accounts(ListResource):
    """ A list of Account resources """

    name = "Accounts"
    instance = Account

    def list(self, **kwargs):
        """
        Returns a page of :class:`Account` resources as a list. For paging
        informtion see :class:`ListResource`

        :param date friendly_name: Only list accounts with this friendly name
        :param date status: Only list accounts with this status
        """
        return self.get_instances(kwargs)

    def update(self, sid, **kwargs):
        """
        :param sid: Account identifier
        :param friendly_name: Update the description of this account.
        :param status: Alter the status of this account

        Use :data:`CLOSED` to irreversibly close this account,
        :data:`SUSPENDED` to temporarily suspend it, or :data:`ACTIVE`
        to reactivate it.
        """
        return self.update_instance(sid, kwargs)

    def close(self, sid):
        """
        Permenently deactivate an account, Alias to update
        """
        return self.update(sid, status=Account.CLOSED)

    def suspend(self, sid):
        """
        Temporarily suspend an account, Alias to update
        """
        return self.update(sid, status=Account.SUSPENDED)

    def activate(self, sid):
        """
        Reactivate an account, Alias to update
        """
        return self.update(sid, status=Account.ACTIVE)

    def create(self, **kwargs):
        """
        Returns a newly created sub account resource.

        :param friendly_name: Update the description of this account.
        """
        return self.create_instance(kwargs)

########NEW FILE########
__FILENAME__ = applications
from . import InstanceResource, ListResource


class Application(InstanceResource):
    """ An application resource """

    def update(self, **kwargs):
        """
        Update this application
        """
        return self.parent.update(self.name, **kwargs)

    def delete(self):
        """
        Delete this application
        """
        return self.parent.delete(self.name)


class Applications(ListResource):

    name = "Applications"
    instance = Application

    def list(self, **kwargs):
        """
        Returns a page of :class:`Application` resources as a list. For paging
        informtion see :class:`ListResource`

        :param date friendly_name: List applications with this friendly name
        """
        return self.get_instances(kwargs)

    def create(self, **kwargs):
        """
        Create an :class:`Application` with any of these optional parameters.

        :param friendly_name: A human readable description of the application,
                              with maximum length 64 characters.
        :param api_version: Requests to this application's URLs will start a
                            new TwiML session with this API version.
                            Either 2010-04-01 or 2008-08-01.
        :param voice_url: The URL that Twilio should request when somebody
                          dials a phone number assigned to this application.
        :param voice_method: The HTTP method that should be used to request the
                             VoiceUrl. Either GET or POST.
        :param voice_fallback_url: A URL that Twilio will request if an error
                                   occurs requesting or executing the TwiML
                                   defined by VoiceUrl.
        :param voice_fallback_method: The HTTP method that should be used to
                                      request the VoiceFallbackUrl. Either GET
                                      or POST.
        :param status_callback: The URL that Twilio will request to pass status
                                parameters (such as call ended) to your
                                application.
        :param status_callback_method: The HTTP method Twilio will use to make
                                       requests to the StatusCallback URL.
                                       Either GET or POST.
        :param voice_caller_id_lookup: Do a lookup of a caller's name from the
                                       CNAM database and post it to your app.
                                       Either true or false.
        :param sms_url: The URL that Twilio should request when somebody sends
                        an SMS to a phone number assigned to this application.
        :param sms_method: The HTTP method that should be used to request the
                           SmsUrl. Either GET or POST.
        :param sms_fallback_url: A URL that Twilio will request if an error
                                 occurs requesting or executing the TwiML
                                 defined by SmsUrl.
        :param sms_fallback_method: The HTTP method that should be used to
                                    request the SmsFallbackUrl. Either GET
                                    or POST.
        :param sms_status_callback: Twilio will make a POST request to this URL
                                    to pass status parameters (such as sent or
                                    failed) to your application if you specify
                                    this application's Sid as the
                                    ApplicationSid on an outgoing SMS request.
        """
        return self.create_instance(kwargs)

    def update(self, sid, **kwargs):
        """
        Update an :class:`Application` with the given parameters.

        All the parameters are describe above in :meth:`create`
        """
        return self.update_instance(sid, kwargs)

    def delete(self, sid):
        """
        Delete an :class:`Application`
        """
        return self.delete_instance(sid)

########NEW FILE########
__FILENAME__ = base
import logging
import os
import platform

from six import integer_types, string_types, binary_type, iteritems
from ...compat import urlparse
from ...compat import urlencode

from ... import __version__, TwilioException, TwilioRestException
from .connection import Connection
from .imports import parse_qs, httplib2, json
from .util import transform_params, parse_rfc2822_date, UNSET_TIMEOUT


class Response(object):
    """
    Take a httplib2 response and turn it into a requests response
    """
    def __init__(self, httplib_resp, content, url):
        self.content = content
        self.cached = False
        self.status_code = int(httplib_resp.status)
        self.ok = self.status_code < 400
        self.url = url


def get_cert_file():
    """ Get the cert file location or bail """
    # XXX - this currently fails test coverage because we don't actually go
    # over the network anywhere. Might be good to have a test that stands up a
    # local server and authenticates against it.
    try:
        # Apparently __file__ is not available in all places so wrapping this
        # in a try/catch
        current_path = os.path.realpath(__file__)
        ca_cert_path = os.path.join(current_path, "..", "..", "..",
                                    "conf", "cacert.pem")
        return os.path.abspath(ca_cert_path)
    except Exception:
        # None means use the default system file
        return None


def make_request(method, url, params=None, data=None, headers=None,
                 cookies=None, files=None, auth=None, timeout=None,
                 allow_redirects=False, proxies=None):
    """Sends an HTTP request

    :param str method: The HTTP method to use
    :param str url: The URL to request
    :param dict params: Query parameters to append to the URL
    :param dict data: Parameters to go in the body of the HTTP request
    :param dict headers: HTTP Headers to send with the request
    :param float timeout: Socket/Read timeout for the request

    :return: An http response
    :rtype: A :class:`Response <models.Response>` object

    See the requests documentation for explanation of all these parameters

    Currently proxies, files, and cookies are all ignored
    """
    http = httplib2.Http(
        timeout=timeout,
        ca_certs=get_cert_file(),
        proxy_info=Connection.proxy_info(),
    )
    http.follow_redirects = allow_redirects

    if auth is not None:
        http.add_credentials(auth[0], auth[1])

    def encode_atom(atom):
            if isinstance(atom, (integer_types, binary_type)):
                return atom
            elif isinstance(atom, string_types):
                return atom.encode('utf-8')
            else:
                raise ValueError('list elements should be an integer, '
                                 'binary, or string')

    if data is not None:
        udata = {}
        for k, v in iteritems(data):
            key = k.encode('utf-8')
            if isinstance(v, (list, tuple, set)):
                udata[key] = [encode_atom(x) for x in v]
            elif isinstance(v, (integer_types, binary_type, string_types)):
                udata[key] = encode_atom(v)
            else:
                raise ValueError('data should be an integer, '
                                 'binary, or string, or sequence ')
        data = urlencode(udata, doseq=True)

    if params is not None:
        enc_params = urlencode(params, doseq=True)
        if urlparse(url).query:
            url = '%s&%s' % (url, enc_params)
        else:
            url = '%s?%s' % (url, enc_params)

    resp, content = http.request(url, method, headers=headers, body=data)

    # Format httplib2 request as requests object
    return Response(resp, content.decode('utf-8'), url)


def make_twilio_request(method, uri, **kwargs):
    """
    Make a request to Twilio. Throws an error

    :return: a requests-like HTTP response
    :rtype: :class:`RequestsResponse`
    :raises TwilioRestException: if the response is a 400
        or 500-level response.
    """
    headers = kwargs.get("headers", {})

    user_agent = "twilio-python/%s (Python %s)" % (
        __version__,
        platform.python_version(),
    )
    headers["User-Agent"] = user_agent
    headers["Accept-Charset"] = "utf-8"

    if method == "POST" and "Content-Type" not in headers:
        headers["Content-Type"] = "application/x-www-form-urlencoded"

    kwargs["headers"] = headers

    if "Accept" not in headers:
        headers["Accept"] = "application/json"
        uri += ".json"

    resp = make_request(method, uri, **kwargs)

    if not resp.ok:
        try:
            error = json.loads(resp.content)
            code = error["code"]
            message = "%s: %s" % (code, error["message"])
        except:
            code = None
            message = resp.content

        raise TwilioRestException(status=resp.status_code, method=method,
                                  uri=resp.url, msg=message, code=code)

    return resp


class Resource(object):
    """A REST Resource"""

    name = "Resource"

    def __init__(self, base_uri, auth, timeout=UNSET_TIMEOUT):
        self.base_uri = base_uri
        self.auth = auth
        self.timeout = timeout

    def __eq__(self, other):
        return (isinstance(other, self.__class__)
                and self.__dict__ == other.__dict__)

    def __hash__(self):
        return hash(frozenset(self.__dict__))

    def __ne__(self, other):
        return not self.__eq__(other)

    def request(self, method, uri, **kwargs):
        """
        Send an HTTP request to the resource.

        :raises: a :exc:`~twilio.TwilioRestException`
        """
        if 'timeout' not in kwargs and self.timeout is not UNSET_TIMEOUT:
            kwargs['timeout'] = self.timeout
        resp = make_twilio_request(method, uri, auth=self.auth, **kwargs)

        logging.debug(resp.content)

        if method == "DELETE":
            return resp, {}
        else:
            return resp, json.loads(resp.content)

    @property
    def uri(self):
        format = (self.base_uri, self.name)
        return "%s/%s" % format


class InstanceResource(Resource):
    """ The object representation of an instance response from the Twilio API

    :param parent: The parent list class for this instance resource.
        For example, the parent for a :class:`~twilio.rest.resources.Call`
        would be a :class:`~twilio.rest.resources.Calls` object.
    :type parent: :class:`~twilio.rest.resources.ListResource`
    :param str sid: The 34-character unique identifier for this instance
    """

    subresources = []
    id_key = "sid"

    def __init__(self, parent, sid):
        self.parent = parent
        self.name = sid
        super(InstanceResource, self).__init__(
            parent.uri,
            parent.auth,
            parent.timeout
        )

    def load(self, entries):
        if "from" in entries.keys():
            entries["from_"] = entries["from"]
            del entries["from"]

        if "uri" in entries.keys():
            del entries["uri"]

        for key in entries.keys():
            if key.startswith("date_") and isinstance(entries[key], str):
                entries[key] = parse_rfc2822_date(entries[key])

        self.__dict__.update(entries)

    def load_subresources(self):
        """
        Load all subresources
        """
        for resource in self.subresources:
            list_resource = resource(
                self.uri,
                self.parent.auth,
                self.parent.timeout
            )
            self.__dict__[list_resource.key] = list_resource

    def update_instance(self, **kwargs):
        """ Make a POST request to the API to update an object's properties

        :return: None, this is purely side effecting
        :raises: a :class:`~twilio.rest.RestException` on failure
        """
        a = self.parent.update(self.name, **kwargs)
        self.load(a.__dict__)

    def delete_instance(self):
        """ Make a DELETE request to the API to delete the object

        :return: None, this is purely side effecting
        :raises: a :class:`~twilio.rest.RestException` on failure
        """
        return self.parent.delete(self.name)

    def __str__(self):
        return "<%s %s>" % (self.__class__.__name__, self.name[0:5])


class ListResource(Resource):

    name = "Resources"
    instance = InstanceResource

    def __init__(self, *args, **kwargs):
        super(ListResource, self).__init__(*args, **kwargs)

        try:
            self.key
        except AttributeError:
            self.key = self.name.lower()

    def get(self, sid):
        """ Get an instance resource by its sid

        Usage:

        .. code-block:: python

            message = client.messages.get("SM1234")
            print message.body

        :rtype: :class:`~twilio.rest.resources.InstanceResource`
        :raises: a :exc:`~twilio.TwilioRestException` if a resource with that
            sid does not exist, or the request fails
        """
        return self.get_instance(sid)

    def get_instance(self, sid):
        """Request the specified instance resource"""
        uri = "%s/%s" % (self.uri, sid)
        resp, item = self.request("GET", uri)
        return self.load_instance(item)

    def get_instances(self, params):
        """
        Query the list resource for a list of InstanceResources.

        Raises a :exc:`~twilio.TwilioRestException` if requesting a page of
        results that does not exist.

        :param dict params: List of URL parameters to be included in request
        :param int page: The page of results to retrieve (most recent at 0)
        :param int page_size: The number of results to be returned.

        :returns: -- the list of resources
        """
        params = transform_params(params)

        resp, page = self.request("GET", self.uri, params=params)

        if self.key not in page:
            raise TwilioException("Key %s not present in response" % self.key)

        return [self.load_instance(ir) for ir in page[self.key]]

    def create_instance(self, body):
        """
        Create an InstanceResource via a POST to the List Resource

        :param dict body: Dictionary of POST data
        """
        resp, instance = self.request("POST", self.uri,
                                      data=transform_params(body))

        if resp.status_code not in (200, 201):
            raise TwilioRestException(resp.status_code,
                                      self.uri, "Resource not created")

        return self.load_instance(instance)

    def delete_instance(self, sid):
        """
        Delete an InstanceResource via DELETE

        body: string -- HTTP Body for the quest
        """
        uri = "%s/%s" % (self.uri, sid)
        resp, instance = self.request("DELETE", uri)
        return resp.status_code == 204

    def update_instance(self, sid, body):
        """
        Update an InstanceResource via a POST

        sid: string -- String identifier for the list resource
        body: dictionary -- Dict of items to POST
        """
        uri = "%s/%s" % (self.uri, sid)
        resp, entry = self.request("POST", uri, data=transform_params(body))
        return self.load_instance(entry)

    def count(self):
        """ .. deprecated:: 3.6.5

        Get the total number of instances for this resource

        Note: this query can be slow if you have many instances.

        :return: the total number of instances
        :rtype: int
        :raises: a :exc:`~twilio.TwilioRestException` if the request fails


        Example usage:

        .. code-block:: python

            print client.calls.count() # prints 323
        """
        # XXX: this should make a request with PageSize=1 to return as quickly
        # as possible
        resp, page = self.request("GET", self.uri)
        return page["total"]

    def iter(self, **kwargs):
        """ Return all instance resources using an iterator

        This will fetch a page of resources from the API and yield them in
        turn. When the page is exhausted, this will make a request to the API
        to retrieve the next page. Hence you may notice a pattern - the library
        will loop through 50 objects very quickly, but there will be a delay
        retrieving the 51st as the library must make another request to the API
        for resources.

        Example usage:

        .. code-block:: python

            for message in client.messages:
                print message.sid
        """
        params = transform_params(kwargs)

        while True:
            resp, page = self.request("GET", self.uri, params=params)

            if self.key not in page:
                raise StopIteration()

            for ir in page[self.key]:
                yield self.load_instance(ir)

            if not page.get('next_page_uri', ''):
                raise StopIteration()

            o = urlparse(page['next_page_uri'])
            params.update(parse_qs(o.query))

    def load_instance(self, data):
        instance = self.instance(self, data[self.instance.id_key])
        instance.load(data)
        instance.load_subresources()
        return instance

    def __str__(self):
        return '<%s (%s)>' % (self.__class__.__name__, self.count())

    def list(self, **kw):
        """Query the list resource for a list of InstanceResources.

        :param int page: The page of results to retrieve (most recent at 0)
        :param int page_size: The number of results to be returned.
        """
        return self.get_instances(kw)

########NEW FILE########
__FILENAME__ = caller_ids
from . import transform_params
from . import InstanceResource, ListResource


class CallerId(InstanceResource):

    def delete(self):
        """
        Deletes this caller ID from the account.
        """
        return self.delete_instance()

    def update(self, **kwargs):
        """
        Update the CallerId
        """
        self.update_instance(**kwargs)


class CallerIds(ListResource):
    """ A list of :class:`CallerId` resources """

    name = "OutgoingCallerIds"
    key = "outgoing_caller_ids"
    instance = CallerId

    def delete(self, sid):
        """
        Deletes a specific :class:`CallerId` from the account.
        """
        self.delete_instance(sid)

    def list(self, **kwargs):
        """
        :param phone_number: Show caller ids with this phone number.
        :param friendly_name: Show caller ids with this friendly name.
        """
        return self.get_instances(kwargs)

    def update(self, sid, **kwargs):
        """
        Update a specific :class:`CallerId`
        """
        return self.update_instance(sid, kwargs)

    def validate(self, phone_number, **kwargs):
        """
        Begin the validation process for the given number.

        Returns a dictionary with the following keys

        **account_sid**:
        The unique id of the Account to which the Validation Request belongs.

        **phone_number**: The incoming phone number being validated,
        formatted with a '+' and country code e.g., +16175551212

        **friendly_name**: The friendly name you provided, if any.

        **validation_code**: The 6 digit validation code that must be entered
        via the phone to validate this phone number for Caller ID.

        :param phone_number: The phone number to call and validate
        :param friendly_name: A description for the new caller ID
        :param call_delay: Number of seconds to delay the validation call.
        :param extension: Digits to dial after connecting the validation call.
        :returns: A response dictionary
        """
        kwargs["phone_number"] = phone_number
        params = transform_params(kwargs)
        resp, validation = self.request("POST", self.uri, data=params)
        return validation

########NEW FILE########
__FILENAME__ = calls
from .notifications import Notifications
from .recordings import Recordings
from .util import normalize_dates, parse_date
from . import InstanceResource, ListResource


class Call(InstanceResource):
    """ A call resource """

    BUSY = "busy"
    CANCELED = "canceled"
    COMPLETED = "completed"
    FAILED = "failed"
    IN_PROGRESS = "in-progress"
    NO_ANSWER = "no-answer"
    QUEUED = "queued"
    RINGING = "ringing"

    subresources = [
        Notifications,
        Recordings,
    ]

    def hangup(self):
        """ If this call is currenlty active, hang up the call.
        If this call is scheduled to be made, remove the call
        from the queue
        """
        a = self.parent.hangup(self.name)
        self.load(a.__dict__)

    def cancel(self):
        """ If the called is queued or rining, cancel the calls.
        Will not affect in progress calls
        """
        a = self.parent.cancel(self.name)
        self.load(a.__dict__)

    def route(self, **kwargs):
        """Route the specified :class:`Call` to another url.

        :param url: A valid URL that returns TwiML.
        :param method: HTTP method Twilio uses when requesting the above URL.
        """
        a = self.parent.route(self.name, **kwargs)
        self.load(a.__dict__)


class Calls(ListResource):
    """ A list of Call resources """

    name = "Calls"
    instance = Call

    @normalize_dates
    def list(self, from_=None, ended_after=None,
             ended_before=None, ended=None, started_before=None,
             started_after=None, started=None, **kwargs):
        """
        Returns a page of :class:`Call` resources as a list. For paging
        informtion see :class:`ListResource`

        :param date after: Only list calls started after this datetime
        :param date before: Only list calls started before this datetime
        """
        kwargs["from"] = from_
        kwargs["StartTime<"] = started_before
        kwargs["StartTime>"] = started_after
        kwargs["StartTime"] = parse_date(started)
        kwargs["EndTime<"] = ended_before
        kwargs["EndTime>"] = ended_after
        kwargs["EndTime"] = parse_date(ended)
        return self.get_instances(kwargs)

    def create(self, to, from_, url, status_method=None, **kwargs):
        """
        Make a phone call to a number.

        :param str to: The phone number to call
        :param str `from_`: The caller ID (must be a verified Twilio number)
        :param str url: The URL to read TwiML from when the call connects
        :param method: The HTTP method Twilio should use to request the url
        :type method: None (defaults to 'POST'), 'GET', or 'POST'
        :param str fallback_url: A URL that Twilio will request if an error
            occurs requesting or executing the TwiML at url
        :param str fallback_method: The HTTP method that Twilio should use
            to request the fallback_url
        :type fallback_method: None (will make 'POST' request),
                               'GET', or 'POST'
        :param str status_callback: A URL that Twilio will request when the
            call ends to notify your app.
        :param str status_method: The HTTP method Twilio should use when
            requesting the above URL.
        :param str if_machine: Tell Twilio to try and determine if a machine
            (like voicemail) or a human has answered the call.
            See more in our `answering machine documentation
            <http://www.twilio.com/docs/api/rest/making_calls>`_.
        :type if_machine: None, 'Continue', or 'Hangup'
        :param str send_digits: A string of keys to dial after
            connecting to the number.
        :type send_digits: None or any combination of
            (0-9), '#', '*' or 'w' (to insert a half second pause).
        :param int timeout: The integer number of seconds that Twilio should
            allow the phone to ring before assuming there is no answer.
        :param str application_sid: The 34 character sid of the application
            Twilio should use to handle this phone call.
            Should not be used in conjunction with the url parameter.

        :return: A :class:`Call` object
        """
        kwargs["from"] = from_
        kwargs["to"] = to
        kwargs["url"] = url
        kwargs["status_callback_method"] = status_method
        return self.create_instance(kwargs)

    def update(self, sid, **kwargs):
        return self.update_instance(sid, kwargs)

    def cancel(self, sid):
        """ If this call is queued or ringing, cancel the call.
        Will not affect in-progress calls.

        :param sid: A Call Sid for a specific call
        :returns: Updated :class:`Call` resource
        """
        return self.update(sid, status=Call.CANCELED)

    def hangup(self, sid):
        """ If this call is currently active, hang up the call. If this call is
        scheduled to be made, remove the call from the queue.

        :param sid: A Call Sid for a specific call
        :returns: Updated :class:`Call` resource
        """
        return self.update(sid, status=Call.COMPLETED)

    def route(self, sid, url, method="POST"):
        """Route the specified :class:`Call` to another url.

        :param sid: A Call Sid for a specific call
        :param url: A valid URL that returns TwiML.
        :param method: The HTTP method Twilio uses when requesting the URL.
        :returns: Updated :class:`Call` resource
        """
        return self.update(sid, url=url, method=method)

########NEW FILE########
__FILENAME__ = conferences
from .util import parse_date, normalize_dates
from . import InstanceResource, ListResource


class Participant(InstanceResource):

    id_key = "call_sid"

    def mute(self):
        """
        Mute the participant
        """
        self.update_instance(muted="true")

    def unmute(self):
        """
        Unmute the participant
        """
        self.update_instance(muted="false")

    def kick(self):
        """
        Remove the participant from the given conference
        """
        self.delete_instance()


class Participants(ListResource):

    name = "Participants"
    instance = Participant

    def list(self, **kwargs):
        """
        Returns a list of :class:`Participant` resources in the given
        conference

        :param conference_sid: Conference this participant is part of
        :param boolean muted: If True, only show participants who are muted
        """
        return self.get_instances(kwargs)

    def mute(self, call_sid):
        """
        Mute the given participant
        """
        return self.update(call_sid, muted=True)

    def unmute(self, call_sid):
        """
        Unmute the given participant
        """
        return self.update(call_sid, muted=False)

    def kick(self, call_sid):
        """
        Remove the participant from the given conference
        """
        return self.delete(call_sid)

    def delete(self, call_sid):
        """
        Remove the participant from the given conference
        """
        return self.delete_instance(call_sid)

    def update(self, sid, **kwargs):
        """
        :param sid: Participant identifier
        :param boolean muted: If true, mute this participant
        """
        return self.update_instance(sid, kwargs)


class Conference(InstanceResource):

    subresources = [
        Participants
    ]


class Conferences(ListResource):

    name = "Conferences"
    instance = Conference

    @normalize_dates
    def list(self, updated_before=None, updated_after=None, created_after=None,
             created_before=None, updated=None, created=None, **kwargs):
        """
        Return a list of :class:`Conference` resources

        :param status: Show conferences with this status
        :param friendly_name: Show conferences with this exact friendly_name
        :param date updated_after: List conferences updated after this date
        :param date updated_before: List conferences updated before this date
        :param date created_after: List conferences created after this date
        :param date created_before: List conferences created before this date
        """
        kwargs["DateUpdated"] = parse_date(kwargs.get("date_updated", updated))
        kwargs["DateCreated"] = parse_date(kwargs.get("date_created", created))
        kwargs["DateUpdated<"] = updated_before
        kwargs["DateUpdated>"] = updated_after
        kwargs["DateCreated<"] = created_before
        kwargs["DateCreated>"] = created_after
        return self.get_instances(kwargs)

########NEW FILE########
__FILENAME__ = connection
from .imports import httplib2
from .imports import socks
from .imports import PROXY_TYPE_HTTP
from .imports import PROXY_TYPE_SOCKS4
from .imports import PROXY_TYPE_SOCKS5


class Connection(object):
    '''Class for setting proxy configuration to be used for REST calls.'''
    _proxy_info = None

    @classmethod
    def proxy_info(cls):
        '''Returns the currently-set proxy information
        as an httplib2.ProxyInfo object.
        '''
        return cls._proxy_info

    @classmethod
    def set_proxy_info(cls, proxy_host, proxy_port,
                       proxy_type=PROXY_TYPE_HTTP, proxy_rdns=None,
                       proxy_user=None, proxy_pass=None):
        '''Set proxy configuration for future REST API calls.

        :param str proxy_host: Hostname of the proxy to use.
        :param int proxy_port: Port to connect to.
        :param proxy_type: The proxy protocol to use. One of
        PROXY_TYPE_HTTP, PROXY_TYPE_SOCKS4, PROXY_TYPE_SOCKS5.
        Defaults to connection.PROXY_TYPE_HTTP.
        :param bool proxy_rdns: Use the proxy host's DNS resolver.
        :param str proxy_user: Username for the proxy.
        :param str proxy_pass: Password for the proxy.
        '''

        cls._proxy_info = httplib2.ProxyInfo(
            proxy_type,
            proxy_host,
            proxy_port,
            proxy_rdns=proxy_rdns,
            proxy_user=proxy_user,
            proxy_pass=proxy_pass,
        )


_hush_pyflakes = [
    socks,
    PROXY_TYPE_SOCKS4,
    PROXY_TYPE_SOCKS5
]

########NEW FILE########
__FILENAME__ = connect_apps
from . import InstanceResource, ListResource
from six import iteritems


class ConnectApp(InstanceResource):
    """ An authorized connect app """
    pass


class ConnectApps(ListResource):
    """ A list of Connect App resources """

    name = "ConnectApps"
    instance = ConnectApp
    key = "connect_apps"

    def list(self, **kwargs):
        """
        Returns a page of :class:`ConnectApp` resources as a list. For paging
        informtion see :class:`ListResource`
        """
        return self.get_instances(kwargs)


class AuthorizedConnectApp(ConnectApp):
    """ An authorized connect app """

    id_key = "connect_app_sid"

    def load(self, entries):
        """ Translate certain parameters into others"""
        result = {}

        for k, v in iteritems(entries):
            k = k.replace("connect_app_", "")
            result[k] = v

        super(AuthorizedConnectApp, self).load(result)


class AuthorizedConnectApps(ConnectApps):
    """ A list of Authorized Connect App resources """

    name = "AuthorizedConnectApps"
    instance = AuthorizedConnectApp
    key = "authorized_connect_apps"

########NEW FILE########
__FILENAME__ = imports
# parse_qs
try:
    from urlparse import parse_qs
except ImportError:
    from cgi import parse_qs

# json
try:
    import json
except ImportError:
    try:
        import simplejson as json
    except ImportError:
        from django.utils import simplejson as json

# httplib2
import httplib2

# socks
try:
    from httplib2 import socks
    from httplib2.socks import PROXY_TYPE_HTTP
    from httplib2.socks import PROXY_TYPE_SOCKS4
    from httplib2.socks import PROXY_TYPE_SOCKS5
except ImportError:
    import socks
    from socks import PROXY_TYPE_HTTP
    from socks import PROXY_TYPE_SOCKS4
    from socks import PROXY_TYPE_SOCKS5

########NEW FILE########
__FILENAME__ = media
from . import InstanceResource, ListResource
from .util import normalize_dates, parse_date


class Media(InstanceResource):
    """ Represents media associated with a :class:`Message`.

    .. attribute:: sid

        A 34 character string that uniquely identifies this resource.

    .. attribute:: account_sid

        The unique id of the Account responsible for this media.

    .. attribute:: date_created

        The date that this resource was created, given in RFC 2822 format.

    .. attribute:: date_updated

        The date that this resource was last updated, given in RFC 2822 format.

    .. attribute:: parent_sid

        The MessageSid of the message that created the media.

    .. attribute:: content_type

        The default content-type of the media, for example image/jpeg,
        image/png, or image/gif.

    .. attribute:: uri

        The URI for this resource, relative to https://api.twilio.com

    """

    def delete(self):
        """
        Delete this media.
        """
        return self.parent.delete_instance(self.name)


class MediaList(ListResource):
    name = "Media"
    key = "media_list"
    instance = Media

    def __call__(self, message_sid):
        # `Media` is a word of ambiguous plurality. This causes issues.
        # To match the rest of the library:
        # `client.media` needs to return a new MediaList.
        # `client.media('message_sid')` needs to return a MediaList
        # for a given message.

        base_uri = "%s/Messages/%s" % (self.base_uri, message_sid)
        return MediaList(base_uri, self.auth, self.timeout)

    def __init__(self, *args, **kwargs):
        super(MediaList, self).__init__(*args, **kwargs)

    @normalize_dates
    def list(self, before=None, after=None, date_created=None, **kw):
        """
        Returns a page of :class:`Media` resources as a list. For
        paging information see :class:`ListResource`.

        :param date after: Only list media created after this date.
        :param date before: Only list media created before this date.
        :param date date_created: Only list media created on this date.
        :param sid message_sid: Only list media created by the given MessageSid
        """
        kw["DateCreated<"] = before
        kw["DateCreated>"] = after
        kw["DateCreated"] = parse_date(date_created)
        return self.get_instances(kw)

    def delete(self, sid):
        """
        Delete a :class:`Media`.

        :param sid: String identifier for a Media resource
        """
        return self.delete_instance(sid)

########NEW FILE########
__FILENAME__ = messages
from . import InstanceResource, ListResource
from .media import MediaList
from .util import normalize_dates, parse_date


class Message(InstanceResource):
    """ A Message instance.

    .. attribute:: sid

        A 34 character string that uniquely identifies this resource.

    .. attribute:: account_sid

        The unique id of the Account that sent or received this message.

    .. attribute:: from

        The phone number that initiated this message in E.164 format. For
        incoming messages, this will be the remote phone. For outgoing
        messages, this will be one of your Twilio phone numbers.

    .. attribute:: to

        The phone number that received the message in E.164 format. For
        incoming messages, this will be one of your Twilio phone numbers.
        For outgoing messages, this will be the remote phone.

    .. attribute:: date_created

        The date that this resource was created, given in RFC 2822 format.

    .. attribute:: date_updated

        The date that this resource was last updated, given in RFC 2822 format.

    .. attribute:: date_sent

        The date that the SMS was sent, given in RFC 2822 format.

    .. attribute:: body

        The text body of the message, as a unicode string.

    .. attribute:: num_segments

        The number of SMS messages used to deliver the
        body specified.

    .. attribute:: num_media

        The number of media that are associated with the message. If num_media
        is 0, then the media and image subresource will not contain any images.

    .. attribute:: status

        The status of this message. Either queued, sending, sent,failed,
        or received.

    .. attribute:: direction

        The direction of this message. inbound for incoming messages,
        outbound-api for messages initiated via the REST API, outbound-call
        for messages initiated during a call or outbound-reply for messages
        initiated in response to an incoming message.

    .. attribute:: price

        The amount billed for the message, in the currency associated with
        the account.

    .. attribute:: price_unit

        The currency in which price is measured, in ISO 4127 format
        (e.g. USD,EUR, JPY).

    .. attribute:: api_version

        The version of the Twilio API used to process the message.

    .. attribute:: uri

        The URI for this resource, relative to https://api.twilio.com

    """

    subresources = [MediaList]


class Messages(ListResource):
    name = "Messages"
    key = "messages"
    instance = Message

    def create(self, from_=None, **kwargs):
        """
        Create and send a Message.

        :param str to: The destination phone number.
        :param str `from_`: The phone number sending this message
            (must be a verified Twilio number)
        :param str body: The message you want to send,
            limited to 1600 characters.
        :param list media_url: A list of URLs of images to include in the
            message.
        :param status_callback: A URL that Twilio will POST to when
            your message is processed.
        :param str application_sid: The 34 character sid of the application
            Twilio should use to handle this phone call.
        """
        kwargs["from"] = from_
        return self.create_instance(kwargs)

    @normalize_dates
    def list(self, from_=None, before=None, after=None, date_sent=None, **kw):
        """
        Returns a page of :class:`Message` resources as a list. For
        paging information see :class:`ListResource`.

        :param to: Only show messages to this phone number.
        :param from_: Only show messages from this phone number.
        :param date after: Only list messages sent after this date.
        :param date before: Only list message sent before this date.
        :param date date_sent: Only list message sent on this date.
        :param `from_`: Only show messages from this phone number.
        :param date after: Only list messages logged after this datetime
        :param date before: Only list messages logged before this datetime
        """
        kw["From"] = from_
        kw["DateSent<"] = before
        kw["DateSent>"] = after
        kw["DateSent"] = parse_date(date_sent)
        return self.get_instances(kw)

    def update(self, sid, **kwargs):
        """ Updates the message for the given sid
        :param sid: The sid of the message to update.
        """
        return self.update_instance(sid, kwargs)

########NEW FILE########
__FILENAME__ = notifications
from .util import normalize_dates
from . import InstanceResource, ListResource


class Notification(InstanceResource):

    def delete(self):
        """
        Delete this notification
        """
        return self.delete_instance()


class Notifications(ListResource):

    name = "Notifications"
    instance = Notification

    @normalize_dates
    def list(self, before=None, after=None, **kwargs):
        """
        Returns a page of :class:`Notification` resources as a list.
        For paging information see :class:`ListResource`.

        **NOTE**: Due to the potentially voluminous amount of data in a
        notification, the full HTTP request and response data is only returned
        in the Notification instance resource representation.

        :param date after: Only list notifications logged after this datetime
        :param date before: Only list notifications logger before this datetime
        :param log_level: If 1, only shows errors. If 0, only show warnings
        """
        kwargs["MessageDate<"] = before
        kwargs["MessageDate>"] = after
        return self.get_instances(kwargs)

    def delete(self, sid):
        """
        Delete a given Notificiation
        """
        return self.delete_instance(sid)

########NEW FILE########
__FILENAME__ = phone_numbers
import re

from .. import TwilioException
from .util import change_dict_key, transform_params
from .util import UNSET_TIMEOUT
from . import InstanceResource, ListResource


TYPES = {"local": "Local", "tollfree": "TollFree", "mobile": "Mobile"}


class AvailablePhoneNumber(InstanceResource):
    """ An available phone number resource

   .. attribute:: friendly_name

      A nicely-formatted version of the phone number.

   .. attribute:: phone_number

      The phone number, in E.164 (i.e. "+1") format.

   .. attribute:: lata

      The LATA of this phone number.

   .. attribute:: rate_center

      The rate center of this phone number.

   .. attribute:: latitude

      The latitude coordinate of this phone number.

   .. attribute:: longitude

      The longitude coordinate of this phone number.

   .. attribute:: region

      The two-letter state or province abbreviation of this phone number.

   .. attribute:: postal_code

      The postal (zip) code of this phone number.

   .. attribute:: iso_country

        The country for this number

    """

    def __init__(self, parent):
        # Available Phone Numbers have no sid.
        super(AvailablePhoneNumber, self).__init__(parent, "")
        self.name = ""

    def purchase(self, **kwargs):
        return self.parent.purchase(phone_number=self.phone_number,
                                    **kwargs)


class AvailablePhoneNumbers(ListResource):

    name = "AvailablePhoneNumbers"
    key = "available_phone_numbers"
    instance = AvailablePhoneNumber

    def __init__(self, base_uri, auth, timeout, phone_numbers):
        super(AvailablePhoneNumbers, self).__init__(base_uri, auth, timeout)
        self.phone_numbers = phone_numbers

    def get(self, sid):
        raise TwilioException("Individual AvailablePhoneNumbers have no sid")

    def list(self, type="local", country="US", region=None, postal_code=None,
             lata=None, rate_center=None, **kwargs):
        """
        Search for phone numbers
        """
        kwargs["in_region"] = kwargs.get("in_region", region)
        kwargs["in_postal_code"] = kwargs.get("in_postal_code", postal_code)
        kwargs["in_lata"] = kwargs.get("in_lata", lata)
        kwargs["in_rate_center"] = kwargs.get("in_rate_center", rate_center)
        params = transform_params(kwargs)

        uri = "%s/%s/%s" % (self.uri, country, TYPES[type])
        resp, page = self.request("GET", uri, params=params)

        return [self.load_instance(i) for i in page[self.key]]

    def load_instance(self, data):
        instance = self.instance(self.phone_numbers)
        instance.load(data)
        instance.load_subresources()
        return instance


class PhoneNumber(InstanceResource):
    """ An IncomingPhoneNumber object

   .. attribute:: sid

      A 34 character string that uniquely identifies this resource.

   .. attribute:: date_created

      The date that this resource was created, given as GMT RFC 2822 format.

   .. attribute:: date_updated

      The date that this resource was last updated, in GMT RFC 2822 format.

   .. attribute:: friendly_name

      A human readable descriptive text for this resource, up to 64 characters
      long. By default, the FriendlyName is a nicely formatted version of
      the phone number.

   .. attribute:: account_sid

      The unique id of the Account responsible for this phone number.

   .. attribute:: phone_number

      The incoming phone number. e.g., +16175551212 (E.164 format)

   .. attribute:: api_version

      Calls to this phone number will start a new TwiML session with this
      API version.

   .. attribute:: voice_caller_id_lookup

      Look up the caller's caller-ID name from the CNAM database (additional
      charges apply). Either true or false.

   .. attribute:: voice_url

      The URL Twilio will request when this phone number receives a call.

   .. attribute:: voice_method

      The HTTP method Twilio will use when requesting the above Url.
      Either GET or POST.

   .. attribute:: voice_fallback_url

      The URL that Twilio will request if an error occurs retrieving or
      executing the TwiML requested by Url.

   .. attribute:: voice_fallback_method

      The HTTP method Twilio will use when requesting the VoiceFallbackUrl.
      Either GET or POST.

   .. attribute:: status_callback

      The URL that Twilio will request to pass status parameters (such as
      call ended) to your application.

   .. attribute:: status_callback_method

      The HTTP method Twilio will use to make requests to the
      StatusCallback URL. Either GET or POST.

   .. attribute:: sms_url

      The URL Twilio will request when receiving an incoming SMS message
      to this number.

   .. attribute:: sms_method

      The HTTP method Twilio will use when making requests to the SmsUrl.
      Either GET or POST.

   .. attribute:: sms_fallback_url

      The URL that Twilio will request if an error occurs retrieving or
      executing the TwiML from SmsUrl.

   .. attribute:: sms_fallback_method

      The HTTP method Twilio will use when requesting the above URL.
      Either GET or POST.

   .. attribute:: uri

      The URI for this resource, relative to https://api.twilio.com.
    """

    def load(self, entries):
        """ Set the proper Account owner of this phone number """

        # Only check if entries has a uri
        if "account_sid" in entries:
            # Parse the parent's uri to get the scheme and base
            uri = re.sub(r'AC(.*)', entries["account_sid"],
                         self.parent.base_uri)

            self.parent = PhoneNumbers(
                uri,
                self.parent.auth,
                self.parent.timeout
            )
            self.base_uri = self.parent.uri

        super(PhoneNumber, self).load(entries)

    def transfer(self, account_sid):
        """
        Transfer the phone number with sid from the current account to another
        identified by account_sid
        """
        a = self.parent.transfer(self.name, account_sid)
        self.load(a.__dict__)

    def update(self, **kwargs):
        """
        Update this phone number instance.
        """
        kwargs_copy = dict(kwargs)
        change_dict_key(kwargs_copy, from_key="status_callback_url",
                        to_key="status_callback")

        a = self.parent.update(self.name, **kwargs_copy)
        self.load(a.__dict__)

    def delete(self):
        """
        Release this phone number from your account. Twilio will no longer
        answer calls to this number, and you will stop being billed the monthly
        phone number fees. The phone number will eventually be recycled and
        potentially given to another customer, so use with care. If you make a
        mistake, contact us... we may be able to give you the number back.
        """
        return self.parent.delete(self.name)


class PhoneNumbers(ListResource):

    name = "IncomingPhoneNumbers"
    key = "incoming_phone_numbers"
    instance = PhoneNumber

    def __init__(self, base_uri, auth, timeout=UNSET_TIMEOUT):
        super(PhoneNumbers, self).__init__(base_uri, auth, timeout)
        self.available_phone_numbers = \
            AvailablePhoneNumbers(base_uri, auth, timeout, self)

    def delete(self, sid):
        """
        Release this phone number from your account. Twilio will no longer
        answer calls to this number, and you will stop being billed the
        monthly phone number fees. The phone number will eventually be
        recycled and potentially given to another customer, so use with care.
        If you make a mistake, contact us... we may be able to give you the
        number back.
        """
        return self.delete_instance(sid)

    def list(self, type=None, **kwargs):
        """
        :param phone_number: Show phone numbers that match this pattern.
        :param friendly_name: Show phone numbers with this friendly name
        :param type: Filter numbers by type. Available types are
            'local', 'mobile', or 'tollfree'

        You can specify partial numbers and use '*' as a wildcard.
        """

        uri = self.uri
        if type:
            uri = "%s/%s" % (self.uri, TYPES[type])

        params = transform_params(kwargs)
        resp, page = self.request("GET", uri, params=params)

        return [self.load_instance(i) for i in page[self.key]]

    def purchase(self, status_callback_url=None, **kwargs):
        """
        Attempt to purchase the specified number. The only required parameters
        are **either** phone_number or area_code

        :returns: Returns a :class:`PhoneNumber` instance on success,
                  :data:`False` on failure
        :raises: A :exc:`TypeError` if neither phone_number or area_code
        is specified.
        """
        kwargs["StatusCallback"] = kwargs.get("status_callback",
                                              status_callback_url)

        if 'phone_number' not in kwargs and 'area_code' not in kwargs:
            raise TypeError("phone_number or area_code is required")

        number_type = kwargs.pop('type', False)
        uri = self.uri
        if number_type:
            uri = "%s/%s" % (self.uri, TYPES[number_type])

        params = transform_params(kwargs)
        resp, instance = self.request('POST', uri, data=params)

        return self.load_instance(instance)

    def search(self, **kwargs):
        """
        :param type: The type of phone number to search for.
        :param str country: Only show numbers for this country (iso2)
        :param str region: When searching the US, show numbers in this state
        :param str postal_code: Only show numbers in this area code
        :param str rate_center: US only.
        :param tuple near_lat_long: Find close numbers within Distance miles.
        :param integer distance: Search radius for a Near- query in miles.
        """
        return self.available_phone_numbers.list(**kwargs)

    def transfer(self, sid, account_sid):
        """
        Transfer the phone number with sid from the current account to another
        identified by account_sid
        """
        return self.update(sid, account_sid=account_sid)

    def update(self, sid, **kwargs):
        """
        Update this phone number instance
        """
        kwargs_copy = dict(kwargs)
        change_dict_key(kwargs_copy, from_key="status_callback_url",
                        to_key="status_callback")

        if "application_sid" in kwargs_copy:
            for sid_type in ["voice_application_sid", "sms_application_sid"]:
                if sid_type not in kwargs_copy:
                    kwargs_copy[sid_type] = kwargs_copy["application_sid"]
            del kwargs_copy["application_sid"]
        return self.update_instance(sid, kwargs_copy)

########NEW FILE########
__FILENAME__ = queues
from . import InstanceResource, ListResource


class Member(InstanceResource):
    """ A Member of a queue

   .. attribute:: call_sid

      A 34 character string that uniquely identifies the call that is enqueued.

   .. attribute:: date_enqueued

      The date that the member was enqueued, given in RFC 2822 format.

   .. attribute:: wait_time

      The number of seconds the member has been in the queue.

   .. attribute:: position

      This member's current position in the queue.

   .. attribute:: uri

      The URI for this resource, relative to https://api.twilio.com.
    """

    id_key = "call_sid"


class Members(ListResource):
    """ A list of :class:`Member` objects """
    name = "Members"
    instance = Member
    key = "queue_members"

    def list(self, **kwargs):
        """
        Returns a list of :class:`Member` resources in the given queue

        :param queue_sid: :class:`Queue` this participant is part of
        """
        return self.get_instances(kwargs)

    def dequeue(self, url, call_sid='Front', **kwargs):
        """
        Dequeues a member from the queue and have the member's call
        begin executing the TwiML document at the url.

        :param call_sid: Call sid specifying the member, if not given,
                         the member at the front of the queue will be used
        :param url: url of the TwiML document to be executed.
        """
        kwargs['url'] = url
        return self.update_instance(call_sid, kwargs)


class Queue(InstanceResource):
    """ An instance of a Queue

   .. attribute:: sid

      A 34 character string that uniquely identifies this queue.

   .. attribute:: friendly_name

      A user-provided string that identifies this queue.

   .. attribute:: current_size

      The count of calls currently in the queue.

   .. attribute:: max_size

      The upper limit of calls allowed to be in the queue.
      `unlimited` is an option. The default is 100.

   .. attribute:: average_wait_time

      The average wait time of the members of this queue in seconds.
      This is calculated at the time of the request.

   .. attribute:: uri

      The URI for this resource, relative to https://api.twilio.com.

   .. attribute:: queue_members

      A :class:`Members` object holding the :class:`Member` objects in this
      queue.
    """

    subresources = [
        Members
    ]

    def update(self, **kwargs):
        """
        Update this queue

        :param friendly_name: A new friendly name for this queue
        :param max_size: A new max size. Changing a max size to less than the
                         current size results in the queue rejecting incoming
                         requests until it shrinks below the new max size
        """
        return self.parent.update_instance(self.name, kwargs)

    def delete(self):
        """
        Delete this queue.  Can only be run on empty queues.
        """
        return self.parent.delete_instance(self.name)


class Queues(ListResource):
    name = "Queues"
    instance = Queue

    def list(self, **kwargs):
        """
        Returns a page of :class:`Queue` resources as a list sorted
        by DateUpdated. For paging informtion see :class:`ListResource`
        """
        return self.get_instances(kwargs)

    def create(self, name, **kwargs):
        """ Create an :class:`Queue` with any of these optional parameters.

        :param name: A human readable description of the application,
                              with maximum length 64 characters.
        :param max_size: The limit on calls allowed into the queue (optional)
        """
        kwargs['friendly_name'] = name
        return self.create_instance(kwargs)

    def update(self, sid, **kwargs):
        """
        Update a :class:`Queue`

        :param sid: String identifier for a Queue resource
        :param friendly_name: A new friendly name for this queue
        :param max_size: A new max size. Changing a max size to less than the
                         current size results in the queue rejecting incoming
                         requests until it shrinks below the new max size
        """
        return self.update_instance(sid, kwargs)

    def delete(self, sid):
        """
        Delete a :class:`Queue`. Can only be run on empty queues.

        :param sid: String identifier for a Queue resource
        """
        return self.delete_instance(sid)

########NEW FILE########
__FILENAME__ = recordings
from .util import normalize_dates

from .transcriptions import Transcriptions
from .base import InstanceResource, ListResource


class Recording(InstanceResource):

    subresources = [Transcriptions]

    def __init__(self, *args, **kwargs):
        super(Recording, self).__init__(*args, **kwargs)
        self.formats = {
            "mp3": self.uri + ".mp3",
            "wav": self.uri + ".wav",
        }

    def delete(self):
        """
        Delete this recording
        """
        return self.delete_instance()


class Recordings(ListResource):

    name = "Recordings"
    instance = Recording

    @normalize_dates
    def list(self, before=None, after=None, **kwargs):
        """
        Returns a page of :class:`Recording` resources as a list.
        For paging information see :class:`ListResource`.

        :param date after: Only list recordings logged after this datetime
        :param date before: Only list recordings logger before this datetime
        :param call_sid: Only list recordings from this :class:`Call`
        """
        kwargs["DateCreated<"] = before
        kwargs["DateCreated>"] = after
        return self.get_instances(kwargs)

    def delete(self, sid):
        """
        Delete the given recording
        """
        return self.delete_instance(sid)

########NEW FILE########
__FILENAME__ = sandboxes
from .util import transform_params
from . import InstanceResource, ListResource


class Sandbox(InstanceResource):

    id_key = "pin"

    def update(self, **kwargs):
        """
        Update your Twilio Sandbox
        """
        a = self.parent.update(**kwargs)
        self.load(a.__dict__)


class Sandboxes(ListResource):

    name = "Sandbox"
    instance = Sandbox

    def get(self):
        """Request the specified instance resource"""
        return self.get_instance(self.uri)

    def update(self, **kwargs):
        """
        Update your Twilio Sandbox
        """
        resp, entry = self.request("POST", self.uri,
                                   body=transform_params(kwargs))
        return self.create_instance(entry)

########NEW FILE########
__FILENAME__ = credential_lists
from .. import InstanceResource, ListResource


class Credential(InstanceResource):
    """ A username/password entry in a CredentialList.

    .. attribute:: sid

        A 34 character string that uniquely identifies this resource.

    .. attribute:: account_sid

        The unique id of the Account responsible for this Credential.

    .. attribute:: friendly_name

        A human-readable name for this resource.

    .. attribute:: username

        The username for this credential

    .. attribute:: date_created

        The date that this resource was created.

    .. attribute:: date_updated

        The date that this resource was last updated.

    """
    def update(self, **kwargs):
        """Update this credential."""
        return self.parent.update_instance(self.name, **kwargs)

    def delete(self):
        """
        Delete this credential.
        """
        return self.parent.delete_instance(self.name)


class Credentials(ListResource):
    name = "Credentials"
    key = "credentials"
    instance = Credential

    def create(self, username, password, **kwargs):
        """Add a Credential to a SipCredentialList.

        :param username: The username to add
        :param password: The password for the user
        """
        kwargs.update(username=username, password=password)
        return self.create_instance(kwargs)

    def update(self, sid, **kwargs):
        """Update a :class:`Credential`.

        :param sid: String identifier for a credential
        """
        return self.update_instance(sid, kwargs)

    def delete(self, sid):
        """Remove a username/password

        :param sid: String identifier for a credential
        """
        return self.delete_instance(sid)


class SipCredentialList(InstanceResource):
    """ A list of username/password credentials used to control access to
    Domains.

    .. attribute:: sid

        A 34 character string that uniquely identifies this resource.

    .. attribute:: account_sid

        The unique id of the Account responsible for this CredentialList.

    .. attribute:: friendly_name

        A human-readable name for this CredentialList.

    .. attribute:: date_created

        The date that this resource was created.

    .. attribute:: date_updated

        The date that this resource was last updated.

    """

    subresources = [Credentials]

    def update(self, **kwargs):
        """Update this credential list."""
        return self.parent.update_instance(self.name, **kwargs)

    def delete(self):
        """
        Delete this credential list.
        """
        return self.parent.delete_instance(self.name)


class SipCredentialLists(ListResource):
    name = "CredentialLists"
    key = "credential_lists"
    instance = SipCredentialList

    def create(self, friendly_name, **kwargs):
        """ Create a :class:`SipCredentialList`.

        :param friendly_name: A human-readable name for this credential list.
        """
        kwargs['friendly_name'] = friendly_name
        return self.create_instance(kwargs)

    def update(self, sid, **kwargs):
        """
        Update a :class:`SipCredentialList`

        :param sid: String identifier for a SipCredentialList resource
        """
        return self.update_instance(sid, kwargs)

    def delete(self, sid):
        """
        Delete a :class:`SipCredentialList`.

        :param sid: String identifier for a SipCredentialList resource
        """
        return self.delete_instance(sid)

########NEW FILE########
__FILENAME__ = domains
from .. import InstanceResource, ListResource


class IpAccessControlListMapping(InstanceResource):
    def delete(self):
        """
        Remove this mapping (disassociate the ACL from the Domain).
        """
        return self.parent.delete_instance(self.name)


class IpAccessControlListMappings(ListResource):
    name = "IpAccessControlListMappings"
    key = "ip_access_control_list_mappings"
    instance = IpAccessControlListMapping

    def create(self, ip_access_control_list_sid, **kwargs):
        """Add a :class:`CredentialListMapping` to this domain.

        :param sid: String identifier for an existing
                                    :class:`CredentialList`.
        """
        kwargs.update(ip_access_control_list_sid=ip_access_control_list_sid)
        return self.create_instance(kwargs)

    def delete(self, sid):
        """Remove a :class:`CredentialListMapping` from this domain.

        :param sid: String identifier for a CredentialList resource
        """
        return self.delete_instance(sid)


class CredentialListMapping(InstanceResource):
    def delete(self):
        """
        Remove this mapping (disassociate the CredentialList from the Domain).
        """
        return self.parent.delete_instance(self.name)


class CredentialListMappings(ListResource):
    name = "CredentialListMappings"
    key = "credential_list_mappings"
    instance = CredentialListMapping

    def create(self, credential_list_sid, **kwargs):
        """Add a :class:`CredentialListMapping` to this domain.

        :param sid: String identifier for an existing
                                    :class:`CredentialList`.
        """
        kwargs.update(credential_list_sid=credential_list_sid)
        return self.create_instance(kwargs)

    def delete(self, sid):
        """Remove a :class:`CredentialListMapping` from this domain.

        :param sid: String identifier for a CredentialList resource
        """
        return self.delete_instance(sid)


class Domain(InstanceResource):
    """An inbound SIP Domain.

    .. attribute:: sid

        A 34 character string that uniquely identifies this resource.

    .. attribute:: account_sid

        The unique id of the Account responsible for this domain.

    .. attribute:: domain_name

        A unique domain name for this inbound SIP endpoint. Must end in
        .sip.twilio.com.

    .. attribute:: friendly_name

        A human-readable name for this SIP domain. (restrictions?)

    .. attribute:: auth_type

        ???

    .. attribute:: voice_url

        The URL Twilio will request when this domain receives a call.

    .. attribute:: voice_method

        The HTTP method Twilio will use when requesting the above voice_url.
        Either GET or POST.

    .. attribute:: voice_fallback_url

        The URL that Twilio will request if an error occurs retrieving or
        executing the TwiML requested by voice_url.

    .. attribute:: voice_fallback_method

        The HTTP method Twilio will use when requesting the voice_fallback_url.
        Either GET or POST.

    .. attribute:: voice_status_callback_url

        The URL that Twilio will request to pass status parameters (such as
        call ended) to your application.

    .. attribute:: voice_status_callback_method

        The HTTP method Twilio will use to make requests to the status_callback
        URL. Either GET or POST.

    .. attribute:: date_created

        The date that this resource was created.

    .. attribute:: date_updated

        The date that this resource was last updated.

    """
    subresources = [IpAccessControlListMappings, CredentialListMappings]

    def update(self, **kwargs):
        """
        Update this :class:`Domain`

        Available attributes to update are described above as instance
        attributes.
        """
        return self.parent.update_instance(self.name, kwargs)

    def delete(self):
        """
        Delete this domain.
        """
        return self.parent.delete_instance(self.name)


class Domains(ListResource):
    name = "Domains"
    key = "domains"
    instance = Domain

    def create(self, domain_name, **kwargs):
        """ Create a :class:`Domain`.

        :param str domain_name: A unique domain name ending in
        '.sip.twilio.com'
        :param str friendly_name: A human-readable name for this domain.
        :param str voice_url: The URL Twilio will request when this domain
        receives a call.
        :param voice_method: The HTTP method Twilio should use to request
            voice_url.
        :type voice_method: None (defaults to 'POST'), 'GET', or 'POST'
        :param str voice_fallback_url: A URL that Twilio will request if an
            error occurs requesting or executing the TwiML at voice_url
        :param str voice_fallback_method: The HTTP method that Twilio should
            use to request the fallback_url
        :type voice_fallback_method: None (defaults to 'POST'),
            'GET', or 'POST'
        :param str voice_status_callback: A URL that Twilio will request when
            the call ends to notify your app.
        :param str voice_status_method: The HTTP method Twilio should use when
            requesting the above URL.

        """
        kwargs['domain_name'] = domain_name
        return self.create_instance(kwargs)

    def update(self, sid, **kwargs):
        """
        Update a :class:`Domain`

        Available attributes to update are described above in :meth:`create`.

        :param sid: String identifier for a Domain resource
        """
        return self.update_instance(sid, kwargs)

    def delete(self, sid):
        """
        Delete a :class:`Domain`.

        :param sid: String identifier for a Domain resource
        """
        return self.delete_instance(sid)

########NEW FILE########
__FILENAME__ = ip_access_control_lists
from .. import InstanceResource, ListResource


class IpAddress(InstanceResource):
    """ An IP address entry in an Access Control List.

    .. attribute:: sid

        A 34 character string that uniquely identifies this resource.

    .. attribute:: account_sid

        The unique id of the Account responsible for this IpAddress.

    .. attribute:: friendly_name

        A human-readable name for this IP address.

    .. attribute:: ip_address

        The IP address in dotted-decimal IPv4 notation.

    .. attribute:: date_created

        The date that this resource was created.

    .. attribute:: date_updated

        The date that this resource was last updated.

    """

    def update(self, **kwargs):
        """Update this address."""
        return self.parent.update_instance(self.name, **kwargs)

    def delete(self):
        """
        Delete this address.
        """
        return self.parent.delete_instance(self.name)


class IpAddresses(ListResource):
    name = "IpAddresses"
    key = "ip_addresses"
    instance = IpAddress

    def create(self, friendly_name, ip_address, **kwargs):
        """Add an IP address to a SipIpAccessControlList.

        :param str friendly_name: A human-readable name for this address.
        :param str ip_address: A dotted-decimal IPv4 address
        """
        kwargs['friendly_name'] = friendly_name
        kwargs['ip_address'] = ip_address
        return self.create_instance(kwargs)

    def update(self, sid, **kwargs):
        """Update an :class:`IpAddress`.

        :param sid: String identifier for an address
        """
        return self.update_instance(sid, kwargs)

    def delete(self, sid):
        """Remove an :class:`IpAddress` from a :class:`SipIpAccessControlList`.

        :param sid: String identifier for an address
        """
        return self.delete_instance(sid)


class SipIpAccessControlList(InstanceResource):
    """ A list of IP addresses for controlling access to a SIP Domain.

    .. attribute:: sid

        A 34 character string that uniquely identifies this resource.

    .. attribute:: account_sid

        The unique id of the Account responsible for this ACL.

    .. attribute:: friendly_name

        A human-readable name for this SipIpAccessControlList.

    .. attribute:: date_created

        The date that this resource was created.

    .. attribute:: date_updated

        The date that this resource was last updated.

    """
    subresources = [IpAddresses]

    def update(self, **kwargs):
        """Update this address."""
        return self.parent.update_instance(self.name, **kwargs)

    def delete(self):
        """
        Delete this address.
        """
        return self.parent.delete_instance(self.name)


class SipIpAccessControlLists(ListResource):
    name = "IpAccessControlLists"
    key = "ip_access_control_lists"
    instance = SipIpAccessControlList

    def create(self, friendly_name, **kwargs):
        """ Create a :class:`SipIpAccessControlList`.

        :param str friendly_name: A human-readable name for this ACL.
        """
        kwargs['friendly_name'] = friendly_name
        return self.create_instance(kwargs)

    def update(self, sid, **kwargs):
        """ Change the name of a :class:`SipIpAccessControlList`.

        :param str sid: String identifier for a SipIpAccessControlList resource

        :param str friendly_name: A human-readable name for the ACL.
        """
        return self.update_instance(sid, kwargs)

    def delete(self, sid):
        """
        Delete a :class:`SipIpAccessControlList`.

        :param sid: String identifier for a SipIpAccessControlList resource
        """
        return self.delete_instance(sid)

########NEW FILE########
__FILENAME__ = sms_messages
from .util import normalize_dates, parse_date
from . import InstanceResource, ListResource


class ShortCode(InstanceResource):

    def update(self, **kwargs):
        return self.parent.update(self.name, **kwargs)


class ShortCodes(ListResource):

    name = "ShortCodes"
    key = "short_codes"
    instance = ShortCode

    def list(self, **kwargs):
        """
        Returns a page of :class:`ShortCode` resources as a list. For
        paging information see :class:`ListResource`.

        :param short_code: Only show the ShortCode resources that match this
                           pattern. You can specify partial numbers and use '*'
                           as a wildcard for any digit.
        :param friendly_name: Only show the ShortCode resources with friendly
                              names that exactly match this name.
        """
        return self.get_instances(kwargs)

    def update(self, sid, url=None, method=None, fallback_url=None,
               fallback_method=None, **kwargs):
        """
        Update a specific :class:`ShortCode`, by specifying the sid.

        :param friendly_name: Description of the short code, with maximum
                              length 64 characters.
        :param api_version: SMSs to this short code will start a new TwiML
                            session with this API version.
        :param url: The URL that Twilio should request when somebody sends an
                    SMS to the short code.
        :param method: The HTTP method that should be used to request the url.
        :param fallback_url: A URL that Twilio will request if an error occurs
                             requesting or executing the TwiML at the url.
        :param fallback_method: The HTTP method that should be used to request
                                the fallback_url.
        """
        kwargs["sms_url"] = kwargs.get("sms_url", url)
        kwargs["sms_method"] = kwargs.get("sms_method", method)
        kwargs["sms_fallback_url"] = \
            kwargs.get("sms_fallback_url", fallback_url)
        kwargs["sms_fallback_method"] = \
            kwargs.get("sms_fallback_method", fallback_method)
        return self.update_instance(sid, kwargs)


class Sms(object):
    """
    Holds all the specific SMS list resources
    """

    name = "SMS"
    key = "sms"

    def __init__(self, base_uri, auth, timeout):
        self.uri = "%s/SMS" % base_uri
        self.messages = SmsMessages(self.uri, auth, timeout)
        self.short_codes = ShortCodes(self.uri, auth, timeout)


class SmsMessage(InstanceResource):
    """ An instance of an SMS Message

   .. attribute:: sid

      A 34 character string that uniquely identifies this resource.

   .. attribute:: date_created

      The date that this resource was created, given in RFC 2822 format.

   .. attribute:: date_updated

      The date that this resource was last updated, given in RFC 2822 format.

   .. attribute:: date_sent

      The date that the SMS was sent, given in RFC 2822 format.

   .. attribute:: account_sid

      The unique id of the Account that sent this SMS message.

   .. attribute:: from

      The phone number that initiated the message in E.164 format.
      For incoming messages, this will be the remote phone.
      For outgoing messages, this will be one of your Twilio phone numbers.

   .. attribute:: to

      The phone number that received the message in E.164 format.
      For incoming messages, this will be one of your Twilio phone numbers.
      For outgoing messages, this will be the remote phone.

   .. attribute:: body

      The text body of the SMS message.

   .. attribute:: status

      The status of this SMS message. Either queued, sending, sent, or failed.

   .. attribute:: direction

        The direction of this SMS message. ``incoming`` for incoming
        messages, ``outbound-api`` for messages initiated via the REST
        API, ``outbound-call`` for messages initiated during a call or
        ``outbound-reply`` for messages initiated in response to an incoming
        SMS.

   .. attribute:: price

      The amount billed for the message.

   .. attribute:: api_version

      The version of the Twilio API used to process the SMS message.

   .. attribute:: uri

      The URI for this resource, relative to https://api.twilio.com
    """

    pass


class SmsMessages(ListResource):

    name = "Messages"
    key = "sms_messages"
    instance = SmsMessage

    def create(self, from_=None, **kwargs):
        """
        Create and send a SMS Message.

        :param str to: The destination phone number.
        :param str `from_`: The phone number sending this message
            (must be a verified Twilio number)
        :param str body: The message you want to send,
            limited to 160 characters.
        :param status_callback: A URL that Twilio will POST to when
            your message is processed.
        :param str application_sid: The 34 character sid of the application
            Twilio should use to handle this phone call.

        Usage:

        .. code-block::python

            message = client.sms.messages.create(to="+12316851234",
                from_="+15555555555",
                body="Hello there!")

        """
        kwargs["from"] = from_
        return self.create_instance(kwargs)

    @normalize_dates
    def list(self, from_=None, before=None, after=None, date_sent=None, **kw):
        """
        Returns a page of :class:`~twilio.rest.resources.SmsMessage` resources
        as a list. For paging information see :class:`ListResource`.

        :param to: Only show SMS messages to this phone number.
        :param from_: Only show SMS messages from this phone number.
        :param date after: Only list SMS messages sent after this date.
        :param date before: Only list SMS message sent before this date.
        :param date date_sent: Only list SMS message sent on this date.
        :param `from_`: Only show SMS messages from this phone number.
        :param date after: Only list SMS messages logged after this datetime
        :param date before: Only list SMS messages logged before this datetime
        """
        kw["From"] = from_
        kw["DateSent<"] = before
        kw["DateSent>"] = after
        kw["DateSent"] = parse_date(date_sent)
        return self.get_instances(kw)

########NEW FILE########
__FILENAME__ = transcriptions
from . import InstanceResource, ListResource


class Transcription(InstanceResource):

    def delete(self):
        """
        Delete this transcription
        """
        return self.parent.delete(self.name)


class Transcriptions(ListResource):

    name = "Transcriptions"
    instance = Transcription

    def list(self, **kwargs):
        """
        Return a list of :class:`Transcription` resources
        """
        return self.get_instances(kwargs)

    def delete(self, sid):
        """
        Delete the given transcription
        """
        return self.delete_instance(sid)

########NEW FILE########
__FILENAME__ = usage
from . import InstanceResource, ListResource
from .util import UNSET_TIMEOUT


class UsageTrigger(InstanceResource):
    """ A usage trigger resource """

    def update(self, **kwargs):
        """
        Update this usage trigger
        """
        return self.parent.update(self.name, **kwargs)

    def delete(self):
        """
        Delete this usage trigger
        """
        return self.parent.delete(self.name)


class UsageTriggers(ListResource):
    name = "Usage/Triggers"
    instance = UsageTrigger
    key = "usage_triggers"

    def list(self, **kwargs):
        """
        Returns a page of :class:`UsageTrigger` resources as a list. For paging
        information see :class:`ListResource`

        :param recurring: Only show UsageTriggers that count over this
                          interval. One of daily, monthly, or yearly. To
                          retrieve non-recurring triggers, leave this empty or
                          use alltime.
        :param usage_category: Only show UsageTriggers that watch this usage
                               category. Must be one of the supported usage
                               categories.
        :trigger_by: Only show UsageTriggers that trigger by this field in the
                     UsageRecord. Must be one of: count, usage, or price as
                     described in the UsageRecords documentation.
        """
        return self.get_instances(kwargs)

    def create(self, **kwargs):
        """
        Create an :class:`UsageTrigger` with any of these optional parameters.

        :param friendly_name: A human readable description of the UsageTrigger,
                              with maximum length 64 characters.
        :param usage_category: The trigger will watch this usage category.
        :param trigger_value: The trigger will fire when usage reaches this
                              value.
        :param callback_url: Twilio will make a request to this url when the
                             trigger fires.
        :param trigger_by: The field in the UsageRecord that will fire the
                           trigger. One of count, usage, or price as described
                           in the UsageRecords documentation. The default is
                           usage.
        :param recurring: The interval the trigger will count over. Must be one
                          of: daily, monthly, or yearly. Omit this to create a
                          non-recurring trigger.
        :param callback_method: Twilio will use this HTTP method when making a
                                request to the CallbackUrl. GET or POST. The
                                default is POST.
        """
        return self.create_instance(kwargs)

    def update(self, sid, **kwargs):
        """ Update the UsageTrigger with the given sid to have the kwargs """
        return self.update_instance(sid, kwargs)

    def delete(self, sid):
        """
        Delete a :class:`UsageTrigger`
        """
        return self.delete_instance(sid)


class UsageRecord(InstanceResource):
    """ A usage record resource """

    def load(self, entries):
        uri = entries.get('uri')
        super(UsageRecord, self).load(entries)
        self.__dict__.update({'uri': uri})

    @property
    def uri(self):
        return self.__dict__.get('uri')


class BaseUsageRecords(ListResource):
    name = "Usage/Records"
    instance = UsageRecord
    key = "usage_records"

    def list(self, **kwargs):
        """
        Returns a page of :class:`UsageRecord` resources as a list. For paging
        information see :class:`ListResource`

        :param category: Only include usage of this usage category.
        :param start_date: Only include usage that has occurred on or after
                           this date. Format is YYYY-MM-DD. All dates are in
                           GMT.
        :param end_date: Only include usage that has occurred on or before this
                         date. Format is YYYY-MM-DD. All dates are in GMT.
        """
        return self.get_instances(kwargs)

    def get(self, *args, **kwargs):
        raise AttributeError('Unsupported in UsageRecords')

    def load_instance(self, data):
        instance = self.instance(self, "Resource")
        instance.load(data)
        instance.load_subresources()
        return instance


class UsageRecords(BaseUsageRecords):

    def __init__(self, base_uri, auth, timeout=UNSET_TIMEOUT):
        super(UsageRecords, self).__init__(base_uri, auth, timeout)
        self.daily = UsageRecordsDaily(base_uri, auth, timeout)
        self.monthly = UsageRecordsMonthly(base_uri, auth, timeout)
        self.yearly = UsageRecordsYearly(base_uri, auth, timeout)
        self.today = UsageRecordsToday(base_uri, auth, timeout)
        self.yesterday = UsageRecordsYesterday(base_uri, auth, timeout)
        self.this_month = UsageRecordsThisMonth(base_uri, auth, timeout)
        self.last_month = UsageRecordsLastMonth(base_uri, auth, timeout)


class UsageRecordsDaily(BaseUsageRecords):
    name = "Usage/Records/Daily"


class UsageRecordsMonthly(BaseUsageRecords):
    name = "Usage/Records/Monthly"


class UsageRecordsYearly(BaseUsageRecords):
    name = "Usage/Records/Yearly"


class UsageRecordsToday(BaseUsageRecords):
    name = "Usage/Records/Today"


class UsageRecordsYesterday(BaseUsageRecords):
    name = "Usage/Records/Yesterday"


class UsageRecordsThisMonth(BaseUsageRecords):
    name = "Usage/Records/ThisMonth"


class UsageRecordsLastMonth(BaseUsageRecords):
    name = "Usage/Records/LastMonth"

UsageRecord.subresources = [
    UsageRecordsDaily,
    UsageRecordsMonthly,
    UsageRecordsYearly,
    UsageRecordsToday,
    UsageRecordsYesterday,
    UsageRecordsThisMonth,
    UsageRecordsLastMonth
]


class Usage(object):
    """
    Holds all the specific Usage list resources
    """

    def __init__(self, base_uri, auth, timeout=UNSET_TIMEOUT):
        self.records = UsageRecords(base_uri, auth, timeout=timeout)
        self.triggers = UsageTriggers(base_uri, auth, timeout=timeout)
        self.timeout = timeout

########NEW FILE########
__FILENAME__ = util
import datetime
from email.utils import parsedate
from six import iteritems


def transform_params(parameters):
    """
    Transform parameters, throwing away any None values
    and convert False and True values to strings

    Ex:
    {"record": true, "date_created": "2012-01-02"}

    becomes:
    {"Record": "true", "DateCreated": "2012-01-02"}
    """
    transformed_parameters = {}

    for key, value in iteritems(parameters):
        if isinstance(value, (list, tuple, set)):
            value = [convert_boolean(param) for param in value]
            transformed_parameters[format_name(key)] = value
        elif value is not None:
            transformed_parameters[format_name(key)] = convert_boolean(value)

    return transformed_parameters


def format_name(word):
    if word.lower() == word:
        return convert_case(word)
    else:
        return word


def parse_date(d):
    """
    Return a string representation of a date that the Twilio API understands
    Format is YYYY-MM-DD. Returns None if d is not a string, datetime, or date
    """
    if isinstance(d, datetime.datetime):
        return str(d.date())
    elif isinstance(d, datetime.date):
        return str(d)
    elif isinstance(d, str):
        return d


def parse_rfc2822_date(s):
    """
    Parses an RFC 2822 date string and returns a time zone naive datetime
    object. All dates returned from Twilio are UTC.
    """
    date_tuple = parsedate(s)
    if date_tuple is None:
        return None
    return datetime.datetime(*date_tuple[:6])


def convert_boolean(boolean):
    if isinstance(boolean, bool):
        return 'true' if boolean else 'false'
    return boolean


def convert_case(s):
    """
    Given a string in snake case, convert to CamelCase

    Ex:
    date_created -> DateCreated
    """
    return ''.join([a.title() for a in s.split("_") if a])


def convert_keys(d):
    """
    Return a dictionary with all keys converted from arguments
    """
    special = {
        "started_before": "StartTime<",
        "started_after": "StartTime>",
        "started": "StartTime",
        "ended_before": "EndTime<",
        "ended_after": "EndTime>",
        "ended": "EndTime",
        "from_": "From",
    }

    result = {}

    for k, v in iteritems(d):
        if k in special:
            result[special[k]] = v
        else:
            result[convert_case(k)] = v

    return result


def normalize_dates(myfunc):
    def inner_func(*args, **kwargs):
        for k, v in iteritems(kwargs):
            res = [True for s in ["after", "before", "on"] if s in k]
            if len(res):
                kwargs[k] = parse_date(v)
        return myfunc(*args, **kwargs)
    inner_func.__doc__ = myfunc.__doc__
    inner_func.__repr__ = myfunc.__repr__
    return inner_func


def change_dict_key(d, from_key, to_key):
    """
    Changes a dictionary's key from from_key to to_key.
    No-op if the key does not exist.

    :param d: Dictionary with key to change
    :param from_key: Old key
    :param to_key: New key
    :return: None
    """
    try:
        d[to_key] = d.pop(from_key)
    except KeyError:
        pass


class _UnsetTimeoutKls(object):
    """ A sentinel for an unset timeout. Defaults to the system timeout. """
    def __repr__(self):
        return '<Unset Timeout Value>'


# None has special meaning for timeouts, so we use this sigil to indicate
# that we don't care
UNSET_TIMEOUT = _UnsetTimeoutKls()

########NEW FILE########
__FILENAME__ = twiml
"""
Make sure to check out the TwiML overview and tutorial
"""
import xml.etree.ElementTree as ET


class TwimlException(Exception):
    pass


class Verb(object):
    """Twilio basic verb object.
    """
    GET = "GET"
    POST = "POST"
    nestables = None

    def __init__(self, **kwargs):
        self.name = self.__class__.__name__
        self.body = None
        self.verbs = []
        self.attrs = {}

        if kwargs.get("waitMethod", "GET") not in ["GET", "POST"]:
            raise TwimlException("Invalid waitMethod parameter, "
                                 "must be 'GET' or 'POST'")

        if kwargs.get("method", "GET") not in ["GET", "POST"]:
            raise TwimlException("Invalid method parameter, "
                                 "must be 'GET' or 'POST'")

        for k, v in kwargs.items():
            if k == "sender":
                k = "from"
            if v is not None:
                self.attrs[k] = v

    def __str__(self):
        return self.toxml()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        return False

    def toxml(self, xml_declaration=True):
        """
        Return the contents of this verb as an XML string

        :param bool xml_declaration: Include the XML declaration. Defaults to
                                     True
        """
        xml = ET.tostring(self.xml()).decode('utf-8')

        if xml_declaration:
            return '<?xml version="1.0" encoding="UTF-8"?>' + xml
        else:
            return xml

    def xml(self):
        el = ET.Element(self.name)

        keys = self.attrs.keys()
        keys = sorted(keys)
        for a in keys:
            value = self.attrs[a]

            if isinstance(value, bool):
                el.set(a, str(value).lower())
            else:
                el.set(a, str(value))

        if self.body:
            el.text = self.body

        for verb in self.verbs:
            el.append(verb.xml())

        return el

    def append(self, verb):
        if not self.nestables or verb.name not in self.nestables:
            raise TwimlException("%s is not nestable inside %s" %
                                 (verb.name, self.name))
        self.verbs.append(verb)
        return verb


class Response(Verb):
    """Twilio response object."""
    nestables = [
        'Say',
        'Play',
        'Gather',
        'Record',
        'Dial',
        'Redirect',
        'Pause',
        'Hangup',
        'Reject',
        'Sms',
        'Enqueue',
        'Leave',
        'Message',
    ]

    def __init__(self, **kwargs):
        """Version: Twilio API version e.g. 2008-08-01 """
        super(Response, self).__init__(**kwargs)

    def say(self, text, **kwargs):
        """Return a newly created :class:`Say` verb, nested inside this
        :class:`Response` """
        return self.append(Say(text, **kwargs))

    def play(self, url=None, digits=None, **kwargs):
        """Return a newly created :class:`Play` verb, nested inside this
        :class:`Response` """
        return self.append(Play(url=url, digits=digits, **kwargs))

    def pause(self, **kwargs):
        """Return a newly created :class:`Pause` verb, nested inside this
        :class:`Response` """
        return self.append(Pause(**kwargs))

    def redirect(self, url=None, **kwargs):
        """Return a newly created :class:`Redirect` verb, nested inside this
        :class:`Response` """
        return self.append(Redirect(url, **kwargs))

    def hangup(self, **kwargs):
        """Return a newly created :class:`Hangup` verb, nested inside this
        :class:`Response` """
        return self.append(Hangup(**kwargs))

    def reject(self, reason=None, **kwargs):
        """Return a newly created :class:`Hangup` verb, nested inside this
        :class:`Response` """
        return self.append(Reject(reason=reason, **kwargs))

    def gather(self, **kwargs):
        """Return a newly created :class:`Gather` verb, nested inside this
        :class:`Response` """
        return self.append(Gather(**kwargs))

    def dial(self, number=None, **kwargs):
        """Return a newly created :class:`Dial` verb, nested inside this
        :class:`Response` """
        return self.append(Dial(number, **kwargs))

    def enqueue(self, name, **kwargs):
        """Return a newly created :class:`Enqueue` verb, nested inside this
        :class:`Response` """
        return self.append(Enqueue(name, **kwargs))

    def leave(self, **kwargs):
        """Return a newly created :class:`Leave` verb, nested inside this
        :class:`Response` """
        return self.append(Leave(**kwargs))

    def record(self, **kwargs):
        """Return a newly created :class:`Record` verb, nested inside this
        :class:`Response` """
        return self.append(Record(**kwargs))

    def sms(self, msg, **kwargs):
        """Return a newly created :class:`Sms` verb, nested inside this
        :class:`Response` """
        return self.append(Sms(msg, **kwargs))

    def message(self, msg=None, **kwargs):
        """Return a newly created :class:`Message` verb, nested inside this
        :class:`Response`"""
        return self.append(Message(msg, **kwargs))

    # All add* methods are deprecated
    def addSay(self, *args, **kwargs):
        return self.say(*args, **kwargs)

    def addPlay(self, *args, **kwargs):
        return self.play(*args, **kwargs)

    def addPause(self, *args, **kwargs):
        return self.pause(*args, **kwargs)

    def addRedirect(self, *args, **kwargs):
        return self.redirect(*args, **kwargs)

    def addHangup(self, *args, **kwargs):
        return self.hangup(*args, **kwargs)

    def addReject(self, *args, **kwargs):
        return self.reject(*args, **kwargs)

    def addGather(self, *args, **kwargs):
        return self.gather(*args, **kwargs)

    def addDial(self, *args, **kwargs):
        return self.dial(*args, **kwargs)

    def addRecord(self, *args, **kwargs):
        return self.record(*args, **kwargs)

    def addSms(self, *args, **kwargs):
        return self.sms(*args, **kwargs)


class Say(Verb):
    """The :class:`Say` verb converts text to speech that is read back to the
    caller.

    :param voice: allows you to choose a male or female voice to read text
                  back.

    :param language: allows you pick a voice with a specific language's accent
                     and pronunciations. Twilio currently supports languages
                     'en' (English), 'es' (Spanish), 'fr' (French), and 'de'
                     (German), 'en-gb' (English Great Britain").

    :param loop: specifies how many times you'd like the text repeated.
                 Specifying '0' will cause the the :class:`Say` verb to loop
                 until the call is hung up. Defaults to 1.
    """
    MAN = 'man'
    WOMAN = 'woman'

    ENGLISH = 'en'
    BRITISH = 'en-gb'
    SPANISH = 'es'
    FRENCH = 'fr'
    GERMAN = 'de'

    def __init__(self, text, **kwargs):
        super(Say, self).__init__(**kwargs)
        self.body = text


class Play(Verb):
    """Play DTMF digits or audio from a URL.

    :param str url: point to an audio file. The MIME type on the file must be
                    set correctly. At least one of `url` and `digits` must be
                    specified. If both are given, the digits will play prior
                    to the audio from the URL.

    :param str digits: a string of digits to play. To pause before playing
                   digits, use leading 'w' characters. Each 'w' will cause
                   Twilio to wait 0.5 seconds instead of playing a digit.
                   At least one of `url` and `digits` must be specified.
                   If both are given, the digits will play first.

    :param int loop: specifies how many times you'd like the text repeated.
                 Specifying '0' will cause the the :class:`Play` verb to loop
                 until the call is hung up. Defaults to 1.
    """
    def __init__(self, url=None, digits=None, **kwargs):
        if url is None and digits is None:
            raise TwimlException(
                "Please specify either a url or digits to play.",
            )

        if digits is not None:
            kwargs['digits'] = digits
        super(Play, self).__init__(**kwargs)
        if url is not None:
            self.body = url


class Pause(Verb):
    """Pause the call

    :param length: specifies how many seconds Twilio will wait silently before
                   continuing on.
    """


class Redirect(Verb):
    """Redirect call flow to another URL

    :param url: specifies the url which Twilio should query to retrieve new
                TwiML. The default is the current url

    :param method: specifies the HTTP method to use when retrieving the url
    """
    GET = 'GET'
    POST = 'POST'

    def __init__(self, url="", **kwargs):
        super(Redirect, self).__init__(**kwargs)
        self.body = url


class Hangup(Verb):
    """Hangup the call
    """


class Reject(Verb):
    """Hangup the call

    :param reason: not sure
    """


class Gather(Verb):
    """Gather digits from the caller's keypad

    :param action: URL to which the digits entered will be sent
    :param method: submit to 'action' url using GET or POST
    :param numDigits: how many digits to gather before returning
    :param timeout: wait for this many seconds before returning
    :param finishOnKey: key that triggers the end of caller input
    """
    GET = 'GET'
    POST = 'POST'
    nestables = ['Say', 'Play', 'Pause']

    def __init__(self, **kwargs):
        super(Gather, self).__init__(**kwargs)

    def say(self, text, **kwargs):
        return self.append(Say(text, **kwargs))

    def play(self, url, **kwargs):
        return self.append(Play(url, **kwargs))

    def pause(self, **kwargs):
        return self.append(Pause(**kwargs))

    def addSay(self, *args, **kwargs):
        return self.say(*args, **kwargs)

    def addPlay(self, *args, **kwargs):
        return self.play(*args, **kwargs)

    def addPause(self, *args, **kwargs):
        return self.pause(*args, **kwargs)


class Number(Verb):
    """Specify phone number in a nested Dial element.

    :param number: phone number to dial
    :param sendDigits: key to press after connecting to the number
    """
    def __init__(self, number, **kwargs):
        super(Number, self).__init__(**kwargs)
        self.body = number


class Client(Verb):
    """Specify a client name to call in a nested Dial element.

    :param name: Client name to connect to
    """
    def __init__(self, name, **kwargs):
        super(Client, self).__init__(**kwargs)
        self.body = name


class Sms(Verb):
    """ Send a Sms Message to a phone number

    :param to: whom to send message to
    :param sender: whom to send message from.
    :param action: url to request after the message is queued
    :param method: submit to 'action' url using GET or POST
    :param statusCallback: url to hit when the message is actually sent
    """
    GET = 'GET'
    POST = 'POST'

    def __init__(self, msg, **kwargs):
        super(Sms, self).__init__(**kwargs)
        self.body = msg


class Message(Verb):
    """ Send an MMS Message to a phone number.

    :param to: whom to send message to
    :param sender: whom to send message from.
    :param action: url to request after the message is queued
    :param method: submit to 'action' url using GET or POST
    :param statusCallback: url to hit when the message is actually sent
    """

    GET = 'GET'
    POST = 'POST'

    nestables = ['Media', 'Body']

    def __init__(self, msg=None, **kwargs):
        super(Message, self).__init__(**kwargs)
        if msg is not None:
            self.append(Body(msg))

    def media(self, media_url, **kwargs):
        return self.append(Media(media_url, **kwargs))


class Body(Verb):
    """ Specify a text body for a Message.

    :param msg: the text to use in the body.
    """

    GET = 'GET'
    POST = 'POST'

    def __init__(self, msg, **kwargs):
        super(Body, self).__init__(**kwargs)
        self.body = msg


class Media(Verb):
    """Specify media to include in a Message.

    :param url: The URL of the media to include.
    """

    GET = 'GET'
    POST = 'POST'

    def __init__(self, url, **kwargs):
        super(Media, self).__init__(**kwargs)
        self.body = url


class Conference(Verb):
    """Specify conference in a nested Dial element.

    :param name: friendly name of conference
    :param bool muted: keep this participant muted
    :param bool beep: play a beep when this participant enters/leaves
    :param bool startConferenceOnEnter: start conf when this participants joins
    :param bool endConferenceOnExit: end conf when this participants leaves
    :param waitUrl: TwiML url that executes before conference starts
    :param waitMethod: HTTP method for waitUrl GET/POST
    """
    GET = 'GET'
    POST = 'POST'

    def __init__(self, name, **kwargs):
        super(Conference, self).__init__(**kwargs)
        self.body = name


class Dial(Verb):
    """Dial another phone number and connect it to this call

    :param action: submit the result of the dial to this URL
    :param method: submit to 'action' url using GET or POST
    :param int timeout: The number of seconds to waits for the called
                         party to answer the call
    :param bool hangupOnStar: Allow the calling party to hang up on the
                              called party by pressing the '*' key
    :param int timeLimit: The maximum duration of the Call in seconds
    :param callerId: The caller ID that will appear to the called party
    :param bool record: Record both legs of a call within this <Dial>
    """
    GET = 'GET'
    POST = 'POST'
    nestables = ['Number', 'Conference', 'Client', 'Queue', 'Sip']

    def __init__(self, number=None, **kwargs):
        super(Dial, self).__init__(**kwargs)
        if number and len(number.split(',')) > 1:
            for n in number.split(','):
                self.append(Number(n.strip()))
        else:
            self.body = number

    def client(self, name, **kwargs):
        return self.append(Client(name, **kwargs))

    def number(self, number, **kwargs):
        return self.append(Number(number, **kwargs))

    def conference(self, name, **kwargs):
        return self.append(Conference(name, **kwargs))

    def queue(self, name, **kwargs):
        return self.append(Queue(name, **kwargs))

    def sip(self, sip_address=None, **kwargs):
        return self.append(Sip(sip_address, **kwargs))

    def addNumber(self, *args, **kwargs):
        return self.number(*args, **kwargs)

    def addConference(self, *args, **kwargs):
        return self.conference(*args, **kwargs)


class Queue(Verb):
    """Specify queue in a nested Dial element.

    :param name: friendly name for the queue
    :param url: url to a twiml document that executes after a call is dequeued
                and before the call is connected
    :param method: HTTP method for url GET/POST
    """
    GET = 'GET'
    POST = 'POST'

    def __init__(self, name, **kwargs):
        super(Queue, self).__init__(**kwargs)
        self.body = name


class Enqueue(Verb):
    """Enqueue the call into a specific queue.

    :param name: friendly name for the queue
    :param action: url to a twiml document that executes when the call
                   leaves the queue. When dequeued via a <Dial> verb,
                   this url is executed after the bridged parties disconnect
    :param method: HTTP method for action GET/POST
    :param waitUrl: url to a twiml document that executes
                     while the call is on the queue
    :param waitUrlMethod: HTTP method for waitUrl GET/POST
    """
    GET = 'GET'
    POST = 'POST'

    def __init__(self, name, **kwargs):
        super(Enqueue, self).__init__(**kwargs)
        self.body = name


class Leave(Verb):
    """Signals the call to leave its queue
    """
    GET = 'GET'
    POST = 'POST'


class Record(Verb):
    """Record audio from caller

    :param action: submit the result of the dial to this URL
    :param method: submit to 'action' url using GET or POST
    :param maxLength: maximum number of seconds to record
    :param timeout: seconds of silence before considering the recording done
    """
    GET = 'GET'
    POST = 'POST'


class Sip(Verb):
    """Dial out to a SIP endpoint

    :param url: call screening URL none
    :param method: call screening method POST
    :param username: Username for SIP authentication
    :param password: Password for SIP authentication
    """
    nestables = ['Headers', 'Uri']

    def __init__(self, sip_address=None, **kwargs):
        super(Sip, self).__init__(**kwargs)
        if sip_address:
            self.body = sip_address

    def uri(self, uri, **kwargs):
        return self.append(Uri(uri, **kwargs))


class Uri(Verb):
    """A uniform resource indentifier"""
    def __init__(self, uri, **kwargs):
        super(Uri, self).__init__(**kwargs)
        self.body = uri

########NEW FILE########
__FILENAME__ = util
import base64
import hmac
import time
from hashlib import sha1

from . import jwt
from .compat import izip, urlencode
from six import iteritems


class RequestValidator(object):

    def __init__(self, token):
        self.token = token.encode("utf-8")

    def compute_signature(self, uri, params):
        """Compute the signature for a given request

        :param uri: full URI that Twilio requested on your server
        :param params: post vars that Twilio sent with the request
        :param auth: tuple with (account_sid, token)

        :returns: The computed signature
        """
        s = uri
        if len(params) > 0:
            for k, v in sorted(params.items()):
                s += k + v

        # compute signature and compare signatures
        mac = hmac.new(self.token, s.encode("utf-8"), sha1)
        computed = base64.b64encode(mac.digest())

        return computed.strip()

    def validate(self, uri, params, signature):
        """Validate a request from Twilio

        :param uri: full URI that Twilio requested on your server
        :param params: post vars that Twilio sent with the request
        :param signature: expexcted signature in HTTP X-Twilio-Signature header
        :param auth: tuple with (account_sid, token)

        :returns: True if the request passes validation, False if not
        """
        return secure_compare(self.compute_signature(uri, params), signature)


def secure_compare(string1, string2):
    """Compare two strings while protecting against timing attacks

    :param str string1: the first string
    :param str string2: the second string

    :returns: True if the strings are equal, False if not
    :rtype: :obj:`bool`
    """
    if len(string1) != len(string2):
        return False
    result = True
    for c1, c2 in izip(string1, string2):
        result &= c1 == c2
    return result


class TwilioCapability(object):
    """
    A token to control permissions with Twilio Client

    :param str account_sid: the account sid to which this token
                               is granted access
    :param str auth_token: the secret key used to sign the token.
                              Note, this auth token is not visible to the
                              user of the token.

    :returns: A new TwilioCapability with zero permissions
    """

    def __init__(self, account_sid, auth_token):
        self.account_sid = account_sid
        self.auth_token = auth_token
        self.capabilities = {}
        self.client_name = None

    def payload(self):
        """Return the payload for this token."""
        if "outgoing" in self.capabilities and self.client_name is not None:
            scope = self.capabilities["outgoing"]
            scope.params["clientName"] = self.client_name

        capabilities = self.capabilities.values()
        scope_uris = [str(scope_uri) for scope_uri in capabilities]

        return {
            "scope": " ".join(scope_uris)
        }

    def generate(self, expires=3600):
        """Generate a valid JWT token with an expiration date.

        :param int expires: The token lifetime, in seconds. Defaults to
                            1 hour (3600)

        """
        payload = self.payload()
        payload['iss'] = self.account_sid
        payload['exp'] = int(time.time() + expires)
        return jwt.encode(payload, self.auth_token)

    def allow_client_outgoing(self, application_sid, **kwargs):
        """Allow the user of this token to make outgoing connections.

        Keyword arguments are passed to the application.

        :param str application_sid: Application to contact
        """
        scope_params = {
            "appSid": application_sid,
        }
        if kwargs:
            scope_params["appParams"] = urlencode(kwargs, doseq=True)

        self.capabilities["outgoing"] = ScopeURI("client", "outgoing",
                                                 scope_params)

    def allow_client_incoming(self, client_name):
        """If the user of this token should be allowed to accept incoming
        connections then configure the TwilioCapability through this method and
        specify the client name.

        :param str client_name: Client name to accept calls from

        """
        self.client_name = client_name
        self.capabilities["incoming"] = ScopeURI("client", "incoming", {
            'clientName': client_name
        })

    def allow_event_stream(self, **kwargs):
        """Allow the user of this token to access their event stream."""
        scope_params = {
            "path": "/2010-04-01/Events",
        }
        if kwargs:
            scope_params['params'] = urlencode(kwargs, doseq=True)

        self.capabilities["events"] = ScopeURI("stream", "subscribe",
                                               scope_params)


class ScopeURI(object):

    def __init__(self, service, privilege, params=None):
        self.service = service
        self.privilege = privilege
        self.params = params

    def __str__(self):
        if self.params:
            sorted_params = sorted([(k, v) for k, v in iteritems(self.params)])
            encoded_params = urlencode(sorted_params)
            param_string = '?%s' % encoded_params
        else:
            param_string = ''
        return "scope:%s:%s%s" % (self.service, self.privilege, param_string)

########NEW FILE########
__FILENAME__ = version
__version_info__ = ('3', '6', '6')
__version__ = '.'.join(__version_info__)

########NEW FILE########
